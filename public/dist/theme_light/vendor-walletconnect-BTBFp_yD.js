import { g as getDefaultExportFromCjs, d as getAugmentedNamespace, e as commonjsGlobal, p as process$1 } from "./vendor-react-DSEtE0wE.js";
const global = globalThis || void 0 || self;
var buffer$1 = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len = code.length; i$2 < len; ++i$2)
  lookup[i$2] = code[i$2], revLookup[code.charCodeAt(i$2)] = i$2;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(Ae) {
  var t = Ae.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var Ie = Ae.indexOf("=");
  Ie === -1 && (Ie = t);
  var Me = Ie === t ? 0 : 4 - Ie % 4;
  return [Ie, Me];
}
function byteLength(Ae) {
  var t = getLens(Ae), Ie = t[0], Me = t[1];
  return (Ie + Me) * 3 / 4 - Me;
}
function _byteLength(Ae, t, Ie) {
  return (t + Ie) * 3 / 4 - Ie;
}
function toByteArray(Ae) {
  var t, Ie = getLens(Ae), Me = Ie[0], Be = Ie[1], Pe = new Arr(_byteLength(Ae, Me, Be)), Te = 0, je = Be > 0 ? Me - 4 : Me, Ve;
  for (Ve = 0; Ve < je; Ve += 4)
    t = revLookup[Ae.charCodeAt(Ve)] << 18 | revLookup[Ae.charCodeAt(Ve + 1)] << 12 | revLookup[Ae.charCodeAt(Ve + 2)] << 6 | revLookup[Ae.charCodeAt(Ve + 3)], Pe[Te++] = t >> 16 & 255, Pe[Te++] = t >> 8 & 255, Pe[Te++] = t & 255;
  return Be === 2 && (t = revLookup[Ae.charCodeAt(Ve)] << 2 | revLookup[Ae.charCodeAt(Ve + 1)] >> 4, Pe[Te++] = t & 255), Be === 1 && (t = revLookup[Ae.charCodeAt(Ve)] << 10 | revLookup[Ae.charCodeAt(Ve + 1)] << 4 | revLookup[Ae.charCodeAt(Ve + 2)] >> 2, Pe[Te++] = t >> 8 & 255, Pe[Te++] = t & 255), Pe;
}
function tripletToBase64(Ae) {
  return lookup[Ae >> 18 & 63] + lookup[Ae >> 12 & 63] + lookup[Ae >> 6 & 63] + lookup[Ae & 63];
}
function encodeChunk(Ae, t, Ie) {
  for (var Me, Be = [], Pe = t; Pe < Ie; Pe += 3)
    Me = (Ae[Pe] << 16 & 16711680) + (Ae[Pe + 1] << 8 & 65280) + (Ae[Pe + 2] & 255), Be.push(tripletToBase64(Me));
  return Be.join("");
}
function fromByteArray(Ae) {
  for (var t, Ie = Ae.length, Me = Ie % 3, Be = [], Pe = 16383, Te = 0, je = Ie - Me; Te < je; Te += Pe)
    Be.push(encodeChunk(Ae, Te, Te + Pe > je ? je : Te + Pe));
  return Me === 1 ? (t = Ae[Ie - 1], Be.push(
    lookup[t >> 2] + lookup[t << 4 & 63] + "=="
  )) : Me === 2 && (t = (Ae[Ie - 2] << 8) + Ae[Ie - 1], Be.push(
    lookup[t >> 10] + lookup[t >> 4 & 63] + lookup[t << 2 & 63] + "="
  )), Be.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(Ae, t, Ie, Me, Be) {
  var Pe, Te, je = Be * 8 - Me - 1, Ve = (1 << je) - 1, fi = Ve >> 1, Ue = -7, bi = Ie ? Be - 1 : 0, vi = Ie ? -1 : 1, mi = Ae[t + bi];
  for (bi += vi, Pe = mi & (1 << -Ue) - 1, mi >>= -Ue, Ue += je; Ue > 0; Pe = Pe * 256 + Ae[t + bi], bi += vi, Ue -= 8)
    ;
  for (Te = Pe & (1 << -Ue) - 1, Pe >>= -Ue, Ue += Me; Ue > 0; Te = Te * 256 + Ae[t + bi], bi += vi, Ue -= 8)
    ;
  if (Pe === 0)
    Pe = 1 - fi;
  else {
    if (Pe === Ve)
      return Te ? NaN : (mi ? -1 : 1) * (1 / 0);
    Te = Te + Math.pow(2, Me), Pe = Pe - fi;
  }
  return (mi ? -1 : 1) * Te * Math.pow(2, Pe - Me);
};
ieee754.write = function(Ae, t, Ie, Me, Be, Pe) {
  var Te, je, Ve, fi = Pe * 8 - Be - 1, Ue = (1 << fi) - 1, bi = Ue >> 1, vi = Be === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, mi = Me ? 0 : Pe - 1, _i = Me ? 1 : -1, Ei = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (je = isNaN(t) ? 1 : 0, Te = Ue) : (Te = Math.floor(Math.log(t) / Math.LN2), t * (Ve = Math.pow(2, -Te)) < 1 && (Te--, Ve *= 2), Te + bi >= 1 ? t += vi / Ve : t += vi * Math.pow(2, 1 - bi), t * Ve >= 2 && (Te++, Ve /= 2), Te + bi >= Ue ? (je = 0, Te = Ue) : Te + bi >= 1 ? (je = (t * Ve - 1) * Math.pow(2, Be), Te = Te + bi) : (je = t * Math.pow(2, bi - 1) * Math.pow(2, Be), Te = 0)); Be >= 8; Ae[Ie + mi] = je & 255, mi += _i, je /= 256, Be -= 8)
    ;
  for (Te = Te << Be | je, fi += Be; fi > 0; Ae[Ie + mi] = Te & 255, mi += _i, Te /= 256, fi -= 8)
    ;
  Ae[Ie + mi - _i] |= Ei * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(Ae) {
  const t = base64Js, Ie = ieee754, Me = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  Ae.Buffer = Ue, Ae.SlowBuffer = Xi, Ae.INSPECT_MAX_BYTES = 50;
  const Be = 2147483647;
  Ae.kMaxLength = Be;
  const { Uint8Array: Pe, ArrayBuffer: Te, SharedArrayBuffer: je } = globalThis;
  Ue.TYPED_ARRAY_SUPPORT = Ve(), !Ue.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function Ve() {
    try {
      const Zi = new Pe(1), Ui = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(Ui, Pe.prototype), Object.setPrototypeOf(Zi, Ui), Zi.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(Ue.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (Ue.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(Ue.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (Ue.isBuffer(this))
        return this.byteOffset;
    }
  });
  function fi(Zi) {
    if (Zi > Be)
      throw new RangeError('The value "' + Zi + '" is invalid for option "size"');
    const Ui = new Pe(Zi);
    return Object.setPrototypeOf(Ui, Ue.prototype), Ui;
  }
  function Ue(Zi, Ui, Ki) {
    if (typeof Zi == "number") {
      if (typeof Ui == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return _i(Zi);
    }
    return bi(Zi, Ui, Ki);
  }
  Ue.poolSize = 8192;
  function bi(Zi, Ui, Ki) {
    if (typeof Zi == "string")
      return Ei(Zi, Ui);
    if (Te.isView(Zi))
      return Ii(Zi);
    if (Zi == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Zi
      );
    if (ra(Zi, Te) || Zi && ra(Zi.buffer, Te) || typeof je < "u" && (ra(Zi, je) || Zi && ra(Zi.buffer, je)))
      return Ci(Zi, Ui, Ki);
    if (typeof Zi == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const En = Zi.valueOf && Zi.valueOf();
    if (En != null && En !== Zi)
      return Ue.from(En, Ui, Ki);
    const ss = Wi(Zi);
    if (ss) return ss;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Zi[Symbol.toPrimitive] == "function")
      return Ue.from(Zi[Symbol.toPrimitive]("string"), Ui, Ki);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Zi
    );
  }
  Ue.from = function(Zi, Ui, Ki) {
    return bi(Zi, Ui, Ki);
  }, Object.setPrototypeOf(Ue.prototype, Pe.prototype), Object.setPrototypeOf(Ue, Pe);
  function vi(Zi) {
    if (typeof Zi != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Zi < 0)
      throw new RangeError('The value "' + Zi + '" is invalid for option "size"');
  }
  function mi(Zi, Ui, Ki) {
    return vi(Zi), Zi <= 0 ? fi(Zi) : Ui !== void 0 ? typeof Ki == "string" ? fi(Zi).fill(Ui, Ki) : fi(Zi).fill(Ui) : fi(Zi);
  }
  Ue.alloc = function(Zi, Ui, Ki) {
    return mi(Zi, Ui, Ki);
  };
  function _i(Zi) {
    return vi(Zi), fi(Zi < 0 ? 0 : zi(Zi) | 0);
  }
  Ue.allocUnsafe = function(Zi) {
    return _i(Zi);
  }, Ue.allocUnsafeSlow = function(Zi) {
    return _i(Zi);
  };
  function Ei(Zi, Ui) {
    if ((typeof Ui != "string" || Ui === "") && (Ui = "utf8"), !Ue.isEncoding(Ui))
      throw new TypeError("Unknown encoding: " + Ui);
    const Ki = Qi(Zi, Ui) | 0;
    let En = fi(Ki);
    const ss = En.write(Zi, Ui);
    return ss !== Ki && (En = En.slice(0, ss)), En;
  }
  function Pi(Zi) {
    const Ui = Zi.length < 0 ? 0 : zi(Zi.length) | 0, Ki = fi(Ui);
    for (let En = 0; En < Ui; En += 1)
      Ki[En] = Zi[En] & 255;
    return Ki;
  }
  function Ii(Zi) {
    if (ra(Zi, Pe)) {
      const Ui = new Pe(Zi);
      return Ci(Ui.buffer, Ui.byteOffset, Ui.byteLength);
    }
    return Pi(Zi);
  }
  function Ci(Zi, Ui, Ki) {
    if (Ui < 0 || Zi.byteLength < Ui)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Zi.byteLength < Ui + (Ki || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let En;
    return Ui === void 0 && Ki === void 0 ? En = new Pe(Zi) : Ki === void 0 ? En = new Pe(Zi, Ui) : En = new Pe(Zi, Ui, Ki), Object.setPrototypeOf(En, Ue.prototype), En;
  }
  function Wi(Zi) {
    if (Ue.isBuffer(Zi)) {
      const Ui = zi(Zi.length) | 0, Ki = fi(Ui);
      return Ki.length === 0 || Zi.copy(Ki, 0, 0, Ui), Ki;
    }
    if (Zi.length !== void 0)
      return typeof Zi.length != "number" || ca(Zi.length) ? fi(0) : Pi(Zi);
    if (Zi.type === "Buffer" && Array.isArray(Zi.data))
      return Pi(Zi.data);
  }
  function zi(Zi) {
    if (Zi >= Be)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Be.toString(16) + " bytes");
    return Zi | 0;
  }
  function Xi(Zi) {
    return +Zi != Zi && (Zi = 0), Ue.alloc(+Zi);
  }
  Ue.isBuffer = function(Ui) {
    return Ui != null && Ui._isBuffer === !0 && Ui !== Ue.prototype;
  }, Ue.compare = function(Ui, Ki) {
    if (ra(Ui, Pe) && (Ui = Ue.from(Ui, Ui.offset, Ui.byteLength)), ra(Ki, Pe) && (Ki = Ue.from(Ki, Ki.offset, Ki.byteLength)), !Ue.isBuffer(Ui) || !Ue.isBuffer(Ki))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (Ui === Ki) return 0;
    let En = Ui.length, ss = Ki.length;
    for (let as = 0, us = Math.min(En, ss); as < us; ++as)
      if (Ui[as] !== Ki[as]) {
        En = Ui[as], ss = Ki[as];
        break;
      }
    return En < ss ? -1 : ss < En ? 1 : 0;
  }, Ue.isEncoding = function(Ui) {
    switch (String(Ui).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, Ue.concat = function(Ui, Ki) {
    if (!Array.isArray(Ui))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (Ui.length === 0)
      return Ue.alloc(0);
    let En;
    if (Ki === void 0)
      for (Ki = 0, En = 0; En < Ui.length; ++En)
        Ki += Ui[En].length;
    const ss = Ue.allocUnsafe(Ki);
    let as = 0;
    for (En = 0; En < Ui.length; ++En) {
      let us = Ui[En];
      if (ra(us, Pe))
        as + us.length > ss.length ? (Ue.isBuffer(us) || (us = Ue.from(us)), us.copy(ss, as)) : Pe.prototype.set.call(
          ss,
          us,
          as
        );
      else if (Ue.isBuffer(us))
        us.copy(ss, as);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      as += us.length;
    }
    return ss;
  };
  function Qi(Zi, Ui) {
    if (Ue.isBuffer(Zi))
      return Zi.length;
    if (Te.isView(Zi) || ra(Zi, Te))
      return Zi.byteLength;
    if (typeof Zi != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Zi
      );
    const Ki = Zi.length, En = arguments.length > 2 && arguments[2] === !0;
    if (!En && Ki === 0) return 0;
    let ss = !1;
    for (; ; )
      switch (Ui) {
        case "ascii":
        case "latin1":
        case "binary":
          return Ki;
        case "utf8":
        case "utf-8":
          return fa(Zi).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ki * 2;
        case "hex":
          return Ki >>> 1;
        case "base64":
          return aa(Zi).length;
        default:
          if (ss)
            return En ? -1 : fa(Zi).length;
          Ui = ("" + Ui).toLowerCase(), ss = !0;
      }
  }
  Ue.byteLength = Qi;
  function Oi(Zi, Ui, Ki) {
    let En = !1;
    if ((Ui === void 0 || Ui < 0) && (Ui = 0), Ui > this.length || ((Ki === void 0 || Ki > this.length) && (Ki = this.length), Ki <= 0) || (Ki >>>= 0, Ui >>>= 0, Ki <= Ui))
      return "";
    for (Zi || (Zi = "utf8"); ; )
      switch (Zi) {
        case "hex":
          return Si(this, Ui, Ki);
        case "utf8":
        case "utf-8":
          return qi(this, Ui, Ki);
        case "ascii":
          return xi(this, Ui, Ki);
        case "latin1":
        case "binary":
          return Fi(this, Ui, Ki);
        case "base64":
          return Li(this, Ui, Ki);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Vi(this, Ui, Ki);
        default:
          if (En) throw new TypeError("Unknown encoding: " + Zi);
          Zi = (Zi + "").toLowerCase(), En = !0;
      }
  }
  Ue.prototype._isBuffer = !0;
  function Yi(Zi, Ui, Ki) {
    const En = Zi[Ui];
    Zi[Ui] = Zi[Ki], Zi[Ki] = En;
  }
  Ue.prototype.swap16 = function() {
    const Ui = this.length;
    if (Ui % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let Ki = 0; Ki < Ui; Ki += 2)
      Yi(this, Ki, Ki + 1);
    return this;
  }, Ue.prototype.swap32 = function() {
    const Ui = this.length;
    if (Ui % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let Ki = 0; Ki < Ui; Ki += 4)
      Yi(this, Ki, Ki + 3), Yi(this, Ki + 1, Ki + 2);
    return this;
  }, Ue.prototype.swap64 = function() {
    const Ui = this.length;
    if (Ui % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let Ki = 0; Ki < Ui; Ki += 8)
      Yi(this, Ki, Ki + 7), Yi(this, Ki + 1, Ki + 6), Yi(this, Ki + 2, Ki + 5), Yi(this, Ki + 3, Ki + 4);
    return this;
  }, Ue.prototype.toString = function() {
    const Ui = this.length;
    return Ui === 0 ? "" : arguments.length === 0 ? qi(this, 0, Ui) : Oi.apply(this, arguments);
  }, Ue.prototype.toLocaleString = Ue.prototype.toString, Ue.prototype.equals = function(Ui) {
    if (!Ue.isBuffer(Ui)) throw new TypeError("Argument must be a Buffer");
    return this === Ui ? !0 : Ue.compare(this, Ui) === 0;
  }, Ue.prototype.inspect = function() {
    let Ui = "";
    const Ki = Ae.INSPECT_MAX_BYTES;
    return Ui = this.toString("hex", 0, Ki).replace(/(.{2})/g, "$1 ").trim(), this.length > Ki && (Ui += " ... "), "<Buffer " + Ui + ">";
  }, Me && (Ue.prototype[Me] = Ue.prototype.inspect), Ue.prototype.compare = function(Ui, Ki, En, ss, as) {
    if (ra(Ui, Pe) && (Ui = Ue.from(Ui, Ui.offset, Ui.byteLength)), !Ue.isBuffer(Ui))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Ui
      );
    if (Ki === void 0 && (Ki = 0), En === void 0 && (En = Ui ? Ui.length : 0), ss === void 0 && (ss = 0), as === void 0 && (as = this.length), Ki < 0 || En > Ui.length || ss < 0 || as > this.length)
      throw new RangeError("out of range index");
    if (ss >= as && Ki >= En)
      return 0;
    if (ss >= as)
      return -1;
    if (Ki >= En)
      return 1;
    if (Ki >>>= 0, En >>>= 0, ss >>>= 0, as >>>= 0, this === Ui) return 0;
    let us = as - ss, ua = En - Ki;
    const ma = Math.min(us, ua), na = this.slice(ss, as), wa = Ui.slice(Ki, En);
    for (let ga = 0; ga < ma; ++ga)
      if (na[ga] !== wa[ga]) {
        us = na[ga], ua = wa[ga];
        break;
      }
    return us < ua ? -1 : ua < us ? 1 : 0;
  };
  function ns(Zi, Ui, Ki, En, ss) {
    if (Zi.length === 0) return -1;
    if (typeof Ki == "string" ? (En = Ki, Ki = 0) : Ki > 2147483647 ? Ki = 2147483647 : Ki < -2147483648 && (Ki = -2147483648), Ki = +Ki, ca(Ki) && (Ki = ss ? 0 : Zi.length - 1), Ki < 0 && (Ki = Zi.length + Ki), Ki >= Zi.length) {
      if (ss) return -1;
      Ki = Zi.length - 1;
    } else if (Ki < 0)
      if (ss) Ki = 0;
      else return -1;
    if (typeof Ui == "string" && (Ui = Ue.from(Ui, En)), Ue.isBuffer(Ui))
      return Ui.length === 0 ? -1 : ls(Zi, Ui, Ki, En, ss);
    if (typeof Ui == "number")
      return Ui = Ui & 255, typeof Pe.prototype.indexOf == "function" ? ss ? Pe.prototype.indexOf.call(Zi, Ui, Ki) : Pe.prototype.lastIndexOf.call(Zi, Ui, Ki) : ls(Zi, [Ui], Ki, En, ss);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ls(Zi, Ui, Ki, En, ss) {
    let as = 1, us = Zi.length, ua = Ui.length;
    if (En !== void 0 && (En = String(En).toLowerCase(), En === "ucs2" || En === "ucs-2" || En === "utf16le" || En === "utf-16le")) {
      if (Zi.length < 2 || Ui.length < 2)
        return -1;
      as = 2, us /= 2, ua /= 2, Ki /= 2;
    }
    function ma(wa, ga) {
      return as === 1 ? wa[ga] : wa.readUInt16BE(ga * as);
    }
    let na;
    if (ss) {
      let wa = -1;
      for (na = Ki; na < us; na++)
        if (ma(Zi, na) === ma(Ui, wa === -1 ? 0 : na - wa)) {
          if (wa === -1 && (wa = na), na - wa + 1 === ua) return wa * as;
        } else
          wa !== -1 && (na -= na - wa), wa = -1;
    } else
      for (Ki + ua > us && (Ki = us - ua), na = Ki; na >= 0; na--) {
        let wa = !0;
        for (let ga = 0; ga < ua; ga++)
          if (ma(Zi, na + ga) !== ma(Ui, ga)) {
            wa = !1;
            break;
          }
        if (wa) return na;
      }
    return -1;
  }
  Ue.prototype.includes = function(Ui, Ki, En) {
    return this.indexOf(Ui, Ki, En) !== -1;
  }, Ue.prototype.indexOf = function(Ui, Ki, En) {
    return ns(this, Ui, Ki, En, !0);
  }, Ue.prototype.lastIndexOf = function(Ui, Ki, En) {
    return ns(this, Ui, Ki, En, !1);
  };
  function vn(Zi, Ui, Ki, En) {
    Ki = Number(Ki) || 0;
    const ss = Zi.length - Ki;
    En ? (En = Number(En), En > ss && (En = ss)) : En = ss;
    const as = Ui.length;
    En > as / 2 && (En = as / 2);
    let us;
    for (us = 0; us < En; ++us) {
      const ua = parseInt(Ui.substr(us * 2, 2), 16);
      if (ca(ua)) return us;
      Zi[Ki + us] = ua;
    }
    return us;
  }
  function Mi(Zi, Ui, Ki, En) {
    return Ds(fa(Ui, Zi.length - Ki), Zi, Ki, En);
  }
  function Ai(Zi, Ui, Ki, En) {
    return Ds(gs(Ui), Zi, Ki, En);
  }
  function wi(Zi, Ui, Ki, En) {
    return Ds(aa(Ui), Zi, Ki, En);
  }
  function $i(Zi, Ui, Ki, En) {
    return Ds(sa(Ui, Zi.length - Ki), Zi, Ki, En);
  }
  Ue.prototype.write = function(Ui, Ki, En, ss) {
    if (Ki === void 0)
      ss = "utf8", En = this.length, Ki = 0;
    else if (En === void 0 && typeof Ki == "string")
      ss = Ki, En = this.length, Ki = 0;
    else if (isFinite(Ki))
      Ki = Ki >>> 0, isFinite(En) ? (En = En >>> 0, ss === void 0 && (ss = "utf8")) : (ss = En, En = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const as = this.length - Ki;
    if ((En === void 0 || En > as) && (En = as), Ui.length > 0 && (En < 0 || Ki < 0) || Ki > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    ss || (ss = "utf8");
    let us = !1;
    for (; ; )
      switch (ss) {
        case "hex":
          return vn(this, Ui, Ki, En);
        case "utf8":
        case "utf-8":
          return Mi(this, Ui, Ki, En);
        case "ascii":
        case "latin1":
        case "binary":
          return Ai(this, Ui, Ki, En);
        case "base64":
          return wi(this, Ui, Ki, En);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return $i(this, Ui, Ki, En);
        default:
          if (us) throw new TypeError("Unknown encoding: " + ss);
          ss = ("" + ss).toLowerCase(), us = !0;
      }
  }, Ue.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function Li(Zi, Ui, Ki) {
    return Ui === 0 && Ki === Zi.length ? t.fromByteArray(Zi) : t.fromByteArray(Zi.slice(Ui, Ki));
  }
  function qi(Zi, Ui, Ki) {
    Ki = Math.min(Zi.length, Ki);
    const En = [];
    let ss = Ui;
    for (; ss < Ki; ) {
      const as = Zi[ss];
      let us = null, ua = as > 239 ? 4 : as > 223 ? 3 : as > 191 ? 2 : 1;
      if (ss + ua <= Ki) {
        let ma, na, wa, ga;
        switch (ua) {
          case 1:
            as < 128 && (us = as);
            break;
          case 2:
            ma = Zi[ss + 1], (ma & 192) === 128 && (ga = (as & 31) << 6 | ma & 63, ga > 127 && (us = ga));
            break;
          case 3:
            ma = Zi[ss + 1], na = Zi[ss + 2], (ma & 192) === 128 && (na & 192) === 128 && (ga = (as & 15) << 12 | (ma & 63) << 6 | na & 63, ga > 2047 && (ga < 55296 || ga > 57343) && (us = ga));
            break;
          case 4:
            ma = Zi[ss + 1], na = Zi[ss + 2], wa = Zi[ss + 3], (ma & 192) === 128 && (na & 192) === 128 && (wa & 192) === 128 && (ga = (as & 15) << 18 | (ma & 63) << 12 | (na & 63) << 6 | wa & 63, ga > 65535 && ga < 1114112 && (us = ga));
        }
      }
      us === null ? (us = 65533, ua = 1) : us > 65535 && (us -= 65536, En.push(us >>> 10 & 1023 | 55296), us = 56320 | us & 1023), En.push(us), ss += ua;
    }
    return Ti(En);
  }
  const Ni = 4096;
  function Ti(Zi) {
    const Ui = Zi.length;
    if (Ui <= Ni)
      return String.fromCharCode.apply(String, Zi);
    let Ki = "", En = 0;
    for (; En < Ui; )
      Ki += String.fromCharCode.apply(
        String,
        Zi.slice(En, En += Ni)
      );
    return Ki;
  }
  function xi(Zi, Ui, Ki) {
    let En = "";
    Ki = Math.min(Zi.length, Ki);
    for (let ss = Ui; ss < Ki; ++ss)
      En += String.fromCharCode(Zi[ss] & 127);
    return En;
  }
  function Fi(Zi, Ui, Ki) {
    let En = "";
    Ki = Math.min(Zi.length, Ki);
    for (let ss = Ui; ss < Ki; ++ss)
      En += String.fromCharCode(Zi[ss]);
    return En;
  }
  function Si(Zi, Ui, Ki) {
    const En = Zi.length;
    (!Ui || Ui < 0) && (Ui = 0), (!Ki || Ki < 0 || Ki > En) && (Ki = En);
    let ss = "";
    for (let as = Ui; as < Ki; ++as)
      ss += ta[Zi[as]];
    return ss;
  }
  function Vi(Zi, Ui, Ki) {
    const En = Zi.slice(Ui, Ki);
    let ss = "";
    for (let as = 0; as < En.length - 1; as += 2)
      ss += String.fromCharCode(En[as] + En[as + 1] * 256);
    return ss;
  }
  Ue.prototype.slice = function(Ui, Ki) {
    const En = this.length;
    Ui = ~~Ui, Ki = Ki === void 0 ? En : ~~Ki, Ui < 0 ? (Ui += En, Ui < 0 && (Ui = 0)) : Ui > En && (Ui = En), Ki < 0 ? (Ki += En, Ki < 0 && (Ki = 0)) : Ki > En && (Ki = En), Ki < Ui && (Ki = Ui);
    const ss = this.subarray(Ui, Ki);
    return Object.setPrototypeOf(ss, Ue.prototype), ss;
  };
  function ts(Zi, Ui, Ki) {
    if (Zi % 1 !== 0 || Zi < 0) throw new RangeError("offset is not uint");
    if (Zi + Ui > Ki) throw new RangeError("Trying to access beyond buffer length");
  }
  Ue.prototype.readUintLE = Ue.prototype.readUIntLE = function(Ui, Ki, En) {
    Ui = Ui >>> 0, Ki = Ki >>> 0, En || ts(Ui, Ki, this.length);
    let ss = this[Ui], as = 1, us = 0;
    for (; ++us < Ki && (as *= 256); )
      ss += this[Ui + us] * as;
    return ss;
  }, Ue.prototype.readUintBE = Ue.prototype.readUIntBE = function(Ui, Ki, En) {
    Ui = Ui >>> 0, Ki = Ki >>> 0, En || ts(Ui, Ki, this.length);
    let ss = this[Ui + --Ki], as = 1;
    for (; Ki > 0 && (as *= 256); )
      ss += this[Ui + --Ki] * as;
    return ss;
  }, Ue.prototype.readUint8 = Ue.prototype.readUInt8 = function(Ui, Ki) {
    return Ui = Ui >>> 0, Ki || ts(Ui, 1, this.length), this[Ui];
  }, Ue.prototype.readUint16LE = Ue.prototype.readUInt16LE = function(Ui, Ki) {
    return Ui = Ui >>> 0, Ki || ts(Ui, 2, this.length), this[Ui] | this[Ui + 1] << 8;
  }, Ue.prototype.readUint16BE = Ue.prototype.readUInt16BE = function(Ui, Ki) {
    return Ui = Ui >>> 0, Ki || ts(Ui, 2, this.length), this[Ui] << 8 | this[Ui + 1];
  }, Ue.prototype.readUint32LE = Ue.prototype.readUInt32LE = function(Ui, Ki) {
    return Ui = Ui >>> 0, Ki || ts(Ui, 4, this.length), (this[Ui] | this[Ui + 1] << 8 | this[Ui + 2] << 16) + this[Ui + 3] * 16777216;
  }, Ue.prototype.readUint32BE = Ue.prototype.readUInt32BE = function(Ui, Ki) {
    return Ui = Ui >>> 0, Ki || ts(Ui, 4, this.length), this[Ui] * 16777216 + (this[Ui + 1] << 16 | this[Ui + 2] << 8 | this[Ui + 3]);
  }, Ue.prototype.readBigUInt64LE = oa(function(Ui) {
    Ui = Ui >>> 0, ps(Ui, "offset");
    const Ki = this[Ui], En = this[Ui + 7];
    (Ki === void 0 || En === void 0) && ea(Ui, this.length - 8);
    const ss = Ki + this[++Ui] * 2 ** 8 + this[++Ui] * 2 ** 16 + this[++Ui] * 2 ** 24, as = this[++Ui] + this[++Ui] * 2 ** 8 + this[++Ui] * 2 ** 16 + En * 2 ** 24;
    return BigInt(ss) + (BigInt(as) << BigInt(32));
  }), Ue.prototype.readBigUInt64BE = oa(function(Ui) {
    Ui = Ui >>> 0, ps(Ui, "offset");
    const Ki = this[Ui], En = this[Ui + 7];
    (Ki === void 0 || En === void 0) && ea(Ui, this.length - 8);
    const ss = Ki * 2 ** 24 + this[++Ui] * 2 ** 16 + this[++Ui] * 2 ** 8 + this[++Ui], as = this[++Ui] * 2 ** 24 + this[++Ui] * 2 ** 16 + this[++Ui] * 2 ** 8 + En;
    return (BigInt(ss) << BigInt(32)) + BigInt(as);
  }), Ue.prototype.readIntLE = function(Ui, Ki, En) {
    Ui = Ui >>> 0, Ki = Ki >>> 0, En || ts(Ui, Ki, this.length);
    let ss = this[Ui], as = 1, us = 0;
    for (; ++us < Ki && (as *= 256); )
      ss += this[Ui + us] * as;
    return as *= 128, ss >= as && (ss -= Math.pow(2, 8 * Ki)), ss;
  }, Ue.prototype.readIntBE = function(Ui, Ki, En) {
    Ui = Ui >>> 0, Ki = Ki >>> 0, En || ts(Ui, Ki, this.length);
    let ss = Ki, as = 1, us = this[Ui + --ss];
    for (; ss > 0 && (as *= 256); )
      us += this[Ui + --ss] * as;
    return as *= 128, us >= as && (us -= Math.pow(2, 8 * Ki)), us;
  }, Ue.prototype.readInt8 = function(Ui, Ki) {
    return Ui = Ui >>> 0, Ki || ts(Ui, 1, this.length), this[Ui] & 128 ? (255 - this[Ui] + 1) * -1 : this[Ui];
  }, Ue.prototype.readInt16LE = function(Ui, Ki) {
    Ui = Ui >>> 0, Ki || ts(Ui, 2, this.length);
    const En = this[Ui] | this[Ui + 1] << 8;
    return En & 32768 ? En | 4294901760 : En;
  }, Ue.prototype.readInt16BE = function(Ui, Ki) {
    Ui = Ui >>> 0, Ki || ts(Ui, 2, this.length);
    const En = this[Ui + 1] | this[Ui] << 8;
    return En & 32768 ? En | 4294901760 : En;
  }, Ue.prototype.readInt32LE = function(Ui, Ki) {
    return Ui = Ui >>> 0, Ki || ts(Ui, 4, this.length), this[Ui] | this[Ui + 1] << 8 | this[Ui + 2] << 16 | this[Ui + 3] << 24;
  }, Ue.prototype.readInt32BE = function(Ui, Ki) {
    return Ui = Ui >>> 0, Ki || ts(Ui, 4, this.length), this[Ui] << 24 | this[Ui + 1] << 16 | this[Ui + 2] << 8 | this[Ui + 3];
  }, Ue.prototype.readBigInt64LE = oa(function(Ui) {
    Ui = Ui >>> 0, ps(Ui, "offset");
    const Ki = this[Ui], En = this[Ui + 7];
    (Ki === void 0 || En === void 0) && ea(Ui, this.length - 8);
    const ss = this[Ui + 4] + this[Ui + 5] * 2 ** 8 + this[Ui + 6] * 2 ** 16 + (En << 24);
    return (BigInt(ss) << BigInt(32)) + BigInt(Ki + this[++Ui] * 2 ** 8 + this[++Ui] * 2 ** 16 + this[++Ui] * 2 ** 24);
  }), Ue.prototype.readBigInt64BE = oa(function(Ui) {
    Ui = Ui >>> 0, ps(Ui, "offset");
    const Ki = this[Ui], En = this[Ui + 7];
    (Ki === void 0 || En === void 0) && ea(Ui, this.length - 8);
    const ss = (Ki << 24) + // Overflow
    this[++Ui] * 2 ** 16 + this[++Ui] * 2 ** 8 + this[++Ui];
    return (BigInt(ss) << BigInt(32)) + BigInt(this[++Ui] * 2 ** 24 + this[++Ui] * 2 ** 16 + this[++Ui] * 2 ** 8 + En);
  }), Ue.prototype.readFloatLE = function(Ui, Ki) {
    return Ui = Ui >>> 0, Ki || ts(Ui, 4, this.length), Ie.read(this, Ui, !0, 23, 4);
  }, Ue.prototype.readFloatBE = function(Ui, Ki) {
    return Ui = Ui >>> 0, Ki || ts(Ui, 4, this.length), Ie.read(this, Ui, !1, 23, 4);
  }, Ue.prototype.readDoubleLE = function(Ui, Ki) {
    return Ui = Ui >>> 0, Ki || ts(Ui, 8, this.length), Ie.read(this, Ui, !0, 52, 8);
  }, Ue.prototype.readDoubleBE = function(Ui, Ki) {
    return Ui = Ui >>> 0, Ki || ts(Ui, 8, this.length), Ie.read(this, Ui, !1, 52, 8);
  };
  function Hi(Zi, Ui, Ki, En, ss, as) {
    if (!Ue.isBuffer(Zi)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (Ui > ss || Ui < as) throw new RangeError('"value" argument is out of bounds');
    if (Ki + En > Zi.length) throw new RangeError("Index out of range");
  }
  Ue.prototype.writeUintLE = Ue.prototype.writeUIntLE = function(Ui, Ki, En, ss) {
    if (Ui = +Ui, Ki = Ki >>> 0, En = En >>> 0, !ss) {
      const ua = Math.pow(2, 8 * En) - 1;
      Hi(this, Ui, Ki, En, ua, 0);
    }
    let as = 1, us = 0;
    for (this[Ki] = Ui & 255; ++us < En && (as *= 256); )
      this[Ki + us] = Ui / as & 255;
    return Ki + En;
  }, Ue.prototype.writeUintBE = Ue.prototype.writeUIntBE = function(Ui, Ki, En, ss) {
    if (Ui = +Ui, Ki = Ki >>> 0, En = En >>> 0, !ss) {
      const ua = Math.pow(2, 8 * En) - 1;
      Hi(this, Ui, Ki, En, ua, 0);
    }
    let as = En - 1, us = 1;
    for (this[Ki + as] = Ui & 255; --as >= 0 && (us *= 256); )
      this[Ki + as] = Ui / us & 255;
    return Ki + En;
  }, Ue.prototype.writeUint8 = Ue.prototype.writeUInt8 = function(Ui, Ki, En) {
    return Ui = +Ui, Ki = Ki >>> 0, En || Hi(this, Ui, Ki, 1, 255, 0), this[Ki] = Ui & 255, Ki + 1;
  }, Ue.prototype.writeUint16LE = Ue.prototype.writeUInt16LE = function(Ui, Ki, En) {
    return Ui = +Ui, Ki = Ki >>> 0, En || Hi(this, Ui, Ki, 2, 65535, 0), this[Ki] = Ui & 255, this[Ki + 1] = Ui >>> 8, Ki + 2;
  }, Ue.prototype.writeUint16BE = Ue.prototype.writeUInt16BE = function(Ui, Ki, En) {
    return Ui = +Ui, Ki = Ki >>> 0, En || Hi(this, Ui, Ki, 2, 65535, 0), this[Ki] = Ui >>> 8, this[Ki + 1] = Ui & 255, Ki + 2;
  }, Ue.prototype.writeUint32LE = Ue.prototype.writeUInt32LE = function(Ui, Ki, En) {
    return Ui = +Ui, Ki = Ki >>> 0, En || Hi(this, Ui, Ki, 4, 4294967295, 0), this[Ki + 3] = Ui >>> 24, this[Ki + 2] = Ui >>> 16, this[Ki + 1] = Ui >>> 8, this[Ki] = Ui & 255, Ki + 4;
  }, Ue.prototype.writeUint32BE = Ue.prototype.writeUInt32BE = function(Ui, Ki, En) {
    return Ui = +Ui, Ki = Ki >>> 0, En || Hi(this, Ui, Ki, 4, 4294967295, 0), this[Ki] = Ui >>> 24, this[Ki + 1] = Ui >>> 16, this[Ki + 2] = Ui >>> 8, this[Ki + 3] = Ui & 255, Ki + 4;
  };
  function fn(Zi, Ui, Ki, En, ss) {
    ds(Ui, En, ss, Zi, Ki, 7);
    let as = Number(Ui & BigInt(4294967295));
    Zi[Ki++] = as, as = as >> 8, Zi[Ki++] = as, as = as >> 8, Zi[Ki++] = as, as = as >> 8, Zi[Ki++] = as;
    let us = Number(Ui >> BigInt(32) & BigInt(4294967295));
    return Zi[Ki++] = us, us = us >> 8, Zi[Ki++] = us, us = us >> 8, Zi[Ki++] = us, us = us >> 8, Zi[Ki++] = us, Ki;
  }
  function Bi(Zi, Ui, Ki, En, ss) {
    ds(Ui, En, ss, Zi, Ki, 7);
    let as = Number(Ui & BigInt(4294967295));
    Zi[Ki + 7] = as, as = as >> 8, Zi[Ki + 6] = as, as = as >> 8, Zi[Ki + 5] = as, as = as >> 8, Zi[Ki + 4] = as;
    let us = Number(Ui >> BigInt(32) & BigInt(4294967295));
    return Zi[Ki + 3] = us, us = us >> 8, Zi[Ki + 2] = us, us = us >> 8, Zi[Ki + 1] = us, us = us >> 8, Zi[Ki] = us, Ki + 8;
  }
  Ue.prototype.writeBigUInt64LE = oa(function(Ui, Ki = 0) {
    return fn(this, Ui, Ki, BigInt(0), BigInt("0xffffffffffffffff"));
  }), Ue.prototype.writeBigUInt64BE = oa(function(Ui, Ki = 0) {
    return Bi(this, Ui, Ki, BigInt(0), BigInt("0xffffffffffffffff"));
  }), Ue.prototype.writeIntLE = function(Ui, Ki, En, ss) {
    if (Ui = +Ui, Ki = Ki >>> 0, !ss) {
      const ma = Math.pow(2, 8 * En - 1);
      Hi(this, Ui, Ki, En, ma - 1, -ma);
    }
    let as = 0, us = 1, ua = 0;
    for (this[Ki] = Ui & 255; ++as < En && (us *= 256); )
      Ui < 0 && ua === 0 && this[Ki + as - 1] !== 0 && (ua = 1), this[Ki + as] = (Ui / us >> 0) - ua & 255;
    return Ki + En;
  }, Ue.prototype.writeIntBE = function(Ui, Ki, En, ss) {
    if (Ui = +Ui, Ki = Ki >>> 0, !ss) {
      const ma = Math.pow(2, 8 * En - 1);
      Hi(this, Ui, Ki, En, ma - 1, -ma);
    }
    let as = En - 1, us = 1, ua = 0;
    for (this[Ki + as] = Ui & 255; --as >= 0 && (us *= 256); )
      Ui < 0 && ua === 0 && this[Ki + as + 1] !== 0 && (ua = 1), this[Ki + as] = (Ui / us >> 0) - ua & 255;
    return Ki + En;
  }, Ue.prototype.writeInt8 = function(Ui, Ki, En) {
    return Ui = +Ui, Ki = Ki >>> 0, En || Hi(this, Ui, Ki, 1, 127, -128), Ui < 0 && (Ui = 255 + Ui + 1), this[Ki] = Ui & 255, Ki + 1;
  }, Ue.prototype.writeInt16LE = function(Ui, Ki, En) {
    return Ui = +Ui, Ki = Ki >>> 0, En || Hi(this, Ui, Ki, 2, 32767, -32768), this[Ki] = Ui & 255, this[Ki + 1] = Ui >>> 8, Ki + 2;
  }, Ue.prototype.writeInt16BE = function(Ui, Ki, En) {
    return Ui = +Ui, Ki = Ki >>> 0, En || Hi(this, Ui, Ki, 2, 32767, -32768), this[Ki] = Ui >>> 8, this[Ki + 1] = Ui & 255, Ki + 2;
  }, Ue.prototype.writeInt32LE = function(Ui, Ki, En) {
    return Ui = +Ui, Ki = Ki >>> 0, En || Hi(this, Ui, Ki, 4, 2147483647, -2147483648), this[Ki] = Ui & 255, this[Ki + 1] = Ui >>> 8, this[Ki + 2] = Ui >>> 16, this[Ki + 3] = Ui >>> 24, Ki + 4;
  }, Ue.prototype.writeInt32BE = function(Ui, Ki, En) {
    return Ui = +Ui, Ki = Ki >>> 0, En || Hi(this, Ui, Ki, 4, 2147483647, -2147483648), Ui < 0 && (Ui = 4294967295 + Ui + 1), this[Ki] = Ui >>> 24, this[Ki + 1] = Ui >>> 16, this[Ki + 2] = Ui >>> 8, this[Ki + 3] = Ui & 255, Ki + 4;
  }, Ue.prototype.writeBigInt64LE = oa(function(Ui, Ki = 0) {
    return fn(this, Ui, Ki, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), Ue.prototype.writeBigInt64BE = oa(function(Ui, Ki = 0) {
    return Bi(this, Ui, Ki, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function ki(Zi, Ui, Ki, En, ss, as) {
    if (Ki + En > Zi.length) throw new RangeError("Index out of range");
    if (Ki < 0) throw new RangeError("Index out of range");
  }
  function Ji(Zi, Ui, Ki, En, ss) {
    return Ui = +Ui, Ki = Ki >>> 0, ss || ki(Zi, Ui, Ki, 4), Ie.write(Zi, Ui, Ki, En, 23, 4), Ki + 4;
  }
  Ue.prototype.writeFloatLE = function(Ui, Ki, En) {
    return Ji(this, Ui, Ki, !0, En);
  }, Ue.prototype.writeFloatBE = function(Ui, Ki, En) {
    return Ji(this, Ui, Ki, !1, En);
  };
  function Ri(Zi, Ui, Ki, En, ss) {
    return Ui = +Ui, Ki = Ki >>> 0, ss || ki(Zi, Ui, Ki, 8), Ie.write(Zi, Ui, Ki, En, 52, 8), Ki + 8;
  }
  Ue.prototype.writeDoubleLE = function(Ui, Ki, En) {
    return Ri(this, Ui, Ki, !0, En);
  }, Ue.prototype.writeDoubleBE = function(Ui, Ki, En) {
    return Ri(this, Ui, Ki, !1, En);
  }, Ue.prototype.copy = function(Ui, Ki, En, ss) {
    if (!Ue.isBuffer(Ui)) throw new TypeError("argument should be a Buffer");
    if (En || (En = 0), !ss && ss !== 0 && (ss = this.length), Ki >= Ui.length && (Ki = Ui.length), Ki || (Ki = 0), ss > 0 && ss < En && (ss = En), ss === En || Ui.length === 0 || this.length === 0) return 0;
    if (Ki < 0)
      throw new RangeError("targetStart out of bounds");
    if (En < 0 || En >= this.length) throw new RangeError("Index out of range");
    if (ss < 0) throw new RangeError("sourceEnd out of bounds");
    ss > this.length && (ss = this.length), Ui.length - Ki < ss - En && (ss = Ui.length - Ki + En);
    const as = ss - En;
    return this === Ui && typeof Pe.prototype.copyWithin == "function" ? this.copyWithin(Ki, En, ss) : Pe.prototype.set.call(
      Ui,
      this.subarray(En, ss),
      Ki
    ), as;
  }, Ue.prototype.fill = function(Ui, Ki, En, ss) {
    if (typeof Ui == "string") {
      if (typeof Ki == "string" ? (ss = Ki, Ki = 0, En = this.length) : typeof En == "string" && (ss = En, En = this.length), ss !== void 0 && typeof ss != "string")
        throw new TypeError("encoding must be a string");
      if (typeof ss == "string" && !Ue.isEncoding(ss))
        throw new TypeError("Unknown encoding: " + ss);
      if (Ui.length === 1) {
        const us = Ui.charCodeAt(0);
        (ss === "utf8" && us < 128 || ss === "latin1") && (Ui = us);
      }
    } else typeof Ui == "number" ? Ui = Ui & 255 : typeof Ui == "boolean" && (Ui = Number(Ui));
    if (Ki < 0 || this.length < Ki || this.length < En)
      throw new RangeError("Out of range index");
    if (En <= Ki)
      return this;
    Ki = Ki >>> 0, En = En === void 0 ? this.length : En >>> 0, Ui || (Ui = 0);
    let as;
    if (typeof Ui == "number")
      for (as = Ki; as < En; ++as)
        this[as] = Ui;
    else {
      const us = Ue.isBuffer(Ui) ? Ui : Ue.from(Ui, ss), ua = us.length;
      if (ua === 0)
        throw new TypeError('The value "' + Ui + '" is invalid for argument "value"');
      for (as = 0; as < En - Ki; ++as)
        this[as + Ki] = us[as % ua];
    }
    return this;
  };
  const ji = {};
  function Gi(Zi, Ui, Ki) {
    ji[Zi] = class extends Ki {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: Ui.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${Zi}]`, this.stack, delete this.name;
      }
      get code() {
        return Zi;
      }
      set code(ss) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: ss,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${Zi}]: ${this.message}`;
      }
    };
  }
  Gi(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(Zi) {
      return Zi ? `${Zi} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Gi(
    "ERR_INVALID_ARG_TYPE",
    function(Zi, Ui) {
      return `The "${Zi}" argument must be of type number. Received type ${typeof Ui}`;
    },
    TypeError
  ), Gi(
    "ERR_OUT_OF_RANGE",
    function(Zi, Ui, Ki) {
      let En = `The value of "${Zi}" is out of range.`, ss = Ki;
      return Number.isInteger(Ki) && Math.abs(Ki) > 2 ** 32 ? ss = is(String(Ki)) : typeof Ki == "bigint" && (ss = String(Ki), (Ki > BigInt(2) ** BigInt(32) || Ki < -(BigInt(2) ** BigInt(32))) && (ss = is(ss)), ss += "n"), En += ` It must be ${Ui}. Received ${ss}`, En;
    },
    RangeError
  );
  function is(Zi) {
    let Ui = "", Ki = Zi.length;
    const En = Zi[0] === "-" ? 1 : 0;
    for (; Ki >= En + 4; Ki -= 3)
      Ui = `_${Zi.slice(Ki - 3, Ki)}${Ui}`;
    return `${Zi.slice(0, Ki)}${Ui}`;
  }
  function os(Zi, Ui, Ki) {
    ps(Ui, "offset"), (Zi[Ui] === void 0 || Zi[Ui + Ki] === void 0) && ea(Ui, Zi.length - (Ki + 1));
  }
  function ds(Zi, Ui, Ki, En, ss, as) {
    if (Zi > Ki || Zi < Ui) {
      const us = typeof Ui == "bigint" ? "n" : "";
      let ua;
      throw Ui === 0 || Ui === BigInt(0) ? ua = `>= 0${us} and < 2${us} ** ${(as + 1) * 8}${us}` : ua = `>= -(2${us} ** ${(as + 1) * 8 - 1}${us}) and < 2 ** ${(as + 1) * 8 - 1}${us}`, new ji.ERR_OUT_OF_RANGE("value", ua, Zi);
    }
    os(En, ss, as);
  }
  function ps(Zi, Ui) {
    if (typeof Zi != "number")
      throw new ji.ERR_INVALID_ARG_TYPE(Ui, "number", Zi);
  }
  function ea(Zi, Ui, Ki) {
    throw Math.floor(Zi) !== Zi ? (ps(Zi, Ki), new ji.ERR_OUT_OF_RANGE("offset", "an integer", Zi)) : Ui < 0 ? new ji.ERR_BUFFER_OUT_OF_BOUNDS() : new ji.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${Ui}`,
      Zi
    );
  }
  const ia = /[^+/0-9A-Za-z-_]/g;
  function hs(Zi) {
    if (Zi = Zi.split("=")[0], Zi = Zi.trim().replace(ia, ""), Zi.length < 2) return "";
    for (; Zi.length % 4 !== 0; )
      Zi = Zi + "=";
    return Zi;
  }
  function fa(Zi, Ui) {
    Ui = Ui || 1 / 0;
    let Ki;
    const En = Zi.length;
    let ss = null;
    const as = [];
    for (let us = 0; us < En; ++us) {
      if (Ki = Zi.charCodeAt(us), Ki > 55295 && Ki < 57344) {
        if (!ss) {
          if (Ki > 56319) {
            (Ui -= 3) > -1 && as.push(239, 191, 189);
            continue;
          } else if (us + 1 === En) {
            (Ui -= 3) > -1 && as.push(239, 191, 189);
            continue;
          }
          ss = Ki;
          continue;
        }
        if (Ki < 56320) {
          (Ui -= 3) > -1 && as.push(239, 191, 189), ss = Ki;
          continue;
        }
        Ki = (ss - 55296 << 10 | Ki - 56320) + 65536;
      } else ss && (Ui -= 3) > -1 && as.push(239, 191, 189);
      if (ss = null, Ki < 128) {
        if ((Ui -= 1) < 0) break;
        as.push(Ki);
      } else if (Ki < 2048) {
        if ((Ui -= 2) < 0) break;
        as.push(
          Ki >> 6 | 192,
          Ki & 63 | 128
        );
      } else if (Ki < 65536) {
        if ((Ui -= 3) < 0) break;
        as.push(
          Ki >> 12 | 224,
          Ki >> 6 & 63 | 128,
          Ki & 63 | 128
        );
      } else if (Ki < 1114112) {
        if ((Ui -= 4) < 0) break;
        as.push(
          Ki >> 18 | 240,
          Ki >> 12 & 63 | 128,
          Ki >> 6 & 63 | 128,
          Ki & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return as;
  }
  function gs(Zi) {
    const Ui = [];
    for (let Ki = 0; Ki < Zi.length; ++Ki)
      Ui.push(Zi.charCodeAt(Ki) & 255);
    return Ui;
  }
  function sa(Zi, Ui) {
    let Ki, En, ss;
    const as = [];
    for (let us = 0; us < Zi.length && !((Ui -= 2) < 0); ++us)
      Ki = Zi.charCodeAt(us), En = Ki >> 8, ss = Ki % 256, as.push(ss), as.push(En);
    return as;
  }
  function aa(Zi) {
    return t.toByteArray(hs(Zi));
  }
  function Ds(Zi, Ui, Ki, En) {
    let ss;
    for (ss = 0; ss < En && !(ss + Ki >= Ui.length || ss >= Zi.length); ++ss)
      Ui[ss + Ki] = Zi[ss];
    return ss;
  }
  function ra(Zi, Ui) {
    return Zi instanceof Ui || Zi != null && Zi.constructor != null && Zi.constructor.name != null && Zi.constructor.name === Ui.name;
  }
  function ca(Zi) {
    return Zi !== Zi;
  }
  const ta = function() {
    const Zi = "0123456789abcdef", Ui = new Array(256);
    for (let Ki = 0; Ki < 16; ++Ki) {
      const En = Ki * 16;
      for (let ss = 0; ss < 16; ++ss)
        Ui[En + ss] = Zi[Ki] + Zi[ss];
    }
    return Ui;
  }();
  function oa(Zi) {
    return typeof BigInt > "u" ? da : Zi;
  }
  function da() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer = buffer$1.Buffer, Blob$1 = buffer$1.Blob, BlobOptions = buffer$1.BlobOptions, Buffer$1 = buffer$1.Buffer, File = buffer$1.File, FileOptions = buffer$1.FileOptions, INSPECT_MAX_BYTES = buffer$1.INSPECT_MAX_BYTES, SlowBuffer = buffer$1.SlowBuffer, TranscodeEncoding = buffer$1.TranscodeEncoding, atob$1 = buffer$1.atob, btoa$1 = buffer$1.btoa, constants$2 = buffer$1.constants, isAscii = buffer$1.isAscii, isUtf8 = buffer$1.isUtf8, kMaxLength = buffer$1.kMaxLength, kStringMaxLength = buffer$1.kStringMaxLength, resolveObjectURL = buffer$1.resolveObjectURL, transcode = buffer$1.transcode, dist = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: Blob$1,
  BlobOptions,
  Buffer: Buffer$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob: atob$1,
  btoa: btoa$1,
  constants: constants$2,
  default: Buffer,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
var events = { exports: {} }, R$3 = typeof Reflect == "object" ? Reflect : null, ReflectApply = R$3 && typeof R$3.apply == "function" ? R$3.apply : function(t, Ie, Me) {
  return Function.prototype.apply.call(t, Ie, Me);
}, ReflectOwnKeys;
R$3 && typeof R$3.ownKeys == "function" ? ReflectOwnKeys = R$3.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : ReflectOwnKeys = function(t) {
  return Object.getOwnPropertyNames(t);
};
function ProcessEmitWarning(Ae) {
  console && console.warn && console.warn(Ae);
}
var NumberIsNaN = Number.isNaN || function(t) {
  return t !== t;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(Ae) {
  if (typeof Ae != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof Ae);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(Ae) {
    if (typeof Ae != "number" || Ae < 0 || NumberIsNaN(Ae))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + Ae + ".");
    defaultMaxListeners = Ae;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || NumberIsNaN(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function _getMaxListeners(Ae) {
  return Ae._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : Ae._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function(t) {
  for (var Ie = [], Me = 1; Me < arguments.length; Me++) Ie.push(arguments[Me]);
  var Be = t === "error", Pe = this._events;
  if (Pe !== void 0)
    Be = Be && Pe.error === void 0;
  else if (!Be)
    return !1;
  if (Be) {
    var Te;
    if (Ie.length > 0 && (Te = Ie[0]), Te instanceof Error)
      throw Te;
    var je = new Error("Unhandled error." + (Te ? " (" + Te.message + ")" : ""));
    throw je.context = Te, je;
  }
  var Ve = Pe[t];
  if (Ve === void 0)
    return !1;
  if (typeof Ve == "function")
    ReflectApply(Ve, this, Ie);
  else
    for (var fi = Ve.length, Ue = arrayClone(Ve, fi), Me = 0; Me < fi; ++Me)
      ReflectApply(Ue[Me], this, Ie);
  return !0;
};
function _addListener(Ae, t, Ie, Me) {
  var Be, Pe, Te;
  if (checkListener(Ie), Pe = Ae._events, Pe === void 0 ? (Pe = Ae._events = /* @__PURE__ */ Object.create(null), Ae._eventsCount = 0) : (Pe.newListener !== void 0 && (Ae.emit(
    "newListener",
    t,
    Ie.listener ? Ie.listener : Ie
  ), Pe = Ae._events), Te = Pe[t]), Te === void 0)
    Te = Pe[t] = Ie, ++Ae._eventsCount;
  else if (typeof Te == "function" ? Te = Pe[t] = Me ? [Ie, Te] : [Te, Ie] : Me ? Te.unshift(Ie) : Te.push(Ie), Be = _getMaxListeners(Ae), Be > 0 && Te.length > Be && !Te.warned) {
    Te.warned = !0;
    var je = new Error("Possible EventEmitter memory leak detected. " + Te.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    je.name = "MaxListenersExceededWarning", je.emitter = Ae, je.type = t, je.count = Te.length, ProcessEmitWarning(je);
  }
  return Ae;
}
EventEmitter.prototype.addListener = function(t, Ie) {
  return _addListener(this, t, Ie, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function(t, Ie) {
  return _addListener(this, t, Ie, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(Ae, t, Ie) {
  var Me = { fired: !1, wrapFn: void 0, target: Ae, type: t, listener: Ie }, Be = onceWrapper.bind(Me);
  return Be.listener = Ie, Me.wrapFn = Be, Be;
}
EventEmitter.prototype.once = function(t, Ie) {
  return checkListener(Ie), this.on(t, _onceWrap(this, t, Ie)), this;
};
EventEmitter.prototype.prependOnceListener = function(t, Ie) {
  return checkListener(Ie), this.prependListener(t, _onceWrap(this, t, Ie)), this;
};
EventEmitter.prototype.removeListener = function(t, Ie) {
  var Me, Be, Pe, Te, je;
  if (checkListener(Ie), Be = this._events, Be === void 0)
    return this;
  if (Me = Be[t], Me === void 0)
    return this;
  if (Me === Ie || Me.listener === Ie)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete Be[t], Be.removeListener && this.emit("removeListener", t, Me.listener || Ie));
  else if (typeof Me != "function") {
    for (Pe = -1, Te = Me.length - 1; Te >= 0; Te--)
      if (Me[Te] === Ie || Me[Te].listener === Ie) {
        je = Me[Te].listener, Pe = Te;
        break;
      }
    if (Pe < 0)
      return this;
    Pe === 0 ? Me.shift() : spliceOne(Me, Pe), Me.length === 1 && (Be[t] = Me[0]), Be.removeListener !== void 0 && this.emit("removeListener", t, je || Ie);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function(t) {
  var Ie, Me, Be;
  if (Me = this._events, Me === void 0)
    return this;
  if (Me.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Me[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Me[t]), this;
  if (arguments.length === 0) {
    var Pe = Object.keys(Me), Te;
    for (Be = 0; Be < Pe.length; ++Be)
      Te = Pe[Be], Te !== "removeListener" && this.removeAllListeners(Te);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (Ie = Me[t], typeof Ie == "function")
    this.removeListener(t, Ie);
  else if (Ie !== void 0)
    for (Be = Ie.length - 1; Be >= 0; Be--)
      this.removeListener(t, Ie[Be]);
  return this;
};
function _listeners(Ae, t, Ie) {
  var Me = Ae._events;
  if (Me === void 0)
    return [];
  var Be = Me[t];
  return Be === void 0 ? [] : typeof Be == "function" ? Ie ? [Be.listener || Be] : [Be] : Ie ? unwrapListeners(Be) : arrayClone(Be, Be.length);
}
EventEmitter.prototype.listeners = function(t) {
  return _listeners(this, t, !0);
};
EventEmitter.prototype.rawListeners = function(t) {
  return _listeners(this, t, !1);
};
EventEmitter.listenerCount = function(Ae, t) {
  return typeof Ae.listenerCount == "function" ? Ae.listenerCount(t) : listenerCount.call(Ae, t);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(Ae) {
  var t = this._events;
  if (t !== void 0) {
    var Ie = t[Ae];
    if (typeof Ie == "function")
      return 1;
    if (Ie !== void 0)
      return Ie.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(Ae, t) {
  for (var Ie = new Array(t), Me = 0; Me < t; ++Me)
    Ie[Me] = Ae[Me];
  return Ie;
}
function spliceOne(Ae, t) {
  for (; t + 1 < Ae.length; t++)
    Ae[t] = Ae[t + 1];
  Ae.pop();
}
function unwrapListeners(Ae) {
  for (var t = new Array(Ae.length), Ie = 0; Ie < t.length; ++Ie)
    t[Ie] = Ae[Ie].listener || Ae[Ie];
  return t;
}
function once(Ae, t) {
  return new Promise(function(Ie, Me) {
    function Be(Te) {
      Ae.removeListener(t, Pe), Me(Te);
    }
    function Pe() {
      typeof Ae.removeListener == "function" && Ae.removeListener("error", Be), Ie([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(Ae, t, Pe, { once: !0 }), t !== "error" && addErrorHandlerIfEventEmitter(Ae, Be, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(Ae, t, Ie) {
  typeof Ae.on == "function" && eventTargetAgnosticAddListener(Ae, "error", t, Ie);
}
function eventTargetAgnosticAddListener(Ae, t, Ie, Me) {
  if (typeof Ae.on == "function")
    Me.once ? Ae.once(t, Ie) : Ae.on(t, Ie);
  else if (typeof Ae.addEventListener == "function")
    Ae.addEventListener(t, function Be(Pe) {
      Me.once && Ae.removeEventListener(t, Be), Ie(Pe);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof Ae);
}
var eventsExports = events.exports;
const es = /* @__PURE__ */ getDefaultExportFromCjs(eventsExports);
var cjs$3 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(Ae, t) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Ie, Me) {
    Ie.__proto__ = Me;
  } || function(Ie, Me) {
    for (var Be in Me) Me.hasOwnProperty(Be) && (Ie[Be] = Me[Be]);
  }, extendStatics(Ae, t);
};
function __extends(Ae, t) {
  extendStatics(Ae, t);
  function Ie() {
    this.constructor = Ae;
  }
  Ae.prototype = t === null ? Object.create(t) : (Ie.prototype = t.prototype, new Ie());
}
var __assign = function() {
  return __assign = Object.assign || function(t) {
    for (var Ie, Me = 1, Be = arguments.length; Me < Be; Me++) {
      Ie = arguments[Me];
      for (var Pe in Ie) Object.prototype.hasOwnProperty.call(Ie, Pe) && (t[Pe] = Ie[Pe]);
    }
    return t;
  }, __assign.apply(this, arguments);
};
function __rest(Ae, t) {
  var Ie = {};
  for (var Me in Ae) Object.prototype.hasOwnProperty.call(Ae, Me) && t.indexOf(Me) < 0 && (Ie[Me] = Ae[Me]);
  if (Ae != null && typeof Object.getOwnPropertySymbols == "function")
    for (var Be = 0, Me = Object.getOwnPropertySymbols(Ae); Be < Me.length; Be++)
      t.indexOf(Me[Be]) < 0 && Object.prototype.propertyIsEnumerable.call(Ae, Me[Be]) && (Ie[Me[Be]] = Ae[Me[Be]]);
  return Ie;
}
function __decorate(Ae, t, Ie, Me) {
  var Be = arguments.length, Pe = Be < 3 ? t : Me === null ? Me = Object.getOwnPropertyDescriptor(t, Ie) : Me, Te;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") Pe = Reflect.decorate(Ae, t, Ie, Me);
  else for (var je = Ae.length - 1; je >= 0; je--) (Te = Ae[je]) && (Pe = (Be < 3 ? Te(Pe) : Be > 3 ? Te(t, Ie, Pe) : Te(t, Ie)) || Pe);
  return Be > 3 && Pe && Object.defineProperty(t, Ie, Pe), Pe;
}
function __param(Ae, t) {
  return function(Ie, Me) {
    t(Ie, Me, Ae);
  };
}
function __metadata(Ae, t) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(Ae, t);
}
function __awaiter(Ae, t, Ie, Me) {
  function Be(Pe) {
    return Pe instanceof Ie ? Pe : new Ie(function(Te) {
      Te(Pe);
    });
  }
  return new (Ie || (Ie = Promise))(function(Pe, Te) {
    function je(Ue) {
      try {
        fi(Me.next(Ue));
      } catch (bi) {
        Te(bi);
      }
    }
    function Ve(Ue) {
      try {
        fi(Me.throw(Ue));
      } catch (bi) {
        Te(bi);
      }
    }
    function fi(Ue) {
      Ue.done ? Pe(Ue.value) : Be(Ue.value).then(je, Ve);
    }
    fi((Me = Me.apply(Ae, t || [])).next());
  });
}
function __generator(Ae, t) {
  var Ie = { label: 0, sent: function() {
    if (Pe[0] & 1) throw Pe[1];
    return Pe[1];
  }, trys: [], ops: [] }, Me, Be, Pe, Te;
  return Te = { next: je(0), throw: je(1), return: je(2) }, typeof Symbol == "function" && (Te[Symbol.iterator] = function() {
    return this;
  }), Te;
  function je(fi) {
    return function(Ue) {
      return Ve([fi, Ue]);
    };
  }
  function Ve(fi) {
    if (Me) throw new TypeError("Generator is already executing.");
    for (; Ie; ) try {
      if (Me = 1, Be && (Pe = fi[0] & 2 ? Be.return : fi[0] ? Be.throw || ((Pe = Be.return) && Pe.call(Be), 0) : Be.next) && !(Pe = Pe.call(Be, fi[1])).done) return Pe;
      switch (Be = 0, Pe && (fi = [fi[0] & 2, Pe.value]), fi[0]) {
        case 0:
        case 1:
          Pe = fi;
          break;
        case 4:
          return Ie.label++, { value: fi[1], done: !1 };
        case 5:
          Ie.label++, Be = fi[1], fi = [0];
          continue;
        case 7:
          fi = Ie.ops.pop(), Ie.trys.pop();
          continue;
        default:
          if (Pe = Ie.trys, !(Pe = Pe.length > 0 && Pe[Pe.length - 1]) && (fi[0] === 6 || fi[0] === 2)) {
            Ie = 0;
            continue;
          }
          if (fi[0] === 3 && (!Pe || fi[1] > Pe[0] && fi[1] < Pe[3])) {
            Ie.label = fi[1];
            break;
          }
          if (fi[0] === 6 && Ie.label < Pe[1]) {
            Ie.label = Pe[1], Pe = fi;
            break;
          }
          if (Pe && Ie.label < Pe[2]) {
            Ie.label = Pe[2], Ie.ops.push(fi);
            break;
          }
          Pe[2] && Ie.ops.pop(), Ie.trys.pop();
          continue;
      }
      fi = t.call(Ae, Ie);
    } catch (Ue) {
      fi = [6, Ue], Be = 0;
    } finally {
      Me = Pe = 0;
    }
    if (fi[0] & 5) throw fi[1];
    return { value: fi[0] ? fi[1] : void 0, done: !0 };
  }
}
function __createBinding(Ae, t, Ie, Me) {
  Me === void 0 && (Me = Ie), Ae[Me] = t[Ie];
}
function __exportStar(Ae, t) {
  for (var Ie in Ae) Ie !== "default" && !t.hasOwnProperty(Ie) && (t[Ie] = Ae[Ie]);
}
function __values(Ae) {
  var t = typeof Symbol == "function" && Symbol.iterator, Ie = t && Ae[t], Me = 0;
  if (Ie) return Ie.call(Ae);
  if (Ae && typeof Ae.length == "number") return {
    next: function() {
      return Ae && Me >= Ae.length && (Ae = void 0), { value: Ae && Ae[Me++], done: !Ae };
    }
  };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(Ae, t) {
  var Ie = typeof Symbol == "function" && Ae[Symbol.iterator];
  if (!Ie) return Ae;
  var Me = Ie.call(Ae), Be, Pe = [], Te;
  try {
    for (; (t === void 0 || t-- > 0) && !(Be = Me.next()).done; ) Pe.push(Be.value);
  } catch (je) {
    Te = { error: je };
  } finally {
    try {
      Be && !Be.done && (Ie = Me.return) && Ie.call(Me);
    } finally {
      if (Te) throw Te.error;
    }
  }
  return Pe;
}
function __spread() {
  for (var Ae = [], t = 0; t < arguments.length; t++)
    Ae = Ae.concat(__read(arguments[t]));
  return Ae;
}
function __spreadArrays() {
  for (var Ae = 0, t = 0, Ie = arguments.length; t < Ie; t++) Ae += arguments[t].length;
  for (var Me = Array(Ae), Be = 0, t = 0; t < Ie; t++)
    for (var Pe = arguments[t], Te = 0, je = Pe.length; Te < je; Te++, Be++)
      Me[Be] = Pe[Te];
  return Me;
}
function __await(Ae) {
  return this instanceof __await ? (this.v = Ae, this) : new __await(Ae);
}
function __asyncGenerator(Ae, t, Ie) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var Me = Ie.apply(Ae, t || []), Be, Pe = [];
  return Be = {}, Te("next"), Te("throw"), Te("return"), Be[Symbol.asyncIterator] = function() {
    return this;
  }, Be;
  function Te(vi) {
    Me[vi] && (Be[vi] = function(mi) {
      return new Promise(function(_i, Ei) {
        Pe.push([vi, mi, _i, Ei]) > 1 || je(vi, mi);
      });
    });
  }
  function je(vi, mi) {
    try {
      Ve(Me[vi](mi));
    } catch (_i) {
      bi(Pe[0][3], _i);
    }
  }
  function Ve(vi) {
    vi.value instanceof __await ? Promise.resolve(vi.value.v).then(fi, Ue) : bi(Pe[0][2], vi);
  }
  function fi(vi) {
    je("next", vi);
  }
  function Ue(vi) {
    je("throw", vi);
  }
  function bi(vi, mi) {
    vi(mi), Pe.shift(), Pe.length && je(Pe[0][0], Pe[0][1]);
  }
}
function __asyncDelegator(Ae) {
  var t, Ie;
  return t = {}, Me("next"), Me("throw", function(Be) {
    throw Be;
  }), Me("return"), t[Symbol.iterator] = function() {
    return this;
  }, t;
  function Me(Be, Pe) {
    t[Be] = Ae[Be] ? function(Te) {
      return (Ie = !Ie) ? { value: __await(Ae[Be](Te)), done: Be === "return" } : Pe ? Pe(Te) : Te;
    } : Pe;
  }
}
function __asyncValues(Ae) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = Ae[Symbol.asyncIterator], Ie;
  return t ? t.call(Ae) : (Ae = typeof __values == "function" ? __values(Ae) : Ae[Symbol.iterator](), Ie = {}, Me("next"), Me("throw"), Me("return"), Ie[Symbol.asyncIterator] = function() {
    return this;
  }, Ie);
  function Me(Pe) {
    Ie[Pe] = Ae[Pe] && function(Te) {
      return new Promise(function(je, Ve) {
        Te = Ae[Pe](Te), Be(je, Ve, Te.done, Te.value);
      });
    };
  }
  function Be(Pe, Te, je, Ve) {
    Promise.resolve(Ve).then(function(fi) {
      Pe({ value: fi, done: je });
    }, Te);
  }
}
function __makeTemplateObject(Ae, t) {
  return Object.defineProperty ? Object.defineProperty(Ae, "raw", { value: t }) : Ae.raw = t, Ae;
}
function __importStar(Ae) {
  if (Ae && Ae.__esModule) return Ae;
  var t = {};
  if (Ae != null) for (var Ie in Ae) Object.hasOwnProperty.call(Ae, Ie) && (t[Ie] = Ae[Ie]);
  return t.default = Ae, t;
}
function __importDefault(Ae) {
  return Ae && Ae.__esModule ? Ae : { default: Ae };
}
function __classPrivateFieldGet(Ae, t) {
  if (!t.has(Ae))
    throw new TypeError("attempted to get private field on non-instance");
  return t.get(Ae);
}
function __classPrivateFieldSet(Ae, t, Ie) {
  if (!t.has(Ae))
    throw new TypeError("attempted to set private field on non-instance");
  return t.set(Ae, Ie), Ie;
}
const tslib_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __read,
  __rest,
  __spread,
  __spreadArrays,
  __values
}, Symbol.toStringTag, { value: "Module" })), require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6);
var utils$n = {}, delay = {}, hasRequiredDelay;
function requireDelay() {
  if (hasRequiredDelay) return delay;
  hasRequiredDelay = 1, Object.defineProperty(delay, "__esModule", { value: !0 }), delay.delay = void 0;
  function Ae(t) {
    return new Promise((Ie) => {
      setTimeout(() => {
        Ie(!0);
      }, t);
    });
  }
  return delay.delay = Ae, delay;
}
var convert = {}, constants$1 = {}, misc = {}, hasRequiredMisc;
function requireMisc() {
  return hasRequiredMisc || (hasRequiredMisc = 1, Object.defineProperty(misc, "__esModule", { value: !0 }), misc.ONE_THOUSAND = misc.ONE_HUNDRED = void 0, misc.ONE_HUNDRED = 100, misc.ONE_THOUSAND = 1e3), misc;
}
var time = {}, hasRequiredTime;
function requireTime() {
  return hasRequiredTime || (hasRequiredTime = 1, function(Ae) {
    Object.defineProperty(Ae, "__esModule", { value: !0 }), Ae.ONE_YEAR = Ae.FOUR_WEEKS = Ae.THREE_WEEKS = Ae.TWO_WEEKS = Ae.ONE_WEEK = Ae.THIRTY_DAYS = Ae.SEVEN_DAYS = Ae.FIVE_DAYS = Ae.THREE_DAYS = Ae.ONE_DAY = Ae.TWENTY_FOUR_HOURS = Ae.TWELVE_HOURS = Ae.SIX_HOURS = Ae.THREE_HOURS = Ae.ONE_HOUR = Ae.SIXTY_MINUTES = Ae.THIRTY_MINUTES = Ae.TEN_MINUTES = Ae.FIVE_MINUTES = Ae.ONE_MINUTE = Ae.SIXTY_SECONDS = Ae.THIRTY_SECONDS = Ae.TEN_SECONDS = Ae.FIVE_SECONDS = Ae.ONE_SECOND = void 0, Ae.ONE_SECOND = 1, Ae.FIVE_SECONDS = 5, Ae.TEN_SECONDS = 10, Ae.THIRTY_SECONDS = 30, Ae.SIXTY_SECONDS = 60, Ae.ONE_MINUTE = Ae.SIXTY_SECONDS, Ae.FIVE_MINUTES = Ae.ONE_MINUTE * 5, Ae.TEN_MINUTES = Ae.ONE_MINUTE * 10, Ae.THIRTY_MINUTES = Ae.ONE_MINUTE * 30, Ae.SIXTY_MINUTES = Ae.ONE_MINUTE * 60, Ae.ONE_HOUR = Ae.SIXTY_MINUTES, Ae.THREE_HOURS = Ae.ONE_HOUR * 3, Ae.SIX_HOURS = Ae.ONE_HOUR * 6, Ae.TWELVE_HOURS = Ae.ONE_HOUR * 12, Ae.TWENTY_FOUR_HOURS = Ae.ONE_HOUR * 24, Ae.ONE_DAY = Ae.TWENTY_FOUR_HOURS, Ae.THREE_DAYS = Ae.ONE_DAY * 3, Ae.FIVE_DAYS = Ae.ONE_DAY * 5, Ae.SEVEN_DAYS = Ae.ONE_DAY * 7, Ae.THIRTY_DAYS = Ae.ONE_DAY * 30, Ae.ONE_WEEK = Ae.SEVEN_DAYS, Ae.TWO_WEEKS = Ae.ONE_WEEK * 2, Ae.THREE_WEEKS = Ae.ONE_WEEK * 3, Ae.FOUR_WEEKS = Ae.ONE_WEEK * 4, Ae.ONE_YEAR = Ae.ONE_DAY * 365;
  }(time)), time;
}
var hasRequiredConstants$1;
function requireConstants$1() {
  return hasRequiredConstants$1 || (hasRequiredConstants$1 = 1, function(Ae) {
    Object.defineProperty(Ae, "__esModule", { value: !0 });
    const t = require$$0$2;
    t.__exportStar(requireMisc(), Ae), t.__exportStar(requireTime(), Ae);
  }(constants$1)), constants$1;
}
var hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert) return convert;
  hasRequiredConvert = 1, Object.defineProperty(convert, "__esModule", { value: !0 }), convert.fromMiliseconds = convert.toMiliseconds = void 0;
  const Ae = requireConstants$1();
  function t(Me) {
    return Me * Ae.ONE_THOUSAND;
  }
  convert.toMiliseconds = t;
  function Ie(Me) {
    return Math.floor(Me / Ae.ONE_THOUSAND);
  }
  return convert.fromMiliseconds = Ie, convert;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function(Ae) {
    Object.defineProperty(Ae, "__esModule", { value: !0 });
    const t = require$$0$2;
    t.__exportStar(requireDelay(), Ae), t.__exportStar(requireConvert(), Ae);
  }(utils$n)), utils$n;
}
var watch$2 = {}, hasRequiredWatch$1;
function requireWatch$1() {
  if (hasRequiredWatch$1) return watch$2;
  hasRequiredWatch$1 = 1, Object.defineProperty(watch$2, "__esModule", { value: !0 }), watch$2.Watch = void 0;
  class Ae {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(Ie) {
      if (this.timestamps.has(Ie))
        throw new Error(`Watch already started for label: ${Ie}`);
      this.timestamps.set(Ie, { started: Date.now() });
    }
    stop(Ie) {
      const Me = this.get(Ie);
      if (typeof Me.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${Ie}`);
      const Be = Date.now() - Me.started;
      this.timestamps.set(Ie, { started: Me.started, elapsed: Be });
    }
    get(Ie) {
      const Me = this.timestamps.get(Ie);
      if (typeof Me > "u")
        throw new Error(`No timestamp found for label: ${Ie}`);
      return Me;
    }
    elapsed(Ie) {
      const Me = this.get(Ie);
      return Me.elapsed || Date.now() - Me.started;
    }
  }
  return watch$2.Watch = Ae, watch$2.default = Ae, watch$2;
}
var types$1 = {}, watch$1 = {}, hasRequiredWatch;
function requireWatch() {
  if (hasRequiredWatch) return watch$1;
  hasRequiredWatch = 1, Object.defineProperty(watch$1, "__esModule", { value: !0 }), watch$1.IWatch = void 0;
  class Ae {
  }
  return watch$1.IWatch = Ae, watch$1;
}
var hasRequiredTypes$1;
function requireTypes$1() {
  return hasRequiredTypes$1 || (hasRequiredTypes$1 = 1, function(Ae) {
    Object.defineProperty(Ae, "__esModule", { value: !0 }), require$$0$2.__exportStar(requireWatch(), Ae);
  }(types$1)), types$1;
}
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  const t = require$$0$2;
  t.__exportStar(requireUtils$1(), Ae), t.__exportStar(requireWatch$1(), Ae), t.__exportStar(requireTypes$1(), Ae), t.__exportStar(requireConstants$1(), Ae);
})(cjs$3);
class IEvents {
}
let n$3 = class extends IEvents {
  constructor(t) {
    super();
  }
};
const s$1 = cjs$3.FIVE_SECONDS, r$2 = { pulse: "heartbeat_pulse" };
let i$1 = class tf extends n$3 {
  constructor(t) {
    super(t), this.events = new eventsExports.EventEmitter(), this.interval = s$1, this.interval = (t == null ? void 0 : t.interval) || s$1;
  }
  static async init(t) {
    const Ie = new tf(t);
    return await Ie.init(), Ie;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(t, Ie) {
    this.events.on(t, Ie);
  }
  once(t, Ie) {
    this.events.once(t, Ie);
  }
  off(t, Ie) {
    this.events.off(t, Ie);
  }
  removeListener(t, Ie) {
    this.events.removeListener(t, Ie);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), cjs$3.toMiliseconds(this.interval));
  }
  pulse() {
    this.events.emit(r$2.pulse);
  }
};
const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(Ae, t) {
  if (Ae === "__proto__" || Ae === "constructor" && t && typeof t == "object" && "prototype" in t) {
    warnKeyDropped(Ae);
    return;
  }
  return t;
}
function warnKeyDropped(Ae) {
  console.warn(`[destr] Dropping "${Ae}" key to prevent prototype pollution.`);
}
function destr(Ae, t = {}) {
  if (typeof Ae != "string")
    return Ae;
  const Ie = Ae.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    Ae[0] === '"' && Ae.endsWith('"') && !Ae.includes("\\")
  )
    return Ie.slice(1, -1);
  if (Ie.length <= 9) {
    const Me = Ie.toLowerCase();
    if (Me === "true")
      return !0;
    if (Me === "false")
      return !1;
    if (Me === "undefined")
      return;
    if (Me === "null")
      return null;
    if (Me === "nan")
      return Number.NaN;
    if (Me === "infinity")
      return Number.POSITIVE_INFINITY;
    if (Me === "-infinity")
      return Number.NEGATIVE_INFINITY;
  }
  if (!JsonSigRx.test(Ae)) {
    if (t.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return Ae;
  }
  try {
    if (suspectProtoRx.test(Ae) || suspectConstructorRx.test(Ae)) {
      if (t.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(Ae, jsonParseTransform);
    }
    return JSON.parse(Ae);
  } catch (Me) {
    if (t.strict)
      throw Me;
    return Ae;
  }
}
function wrapToPromise(Ae) {
  return !Ae || typeof Ae.then != "function" ? Promise.resolve(Ae) : Ae;
}
function asyncCall(Ae, ...t) {
  try {
    return wrapToPromise(Ae(...t));
  } catch (Ie) {
    return Promise.reject(Ie);
  }
}
function isPrimitive(Ae) {
  const t = typeof Ae;
  return Ae === null || t !== "object" && t !== "function";
}
function isPureObject(Ae) {
  const t = Object.getPrototypeOf(Ae);
  return !t || t.isPrototypeOf(Object);
}
function stringify(Ae) {
  if (isPrimitive(Ae))
    return String(Ae);
  if (isPureObject(Ae) || Array.isArray(Ae))
    return JSON.stringify(Ae);
  if (typeof Ae.toJSON == "function")
    return stringify(Ae.toJSON());
  throw new Error("[unstorage] Cannot stringify value!");
}
function checkBufferSupport() {
  if (typeof Buffer > "u")
    throw new TypeError("[unstorage] Buffer is not supported!");
}
const BASE64_PREFIX = "base64:";
function serializeRaw(Ae) {
  if (typeof Ae == "string")
    return Ae;
  checkBufferSupport();
  const t = Buffer.from(Ae).toString("base64");
  return BASE64_PREFIX + t;
}
function deserializeRaw(Ae) {
  return typeof Ae != "string" || !Ae.startsWith(BASE64_PREFIX) ? Ae : (checkBufferSupport(), Buffer.from(Ae.slice(BASE64_PREFIX.length), "base64"));
}
function normalizeKey(Ae) {
  return Ae ? Ae.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : "";
}
function joinKeys(...Ae) {
  return normalizeKey(Ae.join(":"));
}
function normalizeBaseKey(Ae) {
  return Ae = normalizeKey(Ae), Ae ? Ae + ":" : "";
}
function defineDriver(Ae) {
  return Ae;
}
const DRIVER_NAME = "memory", memory = () => {
  const Ae = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => Ae,
    hasItem(t) {
      return Ae.has(t);
    },
    getItem(t) {
      return Ae.get(t) ?? null;
    },
    getItemRaw(t) {
      return Ae.get(t) ?? null;
    },
    setItem(t, Ie) {
      Ae.set(t, Ie);
    },
    setItemRaw(t, Ie) {
      Ae.set(t, Ie);
    },
    removeItem(t) {
      Ae.delete(t);
    },
    getKeys() {
      return [...Ae.keys()];
    },
    clear() {
      Ae.clear();
    },
    dispose() {
      Ae.clear();
    }
  };
};
function createStorage(Ae = {}) {
  const t = {
    mounts: { "": Ae.driver || memory() },
    mountpoints: [""],
    watching: !1,
    watchListeners: [],
    unwatch: {}
  }, Ie = (fi) => {
    for (const Ue of t.mountpoints)
      if (fi.startsWith(Ue))
        return {
          base: Ue,
          relativeKey: fi.slice(Ue.length),
          driver: t.mounts[Ue]
        };
    return {
      base: "",
      relativeKey: fi,
      driver: t.mounts[""]
    };
  }, Me = (fi, Ue) => t.mountpoints.filter(
    (bi) => bi.startsWith(fi) || Ue && fi.startsWith(bi)
  ).map((bi) => ({
    relativeBase: fi.length > bi.length ? fi.slice(bi.length) : void 0,
    mountpoint: bi,
    driver: t.mounts[bi]
  })), Be = (fi, Ue) => {
    if (t.watching) {
      Ue = normalizeKey(Ue);
      for (const bi of t.watchListeners)
        bi(fi, Ue);
    }
  }, Pe = async () => {
    if (!t.watching) {
      t.watching = !0;
      for (const fi in t.mounts)
        t.unwatch[fi] = await watch(
          t.mounts[fi],
          Be,
          fi
        );
    }
  }, Te = async () => {
    if (t.watching) {
      for (const fi in t.unwatch)
        await t.unwatch[fi]();
      t.unwatch = {}, t.watching = !1;
    }
  }, je = (fi, Ue, bi) => {
    const vi = /* @__PURE__ */ new Map(), mi = (_i) => {
      let Ei = vi.get(_i.base);
      return Ei || (Ei = {
        driver: _i.driver,
        base: _i.base,
        items: []
      }, vi.set(_i.base, Ei)), Ei;
    };
    for (const _i of fi) {
      const Ei = typeof _i == "string", Pi = normalizeKey(Ei ? _i : _i.key), Ii = Ei ? void 0 : _i.value, Ci = Ei || !_i.options ? Ue : { ...Ue, ..._i.options }, Wi = Ie(Pi);
      mi(Wi).items.push({
        key: Pi,
        value: Ii,
        relativeKey: Wi.relativeKey,
        options: Ci
      });
    }
    return Promise.all([...vi.values()].map((_i) => bi(_i))).then(
      (_i) => _i.flat()
    );
  }, Ve = {
    // Item
    hasItem(fi, Ue = {}) {
      fi = normalizeKey(fi);
      const { relativeKey: bi, driver: vi } = Ie(fi);
      return asyncCall(vi.hasItem, bi, Ue);
    },
    getItem(fi, Ue = {}) {
      fi = normalizeKey(fi);
      const { relativeKey: bi, driver: vi } = Ie(fi);
      return asyncCall(vi.getItem, bi, Ue).then(
        (mi) => destr(mi)
      );
    },
    getItems(fi, Ue) {
      return je(fi, Ue, (bi) => bi.driver.getItems ? asyncCall(
        bi.driver.getItems,
        bi.items.map((vi) => ({
          key: vi.relativeKey,
          options: vi.options
        })),
        Ue
      ).then(
        (vi) => vi.map((mi) => ({
          key: joinKeys(bi.base, mi.key),
          value: destr(mi.value)
        }))
      ) : Promise.all(
        bi.items.map((vi) => asyncCall(
          bi.driver.getItem,
          vi.relativeKey,
          vi.options
        ).then((mi) => ({
          key: vi.key,
          value: destr(mi)
        })))
      ));
    },
    getItemRaw(fi, Ue = {}) {
      fi = normalizeKey(fi);
      const { relativeKey: bi, driver: vi } = Ie(fi);
      return vi.getItemRaw ? asyncCall(vi.getItemRaw, bi, Ue) : asyncCall(vi.getItem, bi, Ue).then(
        (mi) => deserializeRaw(mi)
      );
    },
    async setItem(fi, Ue, bi = {}) {
      if (Ue === void 0)
        return Ve.removeItem(fi);
      fi = normalizeKey(fi);
      const { relativeKey: vi, driver: mi } = Ie(fi);
      mi.setItem && (await asyncCall(mi.setItem, vi, stringify(Ue), bi), mi.watch || Be("update", fi));
    },
    async setItems(fi, Ue) {
      await je(fi, Ue, async (bi) => {
        if (bi.driver.setItems)
          return asyncCall(
            bi.driver.setItems,
            bi.items.map((vi) => ({
              key: vi.relativeKey,
              value: stringify(vi.value),
              options: vi.options
            })),
            Ue
          );
        bi.driver.setItem && await Promise.all(
          bi.items.map((vi) => asyncCall(
            bi.driver.setItem,
            vi.relativeKey,
            stringify(vi.value),
            vi.options
          ))
        );
      });
    },
    async setItemRaw(fi, Ue, bi = {}) {
      if (Ue === void 0)
        return Ve.removeItem(fi, bi);
      fi = normalizeKey(fi);
      const { relativeKey: vi, driver: mi } = Ie(fi);
      if (mi.setItemRaw)
        await asyncCall(mi.setItemRaw, vi, Ue, bi);
      else if (mi.setItem)
        await asyncCall(mi.setItem, vi, serializeRaw(Ue), bi);
      else
        return;
      mi.watch || Be("update", fi);
    },
    async removeItem(fi, Ue = {}) {
      typeof Ue == "boolean" && (Ue = { removeMeta: Ue }), fi = normalizeKey(fi);
      const { relativeKey: bi, driver: vi } = Ie(fi);
      vi.removeItem && (await asyncCall(vi.removeItem, bi, Ue), (Ue.removeMeta || Ue.removeMata) && await asyncCall(vi.removeItem, bi + "$", Ue), vi.watch || Be("remove", fi));
    },
    // Meta
    async getMeta(fi, Ue = {}) {
      typeof Ue == "boolean" && (Ue = { nativeOnly: Ue }), fi = normalizeKey(fi);
      const { relativeKey: bi, driver: vi } = Ie(fi), mi = /* @__PURE__ */ Object.create(null);
      if (vi.getMeta && Object.assign(mi, await asyncCall(vi.getMeta, bi, Ue)), !Ue.nativeOnly) {
        const _i = await asyncCall(
          vi.getItem,
          bi + "$",
          Ue
        ).then((Ei) => destr(Ei));
        _i && typeof _i == "object" && (typeof _i.atime == "string" && (_i.atime = new Date(_i.atime)), typeof _i.mtime == "string" && (_i.mtime = new Date(_i.mtime)), Object.assign(mi, _i));
      }
      return mi;
    },
    setMeta(fi, Ue, bi = {}) {
      return this.setItem(fi + "$", Ue, bi);
    },
    removeMeta(fi, Ue = {}) {
      return this.removeItem(fi + "$", Ue);
    },
    // Keys
    async getKeys(fi, Ue = {}) {
      fi = normalizeBaseKey(fi);
      const bi = Me(fi, !0);
      let vi = [];
      const mi = [];
      for (const _i of bi) {
        const Ei = await asyncCall(
          _i.driver.getKeys,
          _i.relativeBase,
          Ue
        );
        for (const Pi of Ei) {
          const Ii = _i.mountpoint + normalizeKey(Pi);
          vi.some((Ci) => Ii.startsWith(Ci)) || mi.push(Ii);
        }
        vi = [
          _i.mountpoint,
          ...vi.filter((Pi) => !Pi.startsWith(_i.mountpoint))
        ];
      }
      return fi ? mi.filter(
        (_i) => _i.startsWith(fi) && _i[_i.length - 1] !== "$"
      ) : mi.filter((_i) => _i[_i.length - 1] !== "$");
    },
    // Utils
    async clear(fi, Ue = {}) {
      fi = normalizeBaseKey(fi), await Promise.all(
        Me(fi, !1).map(async (bi) => {
          if (bi.driver.clear)
            return asyncCall(bi.driver.clear, bi.relativeBase, Ue);
          if (bi.driver.removeItem) {
            const vi = await bi.driver.getKeys(bi.relativeBase || "", Ue);
            return Promise.all(
              vi.map((mi) => bi.driver.removeItem(mi, Ue))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(t.mounts).map((fi) => dispose(fi))
      );
    },
    async watch(fi) {
      return await Pe(), t.watchListeners.push(fi), async () => {
        t.watchListeners = t.watchListeners.filter(
          (Ue) => Ue !== fi
        ), t.watchListeners.length === 0 && await Te();
      };
    },
    async unwatch() {
      t.watchListeners = [], await Te();
    },
    // Mount
    mount(fi, Ue) {
      if (fi = normalizeBaseKey(fi), fi && t.mounts[fi])
        throw new Error(`already mounted at ${fi}`);
      return fi && (t.mountpoints.push(fi), t.mountpoints.sort((bi, vi) => vi.length - bi.length)), t.mounts[fi] = Ue, t.watching && Promise.resolve(watch(Ue, Be, fi)).then((bi) => {
        t.unwatch[fi] = bi;
      }).catch(console.error), Ve;
    },
    async unmount(fi, Ue = !0) {
      fi = normalizeBaseKey(fi), !(!fi || !t.mounts[fi]) && (t.watching && fi in t.unwatch && (t.unwatch[fi](), delete t.unwatch[fi]), Ue && await dispose(t.mounts[fi]), t.mountpoints = t.mountpoints.filter((bi) => bi !== fi), delete t.mounts[fi]);
    },
    getMount(fi = "") {
      fi = normalizeKey(fi) + ":";
      const Ue = Ie(fi);
      return {
        driver: Ue.driver,
        base: Ue.base
      };
    },
    getMounts(fi = "", Ue = {}) {
      return fi = normalizeKey(fi), Me(fi, Ue.parents).map((vi) => ({
        driver: vi.driver,
        base: vi.mountpoint
      }));
    },
    // Aliases
    keys: (fi, Ue = {}) => Ve.getKeys(fi, Ue),
    get: (fi, Ue = {}) => Ve.getItem(fi, Ue),
    set: (fi, Ue, bi = {}) => Ve.setItem(fi, Ue, bi),
    has: (fi, Ue = {}) => Ve.hasItem(fi, Ue),
    del: (fi, Ue = {}) => Ve.removeItem(fi, Ue),
    remove: (fi, Ue = {}) => Ve.removeItem(fi, Ue)
  };
  return Ve;
}
function watch(Ae, t, Ie) {
  return Ae.watch ? Ae.watch((Me, Be) => t(Me, Ie + Be)) : () => {
  };
}
async function dispose(Ae) {
  typeof Ae.dispose == "function" && await asyncCall(Ae.dispose);
}
function promisifyRequest(Ae) {
  return new Promise((t, Ie) => {
    Ae.oncomplete = Ae.onsuccess = () => t(Ae.result), Ae.onabort = Ae.onerror = () => Ie(Ae.error);
  });
}
function createStore(Ae, t) {
  const Ie = indexedDB.open(Ae);
  Ie.onupgradeneeded = () => Ie.result.createObjectStore(t);
  const Me = promisifyRequest(Ie);
  return (Be, Pe) => Me.then((Te) => Pe(Te.transaction(t, Be).objectStore(t)));
}
let defaultGetStoreFunc;
function defaultGetStore() {
  return defaultGetStoreFunc || (defaultGetStoreFunc = createStore("keyval-store", "keyval")), defaultGetStoreFunc;
}
function get(Ae, t = defaultGetStore()) {
  return t("readonly", (Ie) => promisifyRequest(Ie.get(Ae)));
}
function set$1(Ae, t, Ie = defaultGetStore()) {
  return Ie("readwrite", (Me) => (Me.put(t, Ae), promisifyRequest(Me.transaction)));
}
function del(Ae, t = defaultGetStore()) {
  return t("readwrite", (Ie) => (Ie.delete(Ae), promisifyRequest(Ie.transaction)));
}
function clear(Ae = defaultGetStore()) {
  return Ae("readwrite", (t) => (t.clear(), promisifyRequest(t.transaction)));
}
function eachCursor(Ae, t) {
  return Ae.openCursor().onsuccess = function() {
    this.result && (t(this.result), this.result.continue());
  }, promisifyRequest(Ae.transaction);
}
function keys(Ae = defaultGetStore()) {
  return Ae("readonly", (t) => {
    if (t.getAllKeys)
      return promisifyRequest(t.getAllKeys());
    const Ie = [];
    return eachCursor(t, (Me) => Ie.push(Me.key)).then(() => Ie);
  });
}
const JSONStringify = (Ae) => JSON.stringify(Ae, (t, Ie) => typeof Ie == "bigint" ? Ie.toString() + "n" : Ie), JSONParse = (Ae) => {
  const t = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, Ie = Ae.replace(t, '$1"$2n"$3');
  return JSON.parse(Ie, (Me, Be) => typeof Be == "string" && Be.match(/^\d+n$/) ? BigInt(Be.substring(0, Be.length - 1)) : Be);
};
function safeJsonParse(Ae) {
  if (typeof Ae != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof Ae}`);
  try {
    return JSONParse(Ae);
  } catch {
    return Ae;
  }
}
function safeJsonStringify(Ae) {
  return typeof Ae == "string" ? Ae : JSONStringify(Ae) || "";
}
const x$6 = "idb-keyval";
var z$6 = (Ae = {}) => {
  const t = Ae.base && Ae.base.length > 0 ? `${Ae.base}:` : "", Ie = (Be) => t + Be;
  let Me;
  return Ae.dbName && Ae.storeName && (Me = createStore(Ae.dbName, Ae.storeName)), { name: x$6, options: Ae, async hasItem(Be) {
    return !(typeof await get(Ie(Be), Me) > "u");
  }, async getItem(Be) {
    return await get(Ie(Be), Me) ?? null;
  }, setItem(Be, Pe) {
    return set$1(Ie(Be), Pe, Me);
  }, removeItem(Be) {
    return del(Ie(Be), Me);
  }, getKeys() {
    return keys(Me);
  }, clear() {
    return clear(Me);
  } };
};
const D$3 = "WALLET_CONNECT_V2_INDEXED_DB", E$2 = "keyvaluestorage";
let _$3 = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z$6({ dbName: D$3, storeName: E$2 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const Ie = await this.indexedDb.getItem(t);
    if (Ie !== null) return Ie;
  }
  async setItem(t, Ie) {
    await this.indexedDb.setItem(t, safeJsonStringify(Ie));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l$2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, c$2 = { exports: {} };
(function() {
  let Ae;
  function t() {
  }
  Ae = t, Ae.prototype.getItem = function(Ie) {
    return this.hasOwnProperty(Ie) ? String(this[Ie]) : null;
  }, Ae.prototype.setItem = function(Ie, Me) {
    this[Ie] = String(Me);
  }, Ae.prototype.removeItem = function(Ie) {
    delete this[Ie];
  }, Ae.prototype.clear = function() {
    const Ie = this;
    Object.keys(Ie).forEach(function(Me) {
      Ie[Me] = void 0, delete Ie[Me];
    });
  }, Ae.prototype.key = function(Ie) {
    return Ie = Ie || 0, Object.keys(this)[Ie];
  }, Ae.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l$2 < "u" && l$2.localStorage ? c$2.exports = l$2.localStorage : typeof window < "u" && window.localStorage ? c$2.exports = window.localStorage : c$2.exports = new t();
})();
function k$3(Ae) {
  var t;
  return [Ae[0], safeJsonParse((t = Ae[1]) != null ? t : "")];
}
let K$4 = class {
  constructor() {
    this.localStorage = c$2.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k$3);
  }
  async getItem(t) {
    const Ie = this.localStorage.getItem(t);
    if (Ie !== null) return safeJsonParse(Ie);
  }
  async setItem(t, Ie) {
    this.localStorage.setItem(t, safeJsonStringify(Ie));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
const N$1 = "wc_storage_version", y$4 = 1, O$5 = async (Ae, t, Ie) => {
  const Me = N$1, Be = await t.getItem(Me);
  if (Be && Be >= y$4) {
    Ie(t);
    return;
  }
  const Pe = await Ae.getKeys();
  if (!Pe.length) {
    Ie(t);
    return;
  }
  const Te = [];
  for (; Pe.length; ) {
    const je = Pe.shift();
    if (!je) continue;
    const Ve = je.toLowerCase();
    if (Ve.includes("wc@") || Ve.includes("walletconnect") || Ve.includes("wc_") || Ve.includes("wallet_connect")) {
      const fi = await Ae.getItem(je);
      await t.setItem(je, fi), Te.push(je);
    }
  }
  await t.setItem(Me, y$4), Ie(t), j$2(Ae, Te);
}, j$2 = async (Ae, t) => {
  t.length && t.forEach(async (Ie) => {
    await Ae.removeItem(Ie);
  });
};
let h$2 = class {
  constructor() {
    this.initialized = !1, this.setInitialized = (Ie) => {
      this.storage = Ie, this.initialized = !0;
    };
    const t = new K$4();
    this.storage = t;
    try {
      const Ie = new _$3();
      O$5(t, Ie, this.setInitialized);
    } catch {
      this.initialized = !0;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, Ie) {
    return await this.initialize(), this.storage.setItem(t, Ie);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const Ie = setInterval(() => {
        this.initialized && (clearInterval(Ie), t());
      }, 20);
    });
  }
};
function tryStringify(Ae) {
  try {
    return JSON.stringify(Ae);
  } catch {
    return '"[Circular]"';
  }
}
var quickFormatUnescaped = format$1;
function format$1(Ae, t, Ie) {
  var Me = Ie && Ie.stringify || tryStringify, Be = 1;
  if (typeof Ae == "object" && Ae !== null) {
    var Pe = t.length + Be;
    if (Pe === 1) return Ae;
    var Te = new Array(Pe);
    Te[0] = Me(Ae);
    for (var je = 1; je < Pe; je++)
      Te[je] = Me(t[je]);
    return Te.join(" ");
  }
  if (typeof Ae != "string")
    return Ae;
  var Ve = t.length;
  if (Ve === 0) return Ae;
  for (var fi = "", Ue = 1 - Be, bi = -1, vi = Ae && Ae.length || 0, mi = 0; mi < vi; ) {
    if (Ae.charCodeAt(mi) === 37 && mi + 1 < vi) {
      switch (bi = bi > -1 ? bi : 0, Ae.charCodeAt(mi + 1)) {
        case 100:
        case 102:
          if (Ue >= Ve || t[Ue] == null) break;
          bi < mi && (fi += Ae.slice(bi, mi)), fi += Number(t[Ue]), bi = mi + 2, mi++;
          break;
        case 105:
          if (Ue >= Ve || t[Ue] == null) break;
          bi < mi && (fi += Ae.slice(bi, mi)), fi += Math.floor(Number(t[Ue])), bi = mi + 2, mi++;
          break;
        case 79:
        case 111:
        case 106:
          if (Ue >= Ve || t[Ue] === void 0) break;
          bi < mi && (fi += Ae.slice(bi, mi));
          var _i = typeof t[Ue];
          if (_i === "string") {
            fi += "'" + t[Ue] + "'", bi = mi + 2, mi++;
            break;
          }
          if (_i === "function") {
            fi += t[Ue].name || "<anonymous>", bi = mi + 2, mi++;
            break;
          }
          fi += Me(t[Ue]), bi = mi + 2, mi++;
          break;
        case 115:
          if (Ue >= Ve)
            break;
          bi < mi && (fi += Ae.slice(bi, mi)), fi += String(t[Ue]), bi = mi + 2, mi++;
          break;
        case 37:
          bi < mi && (fi += Ae.slice(bi, mi)), fi += "%", bi = mi + 2, mi++, Ue--;
          break;
      }
      ++Ue;
    }
    ++mi;
  }
  return bi === -1 ? Ae : (bi < vi && (fi += Ae.slice(bi)), fi);
}
const format = quickFormatUnescaped;
var browser$e = pino;
const _console = pfGlobalThisOrFallback().console || {}, stdSerializers = {
  mapHttpRequest: mock,
  mapHttpResponse: mock,
  wrapRequestSerializer: passthrough,
  wrapResponseSerializer: passthrough,
  wrapErrorSerializer: passthrough,
  req: mock,
  res: mock,
  err: asErrValue
};
function shouldSerialize(Ae, t) {
  return Array.isArray(Ae) ? Ae.filter(function(Me) {
    return Me !== "!stdSerializers.err";
  }) : Ae === !0 ? Object.keys(t) : !1;
}
function pino(Ae) {
  Ae = Ae || {}, Ae.browser = Ae.browser || {};
  const t = Ae.browser.transmit;
  if (t && typeof t.send != "function")
    throw Error("pino: transmit option must have a send function");
  const Ie = Ae.browser.write || _console;
  Ae.browser.write && (Ae.browser.asObject = !0);
  const Me = Ae.serializers || {}, Be = shouldSerialize(Ae.browser.serialize, Me);
  let Pe = Ae.browser.serialize;
  Array.isArray(Ae.browser.serialize) && Ae.browser.serialize.indexOf("!stdSerializers.err") > -1 && (Pe = !1);
  const Te = ["error", "fatal", "warn", "info", "debug", "trace"];
  typeof Ie == "function" && (Ie.error = Ie.fatal = Ie.warn = Ie.info = Ie.debug = Ie.trace = Ie), Ae.enabled === !1 && (Ae.level = "silent");
  const je = Ae.level || "info", Ve = Object.create(Ie);
  Ve.log || (Ve.log = noop), Object.defineProperty(Ve, "levelVal", {
    get: Ue
  }), Object.defineProperty(Ve, "level", {
    get: bi,
    set: vi
  });
  const fi = {
    transmit: t,
    serialize: Be,
    asObject: Ae.browser.asObject,
    levels: Te,
    timestamp: getTimeFunction(Ae)
  };
  Ve.levels = pino.levels, Ve.level = je, Ve.setMaxListeners = Ve.getMaxListeners = Ve.emit = Ve.addListener = Ve.on = Ve.prependListener = Ve.once = Ve.prependOnceListener = Ve.removeListener = Ve.removeAllListeners = Ve.listeners = Ve.listenerCount = Ve.eventNames = Ve.write = Ve.flush = noop, Ve.serializers = Me, Ve._serialize = Be, Ve._stdErrSerialize = Pe, Ve.child = mi, t && (Ve._logEvent = createLogEventShape());
  function Ue() {
    return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
  }
  function bi() {
    return this._level;
  }
  function vi(_i) {
    if (_i !== "silent" && !this.levels.values[_i])
      throw Error("unknown level " + _i);
    this._level = _i, set(fi, Ve, "error", "log"), set(fi, Ve, "fatal", "error"), set(fi, Ve, "warn", "error"), set(fi, Ve, "info", "log"), set(fi, Ve, "debug", "log"), set(fi, Ve, "trace", "log");
  }
  function mi(_i, Ei) {
    if (!_i)
      throw new Error("missing bindings for child Pino");
    Ei = Ei || {}, Be && _i.serializers && (Ei.serializers = _i.serializers);
    const Pi = Ei.serializers;
    if (Be && Pi) {
      var Ii = Object.assign({}, Me, Pi), Ci = Ae.browser.serialize === !0 ? Object.keys(Ii) : Be;
      delete _i.serializers, applySerializers([_i], Ci, Ii, this._stdErrSerialize);
    }
    function Wi(zi) {
      this._childLevel = (zi._childLevel | 0) + 1, this.error = bind(zi, _i, "error"), this.fatal = bind(zi, _i, "fatal"), this.warn = bind(zi, _i, "warn"), this.info = bind(zi, _i, "info"), this.debug = bind(zi, _i, "debug"), this.trace = bind(zi, _i, "trace"), Ii && (this.serializers = Ii, this._serialize = Ci), t && (this._logEvent = createLogEventShape(
        [].concat(zi._logEvent.bindings, _i)
      ));
    }
    return Wi.prototype = this, new Wi(this);
  }
  return Ve;
}
pino.levels = {
  values: {
    fatal: 60,
    error: 50,
    warn: 40,
    info: 30,
    debug: 20,
    trace: 10
  },
  labels: {
    10: "trace",
    20: "debug",
    30: "info",
    40: "warn",
    50: "error",
    60: "fatal"
  }
};
pino.stdSerializers = stdSerializers;
pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
function set(Ae, t, Ie, Me) {
  const Be = Object.getPrototypeOf(t);
  t[Ie] = t.levelVal > t.levels.values[Ie] ? noop : Be[Ie] ? Be[Ie] : _console[Ie] || _console[Me] || noop, wrap(Ae, t, Ie);
}
function wrap(Ae, t, Ie) {
  !Ae.transmit && t[Ie] === noop || (t[Ie] = /* @__PURE__ */ function(Me) {
    return function() {
      const Pe = Ae.timestamp(), Te = new Array(arguments.length), je = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
      for (var Ve = 0; Ve < Te.length; Ve++) Te[Ve] = arguments[Ve];
      if (Ae.serialize && !Ae.asObject && applySerializers(Te, this._serialize, this.serializers, this._stdErrSerialize), Ae.asObject ? Me.call(je, asObject(this, Ie, Te, Pe)) : Me.apply(je, Te), Ae.transmit) {
        const fi = Ae.transmit.level || t.level, Ue = pino.levels.values[fi], bi = pino.levels.values[Ie];
        if (bi < Ue) return;
        transmit(this, {
          ts: Pe,
          methodLevel: Ie,
          methodValue: bi,
          transmitLevel: fi,
          transmitValue: pino.levels.values[Ae.transmit.level || t.level],
          send: Ae.transmit.send,
          val: t.levelVal
        }, Te);
      }
    };
  }(t[Ie]));
}
function asObject(Ae, t, Ie, Me) {
  Ae._serialize && applySerializers(Ie, Ae._serialize, Ae.serializers, Ae._stdErrSerialize);
  const Be = Ie.slice();
  let Pe = Be[0];
  const Te = {};
  Me && (Te.time = Me), Te.level = pino.levels.values[t];
  let je = (Ae._childLevel | 0) + 1;
  if (je < 1 && (je = 1), Pe !== null && typeof Pe == "object") {
    for (; je-- && typeof Be[0] == "object"; )
      Object.assign(Te, Be.shift());
    Pe = Be.length ? format(Be.shift(), Be) : void 0;
  } else typeof Pe == "string" && (Pe = format(Be.shift(), Be));
  return Pe !== void 0 && (Te.msg = Pe), Te;
}
function applySerializers(Ae, t, Ie, Me) {
  for (const Be in Ae)
    if (Me && Ae[Be] instanceof Error)
      Ae[Be] = pino.stdSerializers.err(Ae[Be]);
    else if (typeof Ae[Be] == "object" && !Array.isArray(Ae[Be]))
      for (const Pe in Ae[Be])
        t && t.indexOf(Pe) > -1 && Pe in Ie && (Ae[Be][Pe] = Ie[Pe](Ae[Be][Pe]));
}
function bind(Ae, t, Ie) {
  return function() {
    const Me = new Array(1 + arguments.length);
    Me[0] = t;
    for (var Be = 1; Be < Me.length; Be++)
      Me[Be] = arguments[Be - 1];
    return Ae[Ie].apply(this, Me);
  };
}
function transmit(Ae, t, Ie) {
  const Me = t.send, Be = t.ts, Pe = t.methodLevel, Te = t.methodValue, je = t.val, Ve = Ae._logEvent.bindings;
  applySerializers(
    Ie,
    Ae._serialize || Object.keys(Ae.serializers),
    Ae.serializers,
    Ae._stdErrSerialize === void 0 ? !0 : Ae._stdErrSerialize
  ), Ae._logEvent.ts = Be, Ae._logEvent.messages = Ie.filter(function(fi) {
    return Ve.indexOf(fi) === -1;
  }), Ae._logEvent.level.label = Pe, Ae._logEvent.level.value = Te, Me(Pe, Ae._logEvent, je), Ae._logEvent = createLogEventShape(Ve);
}
function createLogEventShape(Ae) {
  return {
    ts: 0,
    messages: [],
    bindings: Ae || [],
    level: { label: "", value: 0 }
  };
}
function asErrValue(Ae) {
  const t = {
    type: Ae.constructor.name,
    msg: Ae.message,
    stack: Ae.stack
  };
  for (const Ie in Ae)
    t[Ie] === void 0 && (t[Ie] = Ae[Ie]);
  return t;
}
function getTimeFunction(Ae) {
  return typeof Ae.timestamp == "function" ? Ae.timestamp : Ae.timestamp === !1 ? nullTime : epochTime;
}
function mock() {
  return {};
}
function passthrough(Ae) {
  return Ae;
}
function noop() {
}
function nullTime() {
  return !1;
}
function epochTime() {
  return Date.now();
}
function unixTime() {
  return Math.round(Date.now() / 1e3);
}
function isoTime() {
  return new Date(Date.now()).toISOString();
}
function pfGlobalThisOrFallback() {
  function Ae(t) {
    return typeof t < "u" && t;
  }
  try {
    return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
      get: function() {
        return delete Object.prototype.globalThis, this.globalThis = this;
      },
      configurable: !0
    }), globalThis;
  } catch {
    return Ae(self) || Ae(window) || Ae(this) || {};
  }
}
const qt$3 = /* @__PURE__ */ getDefaultExportFromCjs(browser$e), c$1 = { level: "info" }, n$2 = "custom_context", l$1 = 1e3 * 1024;
let O$4 = class {
  constructor(t) {
    this.nodeValue = t, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
}, d$2 = class {
  constructor(t) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = t, this.sizeInBytes = 0;
  }
  append(t) {
    const Ie = new O$4(t);
    if (Ie.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${t} with size ${Ie.size}`);
    for (; this.size + Ie.size > this.maxSizeInBytes; ) this.shift();
    this.head ? (this.tail && (this.tail.next = Ie), this.tail = Ie) : (this.head = Ie, this.tail = Ie), this.lengthInNodes++, this.sizeInBytes += Ie.size;
  }
  shift() {
    if (!this.head) return;
    const t = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= t.size;
  }
  toArray() {
    const t = [];
    let Ie = this.head;
    for (; Ie !== null; ) t.push(Ie.value), Ie = Ie.next;
    return t;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let t = this.head;
    return { next: () => {
      if (!t) return { done: !0, value: null };
      const Ie = t.value;
      return t = t.next, { done: !1, value: Ie };
    } };
  }
}, L$3 = class {
  constructor(t, Ie = l$1) {
    this.level = t ?? "error", this.levelValue = browser$e.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = Ie, this.logs = new d$2(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(t, Ie) {
    Ie === browser$e.levels.values.error ? console.error(t) : Ie === browser$e.levels.values.warn ? console.warn(t) : Ie === browser$e.levels.values.debug ? console.debug(t) : Ie === browser$e.levels.values.trace ? console.trace(t) : console.log(t);
  }
  appendToLogs(t) {
    this.logs.append(safeJsonStringify({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: t }));
    const Ie = typeof t == "string" ? JSON.parse(t).level : t.level;
    Ie >= this.levelValue && this.forwardToConsole(t, Ie);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new d$2(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(t) {
    const Ie = this.getLogArray();
    return Ie.push(safeJsonStringify({ extraMetadata: t })), new Blob(Ie, { type: "application/json" });
  }
};
class m {
  constructor(t, Ie = l$1) {
    this.baseChunkLogger = new L$3(t, Ie);
  }
  write(t) {
    this.baseChunkLogger.appendToLogs(t);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(t) {
    return this.baseChunkLogger.logsToBlob(t);
  }
  downloadLogsBlobInBrowser(t) {
    const Ie = URL.createObjectURL(this.logsToBlob(t)), Me = document.createElement("a");
    Me.href = Ie, Me.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(Me), Me.click(), document.body.removeChild(Me), URL.revokeObjectURL(Ie);
  }
}
let B$3 = class {
  constructor(t, Ie = l$1) {
    this.baseChunkLogger = new L$3(t, Ie);
  }
  write(t) {
    this.baseChunkLogger.appendToLogs(t);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(t) {
    return this.baseChunkLogger.logsToBlob(t);
  }
};
var x$5 = Object.defineProperty, S$6 = Object.defineProperties, _$2 = Object.getOwnPropertyDescriptors, p$2 = Object.getOwnPropertySymbols, T$2 = Object.prototype.hasOwnProperty, z$5 = Object.prototype.propertyIsEnumerable, f$4 = (Ae, t, Ie) => t in Ae ? x$5(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, i = (Ae, t) => {
  for (var Ie in t || (t = {})) T$2.call(t, Ie) && f$4(Ae, Ie, t[Ie]);
  if (p$2) for (var Ie of p$2(t)) z$5.call(t, Ie) && f$4(Ae, Ie, t[Ie]);
  return Ae;
}, g$3 = (Ae, t) => S$6(Ae, _$2(t));
function k$2(Ae) {
  return g$3(i({}, Ae), { level: (Ae == null ? void 0 : Ae.level) || c$1.level });
}
function v$4(Ae, t = n$2) {
  return Ae[t] || "";
}
function b$3(Ae, t, Ie = n$2) {
  return Ae[Ie] = t, Ae;
}
function y$3(Ae, t = n$2) {
  let Ie = "";
  return typeof Ae.bindings > "u" ? Ie = v$4(Ae, t) : Ie = Ae.bindings().context || "", Ie;
}
function w$2(Ae, t, Ie = n$2) {
  const Me = y$3(Ae, Ie);
  return Me.trim() ? `${Me}/${t}` : t;
}
function E$1(Ae, t, Ie = n$2) {
  const Me = w$2(Ae, t, Ie), Be = Ae.child({ context: Me });
  return b$3(Be, Me, Ie);
}
function C$4(Ae) {
  var t, Ie;
  const Me = new m((t = Ae.opts) == null ? void 0 : t.level, Ae.maxSizeInBytes);
  return { logger: qt$3(g$3(i({}, Ae.opts), { level: "trace", browser: g$3(i({}, (Ie = Ae.opts) == null ? void 0 : Ie.browser), { write: (Be) => Me.write(Be) }) })), chunkLoggerController: Me };
}
function I$4(Ae) {
  var t;
  const Ie = new B$3((t = Ae.opts) == null ? void 0 : t.level, Ae.maxSizeInBytes);
  return { logger: qt$3(g$3(i({}, Ae.opts), { level: "trace" }), Ie), chunkLoggerController: Ie };
}
function A$1(Ae) {
  return typeof Ae.loggerOverride < "u" && typeof Ae.loggerOverride != "string" ? { logger: Ae.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? C$4(Ae) : I$4(Ae);
}
let n$1 = class extends IEvents {
  constructor(t) {
    super(), this.opts = t, this.protocol = "wc", this.version = 2;
  }
}, h$1 = class extends IEvents {
  constructor(t, Ie) {
    super(), this.core = t, this.logger = Ie, this.records = /* @__PURE__ */ new Map();
  }
}, a$1 = class {
  constructor(t, Ie) {
    this.logger = t, this.core = Ie;
  }
}, g$2 = class extends IEvents {
  constructor(t, Ie) {
    super(), this.relayer = t, this.logger = Ie;
  }
};
class u extends IEvents {
  constructor(t) {
    super();
  }
}
let p$1 = class {
  constructor(t, Ie, Me, Be) {
    this.core = t, this.logger = Ie, this.name = Me;
  }
}, d$1 = class extends IEvents {
  constructor(t, Ie) {
    super(), this.relayer = t, this.logger = Ie;
  }
}, x$4 = class extends IEvents {
  constructor(t, Ie) {
    super(), this.core = t, this.logger = Ie;
  }
}, y$2 = class {
  constructor(t, Ie, Me) {
    this.core = t, this.logger = Ie, this.store = Me;
  }
}, v$3 = class {
  constructor(t, Ie) {
    this.projectId = t, this.logger = Ie;
  }
}, C$3 = class {
  constructor(t, Ie, Me) {
    this.core = t, this.logger = Ie, this.telemetryEnabled = Me;
  }
}, S$5 = class {
  constructor(t) {
    this.opts = t, this.protocol = "wc", this.version = 2;
  }
}, M$3 = class {
  constructor(t) {
    this.client = t;
  }
};
var ed25519 = {}, random = {}, system = {}, browser$d = {};
Object.defineProperty(browser$d, "__esModule", { value: !0 });
browser$d.BrowserRandomSource = void 0;
const QUOTA = 65536;
class BrowserRandomSource {
  constructor() {
    this.isAvailable = !1, this.isInstantiated = !1;
    const t = typeof self < "u" ? self.crypto || self.msCrypto : null;
    t && t.getRandomValues !== void 0 && (this._crypto = t, this.isAvailable = !0, this.isInstantiated = !0);
  }
  randomBytes(t) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Browser random byte generator is not available.");
    const Ie = new Uint8Array(t);
    for (let Me = 0; Me < Ie.length; Me += QUOTA)
      this._crypto.getRandomValues(Ie.subarray(Me, Me + Math.min(Ie.length - Me, QUOTA)));
    return Ie;
  }
}
browser$d.BrowserRandomSource = BrowserRandomSource;
function commonjsRequire$1(Ae) {
  throw new Error('Could not dynamically require "' + Ae + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var node$1 = {}, wipe$1 = {};
Object.defineProperty(wipe$1, "__esModule", { value: !0 });
function wipe(Ae) {
  for (var t = 0; t < Ae.length; t++)
    Ae[t] = 0;
  return Ae;
}
wipe$1.wipe = wipe;
var cryptoBrowserify = {}, browser$c = { exports: {} }, safeBuffer$1 = { exports: {} };
const require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(dist);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer$1;
function requireSafeBuffer$1() {
  return hasRequiredSafeBuffer$1 || (hasRequiredSafeBuffer$1 = 1, function(Ae, t) {
    var Ie = require$$1$2, Me = Ie.Buffer;
    function Be(Te, je) {
      for (var Ve in Te)
        je[Ve] = Te[Ve];
    }
    Me.from && Me.alloc && Me.allocUnsafe && Me.allocUnsafeSlow ? Ae.exports = Ie : (Be(Ie, t), t.Buffer = Pe);
    function Pe(Te, je, Ve) {
      return Me(Te, je, Ve);
    }
    Pe.prototype = Object.create(Me.prototype), Be(Me, Pe), Pe.from = function(Te, je, Ve) {
      if (typeof Te == "number")
        throw new TypeError("Argument must not be a number");
      return Me(Te, je, Ve);
    }, Pe.alloc = function(Te, je, Ve) {
      if (typeof Te != "number")
        throw new TypeError("Argument must be a number");
      var fi = Me(Te);
      return je !== void 0 ? typeof Ve == "string" ? fi.fill(je, Ve) : fi.fill(je) : fi.fill(0), fi;
    }, Pe.allocUnsafe = function(Te) {
      if (typeof Te != "number")
        throw new TypeError("Argument must be a number");
      return Me(Te);
    }, Pe.allocUnsafeSlow = function(Te) {
      if (typeof Te != "number")
        throw new TypeError("Argument must be a number");
      return Ie.SlowBuffer(Te);
    };
  }(safeBuffer$1, safeBuffer$1.exports)), safeBuffer$1.exports;
}
var hasRequiredBrowser$b;
function requireBrowser$b() {
  if (hasRequiredBrowser$b) return browser$c.exports;
  hasRequiredBrowser$b = 1;
  var Ae = 65536, t = 4294967295;
  function Ie() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var Me = requireSafeBuffer$1().Buffer, Be = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  Be && Be.getRandomValues ? browser$c.exports = Pe : browser$c.exports = Ie;
  function Pe(Te, je) {
    if (Te > t) throw new RangeError("requested too many random bytes");
    var Ve = Me.allocUnsafe(Te);
    if (Te > 0)
      if (Te > Ae)
        for (var fi = 0; fi < Te; fi += Ae)
          Be.getRandomValues(Ve.slice(fi, fi + Ae));
      else
        Be.getRandomValues(Ve);
    return typeof je == "function" ? process$1.nextTick(function() {
      je(null, Ve);
    }) : Ve;
  }
  return browser$c.exports;
}
var inherits_browser$1 = { exports: {} };
typeof Object.create == "function" ? inherits_browser$1.exports = function(t, Ie) {
  Ie && (t.super_ = Ie, t.prototype = Object.create(Ie.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser$1.exports = function(t, Ie) {
  if (Ie) {
    t.super_ = Ie;
    var Me = function() {
    };
    Me.prototype = Ie.prototype, t.prototype = new Me(), t.prototype.constructor = t;
  }
};
var inherits_browserExports = inherits_browser$1.exports, streamBrowser$1, hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
  return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1, streamBrowser$1 = eventsExports.EventEmitter), streamBrowser$1;
}
var util$1 = {}, types = {}, shams$1, hasRequiredShams$1;
function requireShams$1() {
  return hasRequiredShams$1 || (hasRequiredShams$1 = 1, shams$1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var t = {}, Ie = Symbol("test"), Me = Object(Ie);
    if (typeof Ie == "string" || Object.prototype.toString.call(Ie) !== "[object Symbol]" || Object.prototype.toString.call(Me) !== "[object Symbol]")
      return !1;
    var Be = 42;
    t[Ie] = Be;
    for (Ie in t)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
      return !1;
    var Pe = Object.getOwnPropertySymbols(t);
    if (Pe.length !== 1 || Pe[0] !== Ie || !Object.prototype.propertyIsEnumerable.call(t, Ie))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var Te = Object.getOwnPropertyDescriptor(t, Ie);
      if (Te.value !== Be || Te.enumerable !== !0)
        return !1;
    }
    return !0;
  }), shams$1;
}
var shams, hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var Ae = requireShams$1();
  return shams = function() {
    return Ae() && !!Symbol.toStringTag;
  }, shams;
}
var esErrors, hasRequiredEsErrors;
function requireEsErrors() {
  return hasRequiredEsErrors || (hasRequiredEsErrors = 1, esErrors = Error), esErrors;
}
var _eval, hasRequired_eval;
function require_eval() {
  return hasRequired_eval || (hasRequired_eval = 1, _eval = EvalError), _eval;
}
var range, hasRequiredRange;
function requireRange() {
  return hasRequiredRange || (hasRequiredRange = 1, range = RangeError), range;
}
var ref, hasRequiredRef;
function requireRef() {
  return hasRequiredRef || (hasRequiredRef = 1, ref = ReferenceError), ref;
}
var syntax, hasRequiredSyntax;
function requireSyntax() {
  return hasRequiredSyntax || (hasRequiredSyntax = 1, syntax = SyntaxError), syntax;
}
var type, hasRequiredType;
function requireType() {
  return hasRequiredType || (hasRequiredType = 1, type = TypeError), type;
}
var uri, hasRequiredUri;
function requireUri() {
  return hasRequiredUri || (hasRequiredUri = 1, uri = URIError), uri;
}
var hasSymbols, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var Ae = typeof Symbol < "u" && Symbol, t = requireShams$1();
  return hasSymbols = function() {
    return typeof Ae != "function" || typeof Symbol != "function" || typeof Ae("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, hasSymbols;
}
var hasProto, hasRequiredHasProto;
function requireHasProto() {
  if (hasRequiredHasProto) return hasProto;
  hasRequiredHasProto = 1;
  var Ae = {
    __proto__: null,
    foo: {}
  }, t = Object;
  return hasProto = function() {
    return { __proto__: Ae }.foo === Ae.foo && !(Ae instanceof t);
  }, hasProto;
}
var implementation, hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var Ae = "Function.prototype.bind called on incompatible ", t = Object.prototype.toString, Ie = Math.max, Me = "[object Function]", Be = function(Ve, fi) {
    for (var Ue = [], bi = 0; bi < Ve.length; bi += 1)
      Ue[bi] = Ve[bi];
    for (var vi = 0; vi < fi.length; vi += 1)
      Ue[vi + Ve.length] = fi[vi];
    return Ue;
  }, Pe = function(Ve, fi) {
    for (var Ue = [], bi = fi, vi = 0; bi < Ve.length; bi += 1, vi += 1)
      Ue[vi] = Ve[bi];
    return Ue;
  }, Te = function(je, Ve) {
    for (var fi = "", Ue = 0; Ue < je.length; Ue += 1)
      fi += je[Ue], Ue + 1 < je.length && (fi += Ve);
    return fi;
  };
  return implementation = function(Ve) {
    var fi = this;
    if (typeof fi != "function" || t.apply(fi) !== Me)
      throw new TypeError(Ae + fi);
    for (var Ue = Pe(arguments, 1), bi, vi = function() {
      if (this instanceof bi) {
        var Ii = fi.apply(
          this,
          Be(Ue, arguments)
        );
        return Object(Ii) === Ii ? Ii : this;
      }
      return fi.apply(
        Ve,
        Be(Ue, arguments)
      );
    }, mi = Ie(0, fi.length - Ue.length), _i = [], Ei = 0; Ei < mi; Ei++)
      _i[Ei] = "$" + Ei;
    if (bi = Function("binder", "return function (" + Te(_i, ",") + "){ return binder.apply(this,arguments); }")(vi), fi.prototype) {
      var Pi = function() {
      };
      Pi.prototype = fi.prototype, bi.prototype = new Pi(), Pi.prototype = null;
    }
    return bi;
  }, implementation;
}
var functionBind, hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var Ae = requireImplementation();
  return functionBind = Function.prototype.bind || Ae, functionBind;
}
var hasown, hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var Ae = Function.prototype.call, t = Object.prototype.hasOwnProperty, Ie = requireFunctionBind();
  return hasown = Ie.call(Ae, t), hasown;
}
var getIntrinsic, hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var Ae, t = requireEsErrors(), Ie = require_eval(), Me = requireRange(), Be = requireRef(), Pe = requireSyntax(), Te = requireType(), je = requireUri(), Ve = Function, fi = function(qi) {
    try {
      return Ve('"use strict"; return (' + qi + ").constructor;")();
    } catch {
    }
  }, Ue = Object.getOwnPropertyDescriptor;
  if (Ue)
    try {
      Ue({}, "");
    } catch {
      Ue = null;
    }
  var bi = function() {
    throw new Te();
  }, vi = Ue ? function() {
    try {
      return arguments.callee, bi;
    } catch {
      try {
        return Ue(arguments, "callee").get;
      } catch {
        return bi;
      }
    }
  }() : bi, mi = requireHasSymbols()(), _i = requireHasProto()(), Ei = Object.getPrototypeOf || (_i ? function(qi) {
    return qi.__proto__;
  } : null), Pi = {}, Ii = typeof Uint8Array > "u" || !Ei ? Ae : Ei(Uint8Array), Ci = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? Ae : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Ae : ArrayBuffer,
    "%ArrayIteratorPrototype%": mi && Ei ? Ei([][Symbol.iterator]()) : Ae,
    "%AsyncFromSyncIteratorPrototype%": Ae,
    "%AsyncFunction%": Pi,
    "%AsyncGenerator%": Pi,
    "%AsyncGeneratorFunction%": Pi,
    "%AsyncIteratorPrototype%": Pi,
    "%Atomics%": typeof Atomics > "u" ? Ae : Atomics,
    "%BigInt%": typeof BigInt > "u" ? Ae : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? Ae : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? Ae : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? Ae : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": t,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": Ie,
    "%Float32Array%": typeof Float32Array > "u" ? Ae : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? Ae : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Ae : FinalizationRegistry,
    "%Function%": Ve,
    "%GeneratorFunction%": Pi,
    "%Int8Array%": typeof Int8Array > "u" ? Ae : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? Ae : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? Ae : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": mi && Ei ? Ei(Ei([][Symbol.iterator]())) : Ae,
    "%JSON%": typeof JSON == "object" ? JSON : Ae,
    "%Map%": typeof Map > "u" ? Ae : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !mi || !Ei ? Ae : Ei((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? Ae : Promise,
    "%Proxy%": typeof Proxy > "u" ? Ae : Proxy,
    "%RangeError%": Me,
    "%ReferenceError%": Be,
    "%Reflect%": typeof Reflect > "u" ? Ae : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? Ae : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !mi || !Ei ? Ae : Ei((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Ae : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": mi && Ei ? Ei(""[Symbol.iterator]()) : Ae,
    "%Symbol%": mi ? Symbol : Ae,
    "%SyntaxError%": Pe,
    "%ThrowTypeError%": vi,
    "%TypedArray%": Ii,
    "%TypeError%": Te,
    "%Uint8Array%": typeof Uint8Array > "u" ? Ae : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Ae : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? Ae : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? Ae : Uint32Array,
    "%URIError%": je,
    "%WeakMap%": typeof WeakMap > "u" ? Ae : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? Ae : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? Ae : WeakSet
  };
  if (Ei)
    try {
      null.error;
    } catch (qi) {
      var Wi = Ei(Ei(qi));
      Ci["%Error.prototype%"] = Wi;
    }
  var zi = function qi(Ni) {
    var Ti;
    if (Ni === "%AsyncFunction%")
      Ti = fi("async function () {}");
    else if (Ni === "%GeneratorFunction%")
      Ti = fi("function* () {}");
    else if (Ni === "%AsyncGeneratorFunction%")
      Ti = fi("async function* () {}");
    else if (Ni === "%AsyncGenerator%") {
      var xi = qi("%AsyncGeneratorFunction%");
      xi && (Ti = xi.prototype);
    } else if (Ni === "%AsyncIteratorPrototype%") {
      var Fi = qi("%AsyncGenerator%");
      Fi && Ei && (Ti = Ei(Fi.prototype));
    }
    return Ci[Ni] = Ti, Ti;
  }, Xi = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, Qi = requireFunctionBind(), Oi = requireHasown(), Yi = Qi.call(Function.call, Array.prototype.concat), ns = Qi.call(Function.apply, Array.prototype.splice), ls = Qi.call(Function.call, String.prototype.replace), vn = Qi.call(Function.call, String.prototype.slice), Mi = Qi.call(Function.call, RegExp.prototype.exec), Ai = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, wi = /\\(\\)?/g, $i = function(Ni) {
    var Ti = vn(Ni, 0, 1), xi = vn(Ni, -1);
    if (Ti === "%" && xi !== "%")
      throw new Pe("invalid intrinsic syntax, expected closing `%`");
    if (xi === "%" && Ti !== "%")
      throw new Pe("invalid intrinsic syntax, expected opening `%`");
    var Fi = [];
    return ls(Ni, Ai, function(Si, Vi, ts, Hi) {
      Fi[Fi.length] = ts ? ls(Hi, wi, "$1") : Vi || Si;
    }), Fi;
  }, Li = function(Ni, Ti) {
    var xi = Ni, Fi;
    if (Oi(Xi, xi) && (Fi = Xi[xi], xi = "%" + Fi[0] + "%"), Oi(Ci, xi)) {
      var Si = Ci[xi];
      if (Si === Pi && (Si = zi(xi)), typeof Si > "u" && !Ti)
        throw new Te("intrinsic " + Ni + " exists, but is not available. Please file an issue!");
      return {
        alias: Fi,
        name: xi,
        value: Si
      };
    }
    throw new Pe("intrinsic " + Ni + " does not exist!");
  };
  return getIntrinsic = function(Ni, Ti) {
    if (typeof Ni != "string" || Ni.length === 0)
      throw new Te("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof Ti != "boolean")
      throw new Te('"allowMissing" argument must be a boolean');
    if (Mi(/^%?[^%]*%?$/, Ni) === null)
      throw new Pe("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var xi = $i(Ni), Fi = xi.length > 0 ? xi[0] : "", Si = Li("%" + Fi + "%", Ti), Vi = Si.name, ts = Si.value, Hi = !1, fn = Si.alias;
    fn && (Fi = fn[0], ns(xi, Yi([0, 1], fn)));
    for (var Bi = 1, ki = !0; Bi < xi.length; Bi += 1) {
      var Ji = xi[Bi], Ri = vn(Ji, 0, 1), ji = vn(Ji, -1);
      if ((Ri === '"' || Ri === "'" || Ri === "`" || ji === '"' || ji === "'" || ji === "`") && Ri !== ji)
        throw new Pe("property names with quotes must have matching quotes");
      if ((Ji === "constructor" || !ki) && (Hi = !0), Fi += "." + Ji, Vi = "%" + Fi + "%", Oi(Ci, Vi))
        ts = Ci[Vi];
      else if (ts != null) {
        if (!(Ji in ts)) {
          if (!Ti)
            throw new Te("base intrinsic for " + Ni + " exists, but the property is not available.");
          return;
        }
        if (Ue && Bi + 1 >= xi.length) {
          var Gi = Ue(ts, Ji);
          ki = !!Gi, ki && "get" in Gi && !("originalValue" in Gi.get) ? ts = Gi.get : ts = ts[Ji];
        } else
          ki = Oi(ts, Ji), ts = ts[Ji];
        ki && !Hi && (Ci[Vi] = ts);
      }
    }
    return ts;
  }, getIntrinsic;
}
var callBind = { exports: {} }, esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var Ae = requireGetIntrinsic(), t = Ae("%Object.defineProperty%", !0) || !1;
  if (t)
    try {
      t({}, "a", { value: 1 });
    } catch {
      t = !1;
    }
  return esDefineProperty = t, esDefineProperty;
}
var gopd, hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var Ae = requireGetIntrinsic(), t = Ae("%Object.getOwnPropertyDescriptor%", !0);
  if (t)
    try {
      t([], "length");
    } catch {
      t = null;
    }
  return gopd = t, gopd;
}
var defineDataProperty, hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var Ae = requireEsDefineProperty(), t = requireSyntax(), Ie = requireType(), Me = requireGopd();
  return defineDataProperty = function(Pe, Te, je) {
    if (!Pe || typeof Pe != "object" && typeof Pe != "function")
      throw new Ie("`obj` must be an object or a function`");
    if (typeof Te != "string" && typeof Te != "symbol")
      throw new Ie("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new Ie("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new Ie("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new Ie("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new Ie("`loose`, if provided, must be a boolean");
    var Ve = arguments.length > 3 ? arguments[3] : null, fi = arguments.length > 4 ? arguments[4] : null, Ue = arguments.length > 5 ? arguments[5] : null, bi = arguments.length > 6 ? arguments[6] : !1, vi = !!Me && Me(Pe, Te);
    if (Ae)
      Ae(Pe, Te, {
        configurable: Ue === null && vi ? vi.configurable : !Ue,
        enumerable: Ve === null && vi ? vi.enumerable : !Ve,
        value: je,
        writable: fi === null && vi ? vi.writable : !fi
      });
    else if (bi || !Ve && !fi && !Ue)
      Pe[Te] = je;
    else
      throw new t("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, defineDataProperty;
}
var hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var Ae = requireEsDefineProperty(), t = function() {
    return !!Ae;
  };
  return t.hasArrayLengthDefineBug = function() {
    if (!Ae)
      return null;
    try {
      return Ae([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, hasPropertyDescriptors_1 = t, hasPropertyDescriptors_1;
}
var setFunctionLength, hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var Ae = requireGetIntrinsic(), t = requireDefineDataProperty(), Ie = requireHasPropertyDescriptors()(), Me = requireGopd(), Be = requireType(), Pe = Ae("%Math.floor%");
  return setFunctionLength = function(je, Ve) {
    if (typeof je != "function")
      throw new Be("`fn` is not a function");
    if (typeof Ve != "number" || Ve < 0 || Ve > 4294967295 || Pe(Ve) !== Ve)
      throw new Be("`length` must be a positive 32-bit integer");
    var fi = arguments.length > 2 && !!arguments[2], Ue = !0, bi = !0;
    if ("length" in je && Me) {
      var vi = Me(je, "length");
      vi && !vi.configurable && (Ue = !1), vi && !vi.writable && (bi = !1);
    }
    return (Ue || bi || !fi) && (Ie ? t(
      /** @type {Parameters<define>[0]} */
      je,
      "length",
      Ve,
      !0,
      !0
    ) : t(
      /** @type {Parameters<define>[0]} */
      je,
      "length",
      Ve
    )), je;
  }, setFunctionLength;
}
var hasRequiredCallBind;
function requireCallBind() {
  return hasRequiredCallBind || (hasRequiredCallBind = 1, function(Ae) {
    var t = requireFunctionBind(), Ie = requireGetIntrinsic(), Me = requireSetFunctionLength(), Be = requireType(), Pe = Ie("%Function.prototype.apply%"), Te = Ie("%Function.prototype.call%"), je = Ie("%Reflect.apply%", !0) || t.call(Te, Pe), Ve = requireEsDefineProperty(), fi = Ie("%Math.max%");
    Ae.exports = function(vi) {
      if (typeof vi != "function")
        throw new Be("a function is required");
      var mi = je(t, Te, arguments);
      return Me(
        mi,
        1 + fi(0, vi.length - (arguments.length - 1)),
        !0
      );
    };
    var Ue = function() {
      return je(t, Pe, arguments);
    };
    Ve ? Ve(Ae.exports, "apply", { value: Ue }) : Ae.exports.apply = Ue;
  }(callBind)), callBind.exports;
}
var callBound, hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var Ae = requireGetIntrinsic(), t = requireCallBind(), Ie = t(Ae("String.prototype.indexOf"));
  return callBound = function(Be, Pe) {
    var Te = Ae(Be, !!Pe);
    return typeof Te == "function" && Ie(Be, ".prototype.") > -1 ? t(Te) : Te;
  }, callBound;
}
var isArguments, hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var Ae = requireShams()(), t = requireCallBound(), Ie = t("Object.prototype.toString"), Me = function(je) {
    return Ae && je && typeof je == "object" && Symbol.toStringTag in je ? !1 : Ie(je) === "[object Arguments]";
  }, Be = function(je) {
    return Me(je) ? !0 : je !== null && typeof je == "object" && typeof je.length == "number" && je.length >= 0 && Ie(je) !== "[object Array]" && Ie(je.callee) === "[object Function]";
  }, Pe = function() {
    return Me(arguments);
  }();
  return Me.isLegacyArguments = Be, isArguments = Pe ? Me : Be, isArguments;
}
var isGeneratorFunction, hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var Ae = Object.prototype.toString, t = Function.prototype.toString, Ie = /^\s*(?:function)?\*/, Me = requireShams()(), Be = Object.getPrototypeOf, Pe = function() {
    if (!Me)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, Te;
  return isGeneratorFunction = function(Ve) {
    if (typeof Ve != "function")
      return !1;
    if (Ie.test(t.call(Ve)))
      return !0;
    if (!Me) {
      var fi = Ae.call(Ve);
      return fi === "[object GeneratorFunction]";
    }
    if (!Be)
      return !1;
    if (typeof Te > "u") {
      var Ue = Pe();
      Te = Ue ? Be(Ue) : !1;
    }
    return Be(Ve) === Te;
  }, isGeneratorFunction;
}
var isCallable, hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var Ae = Function.prototype.toString, t = typeof Reflect == "object" && Reflect !== null && Reflect.apply, Ie, Me;
  if (typeof t == "function" && typeof Object.defineProperty == "function")
    try {
      Ie = Object.defineProperty({}, "length", {
        get: function() {
          throw Me;
        }
      }), Me = {}, t(function() {
        throw 42;
      }, null, Ie);
    } catch (Ci) {
      Ci !== Me && (t = null);
    }
  else
    t = null;
  var Be = /^\s*class\b/, Pe = function(Wi) {
    try {
      var zi = Ae.call(Wi);
      return Be.test(zi);
    } catch {
      return !1;
    }
  }, Te = function(Wi) {
    try {
      return Pe(Wi) ? !1 : (Ae.call(Wi), !0);
    } catch {
      return !1;
    }
  }, je = Object.prototype.toString, Ve = "[object Object]", fi = "[object Function]", Ue = "[object GeneratorFunction]", bi = "[object HTMLAllCollection]", vi = "[object HTML document.all class]", mi = "[object HTMLCollection]", _i = typeof Symbol == "function" && !!Symbol.toStringTag, Ei = !(0 in [,]), Pi = function() {
    return !1;
  };
  if (typeof document == "object") {
    var Ii = document.all;
    je.call(Ii) === je.call(document.all) && (Pi = function(Wi) {
      if ((Ei || !Wi) && (typeof Wi > "u" || typeof Wi == "object"))
        try {
          var zi = je.call(Wi);
          return (zi === bi || zi === vi || zi === mi || zi === Ve) && Wi("") == null;
        } catch {
        }
      return !1;
    });
  }
  return isCallable = t ? function(Wi) {
    if (Pi(Wi))
      return !0;
    if (!Wi || typeof Wi != "function" && typeof Wi != "object")
      return !1;
    try {
      t(Wi, null, Ie);
    } catch (zi) {
      if (zi !== Me)
        return !1;
    }
    return !Pe(Wi) && Te(Wi);
  } : function(Wi) {
    if (Pi(Wi))
      return !0;
    if (!Wi || typeof Wi != "function" && typeof Wi != "object")
      return !1;
    if (_i)
      return Te(Wi);
    if (Pe(Wi))
      return !1;
    var zi = je.call(Wi);
    return zi !== fi && zi !== Ue && !/^\[object HTML/.test(zi) ? !1 : Te(Wi);
  }, isCallable;
}
var forEach_1, hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach_1;
  hasRequiredForEach = 1;
  var Ae = requireIsCallable(), t = Object.prototype.toString, Ie = Object.prototype.hasOwnProperty, Me = function(Ve, fi, Ue) {
    for (var bi = 0, vi = Ve.length; bi < vi; bi++)
      Ie.call(Ve, bi) && (Ue == null ? fi(Ve[bi], bi, Ve) : fi.call(Ue, Ve[bi], bi, Ve));
  }, Be = function(Ve, fi, Ue) {
    for (var bi = 0, vi = Ve.length; bi < vi; bi++)
      Ue == null ? fi(Ve.charAt(bi), bi, Ve) : fi.call(Ue, Ve.charAt(bi), bi, Ve);
  }, Pe = function(Ve, fi, Ue) {
    for (var bi in Ve)
      Ie.call(Ve, bi) && (Ue == null ? fi(Ve[bi], bi, Ve) : fi.call(Ue, Ve[bi], bi, Ve));
  }, Te = function(Ve, fi, Ue) {
    if (!Ae(fi))
      throw new TypeError("iterator must be a function");
    var bi;
    arguments.length >= 3 && (bi = Ue), t.call(Ve) === "[object Array]" ? Me(Ve, fi, bi) : typeof Ve == "string" ? Be(Ve, fi, bi) : Pe(Ve, fi, bi);
  };
  return forEach_1 = Te, forEach_1;
}
var possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  return hasRequiredPossibleTypedArrayNames || (hasRequiredPossibleTypedArrayNames = 1, possibleTypedArrayNames = [
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), possibleTypedArrayNames;
}
var availableTypedArrays, hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var Ae = requirePossibleTypedArrayNames(), t = typeof globalThis > "u" ? commonjsGlobal : globalThis;
  return availableTypedArrays = function() {
    for (var Me = [], Be = 0; Be < Ae.length; Be++)
      typeof t[Ae[Be]] == "function" && (Me[Me.length] = Ae[Be]);
    return Me;
  }, availableTypedArrays;
}
var whichTypedArray, hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var Ae = requireForEach(), t = requireAvailableTypedArrays(), Ie = requireCallBind(), Me = requireCallBound(), Be = requireGopd(), Pe = Me("Object.prototype.toString"), Te = requireShams()(), je = typeof globalThis > "u" ? commonjsGlobal : globalThis, Ve = t(), fi = Me("String.prototype.slice"), Ue = Object.getPrototypeOf, bi = Me("Array.prototype.indexOf", !0) || function(Pi, Ii) {
    for (var Ci = 0; Ci < Pi.length; Ci += 1)
      if (Pi[Ci] === Ii)
        return Ci;
    return -1;
  }, vi = { __proto__: null };
  Te && Be && Ue ? Ae(Ve, function(Ei) {
    var Pi = new je[Ei]();
    if (Symbol.toStringTag in Pi) {
      var Ii = Ue(Pi), Ci = Be(Ii, Symbol.toStringTag);
      if (!Ci) {
        var Wi = Ue(Ii);
        Ci = Be(Wi, Symbol.toStringTag);
      }
      vi["$" + Ei] = Ie(Ci.get);
    }
  }) : Ae(Ve, function(Ei) {
    var Pi = new je[Ei](), Ii = Pi.slice || Pi.set;
    Ii && (vi["$" + Ei] = Ie(Ii));
  });
  var mi = function(Pi) {
    var Ii = !1;
    return Ae(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      vi,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(Ci, Wi) {
        if (!Ii)
          try {
            "$" + Ci(Pi) === Wi && (Ii = fi(Wi, 1));
          } catch {
          }
      }
    ), Ii;
  }, _i = function(Pi) {
    var Ii = !1;
    return Ae(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      vi,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(Ci, Wi) {
        if (!Ii)
          try {
            Ci(Pi), Ii = fi(Wi, 1);
          } catch {
          }
      }
    ), Ii;
  };
  return whichTypedArray = function(Pi) {
    if (!Pi || typeof Pi != "object")
      return !1;
    if (!Te) {
      var Ii = fi(Pe(Pi), 8, -1);
      return bi(Ve, Ii) > -1 ? Ii : Ii !== "Object" ? !1 : _i(Pi);
    }
    return Be ? mi(Pi) : null;
  }, whichTypedArray;
}
var isTypedArray, hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var Ae = requireWhichTypedArray();
  return isTypedArray = function(Ie) {
    return !!Ae(Ie);
  }, isTypedArray;
}
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(Ae) {
    var t = requireIsArguments(), Ie = requireIsGeneratorFunction(), Me = requireWhichTypedArray(), Be = requireIsTypedArray();
    function Pe(hs) {
      return hs.call.bind(hs);
    }
    var Te = typeof BigInt < "u", je = typeof Symbol < "u", Ve = Pe(Object.prototype.toString), fi = Pe(Number.prototype.valueOf), Ue = Pe(String.prototype.valueOf), bi = Pe(Boolean.prototype.valueOf);
    if (Te)
      var vi = Pe(BigInt.prototype.valueOf);
    if (je)
      var mi = Pe(Symbol.prototype.valueOf);
    function _i(hs, fa) {
      if (typeof hs != "object")
        return !1;
      try {
        return fa(hs), !0;
      } catch {
        return !1;
      }
    }
    Ae.isArgumentsObject = t, Ae.isGeneratorFunction = Ie, Ae.isTypedArray = Be;
    function Ei(hs) {
      return typeof Promise < "u" && hs instanceof Promise || hs !== null && typeof hs == "object" && typeof hs.then == "function" && typeof hs.catch == "function";
    }
    Ae.isPromise = Ei;
    function Pi(hs) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(hs) : Be(hs) || Vi(hs);
    }
    Ae.isArrayBufferView = Pi;
    function Ii(hs) {
      return Me(hs) === "Uint8Array";
    }
    Ae.isUint8Array = Ii;
    function Ci(hs) {
      return Me(hs) === "Uint8ClampedArray";
    }
    Ae.isUint8ClampedArray = Ci;
    function Wi(hs) {
      return Me(hs) === "Uint16Array";
    }
    Ae.isUint16Array = Wi;
    function zi(hs) {
      return Me(hs) === "Uint32Array";
    }
    Ae.isUint32Array = zi;
    function Xi(hs) {
      return Me(hs) === "Int8Array";
    }
    Ae.isInt8Array = Xi;
    function Qi(hs) {
      return Me(hs) === "Int16Array";
    }
    Ae.isInt16Array = Qi;
    function Oi(hs) {
      return Me(hs) === "Int32Array";
    }
    Ae.isInt32Array = Oi;
    function Yi(hs) {
      return Me(hs) === "Float32Array";
    }
    Ae.isFloat32Array = Yi;
    function ns(hs) {
      return Me(hs) === "Float64Array";
    }
    Ae.isFloat64Array = ns;
    function ls(hs) {
      return Me(hs) === "BigInt64Array";
    }
    Ae.isBigInt64Array = ls;
    function vn(hs) {
      return Me(hs) === "BigUint64Array";
    }
    Ae.isBigUint64Array = vn;
    function Mi(hs) {
      return Ve(hs) === "[object Map]";
    }
    Mi.working = typeof Map < "u" && Mi(/* @__PURE__ */ new Map());
    function Ai(hs) {
      return typeof Map > "u" ? !1 : Mi.working ? Mi(hs) : hs instanceof Map;
    }
    Ae.isMap = Ai;
    function wi(hs) {
      return Ve(hs) === "[object Set]";
    }
    wi.working = typeof Set < "u" && wi(/* @__PURE__ */ new Set());
    function $i(hs) {
      return typeof Set > "u" ? !1 : wi.working ? wi(hs) : hs instanceof Set;
    }
    Ae.isSet = $i;
    function Li(hs) {
      return Ve(hs) === "[object WeakMap]";
    }
    Li.working = typeof WeakMap < "u" && Li(/* @__PURE__ */ new WeakMap());
    function qi(hs) {
      return typeof WeakMap > "u" ? !1 : Li.working ? Li(hs) : hs instanceof WeakMap;
    }
    Ae.isWeakMap = qi;
    function Ni(hs) {
      return Ve(hs) === "[object WeakSet]";
    }
    Ni.working = typeof WeakSet < "u" && Ni(/* @__PURE__ */ new WeakSet());
    function Ti(hs) {
      return Ni(hs);
    }
    Ae.isWeakSet = Ti;
    function xi(hs) {
      return Ve(hs) === "[object ArrayBuffer]";
    }
    xi.working = typeof ArrayBuffer < "u" && xi(new ArrayBuffer());
    function Fi(hs) {
      return typeof ArrayBuffer > "u" ? !1 : xi.working ? xi(hs) : hs instanceof ArrayBuffer;
    }
    Ae.isArrayBuffer = Fi;
    function Si(hs) {
      return Ve(hs) === "[object DataView]";
    }
    Si.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && Si(new DataView(new ArrayBuffer(1), 0, 1));
    function Vi(hs) {
      return typeof DataView > "u" ? !1 : Si.working ? Si(hs) : hs instanceof DataView;
    }
    Ae.isDataView = Vi;
    var ts = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function Hi(hs) {
      return Ve(hs) === "[object SharedArrayBuffer]";
    }
    function fn(hs) {
      return typeof ts > "u" ? !1 : (typeof Hi.working > "u" && (Hi.working = Hi(new ts())), Hi.working ? Hi(hs) : hs instanceof ts);
    }
    Ae.isSharedArrayBuffer = fn;
    function Bi(hs) {
      return Ve(hs) === "[object AsyncFunction]";
    }
    Ae.isAsyncFunction = Bi;
    function ki(hs) {
      return Ve(hs) === "[object Map Iterator]";
    }
    Ae.isMapIterator = ki;
    function Ji(hs) {
      return Ve(hs) === "[object Set Iterator]";
    }
    Ae.isSetIterator = Ji;
    function Ri(hs) {
      return Ve(hs) === "[object Generator]";
    }
    Ae.isGeneratorObject = Ri;
    function ji(hs) {
      return Ve(hs) === "[object WebAssembly.Module]";
    }
    Ae.isWebAssemblyCompiledModule = ji;
    function Gi(hs) {
      return _i(hs, fi);
    }
    Ae.isNumberObject = Gi;
    function is(hs) {
      return _i(hs, Ue);
    }
    Ae.isStringObject = is;
    function os(hs) {
      return _i(hs, bi);
    }
    Ae.isBooleanObject = os;
    function ds(hs) {
      return Te && _i(hs, vi);
    }
    Ae.isBigIntObject = ds;
    function ps(hs) {
      return je && _i(hs, mi);
    }
    Ae.isSymbolObject = ps;
    function ea(hs) {
      return Gi(hs) || is(hs) || os(hs) || ds(hs) || ps(hs);
    }
    Ae.isBoxedPrimitive = ea;
    function ia(hs) {
      return typeof Uint8Array < "u" && (Fi(hs) || fn(hs));
    }
    Ae.isAnyArrayBuffer = ia, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(hs) {
      Object.defineProperty(Ae, hs, {
        enumerable: !1,
        value: function() {
          throw new Error(hs + " is not supported in userland");
        }
      });
    });
  }(types)), types;
}
var isBufferBrowser, hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(t) {
    return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
  }), isBufferBrowser;
}
var hasRequiredUtil$1;
function requireUtil$1() {
  return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1, function(Ae) {
    var t = Object.getOwnPropertyDescriptors || function(Vi) {
      for (var ts = Object.keys(Vi), Hi = {}, fn = 0; fn < ts.length; fn++)
        Hi[ts[fn]] = Object.getOwnPropertyDescriptor(Vi, ts[fn]);
      return Hi;
    }, Ie = /%[sdj%]/g;
    Ae.format = function(Si) {
      if (!Xi(Si)) {
        for (var Vi = [], ts = 0; ts < arguments.length; ts++)
          Vi.push(Te(arguments[ts]));
        return Vi.join(" ");
      }
      for (var ts = 1, Hi = arguments, fn = Hi.length, Bi = String(Si).replace(Ie, function(Ji) {
        if (Ji === "%%") return "%";
        if (ts >= fn) return Ji;
        switch (Ji) {
          case "%s":
            return String(Hi[ts++]);
          case "%d":
            return Number(Hi[ts++]);
          case "%j":
            try {
              return JSON.stringify(Hi[ts++]);
            } catch {
              return "[Circular]";
            }
          default:
            return Ji;
        }
      }), ki = Hi[ts]; ts < fn; ki = Hi[++ts])
        Ci(ki) || !ns(ki) ? Bi += " " + ki : Bi += " " + Te(ki);
      return Bi;
    }, Ae.deprecate = function(Si, Vi) {
      if (typeof process$1 < "u" && process$1.noDeprecation === !0)
        return Si;
      if (typeof process$1 > "u")
        return function() {
          return Ae.deprecate(Si, Vi).apply(this, arguments);
        };
      var ts = !1;
      function Hi() {
        if (!ts) {
          if (process$1.throwDeprecation)
            throw new Error(Vi);
          process$1.traceDeprecation ? console.trace(Vi) : console.error(Vi), ts = !0;
        }
        return Si.apply(this, arguments);
      }
      return Hi;
    };
    var Me = {}, Be = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var Pe = process$1.env.NODE_DEBUG;
      Pe = Pe.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), Be = new RegExp("^" + Pe + "$", "i");
    }
    Ae.debuglog = function(Si) {
      if (Si = Si.toUpperCase(), !Me[Si])
        if (Be.test(Si)) {
          var Vi = process$1.pid;
          Me[Si] = function() {
            var ts = Ae.format.apply(Ae, arguments);
            console.error("%s %d: %s", Si, Vi, ts);
          };
        } else
          Me[Si] = function() {
          };
      return Me[Si];
    };
    function Te(Si, Vi) {
      var ts = {
        seen: [],
        stylize: Ve
      };
      return arguments.length >= 3 && (ts.depth = arguments[2]), arguments.length >= 4 && (ts.colors = arguments[3]), Ii(Vi) ? ts.showHidden = Vi : Vi && Ae._extend(ts, Vi), Oi(ts.showHidden) && (ts.showHidden = !1), Oi(ts.depth) && (ts.depth = 2), Oi(ts.colors) && (ts.colors = !1), Oi(ts.customInspect) && (ts.customInspect = !0), ts.colors && (ts.stylize = je), Ue(ts, Si, ts.depth);
    }
    Ae.inspect = Te, Te.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, Te.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function je(Si, Vi) {
      var ts = Te.styles[Vi];
      return ts ? "\x1B[" + Te.colors[ts][0] + "m" + Si + "\x1B[" + Te.colors[ts][1] + "m" : Si;
    }
    function Ve(Si, Vi) {
      return Si;
    }
    function fi(Si) {
      var Vi = {};
      return Si.forEach(function(ts, Hi) {
        Vi[ts] = !0;
      }), Vi;
    }
    function Ue(Si, Vi, ts) {
      if (Si.customInspect && Vi && Mi(Vi.inspect) && // Filter out the util module, it's inspect function is special
      Vi.inspect !== Ae.inspect && // Also filter out any prototype objects using the circular check.
      !(Vi.constructor && Vi.constructor.prototype === Vi)) {
        var Hi = Vi.inspect(ts, Si);
        return Xi(Hi) || (Hi = Ue(Si, Hi, ts)), Hi;
      }
      var fn = bi(Si, Vi);
      if (fn)
        return fn;
      var Bi = Object.keys(Vi), ki = fi(Bi);
      if (Si.showHidden && (Bi = Object.getOwnPropertyNames(Vi)), vn(Vi) && (Bi.indexOf("message") >= 0 || Bi.indexOf("description") >= 0))
        return vi(Vi);
      if (Bi.length === 0) {
        if (Mi(Vi)) {
          var Ji = Vi.name ? ": " + Vi.name : "";
          return Si.stylize("[Function" + Ji + "]", "special");
        }
        if (Yi(Vi))
          return Si.stylize(RegExp.prototype.toString.call(Vi), "regexp");
        if (ls(Vi))
          return Si.stylize(Date.prototype.toString.call(Vi), "date");
        if (vn(Vi))
          return vi(Vi);
      }
      var Ri = "", ji = !1, Gi = ["{", "}"];
      if (Pi(Vi) && (ji = !0, Gi = ["[", "]"]), Mi(Vi)) {
        var is = Vi.name ? ": " + Vi.name : "";
        Ri = " [Function" + is + "]";
      }
      if (Yi(Vi) && (Ri = " " + RegExp.prototype.toString.call(Vi)), ls(Vi) && (Ri = " " + Date.prototype.toUTCString.call(Vi)), vn(Vi) && (Ri = " " + vi(Vi)), Bi.length === 0 && (!ji || Vi.length == 0))
        return Gi[0] + Ri + Gi[1];
      if (ts < 0)
        return Yi(Vi) ? Si.stylize(RegExp.prototype.toString.call(Vi), "regexp") : Si.stylize("[Object]", "special");
      Si.seen.push(Vi);
      var os;
      return ji ? os = mi(Si, Vi, ts, ki, Bi) : os = Bi.map(function(ds) {
        return _i(Si, Vi, ts, ki, ds, ji);
      }), Si.seen.pop(), Ei(os, Ri, Gi);
    }
    function bi(Si, Vi) {
      if (Oi(Vi))
        return Si.stylize("undefined", "undefined");
      if (Xi(Vi)) {
        var ts = "'" + JSON.stringify(Vi).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return Si.stylize(ts, "string");
      }
      if (zi(Vi))
        return Si.stylize("" + Vi, "number");
      if (Ii(Vi))
        return Si.stylize("" + Vi, "boolean");
      if (Ci(Vi))
        return Si.stylize("null", "null");
    }
    function vi(Si) {
      return "[" + Error.prototype.toString.call(Si) + "]";
    }
    function mi(Si, Vi, ts, Hi, fn) {
      for (var Bi = [], ki = 0, Ji = Vi.length; ki < Ji; ++ki)
        Ni(Vi, String(ki)) ? Bi.push(_i(
          Si,
          Vi,
          ts,
          Hi,
          String(ki),
          !0
        )) : Bi.push("");
      return fn.forEach(function(Ri) {
        Ri.match(/^\d+$/) || Bi.push(_i(
          Si,
          Vi,
          ts,
          Hi,
          Ri,
          !0
        ));
      }), Bi;
    }
    function _i(Si, Vi, ts, Hi, fn, Bi) {
      var ki, Ji, Ri;
      if (Ri = Object.getOwnPropertyDescriptor(Vi, fn) || { value: Vi[fn] }, Ri.get ? Ri.set ? Ji = Si.stylize("[Getter/Setter]", "special") : Ji = Si.stylize("[Getter]", "special") : Ri.set && (Ji = Si.stylize("[Setter]", "special")), Ni(Hi, fn) || (ki = "[" + fn + "]"), Ji || (Si.seen.indexOf(Ri.value) < 0 ? (Ci(ts) ? Ji = Ue(Si, Ri.value, null) : Ji = Ue(Si, Ri.value, ts - 1), Ji.indexOf(`
`) > -1 && (Bi ? Ji = Ji.split(`
`).map(function(ji) {
        return "  " + ji;
      }).join(`
`).slice(2) : Ji = `
` + Ji.split(`
`).map(function(ji) {
        return "   " + ji;
      }).join(`
`))) : Ji = Si.stylize("[Circular]", "special")), Oi(ki)) {
        if (Bi && fn.match(/^\d+$/))
          return Ji;
        ki = JSON.stringify("" + fn), ki.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ki = ki.slice(1, -1), ki = Si.stylize(ki, "name")) : (ki = ki.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ki = Si.stylize(ki, "string"));
      }
      return ki + ": " + Ji;
    }
    function Ei(Si, Vi, ts) {
      var Hi = Si.reduce(function(fn, Bi) {
        return Bi.indexOf(`
`) >= 0, fn + Bi.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return Hi > 60 ? ts[0] + (Vi === "" ? "" : Vi + `
 `) + " " + Si.join(`,
  `) + " " + ts[1] : ts[0] + Vi + " " + Si.join(", ") + " " + ts[1];
    }
    Ae.types = requireTypes();
    function Pi(Si) {
      return Array.isArray(Si);
    }
    Ae.isArray = Pi;
    function Ii(Si) {
      return typeof Si == "boolean";
    }
    Ae.isBoolean = Ii;
    function Ci(Si) {
      return Si === null;
    }
    Ae.isNull = Ci;
    function Wi(Si) {
      return Si == null;
    }
    Ae.isNullOrUndefined = Wi;
    function zi(Si) {
      return typeof Si == "number";
    }
    Ae.isNumber = zi;
    function Xi(Si) {
      return typeof Si == "string";
    }
    Ae.isString = Xi;
    function Qi(Si) {
      return typeof Si == "symbol";
    }
    Ae.isSymbol = Qi;
    function Oi(Si) {
      return Si === void 0;
    }
    Ae.isUndefined = Oi;
    function Yi(Si) {
      return ns(Si) && wi(Si) === "[object RegExp]";
    }
    Ae.isRegExp = Yi, Ae.types.isRegExp = Yi;
    function ns(Si) {
      return typeof Si == "object" && Si !== null;
    }
    Ae.isObject = ns;
    function ls(Si) {
      return ns(Si) && wi(Si) === "[object Date]";
    }
    Ae.isDate = ls, Ae.types.isDate = ls;
    function vn(Si) {
      return ns(Si) && (wi(Si) === "[object Error]" || Si instanceof Error);
    }
    Ae.isError = vn, Ae.types.isNativeError = vn;
    function Mi(Si) {
      return typeof Si == "function";
    }
    Ae.isFunction = Mi;
    function Ai(Si) {
      return Si === null || typeof Si == "boolean" || typeof Si == "number" || typeof Si == "string" || typeof Si == "symbol" || // ES6 symbol
      typeof Si > "u";
    }
    Ae.isPrimitive = Ai, Ae.isBuffer = requireIsBufferBrowser();
    function wi(Si) {
      return Object.prototype.toString.call(Si);
    }
    function $i(Si) {
      return Si < 10 ? "0" + Si.toString(10) : Si.toString(10);
    }
    var Li = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function qi() {
      var Si = /* @__PURE__ */ new Date(), Vi = [
        $i(Si.getHours()),
        $i(Si.getMinutes()),
        $i(Si.getSeconds())
      ].join(":");
      return [Si.getDate(), Li[Si.getMonth()], Vi].join(" ");
    }
    Ae.log = function() {
      console.log("%s - %s", qi(), Ae.format.apply(Ae, arguments));
    }, Ae.inherits = inherits_browserExports, Ae._extend = function(Si, Vi) {
      if (!Vi || !ns(Vi)) return Si;
      for (var ts = Object.keys(Vi), Hi = ts.length; Hi--; )
        Si[ts[Hi]] = Vi[ts[Hi]];
      return Si;
    };
    function Ni(Si, Vi) {
      return Object.prototype.hasOwnProperty.call(Si, Vi);
    }
    var Ti = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    Ae.promisify = function(Vi) {
      if (typeof Vi != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (Ti && Vi[Ti]) {
        var ts = Vi[Ti];
        if (typeof ts != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(ts, Ti, {
          value: ts,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), ts;
      }
      function ts() {
        for (var Hi, fn, Bi = new Promise(function(Ri, ji) {
          Hi = Ri, fn = ji;
        }), ki = [], Ji = 0; Ji < arguments.length; Ji++)
          ki.push(arguments[Ji]);
        ki.push(function(Ri, ji) {
          Ri ? fn(Ri) : Hi(ji);
        });
        try {
          Vi.apply(this, ki);
        } catch (Ri) {
          fn(Ri);
        }
        return Bi;
      }
      return Object.setPrototypeOf(ts, Object.getPrototypeOf(Vi)), Ti && Object.defineProperty(ts, Ti, {
        value: ts,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        ts,
        t(Vi)
      );
    }, Ae.promisify.custom = Ti;
    function xi(Si, Vi) {
      if (!Si) {
        var ts = new Error("Promise was rejected with a falsy value");
        ts.reason = Si, Si = ts;
      }
      return Vi(Si);
    }
    function Fi(Si) {
      if (typeof Si != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function Vi() {
        for (var ts = [], Hi = 0; Hi < arguments.length; Hi++)
          ts.push(arguments[Hi]);
        var fn = ts.pop();
        if (typeof fn != "function")
          throw new TypeError("The last argument must be of type Function");
        var Bi = this, ki = function() {
          return fn.apply(Bi, arguments);
        };
        Si.apply(this, ts).then(
          function(Ji) {
            process$1.nextTick(ki.bind(null, null, Ji));
          },
          function(Ji) {
            process$1.nextTick(xi.bind(null, Ji, ki));
          }
        );
      }
      return Object.setPrototypeOf(Vi, Object.getPrototypeOf(Si)), Object.defineProperties(
        Vi,
        t(Si)
      ), Vi;
    }
    Ae.callbackify = Fi;
  }(util$1)), util$1;
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function Ae(_i, Ei) {
    var Pi = Object.keys(_i);
    if (Object.getOwnPropertySymbols) {
      var Ii = Object.getOwnPropertySymbols(_i);
      Ei && (Ii = Ii.filter(function(Ci) {
        return Object.getOwnPropertyDescriptor(_i, Ci).enumerable;
      })), Pi.push.apply(Pi, Ii);
    }
    return Pi;
  }
  function t(_i) {
    for (var Ei = 1; Ei < arguments.length; Ei++) {
      var Pi = arguments[Ei] != null ? arguments[Ei] : {};
      Ei % 2 ? Ae(Object(Pi), !0).forEach(function(Ii) {
        Ie(_i, Ii, Pi[Ii]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_i, Object.getOwnPropertyDescriptors(Pi)) : Ae(Object(Pi)).forEach(function(Ii) {
        Object.defineProperty(_i, Ii, Object.getOwnPropertyDescriptor(Pi, Ii));
      });
    }
    return _i;
  }
  function Ie(_i, Ei, Pi) {
    return Ei = Te(Ei), Ei in _i ? Object.defineProperty(_i, Ei, { value: Pi, enumerable: !0, configurable: !0, writable: !0 }) : _i[Ei] = Pi, _i;
  }
  function Me(_i, Ei) {
    if (!(_i instanceof Ei))
      throw new TypeError("Cannot call a class as a function");
  }
  function Be(_i, Ei) {
    for (var Pi = 0; Pi < Ei.length; Pi++) {
      var Ii = Ei[Pi];
      Ii.enumerable = Ii.enumerable || !1, Ii.configurable = !0, "value" in Ii && (Ii.writable = !0), Object.defineProperty(_i, Te(Ii.key), Ii);
    }
  }
  function Pe(_i, Ei, Pi) {
    return Ei && Be(_i.prototype, Ei), Object.defineProperty(_i, "prototype", { writable: !1 }), _i;
  }
  function Te(_i) {
    var Ei = je(_i, "string");
    return typeof Ei == "symbol" ? Ei : String(Ei);
  }
  function je(_i, Ei) {
    if (typeof _i != "object" || _i === null) return _i;
    var Pi = _i[Symbol.toPrimitive];
    if (Pi !== void 0) {
      var Ii = Pi.call(_i, Ei || "default");
      if (typeof Ii != "object") return Ii;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (Ei === "string" ? String : Number)(_i);
  }
  var Ve = require$$1$2, fi = Ve.Buffer, Ue = requireUtil$1(), bi = Ue.inspect, vi = bi && bi.custom || "inspect";
  function mi(_i, Ei, Pi) {
    fi.prototype.copy.call(_i, Ei, Pi);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function _i() {
      Me(this, _i), this.head = null, this.tail = null, this.length = 0;
    }
    return Pe(_i, [{
      key: "push",
      value: function(Pi) {
        var Ii = {
          data: Pi,
          next: null
        };
        this.length > 0 ? this.tail.next = Ii : this.head = Ii, this.tail = Ii, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(Pi) {
        var Ii = {
          data: Pi,
          next: this.head
        };
        this.length === 0 && (this.tail = Ii), this.head = Ii, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var Pi = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Pi;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(Pi) {
        if (this.length === 0) return "";
        for (var Ii = this.head, Ci = "" + Ii.data; Ii = Ii.next; ) Ci += Pi + Ii.data;
        return Ci;
      }
    }, {
      key: "concat",
      value: function(Pi) {
        if (this.length === 0) return fi.alloc(0);
        for (var Ii = fi.allocUnsafe(Pi >>> 0), Ci = this.head, Wi = 0; Ci; )
          mi(Ci.data, Ii, Wi), Wi += Ci.data.length, Ci = Ci.next;
        return Ii;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(Pi, Ii) {
        var Ci;
        return Pi < this.head.data.length ? (Ci = this.head.data.slice(0, Pi), this.head.data = this.head.data.slice(Pi)) : Pi === this.head.data.length ? Ci = this.shift() : Ci = Ii ? this._getString(Pi) : this._getBuffer(Pi), Ci;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(Pi) {
        var Ii = this.head, Ci = 1, Wi = Ii.data;
        for (Pi -= Wi.length; Ii = Ii.next; ) {
          var zi = Ii.data, Xi = Pi > zi.length ? zi.length : Pi;
          if (Xi === zi.length ? Wi += zi : Wi += zi.slice(0, Pi), Pi -= Xi, Pi === 0) {
            Xi === zi.length ? (++Ci, Ii.next ? this.head = Ii.next : this.head = this.tail = null) : (this.head = Ii, Ii.data = zi.slice(Xi));
            break;
          }
          ++Ci;
        }
        return this.length -= Ci, Wi;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(Pi) {
        var Ii = fi.allocUnsafe(Pi), Ci = this.head, Wi = 1;
        for (Ci.data.copy(Ii), Pi -= Ci.data.length; Ci = Ci.next; ) {
          var zi = Ci.data, Xi = Pi > zi.length ? zi.length : Pi;
          if (zi.copy(Ii, Ii.length - Pi, 0, Xi), Pi -= Xi, Pi === 0) {
            Xi === zi.length ? (++Wi, Ci.next ? this.head = Ci.next : this.head = this.tail = null) : (this.head = Ci, Ci.data = zi.slice(Xi));
            break;
          }
          ++Wi;
        }
        return this.length -= Wi, Ii;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: vi,
      value: function(Pi, Ii) {
        return bi(this, t(t({}, Ii), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), _i;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1) return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  function Ae(Te, je) {
    var Ve = this, fi = this._readableState && this._readableState.destroyed, Ue = this._writableState && this._writableState.destroyed;
    return fi || Ue ? (je ? je(Te) : Te && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(Be, this, Te)) : process$1.nextTick(Be, this, Te)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(Te || null, function(bi) {
      !je && bi ? Ve._writableState ? Ve._writableState.errorEmitted ? process$1.nextTick(Ie, Ve) : (Ve._writableState.errorEmitted = !0, process$1.nextTick(t, Ve, bi)) : process$1.nextTick(t, Ve, bi) : je ? (process$1.nextTick(Ie, Ve), je(bi)) : process$1.nextTick(Ie, Ve);
    }), this);
  }
  function t(Te, je) {
    Be(Te, je), Ie(Te);
  }
  function Ie(Te) {
    Te._writableState && !Te._writableState.emitClose || Te._readableState && !Te._readableState.emitClose || Te.emit("close");
  }
  function Me() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function Be(Te, je) {
    Te.emit("error", je);
  }
  function Pe(Te, je) {
    var Ve = Te._readableState, fi = Te._writableState;
    Ve && Ve.autoDestroy || fi && fi.autoDestroy ? Te.destroy(je) : Te.emit("error", je);
  }
  return destroy_1$1 = {
    destroy: Ae,
    undestroy: Me,
    errorOrDestroy: Pe
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function Ae(je, Ve) {
    je.prototype = Object.create(Ve.prototype), je.prototype.constructor = je, je.__proto__ = Ve;
  }
  var t = {};
  function Ie(je, Ve, fi) {
    fi || (fi = Error);
    function Ue(vi, mi, _i) {
      return typeof Ve == "string" ? Ve : Ve(vi, mi, _i);
    }
    var bi = /* @__PURE__ */ function(vi) {
      Ae(mi, vi);
      function mi(_i, Ei, Pi) {
        return vi.call(this, Ue(_i, Ei, Pi)) || this;
      }
      return mi;
    }(fi);
    bi.prototype.name = fi.name, bi.prototype.code = je, t[je] = bi;
  }
  function Me(je, Ve) {
    if (Array.isArray(je)) {
      var fi = je.length;
      return je = je.map(function(Ue) {
        return String(Ue);
      }), fi > 2 ? "one of ".concat(Ve, " ").concat(je.slice(0, fi - 1).join(", "), ", or ") + je[fi - 1] : fi === 2 ? "one of ".concat(Ve, " ").concat(je[0], " or ").concat(je[1]) : "of ".concat(Ve, " ").concat(je[0]);
    } else
      return "of ".concat(Ve, " ").concat(String(je));
  }
  function Be(je, Ve, fi) {
    return je.substr(0, Ve.length) === Ve;
  }
  function Pe(je, Ve, fi) {
    return (fi === void 0 || fi > je.length) && (fi = je.length), je.substring(fi - Ve.length, fi) === Ve;
  }
  function Te(je, Ve, fi) {
    return typeof fi != "number" && (fi = 0), fi + Ve.length > je.length ? !1 : je.indexOf(Ve, fi) !== -1;
  }
  return Ie("ERR_INVALID_OPT_VALUE", function(je, Ve) {
    return 'The value "' + Ve + '" is invalid for option "' + je + '"';
  }, TypeError), Ie("ERR_INVALID_ARG_TYPE", function(je, Ve, fi) {
    var Ue;
    typeof Ve == "string" && Be(Ve, "not ") ? (Ue = "must not be", Ve = Ve.replace(/^not /, "")) : Ue = "must be";
    var bi;
    if (Pe(je, " argument"))
      bi = "The ".concat(je, " ").concat(Ue, " ").concat(Me(Ve, "type"));
    else {
      var vi = Te(je, ".") ? "property" : "argument";
      bi = 'The "'.concat(je, '" ').concat(vi, " ").concat(Ue, " ").concat(Me(Ve, "type"));
    }
    return bi += ". Received type ".concat(typeof fi), bi;
  }, TypeError), Ie("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), Ie("ERR_METHOD_NOT_IMPLEMENTED", function(je) {
    return "The " + je + " method is not implemented";
  }), Ie("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), Ie("ERR_STREAM_DESTROYED", function(je) {
    return "Cannot call " + je + " after a stream was destroyed";
  }), Ie("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), Ie("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), Ie("ERR_STREAM_WRITE_AFTER_END", "write after end"), Ie("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), Ie("ERR_UNKNOWN_ENCODING", function(je) {
    return "Unknown encoding: " + je;
  }, TypeError), Ie("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = t, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var Ae = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function t(Me, Be, Pe) {
    return Me.highWaterMark != null ? Me.highWaterMark : Be ? Me[Pe] : null;
  }
  function Ie(Me, Be, Pe, Te) {
    var je = t(Be, Te, Pe);
    if (je != null) {
      if (!(isFinite(je) && Math.floor(je) === je) || je < 0) {
        var Ve = Te ? Pe : "highWaterMark";
        throw new Ae(Ve, je);
      }
      return Math.floor(je);
    }
    return Me.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: Ie
  }, state;
}
var browser$b, hasRequiredBrowser$a;
function requireBrowser$a() {
  if (hasRequiredBrowser$a) return browser$b;
  hasRequiredBrowser$a = 1, browser$b = Ae;
  function Ae(Ie, Me) {
    if (t("noDeprecation"))
      return Ie;
    var Be = !1;
    function Pe() {
      if (!Be) {
        if (t("throwDeprecation"))
          throw new Error(Me);
        t("traceDeprecation") ? console.trace(Me) : console.warn(Me), Be = !0;
      }
      return Ie.apply(this, arguments);
    }
    return Pe;
  }
  function t(Ie) {
    try {
      if (!commonjsGlobal.localStorage) return !1;
    } catch {
      return !1;
    }
    var Me = commonjsGlobal.localStorage[Ie];
    return Me == null ? !1 : String(Me).toLowerCase() === "true";
  }
  return browser$b;
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = Yi;
  function Ae(fn) {
    var Bi = this;
    this.next = null, this.entry = null, this.finish = function() {
      Hi(Bi, fn);
    };
  }
  var t;
  Yi.WritableState = Qi;
  var Ie = {
    deprecate: requireBrowser$a()
  }, Me = requireStreamBrowser$1(), Be = require$$1$2.Buffer, Pe = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function Te(fn) {
    return Be.from(fn);
  }
  function je(fn) {
    return Be.isBuffer(fn) || fn instanceof Pe;
  }
  var Ve = requireDestroy$1(), fi = requireState(), Ue = fi.getHighWaterMark, bi = requireErrorsBrowser().codes, vi = bi.ERR_INVALID_ARG_TYPE, mi = bi.ERR_METHOD_NOT_IMPLEMENTED, _i = bi.ERR_MULTIPLE_CALLBACK, Ei = bi.ERR_STREAM_CANNOT_PIPE, Pi = bi.ERR_STREAM_DESTROYED, Ii = bi.ERR_STREAM_NULL_VALUES, Ci = bi.ERR_STREAM_WRITE_AFTER_END, Wi = bi.ERR_UNKNOWN_ENCODING, zi = Ve.errorOrDestroy;
  inherits_browserExports(Yi, Me);
  function Xi() {
  }
  function Qi(fn, Bi, ki) {
    t = t || require_stream_duplex$1(), fn = fn || {}, typeof ki != "boolean" && (ki = Bi instanceof t), this.objectMode = !!fn.objectMode, ki && (this.objectMode = this.objectMode || !!fn.writableObjectMode), this.highWaterMark = Ue(this, fn, "writableHighWaterMark", ki), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ji = fn.decodeStrings === !1;
    this.decodeStrings = !Ji, this.defaultEncoding = fn.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Ri) {
      Li(Bi, Ri);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = fn.emitClose !== !1, this.autoDestroy = !!fn.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Ae(this);
  }
  Qi.prototype.getBuffer = function() {
    for (var Bi = this.bufferedRequest, ki = []; Bi; )
      ki.push(Bi), Bi = Bi.next;
    return ki;
  }, function() {
    try {
      Object.defineProperty(Qi.prototype, "buffer", {
        get: Ie.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Oi;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Oi = Function.prototype[Symbol.hasInstance], Object.defineProperty(Yi, Symbol.hasInstance, {
    value: function(Bi) {
      return Oi.call(this, Bi) ? !0 : this !== Yi ? !1 : Bi && Bi._writableState instanceof Qi;
    }
  })) : Oi = function(Bi) {
    return Bi instanceof this;
  };
  function Yi(fn) {
    t = t || require_stream_duplex$1();
    var Bi = this instanceof t;
    if (!Bi && !Oi.call(Yi, this)) return new Yi(fn);
    this._writableState = new Qi(fn, this, Bi), this.writable = !0, fn && (typeof fn.write == "function" && (this._write = fn.write), typeof fn.writev == "function" && (this._writev = fn.writev), typeof fn.destroy == "function" && (this._destroy = fn.destroy), typeof fn.final == "function" && (this._final = fn.final)), Me.call(this);
  }
  Yi.prototype.pipe = function() {
    zi(this, new Ei());
  };
  function ns(fn, Bi) {
    var ki = new Ci();
    zi(fn, ki), process$1.nextTick(Bi, ki);
  }
  function ls(fn, Bi, ki, Ji) {
    var Ri;
    return ki === null ? Ri = new Ii() : typeof ki != "string" && !Bi.objectMode && (Ri = new vi("chunk", ["string", "Buffer"], ki)), Ri ? (zi(fn, Ri), process$1.nextTick(Ji, Ri), !1) : !0;
  }
  Yi.prototype.write = function(fn, Bi, ki) {
    var Ji = this._writableState, Ri = !1, ji = !Ji.objectMode && je(fn);
    return ji && !Be.isBuffer(fn) && (fn = Te(fn)), typeof Bi == "function" && (ki = Bi, Bi = null), ji ? Bi = "buffer" : Bi || (Bi = Ji.defaultEncoding), typeof ki != "function" && (ki = Xi), Ji.ending ? ns(this, ki) : (ji || ls(this, Ji, fn, ki)) && (Ji.pendingcb++, Ri = Mi(this, Ji, ji, fn, Bi, ki)), Ri;
  }, Yi.prototype.cork = function() {
    this._writableState.corked++;
  }, Yi.prototype.uncork = function() {
    var fn = this._writableState;
    fn.corked && (fn.corked--, !fn.writing && !fn.corked && !fn.bufferProcessing && fn.bufferedRequest && Ti(this, fn));
  }, Yi.prototype.setDefaultEncoding = function(Bi) {
    if (typeof Bi == "string" && (Bi = Bi.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Bi + "").toLowerCase()) > -1)) throw new Wi(Bi);
    return this._writableState.defaultEncoding = Bi, this;
  }, Object.defineProperty(Yi.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function vn(fn, Bi, ki) {
    return !fn.objectMode && fn.decodeStrings !== !1 && typeof Bi == "string" && (Bi = Be.from(Bi, ki)), Bi;
  }
  Object.defineProperty(Yi.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Mi(fn, Bi, ki, Ji, Ri, ji) {
    if (!ki) {
      var Gi = vn(Bi, Ji, Ri);
      Ji !== Gi && (ki = !0, Ri = "buffer", Ji = Gi);
    }
    var is = Bi.objectMode ? 1 : Ji.length;
    Bi.length += is;
    var os = Bi.length < Bi.highWaterMark;
    if (os || (Bi.needDrain = !0), Bi.writing || Bi.corked) {
      var ds = Bi.lastBufferedRequest;
      Bi.lastBufferedRequest = {
        chunk: Ji,
        encoding: Ri,
        isBuf: ki,
        callback: ji,
        next: null
      }, ds ? ds.next = Bi.lastBufferedRequest : Bi.bufferedRequest = Bi.lastBufferedRequest, Bi.bufferedRequestCount += 1;
    } else
      Ai(fn, Bi, !1, is, Ji, Ri, ji);
    return os;
  }
  function Ai(fn, Bi, ki, Ji, Ri, ji, Gi) {
    Bi.writelen = Ji, Bi.writecb = Gi, Bi.writing = !0, Bi.sync = !0, Bi.destroyed ? Bi.onwrite(new Pi("write")) : ki ? fn._writev(Ri, Bi.onwrite) : fn._write(Ri, ji, Bi.onwrite), Bi.sync = !1;
  }
  function wi(fn, Bi, ki, Ji, Ri) {
    --Bi.pendingcb, ki ? (process$1.nextTick(Ri, Ji), process$1.nextTick(Vi, fn, Bi), fn._writableState.errorEmitted = !0, zi(fn, Ji)) : (Ri(Ji), fn._writableState.errorEmitted = !0, zi(fn, Ji), Vi(fn, Bi));
  }
  function $i(fn) {
    fn.writing = !1, fn.writecb = null, fn.length -= fn.writelen, fn.writelen = 0;
  }
  function Li(fn, Bi) {
    var ki = fn._writableState, Ji = ki.sync, Ri = ki.writecb;
    if (typeof Ri != "function") throw new _i();
    if ($i(ki), Bi) wi(fn, ki, Ji, Bi, Ri);
    else {
      var ji = xi(ki) || fn.destroyed;
      !ji && !ki.corked && !ki.bufferProcessing && ki.bufferedRequest && Ti(fn, ki), Ji ? process$1.nextTick(qi, fn, ki, ji, Ri) : qi(fn, ki, ji, Ri);
    }
  }
  function qi(fn, Bi, ki, Ji) {
    ki || Ni(fn, Bi), Bi.pendingcb--, Ji(), Vi(fn, Bi);
  }
  function Ni(fn, Bi) {
    Bi.length === 0 && Bi.needDrain && (Bi.needDrain = !1, fn.emit("drain"));
  }
  function Ti(fn, Bi) {
    Bi.bufferProcessing = !0;
    var ki = Bi.bufferedRequest;
    if (fn._writev && ki && ki.next) {
      var Ji = Bi.bufferedRequestCount, Ri = new Array(Ji), ji = Bi.corkedRequestsFree;
      ji.entry = ki;
      for (var Gi = 0, is = !0; ki; )
        Ri[Gi] = ki, ki.isBuf || (is = !1), ki = ki.next, Gi += 1;
      Ri.allBuffers = is, Ai(fn, Bi, !0, Bi.length, Ri, "", ji.finish), Bi.pendingcb++, Bi.lastBufferedRequest = null, ji.next ? (Bi.corkedRequestsFree = ji.next, ji.next = null) : Bi.corkedRequestsFree = new Ae(Bi), Bi.bufferedRequestCount = 0;
    } else {
      for (; ki; ) {
        var os = ki.chunk, ds = ki.encoding, ps = ki.callback, ea = Bi.objectMode ? 1 : os.length;
        if (Ai(fn, Bi, !1, ea, os, ds, ps), ki = ki.next, Bi.bufferedRequestCount--, Bi.writing)
          break;
      }
      ki === null && (Bi.lastBufferedRequest = null);
    }
    Bi.bufferedRequest = ki, Bi.bufferProcessing = !1;
  }
  Yi.prototype._write = function(fn, Bi, ki) {
    ki(new mi("_write()"));
  }, Yi.prototype._writev = null, Yi.prototype.end = function(fn, Bi, ki) {
    var Ji = this._writableState;
    return typeof fn == "function" ? (ki = fn, fn = null, Bi = null) : typeof Bi == "function" && (ki = Bi, Bi = null), fn != null && this.write(fn, Bi), Ji.corked && (Ji.corked = 1, this.uncork()), Ji.ending || ts(this, Ji, ki), this;
  }, Object.defineProperty(Yi.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function xi(fn) {
    return fn.ending && fn.length === 0 && fn.bufferedRequest === null && !fn.finished && !fn.writing;
  }
  function Fi(fn, Bi) {
    fn._final(function(ki) {
      Bi.pendingcb--, ki && zi(fn, ki), Bi.prefinished = !0, fn.emit("prefinish"), Vi(fn, Bi);
    });
  }
  function Si(fn, Bi) {
    !Bi.prefinished && !Bi.finalCalled && (typeof fn._final == "function" && !Bi.destroyed ? (Bi.pendingcb++, Bi.finalCalled = !0, process$1.nextTick(Fi, fn, Bi)) : (Bi.prefinished = !0, fn.emit("prefinish")));
  }
  function Vi(fn, Bi) {
    var ki = xi(Bi);
    if (ki && (Si(fn, Bi), Bi.pendingcb === 0 && (Bi.finished = !0, fn.emit("finish"), Bi.autoDestroy))) {
      var Ji = fn._readableState;
      (!Ji || Ji.autoDestroy && Ji.endEmitted) && fn.destroy();
    }
    return ki;
  }
  function ts(fn, Bi, ki) {
    Bi.ending = !0, Vi(fn, Bi), ki && (Bi.finished ? process$1.nextTick(ki) : fn.once("finish", ki)), Bi.ended = !0, fn.writable = !1;
  }
  function Hi(fn, Bi, ki) {
    var Ji = fn.entry;
    for (fn.entry = null; Ji; ) {
      var Ri = Ji.callback;
      Bi.pendingcb--, Ri(ki), Ji = Ji.next;
    }
    Bi.corkedRequestsFree.next = fn;
  }
  return Object.defineProperty(Yi.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Bi) {
      this._writableState && (this._writableState.destroyed = Bi);
    }
  }), Yi.prototype.destroy = Ve.destroy, Yi.prototype._undestroy = Ve.undestroy, Yi.prototype._destroy = function(fn, Bi) {
    Bi(fn);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var Ae = Object.keys || function(fi) {
    var Ue = [];
    for (var bi in fi) Ue.push(bi);
    return Ue;
  };
  _stream_duplex$1 = Te;
  var t = require_stream_readable$1(), Ie = require_stream_writable$1();
  inherits_browserExports(Te, t);
  for (var Me = Ae(Ie.prototype), Be = 0; Be < Me.length; Be++) {
    var Pe = Me[Be];
    Te.prototype[Pe] || (Te.prototype[Pe] = Ie.prototype[Pe]);
  }
  function Te(fi) {
    if (!(this instanceof Te)) return new Te(fi);
    t.call(this, fi), Ie.call(this, fi), this.allowHalfOpen = !0, fi && (fi.readable === !1 && (this.readable = !1), fi.writable === !1 && (this.writable = !1), fi.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", je)));
  }
  Object.defineProperty(Te.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(Te.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(Te.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function je() {
    this._writableState.ended || process$1.nextTick(Ve, this);
  }
  function Ve(fi) {
    fi.end();
  }
  return Object.defineProperty(Te.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(Ue) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = Ue, this._writableState.destroyed = Ue);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = Ae.isEncoding || function(Ii) {
    switch (Ii = "" + Ii, Ii && Ii.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function Ie(Ii) {
    if (!Ii) return "utf8";
    for (var Ci; ; )
      switch (Ii) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return Ii;
        default:
          if (Ci) return;
          Ii = ("" + Ii).toLowerCase(), Ci = !0;
      }
  }
  function Me(Ii) {
    var Ci = Ie(Ii);
    if (typeof Ci != "string" && (Ae.isEncoding === t || !t(Ii))) throw new Error("Unknown encoding: " + Ii);
    return Ci || Ii;
  }
  string_decoder.StringDecoder = Be;
  function Be(Ii) {
    this.encoding = Me(Ii);
    var Ci;
    switch (this.encoding) {
      case "utf16le":
        this.text = bi, this.end = vi, Ci = 4;
        break;
      case "utf8":
        this.fillLast = Ve, Ci = 4;
        break;
      case "base64":
        this.text = mi, this.end = _i, Ci = 3;
        break;
      default:
        this.write = Ei, this.end = Pi;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Ae.allocUnsafe(Ci);
  }
  Be.prototype.write = function(Ii) {
    if (Ii.length === 0) return "";
    var Ci, Wi;
    if (this.lastNeed) {
      if (Ci = this.fillLast(Ii), Ci === void 0) return "";
      Wi = this.lastNeed, this.lastNeed = 0;
    } else
      Wi = 0;
    return Wi < Ii.length ? Ci ? Ci + this.text(Ii, Wi) : this.text(Ii, Wi) : Ci || "";
  }, Be.prototype.end = Ue, Be.prototype.text = fi, Be.prototype.fillLast = function(Ii) {
    if (this.lastNeed <= Ii.length)
      return Ii.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    Ii.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, Ii.length), this.lastNeed -= Ii.length;
  };
  function Pe(Ii) {
    return Ii <= 127 ? 0 : Ii >> 5 === 6 ? 2 : Ii >> 4 === 14 ? 3 : Ii >> 3 === 30 ? 4 : Ii >> 6 === 2 ? -1 : -2;
  }
  function Te(Ii, Ci, Wi) {
    var zi = Ci.length - 1;
    if (zi < Wi) return 0;
    var Xi = Pe(Ci[zi]);
    return Xi >= 0 ? (Xi > 0 && (Ii.lastNeed = Xi - 1), Xi) : --zi < Wi || Xi === -2 ? 0 : (Xi = Pe(Ci[zi]), Xi >= 0 ? (Xi > 0 && (Ii.lastNeed = Xi - 2), Xi) : --zi < Wi || Xi === -2 ? 0 : (Xi = Pe(Ci[zi]), Xi >= 0 ? (Xi > 0 && (Xi === 2 ? Xi = 0 : Ii.lastNeed = Xi - 3), Xi) : 0));
  }
  function je(Ii, Ci, Wi) {
    if ((Ci[0] & 192) !== 128)
      return Ii.lastNeed = 0, "�";
    if (Ii.lastNeed > 1 && Ci.length > 1) {
      if ((Ci[1] & 192) !== 128)
        return Ii.lastNeed = 1, "�";
      if (Ii.lastNeed > 2 && Ci.length > 2 && (Ci[2] & 192) !== 128)
        return Ii.lastNeed = 2, "�";
    }
  }
  function Ve(Ii) {
    var Ci = this.lastTotal - this.lastNeed, Wi = je(this, Ii);
    if (Wi !== void 0) return Wi;
    if (this.lastNeed <= Ii.length)
      return Ii.copy(this.lastChar, Ci, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    Ii.copy(this.lastChar, Ci, 0, Ii.length), this.lastNeed -= Ii.length;
  }
  function fi(Ii, Ci) {
    var Wi = Te(this, Ii, Ci);
    if (!this.lastNeed) return Ii.toString("utf8", Ci);
    this.lastTotal = Wi;
    var zi = Ii.length - (Wi - this.lastNeed);
    return Ii.copy(this.lastChar, 0, zi), Ii.toString("utf8", Ci, zi);
  }
  function Ue(Ii) {
    var Ci = Ii && Ii.length ? this.write(Ii) : "";
    return this.lastNeed ? Ci + "�" : Ci;
  }
  function bi(Ii, Ci) {
    if ((Ii.length - Ci) % 2 === 0) {
      var Wi = Ii.toString("utf16le", Ci);
      if (Wi) {
        var zi = Wi.charCodeAt(Wi.length - 1);
        if (zi >= 55296 && zi <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = Ii[Ii.length - 2], this.lastChar[1] = Ii[Ii.length - 1], Wi.slice(0, -1);
      }
      return Wi;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = Ii[Ii.length - 1], Ii.toString("utf16le", Ci, Ii.length - 1);
  }
  function vi(Ii) {
    var Ci = Ii && Ii.length ? this.write(Ii) : "";
    if (this.lastNeed) {
      var Wi = this.lastTotal - this.lastNeed;
      return Ci + this.lastChar.toString("utf16le", 0, Wi);
    }
    return Ci;
  }
  function mi(Ii, Ci) {
    var Wi = (Ii.length - Ci) % 3;
    return Wi === 0 ? Ii.toString("base64", Ci) : (this.lastNeed = 3 - Wi, this.lastTotal = 3, Wi === 1 ? this.lastChar[0] = Ii[Ii.length - 1] : (this.lastChar[0] = Ii[Ii.length - 2], this.lastChar[1] = Ii[Ii.length - 1]), Ii.toString("base64", Ci, Ii.length - Wi));
  }
  function _i(Ii) {
    var Ci = Ii && Ii.length ? this.write(Ii) : "";
    return this.lastNeed ? Ci + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : Ci;
  }
  function Ei(Ii) {
    return Ii.toString(this.encoding);
  }
  function Pi(Ii) {
    return Ii && Ii.length ? this.write(Ii) : "";
  }
  return string_decoder;
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var Ae = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function t(Pe) {
    var Te = !1;
    return function() {
      if (!Te) {
        Te = !0;
        for (var je = arguments.length, Ve = new Array(je), fi = 0; fi < je; fi++)
          Ve[fi] = arguments[fi];
        Pe.apply(this, Ve);
      }
    };
  }
  function Ie() {
  }
  function Me(Pe) {
    return Pe.setHeader && typeof Pe.abort == "function";
  }
  function Be(Pe, Te, je) {
    if (typeof Te == "function") return Be(Pe, null, Te);
    Te || (Te = {}), je = t(je || Ie);
    var Ve = Te.readable || Te.readable !== !1 && Pe.readable, fi = Te.writable || Te.writable !== !1 && Pe.writable, Ue = function() {
      Pe.writable || vi();
    }, bi = Pe._writableState && Pe._writableState.finished, vi = function() {
      fi = !1, bi = !0, Ve || je.call(Pe);
    }, mi = Pe._readableState && Pe._readableState.endEmitted, _i = function() {
      Ve = !1, mi = !0, fi || je.call(Pe);
    }, Ei = function(Wi) {
      je.call(Pe, Wi);
    }, Pi = function() {
      var Wi;
      if (Ve && !mi)
        return (!Pe._readableState || !Pe._readableState.ended) && (Wi = new Ae()), je.call(Pe, Wi);
      if (fi && !bi)
        return (!Pe._writableState || !Pe._writableState.ended) && (Wi = new Ae()), je.call(Pe, Wi);
    }, Ii = function() {
      Pe.req.on("finish", vi);
    };
    return Me(Pe) ? (Pe.on("complete", vi), Pe.on("abort", Pi), Pe.req ? Ii() : Pe.on("request", Ii)) : fi && !Pe._writableState && (Pe.on("end", Ue), Pe.on("close", Ue)), Pe.on("end", _i), Pe.on("finish", vi), Te.error !== !1 && Pe.on("error", Ei), Pe.on("close", Pi), function() {
      Pe.removeListener("complete", vi), Pe.removeListener("abort", Pi), Pe.removeListener("request", Ii), Pe.req && Pe.req.removeListener("finish", vi), Pe.removeListener("end", Ue), Pe.removeListener("close", Ue), Pe.removeListener("finish", vi), Pe.removeListener("end", _i), Pe.removeListener("error", Ei), Pe.removeListener("close", Pi);
    };
  }
  return endOfStream = Be, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var Ae;
  function t(Wi, zi, Xi) {
    return zi = Ie(zi), zi in Wi ? Object.defineProperty(Wi, zi, { value: Xi, enumerable: !0, configurable: !0, writable: !0 }) : Wi[zi] = Xi, Wi;
  }
  function Ie(Wi) {
    var zi = Me(Wi, "string");
    return typeof zi == "symbol" ? zi : String(zi);
  }
  function Me(Wi, zi) {
    if (typeof Wi != "object" || Wi === null) return Wi;
    var Xi = Wi[Symbol.toPrimitive];
    if (Xi !== void 0) {
      var Qi = Xi.call(Wi, zi || "default");
      if (typeof Qi != "object") return Qi;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (zi === "string" ? String : Number)(Wi);
  }
  var Be = requireEndOfStream(), Pe = Symbol("lastResolve"), Te = Symbol("lastReject"), je = Symbol("error"), Ve = Symbol("ended"), fi = Symbol("lastPromise"), Ue = Symbol("handlePromise"), bi = Symbol("stream");
  function vi(Wi, zi) {
    return {
      value: Wi,
      done: zi
    };
  }
  function mi(Wi) {
    var zi = Wi[Pe];
    if (zi !== null) {
      var Xi = Wi[bi].read();
      Xi !== null && (Wi[fi] = null, Wi[Pe] = null, Wi[Te] = null, zi(vi(Xi, !1)));
    }
  }
  function _i(Wi) {
    process$1.nextTick(mi, Wi);
  }
  function Ei(Wi, zi) {
    return function(Xi, Qi) {
      Wi.then(function() {
        if (zi[Ve]) {
          Xi(vi(void 0, !0));
          return;
        }
        zi[Ue](Xi, Qi);
      }, Qi);
    };
  }
  var Pi = Object.getPrototypeOf(function() {
  }), Ii = Object.setPrototypeOf((Ae = {
    get stream() {
      return this[bi];
    },
    next: function() {
      var zi = this, Xi = this[je];
      if (Xi !== null)
        return Promise.reject(Xi);
      if (this[Ve])
        return Promise.resolve(vi(void 0, !0));
      if (this[bi].destroyed)
        return new Promise(function(ns, ls) {
          process$1.nextTick(function() {
            zi[je] ? ls(zi[je]) : ns(vi(void 0, !0));
          });
        });
      var Qi = this[fi], Oi;
      if (Qi)
        Oi = new Promise(Ei(Qi, this));
      else {
        var Yi = this[bi].read();
        if (Yi !== null)
          return Promise.resolve(vi(Yi, !1));
        Oi = new Promise(this[Ue]);
      }
      return this[fi] = Oi, Oi;
    }
  }, t(Ae, Symbol.asyncIterator, function() {
    return this;
  }), t(Ae, "return", function() {
    var zi = this;
    return new Promise(function(Xi, Qi) {
      zi[bi].destroy(null, function(Oi) {
        if (Oi) {
          Qi(Oi);
          return;
        }
        Xi(vi(void 0, !0));
      });
    });
  }), Ae), Pi), Ci = function(zi) {
    var Xi, Qi = Object.create(Ii, (Xi = {}, t(Xi, bi, {
      value: zi,
      writable: !0
    }), t(Xi, Pe, {
      value: null,
      writable: !0
    }), t(Xi, Te, {
      value: null,
      writable: !0
    }), t(Xi, je, {
      value: null,
      writable: !0
    }), t(Xi, Ve, {
      value: zi._readableState.endEmitted,
      writable: !0
    }), t(Xi, Ue, {
      value: function(Yi, ns) {
        var ls = Qi[bi].read();
        ls ? (Qi[fi] = null, Qi[Pe] = null, Qi[Te] = null, Yi(vi(ls, !1))) : (Qi[Pe] = Yi, Qi[Te] = ns);
      },
      writable: !0
    }), Xi));
    return Qi[fi] = null, Be(zi, function(Oi) {
      if (Oi && Oi.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Yi = Qi[Te];
        Yi !== null && (Qi[fi] = null, Qi[Pe] = null, Qi[Te] = null, Yi(Oi)), Qi[je] = Oi;
        return;
      }
      var ns = Qi[Pe];
      ns !== null && (Qi[fi] = null, Qi[Pe] = null, Qi[Te] = null, ns(vi(void 0, !0))), Qi[Ve] = !0;
    }), zi.on("readable", _i.bind(null, Qi)), Qi;
  };
  return async_iterator = Ci, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = ns;
  var Ae;
  ns.ReadableState = Yi, eventsExports.EventEmitter;
  var t = function(Gi, is) {
    return Gi.listeners(is).length;
  }, Ie = requireStreamBrowser$1(), Me = require$$1$2.Buffer, Be = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function Pe(ji) {
    return Me.from(ji);
  }
  function Te(ji) {
    return Me.isBuffer(ji) || ji instanceof Be;
  }
  var je = requireUtil$1(), Ve;
  je && je.debuglog ? Ve = je.debuglog("stream") : Ve = function() {
  };
  var fi = requireBuffer_list(), Ue = requireDestroy$1(), bi = requireState(), vi = bi.getHighWaterMark, mi = requireErrorsBrowser().codes, _i = mi.ERR_INVALID_ARG_TYPE, Ei = mi.ERR_STREAM_PUSH_AFTER_EOF, Pi = mi.ERR_METHOD_NOT_IMPLEMENTED, Ii = mi.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Ci, Wi, zi;
  inherits_browserExports(ns, Ie);
  var Xi = Ue.errorOrDestroy, Qi = ["error", "close", "destroy", "pause", "resume"];
  function Oi(ji, Gi, is) {
    if (typeof ji.prependListener == "function") return ji.prependListener(Gi, is);
    !ji._events || !ji._events[Gi] ? ji.on(Gi, is) : Array.isArray(ji._events[Gi]) ? ji._events[Gi].unshift(is) : ji._events[Gi] = [is, ji._events[Gi]];
  }
  function Yi(ji, Gi, is) {
    Ae = Ae || require_stream_duplex$1(), ji = ji || {}, typeof is != "boolean" && (is = Gi instanceof Ae), this.objectMode = !!ji.objectMode, is && (this.objectMode = this.objectMode || !!ji.readableObjectMode), this.highWaterMark = vi(this, ji, "readableHighWaterMark", is), this.buffer = new fi(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = ji.emitClose !== !1, this.autoDestroy = !!ji.autoDestroy, this.destroyed = !1, this.defaultEncoding = ji.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, ji.encoding && (Ci || (Ci = requireString_decoder().StringDecoder), this.decoder = new Ci(ji.encoding), this.encoding = ji.encoding);
  }
  function ns(ji) {
    if (Ae = Ae || require_stream_duplex$1(), !(this instanceof ns)) return new ns(ji);
    var Gi = this instanceof Ae;
    this._readableState = new Yi(ji, this, Gi), this.readable = !0, ji && (typeof ji.read == "function" && (this._read = ji.read), typeof ji.destroy == "function" && (this._destroy = ji.destroy)), Ie.call(this);
  }
  Object.defineProperty(ns.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Gi) {
      this._readableState && (this._readableState.destroyed = Gi);
    }
  }), ns.prototype.destroy = Ue.destroy, ns.prototype._undestroy = Ue.undestroy, ns.prototype._destroy = function(ji, Gi) {
    Gi(ji);
  }, ns.prototype.push = function(ji, Gi) {
    var is = this._readableState, os;
    return is.objectMode ? os = !0 : typeof ji == "string" && (Gi = Gi || is.defaultEncoding, Gi !== is.encoding && (ji = Me.from(ji, Gi), Gi = ""), os = !0), ls(this, ji, Gi, !1, os);
  }, ns.prototype.unshift = function(ji) {
    return ls(this, ji, null, !0, !1);
  };
  function ls(ji, Gi, is, os, ds) {
    Ve("readableAddChunk", Gi);
    var ps = ji._readableState;
    if (Gi === null)
      ps.reading = !1, Li(ji, ps);
    else {
      var ea;
      if (ds || (ea = Mi(ps, Gi)), ea)
        Xi(ji, ea);
      else if (ps.objectMode || Gi && Gi.length > 0)
        if (typeof Gi != "string" && !ps.objectMode && Object.getPrototypeOf(Gi) !== Me.prototype && (Gi = Pe(Gi)), os)
          ps.endEmitted ? Xi(ji, new Ii()) : vn(ji, ps, Gi, !0);
        else if (ps.ended)
          Xi(ji, new Ei());
        else {
          if (ps.destroyed)
            return !1;
          ps.reading = !1, ps.decoder && !is ? (Gi = ps.decoder.write(Gi), ps.objectMode || Gi.length !== 0 ? vn(ji, ps, Gi, !1) : Ti(ji, ps)) : vn(ji, ps, Gi, !1);
        }
      else os || (ps.reading = !1, Ti(ji, ps));
    }
    return !ps.ended && (ps.length < ps.highWaterMark || ps.length === 0);
  }
  function vn(ji, Gi, is, os) {
    Gi.flowing && Gi.length === 0 && !Gi.sync ? (Gi.awaitDrain = 0, ji.emit("data", is)) : (Gi.length += Gi.objectMode ? 1 : is.length, os ? Gi.buffer.unshift(is) : Gi.buffer.push(is), Gi.needReadable && qi(ji)), Ti(ji, Gi);
  }
  function Mi(ji, Gi) {
    var is;
    return !Te(Gi) && typeof Gi != "string" && Gi !== void 0 && !ji.objectMode && (is = new _i("chunk", ["string", "Buffer", "Uint8Array"], Gi)), is;
  }
  ns.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, ns.prototype.setEncoding = function(ji) {
    Ci || (Ci = requireString_decoder().StringDecoder);
    var Gi = new Ci(ji);
    this._readableState.decoder = Gi, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var is = this._readableState.buffer.head, os = ""; is !== null; )
      os += Gi.write(is.data), is = is.next;
    return this._readableState.buffer.clear(), os !== "" && this._readableState.buffer.push(os), this._readableState.length = os.length, this;
  };
  var Ai = 1073741824;
  function wi(ji) {
    return ji >= Ai ? ji = Ai : (ji--, ji |= ji >>> 1, ji |= ji >>> 2, ji |= ji >>> 4, ji |= ji >>> 8, ji |= ji >>> 16, ji++), ji;
  }
  function $i(ji, Gi) {
    return ji <= 0 || Gi.length === 0 && Gi.ended ? 0 : Gi.objectMode ? 1 : ji !== ji ? Gi.flowing && Gi.length ? Gi.buffer.head.data.length : Gi.length : (ji > Gi.highWaterMark && (Gi.highWaterMark = wi(ji)), ji <= Gi.length ? ji : Gi.ended ? Gi.length : (Gi.needReadable = !0, 0));
  }
  ns.prototype.read = function(ji) {
    Ve("read", ji), ji = parseInt(ji, 10);
    var Gi = this._readableState, is = ji;
    if (ji !== 0 && (Gi.emittedReadable = !1), ji === 0 && Gi.needReadable && ((Gi.highWaterMark !== 0 ? Gi.length >= Gi.highWaterMark : Gi.length > 0) || Gi.ended))
      return Ve("read: emitReadable", Gi.length, Gi.ended), Gi.length === 0 && Gi.ended ? ki(this) : qi(this), null;
    if (ji = $i(ji, Gi), ji === 0 && Gi.ended)
      return Gi.length === 0 && ki(this), null;
    var os = Gi.needReadable;
    Ve("need readable", os), (Gi.length === 0 || Gi.length - ji < Gi.highWaterMark) && (os = !0, Ve("length less than watermark", os)), Gi.ended || Gi.reading ? (os = !1, Ve("reading or ended", os)) : os && (Ve("do read"), Gi.reading = !0, Gi.sync = !0, Gi.length === 0 && (Gi.needReadable = !0), this._read(Gi.highWaterMark), Gi.sync = !1, Gi.reading || (ji = $i(is, Gi)));
    var ds;
    return ji > 0 ? ds = Bi(ji, Gi) : ds = null, ds === null ? (Gi.needReadable = Gi.length <= Gi.highWaterMark, ji = 0) : (Gi.length -= ji, Gi.awaitDrain = 0), Gi.length === 0 && (Gi.ended || (Gi.needReadable = !0), is !== ji && Gi.ended && ki(this)), ds !== null && this.emit("data", ds), ds;
  };
  function Li(ji, Gi) {
    if (Ve("onEofChunk"), !Gi.ended) {
      if (Gi.decoder) {
        var is = Gi.decoder.end();
        is && is.length && (Gi.buffer.push(is), Gi.length += Gi.objectMode ? 1 : is.length);
      }
      Gi.ended = !0, Gi.sync ? qi(ji) : (Gi.needReadable = !1, Gi.emittedReadable || (Gi.emittedReadable = !0, Ni(ji)));
    }
  }
  function qi(ji) {
    var Gi = ji._readableState;
    Ve("emitReadable", Gi.needReadable, Gi.emittedReadable), Gi.needReadable = !1, Gi.emittedReadable || (Ve("emitReadable", Gi.flowing), Gi.emittedReadable = !0, process$1.nextTick(Ni, ji));
  }
  function Ni(ji) {
    var Gi = ji._readableState;
    Ve("emitReadable_", Gi.destroyed, Gi.length, Gi.ended), !Gi.destroyed && (Gi.length || Gi.ended) && (ji.emit("readable"), Gi.emittedReadable = !1), Gi.needReadable = !Gi.flowing && !Gi.ended && Gi.length <= Gi.highWaterMark, fn(ji);
  }
  function Ti(ji, Gi) {
    Gi.readingMore || (Gi.readingMore = !0, process$1.nextTick(xi, ji, Gi));
  }
  function xi(ji, Gi) {
    for (; !Gi.reading && !Gi.ended && (Gi.length < Gi.highWaterMark || Gi.flowing && Gi.length === 0); ) {
      var is = Gi.length;
      if (Ve("maybeReadMore read 0"), ji.read(0), is === Gi.length)
        break;
    }
    Gi.readingMore = !1;
  }
  ns.prototype._read = function(ji) {
    Xi(this, new Pi("_read()"));
  }, ns.prototype.pipe = function(ji, Gi) {
    var is = this, os = this._readableState;
    switch (os.pipesCount) {
      case 0:
        os.pipes = ji;
        break;
      case 1:
        os.pipes = [os.pipes, ji];
        break;
      default:
        os.pipes.push(ji);
        break;
    }
    os.pipesCount += 1, Ve("pipe count=%d opts=%j", os.pipesCount, Gi);
    var ds = (!Gi || Gi.end !== !1) && ji !== process$1.stdout && ji !== process$1.stderr, ps = ds ? ia : ca;
    os.endEmitted ? process$1.nextTick(ps) : is.once("end", ps), ji.on("unpipe", ea);
    function ea(ta, oa) {
      Ve("onunpipe"), ta === is && oa && oa.hasUnpiped === !1 && (oa.hasUnpiped = !0, gs());
    }
    function ia() {
      Ve("onend"), ji.end();
    }
    var hs = Fi(is);
    ji.on("drain", hs);
    var fa = !1;
    function gs() {
      Ve("cleanup"), ji.removeListener("close", Ds), ji.removeListener("finish", ra), ji.removeListener("drain", hs), ji.removeListener("error", aa), ji.removeListener("unpipe", ea), is.removeListener("end", ia), is.removeListener("end", ca), is.removeListener("data", sa), fa = !0, os.awaitDrain && (!ji._writableState || ji._writableState.needDrain) && hs();
    }
    is.on("data", sa);
    function sa(ta) {
      Ve("ondata");
      var oa = ji.write(ta);
      Ve("dest.write", oa), oa === !1 && ((os.pipesCount === 1 && os.pipes === ji || os.pipesCount > 1 && Ri(os.pipes, ji) !== -1) && !fa && (Ve("false write response, pause", os.awaitDrain), os.awaitDrain++), is.pause());
    }
    function aa(ta) {
      Ve("onerror", ta), ca(), ji.removeListener("error", aa), t(ji, "error") === 0 && Xi(ji, ta);
    }
    Oi(ji, "error", aa);
    function Ds() {
      ji.removeListener("finish", ra), ca();
    }
    ji.once("close", Ds);
    function ra() {
      Ve("onfinish"), ji.removeListener("close", Ds), ca();
    }
    ji.once("finish", ra);
    function ca() {
      Ve("unpipe"), is.unpipe(ji);
    }
    return ji.emit("pipe", is), os.flowing || (Ve("pipe resume"), is.resume()), ji;
  };
  function Fi(ji) {
    return function() {
      var is = ji._readableState;
      Ve("pipeOnDrain", is.awaitDrain), is.awaitDrain && is.awaitDrain--, is.awaitDrain === 0 && t(ji, "data") && (is.flowing = !0, fn(ji));
    };
  }
  ns.prototype.unpipe = function(ji) {
    var Gi = this._readableState, is = {
      hasUnpiped: !1
    };
    if (Gi.pipesCount === 0) return this;
    if (Gi.pipesCount === 1)
      return ji && ji !== Gi.pipes ? this : (ji || (ji = Gi.pipes), Gi.pipes = null, Gi.pipesCount = 0, Gi.flowing = !1, ji && ji.emit("unpipe", this, is), this);
    if (!ji) {
      var os = Gi.pipes, ds = Gi.pipesCount;
      Gi.pipes = null, Gi.pipesCount = 0, Gi.flowing = !1;
      for (var ps = 0; ps < ds; ps++) os[ps].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var ea = Ri(Gi.pipes, ji);
    return ea === -1 ? this : (Gi.pipes.splice(ea, 1), Gi.pipesCount -= 1, Gi.pipesCount === 1 && (Gi.pipes = Gi.pipes[0]), ji.emit("unpipe", this, is), this);
  }, ns.prototype.on = function(ji, Gi) {
    var is = Ie.prototype.on.call(this, ji, Gi), os = this._readableState;
    return ji === "data" ? (os.readableListening = this.listenerCount("readable") > 0, os.flowing !== !1 && this.resume()) : ji === "readable" && !os.endEmitted && !os.readableListening && (os.readableListening = os.needReadable = !0, os.flowing = !1, os.emittedReadable = !1, Ve("on readable", os.length, os.reading), os.length ? qi(this) : os.reading || process$1.nextTick(Vi, this)), is;
  }, ns.prototype.addListener = ns.prototype.on, ns.prototype.removeListener = function(ji, Gi) {
    var is = Ie.prototype.removeListener.call(this, ji, Gi);
    return ji === "readable" && process$1.nextTick(Si, this), is;
  }, ns.prototype.removeAllListeners = function(ji) {
    var Gi = Ie.prototype.removeAllListeners.apply(this, arguments);
    return (ji === "readable" || ji === void 0) && process$1.nextTick(Si, this), Gi;
  };
  function Si(ji) {
    var Gi = ji._readableState;
    Gi.readableListening = ji.listenerCount("readable") > 0, Gi.resumeScheduled && !Gi.paused ? Gi.flowing = !0 : ji.listenerCount("data") > 0 && ji.resume();
  }
  function Vi(ji) {
    Ve("readable nexttick read 0"), ji.read(0);
  }
  ns.prototype.resume = function() {
    var ji = this._readableState;
    return ji.flowing || (Ve("resume"), ji.flowing = !ji.readableListening, ts(this, ji)), ji.paused = !1, this;
  };
  function ts(ji, Gi) {
    Gi.resumeScheduled || (Gi.resumeScheduled = !0, process$1.nextTick(Hi, ji, Gi));
  }
  function Hi(ji, Gi) {
    Ve("resume", Gi.reading), Gi.reading || ji.read(0), Gi.resumeScheduled = !1, ji.emit("resume"), fn(ji), Gi.flowing && !Gi.reading && ji.read(0);
  }
  ns.prototype.pause = function() {
    return Ve("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (Ve("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function fn(ji) {
    var Gi = ji._readableState;
    for (Ve("flow", Gi.flowing); Gi.flowing && ji.read() !== null; ) ;
  }
  ns.prototype.wrap = function(ji) {
    var Gi = this, is = this._readableState, os = !1;
    ji.on("end", function() {
      if (Ve("wrapped end"), is.decoder && !is.ended) {
        var ea = is.decoder.end();
        ea && ea.length && Gi.push(ea);
      }
      Gi.push(null);
    }), ji.on("data", function(ea) {
      if (Ve("wrapped data"), is.decoder && (ea = is.decoder.write(ea)), !(is.objectMode && ea == null) && !(!is.objectMode && (!ea || !ea.length))) {
        var ia = Gi.push(ea);
        ia || (os = !0, ji.pause());
      }
    });
    for (var ds in ji)
      this[ds] === void 0 && typeof ji[ds] == "function" && (this[ds] = /* @__PURE__ */ function(ia) {
        return function() {
          return ji[ia].apply(ji, arguments);
        };
      }(ds));
    for (var ps = 0; ps < Qi.length; ps++)
      ji.on(Qi[ps], this.emit.bind(this, Qi[ps]));
    return this._read = function(ea) {
      Ve("wrapped _read", ea), os && (os = !1, ji.resume());
    }, this;
  }, typeof Symbol == "function" && (ns.prototype[Symbol.asyncIterator] = function() {
    return Wi === void 0 && (Wi = requireAsync_iterator()), Wi(this);
  }), Object.defineProperty(ns.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(ns.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(ns.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(Gi) {
      this._readableState && (this._readableState.flowing = Gi);
    }
  }), ns._fromList = Bi, Object.defineProperty(ns.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Bi(ji, Gi) {
    if (Gi.length === 0) return null;
    var is;
    return Gi.objectMode ? is = Gi.buffer.shift() : !ji || ji >= Gi.length ? (Gi.decoder ? is = Gi.buffer.join("") : Gi.buffer.length === 1 ? is = Gi.buffer.first() : is = Gi.buffer.concat(Gi.length), Gi.buffer.clear()) : is = Gi.buffer.consume(ji, Gi.decoder), is;
  }
  function ki(ji) {
    var Gi = ji._readableState;
    Ve("endReadable", Gi.endEmitted), Gi.endEmitted || (Gi.ended = !0, process$1.nextTick(Ji, Gi, ji));
  }
  function Ji(ji, Gi) {
    if (Ve("endReadableNT", ji.endEmitted, ji.length), !ji.endEmitted && ji.length === 0 && (ji.endEmitted = !0, Gi.readable = !1, Gi.emit("end"), ji.autoDestroy)) {
      var is = Gi._writableState;
      (!is || is.autoDestroy && is.finished) && Gi.destroy();
    }
  }
  typeof Symbol == "function" && (ns.from = function(ji, Gi) {
    return zi === void 0 && (zi = requireFromBrowser()), zi(ns, ji, Gi);
  });
  function Ri(ji, Gi) {
    for (var is = 0, os = ji.length; is < os; is++)
      if (ji[is] === Gi) return is;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1) return _stream_transform$1;
  hasRequired_stream_transform$1 = 1, _stream_transform$1 = je;
  var Ae = requireErrorsBrowser().codes, t = Ae.ERR_METHOD_NOT_IMPLEMENTED, Ie = Ae.ERR_MULTIPLE_CALLBACK, Me = Ae.ERR_TRANSFORM_ALREADY_TRANSFORMING, Be = Ae.ERR_TRANSFORM_WITH_LENGTH_0, Pe = require_stream_duplex$1();
  inherits_browserExports(je, Pe);
  function Te(Ue, bi) {
    var vi = this._transformState;
    vi.transforming = !1;
    var mi = vi.writecb;
    if (mi === null)
      return this.emit("error", new Ie());
    vi.writechunk = null, vi.writecb = null, bi != null && this.push(bi), mi(Ue);
    var _i = this._readableState;
    _i.reading = !1, (_i.needReadable || _i.length < _i.highWaterMark) && this._read(_i.highWaterMark);
  }
  function je(Ue) {
    if (!(this instanceof je)) return new je(Ue);
    Pe.call(this, Ue), this._transformState = {
      afterTransform: Te.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, Ue && (typeof Ue.transform == "function" && (this._transform = Ue.transform), typeof Ue.flush == "function" && (this._flush = Ue.flush)), this.on("prefinish", Ve);
  }
  function Ve() {
    var Ue = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(bi, vi) {
      fi(Ue, bi, vi);
    }) : fi(this, null, null);
  }
  je.prototype.push = function(Ue, bi) {
    return this._transformState.needTransform = !1, Pe.prototype.push.call(this, Ue, bi);
  }, je.prototype._transform = function(Ue, bi, vi) {
    vi(new t("_transform()"));
  }, je.prototype._write = function(Ue, bi, vi) {
    var mi = this._transformState;
    if (mi.writecb = vi, mi.writechunk = Ue, mi.writeencoding = bi, !mi.transforming) {
      var _i = this._readableState;
      (mi.needTransform || _i.needReadable || _i.length < _i.highWaterMark) && this._read(_i.highWaterMark);
    }
  }, je.prototype._read = function(Ue) {
    var bi = this._transformState;
    bi.writechunk !== null && !bi.transforming ? (bi.transforming = !0, this._transform(bi.writechunk, bi.writeencoding, bi.afterTransform)) : bi.needTransform = !0;
  }, je.prototype._destroy = function(Ue, bi) {
    Pe.prototype._destroy.call(this, Ue, function(vi) {
      bi(vi);
    });
  };
  function fi(Ue, bi, vi) {
    if (bi) return Ue.emit("error", bi);
    if (vi != null && Ue.push(vi), Ue._writableState.length) throw new Be();
    if (Ue._transformState.transforming) throw new Me();
    return Ue.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1, _stream_passthrough$1 = t;
  var Ae = require_stream_transform$1();
  inherits_browserExports(t, Ae);
  function t(Ie) {
    if (!(this instanceof t)) return new t(Ie);
    Ae.call(this, Ie);
  }
  return t.prototype._transform = function(Ie, Me, Be) {
    Be(null, Ie);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var Ae;
  function t(vi) {
    var mi = !1;
    return function() {
      mi || (mi = !0, vi.apply(void 0, arguments));
    };
  }
  var Ie = requireErrorsBrowser().codes, Me = Ie.ERR_MISSING_ARGS, Be = Ie.ERR_STREAM_DESTROYED;
  function Pe(vi) {
    if (vi) throw vi;
  }
  function Te(vi) {
    return vi.setHeader && typeof vi.abort == "function";
  }
  function je(vi, mi, _i, Ei) {
    Ei = t(Ei);
    var Pi = !1;
    vi.on("close", function() {
      Pi = !0;
    }), Ae === void 0 && (Ae = requireEndOfStream()), Ae(vi, {
      readable: mi,
      writable: _i
    }, function(Ci) {
      if (Ci) return Ei(Ci);
      Pi = !0, Ei();
    });
    var Ii = !1;
    return function(Ci) {
      if (!Pi && !Ii) {
        if (Ii = !0, Te(vi)) return vi.abort();
        if (typeof vi.destroy == "function") return vi.destroy();
        Ei(Ci || new Be("pipe"));
      }
    };
  }
  function Ve(vi) {
    vi();
  }
  function fi(vi, mi) {
    return vi.pipe(mi);
  }
  function Ue(vi) {
    return !vi.length || typeof vi[vi.length - 1] != "function" ? Pe : vi.pop();
  }
  function bi() {
    for (var vi = arguments.length, mi = new Array(vi), _i = 0; _i < vi; _i++)
      mi[_i] = arguments[_i];
    var Ei = Ue(mi);
    if (Array.isArray(mi[0]) && (mi = mi[0]), mi.length < 2)
      throw new Me("streams");
    var Pi, Ii = mi.map(function(Ci, Wi) {
      var zi = Wi < mi.length - 1, Xi = Wi > 0;
      return je(Ci, zi, Xi, function(Qi) {
        Pi || (Pi = Qi), Qi && Ii.forEach(Ve), !zi && (Ii.forEach(Ve), Ei(Pi));
      });
    });
    return mi.reduce(fi);
  }
  return pipeline_1 = bi, pipeline_1;
}
var streamBrowserify, hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1, streamBrowserify = Ie;
  var Ae = eventsExports.EventEmitter, t = inherits_browserExports;
  t(Ie, Ae), Ie.Readable = require_stream_readable$1(), Ie.Writable = require_stream_writable$1(), Ie.Duplex = require_stream_duplex$1(), Ie.Transform = require_stream_transform$1(), Ie.PassThrough = require_stream_passthrough$1(), Ie.finished = requireEndOfStream(), Ie.pipeline = requirePipeline(), Ie.Stream = Ie;
  function Ie() {
    Ae.call(this);
  }
  return Ie.prototype.pipe = function(Me, Be) {
    var Pe = this;
    function Te(mi) {
      Me.writable && Me.write(mi) === !1 && Pe.pause && Pe.pause();
    }
    Pe.on("data", Te);
    function je() {
      Pe.readable && Pe.resume && Pe.resume();
    }
    Me.on("drain", je), !Me._isStdio && (!Be || Be.end !== !1) && (Pe.on("end", fi), Pe.on("close", Ue));
    var Ve = !1;
    function fi() {
      Ve || (Ve = !0, Me.end());
    }
    function Ue() {
      Ve || (Ve = !0, typeof Me.destroy == "function" && Me.destroy());
    }
    function bi(mi) {
      if (vi(), Ae.listenerCount(this, "error") === 0)
        throw mi;
    }
    Pe.on("error", bi), Me.on("error", bi);
    function vi() {
      Pe.removeListener("data", Te), Me.removeListener("drain", je), Pe.removeListener("end", fi), Pe.removeListener("close", Ue), Pe.removeListener("error", bi), Me.removeListener("error", bi), Pe.removeListener("end", vi), Pe.removeListener("close", vi), Me.removeListener("close", vi);
    }
    return Pe.on("end", vi), Pe.on("close", vi), Me.on("close", vi), Me.emit("pipe", Pe), Me;
  }, streamBrowserify;
}
var hashBase, hasRequiredHashBase;
function requireHashBase() {
  if (hasRequiredHashBase) return hashBase;
  hasRequiredHashBase = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requireStreamBrowserify().Transform, Ie = inherits_browserExports;
  function Me(Pe, Te) {
    if (!Ae.isBuffer(Pe) && typeof Pe != "string")
      throw new TypeError(Te + " must be a string or a buffer");
  }
  function Be(Pe) {
    t.call(this), this._block = Ae.allocUnsafe(Pe), this._blockSize = Pe, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return Ie(Be, t), Be.prototype._transform = function(Pe, Te, je) {
    var Ve = null;
    try {
      this.update(Pe, Te);
    } catch (fi) {
      Ve = fi;
    }
    je(Ve);
  }, Be.prototype._flush = function(Pe) {
    var Te = null;
    try {
      this.push(this.digest());
    } catch (je) {
      Te = je;
    }
    Pe(Te);
  }, Be.prototype.update = function(Pe, Te) {
    if (Me(Pe, "Data"), this._finalized) throw new Error("Digest already called");
    Ae.isBuffer(Pe) || (Pe = Ae.from(Pe, Te));
    for (var je = this._block, Ve = 0; this._blockOffset + Pe.length - Ve >= this._blockSize; ) {
      for (var fi = this._blockOffset; fi < this._blockSize; ) je[fi++] = Pe[Ve++];
      this._update(), this._blockOffset = 0;
    }
    for (; Ve < Pe.length; ) je[this._blockOffset++] = Pe[Ve++];
    for (var Ue = 0, bi = Pe.length * 8; bi > 0; ++Ue)
      this._length[Ue] += bi, bi = this._length[Ue] / 4294967296 | 0, bi > 0 && (this._length[Ue] -= 4294967296 * bi);
    return this;
  }, Be.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, Be.prototype.digest = function(Pe) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = !0;
    var Te = this._digest();
    Pe !== void 0 && (Te = Te.toString(Pe)), this._block.fill(0), this._blockOffset = 0;
    for (var je = 0; je < 4; ++je) this._length[je] = 0;
    return Te;
  }, Be.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase = Be, hashBase;
}
var md5_js, hasRequiredMd5_js;
function requireMd5_js() {
  if (hasRequiredMd5_js) return md5_js;
  hasRequiredMd5_js = 1;
  var Ae = inherits_browserExports, t = requireHashBase(), Ie = requireSafeBuffer$1().Buffer, Me = new Array(16);
  function Be() {
    t.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  Ae(Be, t), Be.prototype._update = function() {
    for (var Ue = Me, bi = 0; bi < 16; ++bi) Ue[bi] = this._block.readInt32LE(bi * 4);
    var vi = this._a, mi = this._b, _i = this._c, Ei = this._d;
    vi = Te(vi, mi, _i, Ei, Ue[0], 3614090360, 7), Ei = Te(Ei, vi, mi, _i, Ue[1], 3905402710, 12), _i = Te(_i, Ei, vi, mi, Ue[2], 606105819, 17), mi = Te(mi, _i, Ei, vi, Ue[3], 3250441966, 22), vi = Te(vi, mi, _i, Ei, Ue[4], 4118548399, 7), Ei = Te(Ei, vi, mi, _i, Ue[5], 1200080426, 12), _i = Te(_i, Ei, vi, mi, Ue[6], 2821735955, 17), mi = Te(mi, _i, Ei, vi, Ue[7], 4249261313, 22), vi = Te(vi, mi, _i, Ei, Ue[8], 1770035416, 7), Ei = Te(Ei, vi, mi, _i, Ue[9], 2336552879, 12), _i = Te(_i, Ei, vi, mi, Ue[10], 4294925233, 17), mi = Te(mi, _i, Ei, vi, Ue[11], 2304563134, 22), vi = Te(vi, mi, _i, Ei, Ue[12], 1804603682, 7), Ei = Te(Ei, vi, mi, _i, Ue[13], 4254626195, 12), _i = Te(_i, Ei, vi, mi, Ue[14], 2792965006, 17), mi = Te(mi, _i, Ei, vi, Ue[15], 1236535329, 22), vi = je(vi, mi, _i, Ei, Ue[1], 4129170786, 5), Ei = je(Ei, vi, mi, _i, Ue[6], 3225465664, 9), _i = je(_i, Ei, vi, mi, Ue[11], 643717713, 14), mi = je(mi, _i, Ei, vi, Ue[0], 3921069994, 20), vi = je(vi, mi, _i, Ei, Ue[5], 3593408605, 5), Ei = je(Ei, vi, mi, _i, Ue[10], 38016083, 9), _i = je(_i, Ei, vi, mi, Ue[15], 3634488961, 14), mi = je(mi, _i, Ei, vi, Ue[4], 3889429448, 20), vi = je(vi, mi, _i, Ei, Ue[9], 568446438, 5), Ei = je(Ei, vi, mi, _i, Ue[14], 3275163606, 9), _i = je(_i, Ei, vi, mi, Ue[3], 4107603335, 14), mi = je(mi, _i, Ei, vi, Ue[8], 1163531501, 20), vi = je(vi, mi, _i, Ei, Ue[13], 2850285829, 5), Ei = je(Ei, vi, mi, _i, Ue[2], 4243563512, 9), _i = je(_i, Ei, vi, mi, Ue[7], 1735328473, 14), mi = je(mi, _i, Ei, vi, Ue[12], 2368359562, 20), vi = Ve(vi, mi, _i, Ei, Ue[5], 4294588738, 4), Ei = Ve(Ei, vi, mi, _i, Ue[8], 2272392833, 11), _i = Ve(_i, Ei, vi, mi, Ue[11], 1839030562, 16), mi = Ve(mi, _i, Ei, vi, Ue[14], 4259657740, 23), vi = Ve(vi, mi, _i, Ei, Ue[1], 2763975236, 4), Ei = Ve(Ei, vi, mi, _i, Ue[4], 1272893353, 11), _i = Ve(_i, Ei, vi, mi, Ue[7], 4139469664, 16), mi = Ve(mi, _i, Ei, vi, Ue[10], 3200236656, 23), vi = Ve(vi, mi, _i, Ei, Ue[13], 681279174, 4), Ei = Ve(Ei, vi, mi, _i, Ue[0], 3936430074, 11), _i = Ve(_i, Ei, vi, mi, Ue[3], 3572445317, 16), mi = Ve(mi, _i, Ei, vi, Ue[6], 76029189, 23), vi = Ve(vi, mi, _i, Ei, Ue[9], 3654602809, 4), Ei = Ve(Ei, vi, mi, _i, Ue[12], 3873151461, 11), _i = Ve(_i, Ei, vi, mi, Ue[15], 530742520, 16), mi = Ve(mi, _i, Ei, vi, Ue[2], 3299628645, 23), vi = fi(vi, mi, _i, Ei, Ue[0], 4096336452, 6), Ei = fi(Ei, vi, mi, _i, Ue[7], 1126891415, 10), _i = fi(_i, Ei, vi, mi, Ue[14], 2878612391, 15), mi = fi(mi, _i, Ei, vi, Ue[5], 4237533241, 21), vi = fi(vi, mi, _i, Ei, Ue[12], 1700485571, 6), Ei = fi(Ei, vi, mi, _i, Ue[3], 2399980690, 10), _i = fi(_i, Ei, vi, mi, Ue[10], 4293915773, 15), mi = fi(mi, _i, Ei, vi, Ue[1], 2240044497, 21), vi = fi(vi, mi, _i, Ei, Ue[8], 1873313359, 6), Ei = fi(Ei, vi, mi, _i, Ue[15], 4264355552, 10), _i = fi(_i, Ei, vi, mi, Ue[6], 2734768916, 15), mi = fi(mi, _i, Ei, vi, Ue[13], 1309151649, 21), vi = fi(vi, mi, _i, Ei, Ue[4], 4149444226, 6), Ei = fi(Ei, vi, mi, _i, Ue[11], 3174756917, 10), _i = fi(_i, Ei, vi, mi, Ue[2], 718787259, 15), mi = fi(mi, _i, Ei, vi, Ue[9], 3951481745, 21), this._a = this._a + vi | 0, this._b = this._b + mi | 0, this._c = this._c + _i | 0, this._d = this._d + Ei | 0;
  }, Be.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var Ue = Ie.allocUnsafe(16);
    return Ue.writeInt32LE(this._a, 0), Ue.writeInt32LE(this._b, 4), Ue.writeInt32LE(this._c, 8), Ue.writeInt32LE(this._d, 12), Ue;
  };
  function Pe(Ue, bi) {
    return Ue << bi | Ue >>> 32 - bi;
  }
  function Te(Ue, bi, vi, mi, _i, Ei, Pi) {
    return Pe(Ue + (bi & vi | ~bi & mi) + _i + Ei | 0, Pi) + bi | 0;
  }
  function je(Ue, bi, vi, mi, _i, Ei, Pi) {
    return Pe(Ue + (bi & mi | vi & ~mi) + _i + Ei | 0, Pi) + bi | 0;
  }
  function Ve(Ue, bi, vi, mi, _i, Ei, Pi) {
    return Pe(Ue + (bi ^ vi ^ mi) + _i + Ei | 0, Pi) + bi | 0;
  }
  function fi(Ue, bi, vi, mi, _i, Ei, Pi) {
    return Pe(Ue + (vi ^ (bi | ~mi)) + _i + Ei | 0, Pi) + bi | 0;
  }
  return md5_js = Be, md5_js;
}
var ripemd160, hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160;
  hasRequiredRipemd160 = 1;
  var Ae = require$$1$2.Buffer, t = inherits_browserExports, Ie = requireHashBase(), Me = new Array(16), Be = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], Pe = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], Te = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], je = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], Ve = [0, 1518500249, 1859775393, 2400959708, 2840853838], fi = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function Ue() {
    Ie.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  t(Ue, Ie), Ue.prototype._update = function() {
    for (var Ii = Me, Ci = 0; Ci < 16; ++Ci) Ii[Ci] = this._block.readInt32LE(Ci * 4);
    for (var Wi = this._a | 0, zi = this._b | 0, Xi = this._c | 0, Qi = this._d | 0, Oi = this._e | 0, Yi = this._a | 0, ns = this._b | 0, ls = this._c | 0, vn = this._d | 0, Mi = this._e | 0, Ai = 0; Ai < 80; Ai += 1) {
      var wi, $i;
      Ai < 16 ? (wi = vi(Wi, zi, Xi, Qi, Oi, Ii[Be[Ai]], Ve[0], Te[Ai]), $i = Pi(Yi, ns, ls, vn, Mi, Ii[Pe[Ai]], fi[0], je[Ai])) : Ai < 32 ? (wi = mi(Wi, zi, Xi, Qi, Oi, Ii[Be[Ai]], Ve[1], Te[Ai]), $i = Ei(Yi, ns, ls, vn, Mi, Ii[Pe[Ai]], fi[1], je[Ai])) : Ai < 48 ? (wi = _i(Wi, zi, Xi, Qi, Oi, Ii[Be[Ai]], Ve[2], Te[Ai]), $i = _i(Yi, ns, ls, vn, Mi, Ii[Pe[Ai]], fi[2], je[Ai])) : Ai < 64 ? (wi = Ei(Wi, zi, Xi, Qi, Oi, Ii[Be[Ai]], Ve[3], Te[Ai]), $i = mi(Yi, ns, ls, vn, Mi, Ii[Pe[Ai]], fi[3], je[Ai])) : (wi = Pi(Wi, zi, Xi, Qi, Oi, Ii[Be[Ai]], Ve[4], Te[Ai]), $i = vi(Yi, ns, ls, vn, Mi, Ii[Pe[Ai]], fi[4], je[Ai])), Wi = Oi, Oi = Qi, Qi = bi(Xi, 10), Xi = zi, zi = wi, Yi = Mi, Mi = vn, vn = bi(ls, 10), ls = ns, ns = $i;
    }
    var Li = this._b + Xi + vn | 0;
    this._b = this._c + Qi + Mi | 0, this._c = this._d + Oi + Yi | 0, this._d = this._e + Wi + ns | 0, this._e = this._a + zi + ls | 0, this._a = Li;
  }, Ue.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var Ii = Ae.alloc ? Ae.alloc(20) : new Ae(20);
    return Ii.writeInt32LE(this._a, 0), Ii.writeInt32LE(this._b, 4), Ii.writeInt32LE(this._c, 8), Ii.writeInt32LE(this._d, 12), Ii.writeInt32LE(this._e, 16), Ii;
  };
  function bi(Ii, Ci) {
    return Ii << Ci | Ii >>> 32 - Ci;
  }
  function vi(Ii, Ci, Wi, zi, Xi, Qi, Oi, Yi) {
    return bi(Ii + (Ci ^ Wi ^ zi) + Qi + Oi | 0, Yi) + Xi | 0;
  }
  function mi(Ii, Ci, Wi, zi, Xi, Qi, Oi, Yi) {
    return bi(Ii + (Ci & Wi | ~Ci & zi) + Qi + Oi | 0, Yi) + Xi | 0;
  }
  function _i(Ii, Ci, Wi, zi, Xi, Qi, Oi, Yi) {
    return bi(Ii + ((Ci | ~Wi) ^ zi) + Qi + Oi | 0, Yi) + Xi | 0;
  }
  function Ei(Ii, Ci, Wi, zi, Xi, Qi, Oi, Yi) {
    return bi(Ii + (Ci & zi | Wi & ~zi) + Qi + Oi | 0, Yi) + Xi | 0;
  }
  function Pi(Ii, Ci, Wi, zi, Xi, Qi, Oi, Yi) {
    return bi(Ii + (Ci ^ (Wi | ~zi)) + Qi + Oi | 0, Yi) + Xi | 0;
  }
  return ripemd160 = Ue, ripemd160;
}
var sha_js = { exports: {} }, hash$5, hasRequiredHash;
function requireHash() {
  if (hasRequiredHash) return hash$5;
  hasRequiredHash = 1;
  var Ae = requireSafeBuffer$1().Buffer;
  function t(Ie, Me) {
    this._block = Ae.alloc(Ie), this._finalSize = Me, this._blockSize = Ie, this._len = 0;
  }
  return t.prototype.update = function(Ie, Me) {
    typeof Ie == "string" && (Me = Me || "utf8", Ie = Ae.from(Ie, Me));
    for (var Be = this._block, Pe = this._blockSize, Te = Ie.length, je = this._len, Ve = 0; Ve < Te; ) {
      for (var fi = je % Pe, Ue = Math.min(Te - Ve, Pe - fi), bi = 0; bi < Ue; bi++)
        Be[fi + bi] = Ie[Ve + bi];
      je += Ue, Ve += Ue, je % Pe === 0 && this._update(Be);
    }
    return this._len += Te, this;
  }, t.prototype.digest = function(Ie) {
    var Me = this._len % this._blockSize;
    this._block[Me] = 128, this._block.fill(0, Me + 1), Me >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var Be = this._len * 8;
    if (Be <= 4294967295)
      this._block.writeUInt32BE(Be, this._blockSize - 4);
    else {
      var Pe = (Be & 4294967295) >>> 0, Te = (Be - Pe) / 4294967296;
      this._block.writeUInt32BE(Te, this._blockSize - 8), this._block.writeUInt32BE(Pe, this._blockSize - 4);
    }
    this._update(this._block);
    var je = this._hash();
    return Ie ? je.toString(Ie) : je;
  }, t.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, hash$5 = t, hash$5;
}
var sha$1, hasRequiredSha;
function requireSha() {
  if (hasRequiredSha) return sha$1;
  hasRequiredSha = 1;
  var Ae = inherits_browserExports, t = requireHash(), Ie = requireSafeBuffer$1().Buffer, Me = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], Be = new Array(80);
  function Pe() {
    this.init(), this._w = Be, t.call(this, 64, 56);
  }
  Ae(Pe, t), Pe.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function Te(fi) {
    return fi << 5 | fi >>> 27;
  }
  function je(fi) {
    return fi << 30 | fi >>> 2;
  }
  function Ve(fi, Ue, bi, vi) {
    return fi === 0 ? Ue & bi | ~Ue & vi : fi === 2 ? Ue & bi | Ue & vi | bi & vi : Ue ^ bi ^ vi;
  }
  return Pe.prototype._update = function(fi) {
    for (var Ue = this._w, bi = this._a | 0, vi = this._b | 0, mi = this._c | 0, _i = this._d | 0, Ei = this._e | 0, Pi = 0; Pi < 16; ++Pi) Ue[Pi] = fi.readInt32BE(Pi * 4);
    for (; Pi < 80; ++Pi) Ue[Pi] = Ue[Pi - 3] ^ Ue[Pi - 8] ^ Ue[Pi - 14] ^ Ue[Pi - 16];
    for (var Ii = 0; Ii < 80; ++Ii) {
      var Ci = ~~(Ii / 20), Wi = Te(bi) + Ve(Ci, vi, mi, _i) + Ei + Ue[Ii] + Me[Ci] | 0;
      Ei = _i, _i = mi, mi = je(vi), vi = bi, bi = Wi;
    }
    this._a = bi + this._a | 0, this._b = vi + this._b | 0, this._c = mi + this._c | 0, this._d = _i + this._d | 0, this._e = Ei + this._e | 0;
  }, Pe.prototype._hash = function() {
    var fi = Ie.allocUnsafe(20);
    return fi.writeInt32BE(this._a | 0, 0), fi.writeInt32BE(this._b | 0, 4), fi.writeInt32BE(this._c | 0, 8), fi.writeInt32BE(this._d | 0, 12), fi.writeInt32BE(this._e | 0, 16), fi;
  }, sha$1 = Pe, sha$1;
}
var sha1, hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1;
  hasRequiredSha1 = 1;
  var Ae = inherits_browserExports, t = requireHash(), Ie = requireSafeBuffer$1().Buffer, Me = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], Be = new Array(80);
  function Pe() {
    this.init(), this._w = Be, t.call(this, 64, 56);
  }
  Ae(Pe, t), Pe.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function Te(Ue) {
    return Ue << 1 | Ue >>> 31;
  }
  function je(Ue) {
    return Ue << 5 | Ue >>> 27;
  }
  function Ve(Ue) {
    return Ue << 30 | Ue >>> 2;
  }
  function fi(Ue, bi, vi, mi) {
    return Ue === 0 ? bi & vi | ~bi & mi : Ue === 2 ? bi & vi | bi & mi | vi & mi : bi ^ vi ^ mi;
  }
  return Pe.prototype._update = function(Ue) {
    for (var bi = this._w, vi = this._a | 0, mi = this._b | 0, _i = this._c | 0, Ei = this._d | 0, Pi = this._e | 0, Ii = 0; Ii < 16; ++Ii) bi[Ii] = Ue.readInt32BE(Ii * 4);
    for (; Ii < 80; ++Ii) bi[Ii] = Te(bi[Ii - 3] ^ bi[Ii - 8] ^ bi[Ii - 14] ^ bi[Ii - 16]);
    for (var Ci = 0; Ci < 80; ++Ci) {
      var Wi = ~~(Ci / 20), zi = je(vi) + fi(Wi, mi, _i, Ei) + Pi + bi[Ci] + Me[Wi] | 0;
      Pi = Ei, Ei = _i, _i = Ve(mi), mi = vi, vi = zi;
    }
    this._a = vi + this._a | 0, this._b = mi + this._b | 0, this._c = _i + this._c | 0, this._d = Ei + this._d | 0, this._e = Pi + this._e | 0;
  }, Pe.prototype._hash = function() {
    var Ue = Ie.allocUnsafe(20);
    return Ue.writeInt32BE(this._a | 0, 0), Ue.writeInt32BE(this._b | 0, 4), Ue.writeInt32BE(this._c | 0, 8), Ue.writeInt32BE(this._d | 0, 12), Ue.writeInt32BE(this._e | 0, 16), Ue;
  }, sha1 = Pe, sha1;
}
var sha256$2, hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$2;
  hasRequiredSha256 = 1;
  var Ae = inherits_browserExports, t = requireHash(), Ie = requireSafeBuffer$1().Buffer, Me = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], Be = new Array(64);
  function Pe() {
    this.init(), this._w = Be, t.call(this, 64, 56);
  }
  Ae(Pe, t), Pe.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function Te(vi, mi, _i) {
    return _i ^ vi & (mi ^ _i);
  }
  function je(vi, mi, _i) {
    return vi & mi | _i & (vi | mi);
  }
  function Ve(vi) {
    return (vi >>> 2 | vi << 30) ^ (vi >>> 13 | vi << 19) ^ (vi >>> 22 | vi << 10);
  }
  function fi(vi) {
    return (vi >>> 6 | vi << 26) ^ (vi >>> 11 | vi << 21) ^ (vi >>> 25 | vi << 7);
  }
  function Ue(vi) {
    return (vi >>> 7 | vi << 25) ^ (vi >>> 18 | vi << 14) ^ vi >>> 3;
  }
  function bi(vi) {
    return (vi >>> 17 | vi << 15) ^ (vi >>> 19 | vi << 13) ^ vi >>> 10;
  }
  return Pe.prototype._update = function(vi) {
    for (var mi = this._w, _i = this._a | 0, Ei = this._b | 0, Pi = this._c | 0, Ii = this._d | 0, Ci = this._e | 0, Wi = this._f | 0, zi = this._g | 0, Xi = this._h | 0, Qi = 0; Qi < 16; ++Qi) mi[Qi] = vi.readInt32BE(Qi * 4);
    for (; Qi < 64; ++Qi) mi[Qi] = bi(mi[Qi - 2]) + mi[Qi - 7] + Ue(mi[Qi - 15]) + mi[Qi - 16] | 0;
    for (var Oi = 0; Oi < 64; ++Oi) {
      var Yi = Xi + fi(Ci) + Te(Ci, Wi, zi) + Me[Oi] + mi[Oi] | 0, ns = Ve(_i) + je(_i, Ei, Pi) | 0;
      Xi = zi, zi = Wi, Wi = Ci, Ci = Ii + Yi | 0, Ii = Pi, Pi = Ei, Ei = _i, _i = Yi + ns | 0;
    }
    this._a = _i + this._a | 0, this._b = Ei + this._b | 0, this._c = Pi + this._c | 0, this._d = Ii + this._d | 0, this._e = Ci + this._e | 0, this._f = Wi + this._f | 0, this._g = zi + this._g | 0, this._h = Xi + this._h | 0;
  }, Pe.prototype._hash = function() {
    var vi = Ie.allocUnsafe(32);
    return vi.writeInt32BE(this._a, 0), vi.writeInt32BE(this._b, 4), vi.writeInt32BE(this._c, 8), vi.writeInt32BE(this._d, 12), vi.writeInt32BE(this._e, 16), vi.writeInt32BE(this._f, 20), vi.writeInt32BE(this._g, 24), vi.writeInt32BE(this._h, 28), vi;
  }, sha256$2 = Pe, sha256$2;
}
var sha224$1, hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha224$1;
  hasRequiredSha224 = 1;
  var Ae = inherits_browserExports, t = requireSha256(), Ie = requireHash(), Me = requireSafeBuffer$1().Buffer, Be = new Array(64);
  function Pe() {
    this.init(), this._w = Be, Ie.call(this, 64, 56);
  }
  return Ae(Pe, t), Pe.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, Pe.prototype._hash = function() {
    var Te = Me.allocUnsafe(28);
    return Te.writeInt32BE(this._a, 0), Te.writeInt32BE(this._b, 4), Te.writeInt32BE(this._c, 8), Te.writeInt32BE(this._d, 12), Te.writeInt32BE(this._e, 16), Te.writeInt32BE(this._f, 20), Te.writeInt32BE(this._g, 24), Te;
  }, sha224$1 = Pe, sha224$1;
}
var sha512$2, hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$2;
  hasRequiredSha512 = 1;
  var Ae = inherits_browserExports, t = requireHash(), Ie = requireSafeBuffer$1().Buffer, Me = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], Be = new Array(160);
  function Pe() {
    this.init(), this._w = Be, t.call(this, 128, 112);
  }
  Ae(Pe, t), Pe.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function Te(Ei, Pi, Ii) {
    return Ii ^ Ei & (Pi ^ Ii);
  }
  function je(Ei, Pi, Ii) {
    return Ei & Pi | Ii & (Ei | Pi);
  }
  function Ve(Ei, Pi) {
    return (Ei >>> 28 | Pi << 4) ^ (Pi >>> 2 | Ei << 30) ^ (Pi >>> 7 | Ei << 25);
  }
  function fi(Ei, Pi) {
    return (Ei >>> 14 | Pi << 18) ^ (Ei >>> 18 | Pi << 14) ^ (Pi >>> 9 | Ei << 23);
  }
  function Ue(Ei, Pi) {
    return (Ei >>> 1 | Pi << 31) ^ (Ei >>> 8 | Pi << 24) ^ Ei >>> 7;
  }
  function bi(Ei, Pi) {
    return (Ei >>> 1 | Pi << 31) ^ (Ei >>> 8 | Pi << 24) ^ (Ei >>> 7 | Pi << 25);
  }
  function vi(Ei, Pi) {
    return (Ei >>> 19 | Pi << 13) ^ (Pi >>> 29 | Ei << 3) ^ Ei >>> 6;
  }
  function mi(Ei, Pi) {
    return (Ei >>> 19 | Pi << 13) ^ (Pi >>> 29 | Ei << 3) ^ (Ei >>> 6 | Pi << 26);
  }
  function _i(Ei, Pi) {
    return Ei >>> 0 < Pi >>> 0 ? 1 : 0;
  }
  return Pe.prototype._update = function(Ei) {
    for (var Pi = this._w, Ii = this._ah | 0, Ci = this._bh | 0, Wi = this._ch | 0, zi = this._dh | 0, Xi = this._eh | 0, Qi = this._fh | 0, Oi = this._gh | 0, Yi = this._hh | 0, ns = this._al | 0, ls = this._bl | 0, vn = this._cl | 0, Mi = this._dl | 0, Ai = this._el | 0, wi = this._fl | 0, $i = this._gl | 0, Li = this._hl | 0, qi = 0; qi < 32; qi += 2)
      Pi[qi] = Ei.readInt32BE(qi * 4), Pi[qi + 1] = Ei.readInt32BE(qi * 4 + 4);
    for (; qi < 160; qi += 2) {
      var Ni = Pi[qi - 30], Ti = Pi[qi - 15 * 2 + 1], xi = Ue(Ni, Ti), Fi = bi(Ti, Ni);
      Ni = Pi[qi - 2 * 2], Ti = Pi[qi - 2 * 2 + 1];
      var Si = vi(Ni, Ti), Vi = mi(Ti, Ni), ts = Pi[qi - 7 * 2], Hi = Pi[qi - 7 * 2 + 1], fn = Pi[qi - 16 * 2], Bi = Pi[qi - 16 * 2 + 1], ki = Fi + Hi | 0, Ji = xi + ts + _i(ki, Fi) | 0;
      ki = ki + Vi | 0, Ji = Ji + Si + _i(ki, Vi) | 0, ki = ki + Bi | 0, Ji = Ji + fn + _i(ki, Bi) | 0, Pi[qi] = Ji, Pi[qi + 1] = ki;
    }
    for (var Ri = 0; Ri < 160; Ri += 2) {
      Ji = Pi[Ri], ki = Pi[Ri + 1];
      var ji = je(Ii, Ci, Wi), Gi = je(ns, ls, vn), is = Ve(Ii, ns), os = Ve(ns, Ii), ds = fi(Xi, Ai), ps = fi(Ai, Xi), ea = Me[Ri], ia = Me[Ri + 1], hs = Te(Xi, Qi, Oi), fa = Te(Ai, wi, $i), gs = Li + ps | 0, sa = Yi + ds + _i(gs, Li) | 0;
      gs = gs + fa | 0, sa = sa + hs + _i(gs, fa) | 0, gs = gs + ia | 0, sa = sa + ea + _i(gs, ia) | 0, gs = gs + ki | 0, sa = sa + Ji + _i(gs, ki) | 0;
      var aa = os + Gi | 0, Ds = is + ji + _i(aa, os) | 0;
      Yi = Oi, Li = $i, Oi = Qi, $i = wi, Qi = Xi, wi = Ai, Ai = Mi + gs | 0, Xi = zi + sa + _i(Ai, Mi) | 0, zi = Wi, Mi = vn, Wi = Ci, vn = ls, Ci = Ii, ls = ns, ns = gs + aa | 0, Ii = sa + Ds + _i(ns, gs) | 0;
    }
    this._al = this._al + ns | 0, this._bl = this._bl + ls | 0, this._cl = this._cl + vn | 0, this._dl = this._dl + Mi | 0, this._el = this._el + Ai | 0, this._fl = this._fl + wi | 0, this._gl = this._gl + $i | 0, this._hl = this._hl + Li | 0, this._ah = this._ah + Ii + _i(this._al, ns) | 0, this._bh = this._bh + Ci + _i(this._bl, ls) | 0, this._ch = this._ch + Wi + _i(this._cl, vn) | 0, this._dh = this._dh + zi + _i(this._dl, Mi) | 0, this._eh = this._eh + Xi + _i(this._el, Ai) | 0, this._fh = this._fh + Qi + _i(this._fl, wi) | 0, this._gh = this._gh + Oi + _i(this._gl, $i) | 0, this._hh = this._hh + Yi + _i(this._hl, Li) | 0;
  }, Pe.prototype._hash = function() {
    var Ei = Ie.allocUnsafe(64);
    function Pi(Ii, Ci, Wi) {
      Ei.writeInt32BE(Ii, Wi), Ei.writeInt32BE(Ci, Wi + 4);
    }
    return Pi(this._ah, this._al, 0), Pi(this._bh, this._bl, 8), Pi(this._ch, this._cl, 16), Pi(this._dh, this._dl, 24), Pi(this._eh, this._el, 32), Pi(this._fh, this._fl, 40), Pi(this._gh, this._gl, 48), Pi(this._hh, this._hl, 56), Ei;
  }, sha512$2 = Pe, sha512$2;
}
var sha384$1, hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha384$1;
  hasRequiredSha384 = 1;
  var Ae = inherits_browserExports, t = requireSha512(), Ie = requireHash(), Me = requireSafeBuffer$1().Buffer, Be = new Array(160);
  function Pe() {
    this.init(), this._w = Be, Ie.call(this, 128, 112);
  }
  return Ae(Pe, t), Pe.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, Pe.prototype._hash = function() {
    var Te = Me.allocUnsafe(48);
    function je(Ve, fi, Ue) {
      Te.writeInt32BE(Ve, Ue), Te.writeInt32BE(fi, Ue + 4);
    }
    return je(this._ah, this._al, 0), je(this._bh, this._bl, 8), je(this._ch, this._cl, 16), je(this._dh, this._dl, 24), je(this._eh, this._el, 32), je(this._fh, this._fl, 40), Te;
  }, sha384$1 = Pe, sha384$1;
}
var hasRequiredSha_js;
function requireSha_js() {
  if (hasRequiredSha_js) return sha_js.exports;
  hasRequiredSha_js = 1;
  var Ae = sha_js.exports = function(Ie) {
    Ie = Ie.toLowerCase();
    var Me = Ae[Ie];
    if (!Me) throw new Error(Ie + " is not supported (we accept pull requests)");
    return new Me();
  };
  return Ae.sha = requireSha(), Ae.sha1 = requireSha1(), Ae.sha224 = requireSha224(), Ae.sha256 = requireSha256(), Ae.sha384 = requireSha384(), Ae.sha512 = requireSha512(), sha_js.exports;
}
var cipherBase, hasRequiredCipherBase;
function requireCipherBase() {
  if (hasRequiredCipherBase) return cipherBase;
  hasRequiredCipherBase = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requireStreamBrowserify().Transform, Ie = requireString_decoder().StringDecoder, Me = inherits_browserExports;
  function Be(Pe) {
    t.call(this), this.hashMode = typeof Pe == "string", this.hashMode ? this[Pe] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  return Me(Be, t), Be.prototype.update = function(Pe, Te, je) {
    typeof Pe == "string" && (Pe = Ae.from(Pe, Te));
    var Ve = this._update(Pe);
    return this.hashMode ? this : (je && (Ve = this._toString(Ve, je)), Ve);
  }, Be.prototype.setAutoPadding = function() {
  }, Be.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, Be.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, Be.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, Be.prototype._transform = function(Pe, Te, je) {
    var Ve;
    try {
      this.hashMode ? this._update(Pe) : this.push(this._update(Pe));
    } catch (fi) {
      Ve = fi;
    } finally {
      je(Ve);
    }
  }, Be.prototype._flush = function(Pe) {
    var Te;
    try {
      this.push(this.__final());
    } catch (je) {
      Te = je;
    }
    Pe(Te);
  }, Be.prototype._finalOrDigest = function(Pe) {
    var Te = this.__final() || Ae.alloc(0);
    return Pe && (Te = this._toString(Te, Pe, !0)), Te;
  }, Be.prototype._toString = function(Pe, Te, je) {
    if (this._decoder || (this._decoder = new Ie(Te), this._encoding = Te), this._encoding !== Te) throw new Error("can't switch encodings");
    var Ve = this._decoder.write(Pe);
    return je && (Ve += this._decoder.end()), Ve;
  }, cipherBase = Be, cipherBase;
}
var browser$a, hasRequiredBrowser$9;
function requireBrowser$9() {
  if (hasRequiredBrowser$9) return browser$a;
  hasRequiredBrowser$9 = 1;
  var Ae = inherits_browserExports, t = requireMd5_js(), Ie = requireRipemd160(), Me = requireSha_js(), Be = requireCipherBase();
  function Pe(Te) {
    Be.call(this, "digest"), this._hash = Te;
  }
  return Ae(Pe, Be), Pe.prototype._update = function(Te) {
    this._hash.update(Te);
  }, Pe.prototype._final = function() {
    return this._hash.digest();
  }, browser$a = function(je) {
    return je = je.toLowerCase(), je === "md5" ? new t() : je === "rmd160" || je === "ripemd160" ? new Ie() : new Pe(Me(je));
  }, browser$a;
}
var legacy, hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  var Ae = inherits_browserExports, t = requireSafeBuffer$1().Buffer, Ie = requireCipherBase(), Me = t.alloc(128), Be = 64;
  function Pe(Te, je) {
    Ie.call(this, "digest"), typeof je == "string" && (je = t.from(je)), this._alg = Te, this._key = je, je.length > Be ? je = Te(je) : je.length < Be && (je = t.concat([je, Me], Be));
    for (var Ve = this._ipad = t.allocUnsafe(Be), fi = this._opad = t.allocUnsafe(Be), Ue = 0; Ue < Be; Ue++)
      Ve[Ue] = je[Ue] ^ 54, fi[Ue] = je[Ue] ^ 92;
    this._hash = [Ve];
  }
  return Ae(Pe, Ie), Pe.prototype._update = function(Te) {
    this._hash.push(Te);
  }, Pe.prototype._final = function() {
    var Te = this._alg(t.concat(this._hash));
    return this._alg(t.concat([this._opad, Te]));
  }, legacy = Pe, legacy;
}
var md5, hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  var Ae = requireMd5_js();
  return md5 = function(t) {
    return new Ae().update(t).digest();
  }, md5;
}
var browser$9, hasRequiredBrowser$8;
function requireBrowser$8() {
  if (hasRequiredBrowser$8) return browser$9;
  hasRequiredBrowser$8 = 1;
  var Ae = inherits_browserExports, t = requireLegacy(), Ie = requireCipherBase(), Me = requireSafeBuffer$1().Buffer, Be = requireMd5(), Pe = requireRipemd160(), Te = requireSha_js(), je = Me.alloc(128);
  function Ve(fi, Ue) {
    Ie.call(this, "digest"), typeof Ue == "string" && (Ue = Me.from(Ue));
    var bi = fi === "sha512" || fi === "sha384" ? 128 : 64;
    if (this._alg = fi, this._key = Ue, Ue.length > bi) {
      var vi = fi === "rmd160" ? new Pe() : Te(fi);
      Ue = vi.update(Ue).digest();
    } else Ue.length < bi && (Ue = Me.concat([Ue, je], bi));
    for (var mi = this._ipad = Me.allocUnsafe(bi), _i = this._opad = Me.allocUnsafe(bi), Ei = 0; Ei < bi; Ei++)
      mi[Ei] = Ue[Ei] ^ 54, _i[Ei] = Ue[Ei] ^ 92;
    this._hash = fi === "rmd160" ? new Pe() : Te(fi), this._hash.update(mi);
  }
  return Ae(Ve, Ie), Ve.prototype._update = function(fi) {
    this._hash.update(fi);
  }, Ve.prototype._final = function() {
    var fi = this._hash.digest(), Ue = this._alg === "rmd160" ? new Pe() : Te(this._alg);
    return Ue.update(this._opad).update(fi).digest();
  }, browser$9 = function(Ue, bi) {
    return Ue = Ue.toLowerCase(), Ue === "rmd160" || Ue === "ripemd160" ? new Ve("rmd160", bi) : Ue === "md5" ? new t(Be, bi) : new Ve(Ue, bi);
  }, browser$9;
}
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$1 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512$1 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$1,
  sha224,
  sha384,
  sha512: sha512$1,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
  return hasRequiredAlgos || (hasRequiredAlgos = 1, algos = require$$6), algos;
}
var browser$8 = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
  if (hasRequiredPrecondition) return precondition;
  hasRequiredPrecondition = 1;
  var Ae = Math.pow(2, 30) - 1;
  return precondition = function(t, Ie) {
    if (typeof t != "number")
      throw new TypeError("Iterations not a number");
    if (t < 0)
      throw new TypeError("Bad iterations");
    if (typeof Ie != "number")
      throw new TypeError("Key length not a number");
    if (Ie < 0 || Ie > Ae || Ie !== Ie)
      throw new TypeError("Bad key length");
  }, precondition;
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
  if (hasRequiredDefaultEncoding) return defaultEncoding_1;
  hasRequiredDefaultEncoding = 1;
  var Ae;
  if (commonjsGlobal.process && commonjsGlobal.process.browser)
    Ae = "utf-8";
  else if (commonjsGlobal.process && commonjsGlobal.process.version) {
    var t = parseInt(process$1.version.split(".")[0].slice(1), 10);
    Ae = t >= 6 ? "utf-8" : "binary";
  } else
    Ae = "utf-8";
  return defaultEncoding_1 = Ae, defaultEncoding_1;
}
var toBuffer, hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer) return toBuffer;
  hasRequiredToBuffer = 1;
  var Ae = requireSafeBuffer$1().Buffer;
  return toBuffer = function(t, Ie, Me) {
    if (Ae.isBuffer(t))
      return t;
    if (typeof t == "string")
      return Ae.from(t, Ie);
    if (ArrayBuffer.isView(t))
      return Ae.from(t.buffer);
    throw new TypeError(Me + " must be a string, a Buffer, a typed array or a DataView");
  }, toBuffer;
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser) return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var Ae = requireMd5(), t = requireRipemd160(), Ie = requireSha_js(), Me = requireSafeBuffer$1().Buffer, Be = requirePrecondition(), Pe = requireDefaultEncoding(), Te = requireToBuffer(), je = Me.alloc(128), Ve = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function fi(vi, mi, _i) {
    var Ei = Ue(vi), Pi = vi === "sha512" || vi === "sha384" ? 128 : 64;
    mi.length > Pi ? mi = Ei(mi) : mi.length < Pi && (mi = Me.concat([mi, je], Pi));
    for (var Ii = Me.allocUnsafe(Pi + Ve[vi]), Ci = Me.allocUnsafe(Pi + Ve[vi]), Wi = 0; Wi < Pi; Wi++)
      Ii[Wi] = mi[Wi] ^ 54, Ci[Wi] = mi[Wi] ^ 92;
    var zi = Me.allocUnsafe(Pi + _i + 4);
    Ii.copy(zi, 0, 0, Pi), this.ipad1 = zi, this.ipad2 = Ii, this.opad = Ci, this.alg = vi, this.blocksize = Pi, this.hash = Ei, this.size = Ve[vi];
  }
  fi.prototype.run = function(vi, mi) {
    vi.copy(mi, this.blocksize);
    var _i = this.hash(mi);
    return _i.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function Ue(vi) {
    function mi(Ei) {
      return Ie(vi).update(Ei).digest();
    }
    function _i(Ei) {
      return new t().update(Ei).digest();
    }
    return vi === "rmd160" || vi === "ripemd160" ? _i : vi === "md5" ? Ae : mi;
  }
  function bi(vi, mi, _i, Ei, Pi) {
    Be(_i, Ei), vi = Te(vi, Pe, "Password"), mi = Te(mi, Pe, "Salt"), Pi = Pi || "sha1";
    var Ii = new fi(Pi, vi, mi.length), Ci = Me.allocUnsafe(Ei), Wi = Me.allocUnsafe(mi.length + 4);
    mi.copy(Wi, 0, 0, mi.length);
    for (var zi = 0, Xi = Ve[Pi], Qi = Math.ceil(Ei / Xi), Oi = 1; Oi <= Qi; Oi++) {
      Wi.writeUInt32BE(Oi, mi.length);
      for (var Yi = Ii.run(Wi, Ii.ipad1), ns = Yi, ls = 1; ls < _i; ls++) {
        ns = Ii.run(ns, Ii.ipad2);
        for (var vn = 0; vn < Xi; vn++) Yi[vn] ^= ns[vn];
      }
      Yi.copy(Ci, zi), zi += Xi;
    }
    return Ci;
  }
  return syncBrowser = bi, syncBrowser;
}
var async, hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requirePrecondition(), Ie = requireDefaultEncoding(), Me = requireSyncBrowser(), Be = requireToBuffer(), Pe, Te = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, je = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, Ve = [];
  function fi(_i) {
    if (commonjsGlobal.process && !commonjsGlobal.process.browser || !Te || !Te.importKey || !Te.deriveBits)
      return Promise.resolve(!1);
    if (Ve[_i] !== void 0)
      return Ve[_i];
    Pe = Pe || Ae.alloc(8);
    var Ei = vi(Pe, Pe, 10, 128, _i).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return Ve[_i] = Ei, Ei;
  }
  var Ue;
  function bi() {
    return Ue || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? Ue = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? Ue = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? Ue = commonjsGlobal.setImmediate : Ue = commonjsGlobal.setTimeout, Ue);
  }
  function vi(_i, Ei, Pi, Ii, Ci) {
    return Te.importKey(
      "raw",
      _i,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(Wi) {
      return Te.deriveBits({
        name: "PBKDF2",
        salt: Ei,
        iterations: Pi,
        hash: {
          name: Ci
        }
      }, Wi, Ii << 3);
    }).then(function(Wi) {
      return Ae.from(Wi);
    });
  }
  function mi(_i, Ei) {
    _i.then(function(Pi) {
      bi()(function() {
        Ei(null, Pi);
      });
    }, function(Pi) {
      bi()(function() {
        Ei(Pi);
      });
    });
  }
  return async = function(_i, Ei, Pi, Ii, Ci, Wi) {
    typeof Ci == "function" && (Wi = Ci, Ci = void 0), Ci = Ci || "sha1";
    var zi = je[Ci.toLowerCase()];
    if (!zi || typeof commonjsGlobal.Promise != "function") {
      bi()(function() {
        var Xi;
        try {
          Xi = Me(_i, Ei, Pi, Ii, Ci);
        } catch (Qi) {
          return Wi(Qi);
        }
        Wi(null, Xi);
      });
      return;
    }
    if (t(Pi, Ii), _i = Be(_i, Ie, "Password"), Ei = Be(Ei, Ie, "Salt"), typeof Wi != "function") throw new Error("No callback provided to pbkdf2");
    mi(fi(zi).then(function(Xi) {
      return Xi ? vi(_i, Ei, Pi, Ii, zi) : Me(_i, Ei, Pi, Ii, Ci);
    }), Wi);
  }, async;
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
  return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1, browser$8.pbkdf2 = requireAsync(), browser$8.pbkdf2Sync = requireSyncBrowser()), browser$8;
}
var browser$7 = {}, des$1 = {}, utils$m = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils$m;
  hasRequiredUtils = 1, utils$m.readUInt32BE = function(Be, Pe) {
    var Te = Be[0 + Pe] << 24 | Be[1 + Pe] << 16 | Be[2 + Pe] << 8 | Be[3 + Pe];
    return Te >>> 0;
  }, utils$m.writeUInt32BE = function(Be, Pe, Te) {
    Be[0 + Te] = Pe >>> 24, Be[1 + Te] = Pe >>> 16 & 255, Be[2 + Te] = Pe >>> 8 & 255, Be[3 + Te] = Pe & 255;
  }, utils$m.ip = function(Be, Pe, Te, je) {
    for (var Ve = 0, fi = 0, Ue = 6; Ue >= 0; Ue -= 2) {
      for (var bi = 0; bi <= 24; bi += 8)
        Ve <<= 1, Ve |= Pe >>> bi + Ue & 1;
      for (var bi = 0; bi <= 24; bi += 8)
        Ve <<= 1, Ve |= Be >>> bi + Ue & 1;
    }
    for (var Ue = 6; Ue >= 0; Ue -= 2) {
      for (var bi = 1; bi <= 25; bi += 8)
        fi <<= 1, fi |= Pe >>> bi + Ue & 1;
      for (var bi = 1; bi <= 25; bi += 8)
        fi <<= 1, fi |= Be >>> bi + Ue & 1;
    }
    Te[je + 0] = Ve >>> 0, Te[je + 1] = fi >>> 0;
  }, utils$m.rip = function(Be, Pe, Te, je) {
    for (var Ve = 0, fi = 0, Ue = 0; Ue < 4; Ue++)
      for (var bi = 24; bi >= 0; bi -= 8)
        Ve <<= 1, Ve |= Pe >>> bi + Ue & 1, Ve <<= 1, Ve |= Be >>> bi + Ue & 1;
    for (var Ue = 4; Ue < 8; Ue++)
      for (var bi = 24; bi >= 0; bi -= 8)
        fi <<= 1, fi |= Pe >>> bi + Ue & 1, fi <<= 1, fi |= Be >>> bi + Ue & 1;
    Te[je + 0] = Ve >>> 0, Te[je + 1] = fi >>> 0;
  }, utils$m.pc1 = function(Be, Pe, Te, je) {
    for (var Ve = 0, fi = 0, Ue = 7; Ue >= 5; Ue--) {
      for (var bi = 0; bi <= 24; bi += 8)
        Ve <<= 1, Ve |= Pe >> bi + Ue & 1;
      for (var bi = 0; bi <= 24; bi += 8)
        Ve <<= 1, Ve |= Be >> bi + Ue & 1;
    }
    for (var bi = 0; bi <= 24; bi += 8)
      Ve <<= 1, Ve |= Pe >> bi + Ue & 1;
    for (var Ue = 1; Ue <= 3; Ue++) {
      for (var bi = 0; bi <= 24; bi += 8)
        fi <<= 1, fi |= Pe >> bi + Ue & 1;
      for (var bi = 0; bi <= 24; bi += 8)
        fi <<= 1, fi |= Be >> bi + Ue & 1;
    }
    for (var bi = 0; bi <= 24; bi += 8)
      fi <<= 1, fi |= Be >> bi + Ue & 1;
    Te[je + 0] = Ve >>> 0, Te[je + 1] = fi >>> 0;
  }, utils$m.r28shl = function(Be, Pe) {
    return Be << Pe & 268435455 | Be >>> 28 - Pe;
  };
  var Ae = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$m.pc2 = function(Be, Pe, Te, je) {
    for (var Ve = 0, fi = 0, Ue = Ae.length >>> 1, bi = 0; bi < Ue; bi++)
      Ve <<= 1, Ve |= Be >>> Ae[bi] & 1;
    for (var bi = Ue; bi < Ae.length; bi++)
      fi <<= 1, fi |= Pe >>> Ae[bi] & 1;
    Te[je + 0] = Ve >>> 0, Te[je + 1] = fi >>> 0;
  }, utils$m.expand = function(Be, Pe, Te) {
    var je = 0, Ve = 0;
    je = (Be & 1) << 5 | Be >>> 27;
    for (var fi = 23; fi >= 15; fi -= 4)
      je <<= 6, je |= Be >>> fi & 63;
    for (var fi = 11; fi >= 3; fi -= 4)
      Ve |= Be >>> fi & 63, Ve <<= 6;
    Ve |= (Be & 31) << 1 | Be >>> 31, Pe[Te + 0] = je >>> 0, Pe[Te + 1] = Ve >>> 0;
  };
  var t = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$m.substitute = function(Be, Pe) {
    for (var Te = 0, je = 0; je < 4; je++) {
      var Ve = Be >>> 18 - je * 6 & 63, fi = t[je * 64 + Ve];
      Te <<= 4, Te |= fi;
    }
    for (var je = 0; je < 4; je++) {
      var Ve = Pe >>> 18 - je * 6 & 63, fi = t[4 * 64 + je * 64 + Ve];
      Te <<= 4, Te |= fi;
    }
    return Te >>> 0;
  };
  var Ie = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return utils$m.permute = function(Be) {
    for (var Pe = 0, Te = 0; Te < Ie.length; Te++)
      Pe <<= 1, Pe |= Be >>> Ie[Te] & 1;
    return Pe >>> 0;
  }, utils$m.padSplit = function(Be, Pe, Te) {
    for (var je = Be.toString(2); je.length < Pe; )
      je = "0" + je;
    for (var Ve = [], fi = 0; fi < Pe; fi += Te)
      Ve.push(je.slice(fi, fi + Te));
    return Ve.join(" ");
  }, utils$m;
}
var minimalisticAssert$1 = assert$k;
function assert$k(Ae, t) {
  if (!Ae)
    throw new Error(t || "Assertion failed");
}
assert$k.equal = function(t, Ie, Me) {
  if (t != Ie)
    throw new Error(Me || "Assertion failed: " + t + " != " + Ie);
};
var cipher, hasRequiredCipher;
function requireCipher() {
  if (hasRequiredCipher) return cipher;
  hasRequiredCipher = 1;
  var Ae = minimalisticAssert$1;
  function t(Ie) {
    this.options = Ie, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = Ie.padding !== !1;
  }
  return cipher = t, t.prototype._init = function() {
  }, t.prototype.update = function(Me) {
    return Me.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(Me) : this._updateEncrypt(Me);
  }, t.prototype._buffer = function(Me, Be) {
    for (var Pe = Math.min(this.buffer.length - this.bufferOff, Me.length - Be), Te = 0; Te < Pe; Te++)
      this.buffer[this.bufferOff + Te] = Me[Be + Te];
    return this.bufferOff += Pe, Pe;
  }, t.prototype._flushBuffer = function(Me, Be) {
    return this._update(this.buffer, 0, Me, Be), this.bufferOff = 0, this.blockSize;
  }, t.prototype._updateEncrypt = function(Me) {
    var Be = 0, Pe = 0, Te = (this.bufferOff + Me.length) / this.blockSize | 0, je = new Array(Te * this.blockSize);
    this.bufferOff !== 0 && (Be += this._buffer(Me, Be), this.bufferOff === this.buffer.length && (Pe += this._flushBuffer(je, Pe)));
    for (var Ve = Me.length - (Me.length - Be) % this.blockSize; Be < Ve; Be += this.blockSize)
      this._update(Me, Be, je, Pe), Pe += this.blockSize;
    for (; Be < Me.length; Be++, this.bufferOff++)
      this.buffer[this.bufferOff] = Me[Be];
    return je;
  }, t.prototype._updateDecrypt = function(Me) {
    for (var Be = 0, Pe = 0, Te = Math.ceil((this.bufferOff + Me.length) / this.blockSize) - 1, je = new Array(Te * this.blockSize); Te > 0; Te--)
      Be += this._buffer(Me, Be), Pe += this._flushBuffer(je, Pe);
    return Be += this._buffer(Me, Be), je;
  }, t.prototype.final = function(Me) {
    var Be;
    Me && (Be = this.update(Me));
    var Pe;
    return this.type === "encrypt" ? Pe = this._finalEncrypt() : Pe = this._finalDecrypt(), Be ? Be.concat(Pe) : Pe;
  }, t.prototype._pad = function(Me, Be) {
    if (Be === 0)
      return !1;
    for (; Be < Me.length; )
      Me[Be++] = 0;
    return !0;
  }, t.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var Me = new Array(this.blockSize);
    return this._update(this.buffer, 0, Me, 0), Me;
  }, t.prototype._unpad = function(Me) {
    return Me;
  }, t.prototype._finalDecrypt = function() {
    Ae.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var Me = new Array(this.blockSize);
    return this._flushBuffer(Me, 0), this._unpad(Me);
  }, cipher;
}
var des, hasRequiredDes$1;
function requireDes$1() {
  if (hasRequiredDes$1) return des;
  hasRequiredDes$1 = 1;
  var Ae = minimalisticAssert$1, t = inherits_browserExports, Ie = requireUtils(), Me = requireCipher();
  function Be() {
    this.tmp = new Array(2), this.keys = null;
  }
  function Pe(je) {
    Me.call(this, je);
    var Ve = new Be();
    this._desState = Ve, this.deriveKeys(Ve, je.key);
  }
  t(Pe, Me), des = Pe, Pe.create = function(Ve) {
    return new Pe(Ve);
  };
  var Te = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return Pe.prototype.deriveKeys = function(Ve, fi) {
    Ve.keys = new Array(16 * 2), Ae.equal(fi.length, this.blockSize, "Invalid key length");
    var Ue = Ie.readUInt32BE(fi, 0), bi = Ie.readUInt32BE(fi, 4);
    Ie.pc1(Ue, bi, Ve.tmp, 0), Ue = Ve.tmp[0], bi = Ve.tmp[1];
    for (var vi = 0; vi < Ve.keys.length; vi += 2) {
      var mi = Te[vi >>> 1];
      Ue = Ie.r28shl(Ue, mi), bi = Ie.r28shl(bi, mi), Ie.pc2(Ue, bi, Ve.keys, vi);
    }
  }, Pe.prototype._update = function(Ve, fi, Ue, bi) {
    var vi = this._desState, mi = Ie.readUInt32BE(Ve, fi), _i = Ie.readUInt32BE(Ve, fi + 4);
    Ie.ip(mi, _i, vi.tmp, 0), mi = vi.tmp[0], _i = vi.tmp[1], this.type === "encrypt" ? this._encrypt(vi, mi, _i, vi.tmp, 0) : this._decrypt(vi, mi, _i, vi.tmp, 0), mi = vi.tmp[0], _i = vi.tmp[1], Ie.writeUInt32BE(Ue, mi, bi), Ie.writeUInt32BE(Ue, _i, bi + 4);
  }, Pe.prototype._pad = function(Ve, fi) {
    if (this.padding === !1)
      return !1;
    for (var Ue = Ve.length - fi, bi = fi; bi < Ve.length; bi++)
      Ve[bi] = Ue;
    return !0;
  }, Pe.prototype._unpad = function(Ve) {
    if (this.padding === !1)
      return Ve;
    for (var fi = Ve[Ve.length - 1], Ue = Ve.length - fi; Ue < Ve.length; Ue++)
      Ae.equal(Ve[Ue], fi);
    return Ve.slice(0, Ve.length - fi);
  }, Pe.prototype._encrypt = function(Ve, fi, Ue, bi, vi) {
    for (var mi = fi, _i = Ue, Ei = 0; Ei < Ve.keys.length; Ei += 2) {
      var Pi = Ve.keys[Ei], Ii = Ve.keys[Ei + 1];
      Ie.expand(_i, Ve.tmp, 0), Pi ^= Ve.tmp[0], Ii ^= Ve.tmp[1];
      var Ci = Ie.substitute(Pi, Ii), Wi = Ie.permute(Ci), zi = _i;
      _i = (mi ^ Wi) >>> 0, mi = zi;
    }
    Ie.rip(_i, mi, bi, vi);
  }, Pe.prototype._decrypt = function(Ve, fi, Ue, bi, vi) {
    for (var mi = Ue, _i = fi, Ei = Ve.keys.length - 2; Ei >= 0; Ei -= 2) {
      var Pi = Ve.keys[Ei], Ii = Ve.keys[Ei + 1];
      Ie.expand(mi, Ve.tmp, 0), Pi ^= Ve.tmp[0], Ii ^= Ve.tmp[1];
      var Ci = Ie.substitute(Pi, Ii), Wi = Ie.permute(Ci), zi = mi;
      mi = (_i ^ Wi) >>> 0, _i = zi;
    }
    Ie.rip(mi, _i, bi, vi);
  }, des;
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
  if (hasRequiredCbc$1) return cbc$1;
  hasRequiredCbc$1 = 1;
  var Ae = minimalisticAssert$1, t = inherits_browserExports, Ie = {};
  function Me(Pe) {
    Ae.equal(Pe.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var Te = 0; Te < this.iv.length; Te++)
      this.iv[Te] = Pe[Te];
  }
  function Be(Pe) {
    function Te(Ue) {
      Pe.call(this, Ue), this._cbcInit();
    }
    t(Te, Pe);
    for (var je = Object.keys(Ie), Ve = 0; Ve < je.length; Ve++) {
      var fi = je[Ve];
      Te.prototype[fi] = Ie[fi];
    }
    return Te.create = function(bi) {
      return new Te(bi);
    }, Te;
  }
  return cbc$1.instantiate = Be, Ie._cbcInit = function() {
    var Te = new Me(this.options.iv);
    this._cbcState = Te;
  }, Ie._update = function(Te, je, Ve, fi) {
    var Ue = this._cbcState, bi = this.constructor.super_.prototype, vi = Ue.iv;
    if (this.type === "encrypt") {
      for (var mi = 0; mi < this.blockSize; mi++)
        vi[mi] ^= Te[je + mi];
      bi._update.call(this, vi, 0, Ve, fi);
      for (var mi = 0; mi < this.blockSize; mi++)
        vi[mi] = Ve[fi + mi];
    } else {
      bi._update.call(this, Te, je, Ve, fi);
      for (var mi = 0; mi < this.blockSize; mi++)
        Ve[fi + mi] ^= vi[mi];
      for (var mi = 0; mi < this.blockSize; mi++)
        vi[mi] = Te[je + mi];
    }
  }, cbc$1;
}
var ede, hasRequiredEde;
function requireEde() {
  if (hasRequiredEde) return ede;
  hasRequiredEde = 1;
  var Ae = minimalisticAssert$1, t = inherits_browserExports, Ie = requireCipher(), Me = requireDes$1();
  function Be(Te, je) {
    Ae.equal(je.length, 24, "Invalid key length");
    var Ve = je.slice(0, 8), fi = je.slice(8, 16), Ue = je.slice(16, 24);
    Te === "encrypt" ? this.ciphers = [
      Me.create({ type: "encrypt", key: Ve }),
      Me.create({ type: "decrypt", key: fi }),
      Me.create({ type: "encrypt", key: Ue })
    ] : this.ciphers = [
      Me.create({ type: "decrypt", key: Ue }),
      Me.create({ type: "encrypt", key: fi }),
      Me.create({ type: "decrypt", key: Ve })
    ];
  }
  function Pe(Te) {
    Ie.call(this, Te);
    var je = new Be(this.type, this.options.key);
    this._edeState = je;
  }
  return t(Pe, Ie), ede = Pe, Pe.create = function(je) {
    return new Pe(je);
  }, Pe.prototype._update = function(je, Ve, fi, Ue) {
    var bi = this._edeState;
    bi.ciphers[0]._update(je, Ve, fi, Ue), bi.ciphers[1]._update(fi, Ue, fi, Ue), bi.ciphers[2]._update(fi, Ue, fi, Ue);
  }, Pe.prototype._pad = Me.prototype._pad, Pe.prototype._unpad = Me.prototype._unpad, ede;
}
var hasRequiredDes;
function requireDes() {
  return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1;
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes) return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var Ae = requireCipherBase(), t = requireDes(), Ie = inherits_browserExports, Me = requireSafeBuffer$1().Buffer, Be = {
    "des-ede3-cbc": t.CBC.instantiate(t.EDE),
    "des-ede3": t.EDE,
    "des-ede-cbc": t.CBC.instantiate(t.EDE),
    "des-ede": t.EDE,
    "des-cbc": t.CBC.instantiate(t.DES),
    "des-ecb": t.DES
  };
  Be.des = Be["des-cbc"], Be.des3 = Be["des-ede3-cbc"], browserifyDes = Pe, Ie(Pe, Ae);
  function Pe(Te) {
    Ae.call(this);
    var je = Te.mode.toLowerCase(), Ve = Be[je], fi;
    Te.decrypt ? fi = "decrypt" : fi = "encrypt";
    var Ue = Te.key;
    Me.isBuffer(Ue) || (Ue = Me.from(Ue)), (je === "des-ede" || je === "des-ede-cbc") && (Ue = Me.concat([Ue, Ue.slice(0, 8)]));
    var bi = Te.iv;
    Me.isBuffer(bi) || (bi = Me.from(bi)), this._des = Ve.create({
      key: Ue,
      iv: bi,
      type: fi
    });
  }
  return Pe.prototype._update = function(Te) {
    return Me.from(this._des.update(Te));
  }, Pe.prototype._final = function() {
    return Me.from(this._des.final());
  }, browserifyDes;
}
var browser$6 = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
  return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function(Ae, t) {
    return Ae._cipher.encryptBlock(t);
  }, ecb.decrypt = function(Ae, t) {
    return Ae._cipher.decryptBlock(t);
  }), ecb;
}
var cbc = {}, bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
  return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function(t, Ie) {
    for (var Me = Math.min(t.length, Ie.length), Be = new Buffer(Me), Pe = 0; Pe < Me; ++Pe)
      Be[Pe] = t[Pe] ^ Ie[Pe];
    return Be;
  }), bufferXor;
}
var hasRequiredCbc;
function requireCbc() {
  if (hasRequiredCbc) return cbc;
  hasRequiredCbc = 1;
  var Ae = requireBufferXor();
  return cbc.encrypt = function(t, Ie) {
    var Me = Ae(Ie, t._prev);
    return t._prev = t._cipher.encryptBlock(Me), t._prev;
  }, cbc.decrypt = function(t, Ie) {
    var Me = t._prev;
    t._prev = Ie;
    var Be = t._cipher.decryptBlock(Ie);
    return Ae(Be, Me);
  }, cbc;
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb) return cfb;
  hasRequiredCfb = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requireBufferXor();
  function Ie(Me, Be, Pe) {
    var Te = Be.length, je = t(Be, Me._cache);
    return Me._cache = Me._cache.slice(Te), Me._prev = Ae.concat([Me._prev, Pe ? Be : je]), je;
  }
  return cfb.encrypt = function(Me, Be, Pe) {
    for (var Te = Ae.allocUnsafe(0), je; Be.length; )
      if (Me._cache.length === 0 && (Me._cache = Me._cipher.encryptBlock(Me._prev), Me._prev = Ae.allocUnsafe(0)), Me._cache.length <= Be.length)
        je = Me._cache.length, Te = Ae.concat([Te, Ie(Me, Be.slice(0, je), Pe)]), Be = Be.slice(je);
      else {
        Te = Ae.concat([Te, Ie(Me, Be, Pe)]);
        break;
      }
    return Te;
  }, cfb;
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8) return cfb8;
  hasRequiredCfb8 = 1;
  var Ae = requireSafeBuffer$1().Buffer;
  function t(Ie, Me, Be) {
    var Pe = Ie._cipher.encryptBlock(Ie._prev), Te = Pe[0] ^ Me;
    return Ie._prev = Ae.concat([
      Ie._prev.slice(1),
      Ae.from([Be ? Me : Te])
    ]), Te;
  }
  return cfb8.encrypt = function(Ie, Me, Be) {
    for (var Pe = Me.length, Te = Ae.allocUnsafe(Pe), je = -1; ++je < Pe; )
      Te[je] = t(Ie, Me[je], Be);
    return Te;
  }, cfb8;
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1) return cfb1;
  hasRequiredCfb1 = 1;
  var Ae = requireSafeBuffer$1().Buffer;
  function t(Me, Be, Pe) {
    for (var Te, je = -1, Ve = 8, fi = 0, Ue, bi; ++je < Ve; )
      Te = Me._cipher.encryptBlock(Me._prev), Ue = Be & 1 << 7 - je ? 128 : 0, bi = Te[0] ^ Ue, fi += (bi & 128) >> je % 8, Me._prev = Ie(Me._prev, Pe ? Ue : bi);
    return fi;
  }
  function Ie(Me, Be) {
    var Pe = Me.length, Te = -1, je = Ae.allocUnsafe(Me.length);
    for (Me = Ae.concat([Me, Ae.from([Be])]); ++Te < Pe; )
      je[Te] = Me[Te] << 1 | Me[Te + 1] >> 7;
    return je;
  }
  return cfb1.encrypt = function(Me, Be, Pe) {
    for (var Te = Be.length, je = Ae.allocUnsafe(Te), Ve = -1; ++Ve < Te; )
      je[Ve] = t(Me, Be[Ve], Pe);
    return je;
  }, cfb1;
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb) return ofb;
  hasRequiredOfb = 1;
  var Ae = requireBufferXor();
  function t(Ie) {
    return Ie._prev = Ie._cipher.encryptBlock(Ie._prev), Ie._prev;
  }
  return ofb.encrypt = function(Ie, Me) {
    for (; Ie._cache.length < Me.length; )
      Ie._cache = Buffer.concat([Ie._cache, t(Ie)]);
    var Be = Ie._cache.slice(0, Me.length);
    return Ie._cache = Ie._cache.slice(Me.length), Ae(Me, Be);
  }, ofb;
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
  if (hasRequiredIncr32) return incr32_1;
  hasRequiredIncr32 = 1;
  function Ae(t) {
    for (var Ie = t.length, Me; Ie--; )
      if (Me = t.readUInt8(Ie), Me === 255)
        t.writeUInt8(0, Ie);
      else {
        Me++, t.writeUInt8(Me, Ie);
        break;
      }
  }
  return incr32_1 = Ae, incr32_1;
}
var hasRequiredCtr;
function requireCtr() {
  if (hasRequiredCtr) return ctr;
  hasRequiredCtr = 1;
  var Ae = requireBufferXor(), t = requireSafeBuffer$1().Buffer, Ie = requireIncr32();
  function Me(Pe) {
    var Te = Pe._cipher.encryptBlockRaw(Pe._prev);
    return Ie(Pe._prev), Te;
  }
  var Be = 16;
  return ctr.encrypt = function(Pe, Te) {
    var je = Math.ceil(Te.length / Be), Ve = Pe._cache.length;
    Pe._cache = t.concat([
      Pe._cache,
      t.allocUnsafe(je * Be)
    ]);
    for (var fi = 0; fi < je; fi++) {
      var Ue = Me(Pe), bi = Ve + fi * Be;
      Pe._cache.writeUInt32BE(Ue[0], bi + 0), Pe._cache.writeUInt32BE(Ue[1], bi + 4), Pe._cache.writeUInt32BE(Ue[2], bi + 8), Pe._cache.writeUInt32BE(Ue[3], bi + 12);
    }
    var vi = Pe._cache.slice(0, Te.length);
    return Pe._cache = Pe._cache.slice(Te.length), Ae(Te, vi);
  }, ctr;
}
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1) return modes_1;
  hasRequiredModes$1 = 1;
  var Ae = {
    ECB: requireEcb(),
    CBC: requireCbc(),
    CFB: requireCfb(),
    CFB8: requireCfb8(),
    CFB1: requireCfb1(),
    OFB: requireOfb(),
    CTR: requireCtr(),
    GCM: requireCtr()
  }, t = require$$2;
  for (var Ie in t)
    t[Ie].module = Ae[t[Ie].mode];
  return modes_1 = t, modes_1;
}
var aes = {}, hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes;
  hasRequiredAes = 1;
  var Ae = requireSafeBuffer$1().Buffer;
  function t(je) {
    Ae.isBuffer(je) || (je = Ae.from(je));
    for (var Ve = je.length / 4 | 0, fi = new Array(Ve), Ue = 0; Ue < Ve; Ue++)
      fi[Ue] = je.readUInt32BE(Ue * 4);
    return fi;
  }
  function Ie(je) {
    for (var Ve = 0; Ve < je.length; je++)
      je[Ve] = 0;
  }
  function Me(je, Ve, fi, Ue, bi) {
    for (var vi = fi[0], mi = fi[1], _i = fi[2], Ei = fi[3], Pi = je[0] ^ Ve[0], Ii = je[1] ^ Ve[1], Ci = je[2] ^ Ve[2], Wi = je[3] ^ Ve[3], zi, Xi, Qi, Oi, Yi = 4, ns = 1; ns < bi; ns++)
      zi = vi[Pi >>> 24] ^ mi[Ii >>> 16 & 255] ^ _i[Ci >>> 8 & 255] ^ Ei[Wi & 255] ^ Ve[Yi++], Xi = vi[Ii >>> 24] ^ mi[Ci >>> 16 & 255] ^ _i[Wi >>> 8 & 255] ^ Ei[Pi & 255] ^ Ve[Yi++], Qi = vi[Ci >>> 24] ^ mi[Wi >>> 16 & 255] ^ _i[Pi >>> 8 & 255] ^ Ei[Ii & 255] ^ Ve[Yi++], Oi = vi[Wi >>> 24] ^ mi[Pi >>> 16 & 255] ^ _i[Ii >>> 8 & 255] ^ Ei[Ci & 255] ^ Ve[Yi++], Pi = zi, Ii = Xi, Ci = Qi, Wi = Oi;
    return zi = (Ue[Pi >>> 24] << 24 | Ue[Ii >>> 16 & 255] << 16 | Ue[Ci >>> 8 & 255] << 8 | Ue[Wi & 255]) ^ Ve[Yi++], Xi = (Ue[Ii >>> 24] << 24 | Ue[Ci >>> 16 & 255] << 16 | Ue[Wi >>> 8 & 255] << 8 | Ue[Pi & 255]) ^ Ve[Yi++], Qi = (Ue[Ci >>> 24] << 24 | Ue[Wi >>> 16 & 255] << 16 | Ue[Pi >>> 8 & 255] << 8 | Ue[Ii & 255]) ^ Ve[Yi++], Oi = (Ue[Wi >>> 24] << 24 | Ue[Pi >>> 16 & 255] << 16 | Ue[Ii >>> 8 & 255] << 8 | Ue[Ci & 255]) ^ Ve[Yi++], zi = zi >>> 0, Xi = Xi >>> 0, Qi = Qi >>> 0, Oi = Oi >>> 0, [zi, Xi, Qi, Oi];
  }
  var Be = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], Pe = function() {
    for (var je = new Array(256), Ve = 0; Ve < 256; Ve++)
      Ve < 128 ? je[Ve] = Ve << 1 : je[Ve] = Ve << 1 ^ 283;
    for (var fi = [], Ue = [], bi = [[], [], [], []], vi = [[], [], [], []], mi = 0, _i = 0, Ei = 0; Ei < 256; ++Ei) {
      var Pi = _i ^ _i << 1 ^ _i << 2 ^ _i << 3 ^ _i << 4;
      Pi = Pi >>> 8 ^ Pi & 255 ^ 99, fi[mi] = Pi, Ue[Pi] = mi;
      var Ii = je[mi], Ci = je[Ii], Wi = je[Ci], zi = je[Pi] * 257 ^ Pi * 16843008;
      bi[0][mi] = zi << 24 | zi >>> 8, bi[1][mi] = zi << 16 | zi >>> 16, bi[2][mi] = zi << 8 | zi >>> 24, bi[3][mi] = zi, zi = Wi * 16843009 ^ Ci * 65537 ^ Ii * 257 ^ mi * 16843008, vi[0][Pi] = zi << 24 | zi >>> 8, vi[1][Pi] = zi << 16 | zi >>> 16, vi[2][Pi] = zi << 8 | zi >>> 24, vi[3][Pi] = zi, mi === 0 ? mi = _i = 1 : (mi = Ii ^ je[je[je[Wi ^ Ii]]], _i ^= je[je[_i]]);
    }
    return {
      SBOX: fi,
      INV_SBOX: Ue,
      SUB_MIX: bi,
      INV_SUB_MIX: vi
    };
  }();
  function Te(je) {
    this._key = t(je), this._reset();
  }
  return Te.blockSize = 4 * 4, Te.keySize = 256 / 8, Te.prototype.blockSize = Te.blockSize, Te.prototype.keySize = Te.keySize, Te.prototype._reset = function() {
    for (var je = this._key, Ve = je.length, fi = Ve + 6, Ue = (fi + 1) * 4, bi = [], vi = 0; vi < Ve; vi++)
      bi[vi] = je[vi];
    for (vi = Ve; vi < Ue; vi++) {
      var mi = bi[vi - 1];
      vi % Ve === 0 ? (mi = mi << 8 | mi >>> 24, mi = Pe.SBOX[mi >>> 24] << 24 | Pe.SBOX[mi >>> 16 & 255] << 16 | Pe.SBOX[mi >>> 8 & 255] << 8 | Pe.SBOX[mi & 255], mi ^= Be[vi / Ve | 0] << 24) : Ve > 6 && vi % Ve === 4 && (mi = Pe.SBOX[mi >>> 24] << 24 | Pe.SBOX[mi >>> 16 & 255] << 16 | Pe.SBOX[mi >>> 8 & 255] << 8 | Pe.SBOX[mi & 255]), bi[vi] = bi[vi - Ve] ^ mi;
    }
    for (var _i = [], Ei = 0; Ei < Ue; Ei++) {
      var Pi = Ue - Ei, Ii = bi[Pi - (Ei % 4 ? 0 : 4)];
      Ei < 4 || Pi <= 4 ? _i[Ei] = Ii : _i[Ei] = Pe.INV_SUB_MIX[0][Pe.SBOX[Ii >>> 24]] ^ Pe.INV_SUB_MIX[1][Pe.SBOX[Ii >>> 16 & 255]] ^ Pe.INV_SUB_MIX[2][Pe.SBOX[Ii >>> 8 & 255]] ^ Pe.INV_SUB_MIX[3][Pe.SBOX[Ii & 255]];
    }
    this._nRounds = fi, this._keySchedule = bi, this._invKeySchedule = _i;
  }, Te.prototype.encryptBlockRaw = function(je) {
    return je = t(je), Me(je, this._keySchedule, Pe.SUB_MIX, Pe.SBOX, this._nRounds);
  }, Te.prototype.encryptBlock = function(je) {
    var Ve = this.encryptBlockRaw(je), fi = Ae.allocUnsafe(16);
    return fi.writeUInt32BE(Ve[0], 0), fi.writeUInt32BE(Ve[1], 4), fi.writeUInt32BE(Ve[2], 8), fi.writeUInt32BE(Ve[3], 12), fi;
  }, Te.prototype.decryptBlock = function(je) {
    je = t(je);
    var Ve = je[1];
    je[1] = je[3], je[3] = Ve;
    var fi = Me(je, this._invKeySchedule, Pe.INV_SUB_MIX, Pe.INV_SBOX, this._nRounds), Ue = Ae.allocUnsafe(16);
    return Ue.writeUInt32BE(fi[0], 0), Ue.writeUInt32BE(fi[3], 4), Ue.writeUInt32BE(fi[2], 8), Ue.writeUInt32BE(fi[1], 12), Ue;
  }, Te.prototype.scrub = function() {
    Ie(this._keySchedule), Ie(this._invKeySchedule), Ie(this._key);
  }, aes.AES = Te, aes;
}
var ghash, hasRequiredGhash;
function requireGhash() {
  if (hasRequiredGhash) return ghash;
  hasRequiredGhash = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = Ae.alloc(16, 0);
  function Ie(Pe) {
    return [
      Pe.readUInt32BE(0),
      Pe.readUInt32BE(4),
      Pe.readUInt32BE(8),
      Pe.readUInt32BE(12)
    ];
  }
  function Me(Pe) {
    var Te = Ae.allocUnsafe(16);
    return Te.writeUInt32BE(Pe[0] >>> 0, 0), Te.writeUInt32BE(Pe[1] >>> 0, 4), Te.writeUInt32BE(Pe[2] >>> 0, 8), Te.writeUInt32BE(Pe[3] >>> 0, 12), Te;
  }
  function Be(Pe) {
    this.h = Pe, this.state = Ae.alloc(16, 0), this.cache = Ae.allocUnsafe(0);
  }
  return Be.prototype.ghash = function(Pe) {
    for (var Te = -1; ++Te < Pe.length; )
      this.state[Te] ^= Pe[Te];
    this._multiply();
  }, Be.prototype._multiply = function() {
    for (var Pe = Ie(this.h), Te = [0, 0, 0, 0], je, Ve, fi, Ue = -1; ++Ue < 128; ) {
      for (Ve = (this.state[~~(Ue / 8)] & 1 << 7 - Ue % 8) !== 0, Ve && (Te[0] ^= Pe[0], Te[1] ^= Pe[1], Te[2] ^= Pe[2], Te[3] ^= Pe[3]), fi = (Pe[3] & 1) !== 0, je = 3; je > 0; je--)
        Pe[je] = Pe[je] >>> 1 | (Pe[je - 1] & 1) << 31;
      Pe[0] = Pe[0] >>> 1, fi && (Pe[0] = Pe[0] ^ 225 << 24);
    }
    this.state = Me(Te);
  }, Be.prototype.update = function(Pe) {
    this.cache = Ae.concat([this.cache, Pe]);
    for (var Te; this.cache.length >= 16; )
      Te = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(Te);
  }, Be.prototype.final = function(Pe, Te) {
    return this.cache.length && this.ghash(Ae.concat([this.cache, t], 16)), this.ghash(Me([0, Pe, 0, Te])), this.state;
  }, ghash = Be, ghash;
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
  if (hasRequiredAuthCipher) return authCipher;
  hasRequiredAuthCipher = 1;
  var Ae = requireAes(), t = requireSafeBuffer$1().Buffer, Ie = requireCipherBase(), Me = inherits_browserExports, Be = requireGhash(), Pe = requireBufferXor(), Te = requireIncr32();
  function je(Ue, bi) {
    var vi = 0;
    Ue.length !== bi.length && vi++;
    for (var mi = Math.min(Ue.length, bi.length), _i = 0; _i < mi; ++_i)
      vi += Ue[_i] ^ bi[_i];
    return vi;
  }
  function Ve(Ue, bi, vi) {
    if (bi.length === 12)
      return Ue._finID = t.concat([bi, t.from([0, 0, 0, 1])]), t.concat([bi, t.from([0, 0, 0, 2])]);
    var mi = new Be(vi), _i = bi.length, Ei = _i % 16;
    mi.update(bi), Ei && (Ei = 16 - Ei, mi.update(t.alloc(Ei, 0))), mi.update(t.alloc(8, 0));
    var Pi = _i * 8, Ii = t.alloc(8);
    Ii.writeUIntBE(Pi, 0, 8), mi.update(Ii), Ue._finID = mi.state;
    var Ci = t.from(Ue._finID);
    return Te(Ci), Ci;
  }
  function fi(Ue, bi, vi, mi) {
    Ie.call(this);
    var _i = t.alloc(4, 0);
    this._cipher = new Ae.AES(bi);
    var Ei = this._cipher.encryptBlock(_i);
    this._ghash = new Be(Ei), vi = Ve(this, vi, Ei), this._prev = t.from(vi), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = mi, this._alen = 0, this._len = 0, this._mode = Ue, this._authTag = null, this._called = !1;
  }
  return Me(fi, Ie), fi.prototype._update = function(Ue) {
    if (!this._called && this._alen) {
      var bi = 16 - this._alen % 16;
      bi < 16 && (bi = t.alloc(bi, 0), this._ghash.update(bi));
    }
    this._called = !0;
    var vi = this._mode.encrypt(this, Ue);
    return this._decrypt ? this._ghash.update(Ue) : this._ghash.update(vi), this._len += Ue.length, vi;
  }, fi.prototype._final = function() {
    if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var Ue = Pe(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && je(Ue, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = Ue, this._cipher.scrub();
  }, fi.prototype.getAuthTag = function() {
    if (this._decrypt || !t.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, fi.prototype.setAuthTag = function(bi) {
    if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = bi;
  }, fi.prototype.setAAD = function(bi) {
    if (this._called) throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(bi), this._alen += bi.length;
  }, authCipher = fi, authCipher;
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
  if (hasRequiredStreamCipher) return streamCipher;
  hasRequiredStreamCipher = 1;
  var Ae = requireAes(), t = requireSafeBuffer$1().Buffer, Ie = requireCipherBase(), Me = inherits_browserExports;
  function Be(Pe, Te, je, Ve) {
    Ie.call(this), this._cipher = new Ae.AES(Te), this._prev = t.from(je), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = Ve, this._mode = Pe;
  }
  return Me(Be, Ie), Be.prototype._update = function(Pe) {
    return this._mode.encrypt(this, Pe, this._decrypt);
  }, Be.prototype._final = function() {
    this._cipher.scrub();
  }, streamCipher = Be, streamCipher;
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey) return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requireMd5_js();
  function Ie(Me, Be, Pe, Te) {
    if (Ae.isBuffer(Me) || (Me = Ae.from(Me, "binary")), Be && (Ae.isBuffer(Be) || (Be = Ae.from(Be, "binary")), Be.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var je = Pe / 8, Ve = Ae.alloc(je), fi = Ae.alloc(Te || 0), Ue = Ae.alloc(0); je > 0 || Te > 0; ) {
      var bi = new t();
      bi.update(Ue), bi.update(Me), Be && bi.update(Be), Ue = bi.digest();
      var vi = 0;
      if (je > 0) {
        var mi = Ve.length - je;
        vi = Math.min(je, Ue.length), Ue.copy(Ve, mi, 0, vi), je -= vi;
      }
      if (vi < Ue.length && Te > 0) {
        var _i = fi.length - Te, Ei = Math.min(Te, Ue.length - vi);
        Ue.copy(fi, _i, vi, vi + Ei), Te -= Ei;
      }
    }
    return Ue.fill(0), { key: Ve, iv: fi };
  }
  return evp_bytestokey = Ie, evp_bytestokey;
}
var hasRequiredEncrypter;
function requireEncrypter() {
  if (hasRequiredEncrypter) return encrypter;
  hasRequiredEncrypter = 1;
  var Ae = requireModes$1(), t = requireAuthCipher(), Ie = requireSafeBuffer$1().Buffer, Me = requireStreamCipher(), Be = requireCipherBase(), Pe = requireAes(), Te = requireEvp_bytestokey(), je = inherits_browserExports;
  function Ve(mi, _i, Ei) {
    Be.call(this), this._cache = new Ue(), this._cipher = new Pe.AES(_i), this._prev = Ie.from(Ei), this._mode = mi, this._autopadding = !0;
  }
  je(Ve, Be), Ve.prototype._update = function(mi) {
    this._cache.add(mi);
    for (var _i, Ei, Pi = []; _i = this._cache.get(); )
      Ei = this._mode.encrypt(this, _i), Pi.push(Ei);
    return Ie.concat(Pi);
  };
  var fi = Ie.alloc(16, 16);
  Ve.prototype._final = function() {
    var mi = this._cache.flush();
    if (this._autopadding)
      return mi = this._mode.encrypt(this, mi), this._cipher.scrub(), mi;
    if (!mi.equals(fi))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, Ve.prototype.setAutoPadding = function(mi) {
    return this._autopadding = !!mi, this;
  };
  function Ue() {
    this.cache = Ie.allocUnsafe(0);
  }
  Ue.prototype.add = function(mi) {
    this.cache = Ie.concat([this.cache, mi]);
  }, Ue.prototype.get = function() {
    if (this.cache.length > 15) {
      var mi = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), mi;
    }
    return null;
  }, Ue.prototype.flush = function() {
    for (var mi = 16 - this.cache.length, _i = Ie.allocUnsafe(mi), Ei = -1; ++Ei < mi; )
      _i.writeUInt8(mi, Ei);
    return Ie.concat([this.cache, _i]);
  };
  function bi(mi, _i, Ei) {
    var Pi = Ae[mi.toLowerCase()];
    if (!Pi) throw new TypeError("invalid suite type");
    if (typeof _i == "string" && (_i = Ie.from(_i)), _i.length !== Pi.key / 8) throw new TypeError("invalid key length " + _i.length);
    if (typeof Ei == "string" && (Ei = Ie.from(Ei)), Pi.mode !== "GCM" && Ei.length !== Pi.iv) throw new TypeError("invalid iv length " + Ei.length);
    return Pi.type === "stream" ? new Me(Pi.module, _i, Ei) : Pi.type === "auth" ? new t(Pi.module, _i, Ei) : new Ve(Pi.module, _i, Ei);
  }
  function vi(mi, _i) {
    var Ei = Ae[mi.toLowerCase()];
    if (!Ei) throw new TypeError("invalid suite type");
    var Pi = Te(_i, !1, Ei.key, Ei.iv);
    return bi(mi, Pi.key, Pi.iv);
  }
  return encrypter.createCipheriv = bi, encrypter.createCipher = vi, encrypter;
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
  if (hasRequiredDecrypter) return decrypter;
  hasRequiredDecrypter = 1;
  var Ae = requireAuthCipher(), t = requireSafeBuffer$1().Buffer, Ie = requireModes$1(), Me = requireStreamCipher(), Be = requireCipherBase(), Pe = requireAes(), Te = requireEvp_bytestokey(), je = inherits_browserExports;
  function Ve(mi, _i, Ei) {
    Be.call(this), this._cache = new fi(), this._last = void 0, this._cipher = new Pe.AES(_i), this._prev = t.from(Ei), this._mode = mi, this._autopadding = !0;
  }
  je(Ve, Be), Ve.prototype._update = function(mi) {
    this._cache.add(mi);
    for (var _i, Ei, Pi = []; _i = this._cache.get(this._autopadding); )
      Ei = this._mode.decrypt(this, _i), Pi.push(Ei);
    return t.concat(Pi);
  }, Ve.prototype._final = function() {
    var mi = this._cache.flush();
    if (this._autopadding)
      return Ue(this._mode.decrypt(this, mi));
    if (mi)
      throw new Error("data not multiple of block length");
  }, Ve.prototype.setAutoPadding = function(mi) {
    return this._autopadding = !!mi, this;
  };
  function fi() {
    this.cache = t.allocUnsafe(0);
  }
  fi.prototype.add = function(mi) {
    this.cache = t.concat([this.cache, mi]);
  }, fi.prototype.get = function(mi) {
    var _i;
    if (mi) {
      if (this.cache.length > 16)
        return _i = this.cache.slice(0, 16), this.cache = this.cache.slice(16), _i;
    } else if (this.cache.length >= 16)
      return _i = this.cache.slice(0, 16), this.cache = this.cache.slice(16), _i;
    return null;
  }, fi.prototype.flush = function() {
    if (this.cache.length) return this.cache;
  };
  function Ue(mi) {
    var _i = mi[15];
    if (_i < 1 || _i > 16)
      throw new Error("unable to decrypt data");
    for (var Ei = -1; ++Ei < _i; )
      if (mi[Ei + (16 - _i)] !== _i)
        throw new Error("unable to decrypt data");
    if (_i !== 16)
      return mi.slice(0, 16 - _i);
  }
  function bi(mi, _i, Ei) {
    var Pi = Ie[mi.toLowerCase()];
    if (!Pi) throw new TypeError("invalid suite type");
    if (typeof Ei == "string" && (Ei = t.from(Ei)), Pi.mode !== "GCM" && Ei.length !== Pi.iv) throw new TypeError("invalid iv length " + Ei.length);
    if (typeof _i == "string" && (_i = t.from(_i)), _i.length !== Pi.key / 8) throw new TypeError("invalid key length " + _i.length);
    return Pi.type === "stream" ? new Me(Pi.module, _i, Ei, !0) : Pi.type === "auth" ? new Ae(Pi.module, _i, Ei, !0) : new Ve(Pi.module, _i, Ei);
  }
  function vi(mi, _i) {
    var Ei = Ie[mi.toLowerCase()];
    if (!Ei) throw new TypeError("invalid suite type");
    var Pi = Te(_i, !1, Ei.key, Ei.iv);
    return bi(mi, Pi.key, Pi.iv);
  }
  return decrypter.createDecipher = vi, decrypter.createDecipheriv = bi, decrypter;
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
  if (hasRequiredBrowser$6) return browser$6;
  hasRequiredBrowser$6 = 1;
  var Ae = requireEncrypter(), t = requireDecrypter(), Ie = require$$2;
  function Me() {
    return Object.keys(Ie);
  }
  return browser$6.createCipher = browser$6.Cipher = Ae.createCipher, browser$6.createCipheriv = browser$6.Cipheriv = Ae.createCipheriv, browser$6.createDecipher = browser$6.Decipher = t.createDecipher, browser$6.createDecipheriv = browser$6.Decipheriv = t.createDecipheriv, browser$6.listCiphers = browser$6.getCiphers = Me, browser$6;
}
var modes = {}, hasRequiredModes;
function requireModes() {
  return hasRequiredModes || (hasRequiredModes = 1, function(Ae) {
    Ae["des-ecb"] = {
      key: 8,
      iv: 0
    }, Ae["des-cbc"] = Ae.des = {
      key: 8,
      iv: 8
    }, Ae["des-ede3-cbc"] = Ae.des3 = {
      key: 24,
      iv: 8
    }, Ae["des-ede3"] = {
      key: 24,
      iv: 0
    }, Ae["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, Ae["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(modes)), modes;
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
  if (hasRequiredBrowser$5) return browser$7;
  hasRequiredBrowser$5 = 1;
  var Ae = requireBrowserifyDes(), t = requireBrowser$6(), Ie = requireModes$1(), Me = requireModes(), Be = requireEvp_bytestokey();
  function Pe(Ue, bi) {
    Ue = Ue.toLowerCase();
    var vi, mi;
    if (Ie[Ue])
      vi = Ie[Ue].key, mi = Ie[Ue].iv;
    else if (Me[Ue])
      vi = Me[Ue].key * 8, mi = Me[Ue].iv;
    else
      throw new TypeError("invalid suite type");
    var _i = Be(bi, !1, vi, mi);
    return je(Ue, _i.key, _i.iv);
  }
  function Te(Ue, bi) {
    Ue = Ue.toLowerCase();
    var vi, mi;
    if (Ie[Ue])
      vi = Ie[Ue].key, mi = Ie[Ue].iv;
    else if (Me[Ue])
      vi = Me[Ue].key * 8, mi = Me[Ue].iv;
    else
      throw new TypeError("invalid suite type");
    var _i = Be(bi, !1, vi, mi);
    return Ve(Ue, _i.key, _i.iv);
  }
  function je(Ue, bi, vi) {
    if (Ue = Ue.toLowerCase(), Ie[Ue]) return t.createCipheriv(Ue, bi, vi);
    if (Me[Ue]) return new Ae({ key: bi, iv: vi, mode: Ue });
    throw new TypeError("invalid suite type");
  }
  function Ve(Ue, bi, vi) {
    if (Ue = Ue.toLowerCase(), Ie[Ue]) return t.createDecipheriv(Ue, bi, vi);
    if (Me[Ue]) return new Ae({ key: bi, iv: vi, mode: Ue, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function fi() {
    return Object.keys(Me).concat(t.getCiphers());
  }
  return browser$7.createCipher = browser$7.Cipher = Pe, browser$7.createCipheriv = browser$7.Cipheriv = je, browser$7.createDecipher = browser$7.Decipher = Te, browser$7.createDecipheriv = browser$7.Decipheriv = Ve, browser$7.listCiphers = browser$7.getCiphers = fi, browser$7;
}
var browser$5 = {}, bn$3 = { exports: {} };
bn$3.exports;
(function(Ae) {
  (function(t, Ie) {
    function Me(vn, Mi) {
      if (!vn) throw new Error(Mi || "Assertion failed");
    }
    function Be(vn, Mi) {
      vn.super_ = Mi;
      var Ai = function() {
      };
      Ai.prototype = Mi.prototype, vn.prototype = new Ai(), vn.prototype.constructor = vn;
    }
    function Pe(vn, Mi, Ai) {
      if (Pe.isBN(vn))
        return vn;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, vn !== null && ((Mi === "le" || Mi === "be") && (Ai = Mi, Mi = 10), this._init(vn || 0, Mi || 10, Ai || "be"));
    }
    typeof t == "object" ? t.exports = Pe : Ie.BN = Pe, Pe.BN = Pe, Pe.wordSize = 26;
    var Te;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Te = window.Buffer : Te = require$$1$2.Buffer;
    } catch {
    }
    Pe.isBN = function(Mi) {
      return Mi instanceof Pe ? !0 : Mi !== null && typeof Mi == "object" && Mi.constructor.wordSize === Pe.wordSize && Array.isArray(Mi.words);
    }, Pe.max = function(Mi, Ai) {
      return Mi.cmp(Ai) > 0 ? Mi : Ai;
    }, Pe.min = function(Mi, Ai) {
      return Mi.cmp(Ai) < 0 ? Mi : Ai;
    }, Pe.prototype._init = function(Mi, Ai, wi) {
      if (typeof Mi == "number")
        return this._initNumber(Mi, Ai, wi);
      if (typeof Mi == "object")
        return this._initArray(Mi, Ai, wi);
      Ai === "hex" && (Ai = 16), Me(Ai === (Ai | 0) && Ai >= 2 && Ai <= 36), Mi = Mi.toString().replace(/\s+/g, "");
      var $i = 0;
      Mi[0] === "-" && ($i++, this.negative = 1), $i < Mi.length && (Ai === 16 ? this._parseHex(Mi, $i, wi) : (this._parseBase(Mi, Ai, $i), wi === "le" && this._initArray(this.toArray(), Ai, wi)));
    }, Pe.prototype._initNumber = function(Mi, Ai, wi) {
      Mi < 0 && (this.negative = 1, Mi = -Mi), Mi < 67108864 ? (this.words = [Mi & 67108863], this.length = 1) : Mi < 4503599627370496 ? (this.words = [
        Mi & 67108863,
        Mi / 67108864 & 67108863
      ], this.length = 2) : (Me(Mi < 9007199254740992), this.words = [
        Mi & 67108863,
        Mi / 67108864 & 67108863,
        1
      ], this.length = 3), wi === "le" && this._initArray(this.toArray(), Ai, wi);
    }, Pe.prototype._initArray = function(Mi, Ai, wi) {
      if (Me(typeof Mi.length == "number"), Mi.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(Mi.length / 3), this.words = new Array(this.length);
      for (var $i = 0; $i < this.length; $i++)
        this.words[$i] = 0;
      var Li, qi, Ni = 0;
      if (wi === "be")
        for ($i = Mi.length - 1, Li = 0; $i >= 0; $i -= 3)
          qi = Mi[$i] | Mi[$i - 1] << 8 | Mi[$i - 2] << 16, this.words[Li] |= qi << Ni & 67108863, this.words[Li + 1] = qi >>> 26 - Ni & 67108863, Ni += 24, Ni >= 26 && (Ni -= 26, Li++);
      else if (wi === "le")
        for ($i = 0, Li = 0; $i < Mi.length; $i += 3)
          qi = Mi[$i] | Mi[$i + 1] << 8 | Mi[$i + 2] << 16, this.words[Li] |= qi << Ni & 67108863, this.words[Li + 1] = qi >>> 26 - Ni & 67108863, Ni += 24, Ni >= 26 && (Ni -= 26, Li++);
      return this.strip();
    };
    function je(vn, Mi) {
      var Ai = vn.charCodeAt(Mi);
      return Ai >= 65 && Ai <= 70 ? Ai - 55 : Ai >= 97 && Ai <= 102 ? Ai - 87 : Ai - 48 & 15;
    }
    function Ve(vn, Mi, Ai) {
      var wi = je(vn, Ai);
      return Ai - 1 >= Mi && (wi |= je(vn, Ai - 1) << 4), wi;
    }
    Pe.prototype._parseHex = function(Mi, Ai, wi) {
      this.length = Math.ceil((Mi.length - Ai) / 6), this.words = new Array(this.length);
      for (var $i = 0; $i < this.length; $i++)
        this.words[$i] = 0;
      var Li = 0, qi = 0, Ni;
      if (wi === "be")
        for ($i = Mi.length - 1; $i >= Ai; $i -= 2)
          Ni = Ve(Mi, Ai, $i) << Li, this.words[qi] |= Ni & 67108863, Li >= 18 ? (Li -= 18, qi += 1, this.words[qi] |= Ni >>> 26) : Li += 8;
      else {
        var Ti = Mi.length - Ai;
        for ($i = Ti % 2 === 0 ? Ai + 1 : Ai; $i < Mi.length; $i += 2)
          Ni = Ve(Mi, Ai, $i) << Li, this.words[qi] |= Ni & 67108863, Li >= 18 ? (Li -= 18, qi += 1, this.words[qi] |= Ni >>> 26) : Li += 8;
      }
      this.strip();
    };
    function fi(vn, Mi, Ai, wi) {
      for (var $i = 0, Li = Math.min(vn.length, Ai), qi = Mi; qi < Li; qi++) {
        var Ni = vn.charCodeAt(qi) - 48;
        $i *= wi, Ni >= 49 ? $i += Ni - 49 + 10 : Ni >= 17 ? $i += Ni - 17 + 10 : $i += Ni;
      }
      return $i;
    }
    Pe.prototype._parseBase = function(Mi, Ai, wi) {
      this.words = [0], this.length = 1;
      for (var $i = 0, Li = 1; Li <= 67108863; Li *= Ai)
        $i++;
      $i--, Li = Li / Ai | 0;
      for (var qi = Mi.length - wi, Ni = qi % $i, Ti = Math.min(qi, qi - Ni) + wi, xi = 0, Fi = wi; Fi < Ti; Fi += $i)
        xi = fi(Mi, Fi, Fi + $i, Ai), this.imuln(Li), this.words[0] + xi < 67108864 ? this.words[0] += xi : this._iaddn(xi);
      if (Ni !== 0) {
        var Si = 1;
        for (xi = fi(Mi, Fi, Mi.length, Ai), Fi = 0; Fi < Ni; Fi++)
          Si *= Ai;
        this.imuln(Si), this.words[0] + xi < 67108864 ? this.words[0] += xi : this._iaddn(xi);
      }
      this.strip();
    }, Pe.prototype.copy = function(Mi) {
      Mi.words = new Array(this.length);
      for (var Ai = 0; Ai < this.length; Ai++)
        Mi.words[Ai] = this.words[Ai];
      Mi.length = this.length, Mi.negative = this.negative, Mi.red = this.red;
    }, Pe.prototype.clone = function() {
      var Mi = new Pe(null);
      return this.copy(Mi), Mi;
    }, Pe.prototype._expand = function(Mi) {
      for (; this.length < Mi; )
        this.words[this.length++] = 0;
      return this;
    }, Pe.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, Pe.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, Pe.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var Ue = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], bi = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], vi = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    Pe.prototype.toString = function(Mi, Ai) {
      Mi = Mi || 10, Ai = Ai | 0 || 1;
      var wi;
      if (Mi === 16 || Mi === "hex") {
        wi = "";
        for (var $i = 0, Li = 0, qi = 0; qi < this.length; qi++) {
          var Ni = this.words[qi], Ti = ((Ni << $i | Li) & 16777215).toString(16);
          Li = Ni >>> 24 - $i & 16777215, Li !== 0 || qi !== this.length - 1 ? wi = Ue[6 - Ti.length] + Ti + wi : wi = Ti + wi, $i += 2, $i >= 26 && ($i -= 26, qi--);
        }
        for (Li !== 0 && (wi = Li.toString(16) + wi); wi.length % Ai !== 0; )
          wi = "0" + wi;
        return this.negative !== 0 && (wi = "-" + wi), wi;
      }
      if (Mi === (Mi | 0) && Mi >= 2 && Mi <= 36) {
        var xi = bi[Mi], Fi = vi[Mi];
        wi = "";
        var Si = this.clone();
        for (Si.negative = 0; !Si.isZero(); ) {
          var Vi = Si.modn(Fi).toString(Mi);
          Si = Si.idivn(Fi), Si.isZero() ? wi = Vi + wi : wi = Ue[xi - Vi.length] + Vi + wi;
        }
        for (this.isZero() && (wi = "0" + wi); wi.length % Ai !== 0; )
          wi = "0" + wi;
        return this.negative !== 0 && (wi = "-" + wi), wi;
      }
      Me(!1, "Base should be between 2 and 36");
    }, Pe.prototype.toNumber = function() {
      var Mi = this.words[0];
      return this.length === 2 ? Mi += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? Mi += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && Me(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -Mi : Mi;
    }, Pe.prototype.toJSON = function() {
      return this.toString(16);
    }, Pe.prototype.toBuffer = function(Mi, Ai) {
      return Me(typeof Te < "u"), this.toArrayLike(Te, Mi, Ai);
    }, Pe.prototype.toArray = function(Mi, Ai) {
      return this.toArrayLike(Array, Mi, Ai);
    }, Pe.prototype.toArrayLike = function(Mi, Ai, wi) {
      var $i = this.byteLength(), Li = wi || Math.max(1, $i);
      Me($i <= Li, "byte array longer than desired length"), Me(Li > 0, "Requested array length <= 0"), this.strip();
      var qi = Ai === "le", Ni = new Mi(Li), Ti, xi, Fi = this.clone();
      if (qi) {
        for (xi = 0; !Fi.isZero(); xi++)
          Ti = Fi.andln(255), Fi.iushrn(8), Ni[xi] = Ti;
        for (; xi < Li; xi++)
          Ni[xi] = 0;
      } else {
        for (xi = 0; xi < Li - $i; xi++)
          Ni[xi] = 0;
        for (xi = 0; !Fi.isZero(); xi++)
          Ti = Fi.andln(255), Fi.iushrn(8), Ni[Li - xi - 1] = Ti;
      }
      return Ni;
    }, Math.clz32 ? Pe.prototype._countBits = function(Mi) {
      return 32 - Math.clz32(Mi);
    } : Pe.prototype._countBits = function(Mi) {
      var Ai = Mi, wi = 0;
      return Ai >= 4096 && (wi += 13, Ai >>>= 13), Ai >= 64 && (wi += 7, Ai >>>= 7), Ai >= 8 && (wi += 4, Ai >>>= 4), Ai >= 2 && (wi += 2, Ai >>>= 2), wi + Ai;
    }, Pe.prototype._zeroBits = function(Mi) {
      if (Mi === 0) return 26;
      var Ai = Mi, wi = 0;
      return Ai & 8191 || (wi += 13, Ai >>>= 13), Ai & 127 || (wi += 7, Ai >>>= 7), Ai & 15 || (wi += 4, Ai >>>= 4), Ai & 3 || (wi += 2, Ai >>>= 2), Ai & 1 || wi++, wi;
    }, Pe.prototype.bitLength = function() {
      var Mi = this.words[this.length - 1], Ai = this._countBits(Mi);
      return (this.length - 1) * 26 + Ai;
    };
    function mi(vn) {
      for (var Mi = new Array(vn.bitLength()), Ai = 0; Ai < Mi.length; Ai++) {
        var wi = Ai / 26 | 0, $i = Ai % 26;
        Mi[Ai] = (vn.words[wi] & 1 << $i) >>> $i;
      }
      return Mi;
    }
    Pe.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var Mi = 0, Ai = 0; Ai < this.length; Ai++) {
        var wi = this._zeroBits(this.words[Ai]);
        if (Mi += wi, wi !== 26) break;
      }
      return Mi;
    }, Pe.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Pe.prototype.toTwos = function(Mi) {
      return this.negative !== 0 ? this.abs().inotn(Mi).iaddn(1) : this.clone();
    }, Pe.prototype.fromTwos = function(Mi) {
      return this.testn(Mi - 1) ? this.notn(Mi).iaddn(1).ineg() : this.clone();
    }, Pe.prototype.isNeg = function() {
      return this.negative !== 0;
    }, Pe.prototype.neg = function() {
      return this.clone().ineg();
    }, Pe.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, Pe.prototype.iuor = function(Mi) {
      for (; this.length < Mi.length; )
        this.words[this.length++] = 0;
      for (var Ai = 0; Ai < Mi.length; Ai++)
        this.words[Ai] = this.words[Ai] | Mi.words[Ai];
      return this.strip();
    }, Pe.prototype.ior = function(Mi) {
      return Me((this.negative | Mi.negative) === 0), this.iuor(Mi);
    }, Pe.prototype.or = function(Mi) {
      return this.length > Mi.length ? this.clone().ior(Mi) : Mi.clone().ior(this);
    }, Pe.prototype.uor = function(Mi) {
      return this.length > Mi.length ? this.clone().iuor(Mi) : Mi.clone().iuor(this);
    }, Pe.prototype.iuand = function(Mi) {
      var Ai;
      this.length > Mi.length ? Ai = Mi : Ai = this;
      for (var wi = 0; wi < Ai.length; wi++)
        this.words[wi] = this.words[wi] & Mi.words[wi];
      return this.length = Ai.length, this.strip();
    }, Pe.prototype.iand = function(Mi) {
      return Me((this.negative | Mi.negative) === 0), this.iuand(Mi);
    }, Pe.prototype.and = function(Mi) {
      return this.length > Mi.length ? this.clone().iand(Mi) : Mi.clone().iand(this);
    }, Pe.prototype.uand = function(Mi) {
      return this.length > Mi.length ? this.clone().iuand(Mi) : Mi.clone().iuand(this);
    }, Pe.prototype.iuxor = function(Mi) {
      var Ai, wi;
      this.length > Mi.length ? (Ai = this, wi = Mi) : (Ai = Mi, wi = this);
      for (var $i = 0; $i < wi.length; $i++)
        this.words[$i] = Ai.words[$i] ^ wi.words[$i];
      if (this !== Ai)
        for (; $i < Ai.length; $i++)
          this.words[$i] = Ai.words[$i];
      return this.length = Ai.length, this.strip();
    }, Pe.prototype.ixor = function(Mi) {
      return Me((this.negative | Mi.negative) === 0), this.iuxor(Mi);
    }, Pe.prototype.xor = function(Mi) {
      return this.length > Mi.length ? this.clone().ixor(Mi) : Mi.clone().ixor(this);
    }, Pe.prototype.uxor = function(Mi) {
      return this.length > Mi.length ? this.clone().iuxor(Mi) : Mi.clone().iuxor(this);
    }, Pe.prototype.inotn = function(Mi) {
      Me(typeof Mi == "number" && Mi >= 0);
      var Ai = Math.ceil(Mi / 26) | 0, wi = Mi % 26;
      this._expand(Ai), wi > 0 && Ai--;
      for (var $i = 0; $i < Ai; $i++)
        this.words[$i] = ~this.words[$i] & 67108863;
      return wi > 0 && (this.words[$i] = ~this.words[$i] & 67108863 >> 26 - wi), this.strip();
    }, Pe.prototype.notn = function(Mi) {
      return this.clone().inotn(Mi);
    }, Pe.prototype.setn = function(Mi, Ai) {
      Me(typeof Mi == "number" && Mi >= 0);
      var wi = Mi / 26 | 0, $i = Mi % 26;
      return this._expand(wi + 1), Ai ? this.words[wi] = this.words[wi] | 1 << $i : this.words[wi] = this.words[wi] & ~(1 << $i), this.strip();
    }, Pe.prototype.iadd = function(Mi) {
      var Ai;
      if (this.negative !== 0 && Mi.negative === 0)
        return this.negative = 0, Ai = this.isub(Mi), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && Mi.negative !== 0)
        return Mi.negative = 0, Ai = this.isub(Mi), Mi.negative = 1, Ai._normSign();
      var wi, $i;
      this.length > Mi.length ? (wi = this, $i = Mi) : (wi = Mi, $i = this);
      for (var Li = 0, qi = 0; qi < $i.length; qi++)
        Ai = (wi.words[qi] | 0) + ($i.words[qi] | 0) + Li, this.words[qi] = Ai & 67108863, Li = Ai >>> 26;
      for (; Li !== 0 && qi < wi.length; qi++)
        Ai = (wi.words[qi] | 0) + Li, this.words[qi] = Ai & 67108863, Li = Ai >>> 26;
      if (this.length = wi.length, Li !== 0)
        this.words[this.length] = Li, this.length++;
      else if (wi !== this)
        for (; qi < wi.length; qi++)
          this.words[qi] = wi.words[qi];
      return this;
    }, Pe.prototype.add = function(Mi) {
      var Ai;
      return Mi.negative !== 0 && this.negative === 0 ? (Mi.negative = 0, Ai = this.sub(Mi), Mi.negative ^= 1, Ai) : Mi.negative === 0 && this.negative !== 0 ? (this.negative = 0, Ai = Mi.sub(this), this.negative = 1, Ai) : this.length > Mi.length ? this.clone().iadd(Mi) : Mi.clone().iadd(this);
    }, Pe.prototype.isub = function(Mi) {
      if (Mi.negative !== 0) {
        Mi.negative = 0;
        var Ai = this.iadd(Mi);
        return Mi.negative = 1, Ai._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(Mi), this.negative = 1, this._normSign();
      var wi = this.cmp(Mi);
      if (wi === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var $i, Li;
      wi > 0 ? ($i = this, Li = Mi) : ($i = Mi, Li = this);
      for (var qi = 0, Ni = 0; Ni < Li.length; Ni++)
        Ai = ($i.words[Ni] | 0) - (Li.words[Ni] | 0) + qi, qi = Ai >> 26, this.words[Ni] = Ai & 67108863;
      for (; qi !== 0 && Ni < $i.length; Ni++)
        Ai = ($i.words[Ni] | 0) + qi, qi = Ai >> 26, this.words[Ni] = Ai & 67108863;
      if (qi === 0 && Ni < $i.length && $i !== this)
        for (; Ni < $i.length; Ni++)
          this.words[Ni] = $i.words[Ni];
      return this.length = Math.max(this.length, Ni), $i !== this && (this.negative = 1), this.strip();
    }, Pe.prototype.sub = function(Mi) {
      return this.clone().isub(Mi);
    };
    function _i(vn, Mi, Ai) {
      Ai.negative = Mi.negative ^ vn.negative;
      var wi = vn.length + Mi.length | 0;
      Ai.length = wi, wi = wi - 1 | 0;
      var $i = vn.words[0] | 0, Li = Mi.words[0] | 0, qi = $i * Li, Ni = qi & 67108863, Ti = qi / 67108864 | 0;
      Ai.words[0] = Ni;
      for (var xi = 1; xi < wi; xi++) {
        for (var Fi = Ti >>> 26, Si = Ti & 67108863, Vi = Math.min(xi, Mi.length - 1), ts = Math.max(0, xi - vn.length + 1); ts <= Vi; ts++) {
          var Hi = xi - ts | 0;
          $i = vn.words[Hi] | 0, Li = Mi.words[ts] | 0, qi = $i * Li + Si, Fi += qi / 67108864 | 0, Si = qi & 67108863;
        }
        Ai.words[xi] = Si | 0, Ti = Fi | 0;
      }
      return Ti !== 0 ? Ai.words[xi] = Ti | 0 : Ai.length--, Ai.strip();
    }
    var Ei = function(Mi, Ai, wi) {
      var $i = Mi.words, Li = Ai.words, qi = wi.words, Ni = 0, Ti, xi, Fi, Si = $i[0] | 0, Vi = Si & 8191, ts = Si >>> 13, Hi = $i[1] | 0, fn = Hi & 8191, Bi = Hi >>> 13, ki = $i[2] | 0, Ji = ki & 8191, Ri = ki >>> 13, ji = $i[3] | 0, Gi = ji & 8191, is = ji >>> 13, os = $i[4] | 0, ds = os & 8191, ps = os >>> 13, ea = $i[5] | 0, ia = ea & 8191, hs = ea >>> 13, fa = $i[6] | 0, gs = fa & 8191, sa = fa >>> 13, aa = $i[7] | 0, Ds = aa & 8191, ra = aa >>> 13, ca = $i[8] | 0, ta = ca & 8191, oa = ca >>> 13, da = $i[9] | 0, Zi = da & 8191, Ui = da >>> 13, Ki = Li[0] | 0, En = Ki & 8191, ss = Ki >>> 13, as = Li[1] | 0, us = as & 8191, ua = as >>> 13, ma = Li[2] | 0, na = ma & 8191, wa = ma >>> 13, ga = Li[3] | 0, Ea = ga & 8191, xa = ga >>> 13, $a = Li[4] | 0, la = $a & 8191, Sa = $a >>> 13, Aa = Li[5] | 0, ha = Aa & 8191, Ma = Aa >>> 13, Da = Li[6] | 0, va = Da & 8191, Ba = Da >>> 13, Pa = Li[7] | 0, pa = Pa & 8191, Ra = Pa >>> 13, _a = Li[8] | 0, ya = _a & 8191, qa = _a >>> 13, Na = Li[9] | 0, Ia = Na & 8191, Fa = Na >>> 13;
      wi.negative = Mi.negative ^ Ai.negative, wi.length = 19, Ti = Math.imul(Vi, En), xi = Math.imul(Vi, ss), xi = xi + Math.imul(ts, En) | 0, Fi = Math.imul(ts, ss);
      var Oa = (Ni + Ti | 0) + ((xi & 8191) << 13) | 0;
      Ni = (Fi + (xi >>> 13) | 0) + (Oa >>> 26) | 0, Oa &= 67108863, Ti = Math.imul(fn, En), xi = Math.imul(fn, ss), xi = xi + Math.imul(Bi, En) | 0, Fi = Math.imul(Bi, ss), Ti = Ti + Math.imul(Vi, us) | 0, xi = xi + Math.imul(Vi, ua) | 0, xi = xi + Math.imul(ts, us) | 0, Fi = Fi + Math.imul(ts, ua) | 0;
      var Ta = (Ni + Ti | 0) + ((xi & 8191) << 13) | 0;
      Ni = (Fi + (xi >>> 13) | 0) + (Ta >>> 26) | 0, Ta &= 67108863, Ti = Math.imul(Ji, En), xi = Math.imul(Ji, ss), xi = xi + Math.imul(Ri, En) | 0, Fi = Math.imul(Ri, ss), Ti = Ti + Math.imul(fn, us) | 0, xi = xi + Math.imul(fn, ua) | 0, xi = xi + Math.imul(Bi, us) | 0, Fi = Fi + Math.imul(Bi, ua) | 0, Ti = Ti + Math.imul(Vi, na) | 0, xi = xi + Math.imul(Vi, wa) | 0, xi = xi + Math.imul(ts, na) | 0, Fi = Fi + Math.imul(ts, wa) | 0;
      var Va = (Ni + Ti | 0) + ((xi & 8191) << 13) | 0;
      Ni = (Fi + (xi >>> 13) | 0) + (Va >>> 26) | 0, Va &= 67108863, Ti = Math.imul(Gi, En), xi = Math.imul(Gi, ss), xi = xi + Math.imul(is, En) | 0, Fi = Math.imul(is, ss), Ti = Ti + Math.imul(Ji, us) | 0, xi = xi + Math.imul(Ji, ua) | 0, xi = xi + Math.imul(Ri, us) | 0, Fi = Fi + Math.imul(Ri, ua) | 0, Ti = Ti + Math.imul(fn, na) | 0, xi = xi + Math.imul(fn, wa) | 0, xi = xi + Math.imul(Bi, na) | 0, Fi = Fi + Math.imul(Bi, wa) | 0, Ti = Ti + Math.imul(Vi, Ea) | 0, xi = xi + Math.imul(Vi, xa) | 0, xi = xi + Math.imul(ts, Ea) | 0, Fi = Fi + Math.imul(ts, xa) | 0;
      var Ga = (Ni + Ti | 0) + ((xi & 8191) << 13) | 0;
      Ni = (Fi + (xi >>> 13) | 0) + (Ga >>> 26) | 0, Ga &= 67108863, Ti = Math.imul(ds, En), xi = Math.imul(ds, ss), xi = xi + Math.imul(ps, En) | 0, Fi = Math.imul(ps, ss), Ti = Ti + Math.imul(Gi, us) | 0, xi = xi + Math.imul(Gi, ua) | 0, xi = xi + Math.imul(is, us) | 0, Fi = Fi + Math.imul(is, ua) | 0, Ti = Ti + Math.imul(Ji, na) | 0, xi = xi + Math.imul(Ji, wa) | 0, xi = xi + Math.imul(Ri, na) | 0, Fi = Fi + Math.imul(Ri, wa) | 0, Ti = Ti + Math.imul(fn, Ea) | 0, xi = xi + Math.imul(fn, xa) | 0, xi = xi + Math.imul(Bi, Ea) | 0, Fi = Fi + Math.imul(Bi, xa) | 0, Ti = Ti + Math.imul(Vi, la) | 0, xi = xi + Math.imul(Vi, Sa) | 0, xi = xi + Math.imul(ts, la) | 0, Fi = Fi + Math.imul(ts, Sa) | 0;
      var Ja = (Ni + Ti | 0) + ((xi & 8191) << 13) | 0;
      Ni = (Fi + (xi >>> 13) | 0) + (Ja >>> 26) | 0, Ja &= 67108863, Ti = Math.imul(ia, En), xi = Math.imul(ia, ss), xi = xi + Math.imul(hs, En) | 0, Fi = Math.imul(hs, ss), Ti = Ti + Math.imul(ds, us) | 0, xi = xi + Math.imul(ds, ua) | 0, xi = xi + Math.imul(ps, us) | 0, Fi = Fi + Math.imul(ps, ua) | 0, Ti = Ti + Math.imul(Gi, na) | 0, xi = xi + Math.imul(Gi, wa) | 0, xi = xi + Math.imul(is, na) | 0, Fi = Fi + Math.imul(is, wa) | 0, Ti = Ti + Math.imul(Ji, Ea) | 0, xi = xi + Math.imul(Ji, xa) | 0, xi = xi + Math.imul(Ri, Ea) | 0, Fi = Fi + Math.imul(Ri, xa) | 0, Ti = Ti + Math.imul(fn, la) | 0, xi = xi + Math.imul(fn, Sa) | 0, xi = xi + Math.imul(Bi, la) | 0, Fi = Fi + Math.imul(Bi, Sa) | 0, Ti = Ti + Math.imul(Vi, ha) | 0, xi = xi + Math.imul(Vi, Ma) | 0, xi = xi + Math.imul(ts, ha) | 0, Fi = Fi + Math.imul(ts, Ma) | 0;
      var Xa = (Ni + Ti | 0) + ((xi & 8191) << 13) | 0;
      Ni = (Fi + (xi >>> 13) | 0) + (Xa >>> 26) | 0, Xa &= 67108863, Ti = Math.imul(gs, En), xi = Math.imul(gs, ss), xi = xi + Math.imul(sa, En) | 0, Fi = Math.imul(sa, ss), Ti = Ti + Math.imul(ia, us) | 0, xi = xi + Math.imul(ia, ua) | 0, xi = xi + Math.imul(hs, us) | 0, Fi = Fi + Math.imul(hs, ua) | 0, Ti = Ti + Math.imul(ds, na) | 0, xi = xi + Math.imul(ds, wa) | 0, xi = xi + Math.imul(ps, na) | 0, Fi = Fi + Math.imul(ps, wa) | 0, Ti = Ti + Math.imul(Gi, Ea) | 0, xi = xi + Math.imul(Gi, xa) | 0, xi = xi + Math.imul(is, Ea) | 0, Fi = Fi + Math.imul(is, xa) | 0, Ti = Ti + Math.imul(Ji, la) | 0, xi = xi + Math.imul(Ji, Sa) | 0, xi = xi + Math.imul(Ri, la) | 0, Fi = Fi + Math.imul(Ri, Sa) | 0, Ti = Ti + Math.imul(fn, ha) | 0, xi = xi + Math.imul(fn, Ma) | 0, xi = xi + Math.imul(Bi, ha) | 0, Fi = Fi + Math.imul(Bi, Ma) | 0, Ti = Ti + Math.imul(Vi, va) | 0, xi = xi + Math.imul(Vi, Ba) | 0, xi = xi + Math.imul(ts, va) | 0, Fi = Fi + Math.imul(ts, Ba) | 0;
      var ja = (Ni + Ti | 0) + ((xi & 8191) << 13) | 0;
      Ni = (Fi + (xi >>> 13) | 0) + (ja >>> 26) | 0, ja &= 67108863, Ti = Math.imul(Ds, En), xi = Math.imul(Ds, ss), xi = xi + Math.imul(ra, En) | 0, Fi = Math.imul(ra, ss), Ti = Ti + Math.imul(gs, us) | 0, xi = xi + Math.imul(gs, ua) | 0, xi = xi + Math.imul(sa, us) | 0, Fi = Fi + Math.imul(sa, ua) | 0, Ti = Ti + Math.imul(ia, na) | 0, xi = xi + Math.imul(ia, wa) | 0, xi = xi + Math.imul(hs, na) | 0, Fi = Fi + Math.imul(hs, wa) | 0, Ti = Ti + Math.imul(ds, Ea) | 0, xi = xi + Math.imul(ds, xa) | 0, xi = xi + Math.imul(ps, Ea) | 0, Fi = Fi + Math.imul(ps, xa) | 0, Ti = Ti + Math.imul(Gi, la) | 0, xi = xi + Math.imul(Gi, Sa) | 0, xi = xi + Math.imul(is, la) | 0, Fi = Fi + Math.imul(is, Sa) | 0, Ti = Ti + Math.imul(Ji, ha) | 0, xi = xi + Math.imul(Ji, Ma) | 0, xi = xi + Math.imul(Ri, ha) | 0, Fi = Fi + Math.imul(Ri, Ma) | 0, Ti = Ti + Math.imul(fn, va) | 0, xi = xi + Math.imul(fn, Ba) | 0, xi = xi + Math.imul(Bi, va) | 0, Fi = Fi + Math.imul(Bi, Ba) | 0, Ti = Ti + Math.imul(Vi, pa) | 0, xi = xi + Math.imul(Vi, Ra) | 0, xi = xi + Math.imul(ts, pa) | 0, Fi = Fi + Math.imul(ts, Ra) | 0;
      var go = (Ni + Ti | 0) + ((xi & 8191) << 13) | 0;
      Ni = (Fi + (xi >>> 13) | 0) + (go >>> 26) | 0, go &= 67108863, Ti = Math.imul(ta, En), xi = Math.imul(ta, ss), xi = xi + Math.imul(oa, En) | 0, Fi = Math.imul(oa, ss), Ti = Ti + Math.imul(Ds, us) | 0, xi = xi + Math.imul(Ds, ua) | 0, xi = xi + Math.imul(ra, us) | 0, Fi = Fi + Math.imul(ra, ua) | 0, Ti = Ti + Math.imul(gs, na) | 0, xi = xi + Math.imul(gs, wa) | 0, xi = xi + Math.imul(sa, na) | 0, Fi = Fi + Math.imul(sa, wa) | 0, Ti = Ti + Math.imul(ia, Ea) | 0, xi = xi + Math.imul(ia, xa) | 0, xi = xi + Math.imul(hs, Ea) | 0, Fi = Fi + Math.imul(hs, xa) | 0, Ti = Ti + Math.imul(ds, la) | 0, xi = xi + Math.imul(ds, Sa) | 0, xi = xi + Math.imul(ps, la) | 0, Fi = Fi + Math.imul(ps, Sa) | 0, Ti = Ti + Math.imul(Gi, ha) | 0, xi = xi + Math.imul(Gi, Ma) | 0, xi = xi + Math.imul(is, ha) | 0, Fi = Fi + Math.imul(is, Ma) | 0, Ti = Ti + Math.imul(Ji, va) | 0, xi = xi + Math.imul(Ji, Ba) | 0, xi = xi + Math.imul(Ri, va) | 0, Fi = Fi + Math.imul(Ri, Ba) | 0, Ti = Ti + Math.imul(fn, pa) | 0, xi = xi + Math.imul(fn, Ra) | 0, xi = xi + Math.imul(Bi, pa) | 0, Fi = Fi + Math.imul(Bi, Ra) | 0, Ti = Ti + Math.imul(Vi, ya) | 0, xi = xi + Math.imul(Vi, qa) | 0, xi = xi + Math.imul(ts, ya) | 0, Fi = Fi + Math.imul(ts, qa) | 0;
      var wo = (Ni + Ti | 0) + ((xi & 8191) << 13) | 0;
      Ni = (Fi + (xi >>> 13) | 0) + (wo >>> 26) | 0, wo &= 67108863, Ti = Math.imul(Zi, En), xi = Math.imul(Zi, ss), xi = xi + Math.imul(Ui, En) | 0, Fi = Math.imul(Ui, ss), Ti = Ti + Math.imul(ta, us) | 0, xi = xi + Math.imul(ta, ua) | 0, xi = xi + Math.imul(oa, us) | 0, Fi = Fi + Math.imul(oa, ua) | 0, Ti = Ti + Math.imul(Ds, na) | 0, xi = xi + Math.imul(Ds, wa) | 0, xi = xi + Math.imul(ra, na) | 0, Fi = Fi + Math.imul(ra, wa) | 0, Ti = Ti + Math.imul(gs, Ea) | 0, xi = xi + Math.imul(gs, xa) | 0, xi = xi + Math.imul(sa, Ea) | 0, Fi = Fi + Math.imul(sa, xa) | 0, Ti = Ti + Math.imul(ia, la) | 0, xi = xi + Math.imul(ia, Sa) | 0, xi = xi + Math.imul(hs, la) | 0, Fi = Fi + Math.imul(hs, Sa) | 0, Ti = Ti + Math.imul(ds, ha) | 0, xi = xi + Math.imul(ds, Ma) | 0, xi = xi + Math.imul(ps, ha) | 0, Fi = Fi + Math.imul(ps, Ma) | 0, Ti = Ti + Math.imul(Gi, va) | 0, xi = xi + Math.imul(Gi, Ba) | 0, xi = xi + Math.imul(is, va) | 0, Fi = Fi + Math.imul(is, Ba) | 0, Ti = Ti + Math.imul(Ji, pa) | 0, xi = xi + Math.imul(Ji, Ra) | 0, xi = xi + Math.imul(Ri, pa) | 0, Fi = Fi + Math.imul(Ri, Ra) | 0, Ti = Ti + Math.imul(fn, ya) | 0, xi = xi + Math.imul(fn, qa) | 0, xi = xi + Math.imul(Bi, ya) | 0, Fi = Fi + Math.imul(Bi, qa) | 0, Ti = Ti + Math.imul(Vi, Ia) | 0, xi = xi + Math.imul(Vi, Fa) | 0, xi = xi + Math.imul(ts, Ia) | 0, Fi = Fi + Math.imul(ts, Fa) | 0;
      var _o = (Ni + Ti | 0) + ((xi & 8191) << 13) | 0;
      Ni = (Fi + (xi >>> 13) | 0) + (_o >>> 26) | 0, _o &= 67108863, Ti = Math.imul(Zi, us), xi = Math.imul(Zi, ua), xi = xi + Math.imul(Ui, us) | 0, Fi = Math.imul(Ui, ua), Ti = Ti + Math.imul(ta, na) | 0, xi = xi + Math.imul(ta, wa) | 0, xi = xi + Math.imul(oa, na) | 0, Fi = Fi + Math.imul(oa, wa) | 0, Ti = Ti + Math.imul(Ds, Ea) | 0, xi = xi + Math.imul(Ds, xa) | 0, xi = xi + Math.imul(ra, Ea) | 0, Fi = Fi + Math.imul(ra, xa) | 0, Ti = Ti + Math.imul(gs, la) | 0, xi = xi + Math.imul(gs, Sa) | 0, xi = xi + Math.imul(sa, la) | 0, Fi = Fi + Math.imul(sa, Sa) | 0, Ti = Ti + Math.imul(ia, ha) | 0, xi = xi + Math.imul(ia, Ma) | 0, xi = xi + Math.imul(hs, ha) | 0, Fi = Fi + Math.imul(hs, Ma) | 0, Ti = Ti + Math.imul(ds, va) | 0, xi = xi + Math.imul(ds, Ba) | 0, xi = xi + Math.imul(ps, va) | 0, Fi = Fi + Math.imul(ps, Ba) | 0, Ti = Ti + Math.imul(Gi, pa) | 0, xi = xi + Math.imul(Gi, Ra) | 0, xi = xi + Math.imul(is, pa) | 0, Fi = Fi + Math.imul(is, Ra) | 0, Ti = Ti + Math.imul(Ji, ya) | 0, xi = xi + Math.imul(Ji, qa) | 0, xi = xi + Math.imul(Ri, ya) | 0, Fi = Fi + Math.imul(Ri, qa) | 0, Ti = Ti + Math.imul(fn, Ia) | 0, xi = xi + Math.imul(fn, Fa) | 0, xi = xi + Math.imul(Bi, Ia) | 0, Fi = Fi + Math.imul(Bi, Fa) | 0;
      var Eo = (Ni + Ti | 0) + ((xi & 8191) << 13) | 0;
      Ni = (Fi + (xi >>> 13) | 0) + (Eo >>> 26) | 0, Eo &= 67108863, Ti = Math.imul(Zi, na), xi = Math.imul(Zi, wa), xi = xi + Math.imul(Ui, na) | 0, Fi = Math.imul(Ui, wa), Ti = Ti + Math.imul(ta, Ea) | 0, xi = xi + Math.imul(ta, xa) | 0, xi = xi + Math.imul(oa, Ea) | 0, Fi = Fi + Math.imul(oa, xa) | 0, Ti = Ti + Math.imul(Ds, la) | 0, xi = xi + Math.imul(Ds, Sa) | 0, xi = xi + Math.imul(ra, la) | 0, Fi = Fi + Math.imul(ra, Sa) | 0, Ti = Ti + Math.imul(gs, ha) | 0, xi = xi + Math.imul(gs, Ma) | 0, xi = xi + Math.imul(sa, ha) | 0, Fi = Fi + Math.imul(sa, Ma) | 0, Ti = Ti + Math.imul(ia, va) | 0, xi = xi + Math.imul(ia, Ba) | 0, xi = xi + Math.imul(hs, va) | 0, Fi = Fi + Math.imul(hs, Ba) | 0, Ti = Ti + Math.imul(ds, pa) | 0, xi = xi + Math.imul(ds, Ra) | 0, xi = xi + Math.imul(ps, pa) | 0, Fi = Fi + Math.imul(ps, Ra) | 0, Ti = Ti + Math.imul(Gi, ya) | 0, xi = xi + Math.imul(Gi, qa) | 0, xi = xi + Math.imul(is, ya) | 0, Fi = Fi + Math.imul(is, qa) | 0, Ti = Ti + Math.imul(Ji, Ia) | 0, xi = xi + Math.imul(Ji, Fa) | 0, xi = xi + Math.imul(Ri, Ia) | 0, Fi = Fi + Math.imul(Ri, Fa) | 0;
      var $o = (Ni + Ti | 0) + ((xi & 8191) << 13) | 0;
      Ni = (Fi + (xi >>> 13) | 0) + ($o >>> 26) | 0, $o &= 67108863, Ti = Math.imul(Zi, Ea), xi = Math.imul(Zi, xa), xi = xi + Math.imul(Ui, Ea) | 0, Fi = Math.imul(Ui, xa), Ti = Ti + Math.imul(ta, la) | 0, xi = xi + Math.imul(ta, Sa) | 0, xi = xi + Math.imul(oa, la) | 0, Fi = Fi + Math.imul(oa, Sa) | 0, Ti = Ti + Math.imul(Ds, ha) | 0, xi = xi + Math.imul(Ds, Ma) | 0, xi = xi + Math.imul(ra, ha) | 0, Fi = Fi + Math.imul(ra, Ma) | 0, Ti = Ti + Math.imul(gs, va) | 0, xi = xi + Math.imul(gs, Ba) | 0, xi = xi + Math.imul(sa, va) | 0, Fi = Fi + Math.imul(sa, Ba) | 0, Ti = Ti + Math.imul(ia, pa) | 0, xi = xi + Math.imul(ia, Ra) | 0, xi = xi + Math.imul(hs, pa) | 0, Fi = Fi + Math.imul(hs, Ra) | 0, Ti = Ti + Math.imul(ds, ya) | 0, xi = xi + Math.imul(ds, qa) | 0, xi = xi + Math.imul(ps, ya) | 0, Fi = Fi + Math.imul(ps, qa) | 0, Ti = Ti + Math.imul(Gi, Ia) | 0, xi = xi + Math.imul(Gi, Fa) | 0, xi = xi + Math.imul(is, Ia) | 0, Fi = Fi + Math.imul(is, Fa) | 0;
      var Za = (Ni + Ti | 0) + ((xi & 8191) << 13) | 0;
      Ni = (Fi + (xi >>> 13) | 0) + (Za >>> 26) | 0, Za &= 67108863, Ti = Math.imul(Zi, la), xi = Math.imul(Zi, Sa), xi = xi + Math.imul(Ui, la) | 0, Fi = Math.imul(Ui, Sa), Ti = Ti + Math.imul(ta, ha) | 0, xi = xi + Math.imul(ta, Ma) | 0, xi = xi + Math.imul(oa, ha) | 0, Fi = Fi + Math.imul(oa, Ma) | 0, Ti = Ti + Math.imul(Ds, va) | 0, xi = xi + Math.imul(Ds, Ba) | 0, xi = xi + Math.imul(ra, va) | 0, Fi = Fi + Math.imul(ra, Ba) | 0, Ti = Ti + Math.imul(gs, pa) | 0, xi = xi + Math.imul(gs, Ra) | 0, xi = xi + Math.imul(sa, pa) | 0, Fi = Fi + Math.imul(sa, Ra) | 0, Ti = Ti + Math.imul(ia, ya) | 0, xi = xi + Math.imul(ia, qa) | 0, xi = xi + Math.imul(hs, ya) | 0, Fi = Fi + Math.imul(hs, qa) | 0, Ti = Ti + Math.imul(ds, Ia) | 0, xi = xi + Math.imul(ds, Fa) | 0, xi = xi + Math.imul(ps, Ia) | 0, Fi = Fi + Math.imul(ps, Fa) | 0;
      var xo = (Ni + Ti | 0) + ((xi & 8191) << 13) | 0;
      Ni = (Fi + (xi >>> 13) | 0) + (xo >>> 26) | 0, xo &= 67108863, Ti = Math.imul(Zi, ha), xi = Math.imul(Zi, Ma), xi = xi + Math.imul(Ui, ha) | 0, Fi = Math.imul(Ui, Ma), Ti = Ti + Math.imul(ta, va) | 0, xi = xi + Math.imul(ta, Ba) | 0, xi = xi + Math.imul(oa, va) | 0, Fi = Fi + Math.imul(oa, Ba) | 0, Ti = Ti + Math.imul(Ds, pa) | 0, xi = xi + Math.imul(Ds, Ra) | 0, xi = xi + Math.imul(ra, pa) | 0, Fi = Fi + Math.imul(ra, Ra) | 0, Ti = Ti + Math.imul(gs, ya) | 0, xi = xi + Math.imul(gs, qa) | 0, xi = xi + Math.imul(sa, ya) | 0, Fi = Fi + Math.imul(sa, qa) | 0, Ti = Ti + Math.imul(ia, Ia) | 0, xi = xi + Math.imul(ia, Fa) | 0, xi = xi + Math.imul(hs, Ia) | 0, Fi = Fi + Math.imul(hs, Fa) | 0;
      var So = (Ni + Ti | 0) + ((xi & 8191) << 13) | 0;
      Ni = (Fi + (xi >>> 13) | 0) + (So >>> 26) | 0, So &= 67108863, Ti = Math.imul(Zi, va), xi = Math.imul(Zi, Ba), xi = xi + Math.imul(Ui, va) | 0, Fi = Math.imul(Ui, Ba), Ti = Ti + Math.imul(ta, pa) | 0, xi = xi + Math.imul(ta, Ra) | 0, xi = xi + Math.imul(oa, pa) | 0, Fi = Fi + Math.imul(oa, Ra) | 0, Ti = Ti + Math.imul(Ds, ya) | 0, xi = xi + Math.imul(Ds, qa) | 0, xi = xi + Math.imul(ra, ya) | 0, Fi = Fi + Math.imul(ra, qa) | 0, Ti = Ti + Math.imul(gs, Ia) | 0, xi = xi + Math.imul(gs, Fa) | 0, xi = xi + Math.imul(sa, Ia) | 0, Fi = Fi + Math.imul(sa, Fa) | 0;
      var Ha = (Ni + Ti | 0) + ((xi & 8191) << 13) | 0;
      Ni = (Fi + (xi >>> 13) | 0) + (Ha >>> 26) | 0, Ha &= 67108863, Ti = Math.imul(Zi, pa), xi = Math.imul(Zi, Ra), xi = xi + Math.imul(Ui, pa) | 0, Fi = Math.imul(Ui, Ra), Ti = Ti + Math.imul(ta, ya) | 0, xi = xi + Math.imul(ta, qa) | 0, xi = xi + Math.imul(oa, ya) | 0, Fi = Fi + Math.imul(oa, qa) | 0, Ti = Ti + Math.imul(Ds, Ia) | 0, xi = xi + Math.imul(Ds, Fa) | 0, xi = xi + Math.imul(ra, Ia) | 0, Fi = Fi + Math.imul(ra, Fa) | 0;
      var Ao = (Ni + Ti | 0) + ((xi & 8191) << 13) | 0;
      Ni = (Fi + (xi >>> 13) | 0) + (Ao >>> 26) | 0, Ao &= 67108863, Ti = Math.imul(Zi, ya), xi = Math.imul(Zi, qa), xi = xi + Math.imul(Ui, ya) | 0, Fi = Math.imul(Ui, qa), Ti = Ti + Math.imul(ta, Ia) | 0, xi = xi + Math.imul(ta, Fa) | 0, xi = xi + Math.imul(oa, Ia) | 0, Fi = Fi + Math.imul(oa, Fa) | 0;
      var Ro = (Ni + Ti | 0) + ((xi & 8191) << 13) | 0;
      Ni = (Fi + (xi >>> 13) | 0) + (Ro >>> 26) | 0, Ro &= 67108863, Ti = Math.imul(Zi, Ia), xi = Math.imul(Zi, Fa), xi = xi + Math.imul(Ui, Ia) | 0, Fi = Math.imul(Ui, Fa);
      var Io = (Ni + Ti | 0) + ((xi & 8191) << 13) | 0;
      return Ni = (Fi + (xi >>> 13) | 0) + (Io >>> 26) | 0, Io &= 67108863, qi[0] = Oa, qi[1] = Ta, qi[2] = Va, qi[3] = Ga, qi[4] = Ja, qi[5] = Xa, qi[6] = ja, qi[7] = go, qi[8] = wo, qi[9] = _o, qi[10] = Eo, qi[11] = $o, qi[12] = Za, qi[13] = xo, qi[14] = So, qi[15] = Ha, qi[16] = Ao, qi[17] = Ro, qi[18] = Io, Ni !== 0 && (qi[19] = Ni, wi.length++), wi;
    };
    Math.imul || (Ei = _i);
    function Pi(vn, Mi, Ai) {
      Ai.negative = Mi.negative ^ vn.negative, Ai.length = vn.length + Mi.length;
      for (var wi = 0, $i = 0, Li = 0; Li < Ai.length - 1; Li++) {
        var qi = $i;
        $i = 0;
        for (var Ni = wi & 67108863, Ti = Math.min(Li, Mi.length - 1), xi = Math.max(0, Li - vn.length + 1); xi <= Ti; xi++) {
          var Fi = Li - xi, Si = vn.words[Fi] | 0, Vi = Mi.words[xi] | 0, ts = Si * Vi, Hi = ts & 67108863;
          qi = qi + (ts / 67108864 | 0) | 0, Hi = Hi + Ni | 0, Ni = Hi & 67108863, qi = qi + (Hi >>> 26) | 0, $i += qi >>> 26, qi &= 67108863;
        }
        Ai.words[Li] = Ni, wi = qi, qi = $i;
      }
      return wi !== 0 ? Ai.words[Li] = wi : Ai.length--, Ai.strip();
    }
    function Ii(vn, Mi, Ai) {
      var wi = new Ci();
      return wi.mulp(vn, Mi, Ai);
    }
    Pe.prototype.mulTo = function(Mi, Ai) {
      var wi, $i = this.length + Mi.length;
      return this.length === 10 && Mi.length === 10 ? wi = Ei(this, Mi, Ai) : $i < 63 ? wi = _i(this, Mi, Ai) : $i < 1024 ? wi = Pi(this, Mi, Ai) : wi = Ii(this, Mi, Ai), wi;
    };
    function Ci(vn, Mi) {
      this.x = vn, this.y = Mi;
    }
    Ci.prototype.makeRBT = function(Mi) {
      for (var Ai = new Array(Mi), wi = Pe.prototype._countBits(Mi) - 1, $i = 0; $i < Mi; $i++)
        Ai[$i] = this.revBin($i, wi, Mi);
      return Ai;
    }, Ci.prototype.revBin = function(Mi, Ai, wi) {
      if (Mi === 0 || Mi === wi - 1) return Mi;
      for (var $i = 0, Li = 0; Li < Ai; Li++)
        $i |= (Mi & 1) << Ai - Li - 1, Mi >>= 1;
      return $i;
    }, Ci.prototype.permute = function(Mi, Ai, wi, $i, Li, qi) {
      for (var Ni = 0; Ni < qi; Ni++)
        $i[Ni] = Ai[Mi[Ni]], Li[Ni] = wi[Mi[Ni]];
    }, Ci.prototype.transform = function(Mi, Ai, wi, $i, Li, qi) {
      this.permute(qi, Mi, Ai, wi, $i, Li);
      for (var Ni = 1; Ni < Li; Ni <<= 1)
        for (var Ti = Ni << 1, xi = Math.cos(2 * Math.PI / Ti), Fi = Math.sin(2 * Math.PI / Ti), Si = 0; Si < Li; Si += Ti)
          for (var Vi = xi, ts = Fi, Hi = 0; Hi < Ni; Hi++) {
            var fn = wi[Si + Hi], Bi = $i[Si + Hi], ki = wi[Si + Hi + Ni], Ji = $i[Si + Hi + Ni], Ri = Vi * ki - ts * Ji;
            Ji = Vi * Ji + ts * ki, ki = Ri, wi[Si + Hi] = fn + ki, $i[Si + Hi] = Bi + Ji, wi[Si + Hi + Ni] = fn - ki, $i[Si + Hi + Ni] = Bi - Ji, Hi !== Ti && (Ri = xi * Vi - Fi * ts, ts = xi * ts + Fi * Vi, Vi = Ri);
          }
    }, Ci.prototype.guessLen13b = function(Mi, Ai) {
      var wi = Math.max(Ai, Mi) | 1, $i = wi & 1, Li = 0;
      for (wi = wi / 2 | 0; wi; wi = wi >>> 1)
        Li++;
      return 1 << Li + 1 + $i;
    }, Ci.prototype.conjugate = function(Mi, Ai, wi) {
      if (!(wi <= 1))
        for (var $i = 0; $i < wi / 2; $i++) {
          var Li = Mi[$i];
          Mi[$i] = Mi[wi - $i - 1], Mi[wi - $i - 1] = Li, Li = Ai[$i], Ai[$i] = -Ai[wi - $i - 1], Ai[wi - $i - 1] = -Li;
        }
    }, Ci.prototype.normalize13b = function(Mi, Ai) {
      for (var wi = 0, $i = 0; $i < Ai / 2; $i++) {
        var Li = Math.round(Mi[2 * $i + 1] / Ai) * 8192 + Math.round(Mi[2 * $i] / Ai) + wi;
        Mi[$i] = Li & 67108863, Li < 67108864 ? wi = 0 : wi = Li / 67108864 | 0;
      }
      return Mi;
    }, Ci.prototype.convert13b = function(Mi, Ai, wi, $i) {
      for (var Li = 0, qi = 0; qi < Ai; qi++)
        Li = Li + (Mi[qi] | 0), wi[2 * qi] = Li & 8191, Li = Li >>> 13, wi[2 * qi + 1] = Li & 8191, Li = Li >>> 13;
      for (qi = 2 * Ai; qi < $i; ++qi)
        wi[qi] = 0;
      Me(Li === 0), Me((Li & -8192) === 0);
    }, Ci.prototype.stub = function(Mi) {
      for (var Ai = new Array(Mi), wi = 0; wi < Mi; wi++)
        Ai[wi] = 0;
      return Ai;
    }, Ci.prototype.mulp = function(Mi, Ai, wi) {
      var $i = 2 * this.guessLen13b(Mi.length, Ai.length), Li = this.makeRBT($i), qi = this.stub($i), Ni = new Array($i), Ti = new Array($i), xi = new Array($i), Fi = new Array($i), Si = new Array($i), Vi = new Array($i), ts = wi.words;
      ts.length = $i, this.convert13b(Mi.words, Mi.length, Ni, $i), this.convert13b(Ai.words, Ai.length, Fi, $i), this.transform(Ni, qi, Ti, xi, $i, Li), this.transform(Fi, qi, Si, Vi, $i, Li);
      for (var Hi = 0; Hi < $i; Hi++) {
        var fn = Ti[Hi] * Si[Hi] - xi[Hi] * Vi[Hi];
        xi[Hi] = Ti[Hi] * Vi[Hi] + xi[Hi] * Si[Hi], Ti[Hi] = fn;
      }
      return this.conjugate(Ti, xi, $i), this.transform(Ti, xi, ts, qi, $i, Li), this.conjugate(ts, qi, $i), this.normalize13b(ts, $i), wi.negative = Mi.negative ^ Ai.negative, wi.length = Mi.length + Ai.length, wi.strip();
    }, Pe.prototype.mul = function(Mi) {
      var Ai = new Pe(null);
      return Ai.words = new Array(this.length + Mi.length), this.mulTo(Mi, Ai);
    }, Pe.prototype.mulf = function(Mi) {
      var Ai = new Pe(null);
      return Ai.words = new Array(this.length + Mi.length), Ii(this, Mi, Ai);
    }, Pe.prototype.imul = function(Mi) {
      return this.clone().mulTo(Mi, this);
    }, Pe.prototype.imuln = function(Mi) {
      Me(typeof Mi == "number"), Me(Mi < 67108864);
      for (var Ai = 0, wi = 0; wi < this.length; wi++) {
        var $i = (this.words[wi] | 0) * Mi, Li = ($i & 67108863) + (Ai & 67108863);
        Ai >>= 26, Ai += $i / 67108864 | 0, Ai += Li >>> 26, this.words[wi] = Li & 67108863;
      }
      return Ai !== 0 && (this.words[wi] = Ai, this.length++), this;
    }, Pe.prototype.muln = function(Mi) {
      return this.clone().imuln(Mi);
    }, Pe.prototype.sqr = function() {
      return this.mul(this);
    }, Pe.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Pe.prototype.pow = function(Mi) {
      var Ai = mi(Mi);
      if (Ai.length === 0) return new Pe(1);
      for (var wi = this, $i = 0; $i < Ai.length && Ai[$i] === 0; $i++, wi = wi.sqr())
        ;
      if (++$i < Ai.length)
        for (var Li = wi.sqr(); $i < Ai.length; $i++, Li = Li.sqr())
          Ai[$i] !== 0 && (wi = wi.mul(Li));
      return wi;
    }, Pe.prototype.iushln = function(Mi) {
      Me(typeof Mi == "number" && Mi >= 0);
      var Ai = Mi % 26, wi = (Mi - Ai) / 26, $i = 67108863 >>> 26 - Ai << 26 - Ai, Li;
      if (Ai !== 0) {
        var qi = 0;
        for (Li = 0; Li < this.length; Li++) {
          var Ni = this.words[Li] & $i, Ti = (this.words[Li] | 0) - Ni << Ai;
          this.words[Li] = Ti | qi, qi = Ni >>> 26 - Ai;
        }
        qi && (this.words[Li] = qi, this.length++);
      }
      if (wi !== 0) {
        for (Li = this.length - 1; Li >= 0; Li--)
          this.words[Li + wi] = this.words[Li];
        for (Li = 0; Li < wi; Li++)
          this.words[Li] = 0;
        this.length += wi;
      }
      return this.strip();
    }, Pe.prototype.ishln = function(Mi) {
      return Me(this.negative === 0), this.iushln(Mi);
    }, Pe.prototype.iushrn = function(Mi, Ai, wi) {
      Me(typeof Mi == "number" && Mi >= 0);
      var $i;
      Ai ? $i = (Ai - Ai % 26) / 26 : $i = 0;
      var Li = Mi % 26, qi = Math.min((Mi - Li) / 26, this.length), Ni = 67108863 ^ 67108863 >>> Li << Li, Ti = wi;
      if ($i -= qi, $i = Math.max(0, $i), Ti) {
        for (var xi = 0; xi < qi; xi++)
          Ti.words[xi] = this.words[xi];
        Ti.length = qi;
      }
      if (qi !== 0) if (this.length > qi)
        for (this.length -= qi, xi = 0; xi < this.length; xi++)
          this.words[xi] = this.words[xi + qi];
      else
        this.words[0] = 0, this.length = 1;
      var Fi = 0;
      for (xi = this.length - 1; xi >= 0 && (Fi !== 0 || xi >= $i); xi--) {
        var Si = this.words[xi] | 0;
        this.words[xi] = Fi << 26 - Li | Si >>> Li, Fi = Si & Ni;
      }
      return Ti && Fi !== 0 && (Ti.words[Ti.length++] = Fi), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, Pe.prototype.ishrn = function(Mi, Ai, wi) {
      return Me(this.negative === 0), this.iushrn(Mi, Ai, wi);
    }, Pe.prototype.shln = function(Mi) {
      return this.clone().ishln(Mi);
    }, Pe.prototype.ushln = function(Mi) {
      return this.clone().iushln(Mi);
    }, Pe.prototype.shrn = function(Mi) {
      return this.clone().ishrn(Mi);
    }, Pe.prototype.ushrn = function(Mi) {
      return this.clone().iushrn(Mi);
    }, Pe.prototype.testn = function(Mi) {
      Me(typeof Mi == "number" && Mi >= 0);
      var Ai = Mi % 26, wi = (Mi - Ai) / 26, $i = 1 << Ai;
      if (this.length <= wi) return !1;
      var Li = this.words[wi];
      return !!(Li & $i);
    }, Pe.prototype.imaskn = function(Mi) {
      Me(typeof Mi == "number" && Mi >= 0);
      var Ai = Mi % 26, wi = (Mi - Ai) / 26;
      if (Me(this.negative === 0, "imaskn works only with positive numbers"), this.length <= wi)
        return this;
      if (Ai !== 0 && wi++, this.length = Math.min(wi, this.length), Ai !== 0) {
        var $i = 67108863 ^ 67108863 >>> Ai << Ai;
        this.words[this.length - 1] &= $i;
      }
      return this.strip();
    }, Pe.prototype.maskn = function(Mi) {
      return this.clone().imaskn(Mi);
    }, Pe.prototype.iaddn = function(Mi) {
      return Me(typeof Mi == "number"), Me(Mi < 67108864), Mi < 0 ? this.isubn(-Mi) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < Mi ? (this.words[0] = Mi - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(Mi), this.negative = 1, this) : this._iaddn(Mi);
    }, Pe.prototype._iaddn = function(Mi) {
      this.words[0] += Mi;
      for (var Ai = 0; Ai < this.length && this.words[Ai] >= 67108864; Ai++)
        this.words[Ai] -= 67108864, Ai === this.length - 1 ? this.words[Ai + 1] = 1 : this.words[Ai + 1]++;
      return this.length = Math.max(this.length, Ai + 1), this;
    }, Pe.prototype.isubn = function(Mi) {
      if (Me(typeof Mi == "number"), Me(Mi < 67108864), Mi < 0) return this.iaddn(-Mi);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(Mi), this.negative = 1, this;
      if (this.words[0] -= Mi, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var Ai = 0; Ai < this.length && this.words[Ai] < 0; Ai++)
          this.words[Ai] += 67108864, this.words[Ai + 1] -= 1;
      return this.strip();
    }, Pe.prototype.addn = function(Mi) {
      return this.clone().iaddn(Mi);
    }, Pe.prototype.subn = function(Mi) {
      return this.clone().isubn(Mi);
    }, Pe.prototype.iabs = function() {
      return this.negative = 0, this;
    }, Pe.prototype.abs = function() {
      return this.clone().iabs();
    }, Pe.prototype._ishlnsubmul = function(Mi, Ai, wi) {
      var $i = Mi.length + wi, Li;
      this._expand($i);
      var qi, Ni = 0;
      for (Li = 0; Li < Mi.length; Li++) {
        qi = (this.words[Li + wi] | 0) + Ni;
        var Ti = (Mi.words[Li] | 0) * Ai;
        qi -= Ti & 67108863, Ni = (qi >> 26) - (Ti / 67108864 | 0), this.words[Li + wi] = qi & 67108863;
      }
      for (; Li < this.length - wi; Li++)
        qi = (this.words[Li + wi] | 0) + Ni, Ni = qi >> 26, this.words[Li + wi] = qi & 67108863;
      if (Ni === 0) return this.strip();
      for (Me(Ni === -1), Ni = 0, Li = 0; Li < this.length; Li++)
        qi = -(this.words[Li] | 0) + Ni, Ni = qi >> 26, this.words[Li] = qi & 67108863;
      return this.negative = 1, this.strip();
    }, Pe.prototype._wordDiv = function(Mi, Ai) {
      var wi = this.length - Mi.length, $i = this.clone(), Li = Mi, qi = Li.words[Li.length - 1] | 0, Ni = this._countBits(qi);
      wi = 26 - Ni, wi !== 0 && (Li = Li.ushln(wi), $i.iushln(wi), qi = Li.words[Li.length - 1] | 0);
      var Ti = $i.length - Li.length, xi;
      if (Ai !== "mod") {
        xi = new Pe(null), xi.length = Ti + 1, xi.words = new Array(xi.length);
        for (var Fi = 0; Fi < xi.length; Fi++)
          xi.words[Fi] = 0;
      }
      var Si = $i.clone()._ishlnsubmul(Li, 1, Ti);
      Si.negative === 0 && ($i = Si, xi && (xi.words[Ti] = 1));
      for (var Vi = Ti - 1; Vi >= 0; Vi--) {
        var ts = ($i.words[Li.length + Vi] | 0) * 67108864 + ($i.words[Li.length + Vi - 1] | 0);
        for (ts = Math.min(ts / qi | 0, 67108863), $i._ishlnsubmul(Li, ts, Vi); $i.negative !== 0; )
          ts--, $i.negative = 0, $i._ishlnsubmul(Li, 1, Vi), $i.isZero() || ($i.negative ^= 1);
        xi && (xi.words[Vi] = ts);
      }
      return xi && xi.strip(), $i.strip(), Ai !== "div" && wi !== 0 && $i.iushrn(wi), {
        div: xi || null,
        mod: $i
      };
    }, Pe.prototype.divmod = function(Mi, Ai, wi) {
      if (Me(!Mi.isZero()), this.isZero())
        return {
          div: new Pe(0),
          mod: new Pe(0)
        };
      var $i, Li, qi;
      return this.negative !== 0 && Mi.negative === 0 ? (qi = this.neg().divmod(Mi, Ai), Ai !== "mod" && ($i = qi.div.neg()), Ai !== "div" && (Li = qi.mod.neg(), wi && Li.negative !== 0 && Li.iadd(Mi)), {
        div: $i,
        mod: Li
      }) : this.negative === 0 && Mi.negative !== 0 ? (qi = this.divmod(Mi.neg(), Ai), Ai !== "mod" && ($i = qi.div.neg()), {
        div: $i,
        mod: qi.mod
      }) : this.negative & Mi.negative ? (qi = this.neg().divmod(Mi.neg(), Ai), Ai !== "div" && (Li = qi.mod.neg(), wi && Li.negative !== 0 && Li.isub(Mi)), {
        div: qi.div,
        mod: Li
      }) : Mi.length > this.length || this.cmp(Mi) < 0 ? {
        div: new Pe(0),
        mod: this
      } : Mi.length === 1 ? Ai === "div" ? {
        div: this.divn(Mi.words[0]),
        mod: null
      } : Ai === "mod" ? {
        div: null,
        mod: new Pe(this.modn(Mi.words[0]))
      } : {
        div: this.divn(Mi.words[0]),
        mod: new Pe(this.modn(Mi.words[0]))
      } : this._wordDiv(Mi, Ai);
    }, Pe.prototype.div = function(Mi) {
      return this.divmod(Mi, "div", !1).div;
    }, Pe.prototype.mod = function(Mi) {
      return this.divmod(Mi, "mod", !1).mod;
    }, Pe.prototype.umod = function(Mi) {
      return this.divmod(Mi, "mod", !0).mod;
    }, Pe.prototype.divRound = function(Mi) {
      var Ai = this.divmod(Mi);
      if (Ai.mod.isZero()) return Ai.div;
      var wi = Ai.div.negative !== 0 ? Ai.mod.isub(Mi) : Ai.mod, $i = Mi.ushrn(1), Li = Mi.andln(1), qi = wi.cmp($i);
      return qi < 0 || Li === 1 && qi === 0 ? Ai.div : Ai.div.negative !== 0 ? Ai.div.isubn(1) : Ai.div.iaddn(1);
    }, Pe.prototype.modn = function(Mi) {
      Me(Mi <= 67108863);
      for (var Ai = (1 << 26) % Mi, wi = 0, $i = this.length - 1; $i >= 0; $i--)
        wi = (Ai * wi + (this.words[$i] | 0)) % Mi;
      return wi;
    }, Pe.prototype.idivn = function(Mi) {
      Me(Mi <= 67108863);
      for (var Ai = 0, wi = this.length - 1; wi >= 0; wi--) {
        var $i = (this.words[wi] | 0) + Ai * 67108864;
        this.words[wi] = $i / Mi | 0, Ai = $i % Mi;
      }
      return this.strip();
    }, Pe.prototype.divn = function(Mi) {
      return this.clone().idivn(Mi);
    }, Pe.prototype.egcd = function(Mi) {
      Me(Mi.negative === 0), Me(!Mi.isZero());
      var Ai = this, wi = Mi.clone();
      Ai.negative !== 0 ? Ai = Ai.umod(Mi) : Ai = Ai.clone();
      for (var $i = new Pe(1), Li = new Pe(0), qi = new Pe(0), Ni = new Pe(1), Ti = 0; Ai.isEven() && wi.isEven(); )
        Ai.iushrn(1), wi.iushrn(1), ++Ti;
      for (var xi = wi.clone(), Fi = Ai.clone(); !Ai.isZero(); ) {
        for (var Si = 0, Vi = 1; !(Ai.words[0] & Vi) && Si < 26; ++Si, Vi <<= 1) ;
        if (Si > 0)
          for (Ai.iushrn(Si); Si-- > 0; )
            ($i.isOdd() || Li.isOdd()) && ($i.iadd(xi), Li.isub(Fi)), $i.iushrn(1), Li.iushrn(1);
        for (var ts = 0, Hi = 1; !(wi.words[0] & Hi) && ts < 26; ++ts, Hi <<= 1) ;
        if (ts > 0)
          for (wi.iushrn(ts); ts-- > 0; )
            (qi.isOdd() || Ni.isOdd()) && (qi.iadd(xi), Ni.isub(Fi)), qi.iushrn(1), Ni.iushrn(1);
        Ai.cmp(wi) >= 0 ? (Ai.isub(wi), $i.isub(qi), Li.isub(Ni)) : (wi.isub(Ai), qi.isub($i), Ni.isub(Li));
      }
      return {
        a: qi,
        b: Ni,
        gcd: wi.iushln(Ti)
      };
    }, Pe.prototype._invmp = function(Mi) {
      Me(Mi.negative === 0), Me(!Mi.isZero());
      var Ai = this, wi = Mi.clone();
      Ai.negative !== 0 ? Ai = Ai.umod(Mi) : Ai = Ai.clone();
      for (var $i = new Pe(1), Li = new Pe(0), qi = wi.clone(); Ai.cmpn(1) > 0 && wi.cmpn(1) > 0; ) {
        for (var Ni = 0, Ti = 1; !(Ai.words[0] & Ti) && Ni < 26; ++Ni, Ti <<= 1) ;
        if (Ni > 0)
          for (Ai.iushrn(Ni); Ni-- > 0; )
            $i.isOdd() && $i.iadd(qi), $i.iushrn(1);
        for (var xi = 0, Fi = 1; !(wi.words[0] & Fi) && xi < 26; ++xi, Fi <<= 1) ;
        if (xi > 0)
          for (wi.iushrn(xi); xi-- > 0; )
            Li.isOdd() && Li.iadd(qi), Li.iushrn(1);
        Ai.cmp(wi) >= 0 ? (Ai.isub(wi), $i.isub(Li)) : (wi.isub(Ai), Li.isub($i));
      }
      var Si;
      return Ai.cmpn(1) === 0 ? Si = $i : Si = Li, Si.cmpn(0) < 0 && Si.iadd(Mi), Si;
    }, Pe.prototype.gcd = function(Mi) {
      if (this.isZero()) return Mi.abs();
      if (Mi.isZero()) return this.abs();
      var Ai = this.clone(), wi = Mi.clone();
      Ai.negative = 0, wi.negative = 0;
      for (var $i = 0; Ai.isEven() && wi.isEven(); $i++)
        Ai.iushrn(1), wi.iushrn(1);
      do {
        for (; Ai.isEven(); )
          Ai.iushrn(1);
        for (; wi.isEven(); )
          wi.iushrn(1);
        var Li = Ai.cmp(wi);
        if (Li < 0) {
          var qi = Ai;
          Ai = wi, wi = qi;
        } else if (Li === 0 || wi.cmpn(1) === 0)
          break;
        Ai.isub(wi);
      } while (!0);
      return wi.iushln($i);
    }, Pe.prototype.invm = function(Mi) {
      return this.egcd(Mi).a.umod(Mi);
    }, Pe.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, Pe.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, Pe.prototype.andln = function(Mi) {
      return this.words[0] & Mi;
    }, Pe.prototype.bincn = function(Mi) {
      Me(typeof Mi == "number");
      var Ai = Mi % 26, wi = (Mi - Ai) / 26, $i = 1 << Ai;
      if (this.length <= wi)
        return this._expand(wi + 1), this.words[wi] |= $i, this;
      for (var Li = $i, qi = wi; Li !== 0 && qi < this.length; qi++) {
        var Ni = this.words[qi] | 0;
        Ni += Li, Li = Ni >>> 26, Ni &= 67108863, this.words[qi] = Ni;
      }
      return Li !== 0 && (this.words[qi] = Li, this.length++), this;
    }, Pe.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, Pe.prototype.cmpn = function(Mi) {
      var Ai = Mi < 0;
      if (this.negative !== 0 && !Ai) return -1;
      if (this.negative === 0 && Ai) return 1;
      this.strip();
      var wi;
      if (this.length > 1)
        wi = 1;
      else {
        Ai && (Mi = -Mi), Me(Mi <= 67108863, "Number is too big");
        var $i = this.words[0] | 0;
        wi = $i === Mi ? 0 : $i < Mi ? -1 : 1;
      }
      return this.negative !== 0 ? -wi | 0 : wi;
    }, Pe.prototype.cmp = function(Mi) {
      if (this.negative !== 0 && Mi.negative === 0) return -1;
      if (this.negative === 0 && Mi.negative !== 0) return 1;
      var Ai = this.ucmp(Mi);
      return this.negative !== 0 ? -Ai | 0 : Ai;
    }, Pe.prototype.ucmp = function(Mi) {
      if (this.length > Mi.length) return 1;
      if (this.length < Mi.length) return -1;
      for (var Ai = 0, wi = this.length - 1; wi >= 0; wi--) {
        var $i = this.words[wi] | 0, Li = Mi.words[wi] | 0;
        if ($i !== Li) {
          $i < Li ? Ai = -1 : $i > Li && (Ai = 1);
          break;
        }
      }
      return Ai;
    }, Pe.prototype.gtn = function(Mi) {
      return this.cmpn(Mi) === 1;
    }, Pe.prototype.gt = function(Mi) {
      return this.cmp(Mi) === 1;
    }, Pe.prototype.gten = function(Mi) {
      return this.cmpn(Mi) >= 0;
    }, Pe.prototype.gte = function(Mi) {
      return this.cmp(Mi) >= 0;
    }, Pe.prototype.ltn = function(Mi) {
      return this.cmpn(Mi) === -1;
    }, Pe.prototype.lt = function(Mi) {
      return this.cmp(Mi) === -1;
    }, Pe.prototype.lten = function(Mi) {
      return this.cmpn(Mi) <= 0;
    }, Pe.prototype.lte = function(Mi) {
      return this.cmp(Mi) <= 0;
    }, Pe.prototype.eqn = function(Mi) {
      return this.cmpn(Mi) === 0;
    }, Pe.prototype.eq = function(Mi) {
      return this.cmp(Mi) === 0;
    }, Pe.red = function(Mi) {
      return new ns(Mi);
    }, Pe.prototype.toRed = function(Mi) {
      return Me(!this.red, "Already a number in reduction context"), Me(this.negative === 0, "red works only with positives"), Mi.convertTo(this)._forceRed(Mi);
    }, Pe.prototype.fromRed = function() {
      return Me(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, Pe.prototype._forceRed = function(Mi) {
      return this.red = Mi, this;
    }, Pe.prototype.forceRed = function(Mi) {
      return Me(!this.red, "Already a number in reduction context"), this._forceRed(Mi);
    }, Pe.prototype.redAdd = function(Mi) {
      return Me(this.red, "redAdd works only with red numbers"), this.red.add(this, Mi);
    }, Pe.prototype.redIAdd = function(Mi) {
      return Me(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, Mi);
    }, Pe.prototype.redSub = function(Mi) {
      return Me(this.red, "redSub works only with red numbers"), this.red.sub(this, Mi);
    }, Pe.prototype.redISub = function(Mi) {
      return Me(this.red, "redISub works only with red numbers"), this.red.isub(this, Mi);
    }, Pe.prototype.redShl = function(Mi) {
      return Me(this.red, "redShl works only with red numbers"), this.red.shl(this, Mi);
    }, Pe.prototype.redMul = function(Mi) {
      return Me(this.red, "redMul works only with red numbers"), this.red._verify2(this, Mi), this.red.mul(this, Mi);
    }, Pe.prototype.redIMul = function(Mi) {
      return Me(this.red, "redMul works only with red numbers"), this.red._verify2(this, Mi), this.red.imul(this, Mi);
    }, Pe.prototype.redSqr = function() {
      return Me(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, Pe.prototype.redISqr = function() {
      return Me(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, Pe.prototype.redSqrt = function() {
      return Me(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, Pe.prototype.redInvm = function() {
      return Me(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, Pe.prototype.redNeg = function() {
      return Me(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, Pe.prototype.redPow = function(Mi) {
      return Me(this.red && !Mi.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, Mi);
    };
    var Wi = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function zi(vn, Mi) {
      this.name = vn, this.p = new Pe(Mi, 16), this.n = this.p.bitLength(), this.k = new Pe(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    zi.prototype._tmp = function() {
      var Mi = new Pe(null);
      return Mi.words = new Array(Math.ceil(this.n / 13)), Mi;
    }, zi.prototype.ireduce = function(Mi) {
      var Ai = Mi, wi;
      do
        this.split(Ai, this.tmp), Ai = this.imulK(Ai), Ai = Ai.iadd(this.tmp), wi = Ai.bitLength();
      while (wi > this.n);
      var $i = wi < this.n ? -1 : Ai.ucmp(this.p);
      return $i === 0 ? (Ai.words[0] = 0, Ai.length = 1) : $i > 0 ? Ai.isub(this.p) : Ai.strip !== void 0 ? Ai.strip() : Ai._strip(), Ai;
    }, zi.prototype.split = function(Mi, Ai) {
      Mi.iushrn(this.n, 0, Ai);
    }, zi.prototype.imulK = function(Mi) {
      return Mi.imul(this.k);
    };
    function Xi() {
      zi.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    Be(Xi, zi), Xi.prototype.split = function(Mi, Ai) {
      for (var wi = 4194303, $i = Math.min(Mi.length, 9), Li = 0; Li < $i; Li++)
        Ai.words[Li] = Mi.words[Li];
      if (Ai.length = $i, Mi.length <= 9) {
        Mi.words[0] = 0, Mi.length = 1;
        return;
      }
      var qi = Mi.words[9];
      for (Ai.words[Ai.length++] = qi & wi, Li = 10; Li < Mi.length; Li++) {
        var Ni = Mi.words[Li] | 0;
        Mi.words[Li - 10] = (Ni & wi) << 4 | qi >>> 22, qi = Ni;
      }
      qi >>>= 22, Mi.words[Li - 10] = qi, qi === 0 && Mi.length > 10 ? Mi.length -= 10 : Mi.length -= 9;
    }, Xi.prototype.imulK = function(Mi) {
      Mi.words[Mi.length] = 0, Mi.words[Mi.length + 1] = 0, Mi.length += 2;
      for (var Ai = 0, wi = 0; wi < Mi.length; wi++) {
        var $i = Mi.words[wi] | 0;
        Ai += $i * 977, Mi.words[wi] = Ai & 67108863, Ai = $i * 64 + (Ai / 67108864 | 0);
      }
      return Mi.words[Mi.length - 1] === 0 && (Mi.length--, Mi.words[Mi.length - 1] === 0 && Mi.length--), Mi;
    };
    function Qi() {
      zi.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    Be(Qi, zi);
    function Oi() {
      zi.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    Be(Oi, zi);
    function Yi() {
      zi.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    Be(Yi, zi), Yi.prototype.imulK = function(Mi) {
      for (var Ai = 0, wi = 0; wi < Mi.length; wi++) {
        var $i = (Mi.words[wi] | 0) * 19 + Ai, Li = $i & 67108863;
        $i >>>= 26, Mi.words[wi] = Li, Ai = $i;
      }
      return Ai !== 0 && (Mi.words[Mi.length++] = Ai), Mi;
    }, Pe._prime = function(Mi) {
      if (Wi[Mi]) return Wi[Mi];
      var Ai;
      if (Mi === "k256")
        Ai = new Xi();
      else if (Mi === "p224")
        Ai = new Qi();
      else if (Mi === "p192")
        Ai = new Oi();
      else if (Mi === "p25519")
        Ai = new Yi();
      else
        throw new Error("Unknown prime " + Mi);
      return Wi[Mi] = Ai, Ai;
    };
    function ns(vn) {
      if (typeof vn == "string") {
        var Mi = Pe._prime(vn);
        this.m = Mi.p, this.prime = Mi;
      } else
        Me(vn.gtn(1), "modulus must be greater than 1"), this.m = vn, this.prime = null;
    }
    ns.prototype._verify1 = function(Mi) {
      Me(Mi.negative === 0, "red works only with positives"), Me(Mi.red, "red works only with red numbers");
    }, ns.prototype._verify2 = function(Mi, Ai) {
      Me((Mi.negative | Ai.negative) === 0, "red works only with positives"), Me(
        Mi.red && Mi.red === Ai.red,
        "red works only with red numbers"
      );
    }, ns.prototype.imod = function(Mi) {
      return this.prime ? this.prime.ireduce(Mi)._forceRed(this) : Mi.umod(this.m)._forceRed(this);
    }, ns.prototype.neg = function(Mi) {
      return Mi.isZero() ? Mi.clone() : this.m.sub(Mi)._forceRed(this);
    }, ns.prototype.add = function(Mi, Ai) {
      this._verify2(Mi, Ai);
      var wi = Mi.add(Ai);
      return wi.cmp(this.m) >= 0 && wi.isub(this.m), wi._forceRed(this);
    }, ns.prototype.iadd = function(Mi, Ai) {
      this._verify2(Mi, Ai);
      var wi = Mi.iadd(Ai);
      return wi.cmp(this.m) >= 0 && wi.isub(this.m), wi;
    }, ns.prototype.sub = function(Mi, Ai) {
      this._verify2(Mi, Ai);
      var wi = Mi.sub(Ai);
      return wi.cmpn(0) < 0 && wi.iadd(this.m), wi._forceRed(this);
    }, ns.prototype.isub = function(Mi, Ai) {
      this._verify2(Mi, Ai);
      var wi = Mi.isub(Ai);
      return wi.cmpn(0) < 0 && wi.iadd(this.m), wi;
    }, ns.prototype.shl = function(Mi, Ai) {
      return this._verify1(Mi), this.imod(Mi.ushln(Ai));
    }, ns.prototype.imul = function(Mi, Ai) {
      return this._verify2(Mi, Ai), this.imod(Mi.imul(Ai));
    }, ns.prototype.mul = function(Mi, Ai) {
      return this._verify2(Mi, Ai), this.imod(Mi.mul(Ai));
    }, ns.prototype.isqr = function(Mi) {
      return this.imul(Mi, Mi.clone());
    }, ns.prototype.sqr = function(Mi) {
      return this.mul(Mi, Mi);
    }, ns.prototype.sqrt = function(Mi) {
      if (Mi.isZero()) return Mi.clone();
      var Ai = this.m.andln(3);
      if (Me(Ai % 2 === 1), Ai === 3) {
        var wi = this.m.add(new Pe(1)).iushrn(2);
        return this.pow(Mi, wi);
      }
      for (var $i = this.m.subn(1), Li = 0; !$i.isZero() && $i.andln(1) === 0; )
        Li++, $i.iushrn(1);
      Me(!$i.isZero());
      var qi = new Pe(1).toRed(this), Ni = qi.redNeg(), Ti = this.m.subn(1).iushrn(1), xi = this.m.bitLength();
      for (xi = new Pe(2 * xi * xi).toRed(this); this.pow(xi, Ti).cmp(Ni) !== 0; )
        xi.redIAdd(Ni);
      for (var Fi = this.pow(xi, $i), Si = this.pow(Mi, $i.addn(1).iushrn(1)), Vi = this.pow(Mi, $i), ts = Li; Vi.cmp(qi) !== 0; ) {
        for (var Hi = Vi, fn = 0; Hi.cmp(qi) !== 0; fn++)
          Hi = Hi.redSqr();
        Me(fn < ts);
        var Bi = this.pow(Fi, new Pe(1).iushln(ts - fn - 1));
        Si = Si.redMul(Bi), Fi = Bi.redSqr(), Vi = Vi.redMul(Fi), ts = fn;
      }
      return Si;
    }, ns.prototype.invm = function(Mi) {
      var Ai = Mi._invmp(this.m);
      return Ai.negative !== 0 ? (Ai.negative = 0, this.imod(Ai).redNeg()) : this.imod(Ai);
    }, ns.prototype.pow = function(Mi, Ai) {
      if (Ai.isZero()) return new Pe(1).toRed(this);
      if (Ai.cmpn(1) === 0) return Mi.clone();
      var wi = 4, $i = new Array(1 << wi);
      $i[0] = new Pe(1).toRed(this), $i[1] = Mi;
      for (var Li = 2; Li < $i.length; Li++)
        $i[Li] = this.mul($i[Li - 1], Mi);
      var qi = $i[0], Ni = 0, Ti = 0, xi = Ai.bitLength() % 26;
      for (xi === 0 && (xi = 26), Li = Ai.length - 1; Li >= 0; Li--) {
        for (var Fi = Ai.words[Li], Si = xi - 1; Si >= 0; Si--) {
          var Vi = Fi >> Si & 1;
          if (qi !== $i[0] && (qi = this.sqr(qi)), Vi === 0 && Ni === 0) {
            Ti = 0;
            continue;
          }
          Ni <<= 1, Ni |= Vi, Ti++, !(Ti !== wi && (Li !== 0 || Si !== 0)) && (qi = this.mul(qi, $i[Ni]), Ti = 0, Ni = 0);
        }
        xi = 26;
      }
      return qi;
    }, ns.prototype.convertTo = function(Mi) {
      var Ai = Mi.umod(this.m);
      return Ai === Mi ? Ai.clone() : Ai;
    }, ns.prototype.convertFrom = function(Mi) {
      var Ai = Mi.clone();
      return Ai.red = null, Ai;
    }, Pe.mont = function(Mi) {
      return new ls(Mi);
    };
    function ls(vn) {
      ns.call(this, vn), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new Pe(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    Be(ls, ns), ls.prototype.convertTo = function(Mi) {
      return this.imod(Mi.ushln(this.shift));
    }, ls.prototype.convertFrom = function(Mi) {
      var Ai = this.imod(Mi.mul(this.rinv));
      return Ai.red = null, Ai;
    }, ls.prototype.imul = function(Mi, Ai) {
      if (Mi.isZero() || Ai.isZero())
        return Mi.words[0] = 0, Mi.length = 1, Mi;
      var wi = Mi.imul(Ai), $i = wi.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Li = wi.isub($i).iushrn(this.shift), qi = Li;
      return Li.cmp(this.m) >= 0 ? qi = Li.isub(this.m) : Li.cmpn(0) < 0 && (qi = Li.iadd(this.m)), qi._forceRed(this);
    }, ls.prototype.mul = function(Mi, Ai) {
      if (Mi.isZero() || Ai.isZero()) return new Pe(0)._forceRed(this);
      var wi = Mi.mul(Ai), $i = wi.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Li = wi.isub($i).iushrn(this.shift), qi = Li;
      return Li.cmp(this.m) >= 0 ? qi = Li.isub(this.m) : Li.cmpn(0) < 0 && (qi = Li.iadd(this.m)), qi._forceRed(this);
    }, ls.prototype.invm = function(Mi) {
      var Ai = this.imod(Mi._invmp(this.m).mul(this.r2));
      return Ai._forceRed(this);
    };
  })(Ae, commonjsGlobal);
})(bn$3);
var bnExports$1 = bn$3.exports, brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var Ae;
  brorand.exports = function(Be) {
    return Ae || (Ae = new t(null)), Ae.generate(Be);
  };
  function t(Me) {
    this.rand = Me;
  }
  if (brorand.exports.Rand = t, t.prototype.generate = function(Be) {
    return this._rand(Be);
  }, t.prototype._rand = function(Be) {
    if (this.rand.getBytes)
      return this.rand.getBytes(Be);
    for (var Pe = new Uint8Array(Be), Te = 0; Te < Pe.length; Te++)
      Pe[Te] = this.rand.getByte();
    return Pe;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? t.prototype._rand = function(Be) {
      var Pe = new Uint8Array(Be);
      return self.crypto.getRandomValues(Pe), Pe;
    } : self.msCrypto && self.msCrypto.getRandomValues ? t.prototype._rand = function(Be) {
      var Pe = new Uint8Array(Be);
      return self.msCrypto.getRandomValues(Pe), Pe;
    } : typeof window == "object" && (t.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var Ie = requireCryptoBrowserify();
      if (typeof Ie.randomBytes != "function")
        throw new Error("Not supported");
      t.prototype._rand = function(Be) {
        return Ie.randomBytes(Be);
      };
    } catch {
    }
  return brorand.exports;
}
var mr$3, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr$3;
  hasRequiredMr = 1;
  var Ae = bnExports$1, t = requireBrorand();
  function Ie(Me) {
    this.rand = Me || new t.Rand();
  }
  return mr$3 = Ie, Ie.create = function(Be) {
    return new Ie(Be);
  }, Ie.prototype._randbelow = function(Be) {
    var Pe = Be.bitLength(), Te = Math.ceil(Pe / 8);
    do
      var je = new Ae(this.rand.generate(Te));
    while (je.cmp(Be) >= 0);
    return je;
  }, Ie.prototype._randrange = function(Be, Pe) {
    var Te = Pe.sub(Be);
    return Be.add(this._randbelow(Te));
  }, Ie.prototype.test = function(Be, Pe, Te) {
    var je = Be.bitLength(), Ve = Ae.mont(Be), fi = new Ae(1).toRed(Ve);
    Pe || (Pe = Math.max(1, je / 48 | 0));
    for (var Ue = Be.subn(1), bi = 0; !Ue.testn(bi); bi++)
      ;
    for (var vi = Be.shrn(bi), mi = Ue.toRed(Ve), _i = !0; Pe > 0; Pe--) {
      var Ei = this._randrange(new Ae(2), Ue);
      Te && Te(Ei);
      var Pi = Ei.toRed(Ve).redPow(vi);
      if (!(Pi.cmp(fi) === 0 || Pi.cmp(mi) === 0)) {
        for (var Ii = 1; Ii < bi; Ii++) {
          if (Pi = Pi.redSqr(), Pi.cmp(fi) === 0)
            return !1;
          if (Pi.cmp(mi) === 0)
            break;
        }
        if (Ii === bi)
          return !1;
      }
    }
    return _i;
  }, Ie.prototype.getDivisor = function(Be, Pe) {
    var Te = Be.bitLength(), je = Ae.mont(Be), Ve = new Ae(1).toRed(je);
    Pe || (Pe = Math.max(1, Te / 48 | 0));
    for (var fi = Be.subn(1), Ue = 0; !fi.testn(Ue); Ue++)
      ;
    for (var bi = Be.shrn(Ue), vi = fi.toRed(je); Pe > 0; Pe--) {
      var mi = this._randrange(new Ae(2), fi), _i = Be.gcd(mi);
      if (_i.cmpn(1) !== 0)
        return _i;
      var Ei = mi.toRed(je).redPow(bi);
      if (!(Ei.cmp(Ve) === 0 || Ei.cmp(vi) === 0)) {
        for (var Pi = 1; Pi < Ue; Pi++) {
          if (Ei = Ei.redSqr(), Ei.cmp(Ve) === 0)
            return Ei.fromRed().subn(1).gcd(Be);
          if (Ei.cmp(vi) === 0)
            break;
        }
        if (Pi === Ue)
          return Ei = Ei.redSqr(), Ei.fromRed().subn(1).gcd(Be);
      }
    }
    return !1;
  }, mr$3;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var Ae = requireBrowser$b();
  generatePrime = Pi, Pi.simpleSieve = _i, Pi.fermatTest = Ei;
  var t = bnExports$1, Ie = new t(24), Me = requireMr(), Be = new Me(), Pe = new t(1), Te = new t(2), je = new t(5);
  new t(16), new t(8);
  var Ve = new t(10), fi = new t(3);
  new t(7);
  var Ue = new t(11), bi = new t(4);
  new t(12);
  var vi = null;
  function mi() {
    if (vi !== null)
      return vi;
    var Ii = 1048576, Ci = [];
    Ci[0] = 2;
    for (var Wi = 1, zi = 3; zi < Ii; zi += 2) {
      for (var Xi = Math.ceil(Math.sqrt(zi)), Qi = 0; Qi < Wi && Ci[Qi] <= Xi && zi % Ci[Qi] !== 0; Qi++)
        ;
      Wi !== Qi && Ci[Qi] <= Xi || (Ci[Wi++] = zi);
    }
    return vi = Ci, Ci;
  }
  function _i(Ii) {
    for (var Ci = mi(), Wi = 0; Wi < Ci.length; Wi++)
      if (Ii.modn(Ci[Wi]) === 0)
        return Ii.cmpn(Ci[Wi]) === 0;
    return !0;
  }
  function Ei(Ii) {
    var Ci = t.mont(Ii);
    return Te.toRed(Ci).redPow(Ii.subn(1)).fromRed().cmpn(1) === 0;
  }
  function Pi(Ii, Ci) {
    if (Ii < 16)
      return Ci === 2 || Ci === 5 ? new t([140, 123]) : new t([140, 39]);
    Ci = new t(Ci);
    for (var Wi, zi; ; ) {
      for (Wi = new t(Ae(Math.ceil(Ii / 8))); Wi.bitLength() > Ii; )
        Wi.ishrn(1);
      if (Wi.isEven() && Wi.iadd(Pe), Wi.testn(1) || Wi.iadd(Te), Ci.cmp(Te)) {
        if (!Ci.cmp(je))
          for (; Wi.mod(Ve).cmp(fi); )
            Wi.iadd(bi);
      } else for (; Wi.mod(Ie).cmp(Ue); )
        Wi.iadd(bi);
      if (zi = Wi.shrn(1), _i(zi) && _i(Wi) && Ei(zi) && Ei(Wi) && Be.test(zi) && Be.test(Wi))
        return Wi;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var Ae = bnExports$1, t = requireMr(), Ie = new t(), Me = new Ae(24), Be = new Ae(11), Pe = new Ae(10), Te = new Ae(3), je = new Ae(7), Ve = requireGeneratePrime(), fi = requireBrowser$b();
  dh = _i;
  function Ue(Pi, Ii) {
    return Ii = Ii || "utf8", Buffer.isBuffer(Pi) || (Pi = new Buffer(Pi, Ii)), this._pub = new Ae(Pi), this;
  }
  function bi(Pi, Ii) {
    return Ii = Ii || "utf8", Buffer.isBuffer(Pi) || (Pi = new Buffer(Pi, Ii)), this._priv = new Ae(Pi), this;
  }
  var vi = {};
  function mi(Pi, Ii) {
    var Ci = Ii.toString("hex"), Wi = [Ci, Pi.toString(16)].join("_");
    if (Wi in vi)
      return vi[Wi];
    var zi = 0;
    if (Pi.isEven() || !Ve.simpleSieve || !Ve.fermatTest(Pi) || !Ie.test(Pi))
      return zi += 1, Ci === "02" || Ci === "05" ? zi += 8 : zi += 4, vi[Wi] = zi, zi;
    Ie.test(Pi.shrn(1)) || (zi += 2);
    var Xi;
    switch (Ci) {
      case "02":
        Pi.mod(Me).cmp(Be) && (zi += 8);
        break;
      case "05":
        Xi = Pi.mod(Pe), Xi.cmp(Te) && Xi.cmp(je) && (zi += 8);
        break;
      default:
        zi += 4;
    }
    return vi[Wi] = zi, zi;
  }
  function _i(Pi, Ii, Ci) {
    this.setGenerator(Ii), this.__prime = new Ae(Pi), this._prime = Ae.mont(this.__prime), this._primeLen = Pi.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, Ci ? (this.setPublicKey = Ue, this.setPrivateKey = bi) : this._primeCode = 8;
  }
  Object.defineProperty(_i.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = mi(this.__prime, this.__gen)), this._primeCode;
    }
  }), _i.prototype.generateKeys = function() {
    return this._priv || (this._priv = new Ae(fi(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, _i.prototype.computeSecret = function(Pi) {
    Pi = new Ae(Pi), Pi = Pi.toRed(this._prime);
    var Ii = Pi.redPow(this._priv).fromRed(), Ci = new Buffer(Ii.toArray()), Wi = this.getPrime();
    if (Ci.length < Wi.length) {
      var zi = new Buffer(Wi.length - Ci.length);
      zi.fill(0), Ci = Buffer.concat([zi, Ci]);
    }
    return Ci;
  }, _i.prototype.getPublicKey = function(Ii) {
    return Ei(this._pub, Ii);
  }, _i.prototype.getPrivateKey = function(Ii) {
    return Ei(this._priv, Ii);
  }, _i.prototype.getPrime = function(Pi) {
    return Ei(this.__prime, Pi);
  }, _i.prototype.getGenerator = function(Pi) {
    return Ei(this._gen, Pi);
  }, _i.prototype.setGenerator = function(Pi, Ii) {
    return Ii = Ii || "utf8", Buffer.isBuffer(Pi) || (Pi = new Buffer(Pi, Ii)), this.__gen = Pi, this._gen = new Ae(Pi), this;
  };
  function Ei(Pi, Ii) {
    var Ci = new Buffer(Pi.toArray());
    return Ii ? Ci.toString(Ii) : Ci;
  }
  return dh;
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4) return browser$5;
  hasRequiredBrowser$4 = 1;
  var Ae = requireGeneratePrime(), t = require$$1$1, Ie = requireDh();
  function Me(Te) {
    var je = new Buffer(t[Te].prime, "hex"), Ve = new Buffer(t[Te].gen, "hex");
    return new Ie(je, Ve);
  }
  var Be = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function Pe(Te, je, Ve, fi) {
    return Buffer.isBuffer(je) || Be[je] === void 0 ? Pe(Te, "binary", je, Ve) : (je = je || "binary", fi = fi || "binary", Ve = Ve || new Buffer([2]), Buffer.isBuffer(Ve) || (Ve = new Buffer(Ve, fi)), typeof Te == "number" ? new Ie(Ae(Te, Ve), Ve, !0) : (Buffer.isBuffer(Te) || (Te = new Buffer(Te, je)), new Ie(Te, Ve, !0)));
  }
  return browser$5.DiffieHellmanGroup = browser$5.createDiffieHellmanGroup = browser$5.getDiffieHellman = Me, browser$5.createDiffieHellman = browser$5.DiffieHellman = Pe, browser$5;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} }, hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1, typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick: Ae } : processNextickArgs.exports = process$1;
  function Ae(t, Ie, Me, Be) {
    if (typeof t != "function")
      throw new TypeError('"callback" argument must be a function');
    var Pe = arguments.length, Te, je;
    switch (Pe) {
      case 0:
      case 1:
        return process$1.nextTick(t);
      case 2:
        return process$1.nextTick(function() {
          t.call(null, Ie);
        });
      case 3:
        return process$1.nextTick(function() {
          t.call(null, Ie, Me);
        });
      case 4:
        return process$1.nextTick(function() {
          t.call(null, Ie, Me, Be);
        });
      default:
        for (Te = new Array(Pe - 1), je = 0; je < Te.length; )
          Te[je++] = arguments[je];
        return process$1.nextTick(function() {
          t.apply(null, Te);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray, hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var Ae = {}.toString;
  return isarray = Array.isArray || function(t) {
    return Ae.call(t) == "[object Array]";
  }, isarray;
}
var streamBrowser, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser = eventsExports.EventEmitter), streamBrowser;
}
var safeBuffer = { exports: {} }, hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(Ae, t) {
    var Ie = require$$1$2, Me = Ie.Buffer;
    function Be(Te, je) {
      for (var Ve in Te)
        je[Ve] = Te[Ve];
    }
    Me.from && Me.alloc && Me.allocUnsafe && Me.allocUnsafeSlow ? Ae.exports = Ie : (Be(Ie, t), t.Buffer = Pe);
    function Pe(Te, je, Ve) {
      return Me(Te, je, Ve);
    }
    Be(Me, Pe), Pe.from = function(Te, je, Ve) {
      if (typeof Te == "number")
        throw new TypeError("Argument must not be a number");
      return Me(Te, je, Ve);
    }, Pe.alloc = function(Te, je, Ve) {
      if (typeof Te != "number")
        throw new TypeError("Argument must be a number");
      var fi = Me(Te);
      return je !== void 0 ? typeof Ve == "string" ? fi.fill(je, Ve) : fi.fill(je) : fi.fill(0), fi;
    }, Pe.allocUnsafe = function(Te) {
      if (typeof Te != "number")
        throw new TypeError("Argument must be a number");
      return Me(Te);
    }, Pe.allocUnsafeSlow = function(Te) {
      if (typeof Te != "number")
        throw new TypeError("Argument must be a number");
      return Ie.SlowBuffer(Te);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var util = {}, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  function Ae(Ei) {
    return Array.isArray ? Array.isArray(Ei) : _i(Ei) === "[object Array]";
  }
  util.isArray = Ae;
  function t(Ei) {
    return typeof Ei == "boolean";
  }
  util.isBoolean = t;
  function Ie(Ei) {
    return Ei === null;
  }
  util.isNull = Ie;
  function Me(Ei) {
    return Ei == null;
  }
  util.isNullOrUndefined = Me;
  function Be(Ei) {
    return typeof Ei == "number";
  }
  util.isNumber = Be;
  function Pe(Ei) {
    return typeof Ei == "string";
  }
  util.isString = Pe;
  function Te(Ei) {
    return typeof Ei == "symbol";
  }
  util.isSymbol = Te;
  function je(Ei) {
    return Ei === void 0;
  }
  util.isUndefined = je;
  function Ve(Ei) {
    return _i(Ei) === "[object RegExp]";
  }
  util.isRegExp = Ve;
  function fi(Ei) {
    return typeof Ei == "object" && Ei !== null;
  }
  util.isObject = fi;
  function Ue(Ei) {
    return _i(Ei) === "[object Date]";
  }
  util.isDate = Ue;
  function bi(Ei) {
    return _i(Ei) === "[object Error]" || Ei instanceof Error;
  }
  util.isError = bi;
  function vi(Ei) {
    return typeof Ei == "function";
  }
  util.isFunction = vi;
  function mi(Ei) {
    return Ei === null || typeof Ei == "boolean" || typeof Ei == "number" || typeof Ei == "string" || typeof Ei == "symbol" || // ES6 symbol
    typeof Ei > "u";
  }
  util.isPrimitive = mi, util.isBuffer = require$$1$2.Buffer.isBuffer;
  function _i(Ei) {
    return Object.prototype.toString.call(Ei);
  }
  return util;
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(Ae) {
    function t(Pe, Te) {
      if (!(Pe instanceof Te))
        throw new TypeError("Cannot call a class as a function");
    }
    var Ie = requireSafeBuffer().Buffer, Me = requireUtil$1();
    function Be(Pe, Te, je) {
      Pe.copy(Te, je);
    }
    Ae.exports = function() {
      function Pe() {
        t(this, Pe), this.head = null, this.tail = null, this.length = 0;
      }
      return Pe.prototype.push = function(je) {
        var Ve = { data: je, next: null };
        this.length > 0 ? this.tail.next = Ve : this.head = Ve, this.tail = Ve, ++this.length;
      }, Pe.prototype.unshift = function(je) {
        var Ve = { data: je, next: this.head };
        this.length === 0 && (this.tail = Ve), this.head = Ve, ++this.length;
      }, Pe.prototype.shift = function() {
        if (this.length !== 0) {
          var je = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, je;
        }
      }, Pe.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, Pe.prototype.join = function(je) {
        if (this.length === 0) return "";
        for (var Ve = this.head, fi = "" + Ve.data; Ve = Ve.next; )
          fi += je + Ve.data;
        return fi;
      }, Pe.prototype.concat = function(je) {
        if (this.length === 0) return Ie.alloc(0);
        for (var Ve = Ie.allocUnsafe(je >>> 0), fi = this.head, Ue = 0; fi; )
          Be(fi.data, Ve, Ue), Ue += fi.data.length, fi = fi.next;
        return Ve;
      }, Pe;
    }(), Me && Me.inspect && Me.inspect.custom && (Ae.exports.prototype[Me.inspect.custom] = function() {
      var Pe = Me.inspect({ length: this.length });
      return this.constructor.name + " " + Pe;
    });
  }(BufferList)), BufferList.exports;
}
var destroy_1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  var Ae = requireProcessNextickArgs();
  function t(Be, Pe) {
    var Te = this, je = this._readableState && this._readableState.destroyed, Ve = this._writableState && this._writableState.destroyed;
    return je || Ve ? (Pe ? Pe(Be) : Be && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, Ae.nextTick(Me, this, Be)) : Ae.nextTick(Me, this, Be)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(Be || null, function(fi) {
      !Pe && fi ? Te._writableState ? Te._writableState.errorEmitted || (Te._writableState.errorEmitted = !0, Ae.nextTick(Me, Te, fi)) : Ae.nextTick(Me, Te, fi) : Pe && Pe(fi);
    }), this);
  }
  function Ie() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function Me(Be, Pe) {
    Be.emit("error", Pe);
  }
  return destroy_1 = {
    destroy: t,
    undestroy: Ie
  }, destroy_1;
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var Ae = requireProcessNextickArgs();
  _stream_writable = Ei;
  function t(qi) {
    var Ni = this;
    this.next = null, this.entry = null, this.finish = function() {
      Li(Ni, qi);
    };
  }
  var Ie = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : Ae.nextTick, Me;
  Ei.WritableState = mi;
  var Be = Object.create(requireUtil());
  Be.inherits = inherits_browserExports;
  var Pe = {
    deprecate: requireBrowser$a()
  }, Te = requireStreamBrowser(), je = requireSafeBuffer().Buffer, Ve = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function fi(qi) {
    return je.from(qi);
  }
  function Ue(qi) {
    return je.isBuffer(qi) || qi instanceof Ve;
  }
  var bi = requireDestroy();
  Be.inherits(Ei, Te);
  function vi() {
  }
  function mi(qi, Ni) {
    Me = Me || require_stream_duplex(), qi = qi || {};
    var Ti = Ni instanceof Me;
    this.objectMode = !!qi.objectMode, Ti && (this.objectMode = this.objectMode || !!qi.writableObjectMode);
    var xi = qi.highWaterMark, Fi = qi.writableHighWaterMark, Si = this.objectMode ? 16 : 16 * 1024;
    xi || xi === 0 ? this.highWaterMark = xi : Ti && (Fi || Fi === 0) ? this.highWaterMark = Fi : this.highWaterMark = Si, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Vi = qi.decodeStrings === !1;
    this.decodeStrings = !Vi, this.defaultEncoding = qi.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ts) {
      Oi(Ni, ts);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  mi.prototype.getBuffer = function() {
    for (var Ni = this.bufferedRequest, Ti = []; Ni; )
      Ti.push(Ni), Ni = Ni.next;
    return Ti;
  }, function() {
    try {
      Object.defineProperty(mi.prototype, "buffer", {
        get: Pe.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var _i;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (_i = Function.prototype[Symbol.hasInstance], Object.defineProperty(Ei, Symbol.hasInstance, {
    value: function(qi) {
      return _i.call(this, qi) ? !0 : this !== Ei ? !1 : qi && qi._writableState instanceof mi;
    }
  })) : _i = function(qi) {
    return qi instanceof this;
  };
  function Ei(qi) {
    if (Me = Me || require_stream_duplex(), !_i.call(Ei, this) && !(this instanceof Me))
      return new Ei(qi);
    this._writableState = new mi(qi, this), this.writable = !0, qi && (typeof qi.write == "function" && (this._write = qi.write), typeof qi.writev == "function" && (this._writev = qi.writev), typeof qi.destroy == "function" && (this._destroy = qi.destroy), typeof qi.final == "function" && (this._final = qi.final)), Te.call(this);
  }
  Ei.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function Pi(qi, Ni) {
    var Ti = new Error("write after end");
    qi.emit("error", Ti), Ae.nextTick(Ni, Ti);
  }
  function Ii(qi, Ni, Ti, xi) {
    var Fi = !0, Si = !1;
    return Ti === null ? Si = new TypeError("May not write null values to stream") : typeof Ti != "string" && Ti !== void 0 && !Ni.objectMode && (Si = new TypeError("Invalid non-string/buffer chunk")), Si && (qi.emit("error", Si), Ae.nextTick(xi, Si), Fi = !1), Fi;
  }
  Ei.prototype.write = function(qi, Ni, Ti) {
    var xi = this._writableState, Fi = !1, Si = !xi.objectMode && Ue(qi);
    return Si && !je.isBuffer(qi) && (qi = fi(qi)), typeof Ni == "function" && (Ti = Ni, Ni = null), Si ? Ni = "buffer" : Ni || (Ni = xi.defaultEncoding), typeof Ti != "function" && (Ti = vi), xi.ended ? Pi(this, Ti) : (Si || Ii(this, xi, qi, Ti)) && (xi.pendingcb++, Fi = Wi(this, xi, Si, qi, Ni, Ti)), Fi;
  }, Ei.prototype.cork = function() {
    var qi = this._writableState;
    qi.corked++;
  }, Ei.prototype.uncork = function() {
    var qi = this._writableState;
    qi.corked && (qi.corked--, !qi.writing && !qi.corked && !qi.bufferProcessing && qi.bufferedRequest && ls(this, qi));
  }, Ei.prototype.setDefaultEncoding = function(Ni) {
    if (typeof Ni == "string" && (Ni = Ni.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Ni + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + Ni);
    return this._writableState.defaultEncoding = Ni, this;
  };
  function Ci(qi, Ni, Ti) {
    return !qi.objectMode && qi.decodeStrings !== !1 && typeof Ni == "string" && (Ni = je.from(Ni, Ti)), Ni;
  }
  Object.defineProperty(Ei.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Wi(qi, Ni, Ti, xi, Fi, Si) {
    if (!Ti) {
      var Vi = Ci(Ni, xi, Fi);
      xi !== Vi && (Ti = !0, Fi = "buffer", xi = Vi);
    }
    var ts = Ni.objectMode ? 1 : xi.length;
    Ni.length += ts;
    var Hi = Ni.length < Ni.highWaterMark;
    if (Hi || (Ni.needDrain = !0), Ni.writing || Ni.corked) {
      var fn = Ni.lastBufferedRequest;
      Ni.lastBufferedRequest = {
        chunk: xi,
        encoding: Fi,
        isBuf: Ti,
        callback: Si,
        next: null
      }, fn ? fn.next = Ni.lastBufferedRequest : Ni.bufferedRequest = Ni.lastBufferedRequest, Ni.bufferedRequestCount += 1;
    } else
      zi(qi, Ni, !1, ts, xi, Fi, Si);
    return Hi;
  }
  function zi(qi, Ni, Ti, xi, Fi, Si, Vi) {
    Ni.writelen = xi, Ni.writecb = Vi, Ni.writing = !0, Ni.sync = !0, Ti ? qi._writev(Fi, Ni.onwrite) : qi._write(Fi, Si, Ni.onwrite), Ni.sync = !1;
  }
  function Xi(qi, Ni, Ti, xi, Fi) {
    --Ni.pendingcb, Ti ? (Ae.nextTick(Fi, xi), Ae.nextTick(wi, qi, Ni), qi._writableState.errorEmitted = !0, qi.emit("error", xi)) : (Fi(xi), qi._writableState.errorEmitted = !0, qi.emit("error", xi), wi(qi, Ni));
  }
  function Qi(qi) {
    qi.writing = !1, qi.writecb = null, qi.length -= qi.writelen, qi.writelen = 0;
  }
  function Oi(qi, Ni) {
    var Ti = qi._writableState, xi = Ti.sync, Fi = Ti.writecb;
    if (Qi(Ti), Ni) Xi(qi, Ti, xi, Ni, Fi);
    else {
      var Si = vn(Ti);
      !Si && !Ti.corked && !Ti.bufferProcessing && Ti.bufferedRequest && ls(qi, Ti), xi ? Ie(Yi, qi, Ti, Si, Fi) : Yi(qi, Ti, Si, Fi);
    }
  }
  function Yi(qi, Ni, Ti, xi) {
    Ti || ns(qi, Ni), Ni.pendingcb--, xi(), wi(qi, Ni);
  }
  function ns(qi, Ni) {
    Ni.length === 0 && Ni.needDrain && (Ni.needDrain = !1, qi.emit("drain"));
  }
  function ls(qi, Ni) {
    Ni.bufferProcessing = !0;
    var Ti = Ni.bufferedRequest;
    if (qi._writev && Ti && Ti.next) {
      var xi = Ni.bufferedRequestCount, Fi = new Array(xi), Si = Ni.corkedRequestsFree;
      Si.entry = Ti;
      for (var Vi = 0, ts = !0; Ti; )
        Fi[Vi] = Ti, Ti.isBuf || (ts = !1), Ti = Ti.next, Vi += 1;
      Fi.allBuffers = ts, zi(qi, Ni, !0, Ni.length, Fi, "", Si.finish), Ni.pendingcb++, Ni.lastBufferedRequest = null, Si.next ? (Ni.corkedRequestsFree = Si.next, Si.next = null) : Ni.corkedRequestsFree = new t(Ni), Ni.bufferedRequestCount = 0;
    } else {
      for (; Ti; ) {
        var Hi = Ti.chunk, fn = Ti.encoding, Bi = Ti.callback, ki = Ni.objectMode ? 1 : Hi.length;
        if (zi(qi, Ni, !1, ki, Hi, fn, Bi), Ti = Ti.next, Ni.bufferedRequestCount--, Ni.writing)
          break;
      }
      Ti === null && (Ni.lastBufferedRequest = null);
    }
    Ni.bufferedRequest = Ti, Ni.bufferProcessing = !1;
  }
  Ei.prototype._write = function(qi, Ni, Ti) {
    Ti(new Error("_write() is not implemented"));
  }, Ei.prototype._writev = null, Ei.prototype.end = function(qi, Ni, Ti) {
    var xi = this._writableState;
    typeof qi == "function" ? (Ti = qi, qi = null, Ni = null) : typeof Ni == "function" && (Ti = Ni, Ni = null), qi != null && this.write(qi, Ni), xi.corked && (xi.corked = 1, this.uncork()), xi.ending || $i(this, xi, Ti);
  };
  function vn(qi) {
    return qi.ending && qi.length === 0 && qi.bufferedRequest === null && !qi.finished && !qi.writing;
  }
  function Mi(qi, Ni) {
    qi._final(function(Ti) {
      Ni.pendingcb--, Ti && qi.emit("error", Ti), Ni.prefinished = !0, qi.emit("prefinish"), wi(qi, Ni);
    });
  }
  function Ai(qi, Ni) {
    !Ni.prefinished && !Ni.finalCalled && (typeof qi._final == "function" ? (Ni.pendingcb++, Ni.finalCalled = !0, Ae.nextTick(Mi, qi, Ni)) : (Ni.prefinished = !0, qi.emit("prefinish")));
  }
  function wi(qi, Ni) {
    var Ti = vn(Ni);
    return Ti && (Ai(qi, Ni), Ni.pendingcb === 0 && (Ni.finished = !0, qi.emit("finish"))), Ti;
  }
  function $i(qi, Ni, Ti) {
    Ni.ending = !0, wi(qi, Ni), Ti && (Ni.finished ? Ae.nextTick(Ti) : qi.once("finish", Ti)), Ni.ended = !0, qi.writable = !1;
  }
  function Li(qi, Ni, Ti) {
    var xi = qi.entry;
    for (qi.entry = null; xi; ) {
      var Fi = xi.callback;
      Ni.pendingcb--, Fi(Ti), xi = xi.next;
    }
    Ni.corkedRequestsFree.next = qi;
  }
  return Object.defineProperty(Ei.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(qi) {
      this._writableState && (this._writableState.destroyed = qi);
    }
  }), Ei.prototype.destroy = bi.destroy, Ei.prototype._undestroy = bi.undestroy, Ei.prototype._destroy = function(qi, Ni) {
    this.end(), Ni(qi);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var Ae = requireProcessNextickArgs(), t = Object.keys || function(bi) {
    var vi = [];
    for (var mi in bi)
      vi.push(mi);
    return vi;
  };
  _stream_duplex = Ve;
  var Ie = Object.create(requireUtil());
  Ie.inherits = inherits_browserExports;
  var Me = require_stream_readable(), Be = require_stream_writable();
  Ie.inherits(Ve, Me);
  for (var Pe = t(Be.prototype), Te = 0; Te < Pe.length; Te++) {
    var je = Pe[Te];
    Ve.prototype[je] || (Ve.prototype[je] = Be.prototype[je]);
  }
  function Ve(bi) {
    if (!(this instanceof Ve)) return new Ve(bi);
    Me.call(this, bi), Be.call(this, bi), bi && bi.readable === !1 && (this.readable = !1), bi && bi.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, bi && bi.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", fi);
  }
  Object.defineProperty(Ve.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function fi() {
    this.allowHalfOpen || this._writableState.ended || Ae.nextTick(Ue, this);
  }
  function Ue(bi) {
    bi.end();
  }
  return Object.defineProperty(Ve.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(bi) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = bi, this._writableState.destroyed = bi);
    }
  }), Ve.prototype._destroy = function(bi, vi) {
    this.push(null), this.end(), Ae.nextTick(vi, bi);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var Ae = requireProcessNextickArgs();
  _stream_readable = Ci;
  var t = requireIsarray(), Ie;
  Ci.ReadableState = Ii, eventsExports.EventEmitter;
  var Me = function(Bi, ki) {
    return Bi.listeners(ki).length;
  }, Be = requireStreamBrowser(), Pe = requireSafeBuffer().Buffer, Te = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function je(Bi) {
    return Pe.from(Bi);
  }
  function Ve(Bi) {
    return Pe.isBuffer(Bi) || Bi instanceof Te;
  }
  var fi = Object.create(requireUtil());
  fi.inherits = inherits_browserExports;
  var Ue = requireUtil$1(), bi = void 0;
  Ue && Ue.debuglog ? bi = Ue.debuglog("stream") : bi = function() {
  };
  var vi = requireBufferList(), mi = requireDestroy(), _i;
  fi.inherits(Ci, Be);
  var Ei = ["error", "close", "destroy", "pause", "resume"];
  function Pi(Bi, ki, Ji) {
    if (typeof Bi.prependListener == "function") return Bi.prependListener(ki, Ji);
    !Bi._events || !Bi._events[ki] ? Bi.on(ki, Ji) : t(Bi._events[ki]) ? Bi._events[ki].unshift(Ji) : Bi._events[ki] = [Ji, Bi._events[ki]];
  }
  function Ii(Bi, ki) {
    Ie = Ie || require_stream_duplex(), Bi = Bi || {};
    var Ji = ki instanceof Ie;
    this.objectMode = !!Bi.objectMode, Ji && (this.objectMode = this.objectMode || !!Bi.readableObjectMode);
    var Ri = Bi.highWaterMark, ji = Bi.readableHighWaterMark, Gi = this.objectMode ? 16 : 16 * 1024;
    Ri || Ri === 0 ? this.highWaterMark = Ri : Ji && (ji || ji === 0) ? this.highWaterMark = ji : this.highWaterMark = Gi, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new vi(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Bi.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Bi.encoding && (_i || (_i = requireString_decoder().StringDecoder), this.decoder = new _i(Bi.encoding), this.encoding = Bi.encoding);
  }
  function Ci(Bi) {
    if (Ie = Ie || require_stream_duplex(), !(this instanceof Ci)) return new Ci(Bi);
    this._readableState = new Ii(Bi, this), this.readable = !0, Bi && (typeof Bi.read == "function" && (this._read = Bi.read), typeof Bi.destroy == "function" && (this._destroy = Bi.destroy)), Be.call(this);
  }
  Object.defineProperty(Ci.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Bi) {
      this._readableState && (this._readableState.destroyed = Bi);
    }
  }), Ci.prototype.destroy = mi.destroy, Ci.prototype._undestroy = mi.undestroy, Ci.prototype._destroy = function(Bi, ki) {
    this.push(null), ki(Bi);
  }, Ci.prototype.push = function(Bi, ki) {
    var Ji = this._readableState, Ri;
    return Ji.objectMode ? Ri = !0 : typeof Bi == "string" && (ki = ki || Ji.defaultEncoding, ki !== Ji.encoding && (Bi = Pe.from(Bi, ki), ki = ""), Ri = !0), Wi(this, Bi, ki, !1, Ri);
  }, Ci.prototype.unshift = function(Bi) {
    return Wi(this, Bi, null, !0, !1);
  };
  function Wi(Bi, ki, Ji, Ri, ji) {
    var Gi = Bi._readableState;
    if (ki === null)
      Gi.reading = !1, ls(Bi, Gi);
    else {
      var is;
      ji || (is = Xi(Gi, ki)), is ? Bi.emit("error", is) : Gi.objectMode || ki && ki.length > 0 ? (typeof ki != "string" && !Gi.objectMode && Object.getPrototypeOf(ki) !== Pe.prototype && (ki = je(ki)), Ri ? Gi.endEmitted ? Bi.emit("error", new Error("stream.unshift() after end event")) : zi(Bi, Gi, ki, !0) : Gi.ended ? Bi.emit("error", new Error("stream.push() after EOF")) : (Gi.reading = !1, Gi.decoder && !Ji ? (ki = Gi.decoder.write(ki), Gi.objectMode || ki.length !== 0 ? zi(Bi, Gi, ki, !1) : Ai(Bi, Gi)) : zi(Bi, Gi, ki, !1))) : Ri || (Gi.reading = !1);
    }
    return Qi(Gi);
  }
  function zi(Bi, ki, Ji, Ri) {
    ki.flowing && ki.length === 0 && !ki.sync ? (Bi.emit("data", Ji), Bi.read(0)) : (ki.length += ki.objectMode ? 1 : Ji.length, Ri ? ki.buffer.unshift(Ji) : ki.buffer.push(Ji), ki.needReadable && vn(Bi)), Ai(Bi, ki);
  }
  function Xi(Bi, ki) {
    var Ji;
    return !Ve(ki) && typeof ki != "string" && ki !== void 0 && !Bi.objectMode && (Ji = new TypeError("Invalid non-string/buffer chunk")), Ji;
  }
  function Qi(Bi) {
    return !Bi.ended && (Bi.needReadable || Bi.length < Bi.highWaterMark || Bi.length === 0);
  }
  Ci.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Ci.prototype.setEncoding = function(Bi) {
    return _i || (_i = requireString_decoder().StringDecoder), this._readableState.decoder = new _i(Bi), this._readableState.encoding = Bi, this;
  };
  var Oi = 8388608;
  function Yi(Bi) {
    return Bi >= Oi ? Bi = Oi : (Bi--, Bi |= Bi >>> 1, Bi |= Bi >>> 2, Bi |= Bi >>> 4, Bi |= Bi >>> 8, Bi |= Bi >>> 16, Bi++), Bi;
  }
  function ns(Bi, ki) {
    return Bi <= 0 || ki.length === 0 && ki.ended ? 0 : ki.objectMode ? 1 : Bi !== Bi ? ki.flowing && ki.length ? ki.buffer.head.data.length : ki.length : (Bi > ki.highWaterMark && (ki.highWaterMark = Yi(Bi)), Bi <= ki.length ? Bi : ki.ended ? ki.length : (ki.needReadable = !0, 0));
  }
  Ci.prototype.read = function(Bi) {
    bi("read", Bi), Bi = parseInt(Bi, 10);
    var ki = this._readableState, Ji = Bi;
    if (Bi !== 0 && (ki.emittedReadable = !1), Bi === 0 && ki.needReadable && (ki.length >= ki.highWaterMark || ki.ended))
      return bi("read: emitReadable", ki.length, ki.ended), ki.length === 0 && ki.ended ? ts(this) : vn(this), null;
    if (Bi = ns(Bi, ki), Bi === 0 && ki.ended)
      return ki.length === 0 && ts(this), null;
    var Ri = ki.needReadable;
    bi("need readable", Ri), (ki.length === 0 || ki.length - Bi < ki.highWaterMark) && (Ri = !0, bi("length less than watermark", Ri)), ki.ended || ki.reading ? (Ri = !1, bi("reading or ended", Ri)) : Ri && (bi("do read"), ki.reading = !0, ki.sync = !0, ki.length === 0 && (ki.needReadable = !0), this._read(ki.highWaterMark), ki.sync = !1, ki.reading || (Bi = ns(Ji, ki)));
    var ji;
    return Bi > 0 ? ji = xi(Bi, ki) : ji = null, ji === null ? (ki.needReadable = !0, Bi = 0) : ki.length -= Bi, ki.length === 0 && (ki.ended || (ki.needReadable = !0), Ji !== Bi && ki.ended && ts(this)), ji !== null && this.emit("data", ji), ji;
  };
  function ls(Bi, ki) {
    if (!ki.ended) {
      if (ki.decoder) {
        var Ji = ki.decoder.end();
        Ji && Ji.length && (ki.buffer.push(Ji), ki.length += ki.objectMode ? 1 : Ji.length);
      }
      ki.ended = !0, vn(Bi);
    }
  }
  function vn(Bi) {
    var ki = Bi._readableState;
    ki.needReadable = !1, ki.emittedReadable || (bi("emitReadable", ki.flowing), ki.emittedReadable = !0, ki.sync ? Ae.nextTick(Mi, Bi) : Mi(Bi));
  }
  function Mi(Bi) {
    bi("emit readable"), Bi.emit("readable"), Ti(Bi);
  }
  function Ai(Bi, ki) {
    ki.readingMore || (ki.readingMore = !0, Ae.nextTick(wi, Bi, ki));
  }
  function wi(Bi, ki) {
    for (var Ji = ki.length; !ki.reading && !ki.flowing && !ki.ended && ki.length < ki.highWaterMark && (bi("maybeReadMore read 0"), Bi.read(0), Ji !== ki.length); )
      Ji = ki.length;
    ki.readingMore = !1;
  }
  Ci.prototype._read = function(Bi) {
    this.emit("error", new Error("_read() is not implemented"));
  }, Ci.prototype.pipe = function(Bi, ki) {
    var Ji = this, Ri = this._readableState;
    switch (Ri.pipesCount) {
      case 0:
        Ri.pipes = Bi;
        break;
      case 1:
        Ri.pipes = [Ri.pipes, Bi];
        break;
      default:
        Ri.pipes.push(Bi);
        break;
    }
    Ri.pipesCount += 1, bi("pipe count=%d opts=%j", Ri.pipesCount, ki);
    var ji = (!ki || ki.end !== !1) && Bi !== process$1.stdout && Bi !== process$1.stderr, Gi = ji ? os : aa;
    Ri.endEmitted ? Ae.nextTick(Gi) : Ji.once("end", Gi), Bi.on("unpipe", is);
    function is(Ds, ra) {
      bi("onunpipe"), Ds === Ji && ra && ra.hasUnpiped === !1 && (ra.hasUnpiped = !0, ea());
    }
    function os() {
      bi("onend"), Bi.end();
    }
    var ds = $i(Ji);
    Bi.on("drain", ds);
    var ps = !1;
    function ea() {
      bi("cleanup"), Bi.removeListener("close", gs), Bi.removeListener("finish", sa), Bi.removeListener("drain", ds), Bi.removeListener("error", fa), Bi.removeListener("unpipe", is), Ji.removeListener("end", os), Ji.removeListener("end", aa), Ji.removeListener("data", hs), ps = !0, Ri.awaitDrain && (!Bi._writableState || Bi._writableState.needDrain) && ds();
    }
    var ia = !1;
    Ji.on("data", hs);
    function hs(Ds) {
      bi("ondata"), ia = !1;
      var ra = Bi.write(Ds);
      ra === !1 && !ia && ((Ri.pipesCount === 1 && Ri.pipes === Bi || Ri.pipesCount > 1 && fn(Ri.pipes, Bi) !== -1) && !ps && (bi("false write response, pause", Ri.awaitDrain), Ri.awaitDrain++, ia = !0), Ji.pause());
    }
    function fa(Ds) {
      bi("onerror", Ds), aa(), Bi.removeListener("error", fa), Me(Bi, "error") === 0 && Bi.emit("error", Ds);
    }
    Pi(Bi, "error", fa);
    function gs() {
      Bi.removeListener("finish", sa), aa();
    }
    Bi.once("close", gs);
    function sa() {
      bi("onfinish"), Bi.removeListener("close", gs), aa();
    }
    Bi.once("finish", sa);
    function aa() {
      bi("unpipe"), Ji.unpipe(Bi);
    }
    return Bi.emit("pipe", Ji), Ri.flowing || (bi("pipe resume"), Ji.resume()), Bi;
  };
  function $i(Bi) {
    return function() {
      var ki = Bi._readableState;
      bi("pipeOnDrain", ki.awaitDrain), ki.awaitDrain && ki.awaitDrain--, ki.awaitDrain === 0 && Me(Bi, "data") && (ki.flowing = !0, Ti(Bi));
    };
  }
  Ci.prototype.unpipe = function(Bi) {
    var ki = this._readableState, Ji = { hasUnpiped: !1 };
    if (ki.pipesCount === 0) return this;
    if (ki.pipesCount === 1)
      return Bi && Bi !== ki.pipes ? this : (Bi || (Bi = ki.pipes), ki.pipes = null, ki.pipesCount = 0, ki.flowing = !1, Bi && Bi.emit("unpipe", this, Ji), this);
    if (!Bi) {
      var Ri = ki.pipes, ji = ki.pipesCount;
      ki.pipes = null, ki.pipesCount = 0, ki.flowing = !1;
      for (var Gi = 0; Gi < ji; Gi++)
        Ri[Gi].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var is = fn(ki.pipes, Bi);
    return is === -1 ? this : (ki.pipes.splice(is, 1), ki.pipesCount -= 1, ki.pipesCount === 1 && (ki.pipes = ki.pipes[0]), Bi.emit("unpipe", this, Ji), this);
  }, Ci.prototype.on = function(Bi, ki) {
    var Ji = Be.prototype.on.call(this, Bi, ki);
    if (Bi === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (Bi === "readable") {
      var Ri = this._readableState;
      !Ri.endEmitted && !Ri.readableListening && (Ri.readableListening = Ri.needReadable = !0, Ri.emittedReadable = !1, Ri.reading ? Ri.length && vn(this) : Ae.nextTick(Li, this));
    }
    return Ji;
  }, Ci.prototype.addListener = Ci.prototype.on;
  function Li(Bi) {
    bi("readable nexttick read 0"), Bi.read(0);
  }
  Ci.prototype.resume = function() {
    var Bi = this._readableState;
    return Bi.flowing || (bi("resume"), Bi.flowing = !0, qi(this, Bi)), this;
  };
  function qi(Bi, ki) {
    ki.resumeScheduled || (ki.resumeScheduled = !0, Ae.nextTick(Ni, Bi, ki));
  }
  function Ni(Bi, ki) {
    ki.reading || (bi("resume read 0"), Bi.read(0)), ki.resumeScheduled = !1, ki.awaitDrain = 0, Bi.emit("resume"), Ti(Bi), ki.flowing && !ki.reading && Bi.read(0);
  }
  Ci.prototype.pause = function() {
    return bi("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (bi("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function Ti(Bi) {
    var ki = Bi._readableState;
    for (bi("flow", ki.flowing); ki.flowing && Bi.read() !== null; )
      ;
  }
  Ci.prototype.wrap = function(Bi) {
    var ki = this, Ji = this._readableState, Ri = !1;
    Bi.on("end", function() {
      if (bi("wrapped end"), Ji.decoder && !Ji.ended) {
        var is = Ji.decoder.end();
        is && is.length && ki.push(is);
      }
      ki.push(null);
    }), Bi.on("data", function(is) {
      if (bi("wrapped data"), Ji.decoder && (is = Ji.decoder.write(is)), !(Ji.objectMode && is == null) && !(!Ji.objectMode && (!is || !is.length))) {
        var os = ki.push(is);
        os || (Ri = !0, Bi.pause());
      }
    });
    for (var ji in Bi)
      this[ji] === void 0 && typeof Bi[ji] == "function" && (this[ji] = /* @__PURE__ */ function(is) {
        return function() {
          return Bi[is].apply(Bi, arguments);
        };
      }(ji));
    for (var Gi = 0; Gi < Ei.length; Gi++)
      Bi.on(Ei[Gi], this.emit.bind(this, Ei[Gi]));
    return this._read = function(is) {
      bi("wrapped _read", is), Ri && (Ri = !1, Bi.resume());
    }, this;
  }, Object.defineProperty(Ci.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Ci._fromList = xi;
  function xi(Bi, ki) {
    if (ki.length === 0) return null;
    var Ji;
    return ki.objectMode ? Ji = ki.buffer.shift() : !Bi || Bi >= ki.length ? (ki.decoder ? Ji = ki.buffer.join("") : ki.buffer.length === 1 ? Ji = ki.buffer.head.data : Ji = ki.buffer.concat(ki.length), ki.buffer.clear()) : Ji = Fi(Bi, ki.buffer, ki.decoder), Ji;
  }
  function Fi(Bi, ki, Ji) {
    var Ri;
    return Bi < ki.head.data.length ? (Ri = ki.head.data.slice(0, Bi), ki.head.data = ki.head.data.slice(Bi)) : Bi === ki.head.data.length ? Ri = ki.shift() : Ri = Ji ? Si(Bi, ki) : Vi(Bi, ki), Ri;
  }
  function Si(Bi, ki) {
    var Ji = ki.head, Ri = 1, ji = Ji.data;
    for (Bi -= ji.length; Ji = Ji.next; ) {
      var Gi = Ji.data, is = Bi > Gi.length ? Gi.length : Bi;
      if (is === Gi.length ? ji += Gi : ji += Gi.slice(0, Bi), Bi -= is, Bi === 0) {
        is === Gi.length ? (++Ri, Ji.next ? ki.head = Ji.next : ki.head = ki.tail = null) : (ki.head = Ji, Ji.data = Gi.slice(is));
        break;
      }
      ++Ri;
    }
    return ki.length -= Ri, ji;
  }
  function Vi(Bi, ki) {
    var Ji = Pe.allocUnsafe(Bi), Ri = ki.head, ji = 1;
    for (Ri.data.copy(Ji), Bi -= Ri.data.length; Ri = Ri.next; ) {
      var Gi = Ri.data, is = Bi > Gi.length ? Gi.length : Bi;
      if (Gi.copy(Ji, Ji.length - Bi, 0, is), Bi -= is, Bi === 0) {
        is === Gi.length ? (++ji, Ri.next ? ki.head = Ri.next : ki.head = ki.tail = null) : (ki.head = Ri, Ri.data = Gi.slice(is));
        break;
      }
      ++ji;
    }
    return ki.length -= ji, Ji;
  }
  function ts(Bi) {
    var ki = Bi._readableState;
    if (ki.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    ki.endEmitted || (ki.ended = !0, Ae.nextTick(Hi, ki, Bi));
  }
  function Hi(Bi, ki) {
    !Bi.endEmitted && Bi.length === 0 && (Bi.endEmitted = !0, ki.readable = !1, ki.emit("end"));
  }
  function fn(Bi, ki) {
    for (var Ji = 0, Ri = Bi.length; Ji < Ri; Ji++)
      if (Bi[Ji] === ki) return Ji;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1, _stream_transform = Me;
  var Ae = require_stream_duplex(), t = Object.create(requireUtil());
  t.inherits = inherits_browserExports, t.inherits(Me, Ae);
  function Ie(Te, je) {
    var Ve = this._transformState;
    Ve.transforming = !1;
    var fi = Ve.writecb;
    if (!fi)
      return this.emit("error", new Error("write callback called multiple times"));
    Ve.writechunk = null, Ve.writecb = null, je != null && this.push(je), fi(Te);
    var Ue = this._readableState;
    Ue.reading = !1, (Ue.needReadable || Ue.length < Ue.highWaterMark) && this._read(Ue.highWaterMark);
  }
  function Me(Te) {
    if (!(this instanceof Me)) return new Me(Te);
    Ae.call(this, Te), this._transformState = {
      afterTransform: Ie.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, Te && (typeof Te.transform == "function" && (this._transform = Te.transform), typeof Te.flush == "function" && (this._flush = Te.flush)), this.on("prefinish", Be);
  }
  function Be() {
    var Te = this;
    typeof this._flush == "function" ? this._flush(function(je, Ve) {
      Pe(Te, je, Ve);
    }) : Pe(this, null, null);
  }
  Me.prototype.push = function(Te, je) {
    return this._transformState.needTransform = !1, Ae.prototype.push.call(this, Te, je);
  }, Me.prototype._transform = function(Te, je, Ve) {
    throw new Error("_transform() is not implemented");
  }, Me.prototype._write = function(Te, je, Ve) {
    var fi = this._transformState;
    if (fi.writecb = Ve, fi.writechunk = Te, fi.writeencoding = je, !fi.transforming) {
      var Ue = this._readableState;
      (fi.needTransform || Ue.needReadable || Ue.length < Ue.highWaterMark) && this._read(Ue.highWaterMark);
    }
  }, Me.prototype._read = function(Te) {
    var je = this._transformState;
    je.writechunk !== null && je.writecb && !je.transforming ? (je.transforming = !0, this._transform(je.writechunk, je.writeencoding, je.afterTransform)) : je.needTransform = !0;
  }, Me.prototype._destroy = function(Te, je) {
    var Ve = this;
    Ae.prototype._destroy.call(this, Te, function(fi) {
      je(fi), Ve.emit("close");
    });
  };
  function Pe(Te, je, Ve) {
    if (je) return Te.emit("error", je);
    if (Ve != null && Te.push(Ve), Te._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (Te._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return Te.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1, _stream_passthrough = Ie;
  var Ae = require_stream_transform(), t = Object.create(requireUtil());
  t.inherits = inherits_browserExports, t.inherits(Ie, Ae);
  function Ie(Me) {
    if (!(this instanceof Ie)) return new Ie(Me);
    Ae.call(this, Me);
  }
  return Ie.prototype._transform = function(Me, Be, Pe) {
    Pe(null, Me);
  }, _stream_passthrough;
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
  return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1, function(Ae, t) {
    t = Ae.exports = require_stream_readable(), t.Stream = t, t.Readable = t, t.Writable = require_stream_writable(), t.Duplex = require_stream_duplex(), t.Transform = require_stream_transform(), t.PassThrough = require_stream_passthrough();
  }(readableBrowser, readableBrowser.exports)), readableBrowser.exports;
}
var sign = { exports: {} }, bn$2 = { exports: {} };
bn$2.exports;
(function(Ae) {
  (function(t, Ie) {
    function Me(Ai, wi) {
      if (!Ai) throw new Error(wi || "Assertion failed");
    }
    function Be(Ai, wi) {
      Ai.super_ = wi;
      var $i = function() {
      };
      $i.prototype = wi.prototype, Ai.prototype = new $i(), Ai.prototype.constructor = Ai;
    }
    function Pe(Ai, wi, $i) {
      if (Pe.isBN(Ai))
        return Ai;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, Ai !== null && ((wi === "le" || wi === "be") && ($i = wi, wi = 10), this._init(Ai || 0, wi || 10, $i || "be"));
    }
    typeof t == "object" ? t.exports = Pe : Ie.BN = Pe, Pe.BN = Pe, Pe.wordSize = 26;
    var Te;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Te = window.Buffer : Te = require$$1$2.Buffer;
    } catch {
    }
    Pe.isBN = function(wi) {
      return wi instanceof Pe ? !0 : wi !== null && typeof wi == "object" && wi.constructor.wordSize === Pe.wordSize && Array.isArray(wi.words);
    }, Pe.max = function(wi, $i) {
      return wi.cmp($i) > 0 ? wi : $i;
    }, Pe.min = function(wi, $i) {
      return wi.cmp($i) < 0 ? wi : $i;
    }, Pe.prototype._init = function(wi, $i, Li) {
      if (typeof wi == "number")
        return this._initNumber(wi, $i, Li);
      if (typeof wi == "object")
        return this._initArray(wi, $i, Li);
      $i === "hex" && ($i = 16), Me($i === ($i | 0) && $i >= 2 && $i <= 36), wi = wi.toString().replace(/\s+/g, "");
      var qi = 0;
      wi[0] === "-" && (qi++, this.negative = 1), qi < wi.length && ($i === 16 ? this._parseHex(wi, qi, Li) : (this._parseBase(wi, $i, qi), Li === "le" && this._initArray(this.toArray(), $i, Li)));
    }, Pe.prototype._initNumber = function(wi, $i, Li) {
      wi < 0 && (this.negative = 1, wi = -wi), wi < 67108864 ? (this.words = [wi & 67108863], this.length = 1) : wi < 4503599627370496 ? (this.words = [
        wi & 67108863,
        wi / 67108864 & 67108863
      ], this.length = 2) : (Me(wi < 9007199254740992), this.words = [
        wi & 67108863,
        wi / 67108864 & 67108863,
        1
      ], this.length = 3), Li === "le" && this._initArray(this.toArray(), $i, Li);
    }, Pe.prototype._initArray = function(wi, $i, Li) {
      if (Me(typeof wi.length == "number"), wi.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(wi.length / 3), this.words = new Array(this.length);
      for (var qi = 0; qi < this.length; qi++)
        this.words[qi] = 0;
      var Ni, Ti, xi = 0;
      if (Li === "be")
        for (qi = wi.length - 1, Ni = 0; qi >= 0; qi -= 3)
          Ti = wi[qi] | wi[qi - 1] << 8 | wi[qi - 2] << 16, this.words[Ni] |= Ti << xi & 67108863, this.words[Ni + 1] = Ti >>> 26 - xi & 67108863, xi += 24, xi >= 26 && (xi -= 26, Ni++);
      else if (Li === "le")
        for (qi = 0, Ni = 0; qi < wi.length; qi += 3)
          Ti = wi[qi] | wi[qi + 1] << 8 | wi[qi + 2] << 16, this.words[Ni] |= Ti << xi & 67108863, this.words[Ni + 1] = Ti >>> 26 - xi & 67108863, xi += 24, xi >= 26 && (xi -= 26, Ni++);
      return this._strip();
    };
    function je(Ai, wi) {
      var $i = Ai.charCodeAt(wi);
      if ($i >= 48 && $i <= 57)
        return $i - 48;
      if ($i >= 65 && $i <= 70)
        return $i - 55;
      if ($i >= 97 && $i <= 102)
        return $i - 87;
      Me(!1, "Invalid character in " + Ai);
    }
    function Ve(Ai, wi, $i) {
      var Li = je(Ai, $i);
      return $i - 1 >= wi && (Li |= je(Ai, $i - 1) << 4), Li;
    }
    Pe.prototype._parseHex = function(wi, $i, Li) {
      this.length = Math.ceil((wi.length - $i) / 6), this.words = new Array(this.length);
      for (var qi = 0; qi < this.length; qi++)
        this.words[qi] = 0;
      var Ni = 0, Ti = 0, xi;
      if (Li === "be")
        for (qi = wi.length - 1; qi >= $i; qi -= 2)
          xi = Ve(wi, $i, qi) << Ni, this.words[Ti] |= xi & 67108863, Ni >= 18 ? (Ni -= 18, Ti += 1, this.words[Ti] |= xi >>> 26) : Ni += 8;
      else {
        var Fi = wi.length - $i;
        for (qi = Fi % 2 === 0 ? $i + 1 : $i; qi < wi.length; qi += 2)
          xi = Ve(wi, $i, qi) << Ni, this.words[Ti] |= xi & 67108863, Ni >= 18 ? (Ni -= 18, Ti += 1, this.words[Ti] |= xi >>> 26) : Ni += 8;
      }
      this._strip();
    };
    function fi(Ai, wi, $i, Li) {
      for (var qi = 0, Ni = 0, Ti = Math.min(Ai.length, $i), xi = wi; xi < Ti; xi++) {
        var Fi = Ai.charCodeAt(xi) - 48;
        qi *= Li, Fi >= 49 ? Ni = Fi - 49 + 10 : Fi >= 17 ? Ni = Fi - 17 + 10 : Ni = Fi, Me(Fi >= 0 && Ni < Li, "Invalid character"), qi += Ni;
      }
      return qi;
    }
    Pe.prototype._parseBase = function(wi, $i, Li) {
      this.words = [0], this.length = 1;
      for (var qi = 0, Ni = 1; Ni <= 67108863; Ni *= $i)
        qi++;
      qi--, Ni = Ni / $i | 0;
      for (var Ti = wi.length - Li, xi = Ti % qi, Fi = Math.min(Ti, Ti - xi) + Li, Si = 0, Vi = Li; Vi < Fi; Vi += qi)
        Si = fi(wi, Vi, Vi + qi, $i), this.imuln(Ni), this.words[0] + Si < 67108864 ? this.words[0] += Si : this._iaddn(Si);
      if (xi !== 0) {
        var ts = 1;
        for (Si = fi(wi, Vi, wi.length, $i), Vi = 0; Vi < xi; Vi++)
          ts *= $i;
        this.imuln(ts), this.words[0] + Si < 67108864 ? this.words[0] += Si : this._iaddn(Si);
      }
      this._strip();
    }, Pe.prototype.copy = function(wi) {
      wi.words = new Array(this.length);
      for (var $i = 0; $i < this.length; $i++)
        wi.words[$i] = this.words[$i];
      wi.length = this.length, wi.negative = this.negative, wi.red = this.red;
    };
    function Ue(Ai, wi) {
      Ai.words = wi.words, Ai.length = wi.length, Ai.negative = wi.negative, Ai.red = wi.red;
    }
    if (Pe.prototype._move = function(wi) {
      Ue(wi, this);
    }, Pe.prototype.clone = function() {
      var wi = new Pe(null);
      return this.copy(wi), wi;
    }, Pe.prototype._expand = function(wi) {
      for (; this.length < wi; )
        this.words[this.length++] = 0;
      return this;
    }, Pe.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, Pe.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        Pe.prototype[Symbol.for("nodejs.util.inspect.custom")] = bi;
      } catch {
        Pe.prototype.inspect = bi;
      }
    else
      Pe.prototype.inspect = bi;
    function bi() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var vi = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], mi = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], _i = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    Pe.prototype.toString = function(wi, $i) {
      wi = wi || 10, $i = $i | 0 || 1;
      var Li;
      if (wi === 16 || wi === "hex") {
        Li = "";
        for (var qi = 0, Ni = 0, Ti = 0; Ti < this.length; Ti++) {
          var xi = this.words[Ti], Fi = ((xi << qi | Ni) & 16777215).toString(16);
          Ni = xi >>> 24 - qi & 16777215, qi += 2, qi >= 26 && (qi -= 26, Ti--), Ni !== 0 || Ti !== this.length - 1 ? Li = vi[6 - Fi.length] + Fi + Li : Li = Fi + Li;
        }
        for (Ni !== 0 && (Li = Ni.toString(16) + Li); Li.length % $i !== 0; )
          Li = "0" + Li;
        return this.negative !== 0 && (Li = "-" + Li), Li;
      }
      if (wi === (wi | 0) && wi >= 2 && wi <= 36) {
        var Si = mi[wi], Vi = _i[wi];
        Li = "";
        var ts = this.clone();
        for (ts.negative = 0; !ts.isZero(); ) {
          var Hi = ts.modrn(Vi).toString(wi);
          ts = ts.idivn(Vi), ts.isZero() ? Li = Hi + Li : Li = vi[Si - Hi.length] + Hi + Li;
        }
        for (this.isZero() && (Li = "0" + Li); Li.length % $i !== 0; )
          Li = "0" + Li;
        return this.negative !== 0 && (Li = "-" + Li), Li;
      }
      Me(!1, "Base should be between 2 and 36");
    }, Pe.prototype.toNumber = function() {
      var wi = this.words[0];
      return this.length === 2 ? wi += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? wi += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && Me(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -wi : wi;
    }, Pe.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, Te && (Pe.prototype.toBuffer = function(wi, $i) {
      return this.toArrayLike(Te, wi, $i);
    }), Pe.prototype.toArray = function(wi, $i) {
      return this.toArrayLike(Array, wi, $i);
    };
    var Ei = function(wi, $i) {
      return wi.allocUnsafe ? wi.allocUnsafe($i) : new wi($i);
    };
    Pe.prototype.toArrayLike = function(wi, $i, Li) {
      this._strip();
      var qi = this.byteLength(), Ni = Li || Math.max(1, qi);
      Me(qi <= Ni, "byte array longer than desired length"), Me(Ni > 0, "Requested array length <= 0");
      var Ti = Ei(wi, Ni), xi = $i === "le" ? "LE" : "BE";
      return this["_toArrayLike" + xi](Ti, qi), Ti;
    }, Pe.prototype._toArrayLikeLE = function(wi, $i) {
      for (var Li = 0, qi = 0, Ni = 0, Ti = 0; Ni < this.length; Ni++) {
        var xi = this.words[Ni] << Ti | qi;
        wi[Li++] = xi & 255, Li < wi.length && (wi[Li++] = xi >> 8 & 255), Li < wi.length && (wi[Li++] = xi >> 16 & 255), Ti === 6 ? (Li < wi.length && (wi[Li++] = xi >> 24 & 255), qi = 0, Ti = 0) : (qi = xi >>> 24, Ti += 2);
      }
      if (Li < wi.length)
        for (wi[Li++] = qi; Li < wi.length; )
          wi[Li++] = 0;
    }, Pe.prototype._toArrayLikeBE = function(wi, $i) {
      for (var Li = wi.length - 1, qi = 0, Ni = 0, Ti = 0; Ni < this.length; Ni++) {
        var xi = this.words[Ni] << Ti | qi;
        wi[Li--] = xi & 255, Li >= 0 && (wi[Li--] = xi >> 8 & 255), Li >= 0 && (wi[Li--] = xi >> 16 & 255), Ti === 6 ? (Li >= 0 && (wi[Li--] = xi >> 24 & 255), qi = 0, Ti = 0) : (qi = xi >>> 24, Ti += 2);
      }
      if (Li >= 0)
        for (wi[Li--] = qi; Li >= 0; )
          wi[Li--] = 0;
    }, Math.clz32 ? Pe.prototype._countBits = function(wi) {
      return 32 - Math.clz32(wi);
    } : Pe.prototype._countBits = function(wi) {
      var $i = wi, Li = 0;
      return $i >= 4096 && (Li += 13, $i >>>= 13), $i >= 64 && (Li += 7, $i >>>= 7), $i >= 8 && (Li += 4, $i >>>= 4), $i >= 2 && (Li += 2, $i >>>= 2), Li + $i;
    }, Pe.prototype._zeroBits = function(wi) {
      if (wi === 0) return 26;
      var $i = wi, Li = 0;
      return $i & 8191 || (Li += 13, $i >>>= 13), $i & 127 || (Li += 7, $i >>>= 7), $i & 15 || (Li += 4, $i >>>= 4), $i & 3 || (Li += 2, $i >>>= 2), $i & 1 || Li++, Li;
    }, Pe.prototype.bitLength = function() {
      var wi = this.words[this.length - 1], $i = this._countBits(wi);
      return (this.length - 1) * 26 + $i;
    };
    function Pi(Ai) {
      for (var wi = new Array(Ai.bitLength()), $i = 0; $i < wi.length; $i++) {
        var Li = $i / 26 | 0, qi = $i % 26;
        wi[$i] = Ai.words[Li] >>> qi & 1;
      }
      return wi;
    }
    Pe.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var wi = 0, $i = 0; $i < this.length; $i++) {
        var Li = this._zeroBits(this.words[$i]);
        if (wi += Li, Li !== 26) break;
      }
      return wi;
    }, Pe.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Pe.prototype.toTwos = function(wi) {
      return this.negative !== 0 ? this.abs().inotn(wi).iaddn(1) : this.clone();
    }, Pe.prototype.fromTwos = function(wi) {
      return this.testn(wi - 1) ? this.notn(wi).iaddn(1).ineg() : this.clone();
    }, Pe.prototype.isNeg = function() {
      return this.negative !== 0;
    }, Pe.prototype.neg = function() {
      return this.clone().ineg();
    }, Pe.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, Pe.prototype.iuor = function(wi) {
      for (; this.length < wi.length; )
        this.words[this.length++] = 0;
      for (var $i = 0; $i < wi.length; $i++)
        this.words[$i] = this.words[$i] | wi.words[$i];
      return this._strip();
    }, Pe.prototype.ior = function(wi) {
      return Me((this.negative | wi.negative) === 0), this.iuor(wi);
    }, Pe.prototype.or = function(wi) {
      return this.length > wi.length ? this.clone().ior(wi) : wi.clone().ior(this);
    }, Pe.prototype.uor = function(wi) {
      return this.length > wi.length ? this.clone().iuor(wi) : wi.clone().iuor(this);
    }, Pe.prototype.iuand = function(wi) {
      var $i;
      this.length > wi.length ? $i = wi : $i = this;
      for (var Li = 0; Li < $i.length; Li++)
        this.words[Li] = this.words[Li] & wi.words[Li];
      return this.length = $i.length, this._strip();
    }, Pe.prototype.iand = function(wi) {
      return Me((this.negative | wi.negative) === 0), this.iuand(wi);
    }, Pe.prototype.and = function(wi) {
      return this.length > wi.length ? this.clone().iand(wi) : wi.clone().iand(this);
    }, Pe.prototype.uand = function(wi) {
      return this.length > wi.length ? this.clone().iuand(wi) : wi.clone().iuand(this);
    }, Pe.prototype.iuxor = function(wi) {
      var $i, Li;
      this.length > wi.length ? ($i = this, Li = wi) : ($i = wi, Li = this);
      for (var qi = 0; qi < Li.length; qi++)
        this.words[qi] = $i.words[qi] ^ Li.words[qi];
      if (this !== $i)
        for (; qi < $i.length; qi++)
          this.words[qi] = $i.words[qi];
      return this.length = $i.length, this._strip();
    }, Pe.prototype.ixor = function(wi) {
      return Me((this.negative | wi.negative) === 0), this.iuxor(wi);
    }, Pe.prototype.xor = function(wi) {
      return this.length > wi.length ? this.clone().ixor(wi) : wi.clone().ixor(this);
    }, Pe.prototype.uxor = function(wi) {
      return this.length > wi.length ? this.clone().iuxor(wi) : wi.clone().iuxor(this);
    }, Pe.prototype.inotn = function(wi) {
      Me(typeof wi == "number" && wi >= 0);
      var $i = Math.ceil(wi / 26) | 0, Li = wi % 26;
      this._expand($i), Li > 0 && $i--;
      for (var qi = 0; qi < $i; qi++)
        this.words[qi] = ~this.words[qi] & 67108863;
      return Li > 0 && (this.words[qi] = ~this.words[qi] & 67108863 >> 26 - Li), this._strip();
    }, Pe.prototype.notn = function(wi) {
      return this.clone().inotn(wi);
    }, Pe.prototype.setn = function(wi, $i) {
      Me(typeof wi == "number" && wi >= 0);
      var Li = wi / 26 | 0, qi = wi % 26;
      return this._expand(Li + 1), $i ? this.words[Li] = this.words[Li] | 1 << qi : this.words[Li] = this.words[Li] & ~(1 << qi), this._strip();
    }, Pe.prototype.iadd = function(wi) {
      var $i;
      if (this.negative !== 0 && wi.negative === 0)
        return this.negative = 0, $i = this.isub(wi), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && wi.negative !== 0)
        return wi.negative = 0, $i = this.isub(wi), wi.negative = 1, $i._normSign();
      var Li, qi;
      this.length > wi.length ? (Li = this, qi = wi) : (Li = wi, qi = this);
      for (var Ni = 0, Ti = 0; Ti < qi.length; Ti++)
        $i = (Li.words[Ti] | 0) + (qi.words[Ti] | 0) + Ni, this.words[Ti] = $i & 67108863, Ni = $i >>> 26;
      for (; Ni !== 0 && Ti < Li.length; Ti++)
        $i = (Li.words[Ti] | 0) + Ni, this.words[Ti] = $i & 67108863, Ni = $i >>> 26;
      if (this.length = Li.length, Ni !== 0)
        this.words[this.length] = Ni, this.length++;
      else if (Li !== this)
        for (; Ti < Li.length; Ti++)
          this.words[Ti] = Li.words[Ti];
      return this;
    }, Pe.prototype.add = function(wi) {
      var $i;
      return wi.negative !== 0 && this.negative === 0 ? (wi.negative = 0, $i = this.sub(wi), wi.negative ^= 1, $i) : wi.negative === 0 && this.negative !== 0 ? (this.negative = 0, $i = wi.sub(this), this.negative = 1, $i) : this.length > wi.length ? this.clone().iadd(wi) : wi.clone().iadd(this);
    }, Pe.prototype.isub = function(wi) {
      if (wi.negative !== 0) {
        wi.negative = 0;
        var $i = this.iadd(wi);
        return wi.negative = 1, $i._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(wi), this.negative = 1, this._normSign();
      var Li = this.cmp(wi);
      if (Li === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var qi, Ni;
      Li > 0 ? (qi = this, Ni = wi) : (qi = wi, Ni = this);
      for (var Ti = 0, xi = 0; xi < Ni.length; xi++)
        $i = (qi.words[xi] | 0) - (Ni.words[xi] | 0) + Ti, Ti = $i >> 26, this.words[xi] = $i & 67108863;
      for (; Ti !== 0 && xi < qi.length; xi++)
        $i = (qi.words[xi] | 0) + Ti, Ti = $i >> 26, this.words[xi] = $i & 67108863;
      if (Ti === 0 && xi < qi.length && qi !== this)
        for (; xi < qi.length; xi++)
          this.words[xi] = qi.words[xi];
      return this.length = Math.max(this.length, xi), qi !== this && (this.negative = 1), this._strip();
    }, Pe.prototype.sub = function(wi) {
      return this.clone().isub(wi);
    };
    function Ii(Ai, wi, $i) {
      $i.negative = wi.negative ^ Ai.negative;
      var Li = Ai.length + wi.length | 0;
      $i.length = Li, Li = Li - 1 | 0;
      var qi = Ai.words[0] | 0, Ni = wi.words[0] | 0, Ti = qi * Ni, xi = Ti & 67108863, Fi = Ti / 67108864 | 0;
      $i.words[0] = xi;
      for (var Si = 1; Si < Li; Si++) {
        for (var Vi = Fi >>> 26, ts = Fi & 67108863, Hi = Math.min(Si, wi.length - 1), fn = Math.max(0, Si - Ai.length + 1); fn <= Hi; fn++) {
          var Bi = Si - fn | 0;
          qi = Ai.words[Bi] | 0, Ni = wi.words[fn] | 0, Ti = qi * Ni + ts, Vi += Ti / 67108864 | 0, ts = Ti & 67108863;
        }
        $i.words[Si] = ts | 0, Fi = Vi | 0;
      }
      return Fi !== 0 ? $i.words[Si] = Fi | 0 : $i.length--, $i._strip();
    }
    var Ci = function(wi, $i, Li) {
      var qi = wi.words, Ni = $i.words, Ti = Li.words, xi = 0, Fi, Si, Vi, ts = qi[0] | 0, Hi = ts & 8191, fn = ts >>> 13, Bi = qi[1] | 0, ki = Bi & 8191, Ji = Bi >>> 13, Ri = qi[2] | 0, ji = Ri & 8191, Gi = Ri >>> 13, is = qi[3] | 0, os = is & 8191, ds = is >>> 13, ps = qi[4] | 0, ea = ps & 8191, ia = ps >>> 13, hs = qi[5] | 0, fa = hs & 8191, gs = hs >>> 13, sa = qi[6] | 0, aa = sa & 8191, Ds = sa >>> 13, ra = qi[7] | 0, ca = ra & 8191, ta = ra >>> 13, oa = qi[8] | 0, da = oa & 8191, Zi = oa >>> 13, Ui = qi[9] | 0, Ki = Ui & 8191, En = Ui >>> 13, ss = Ni[0] | 0, as = ss & 8191, us = ss >>> 13, ua = Ni[1] | 0, ma = ua & 8191, na = ua >>> 13, wa = Ni[2] | 0, ga = wa & 8191, Ea = wa >>> 13, xa = Ni[3] | 0, $a = xa & 8191, la = xa >>> 13, Sa = Ni[4] | 0, Aa = Sa & 8191, ha = Sa >>> 13, Ma = Ni[5] | 0, Da = Ma & 8191, va = Ma >>> 13, Ba = Ni[6] | 0, Pa = Ba & 8191, pa = Ba >>> 13, Ra = Ni[7] | 0, _a = Ra & 8191, ya = Ra >>> 13, qa = Ni[8] | 0, Na = qa & 8191, Ia = qa >>> 13, Fa = Ni[9] | 0, Oa = Fa & 8191, Ta = Fa >>> 13;
      Li.negative = wi.negative ^ $i.negative, Li.length = 19, Fi = Math.imul(Hi, as), Si = Math.imul(Hi, us), Si = Si + Math.imul(fn, as) | 0, Vi = Math.imul(fn, us);
      var Va = (xi + Fi | 0) + ((Si & 8191) << 13) | 0;
      xi = (Vi + (Si >>> 13) | 0) + (Va >>> 26) | 0, Va &= 67108863, Fi = Math.imul(ki, as), Si = Math.imul(ki, us), Si = Si + Math.imul(Ji, as) | 0, Vi = Math.imul(Ji, us), Fi = Fi + Math.imul(Hi, ma) | 0, Si = Si + Math.imul(Hi, na) | 0, Si = Si + Math.imul(fn, ma) | 0, Vi = Vi + Math.imul(fn, na) | 0;
      var Ga = (xi + Fi | 0) + ((Si & 8191) << 13) | 0;
      xi = (Vi + (Si >>> 13) | 0) + (Ga >>> 26) | 0, Ga &= 67108863, Fi = Math.imul(ji, as), Si = Math.imul(ji, us), Si = Si + Math.imul(Gi, as) | 0, Vi = Math.imul(Gi, us), Fi = Fi + Math.imul(ki, ma) | 0, Si = Si + Math.imul(ki, na) | 0, Si = Si + Math.imul(Ji, ma) | 0, Vi = Vi + Math.imul(Ji, na) | 0, Fi = Fi + Math.imul(Hi, ga) | 0, Si = Si + Math.imul(Hi, Ea) | 0, Si = Si + Math.imul(fn, ga) | 0, Vi = Vi + Math.imul(fn, Ea) | 0;
      var Ja = (xi + Fi | 0) + ((Si & 8191) << 13) | 0;
      xi = (Vi + (Si >>> 13) | 0) + (Ja >>> 26) | 0, Ja &= 67108863, Fi = Math.imul(os, as), Si = Math.imul(os, us), Si = Si + Math.imul(ds, as) | 0, Vi = Math.imul(ds, us), Fi = Fi + Math.imul(ji, ma) | 0, Si = Si + Math.imul(ji, na) | 0, Si = Si + Math.imul(Gi, ma) | 0, Vi = Vi + Math.imul(Gi, na) | 0, Fi = Fi + Math.imul(ki, ga) | 0, Si = Si + Math.imul(ki, Ea) | 0, Si = Si + Math.imul(Ji, ga) | 0, Vi = Vi + Math.imul(Ji, Ea) | 0, Fi = Fi + Math.imul(Hi, $a) | 0, Si = Si + Math.imul(Hi, la) | 0, Si = Si + Math.imul(fn, $a) | 0, Vi = Vi + Math.imul(fn, la) | 0;
      var Xa = (xi + Fi | 0) + ((Si & 8191) << 13) | 0;
      xi = (Vi + (Si >>> 13) | 0) + (Xa >>> 26) | 0, Xa &= 67108863, Fi = Math.imul(ea, as), Si = Math.imul(ea, us), Si = Si + Math.imul(ia, as) | 0, Vi = Math.imul(ia, us), Fi = Fi + Math.imul(os, ma) | 0, Si = Si + Math.imul(os, na) | 0, Si = Si + Math.imul(ds, ma) | 0, Vi = Vi + Math.imul(ds, na) | 0, Fi = Fi + Math.imul(ji, ga) | 0, Si = Si + Math.imul(ji, Ea) | 0, Si = Si + Math.imul(Gi, ga) | 0, Vi = Vi + Math.imul(Gi, Ea) | 0, Fi = Fi + Math.imul(ki, $a) | 0, Si = Si + Math.imul(ki, la) | 0, Si = Si + Math.imul(Ji, $a) | 0, Vi = Vi + Math.imul(Ji, la) | 0, Fi = Fi + Math.imul(Hi, Aa) | 0, Si = Si + Math.imul(Hi, ha) | 0, Si = Si + Math.imul(fn, Aa) | 0, Vi = Vi + Math.imul(fn, ha) | 0;
      var ja = (xi + Fi | 0) + ((Si & 8191) << 13) | 0;
      xi = (Vi + (Si >>> 13) | 0) + (ja >>> 26) | 0, ja &= 67108863, Fi = Math.imul(fa, as), Si = Math.imul(fa, us), Si = Si + Math.imul(gs, as) | 0, Vi = Math.imul(gs, us), Fi = Fi + Math.imul(ea, ma) | 0, Si = Si + Math.imul(ea, na) | 0, Si = Si + Math.imul(ia, ma) | 0, Vi = Vi + Math.imul(ia, na) | 0, Fi = Fi + Math.imul(os, ga) | 0, Si = Si + Math.imul(os, Ea) | 0, Si = Si + Math.imul(ds, ga) | 0, Vi = Vi + Math.imul(ds, Ea) | 0, Fi = Fi + Math.imul(ji, $a) | 0, Si = Si + Math.imul(ji, la) | 0, Si = Si + Math.imul(Gi, $a) | 0, Vi = Vi + Math.imul(Gi, la) | 0, Fi = Fi + Math.imul(ki, Aa) | 0, Si = Si + Math.imul(ki, ha) | 0, Si = Si + Math.imul(Ji, Aa) | 0, Vi = Vi + Math.imul(Ji, ha) | 0, Fi = Fi + Math.imul(Hi, Da) | 0, Si = Si + Math.imul(Hi, va) | 0, Si = Si + Math.imul(fn, Da) | 0, Vi = Vi + Math.imul(fn, va) | 0;
      var go = (xi + Fi | 0) + ((Si & 8191) << 13) | 0;
      xi = (Vi + (Si >>> 13) | 0) + (go >>> 26) | 0, go &= 67108863, Fi = Math.imul(aa, as), Si = Math.imul(aa, us), Si = Si + Math.imul(Ds, as) | 0, Vi = Math.imul(Ds, us), Fi = Fi + Math.imul(fa, ma) | 0, Si = Si + Math.imul(fa, na) | 0, Si = Si + Math.imul(gs, ma) | 0, Vi = Vi + Math.imul(gs, na) | 0, Fi = Fi + Math.imul(ea, ga) | 0, Si = Si + Math.imul(ea, Ea) | 0, Si = Si + Math.imul(ia, ga) | 0, Vi = Vi + Math.imul(ia, Ea) | 0, Fi = Fi + Math.imul(os, $a) | 0, Si = Si + Math.imul(os, la) | 0, Si = Si + Math.imul(ds, $a) | 0, Vi = Vi + Math.imul(ds, la) | 0, Fi = Fi + Math.imul(ji, Aa) | 0, Si = Si + Math.imul(ji, ha) | 0, Si = Si + Math.imul(Gi, Aa) | 0, Vi = Vi + Math.imul(Gi, ha) | 0, Fi = Fi + Math.imul(ki, Da) | 0, Si = Si + Math.imul(ki, va) | 0, Si = Si + Math.imul(Ji, Da) | 0, Vi = Vi + Math.imul(Ji, va) | 0, Fi = Fi + Math.imul(Hi, Pa) | 0, Si = Si + Math.imul(Hi, pa) | 0, Si = Si + Math.imul(fn, Pa) | 0, Vi = Vi + Math.imul(fn, pa) | 0;
      var wo = (xi + Fi | 0) + ((Si & 8191) << 13) | 0;
      xi = (Vi + (Si >>> 13) | 0) + (wo >>> 26) | 0, wo &= 67108863, Fi = Math.imul(ca, as), Si = Math.imul(ca, us), Si = Si + Math.imul(ta, as) | 0, Vi = Math.imul(ta, us), Fi = Fi + Math.imul(aa, ma) | 0, Si = Si + Math.imul(aa, na) | 0, Si = Si + Math.imul(Ds, ma) | 0, Vi = Vi + Math.imul(Ds, na) | 0, Fi = Fi + Math.imul(fa, ga) | 0, Si = Si + Math.imul(fa, Ea) | 0, Si = Si + Math.imul(gs, ga) | 0, Vi = Vi + Math.imul(gs, Ea) | 0, Fi = Fi + Math.imul(ea, $a) | 0, Si = Si + Math.imul(ea, la) | 0, Si = Si + Math.imul(ia, $a) | 0, Vi = Vi + Math.imul(ia, la) | 0, Fi = Fi + Math.imul(os, Aa) | 0, Si = Si + Math.imul(os, ha) | 0, Si = Si + Math.imul(ds, Aa) | 0, Vi = Vi + Math.imul(ds, ha) | 0, Fi = Fi + Math.imul(ji, Da) | 0, Si = Si + Math.imul(ji, va) | 0, Si = Si + Math.imul(Gi, Da) | 0, Vi = Vi + Math.imul(Gi, va) | 0, Fi = Fi + Math.imul(ki, Pa) | 0, Si = Si + Math.imul(ki, pa) | 0, Si = Si + Math.imul(Ji, Pa) | 0, Vi = Vi + Math.imul(Ji, pa) | 0, Fi = Fi + Math.imul(Hi, _a) | 0, Si = Si + Math.imul(Hi, ya) | 0, Si = Si + Math.imul(fn, _a) | 0, Vi = Vi + Math.imul(fn, ya) | 0;
      var _o = (xi + Fi | 0) + ((Si & 8191) << 13) | 0;
      xi = (Vi + (Si >>> 13) | 0) + (_o >>> 26) | 0, _o &= 67108863, Fi = Math.imul(da, as), Si = Math.imul(da, us), Si = Si + Math.imul(Zi, as) | 0, Vi = Math.imul(Zi, us), Fi = Fi + Math.imul(ca, ma) | 0, Si = Si + Math.imul(ca, na) | 0, Si = Si + Math.imul(ta, ma) | 0, Vi = Vi + Math.imul(ta, na) | 0, Fi = Fi + Math.imul(aa, ga) | 0, Si = Si + Math.imul(aa, Ea) | 0, Si = Si + Math.imul(Ds, ga) | 0, Vi = Vi + Math.imul(Ds, Ea) | 0, Fi = Fi + Math.imul(fa, $a) | 0, Si = Si + Math.imul(fa, la) | 0, Si = Si + Math.imul(gs, $a) | 0, Vi = Vi + Math.imul(gs, la) | 0, Fi = Fi + Math.imul(ea, Aa) | 0, Si = Si + Math.imul(ea, ha) | 0, Si = Si + Math.imul(ia, Aa) | 0, Vi = Vi + Math.imul(ia, ha) | 0, Fi = Fi + Math.imul(os, Da) | 0, Si = Si + Math.imul(os, va) | 0, Si = Si + Math.imul(ds, Da) | 0, Vi = Vi + Math.imul(ds, va) | 0, Fi = Fi + Math.imul(ji, Pa) | 0, Si = Si + Math.imul(ji, pa) | 0, Si = Si + Math.imul(Gi, Pa) | 0, Vi = Vi + Math.imul(Gi, pa) | 0, Fi = Fi + Math.imul(ki, _a) | 0, Si = Si + Math.imul(ki, ya) | 0, Si = Si + Math.imul(Ji, _a) | 0, Vi = Vi + Math.imul(Ji, ya) | 0, Fi = Fi + Math.imul(Hi, Na) | 0, Si = Si + Math.imul(Hi, Ia) | 0, Si = Si + Math.imul(fn, Na) | 0, Vi = Vi + Math.imul(fn, Ia) | 0;
      var Eo = (xi + Fi | 0) + ((Si & 8191) << 13) | 0;
      xi = (Vi + (Si >>> 13) | 0) + (Eo >>> 26) | 0, Eo &= 67108863, Fi = Math.imul(Ki, as), Si = Math.imul(Ki, us), Si = Si + Math.imul(En, as) | 0, Vi = Math.imul(En, us), Fi = Fi + Math.imul(da, ma) | 0, Si = Si + Math.imul(da, na) | 0, Si = Si + Math.imul(Zi, ma) | 0, Vi = Vi + Math.imul(Zi, na) | 0, Fi = Fi + Math.imul(ca, ga) | 0, Si = Si + Math.imul(ca, Ea) | 0, Si = Si + Math.imul(ta, ga) | 0, Vi = Vi + Math.imul(ta, Ea) | 0, Fi = Fi + Math.imul(aa, $a) | 0, Si = Si + Math.imul(aa, la) | 0, Si = Si + Math.imul(Ds, $a) | 0, Vi = Vi + Math.imul(Ds, la) | 0, Fi = Fi + Math.imul(fa, Aa) | 0, Si = Si + Math.imul(fa, ha) | 0, Si = Si + Math.imul(gs, Aa) | 0, Vi = Vi + Math.imul(gs, ha) | 0, Fi = Fi + Math.imul(ea, Da) | 0, Si = Si + Math.imul(ea, va) | 0, Si = Si + Math.imul(ia, Da) | 0, Vi = Vi + Math.imul(ia, va) | 0, Fi = Fi + Math.imul(os, Pa) | 0, Si = Si + Math.imul(os, pa) | 0, Si = Si + Math.imul(ds, Pa) | 0, Vi = Vi + Math.imul(ds, pa) | 0, Fi = Fi + Math.imul(ji, _a) | 0, Si = Si + Math.imul(ji, ya) | 0, Si = Si + Math.imul(Gi, _a) | 0, Vi = Vi + Math.imul(Gi, ya) | 0, Fi = Fi + Math.imul(ki, Na) | 0, Si = Si + Math.imul(ki, Ia) | 0, Si = Si + Math.imul(Ji, Na) | 0, Vi = Vi + Math.imul(Ji, Ia) | 0, Fi = Fi + Math.imul(Hi, Oa) | 0, Si = Si + Math.imul(Hi, Ta) | 0, Si = Si + Math.imul(fn, Oa) | 0, Vi = Vi + Math.imul(fn, Ta) | 0;
      var $o = (xi + Fi | 0) + ((Si & 8191) << 13) | 0;
      xi = (Vi + (Si >>> 13) | 0) + ($o >>> 26) | 0, $o &= 67108863, Fi = Math.imul(Ki, ma), Si = Math.imul(Ki, na), Si = Si + Math.imul(En, ma) | 0, Vi = Math.imul(En, na), Fi = Fi + Math.imul(da, ga) | 0, Si = Si + Math.imul(da, Ea) | 0, Si = Si + Math.imul(Zi, ga) | 0, Vi = Vi + Math.imul(Zi, Ea) | 0, Fi = Fi + Math.imul(ca, $a) | 0, Si = Si + Math.imul(ca, la) | 0, Si = Si + Math.imul(ta, $a) | 0, Vi = Vi + Math.imul(ta, la) | 0, Fi = Fi + Math.imul(aa, Aa) | 0, Si = Si + Math.imul(aa, ha) | 0, Si = Si + Math.imul(Ds, Aa) | 0, Vi = Vi + Math.imul(Ds, ha) | 0, Fi = Fi + Math.imul(fa, Da) | 0, Si = Si + Math.imul(fa, va) | 0, Si = Si + Math.imul(gs, Da) | 0, Vi = Vi + Math.imul(gs, va) | 0, Fi = Fi + Math.imul(ea, Pa) | 0, Si = Si + Math.imul(ea, pa) | 0, Si = Si + Math.imul(ia, Pa) | 0, Vi = Vi + Math.imul(ia, pa) | 0, Fi = Fi + Math.imul(os, _a) | 0, Si = Si + Math.imul(os, ya) | 0, Si = Si + Math.imul(ds, _a) | 0, Vi = Vi + Math.imul(ds, ya) | 0, Fi = Fi + Math.imul(ji, Na) | 0, Si = Si + Math.imul(ji, Ia) | 0, Si = Si + Math.imul(Gi, Na) | 0, Vi = Vi + Math.imul(Gi, Ia) | 0, Fi = Fi + Math.imul(ki, Oa) | 0, Si = Si + Math.imul(ki, Ta) | 0, Si = Si + Math.imul(Ji, Oa) | 0, Vi = Vi + Math.imul(Ji, Ta) | 0;
      var Za = (xi + Fi | 0) + ((Si & 8191) << 13) | 0;
      xi = (Vi + (Si >>> 13) | 0) + (Za >>> 26) | 0, Za &= 67108863, Fi = Math.imul(Ki, ga), Si = Math.imul(Ki, Ea), Si = Si + Math.imul(En, ga) | 0, Vi = Math.imul(En, Ea), Fi = Fi + Math.imul(da, $a) | 0, Si = Si + Math.imul(da, la) | 0, Si = Si + Math.imul(Zi, $a) | 0, Vi = Vi + Math.imul(Zi, la) | 0, Fi = Fi + Math.imul(ca, Aa) | 0, Si = Si + Math.imul(ca, ha) | 0, Si = Si + Math.imul(ta, Aa) | 0, Vi = Vi + Math.imul(ta, ha) | 0, Fi = Fi + Math.imul(aa, Da) | 0, Si = Si + Math.imul(aa, va) | 0, Si = Si + Math.imul(Ds, Da) | 0, Vi = Vi + Math.imul(Ds, va) | 0, Fi = Fi + Math.imul(fa, Pa) | 0, Si = Si + Math.imul(fa, pa) | 0, Si = Si + Math.imul(gs, Pa) | 0, Vi = Vi + Math.imul(gs, pa) | 0, Fi = Fi + Math.imul(ea, _a) | 0, Si = Si + Math.imul(ea, ya) | 0, Si = Si + Math.imul(ia, _a) | 0, Vi = Vi + Math.imul(ia, ya) | 0, Fi = Fi + Math.imul(os, Na) | 0, Si = Si + Math.imul(os, Ia) | 0, Si = Si + Math.imul(ds, Na) | 0, Vi = Vi + Math.imul(ds, Ia) | 0, Fi = Fi + Math.imul(ji, Oa) | 0, Si = Si + Math.imul(ji, Ta) | 0, Si = Si + Math.imul(Gi, Oa) | 0, Vi = Vi + Math.imul(Gi, Ta) | 0;
      var xo = (xi + Fi | 0) + ((Si & 8191) << 13) | 0;
      xi = (Vi + (Si >>> 13) | 0) + (xo >>> 26) | 0, xo &= 67108863, Fi = Math.imul(Ki, $a), Si = Math.imul(Ki, la), Si = Si + Math.imul(En, $a) | 0, Vi = Math.imul(En, la), Fi = Fi + Math.imul(da, Aa) | 0, Si = Si + Math.imul(da, ha) | 0, Si = Si + Math.imul(Zi, Aa) | 0, Vi = Vi + Math.imul(Zi, ha) | 0, Fi = Fi + Math.imul(ca, Da) | 0, Si = Si + Math.imul(ca, va) | 0, Si = Si + Math.imul(ta, Da) | 0, Vi = Vi + Math.imul(ta, va) | 0, Fi = Fi + Math.imul(aa, Pa) | 0, Si = Si + Math.imul(aa, pa) | 0, Si = Si + Math.imul(Ds, Pa) | 0, Vi = Vi + Math.imul(Ds, pa) | 0, Fi = Fi + Math.imul(fa, _a) | 0, Si = Si + Math.imul(fa, ya) | 0, Si = Si + Math.imul(gs, _a) | 0, Vi = Vi + Math.imul(gs, ya) | 0, Fi = Fi + Math.imul(ea, Na) | 0, Si = Si + Math.imul(ea, Ia) | 0, Si = Si + Math.imul(ia, Na) | 0, Vi = Vi + Math.imul(ia, Ia) | 0, Fi = Fi + Math.imul(os, Oa) | 0, Si = Si + Math.imul(os, Ta) | 0, Si = Si + Math.imul(ds, Oa) | 0, Vi = Vi + Math.imul(ds, Ta) | 0;
      var So = (xi + Fi | 0) + ((Si & 8191) << 13) | 0;
      xi = (Vi + (Si >>> 13) | 0) + (So >>> 26) | 0, So &= 67108863, Fi = Math.imul(Ki, Aa), Si = Math.imul(Ki, ha), Si = Si + Math.imul(En, Aa) | 0, Vi = Math.imul(En, ha), Fi = Fi + Math.imul(da, Da) | 0, Si = Si + Math.imul(da, va) | 0, Si = Si + Math.imul(Zi, Da) | 0, Vi = Vi + Math.imul(Zi, va) | 0, Fi = Fi + Math.imul(ca, Pa) | 0, Si = Si + Math.imul(ca, pa) | 0, Si = Si + Math.imul(ta, Pa) | 0, Vi = Vi + Math.imul(ta, pa) | 0, Fi = Fi + Math.imul(aa, _a) | 0, Si = Si + Math.imul(aa, ya) | 0, Si = Si + Math.imul(Ds, _a) | 0, Vi = Vi + Math.imul(Ds, ya) | 0, Fi = Fi + Math.imul(fa, Na) | 0, Si = Si + Math.imul(fa, Ia) | 0, Si = Si + Math.imul(gs, Na) | 0, Vi = Vi + Math.imul(gs, Ia) | 0, Fi = Fi + Math.imul(ea, Oa) | 0, Si = Si + Math.imul(ea, Ta) | 0, Si = Si + Math.imul(ia, Oa) | 0, Vi = Vi + Math.imul(ia, Ta) | 0;
      var Ha = (xi + Fi | 0) + ((Si & 8191) << 13) | 0;
      xi = (Vi + (Si >>> 13) | 0) + (Ha >>> 26) | 0, Ha &= 67108863, Fi = Math.imul(Ki, Da), Si = Math.imul(Ki, va), Si = Si + Math.imul(En, Da) | 0, Vi = Math.imul(En, va), Fi = Fi + Math.imul(da, Pa) | 0, Si = Si + Math.imul(da, pa) | 0, Si = Si + Math.imul(Zi, Pa) | 0, Vi = Vi + Math.imul(Zi, pa) | 0, Fi = Fi + Math.imul(ca, _a) | 0, Si = Si + Math.imul(ca, ya) | 0, Si = Si + Math.imul(ta, _a) | 0, Vi = Vi + Math.imul(ta, ya) | 0, Fi = Fi + Math.imul(aa, Na) | 0, Si = Si + Math.imul(aa, Ia) | 0, Si = Si + Math.imul(Ds, Na) | 0, Vi = Vi + Math.imul(Ds, Ia) | 0, Fi = Fi + Math.imul(fa, Oa) | 0, Si = Si + Math.imul(fa, Ta) | 0, Si = Si + Math.imul(gs, Oa) | 0, Vi = Vi + Math.imul(gs, Ta) | 0;
      var Ao = (xi + Fi | 0) + ((Si & 8191) << 13) | 0;
      xi = (Vi + (Si >>> 13) | 0) + (Ao >>> 26) | 0, Ao &= 67108863, Fi = Math.imul(Ki, Pa), Si = Math.imul(Ki, pa), Si = Si + Math.imul(En, Pa) | 0, Vi = Math.imul(En, pa), Fi = Fi + Math.imul(da, _a) | 0, Si = Si + Math.imul(da, ya) | 0, Si = Si + Math.imul(Zi, _a) | 0, Vi = Vi + Math.imul(Zi, ya) | 0, Fi = Fi + Math.imul(ca, Na) | 0, Si = Si + Math.imul(ca, Ia) | 0, Si = Si + Math.imul(ta, Na) | 0, Vi = Vi + Math.imul(ta, Ia) | 0, Fi = Fi + Math.imul(aa, Oa) | 0, Si = Si + Math.imul(aa, Ta) | 0, Si = Si + Math.imul(Ds, Oa) | 0, Vi = Vi + Math.imul(Ds, Ta) | 0;
      var Ro = (xi + Fi | 0) + ((Si & 8191) << 13) | 0;
      xi = (Vi + (Si >>> 13) | 0) + (Ro >>> 26) | 0, Ro &= 67108863, Fi = Math.imul(Ki, _a), Si = Math.imul(Ki, ya), Si = Si + Math.imul(En, _a) | 0, Vi = Math.imul(En, ya), Fi = Fi + Math.imul(da, Na) | 0, Si = Si + Math.imul(da, Ia) | 0, Si = Si + Math.imul(Zi, Na) | 0, Vi = Vi + Math.imul(Zi, Ia) | 0, Fi = Fi + Math.imul(ca, Oa) | 0, Si = Si + Math.imul(ca, Ta) | 0, Si = Si + Math.imul(ta, Oa) | 0, Vi = Vi + Math.imul(ta, Ta) | 0;
      var Io = (xi + Fi | 0) + ((Si & 8191) << 13) | 0;
      xi = (Vi + (Si >>> 13) | 0) + (Io >>> 26) | 0, Io &= 67108863, Fi = Math.imul(Ki, Na), Si = Math.imul(Ki, Ia), Si = Si + Math.imul(En, Na) | 0, Vi = Math.imul(En, Ia), Fi = Fi + Math.imul(da, Oa) | 0, Si = Si + Math.imul(da, Ta) | 0, Si = Si + Math.imul(Zi, Oa) | 0, Vi = Vi + Math.imul(Zi, Ta) | 0;
      var Oo = (xi + Fi | 0) + ((Si & 8191) << 13) | 0;
      xi = (Vi + (Si >>> 13) | 0) + (Oo >>> 26) | 0, Oo &= 67108863, Fi = Math.imul(Ki, Oa), Si = Math.imul(Ki, Ta), Si = Si + Math.imul(En, Oa) | 0, Vi = Math.imul(En, Ta);
      var To = (xi + Fi | 0) + ((Si & 8191) << 13) | 0;
      return xi = (Vi + (Si >>> 13) | 0) + (To >>> 26) | 0, To &= 67108863, Ti[0] = Va, Ti[1] = Ga, Ti[2] = Ja, Ti[3] = Xa, Ti[4] = ja, Ti[5] = go, Ti[6] = wo, Ti[7] = _o, Ti[8] = Eo, Ti[9] = $o, Ti[10] = Za, Ti[11] = xo, Ti[12] = So, Ti[13] = Ha, Ti[14] = Ao, Ti[15] = Ro, Ti[16] = Io, Ti[17] = Oo, Ti[18] = To, xi !== 0 && (Ti[19] = xi, Li.length++), Li;
    };
    Math.imul || (Ci = Ii);
    function Wi(Ai, wi, $i) {
      $i.negative = wi.negative ^ Ai.negative, $i.length = Ai.length + wi.length;
      for (var Li = 0, qi = 0, Ni = 0; Ni < $i.length - 1; Ni++) {
        var Ti = qi;
        qi = 0;
        for (var xi = Li & 67108863, Fi = Math.min(Ni, wi.length - 1), Si = Math.max(0, Ni - Ai.length + 1); Si <= Fi; Si++) {
          var Vi = Ni - Si, ts = Ai.words[Vi] | 0, Hi = wi.words[Si] | 0, fn = ts * Hi, Bi = fn & 67108863;
          Ti = Ti + (fn / 67108864 | 0) | 0, Bi = Bi + xi | 0, xi = Bi & 67108863, Ti = Ti + (Bi >>> 26) | 0, qi += Ti >>> 26, Ti &= 67108863;
        }
        $i.words[Ni] = xi, Li = Ti, Ti = qi;
      }
      return Li !== 0 ? $i.words[Ni] = Li : $i.length--, $i._strip();
    }
    function zi(Ai, wi, $i) {
      return Wi(Ai, wi, $i);
    }
    Pe.prototype.mulTo = function(wi, $i) {
      var Li, qi = this.length + wi.length;
      return this.length === 10 && wi.length === 10 ? Li = Ci(this, wi, $i) : qi < 63 ? Li = Ii(this, wi, $i) : qi < 1024 ? Li = Wi(this, wi, $i) : Li = zi(this, wi, $i), Li;
    }, Pe.prototype.mul = function(wi) {
      var $i = new Pe(null);
      return $i.words = new Array(this.length + wi.length), this.mulTo(wi, $i);
    }, Pe.prototype.mulf = function(wi) {
      var $i = new Pe(null);
      return $i.words = new Array(this.length + wi.length), zi(this, wi, $i);
    }, Pe.prototype.imul = function(wi) {
      return this.clone().mulTo(wi, this);
    }, Pe.prototype.imuln = function(wi) {
      var $i = wi < 0;
      $i && (wi = -wi), Me(typeof wi == "number"), Me(wi < 67108864);
      for (var Li = 0, qi = 0; qi < this.length; qi++) {
        var Ni = (this.words[qi] | 0) * wi, Ti = (Ni & 67108863) + (Li & 67108863);
        Li >>= 26, Li += Ni / 67108864 | 0, Li += Ti >>> 26, this.words[qi] = Ti & 67108863;
      }
      return Li !== 0 && (this.words[qi] = Li, this.length++), $i ? this.ineg() : this;
    }, Pe.prototype.muln = function(wi) {
      return this.clone().imuln(wi);
    }, Pe.prototype.sqr = function() {
      return this.mul(this);
    }, Pe.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Pe.prototype.pow = function(wi) {
      var $i = Pi(wi);
      if ($i.length === 0) return new Pe(1);
      for (var Li = this, qi = 0; qi < $i.length && $i[qi] === 0; qi++, Li = Li.sqr())
        ;
      if (++qi < $i.length)
        for (var Ni = Li.sqr(); qi < $i.length; qi++, Ni = Ni.sqr())
          $i[qi] !== 0 && (Li = Li.mul(Ni));
      return Li;
    }, Pe.prototype.iushln = function(wi) {
      Me(typeof wi == "number" && wi >= 0);
      var $i = wi % 26, Li = (wi - $i) / 26, qi = 67108863 >>> 26 - $i << 26 - $i, Ni;
      if ($i !== 0) {
        var Ti = 0;
        for (Ni = 0; Ni < this.length; Ni++) {
          var xi = this.words[Ni] & qi, Fi = (this.words[Ni] | 0) - xi << $i;
          this.words[Ni] = Fi | Ti, Ti = xi >>> 26 - $i;
        }
        Ti && (this.words[Ni] = Ti, this.length++);
      }
      if (Li !== 0) {
        for (Ni = this.length - 1; Ni >= 0; Ni--)
          this.words[Ni + Li] = this.words[Ni];
        for (Ni = 0; Ni < Li; Ni++)
          this.words[Ni] = 0;
        this.length += Li;
      }
      return this._strip();
    }, Pe.prototype.ishln = function(wi) {
      return Me(this.negative === 0), this.iushln(wi);
    }, Pe.prototype.iushrn = function(wi, $i, Li) {
      Me(typeof wi == "number" && wi >= 0);
      var qi;
      $i ? qi = ($i - $i % 26) / 26 : qi = 0;
      var Ni = wi % 26, Ti = Math.min((wi - Ni) / 26, this.length), xi = 67108863 ^ 67108863 >>> Ni << Ni, Fi = Li;
      if (qi -= Ti, qi = Math.max(0, qi), Fi) {
        for (var Si = 0; Si < Ti; Si++)
          Fi.words[Si] = this.words[Si];
        Fi.length = Ti;
      }
      if (Ti !== 0) if (this.length > Ti)
        for (this.length -= Ti, Si = 0; Si < this.length; Si++)
          this.words[Si] = this.words[Si + Ti];
      else
        this.words[0] = 0, this.length = 1;
      var Vi = 0;
      for (Si = this.length - 1; Si >= 0 && (Vi !== 0 || Si >= qi); Si--) {
        var ts = this.words[Si] | 0;
        this.words[Si] = Vi << 26 - Ni | ts >>> Ni, Vi = ts & xi;
      }
      return Fi && Vi !== 0 && (Fi.words[Fi.length++] = Vi), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, Pe.prototype.ishrn = function(wi, $i, Li) {
      return Me(this.negative === 0), this.iushrn(wi, $i, Li);
    }, Pe.prototype.shln = function(wi) {
      return this.clone().ishln(wi);
    }, Pe.prototype.ushln = function(wi) {
      return this.clone().iushln(wi);
    }, Pe.prototype.shrn = function(wi) {
      return this.clone().ishrn(wi);
    }, Pe.prototype.ushrn = function(wi) {
      return this.clone().iushrn(wi);
    }, Pe.prototype.testn = function(wi) {
      Me(typeof wi == "number" && wi >= 0);
      var $i = wi % 26, Li = (wi - $i) / 26, qi = 1 << $i;
      if (this.length <= Li) return !1;
      var Ni = this.words[Li];
      return !!(Ni & qi);
    }, Pe.prototype.imaskn = function(wi) {
      Me(typeof wi == "number" && wi >= 0);
      var $i = wi % 26, Li = (wi - $i) / 26;
      if (Me(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Li)
        return this;
      if ($i !== 0 && Li++, this.length = Math.min(Li, this.length), $i !== 0) {
        var qi = 67108863 ^ 67108863 >>> $i << $i;
        this.words[this.length - 1] &= qi;
      }
      return this._strip();
    }, Pe.prototype.maskn = function(wi) {
      return this.clone().imaskn(wi);
    }, Pe.prototype.iaddn = function(wi) {
      return Me(typeof wi == "number"), Me(wi < 67108864), wi < 0 ? this.isubn(-wi) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= wi ? (this.words[0] = wi - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(wi), this.negative = 1, this) : this._iaddn(wi);
    }, Pe.prototype._iaddn = function(wi) {
      this.words[0] += wi;
      for (var $i = 0; $i < this.length && this.words[$i] >= 67108864; $i++)
        this.words[$i] -= 67108864, $i === this.length - 1 ? this.words[$i + 1] = 1 : this.words[$i + 1]++;
      return this.length = Math.max(this.length, $i + 1), this;
    }, Pe.prototype.isubn = function(wi) {
      if (Me(typeof wi == "number"), Me(wi < 67108864), wi < 0) return this.iaddn(-wi);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(wi), this.negative = 1, this;
      if (this.words[0] -= wi, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var $i = 0; $i < this.length && this.words[$i] < 0; $i++)
          this.words[$i] += 67108864, this.words[$i + 1] -= 1;
      return this._strip();
    }, Pe.prototype.addn = function(wi) {
      return this.clone().iaddn(wi);
    }, Pe.prototype.subn = function(wi) {
      return this.clone().isubn(wi);
    }, Pe.prototype.iabs = function() {
      return this.negative = 0, this;
    }, Pe.prototype.abs = function() {
      return this.clone().iabs();
    }, Pe.prototype._ishlnsubmul = function(wi, $i, Li) {
      var qi = wi.length + Li, Ni;
      this._expand(qi);
      var Ti, xi = 0;
      for (Ni = 0; Ni < wi.length; Ni++) {
        Ti = (this.words[Ni + Li] | 0) + xi;
        var Fi = (wi.words[Ni] | 0) * $i;
        Ti -= Fi & 67108863, xi = (Ti >> 26) - (Fi / 67108864 | 0), this.words[Ni + Li] = Ti & 67108863;
      }
      for (; Ni < this.length - Li; Ni++)
        Ti = (this.words[Ni + Li] | 0) + xi, xi = Ti >> 26, this.words[Ni + Li] = Ti & 67108863;
      if (xi === 0) return this._strip();
      for (Me(xi === -1), xi = 0, Ni = 0; Ni < this.length; Ni++)
        Ti = -(this.words[Ni] | 0) + xi, xi = Ti >> 26, this.words[Ni] = Ti & 67108863;
      return this.negative = 1, this._strip();
    }, Pe.prototype._wordDiv = function(wi, $i) {
      var Li = this.length - wi.length, qi = this.clone(), Ni = wi, Ti = Ni.words[Ni.length - 1] | 0, xi = this._countBits(Ti);
      Li = 26 - xi, Li !== 0 && (Ni = Ni.ushln(Li), qi.iushln(Li), Ti = Ni.words[Ni.length - 1] | 0);
      var Fi = qi.length - Ni.length, Si;
      if ($i !== "mod") {
        Si = new Pe(null), Si.length = Fi + 1, Si.words = new Array(Si.length);
        for (var Vi = 0; Vi < Si.length; Vi++)
          Si.words[Vi] = 0;
      }
      var ts = qi.clone()._ishlnsubmul(Ni, 1, Fi);
      ts.negative === 0 && (qi = ts, Si && (Si.words[Fi] = 1));
      for (var Hi = Fi - 1; Hi >= 0; Hi--) {
        var fn = (qi.words[Ni.length + Hi] | 0) * 67108864 + (qi.words[Ni.length + Hi - 1] | 0);
        for (fn = Math.min(fn / Ti | 0, 67108863), qi._ishlnsubmul(Ni, fn, Hi); qi.negative !== 0; )
          fn--, qi.negative = 0, qi._ishlnsubmul(Ni, 1, Hi), qi.isZero() || (qi.negative ^= 1);
        Si && (Si.words[Hi] = fn);
      }
      return Si && Si._strip(), qi._strip(), $i !== "div" && Li !== 0 && qi.iushrn(Li), {
        div: Si || null,
        mod: qi
      };
    }, Pe.prototype.divmod = function(wi, $i, Li) {
      if (Me(!wi.isZero()), this.isZero())
        return {
          div: new Pe(0),
          mod: new Pe(0)
        };
      var qi, Ni, Ti;
      return this.negative !== 0 && wi.negative === 0 ? (Ti = this.neg().divmod(wi, $i), $i !== "mod" && (qi = Ti.div.neg()), $i !== "div" && (Ni = Ti.mod.neg(), Li && Ni.negative !== 0 && Ni.iadd(wi)), {
        div: qi,
        mod: Ni
      }) : this.negative === 0 && wi.negative !== 0 ? (Ti = this.divmod(wi.neg(), $i), $i !== "mod" && (qi = Ti.div.neg()), {
        div: qi,
        mod: Ti.mod
      }) : this.negative & wi.negative ? (Ti = this.neg().divmod(wi.neg(), $i), $i !== "div" && (Ni = Ti.mod.neg(), Li && Ni.negative !== 0 && Ni.isub(wi)), {
        div: Ti.div,
        mod: Ni
      }) : wi.length > this.length || this.cmp(wi) < 0 ? {
        div: new Pe(0),
        mod: this
      } : wi.length === 1 ? $i === "div" ? {
        div: this.divn(wi.words[0]),
        mod: null
      } : $i === "mod" ? {
        div: null,
        mod: new Pe(this.modrn(wi.words[0]))
      } : {
        div: this.divn(wi.words[0]),
        mod: new Pe(this.modrn(wi.words[0]))
      } : this._wordDiv(wi, $i);
    }, Pe.prototype.div = function(wi) {
      return this.divmod(wi, "div", !1).div;
    }, Pe.prototype.mod = function(wi) {
      return this.divmod(wi, "mod", !1).mod;
    }, Pe.prototype.umod = function(wi) {
      return this.divmod(wi, "mod", !0).mod;
    }, Pe.prototype.divRound = function(wi) {
      var $i = this.divmod(wi);
      if ($i.mod.isZero()) return $i.div;
      var Li = $i.div.negative !== 0 ? $i.mod.isub(wi) : $i.mod, qi = wi.ushrn(1), Ni = wi.andln(1), Ti = Li.cmp(qi);
      return Ti < 0 || Ni === 1 && Ti === 0 ? $i.div : $i.div.negative !== 0 ? $i.div.isubn(1) : $i.div.iaddn(1);
    }, Pe.prototype.modrn = function(wi) {
      var $i = wi < 0;
      $i && (wi = -wi), Me(wi <= 67108863);
      for (var Li = (1 << 26) % wi, qi = 0, Ni = this.length - 1; Ni >= 0; Ni--)
        qi = (Li * qi + (this.words[Ni] | 0)) % wi;
      return $i ? -qi : qi;
    }, Pe.prototype.modn = function(wi) {
      return this.modrn(wi);
    }, Pe.prototype.idivn = function(wi) {
      var $i = wi < 0;
      $i && (wi = -wi), Me(wi <= 67108863);
      for (var Li = 0, qi = this.length - 1; qi >= 0; qi--) {
        var Ni = (this.words[qi] | 0) + Li * 67108864;
        this.words[qi] = Ni / wi | 0, Li = Ni % wi;
      }
      return this._strip(), $i ? this.ineg() : this;
    }, Pe.prototype.divn = function(wi) {
      return this.clone().idivn(wi);
    }, Pe.prototype.egcd = function(wi) {
      Me(wi.negative === 0), Me(!wi.isZero());
      var $i = this, Li = wi.clone();
      $i.negative !== 0 ? $i = $i.umod(wi) : $i = $i.clone();
      for (var qi = new Pe(1), Ni = new Pe(0), Ti = new Pe(0), xi = new Pe(1), Fi = 0; $i.isEven() && Li.isEven(); )
        $i.iushrn(1), Li.iushrn(1), ++Fi;
      for (var Si = Li.clone(), Vi = $i.clone(); !$i.isZero(); ) {
        for (var ts = 0, Hi = 1; !($i.words[0] & Hi) && ts < 26; ++ts, Hi <<= 1) ;
        if (ts > 0)
          for ($i.iushrn(ts); ts-- > 0; )
            (qi.isOdd() || Ni.isOdd()) && (qi.iadd(Si), Ni.isub(Vi)), qi.iushrn(1), Ni.iushrn(1);
        for (var fn = 0, Bi = 1; !(Li.words[0] & Bi) && fn < 26; ++fn, Bi <<= 1) ;
        if (fn > 0)
          for (Li.iushrn(fn); fn-- > 0; )
            (Ti.isOdd() || xi.isOdd()) && (Ti.iadd(Si), xi.isub(Vi)), Ti.iushrn(1), xi.iushrn(1);
        $i.cmp(Li) >= 0 ? ($i.isub(Li), qi.isub(Ti), Ni.isub(xi)) : (Li.isub($i), Ti.isub(qi), xi.isub(Ni));
      }
      return {
        a: Ti,
        b: xi,
        gcd: Li.iushln(Fi)
      };
    }, Pe.prototype._invmp = function(wi) {
      Me(wi.negative === 0), Me(!wi.isZero());
      var $i = this, Li = wi.clone();
      $i.negative !== 0 ? $i = $i.umod(wi) : $i = $i.clone();
      for (var qi = new Pe(1), Ni = new Pe(0), Ti = Li.clone(); $i.cmpn(1) > 0 && Li.cmpn(1) > 0; ) {
        for (var xi = 0, Fi = 1; !($i.words[0] & Fi) && xi < 26; ++xi, Fi <<= 1) ;
        if (xi > 0)
          for ($i.iushrn(xi); xi-- > 0; )
            qi.isOdd() && qi.iadd(Ti), qi.iushrn(1);
        for (var Si = 0, Vi = 1; !(Li.words[0] & Vi) && Si < 26; ++Si, Vi <<= 1) ;
        if (Si > 0)
          for (Li.iushrn(Si); Si-- > 0; )
            Ni.isOdd() && Ni.iadd(Ti), Ni.iushrn(1);
        $i.cmp(Li) >= 0 ? ($i.isub(Li), qi.isub(Ni)) : (Li.isub($i), Ni.isub(qi));
      }
      var ts;
      return $i.cmpn(1) === 0 ? ts = qi : ts = Ni, ts.cmpn(0) < 0 && ts.iadd(wi), ts;
    }, Pe.prototype.gcd = function(wi) {
      if (this.isZero()) return wi.abs();
      if (wi.isZero()) return this.abs();
      var $i = this.clone(), Li = wi.clone();
      $i.negative = 0, Li.negative = 0;
      for (var qi = 0; $i.isEven() && Li.isEven(); qi++)
        $i.iushrn(1), Li.iushrn(1);
      do {
        for (; $i.isEven(); )
          $i.iushrn(1);
        for (; Li.isEven(); )
          Li.iushrn(1);
        var Ni = $i.cmp(Li);
        if (Ni < 0) {
          var Ti = $i;
          $i = Li, Li = Ti;
        } else if (Ni === 0 || Li.cmpn(1) === 0)
          break;
        $i.isub(Li);
      } while (!0);
      return Li.iushln(qi);
    }, Pe.prototype.invm = function(wi) {
      return this.egcd(wi).a.umod(wi);
    }, Pe.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, Pe.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, Pe.prototype.andln = function(wi) {
      return this.words[0] & wi;
    }, Pe.prototype.bincn = function(wi) {
      Me(typeof wi == "number");
      var $i = wi % 26, Li = (wi - $i) / 26, qi = 1 << $i;
      if (this.length <= Li)
        return this._expand(Li + 1), this.words[Li] |= qi, this;
      for (var Ni = qi, Ti = Li; Ni !== 0 && Ti < this.length; Ti++) {
        var xi = this.words[Ti] | 0;
        xi += Ni, Ni = xi >>> 26, xi &= 67108863, this.words[Ti] = xi;
      }
      return Ni !== 0 && (this.words[Ti] = Ni, this.length++), this;
    }, Pe.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, Pe.prototype.cmpn = function(wi) {
      var $i = wi < 0;
      if (this.negative !== 0 && !$i) return -1;
      if (this.negative === 0 && $i) return 1;
      this._strip();
      var Li;
      if (this.length > 1)
        Li = 1;
      else {
        $i && (wi = -wi), Me(wi <= 67108863, "Number is too big");
        var qi = this.words[0] | 0;
        Li = qi === wi ? 0 : qi < wi ? -1 : 1;
      }
      return this.negative !== 0 ? -Li | 0 : Li;
    }, Pe.prototype.cmp = function(wi) {
      if (this.negative !== 0 && wi.negative === 0) return -1;
      if (this.negative === 0 && wi.negative !== 0) return 1;
      var $i = this.ucmp(wi);
      return this.negative !== 0 ? -$i | 0 : $i;
    }, Pe.prototype.ucmp = function(wi) {
      if (this.length > wi.length) return 1;
      if (this.length < wi.length) return -1;
      for (var $i = 0, Li = this.length - 1; Li >= 0; Li--) {
        var qi = this.words[Li] | 0, Ni = wi.words[Li] | 0;
        if (qi !== Ni) {
          qi < Ni ? $i = -1 : qi > Ni && ($i = 1);
          break;
        }
      }
      return $i;
    }, Pe.prototype.gtn = function(wi) {
      return this.cmpn(wi) === 1;
    }, Pe.prototype.gt = function(wi) {
      return this.cmp(wi) === 1;
    }, Pe.prototype.gten = function(wi) {
      return this.cmpn(wi) >= 0;
    }, Pe.prototype.gte = function(wi) {
      return this.cmp(wi) >= 0;
    }, Pe.prototype.ltn = function(wi) {
      return this.cmpn(wi) === -1;
    }, Pe.prototype.lt = function(wi) {
      return this.cmp(wi) === -1;
    }, Pe.prototype.lten = function(wi) {
      return this.cmpn(wi) <= 0;
    }, Pe.prototype.lte = function(wi) {
      return this.cmp(wi) <= 0;
    }, Pe.prototype.eqn = function(wi) {
      return this.cmpn(wi) === 0;
    }, Pe.prototype.eq = function(wi) {
      return this.cmp(wi) === 0;
    }, Pe.red = function(wi) {
      return new vn(wi);
    }, Pe.prototype.toRed = function(wi) {
      return Me(!this.red, "Already a number in reduction context"), Me(this.negative === 0, "red works only with positives"), wi.convertTo(this)._forceRed(wi);
    }, Pe.prototype.fromRed = function() {
      return Me(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, Pe.prototype._forceRed = function(wi) {
      return this.red = wi, this;
    }, Pe.prototype.forceRed = function(wi) {
      return Me(!this.red, "Already a number in reduction context"), this._forceRed(wi);
    }, Pe.prototype.redAdd = function(wi) {
      return Me(this.red, "redAdd works only with red numbers"), this.red.add(this, wi);
    }, Pe.prototype.redIAdd = function(wi) {
      return Me(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, wi);
    }, Pe.prototype.redSub = function(wi) {
      return Me(this.red, "redSub works only with red numbers"), this.red.sub(this, wi);
    }, Pe.prototype.redISub = function(wi) {
      return Me(this.red, "redISub works only with red numbers"), this.red.isub(this, wi);
    }, Pe.prototype.redShl = function(wi) {
      return Me(this.red, "redShl works only with red numbers"), this.red.shl(this, wi);
    }, Pe.prototype.redMul = function(wi) {
      return Me(this.red, "redMul works only with red numbers"), this.red._verify2(this, wi), this.red.mul(this, wi);
    }, Pe.prototype.redIMul = function(wi) {
      return Me(this.red, "redMul works only with red numbers"), this.red._verify2(this, wi), this.red.imul(this, wi);
    }, Pe.prototype.redSqr = function() {
      return Me(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, Pe.prototype.redISqr = function() {
      return Me(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, Pe.prototype.redSqrt = function() {
      return Me(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, Pe.prototype.redInvm = function() {
      return Me(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, Pe.prototype.redNeg = function() {
      return Me(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, Pe.prototype.redPow = function(wi) {
      return Me(this.red && !wi.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, wi);
    };
    var Xi = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Qi(Ai, wi) {
      this.name = Ai, this.p = new Pe(wi, 16), this.n = this.p.bitLength(), this.k = new Pe(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Qi.prototype._tmp = function() {
      var wi = new Pe(null);
      return wi.words = new Array(Math.ceil(this.n / 13)), wi;
    }, Qi.prototype.ireduce = function(wi) {
      var $i = wi, Li;
      do
        this.split($i, this.tmp), $i = this.imulK($i), $i = $i.iadd(this.tmp), Li = $i.bitLength();
      while (Li > this.n);
      var qi = Li < this.n ? -1 : $i.ucmp(this.p);
      return qi === 0 ? ($i.words[0] = 0, $i.length = 1) : qi > 0 ? $i.isub(this.p) : $i.strip !== void 0 ? $i.strip() : $i._strip(), $i;
    }, Qi.prototype.split = function(wi, $i) {
      wi.iushrn(this.n, 0, $i);
    }, Qi.prototype.imulK = function(wi) {
      return wi.imul(this.k);
    };
    function Oi() {
      Qi.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    Be(Oi, Qi), Oi.prototype.split = function(wi, $i) {
      for (var Li = 4194303, qi = Math.min(wi.length, 9), Ni = 0; Ni < qi; Ni++)
        $i.words[Ni] = wi.words[Ni];
      if ($i.length = qi, wi.length <= 9) {
        wi.words[0] = 0, wi.length = 1;
        return;
      }
      var Ti = wi.words[9];
      for ($i.words[$i.length++] = Ti & Li, Ni = 10; Ni < wi.length; Ni++) {
        var xi = wi.words[Ni] | 0;
        wi.words[Ni - 10] = (xi & Li) << 4 | Ti >>> 22, Ti = xi;
      }
      Ti >>>= 22, wi.words[Ni - 10] = Ti, Ti === 0 && wi.length > 10 ? wi.length -= 10 : wi.length -= 9;
    }, Oi.prototype.imulK = function(wi) {
      wi.words[wi.length] = 0, wi.words[wi.length + 1] = 0, wi.length += 2;
      for (var $i = 0, Li = 0; Li < wi.length; Li++) {
        var qi = wi.words[Li] | 0;
        $i += qi * 977, wi.words[Li] = $i & 67108863, $i = qi * 64 + ($i / 67108864 | 0);
      }
      return wi.words[wi.length - 1] === 0 && (wi.length--, wi.words[wi.length - 1] === 0 && wi.length--), wi;
    };
    function Yi() {
      Qi.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    Be(Yi, Qi);
    function ns() {
      Qi.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    Be(ns, Qi);
    function ls() {
      Qi.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    Be(ls, Qi), ls.prototype.imulK = function(wi) {
      for (var $i = 0, Li = 0; Li < wi.length; Li++) {
        var qi = (wi.words[Li] | 0) * 19 + $i, Ni = qi & 67108863;
        qi >>>= 26, wi.words[Li] = Ni, $i = qi;
      }
      return $i !== 0 && (wi.words[wi.length++] = $i), wi;
    }, Pe._prime = function(wi) {
      if (Xi[wi]) return Xi[wi];
      var $i;
      if (wi === "k256")
        $i = new Oi();
      else if (wi === "p224")
        $i = new Yi();
      else if (wi === "p192")
        $i = new ns();
      else if (wi === "p25519")
        $i = new ls();
      else
        throw new Error("Unknown prime " + wi);
      return Xi[wi] = $i, $i;
    };
    function vn(Ai) {
      if (typeof Ai == "string") {
        var wi = Pe._prime(Ai);
        this.m = wi.p, this.prime = wi;
      } else
        Me(Ai.gtn(1), "modulus must be greater than 1"), this.m = Ai, this.prime = null;
    }
    vn.prototype._verify1 = function(wi) {
      Me(wi.negative === 0, "red works only with positives"), Me(wi.red, "red works only with red numbers");
    }, vn.prototype._verify2 = function(wi, $i) {
      Me((wi.negative | $i.negative) === 0, "red works only with positives"), Me(
        wi.red && wi.red === $i.red,
        "red works only with red numbers"
      );
    }, vn.prototype.imod = function(wi) {
      return this.prime ? this.prime.ireduce(wi)._forceRed(this) : (Ue(wi, wi.umod(this.m)._forceRed(this)), wi);
    }, vn.prototype.neg = function(wi) {
      return wi.isZero() ? wi.clone() : this.m.sub(wi)._forceRed(this);
    }, vn.prototype.add = function(wi, $i) {
      this._verify2(wi, $i);
      var Li = wi.add($i);
      return Li.cmp(this.m) >= 0 && Li.isub(this.m), Li._forceRed(this);
    }, vn.prototype.iadd = function(wi, $i) {
      this._verify2(wi, $i);
      var Li = wi.iadd($i);
      return Li.cmp(this.m) >= 0 && Li.isub(this.m), Li;
    }, vn.prototype.sub = function(wi, $i) {
      this._verify2(wi, $i);
      var Li = wi.sub($i);
      return Li.cmpn(0) < 0 && Li.iadd(this.m), Li._forceRed(this);
    }, vn.prototype.isub = function(wi, $i) {
      this._verify2(wi, $i);
      var Li = wi.isub($i);
      return Li.cmpn(0) < 0 && Li.iadd(this.m), Li;
    }, vn.prototype.shl = function(wi, $i) {
      return this._verify1(wi), this.imod(wi.ushln($i));
    }, vn.prototype.imul = function(wi, $i) {
      return this._verify2(wi, $i), this.imod(wi.imul($i));
    }, vn.prototype.mul = function(wi, $i) {
      return this._verify2(wi, $i), this.imod(wi.mul($i));
    }, vn.prototype.isqr = function(wi) {
      return this.imul(wi, wi.clone());
    }, vn.prototype.sqr = function(wi) {
      return this.mul(wi, wi);
    }, vn.prototype.sqrt = function(wi) {
      if (wi.isZero()) return wi.clone();
      var $i = this.m.andln(3);
      if (Me($i % 2 === 1), $i === 3) {
        var Li = this.m.add(new Pe(1)).iushrn(2);
        return this.pow(wi, Li);
      }
      for (var qi = this.m.subn(1), Ni = 0; !qi.isZero() && qi.andln(1) === 0; )
        Ni++, qi.iushrn(1);
      Me(!qi.isZero());
      var Ti = new Pe(1).toRed(this), xi = Ti.redNeg(), Fi = this.m.subn(1).iushrn(1), Si = this.m.bitLength();
      for (Si = new Pe(2 * Si * Si).toRed(this); this.pow(Si, Fi).cmp(xi) !== 0; )
        Si.redIAdd(xi);
      for (var Vi = this.pow(Si, qi), ts = this.pow(wi, qi.addn(1).iushrn(1)), Hi = this.pow(wi, qi), fn = Ni; Hi.cmp(Ti) !== 0; ) {
        for (var Bi = Hi, ki = 0; Bi.cmp(Ti) !== 0; ki++)
          Bi = Bi.redSqr();
        Me(ki < fn);
        var Ji = this.pow(Vi, new Pe(1).iushln(fn - ki - 1));
        ts = ts.redMul(Ji), Vi = Ji.redSqr(), Hi = Hi.redMul(Vi), fn = ki;
      }
      return ts;
    }, vn.prototype.invm = function(wi) {
      var $i = wi._invmp(this.m);
      return $i.negative !== 0 ? ($i.negative = 0, this.imod($i).redNeg()) : this.imod($i);
    }, vn.prototype.pow = function(wi, $i) {
      if ($i.isZero()) return new Pe(1).toRed(this);
      if ($i.cmpn(1) === 0) return wi.clone();
      var Li = 4, qi = new Array(1 << Li);
      qi[0] = new Pe(1).toRed(this), qi[1] = wi;
      for (var Ni = 2; Ni < qi.length; Ni++)
        qi[Ni] = this.mul(qi[Ni - 1], wi);
      var Ti = qi[0], xi = 0, Fi = 0, Si = $i.bitLength() % 26;
      for (Si === 0 && (Si = 26), Ni = $i.length - 1; Ni >= 0; Ni--) {
        for (var Vi = $i.words[Ni], ts = Si - 1; ts >= 0; ts--) {
          var Hi = Vi >> ts & 1;
          if (Ti !== qi[0] && (Ti = this.sqr(Ti)), Hi === 0 && xi === 0) {
            Fi = 0;
            continue;
          }
          xi <<= 1, xi |= Hi, Fi++, !(Fi !== Li && (Ni !== 0 || ts !== 0)) && (Ti = this.mul(Ti, qi[xi]), Fi = 0, xi = 0);
        }
        Si = 26;
      }
      return Ti;
    }, vn.prototype.convertTo = function(wi) {
      var $i = wi.umod(this.m);
      return $i === wi ? $i.clone() : $i;
    }, vn.prototype.convertFrom = function(wi) {
      var $i = wi.clone();
      return $i.red = null, $i;
    }, Pe.mont = function(wi) {
      return new Mi(wi);
    };
    function Mi(Ai) {
      vn.call(this, Ai), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new Pe(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    Be(Mi, vn), Mi.prototype.convertTo = function(wi) {
      return this.imod(wi.ushln(this.shift));
    }, Mi.prototype.convertFrom = function(wi) {
      var $i = this.imod(wi.mul(this.rinv));
      return $i.red = null, $i;
    }, Mi.prototype.imul = function(wi, $i) {
      if (wi.isZero() || $i.isZero())
        return wi.words[0] = 0, wi.length = 1, wi;
      var Li = wi.imul($i), qi = Li.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Ni = Li.isub(qi).iushrn(this.shift), Ti = Ni;
      return Ni.cmp(this.m) >= 0 ? Ti = Ni.isub(this.m) : Ni.cmpn(0) < 0 && (Ti = Ni.iadd(this.m)), Ti._forceRed(this);
    }, Mi.prototype.mul = function(wi, $i) {
      if (wi.isZero() || $i.isZero()) return new Pe(0)._forceRed(this);
      var Li = wi.mul($i), qi = Li.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Ni = Li.isub(qi).iushrn(this.shift), Ti = Ni;
      return Ni.cmp(this.m) >= 0 ? Ti = Ni.isub(this.m) : Ni.cmpn(0) < 0 && (Ti = Ni.iadd(this.m)), Ti._forceRed(this);
    }, Mi.prototype.invm = function(wi) {
      var $i = this.imod(wi._invmp(this.m).mul(this.r2));
      return $i._forceRed(this);
    };
  })(Ae, commonjsGlobal);
})(bn$2);
var bnExports = bn$2.exports;
const BN$8 = /* @__PURE__ */ getDefaultExportFromCjs(bnExports);
var browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa) return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var Ae = bnExports, t = requireBrowser$b(), Ie = requireSafeBuffer$1().Buffer;
  function Me(Te) {
    var je = Te.modulus.byteLength(), Ve;
    do
      Ve = new Ae(t(je));
    while (Ve.cmp(Te.modulus) >= 0 || !Ve.umod(Te.prime1) || !Ve.umod(Te.prime2));
    return Ve;
  }
  function Be(Te) {
    var je = Me(Te), Ve = je.toRed(Ae.mont(Te.modulus)).redPow(new Ae(Te.publicExponent)).fromRed();
    return { blinder: Ve, unblinder: je.invm(Te.modulus) };
  }
  function Pe(Te, je) {
    var Ve = Be(je), fi = je.modulus.byteLength(), Ue = new Ae(Te).mul(Ve.blinder).umod(je.modulus), bi = Ue.toRed(Ae.mont(je.prime1)), vi = Ue.toRed(Ae.mont(je.prime2)), mi = je.coefficient, _i = je.prime1, Ei = je.prime2, Pi = bi.redPow(je.exponent1).fromRed(), Ii = vi.redPow(je.exponent2).fromRed(), Ci = Pi.isub(Ii).imul(mi).umod(_i).imul(Ei);
    return Ii.iadd(Ci).imul(Ve.unblinder).umod(je.modulus).toArrayLike(Ie, "be", fi);
  }
  return Pe.getr = Me, browserifyRsa = Pe, browserifyRsa;
}
var elliptic = {};
const name = "elliptic", version$5 = "6.5.7", description = "EC cryptography", main = "lib/elliptic.js", files = [
  "lib"
], scripts = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author = "Fedor Indutny <fedor@indutny.com>", license = "MIT", bugs = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage = "https://github.com/indutny/elliptic", devDependencies = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0$1 = {
  name,
  version: version$5,
  description,
  main,
  files,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  dependencies
};
var utils$l = {}, utils$k = {};
(function(Ae) {
  var t = Ae;
  function Ie(Pe, Te) {
    if (Array.isArray(Pe))
      return Pe.slice();
    if (!Pe)
      return [];
    var je = [];
    if (typeof Pe != "string") {
      for (var Ve = 0; Ve < Pe.length; Ve++)
        je[Ve] = Pe[Ve] | 0;
      return je;
    }
    if (Te === "hex") {
      Pe = Pe.replace(/[^a-z0-9]+/ig, ""), Pe.length % 2 !== 0 && (Pe = "0" + Pe);
      for (var Ve = 0; Ve < Pe.length; Ve += 2)
        je.push(parseInt(Pe[Ve] + Pe[Ve + 1], 16));
    } else
      for (var Ve = 0; Ve < Pe.length; Ve++) {
        var fi = Pe.charCodeAt(Ve), Ue = fi >> 8, bi = fi & 255;
        Ue ? je.push(Ue, bi) : je.push(bi);
      }
    return je;
  }
  t.toArray = Ie;
  function Me(Pe) {
    return Pe.length === 1 ? "0" + Pe : Pe;
  }
  t.zero2 = Me;
  function Be(Pe) {
    for (var Te = "", je = 0; je < Pe.length; je++)
      Te += Me(Pe[je].toString(16));
    return Te;
  }
  t.toHex = Be, t.encode = function(Te, je) {
    return je === "hex" ? Be(Te) : Te;
  };
})(utils$k);
(function(Ae) {
  var t = Ae, Ie = bnExports$1, Me = minimalisticAssert$1, Be = utils$k;
  t.assert = Me, t.toArray = Be.toArray, t.zero2 = Be.zero2, t.toHex = Be.toHex, t.encode = Be.encode;
  function Pe(Ue, bi, vi) {
    var mi = new Array(Math.max(Ue.bitLength(), vi) + 1), _i;
    for (_i = 0; _i < mi.length; _i += 1)
      mi[_i] = 0;
    var Ei = 1 << bi + 1, Pi = Ue.clone();
    for (_i = 0; _i < mi.length; _i++) {
      var Ii, Ci = Pi.andln(Ei - 1);
      Pi.isOdd() ? (Ci > (Ei >> 1) - 1 ? Ii = (Ei >> 1) - Ci : Ii = Ci, Pi.isubn(Ii)) : Ii = 0, mi[_i] = Ii, Pi.iushrn(1);
    }
    return mi;
  }
  t.getNAF = Pe;
  function Te(Ue, bi) {
    var vi = [
      [],
      []
    ];
    Ue = Ue.clone(), bi = bi.clone();
    for (var mi = 0, _i = 0, Ei; Ue.cmpn(-mi) > 0 || bi.cmpn(-_i) > 0; ) {
      var Pi = Ue.andln(3) + mi & 3, Ii = bi.andln(3) + _i & 3;
      Pi === 3 && (Pi = -1), Ii === 3 && (Ii = -1);
      var Ci;
      Pi & 1 ? (Ei = Ue.andln(7) + mi & 7, (Ei === 3 || Ei === 5) && Ii === 2 ? Ci = -Pi : Ci = Pi) : Ci = 0, vi[0].push(Ci);
      var Wi;
      Ii & 1 ? (Ei = bi.andln(7) + _i & 7, (Ei === 3 || Ei === 5) && Pi === 2 ? Wi = -Ii : Wi = Ii) : Wi = 0, vi[1].push(Wi), 2 * mi === Ci + 1 && (mi = 1 - mi), 2 * _i === Wi + 1 && (_i = 1 - _i), Ue.iushrn(1), bi.iushrn(1);
    }
    return vi;
  }
  t.getJSF = Te;
  function je(Ue, bi, vi) {
    var mi = "_" + bi;
    Ue.prototype[bi] = function() {
      return this[mi] !== void 0 ? this[mi] : this[mi] = vi.call(this);
    };
  }
  t.cachedProperty = je;
  function Ve(Ue) {
    return typeof Ue == "string" ? t.toArray(Ue, "hex") : Ue;
  }
  t.parseBytes = Ve;
  function fi(Ue) {
    return new Ie(Ue, "hex", "le");
  }
  t.intFromLE = fi;
})(utils$l);
var curve = {}, BN$7 = bnExports$1, utils$j = utils$l, getNAF$1 = utils$j.getNAF, getJSF$1 = utils$j.getJSF, assert$j = utils$j.assert;
function BaseCurve$1(Ae, t) {
  this.type = Ae, this.p = new BN$7(t.p, 16), this.red = t.prime ? BN$7.red(t.prime) : BN$7.mont(this.p), this.zero = new BN$7(0).toRed(this.red), this.one = new BN$7(1).toRed(this.red), this.two = new BN$7(2).toRed(this.red), this.n = t.n && new BN$7(t.n, 16), this.g = t.g && this.pointFromJSON(t.g, t.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var Ie = this.n && this.p.div(this.n);
  !Ie || Ie.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$3 = BaseCurve$1;
BaseCurve$1.prototype.point = function() {
  throw new Error("Not implemented");
};
BaseCurve$1.prototype.validate = function() {
  throw new Error("Not implemented");
};
BaseCurve$1.prototype._fixedNafMul = function(t, Ie) {
  assert$j(t.precomputed);
  var Me = t._getDoubles(), Be = getNAF$1(Ie, 1, this._bitLength), Pe = (1 << Me.step + 1) - (Me.step % 2 === 0 ? 2 : 1);
  Pe /= 3;
  var Te = [], je, Ve;
  for (je = 0; je < Be.length; je += Me.step) {
    Ve = 0;
    for (var fi = je + Me.step - 1; fi >= je; fi--)
      Ve = (Ve << 1) + Be[fi];
    Te.push(Ve);
  }
  for (var Ue = this.jpoint(null, null, null), bi = this.jpoint(null, null, null), vi = Pe; vi > 0; vi--) {
    for (je = 0; je < Te.length; je++)
      Ve = Te[je], Ve === vi ? bi = bi.mixedAdd(Me.points[je]) : Ve === -vi && (bi = bi.mixedAdd(Me.points[je].neg()));
    Ue = Ue.add(bi);
  }
  return Ue.toP();
};
BaseCurve$1.prototype._wnafMul = function(t, Ie) {
  var Me = 4, Be = t._getNAFPoints(Me);
  Me = Be.wnd;
  for (var Pe = Be.points, Te = getNAF$1(Ie, Me, this._bitLength), je = this.jpoint(null, null, null), Ve = Te.length - 1; Ve >= 0; Ve--) {
    for (var fi = 0; Ve >= 0 && Te[Ve] === 0; Ve--)
      fi++;
    if (Ve >= 0 && fi++, je = je.dblp(fi), Ve < 0)
      break;
    var Ue = Te[Ve];
    assert$j(Ue !== 0), t.type === "affine" ? Ue > 0 ? je = je.mixedAdd(Pe[Ue - 1 >> 1]) : je = je.mixedAdd(Pe[-Ue - 1 >> 1].neg()) : Ue > 0 ? je = je.add(Pe[Ue - 1 >> 1]) : je = je.add(Pe[-Ue - 1 >> 1].neg());
  }
  return t.type === "affine" ? je.toP() : je;
};
BaseCurve$1.prototype._wnafMulAdd = function(t, Ie, Me, Be, Pe) {
  var Te = this._wnafT1, je = this._wnafT2, Ve = this._wnafT3, fi = 0, Ue, bi, vi;
  for (Ue = 0; Ue < Be; Ue++) {
    vi = Ie[Ue];
    var mi = vi._getNAFPoints(t);
    Te[Ue] = mi.wnd, je[Ue] = mi.points;
  }
  for (Ue = Be - 1; Ue >= 1; Ue -= 2) {
    var _i = Ue - 1, Ei = Ue;
    if (Te[_i] !== 1 || Te[Ei] !== 1) {
      Ve[_i] = getNAF$1(Me[_i], Te[_i], this._bitLength), Ve[Ei] = getNAF$1(Me[Ei], Te[Ei], this._bitLength), fi = Math.max(Ve[_i].length, fi), fi = Math.max(Ve[Ei].length, fi);
      continue;
    }
    var Pi = [
      Ie[_i],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      Ie[Ei]
      /* 7 */
    ];
    Ie[_i].y.cmp(Ie[Ei].y) === 0 ? (Pi[1] = Ie[_i].add(Ie[Ei]), Pi[2] = Ie[_i].toJ().mixedAdd(Ie[Ei].neg())) : Ie[_i].y.cmp(Ie[Ei].y.redNeg()) === 0 ? (Pi[1] = Ie[_i].toJ().mixedAdd(Ie[Ei]), Pi[2] = Ie[_i].add(Ie[Ei].neg())) : (Pi[1] = Ie[_i].toJ().mixedAdd(Ie[Ei]), Pi[2] = Ie[_i].toJ().mixedAdd(Ie[Ei].neg()));
    var Ii = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], Ci = getJSF$1(Me[_i], Me[Ei]);
    for (fi = Math.max(Ci[0].length, fi), Ve[_i] = new Array(fi), Ve[Ei] = new Array(fi), bi = 0; bi < fi; bi++) {
      var Wi = Ci[0][bi] | 0, zi = Ci[1][bi] | 0;
      Ve[_i][bi] = Ii[(Wi + 1) * 3 + (zi + 1)], Ve[Ei][bi] = 0, je[_i] = Pi;
    }
  }
  var Xi = this.jpoint(null, null, null), Qi = this._wnafT4;
  for (Ue = fi; Ue >= 0; Ue--) {
    for (var Oi = 0; Ue >= 0; ) {
      var Yi = !0;
      for (bi = 0; bi < Be; bi++)
        Qi[bi] = Ve[bi][Ue] | 0, Qi[bi] !== 0 && (Yi = !1);
      if (!Yi)
        break;
      Oi++, Ue--;
    }
    if (Ue >= 0 && Oi++, Xi = Xi.dblp(Oi), Ue < 0)
      break;
    for (bi = 0; bi < Be; bi++) {
      var ns = Qi[bi];
      ns !== 0 && (ns > 0 ? vi = je[bi][ns - 1 >> 1] : ns < 0 && (vi = je[bi][-ns - 1 >> 1].neg()), vi.type === "affine" ? Xi = Xi.mixedAdd(vi) : Xi = Xi.add(vi));
    }
  }
  for (Ue = 0; Ue < Be; Ue++)
    je[Ue] = null;
  return Pe ? Xi : Xi.toP();
};
function BasePoint$1(Ae, t) {
  this.curve = Ae, this.type = t, this.precomputed = null;
}
BaseCurve$1.BasePoint = BasePoint$1;
BasePoint$1.prototype.eq = function() {
  throw new Error("Not implemented");
};
BasePoint$1.prototype.validate = function() {
  return this.curve.validate(this);
};
BaseCurve$1.prototype.decodePoint = function(t, Ie) {
  t = utils$j.toArray(t, Ie);
  var Me = this.p.byteLength();
  if ((t[0] === 4 || t[0] === 6 || t[0] === 7) && t.length - 1 === 2 * Me) {
    t[0] === 6 ? assert$j(t[t.length - 1] % 2 === 0) : t[0] === 7 && assert$j(t[t.length - 1] % 2 === 1);
    var Be = this.point(
      t.slice(1, 1 + Me),
      t.slice(1 + Me, 1 + 2 * Me)
    );
    return Be;
  } else if ((t[0] === 2 || t[0] === 3) && t.length - 1 === Me)
    return this.pointFromX(t.slice(1, 1 + Me), t[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint$1.prototype.encodeCompressed = function(t) {
  return this.encode(t, !0);
};
BasePoint$1.prototype._encode = function(t) {
  var Ie = this.curve.p.byteLength(), Me = this.getX().toArray("be", Ie);
  return t ? [this.getY().isEven() ? 2 : 3].concat(Me) : [4].concat(Me, this.getY().toArray("be", Ie));
};
BasePoint$1.prototype.encode = function(t, Ie) {
  return utils$j.encode(this._encode(Ie), t);
};
BasePoint$1.prototype.precompute = function(t) {
  if (this.precomputed)
    return this;
  var Ie = {
    doubles: null,
    naf: null,
    beta: null
  };
  return Ie.naf = this._getNAFPoints(8), Ie.doubles = this._getDoubles(4, t), Ie.beta = this._getBeta(), this.precomputed = Ie, this;
};
BasePoint$1.prototype._hasDoubles = function(t) {
  if (!this.precomputed)
    return !1;
  var Ie = this.precomputed.doubles;
  return Ie ? Ie.points.length >= Math.ceil((t.bitLength() + 1) / Ie.step) : !1;
};
BasePoint$1.prototype._getDoubles = function(t, Ie) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var Me = [this], Be = this, Pe = 0; Pe < Ie; Pe += t) {
    for (var Te = 0; Te < t; Te++)
      Be = Be.dbl();
    Me.push(Be);
  }
  return {
    step: t,
    points: Me
  };
};
BasePoint$1.prototype._getNAFPoints = function(t) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var Ie = [this], Me = (1 << t) - 1, Be = Me === 1 ? null : this.dbl(), Pe = 1; Pe < Me; Pe++)
    Ie[Pe] = Ie[Pe - 1].add(Be);
  return {
    wnd: t,
    points: Ie
  };
};
BasePoint$1.prototype._getBeta = function() {
  return null;
};
BasePoint$1.prototype.dblp = function(t) {
  for (var Ie = this, Me = 0; Me < t; Me++)
    Ie = Ie.dbl();
  return Ie;
};
var utils$i = utils$l, BN$6 = bnExports$1, inherits$3 = inherits_browserExports, Base$2 = base$3, assert$i = utils$i.assert;
function ShortCurve$1(Ae) {
  Base$2.call(this, "short", Ae), this.a = new BN$6(Ae.a, 16).toRed(this.red), this.b = new BN$6(Ae.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(Ae), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits$3(ShortCurve$1, Base$2);
var short = ShortCurve$1;
ShortCurve$1.prototype._getEndomorphism = function(t) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var Ie, Me;
    if (t.beta)
      Ie = new BN$6(t.beta, 16).toRed(this.red);
    else {
      var Be = this._getEndoRoots(this.p);
      Ie = Be[0].cmp(Be[1]) < 0 ? Be[0] : Be[1], Ie = Ie.toRed(this.red);
    }
    if (t.lambda)
      Me = new BN$6(t.lambda, 16);
    else {
      var Pe = this._getEndoRoots(this.n);
      this.g.mul(Pe[0]).x.cmp(this.g.x.redMul(Ie)) === 0 ? Me = Pe[0] : (Me = Pe[1], assert$i(this.g.mul(Me).x.cmp(this.g.x.redMul(Ie)) === 0));
    }
    var Te;
    return t.basis ? Te = t.basis.map(function(je) {
      return {
        a: new BN$6(je.a, 16),
        b: new BN$6(je.b, 16)
      };
    }) : Te = this._getEndoBasis(Me), {
      beta: Ie,
      lambda: Me,
      basis: Te
    };
  }
};
ShortCurve$1.prototype._getEndoRoots = function(t) {
  var Ie = t === this.p ? this.red : BN$6.mont(t), Me = new BN$6(2).toRed(Ie).redInvm(), Be = Me.redNeg(), Pe = new BN$6(3).toRed(Ie).redNeg().redSqrt().redMul(Me), Te = Be.redAdd(Pe).fromRed(), je = Be.redSub(Pe).fromRed();
  return [Te, je];
};
ShortCurve$1.prototype._getEndoBasis = function(t) {
  for (var Ie = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), Me = t, Be = this.n.clone(), Pe = new BN$6(1), Te = new BN$6(0), je = new BN$6(0), Ve = new BN$6(1), fi, Ue, bi, vi, mi, _i, Ei, Pi = 0, Ii, Ci; Me.cmpn(0) !== 0; ) {
    var Wi = Be.div(Me);
    Ii = Be.sub(Wi.mul(Me)), Ci = je.sub(Wi.mul(Pe));
    var zi = Ve.sub(Wi.mul(Te));
    if (!bi && Ii.cmp(Ie) < 0)
      fi = Ei.neg(), Ue = Pe, bi = Ii.neg(), vi = Ci;
    else if (bi && ++Pi === 2)
      break;
    Ei = Ii, Be = Me, Me = Ii, je = Pe, Pe = Ci, Ve = Te, Te = zi;
  }
  mi = Ii.neg(), _i = Ci;
  var Xi = bi.sqr().add(vi.sqr()), Qi = mi.sqr().add(_i.sqr());
  return Qi.cmp(Xi) >= 0 && (mi = fi, _i = Ue), bi.negative && (bi = bi.neg(), vi = vi.neg()), mi.negative && (mi = mi.neg(), _i = _i.neg()), [
    { a: bi, b: vi },
    { a: mi, b: _i }
  ];
};
ShortCurve$1.prototype._endoSplit = function(t) {
  var Ie = this.endo.basis, Me = Ie[0], Be = Ie[1], Pe = Be.b.mul(t).divRound(this.n), Te = Me.b.neg().mul(t).divRound(this.n), je = Pe.mul(Me.a), Ve = Te.mul(Be.a), fi = Pe.mul(Me.b), Ue = Te.mul(Be.b), bi = t.sub(je).sub(Ve), vi = fi.add(Ue).neg();
  return { k1: bi, k2: vi };
};
ShortCurve$1.prototype.pointFromX = function(t, Ie) {
  t = new BN$6(t, 16), t.red || (t = t.toRed(this.red));
  var Me = t.redSqr().redMul(t).redIAdd(t.redMul(this.a)).redIAdd(this.b), Be = Me.redSqrt();
  if (Be.redSqr().redSub(Me).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var Pe = Be.fromRed().isOdd();
  return (Ie && !Pe || !Ie && Pe) && (Be = Be.redNeg()), this.point(t, Be);
};
ShortCurve$1.prototype.validate = function(t) {
  if (t.inf)
    return !0;
  var Ie = t.x, Me = t.y, Be = this.a.redMul(Ie), Pe = Ie.redSqr().redMul(Ie).redIAdd(Be).redIAdd(this.b);
  return Me.redSqr().redISub(Pe).cmpn(0) === 0;
};
ShortCurve$1.prototype._endoWnafMulAdd = function(t, Ie, Me) {
  for (var Be = this._endoWnafT1, Pe = this._endoWnafT2, Te = 0; Te < t.length; Te++) {
    var je = this._endoSplit(Ie[Te]), Ve = t[Te], fi = Ve._getBeta();
    je.k1.negative && (je.k1.ineg(), Ve = Ve.neg(!0)), je.k2.negative && (je.k2.ineg(), fi = fi.neg(!0)), Be[Te * 2] = Ve, Be[Te * 2 + 1] = fi, Pe[Te * 2] = je.k1, Pe[Te * 2 + 1] = je.k2;
  }
  for (var Ue = this._wnafMulAdd(1, Be, Pe, Te * 2, Me), bi = 0; bi < Te * 2; bi++)
    Be[bi] = null, Pe[bi] = null;
  return Ue;
};
function Point$3(Ae, t, Ie, Me) {
  Base$2.BasePoint.call(this, Ae, "affine"), t === null && Ie === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$6(t, 16), this.y = new BN$6(Ie, 16), Me && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits$3(Point$3, Base$2.BasePoint);
ShortCurve$1.prototype.point = function(t, Ie, Me) {
  return new Point$3(this, t, Ie, Me);
};
ShortCurve$1.prototype.pointFromJSON = function(t, Ie) {
  return Point$3.fromJSON(this, t, Ie);
};
Point$3.prototype._getBeta = function() {
  if (this.curve.endo) {
    var t = this.precomputed;
    if (t && t.beta)
      return t.beta;
    var Ie = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (t) {
      var Me = this.curve, Be = function(Pe) {
        return Me.point(Pe.x.redMul(Me.endo.beta), Pe.y);
      };
      t.beta = Ie, Ie.precomputed = {
        beta: null,
        naf: t.naf && {
          wnd: t.naf.wnd,
          points: t.naf.points.map(Be)
        },
        doubles: t.doubles && {
          step: t.doubles.step,
          points: t.doubles.points.map(Be)
        }
      };
    }
    return Ie;
  }
};
Point$3.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point$3.fromJSON = function(t, Ie, Me) {
  typeof Ie == "string" && (Ie = JSON.parse(Ie));
  var Be = t.point(Ie[0], Ie[1], Me);
  if (!Ie[2])
    return Be;
  function Pe(je) {
    return t.point(je[0], je[1], Me);
  }
  var Te = Ie[2];
  return Be.precomputed = {
    beta: null,
    doubles: Te.doubles && {
      step: Te.doubles.step,
      points: [Be].concat(Te.doubles.points.map(Pe))
    },
    naf: Te.naf && {
      wnd: Te.naf.wnd,
      points: [Be].concat(Te.naf.points.map(Pe))
    }
  }, Be;
};
Point$3.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$3.prototype.isInfinity = function() {
  return this.inf;
};
Point$3.prototype.add = function(t) {
  if (this.inf)
    return t;
  if (t.inf)
    return this;
  if (this.eq(t))
    return this.dbl();
  if (this.neg().eq(t))
    return this.curve.point(null, null);
  if (this.x.cmp(t.x) === 0)
    return this.curve.point(null, null);
  var Ie = this.y.redSub(t.y);
  Ie.cmpn(0) !== 0 && (Ie = Ie.redMul(this.x.redSub(t.x).redInvm()));
  var Me = Ie.redSqr().redISub(this.x).redISub(t.x), Be = Ie.redMul(this.x.redSub(Me)).redISub(this.y);
  return this.curve.point(Me, Be);
};
Point$3.prototype.dbl = function() {
  if (this.inf)
    return this;
  var t = this.y.redAdd(this.y);
  if (t.cmpn(0) === 0)
    return this.curve.point(null, null);
  var Ie = this.curve.a, Me = this.x.redSqr(), Be = t.redInvm(), Pe = Me.redAdd(Me).redIAdd(Me).redIAdd(Ie).redMul(Be), Te = Pe.redSqr().redISub(this.x.redAdd(this.x)), je = Pe.redMul(this.x.redSub(Te)).redISub(this.y);
  return this.curve.point(Te, je);
};
Point$3.prototype.getX = function() {
  return this.x.fromRed();
};
Point$3.prototype.getY = function() {
  return this.y.fromRed();
};
Point$3.prototype.mul = function(t) {
  return t = new BN$6(t, 16), this.isInfinity() ? this : this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [t]) : this.curve._wnafMul(this, t);
};
Point$3.prototype.mulAdd = function(t, Ie, Me) {
  var Be = [this, Ie], Pe = [t, Me];
  return this.curve.endo ? this.curve._endoWnafMulAdd(Be, Pe) : this.curve._wnafMulAdd(1, Be, Pe, 2);
};
Point$3.prototype.jmulAdd = function(t, Ie, Me) {
  var Be = [this, Ie], Pe = [t, Me];
  return this.curve.endo ? this.curve._endoWnafMulAdd(Be, Pe, !0) : this.curve._wnafMulAdd(1, Be, Pe, 2, !0);
};
Point$3.prototype.eq = function(t) {
  return this === t || this.inf === t.inf && (this.inf || this.x.cmp(t.x) === 0 && this.y.cmp(t.y) === 0);
};
Point$3.prototype.neg = function(t) {
  if (this.inf)
    return this;
  var Ie = this.curve.point(this.x, this.y.redNeg());
  if (t && this.precomputed) {
    var Me = this.precomputed, Be = function(Pe) {
      return Pe.neg();
    };
    Ie.precomputed = {
      naf: Me.naf && {
        wnd: Me.naf.wnd,
        points: Me.naf.points.map(Be)
      },
      doubles: Me.doubles && {
        step: Me.doubles.step,
        points: Me.doubles.points.map(Be)
      }
    };
  }
  return Ie;
};
Point$3.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var t = this.curve.jpoint(this.x, this.y, this.curve.one);
  return t;
};
function JPoint$1(Ae, t, Ie, Me) {
  Base$2.BasePoint.call(this, Ae, "jacobian"), t === null && Ie === null && Me === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$6(0)) : (this.x = new BN$6(t, 16), this.y = new BN$6(Ie, 16), this.z = new BN$6(Me, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits$3(JPoint$1, Base$2.BasePoint);
ShortCurve$1.prototype.jpoint = function(t, Ie, Me) {
  return new JPoint$1(this, t, Ie, Me);
};
JPoint$1.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var t = this.z.redInvm(), Ie = t.redSqr(), Me = this.x.redMul(Ie), Be = this.y.redMul(Ie).redMul(t);
  return this.curve.point(Me, Be);
};
JPoint$1.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint$1.prototype.add = function(t) {
  if (this.isInfinity())
    return t;
  if (t.isInfinity())
    return this;
  var Ie = t.z.redSqr(), Me = this.z.redSqr(), Be = this.x.redMul(Ie), Pe = t.x.redMul(Me), Te = this.y.redMul(Ie.redMul(t.z)), je = t.y.redMul(Me.redMul(this.z)), Ve = Be.redSub(Pe), fi = Te.redSub(je);
  if (Ve.cmpn(0) === 0)
    return fi.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var Ue = Ve.redSqr(), bi = Ue.redMul(Ve), vi = Be.redMul(Ue), mi = fi.redSqr().redIAdd(bi).redISub(vi).redISub(vi), _i = fi.redMul(vi.redISub(mi)).redISub(Te.redMul(bi)), Ei = this.z.redMul(t.z).redMul(Ve);
  return this.curve.jpoint(mi, _i, Ei);
};
JPoint$1.prototype.mixedAdd = function(t) {
  if (this.isInfinity())
    return t.toJ();
  if (t.isInfinity())
    return this;
  var Ie = this.z.redSqr(), Me = this.x, Be = t.x.redMul(Ie), Pe = this.y, Te = t.y.redMul(Ie).redMul(this.z), je = Me.redSub(Be), Ve = Pe.redSub(Te);
  if (je.cmpn(0) === 0)
    return Ve.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var fi = je.redSqr(), Ue = fi.redMul(je), bi = Me.redMul(fi), vi = Ve.redSqr().redIAdd(Ue).redISub(bi).redISub(bi), mi = Ve.redMul(bi.redISub(vi)).redISub(Pe.redMul(Ue)), _i = this.z.redMul(je);
  return this.curve.jpoint(vi, mi, _i);
};
JPoint$1.prototype.dblp = function(t) {
  if (t === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!t)
    return this.dbl();
  var Ie;
  if (this.curve.zeroA || this.curve.threeA) {
    var Me = this;
    for (Ie = 0; Ie < t; Ie++)
      Me = Me.dbl();
    return Me;
  }
  var Be = this.curve.a, Pe = this.curve.tinv, Te = this.x, je = this.y, Ve = this.z, fi = Ve.redSqr().redSqr(), Ue = je.redAdd(je);
  for (Ie = 0; Ie < t; Ie++) {
    var bi = Te.redSqr(), vi = Ue.redSqr(), mi = vi.redSqr(), _i = bi.redAdd(bi).redIAdd(bi).redIAdd(Be.redMul(fi)), Ei = Te.redMul(vi), Pi = _i.redSqr().redISub(Ei.redAdd(Ei)), Ii = Ei.redISub(Pi), Ci = _i.redMul(Ii);
    Ci = Ci.redIAdd(Ci).redISub(mi);
    var Wi = Ue.redMul(Ve);
    Ie + 1 < t && (fi = fi.redMul(mi)), Te = Pi, Ve = Wi, Ue = Ci;
  }
  return this.curve.jpoint(Te, Ue.redMul(Pe), Ve);
};
JPoint$1.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint$1.prototype._zeroDbl = function() {
  var t, Ie, Me;
  if (this.zOne) {
    var Be = this.x.redSqr(), Pe = this.y.redSqr(), Te = Pe.redSqr(), je = this.x.redAdd(Pe).redSqr().redISub(Be).redISub(Te);
    je = je.redIAdd(je);
    var Ve = Be.redAdd(Be).redIAdd(Be), fi = Ve.redSqr().redISub(je).redISub(je), Ue = Te.redIAdd(Te);
    Ue = Ue.redIAdd(Ue), Ue = Ue.redIAdd(Ue), t = fi, Ie = Ve.redMul(je.redISub(fi)).redISub(Ue), Me = this.y.redAdd(this.y);
  } else {
    var bi = this.x.redSqr(), vi = this.y.redSqr(), mi = vi.redSqr(), _i = this.x.redAdd(vi).redSqr().redISub(bi).redISub(mi);
    _i = _i.redIAdd(_i);
    var Ei = bi.redAdd(bi).redIAdd(bi), Pi = Ei.redSqr(), Ii = mi.redIAdd(mi);
    Ii = Ii.redIAdd(Ii), Ii = Ii.redIAdd(Ii), t = Pi.redISub(_i).redISub(_i), Ie = Ei.redMul(_i.redISub(t)).redISub(Ii), Me = this.y.redMul(this.z), Me = Me.redIAdd(Me);
  }
  return this.curve.jpoint(t, Ie, Me);
};
JPoint$1.prototype._threeDbl = function() {
  var t, Ie, Me;
  if (this.zOne) {
    var Be = this.x.redSqr(), Pe = this.y.redSqr(), Te = Pe.redSqr(), je = this.x.redAdd(Pe).redSqr().redISub(Be).redISub(Te);
    je = je.redIAdd(je);
    var Ve = Be.redAdd(Be).redIAdd(Be).redIAdd(this.curve.a), fi = Ve.redSqr().redISub(je).redISub(je);
    t = fi;
    var Ue = Te.redIAdd(Te);
    Ue = Ue.redIAdd(Ue), Ue = Ue.redIAdd(Ue), Ie = Ve.redMul(je.redISub(fi)).redISub(Ue), Me = this.y.redAdd(this.y);
  } else {
    var bi = this.z.redSqr(), vi = this.y.redSqr(), mi = this.x.redMul(vi), _i = this.x.redSub(bi).redMul(this.x.redAdd(bi));
    _i = _i.redAdd(_i).redIAdd(_i);
    var Ei = mi.redIAdd(mi);
    Ei = Ei.redIAdd(Ei);
    var Pi = Ei.redAdd(Ei);
    t = _i.redSqr().redISub(Pi), Me = this.y.redAdd(this.z).redSqr().redISub(vi).redISub(bi);
    var Ii = vi.redSqr();
    Ii = Ii.redIAdd(Ii), Ii = Ii.redIAdd(Ii), Ii = Ii.redIAdd(Ii), Ie = _i.redMul(Ei.redISub(t)).redISub(Ii);
  }
  return this.curve.jpoint(t, Ie, Me);
};
JPoint$1.prototype._dbl = function() {
  var t = this.curve.a, Ie = this.x, Me = this.y, Be = this.z, Pe = Be.redSqr().redSqr(), Te = Ie.redSqr(), je = Me.redSqr(), Ve = Te.redAdd(Te).redIAdd(Te).redIAdd(t.redMul(Pe)), fi = Ie.redAdd(Ie);
  fi = fi.redIAdd(fi);
  var Ue = fi.redMul(je), bi = Ve.redSqr().redISub(Ue.redAdd(Ue)), vi = Ue.redISub(bi), mi = je.redSqr();
  mi = mi.redIAdd(mi), mi = mi.redIAdd(mi), mi = mi.redIAdd(mi);
  var _i = Ve.redMul(vi).redISub(mi), Ei = Me.redAdd(Me).redMul(Be);
  return this.curve.jpoint(bi, _i, Ei);
};
JPoint$1.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var t = this.x.redSqr(), Ie = this.y.redSqr(), Me = this.z.redSqr(), Be = Ie.redSqr(), Pe = t.redAdd(t).redIAdd(t), Te = Pe.redSqr(), je = this.x.redAdd(Ie).redSqr().redISub(t).redISub(Be);
  je = je.redIAdd(je), je = je.redAdd(je).redIAdd(je), je = je.redISub(Te);
  var Ve = je.redSqr(), fi = Be.redIAdd(Be);
  fi = fi.redIAdd(fi), fi = fi.redIAdd(fi), fi = fi.redIAdd(fi);
  var Ue = Pe.redIAdd(je).redSqr().redISub(Te).redISub(Ve).redISub(fi), bi = Ie.redMul(Ue);
  bi = bi.redIAdd(bi), bi = bi.redIAdd(bi);
  var vi = this.x.redMul(Ve).redISub(bi);
  vi = vi.redIAdd(vi), vi = vi.redIAdd(vi);
  var mi = this.y.redMul(Ue.redMul(fi.redISub(Ue)).redISub(je.redMul(Ve)));
  mi = mi.redIAdd(mi), mi = mi.redIAdd(mi), mi = mi.redIAdd(mi);
  var _i = this.z.redAdd(je).redSqr().redISub(Me).redISub(Ve);
  return this.curve.jpoint(vi, mi, _i);
};
JPoint$1.prototype.mul = function(t, Ie) {
  return t = new BN$6(t, Ie), this.curve._wnafMul(this, t);
};
JPoint$1.prototype.eq = function(t) {
  if (t.type === "affine")
    return this.eq(t.toJ());
  if (this === t)
    return !0;
  var Ie = this.z.redSqr(), Me = t.z.redSqr();
  if (this.x.redMul(Me).redISub(t.x.redMul(Ie)).cmpn(0) !== 0)
    return !1;
  var Be = Ie.redMul(this.z), Pe = Me.redMul(t.z);
  return this.y.redMul(Pe).redISub(t.y.redMul(Be)).cmpn(0) === 0;
};
JPoint$1.prototype.eqXToP = function(t) {
  var Ie = this.z.redSqr(), Me = t.toRed(this.curve.red).redMul(Ie);
  if (this.x.cmp(Me) === 0)
    return !0;
  for (var Be = t.clone(), Pe = this.curve.redN.redMul(Ie); ; ) {
    if (Be.iadd(this.curve.n), Be.cmp(this.curve.p) >= 0)
      return !1;
    if (Me.redIAdd(Pe), this.x.cmp(Me) === 0)
      return !0;
  }
};
JPoint$1.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint$1.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var BN$5 = bnExports$1, inherits$2 = inherits_browserExports, Base$1 = base$3, utils$h = utils$l;
function MontCurve(Ae) {
  Base$1.call(this, "mont", Ae), this.a = new BN$5(Ae.a, 16).toRed(this.red), this.b = new BN$5(Ae.b, 16).toRed(this.red), this.i4 = new BN$5(4).toRed(this.red).redInvm(), this.two = new BN$5(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$2(MontCurve, Base$1);
var mont = MontCurve;
MontCurve.prototype.validate = function(t) {
  var Ie = t.normalize().x, Me = Ie.redSqr(), Be = Me.redMul(Ie).redAdd(Me.redMul(this.a)).redAdd(Ie), Pe = Be.redSqrt();
  return Pe.redSqr().cmp(Be) === 0;
};
function Point$2(Ae, t, Ie) {
  Base$1.BasePoint.call(this, Ae, "projective"), t === null && Ie === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN$5(t, 16), this.z = new BN$5(Ie, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
inherits$2(Point$2, Base$1.BasePoint);
MontCurve.prototype.decodePoint = function(t, Ie) {
  return this.point(utils$h.toArray(t, Ie), 1);
};
MontCurve.prototype.point = function(t, Ie) {
  return new Point$2(this, t, Ie);
};
MontCurve.prototype.pointFromJSON = function(t) {
  return Point$2.fromJSON(this, t);
};
Point$2.prototype.precompute = function() {
};
Point$2.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$2.fromJSON = function(t, Ie) {
  return new Point$2(t, Ie[0], Ie[1] || t.one);
};
Point$2.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
Point$2.prototype.dbl = function() {
  var t = this.x.redAdd(this.z), Ie = t.redSqr(), Me = this.x.redSub(this.z), Be = Me.redSqr(), Pe = Ie.redSub(Be), Te = Ie.redMul(Be), je = Pe.redMul(Be.redAdd(this.curve.a24.redMul(Pe)));
  return this.curve.point(Te, je);
};
Point$2.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$2.prototype.diffAdd = function(t, Ie) {
  var Me = this.x.redAdd(this.z), Be = this.x.redSub(this.z), Pe = t.x.redAdd(t.z), Te = t.x.redSub(t.z), je = Te.redMul(Me), Ve = Pe.redMul(Be), fi = Ie.z.redMul(je.redAdd(Ve).redSqr()), Ue = Ie.x.redMul(je.redISub(Ve).redSqr());
  return this.curve.point(fi, Ue);
};
Point$2.prototype.mul = function(t) {
  for (var Ie = t.clone(), Me = this, Be = this.curve.point(null, null), Pe = this, Te = []; Ie.cmpn(0) !== 0; Ie.iushrn(1))
    Te.push(Ie.andln(1));
  for (var je = Te.length - 1; je >= 0; je--)
    Te[je] === 0 ? (Me = Me.diffAdd(Be, Pe), Be = Be.dbl()) : (Be = Me.diffAdd(Be, Pe), Me = Me.dbl());
  return Be;
};
Point$2.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$2.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$2.prototype.eq = function(t) {
  return this.getX().cmp(t.getX()) === 0;
};
Point$2.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Point$2.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var utils$g = utils$l, BN$4 = bnExports$1, inherits$1 = inherits_browserExports, Base = base$3, assert$h = utils$g.assert;
function EdwardsCurve(Ae) {
  this.twisted = (Ae.a | 0) !== 1, this.mOneA = this.twisted && (Ae.a | 0) === -1, this.extended = this.mOneA, Base.call(this, "edwards", Ae), this.a = new BN$4(Ae.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN$4(Ae.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN$4(Ae.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert$h(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (Ae.c | 0) === 1;
}
inherits$1(EdwardsCurve, Base);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function(t) {
  return this.mOneA ? t.redNeg() : this.a.redMul(t);
};
EdwardsCurve.prototype._mulC = function(t) {
  return this.oneC ? t : this.c.redMul(t);
};
EdwardsCurve.prototype.jpoint = function(t, Ie, Me, Be) {
  return this.point(t, Ie, Me, Be);
};
EdwardsCurve.prototype.pointFromX = function(t, Ie) {
  t = new BN$4(t, 16), t.red || (t = t.toRed(this.red));
  var Me = t.redSqr(), Be = this.c2.redSub(this.a.redMul(Me)), Pe = this.one.redSub(this.c2.redMul(this.d).redMul(Me)), Te = Be.redMul(Pe.redInvm()), je = Te.redSqrt();
  if (je.redSqr().redSub(Te).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var Ve = je.fromRed().isOdd();
  return (Ie && !Ve || !Ie && Ve) && (je = je.redNeg()), this.point(t, je);
};
EdwardsCurve.prototype.pointFromY = function(t, Ie) {
  t = new BN$4(t, 16), t.red || (t = t.toRed(this.red));
  var Me = t.redSqr(), Be = Me.redSub(this.c2), Pe = Me.redMul(this.d).redMul(this.c2).redSub(this.a), Te = Be.redMul(Pe.redInvm());
  if (Te.cmp(this.zero) === 0) {
    if (Ie)
      throw new Error("invalid point");
    return this.point(this.zero, t);
  }
  var je = Te.redSqrt();
  if (je.redSqr().redSub(Te).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return je.fromRed().isOdd() !== Ie && (je = je.redNeg()), this.point(je, t);
};
EdwardsCurve.prototype.validate = function(t) {
  if (t.isInfinity())
    return !0;
  t.normalize();
  var Ie = t.x.redSqr(), Me = t.y.redSqr(), Be = Ie.redMul(this.a).redAdd(Me), Pe = this.c2.redMul(this.one.redAdd(this.d.redMul(Ie).redMul(Me)));
  return Be.cmp(Pe) === 0;
};
function Point$1(Ae, t, Ie, Me, Be) {
  Base.BasePoint.call(this, Ae, "projective"), t === null && Ie === null && Me === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN$4(t, 16), this.y = new BN$4(Ie, 16), this.z = Me ? new BN$4(Me, 16) : this.curve.one, this.t = Be && new BN$4(Be, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
inherits$1(Point$1, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function(t) {
  return Point$1.fromJSON(this, t);
};
EdwardsCurve.prototype.point = function(t, Ie, Me, Be) {
  return new Point$1(this, t, Ie, Me, Be);
};
Point$1.fromJSON = function(t, Ie) {
  return new Point$1(t, Ie[0], Ie[1], Ie[2]);
};
Point$1.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point$1.prototype._extDbl = function() {
  var t = this.x.redSqr(), Ie = this.y.redSqr(), Me = this.z.redSqr();
  Me = Me.redIAdd(Me);
  var Be = this.curve._mulA(t), Pe = this.x.redAdd(this.y).redSqr().redISub(t).redISub(Ie), Te = Be.redAdd(Ie), je = Te.redSub(Me), Ve = Be.redSub(Ie), fi = Pe.redMul(je), Ue = Te.redMul(Ve), bi = Pe.redMul(Ve), vi = je.redMul(Te);
  return this.curve.point(fi, Ue, vi, bi);
};
Point$1.prototype._projDbl = function() {
  var t = this.x.redAdd(this.y).redSqr(), Ie = this.x.redSqr(), Me = this.y.redSqr(), Be, Pe, Te, je, Ve, fi;
  if (this.curve.twisted) {
    je = this.curve._mulA(Ie);
    var Ue = je.redAdd(Me);
    this.zOne ? (Be = t.redSub(Ie).redSub(Me).redMul(Ue.redSub(this.curve.two)), Pe = Ue.redMul(je.redSub(Me)), Te = Ue.redSqr().redSub(Ue).redSub(Ue)) : (Ve = this.z.redSqr(), fi = Ue.redSub(Ve).redISub(Ve), Be = t.redSub(Ie).redISub(Me).redMul(fi), Pe = Ue.redMul(je.redSub(Me)), Te = Ue.redMul(fi));
  } else
    je = Ie.redAdd(Me), Ve = this.curve._mulC(this.z).redSqr(), fi = je.redSub(Ve).redSub(Ve), Be = this.curve._mulC(t.redISub(je)).redMul(fi), Pe = this.curve._mulC(je).redMul(Ie.redISub(Me)), Te = je.redMul(fi);
  return this.curve.point(Be, Pe, Te);
};
Point$1.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Point$1.prototype._extAdd = function(t) {
  var Ie = this.y.redSub(this.x).redMul(t.y.redSub(t.x)), Me = this.y.redAdd(this.x).redMul(t.y.redAdd(t.x)), Be = this.t.redMul(this.curve.dd).redMul(t.t), Pe = this.z.redMul(t.z.redAdd(t.z)), Te = Me.redSub(Ie), je = Pe.redSub(Be), Ve = Pe.redAdd(Be), fi = Me.redAdd(Ie), Ue = Te.redMul(je), bi = Ve.redMul(fi), vi = Te.redMul(fi), mi = je.redMul(Ve);
  return this.curve.point(Ue, bi, mi, vi);
};
Point$1.prototype._projAdd = function(t) {
  var Ie = this.z.redMul(t.z), Me = Ie.redSqr(), Be = this.x.redMul(t.x), Pe = this.y.redMul(t.y), Te = this.curve.d.redMul(Be).redMul(Pe), je = Me.redSub(Te), Ve = Me.redAdd(Te), fi = this.x.redAdd(this.y).redMul(t.x.redAdd(t.y)).redISub(Be).redISub(Pe), Ue = Ie.redMul(je).redMul(fi), bi, vi;
  return this.curve.twisted ? (bi = Ie.redMul(Ve).redMul(Pe.redSub(this.curve._mulA(Be))), vi = je.redMul(Ve)) : (bi = Ie.redMul(Ve).redMul(Pe.redSub(Be)), vi = this.curve._mulC(je).redMul(Ve)), this.curve.point(Ue, bi, vi);
};
Point$1.prototype.add = function(t) {
  return this.isInfinity() ? t : t.isInfinity() ? this : this.curve.extended ? this._extAdd(t) : this._projAdd(t);
};
Point$1.prototype.mul = function(t) {
  return this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve._wnafMul(this, t);
};
Point$1.prototype.mulAdd = function(t, Ie, Me) {
  return this.curve._wnafMulAdd(1, [this, Ie], [t, Me], 2, !1);
};
Point$1.prototype.jmulAdd = function(t, Ie, Me) {
  return this.curve._wnafMulAdd(1, [this, Ie], [t, Me], 2, !0);
};
Point$1.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var t = this.z.redInvm();
  return this.x = this.x.redMul(t), this.y = this.y.redMul(t), this.t && (this.t = this.t.redMul(t)), this.z = this.curve.one, this.zOne = !0, this;
};
Point$1.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point$1.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
Point$1.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
Point$1.prototype.eq = function(t) {
  return this === t || this.getX().cmp(t.getX()) === 0 && this.getY().cmp(t.getY()) === 0;
};
Point$1.prototype.eqXToP = function(t) {
  var Ie = t.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(Ie) === 0)
    return !0;
  for (var Me = t.clone(), Be = this.curve.redN.redMul(this.z); ; ) {
    if (Me.iadd(this.curve.n), Me.cmp(this.curve.p) >= 0)
      return !1;
    if (Ie.redIAdd(Be), this.x.cmp(Ie) === 0)
      return !0;
  }
};
Point$1.prototype.toP = Point$1.prototype.normalize;
Point$1.prototype.mixedAdd = Point$1.prototype.add;
(function(Ae) {
  var t = Ae;
  t.base = base$3, t.short = short, t.mont = mont, t.edwards = edwards;
})(curve);
var curves$1 = {}, hash$4 = {}, utils$f = {}, assert$g = minimalisticAssert$1, inherits = inherits_browserExports;
utils$f.inherits = inherits;
function isSurrogatePair(Ae, t) {
  return (Ae.charCodeAt(t) & 64512) !== 55296 || t < 0 || t + 1 >= Ae.length ? !1 : (Ae.charCodeAt(t + 1) & 64512) === 56320;
}
function toArray(Ae, t) {
  if (Array.isArray(Ae))
    return Ae.slice();
  if (!Ae)
    return [];
  var Ie = [];
  if (typeof Ae == "string")
    if (t) {
      if (t === "hex")
        for (Ae = Ae.replace(/[^a-z0-9]+/ig, ""), Ae.length % 2 !== 0 && (Ae = "0" + Ae), Be = 0; Be < Ae.length; Be += 2)
          Ie.push(parseInt(Ae[Be] + Ae[Be + 1], 16));
    } else for (var Me = 0, Be = 0; Be < Ae.length; Be++) {
      var Pe = Ae.charCodeAt(Be);
      Pe < 128 ? Ie[Me++] = Pe : Pe < 2048 ? (Ie[Me++] = Pe >> 6 | 192, Ie[Me++] = Pe & 63 | 128) : isSurrogatePair(Ae, Be) ? (Pe = 65536 + ((Pe & 1023) << 10) + (Ae.charCodeAt(++Be) & 1023), Ie[Me++] = Pe >> 18 | 240, Ie[Me++] = Pe >> 12 & 63 | 128, Ie[Me++] = Pe >> 6 & 63 | 128, Ie[Me++] = Pe & 63 | 128) : (Ie[Me++] = Pe >> 12 | 224, Ie[Me++] = Pe >> 6 & 63 | 128, Ie[Me++] = Pe & 63 | 128);
    }
  else
    for (Be = 0; Be < Ae.length; Be++)
      Ie[Be] = Ae[Be] | 0;
  return Ie;
}
utils$f.toArray = toArray;
function toHex(Ae) {
  for (var t = "", Ie = 0; Ie < Ae.length; Ie++)
    t += zero2(Ae[Ie].toString(16));
  return t;
}
utils$f.toHex = toHex;
function htonl(Ae) {
  var t = Ae >>> 24 | Ae >>> 8 & 65280 | Ae << 8 & 16711680 | (Ae & 255) << 24;
  return t >>> 0;
}
utils$f.htonl = htonl;
function toHex32(Ae, t) {
  for (var Ie = "", Me = 0; Me < Ae.length; Me++) {
    var Be = Ae[Me];
    t === "little" && (Be = htonl(Be)), Ie += zero8(Be.toString(16));
  }
  return Ie;
}
utils$f.toHex32 = toHex32;
function zero2(Ae) {
  return Ae.length === 1 ? "0" + Ae : Ae;
}
utils$f.zero2 = zero2;
function zero8(Ae) {
  return Ae.length === 7 ? "0" + Ae : Ae.length === 6 ? "00" + Ae : Ae.length === 5 ? "000" + Ae : Ae.length === 4 ? "0000" + Ae : Ae.length === 3 ? "00000" + Ae : Ae.length === 2 ? "000000" + Ae : Ae.length === 1 ? "0000000" + Ae : Ae;
}
utils$f.zero8 = zero8;
function join32(Ae, t, Ie, Me) {
  var Be = Ie - t;
  assert$g(Be % 4 === 0);
  for (var Pe = new Array(Be / 4), Te = 0, je = t; Te < Pe.length; Te++, je += 4) {
    var Ve;
    Me === "big" ? Ve = Ae[je] << 24 | Ae[je + 1] << 16 | Ae[je + 2] << 8 | Ae[je + 3] : Ve = Ae[je + 3] << 24 | Ae[je + 2] << 16 | Ae[je + 1] << 8 | Ae[je], Pe[Te] = Ve >>> 0;
  }
  return Pe;
}
utils$f.join32 = join32;
function split32(Ae, t) {
  for (var Ie = new Array(Ae.length * 4), Me = 0, Be = 0; Me < Ae.length; Me++, Be += 4) {
    var Pe = Ae[Me];
    t === "big" ? (Ie[Be] = Pe >>> 24, Ie[Be + 1] = Pe >>> 16 & 255, Ie[Be + 2] = Pe >>> 8 & 255, Ie[Be + 3] = Pe & 255) : (Ie[Be + 3] = Pe >>> 24, Ie[Be + 2] = Pe >>> 16 & 255, Ie[Be + 1] = Pe >>> 8 & 255, Ie[Be] = Pe & 255);
  }
  return Ie;
}
utils$f.split32 = split32;
function rotr32$1(Ae, t) {
  return Ae >>> t | Ae << 32 - t;
}
utils$f.rotr32 = rotr32$1;
function rotl32$2(Ae, t) {
  return Ae << t | Ae >>> 32 - t;
}
utils$f.rotl32 = rotl32$2;
function sum32$3(Ae, t) {
  return Ae + t >>> 0;
}
utils$f.sum32 = sum32$3;
function sum32_3$1(Ae, t, Ie) {
  return Ae + t + Ie >>> 0;
}
utils$f.sum32_3 = sum32_3$1;
function sum32_4$2(Ae, t, Ie, Me) {
  return Ae + t + Ie + Me >>> 0;
}
utils$f.sum32_4 = sum32_4$2;
function sum32_5$2(Ae, t, Ie, Me, Be) {
  return Ae + t + Ie + Me + Be >>> 0;
}
utils$f.sum32_5 = sum32_5$2;
function sum64$1(Ae, t, Ie, Me) {
  var Be = Ae[t], Pe = Ae[t + 1], Te = Me + Pe >>> 0, je = (Te < Me ? 1 : 0) + Ie + Be;
  Ae[t] = je >>> 0, Ae[t + 1] = Te;
}
utils$f.sum64 = sum64$1;
function sum64_hi$1(Ae, t, Ie, Me) {
  var Be = t + Me >>> 0, Pe = (Be < t ? 1 : 0) + Ae + Ie;
  return Pe >>> 0;
}
utils$f.sum64_hi = sum64_hi$1;
function sum64_lo$1(Ae, t, Ie, Me) {
  var Be = t + Me;
  return Be >>> 0;
}
utils$f.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(Ae, t, Ie, Me, Be, Pe, Te, je) {
  var Ve = 0, fi = t;
  fi = fi + Me >>> 0, Ve += fi < t ? 1 : 0, fi = fi + Pe >>> 0, Ve += fi < Pe ? 1 : 0, fi = fi + je >>> 0, Ve += fi < je ? 1 : 0;
  var Ue = Ae + Ie + Be + Te + Ve;
  return Ue >>> 0;
}
utils$f.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(Ae, t, Ie, Me, Be, Pe, Te, je) {
  var Ve = t + Me + Pe + je;
  return Ve >>> 0;
}
utils$f.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(Ae, t, Ie, Me, Be, Pe, Te, je, Ve, fi) {
  var Ue = 0, bi = t;
  bi = bi + Me >>> 0, Ue += bi < t ? 1 : 0, bi = bi + Pe >>> 0, Ue += bi < Pe ? 1 : 0, bi = bi + je >>> 0, Ue += bi < je ? 1 : 0, bi = bi + fi >>> 0, Ue += bi < fi ? 1 : 0;
  var vi = Ae + Ie + Be + Te + Ve + Ue;
  return vi >>> 0;
}
utils$f.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(Ae, t, Ie, Me, Be, Pe, Te, je, Ve, fi) {
  var Ue = t + Me + Pe + je + fi;
  return Ue >>> 0;
}
utils$f.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(Ae, t, Ie) {
  var Me = t << 32 - Ie | Ae >>> Ie;
  return Me >>> 0;
}
utils$f.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(Ae, t, Ie) {
  var Me = Ae << 32 - Ie | t >>> Ie;
  return Me >>> 0;
}
utils$f.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(Ae, t, Ie) {
  return Ae >>> Ie;
}
utils$f.shr64_hi = shr64_hi$1;
function shr64_lo$1(Ae, t, Ie) {
  var Me = Ae << 32 - Ie | t >>> Ie;
  return Me >>> 0;
}
utils$f.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$e = utils$f, assert$f = minimalisticAssert$1;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function(t, Ie) {
  if (t = utils$e.toArray(t, Ie), this.pending ? this.pending = this.pending.concat(t) : this.pending = t, this.pendingTotal += t.length, this.pending.length >= this._delta8) {
    t = this.pending;
    var Me = t.length % this._delta8;
    this.pending = t.slice(t.length - Me, t.length), this.pending.length === 0 && (this.pending = null), t = utils$e.join32(t, 0, t.length - Me, this.endian);
    for (var Be = 0; Be < t.length; Be += this._delta32)
      this._update(t, Be, Be + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function(t) {
  return this.update(this._pad()), assert$f(this.pending === null), this._digest(t);
};
BlockHash$4.prototype._pad = function() {
  var t = this.pendingTotal, Ie = this._delta8, Me = Ie - (t + this.padLength) % Ie, Be = new Array(Me + this.padLength);
  Be[0] = 128;
  for (var Pe = 1; Pe < Me; Pe++)
    Be[Pe] = 0;
  if (t <<= 3, this.endian === "big") {
    for (var Te = 8; Te < this.padLength; Te++)
      Be[Pe++] = 0;
    Be[Pe++] = 0, Be[Pe++] = 0, Be[Pe++] = 0, Be[Pe++] = 0, Be[Pe++] = t >>> 24 & 255, Be[Pe++] = t >>> 16 & 255, Be[Pe++] = t >>> 8 & 255, Be[Pe++] = t & 255;
  } else
    for (Be[Pe++] = t & 255, Be[Pe++] = t >>> 8 & 255, Be[Pe++] = t >>> 16 & 255, Be[Pe++] = t >>> 24 & 255, Be[Pe++] = 0, Be[Pe++] = 0, Be[Pe++] = 0, Be[Pe++] = 0, Te = 8; Te < this.padLength; Te++)
      Be[Pe++] = 0;
  return Be;
};
var sha = {}, common$4 = {}, utils$d = utils$f, rotr32 = utils$d.rotr32;
function ft_1$1(Ae, t, Ie, Me) {
  if (Ae === 0)
    return ch32$1(t, Ie, Me);
  if (Ae === 1 || Ae === 3)
    return p32(t, Ie, Me);
  if (Ae === 2)
    return maj32$1(t, Ie, Me);
}
common$4.ft_1 = ft_1$1;
function ch32$1(Ae, t, Ie) {
  return Ae & t ^ ~Ae & Ie;
}
common$4.ch32 = ch32$1;
function maj32$1(Ae, t, Ie) {
  return Ae & t ^ Ae & Ie ^ t & Ie;
}
common$4.maj32 = maj32$1;
function p32(Ae, t, Ie) {
  return Ae ^ t ^ Ie;
}
common$4.p32 = p32;
function s0_256$1(Ae) {
  return rotr32(Ae, 2) ^ rotr32(Ae, 13) ^ rotr32(Ae, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(Ae) {
  return rotr32(Ae, 6) ^ rotr32(Ae, 11) ^ rotr32(Ae, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(Ae) {
  return rotr32(Ae, 7) ^ rotr32(Ae, 18) ^ Ae >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(Ae) {
  return rotr32(Ae, 17) ^ rotr32(Ae, 19) ^ Ae >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$c = utils$f, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$c.rotl32, sum32$2 = utils$c.sum32, sum32_5$1 = utils$c.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$c.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function(t, Ie) {
  for (var Me = this.W, Be = 0; Be < 16; Be++)
    Me[Be] = t[Ie + Be];
  for (; Be < Me.length; Be++)
    Me[Be] = rotl32$1(Me[Be - 3] ^ Me[Be - 8] ^ Me[Be - 14] ^ Me[Be - 16], 1);
  var Pe = this.h[0], Te = this.h[1], je = this.h[2], Ve = this.h[3], fi = this.h[4];
  for (Be = 0; Be < Me.length; Be++) {
    var Ue = ~~(Be / 20), bi = sum32_5$1(rotl32$1(Pe, 5), ft_1(Ue, Te, je, Ve), fi, Me[Be], sha1_K[Ue]);
    fi = Ve, Ve = je, je = rotl32$1(Te, 30), Te = Pe, Pe = bi;
  }
  this.h[0] = sum32$2(this.h[0], Pe), this.h[1] = sum32$2(this.h[1], Te), this.h[2] = sum32$2(this.h[2], je), this.h[3] = sum32$2(this.h[3], Ve), this.h[4] = sum32$2(this.h[4], fi);
};
SHA1.prototype._digest = function(t) {
  return t === "hex" ? utils$c.toHex32(this.h, "big") : utils$c.split32(this.h, "big");
};
var utils$b = utils$f, common$2 = common$5, shaCommon = common$4, assert$e = minimalisticAssert$1, sum32$1 = utils$b.sum32, sum32_4$1 = utils$b.sum32_4, sum32_5 = utils$b.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$b.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function(t, Ie) {
  for (var Me = this.W, Be = 0; Be < 16; Be++)
    Me[Be] = t[Ie + Be];
  for (; Be < Me.length; Be++)
    Me[Be] = sum32_4$1(g1_256(Me[Be - 2]), Me[Be - 7], g0_256(Me[Be - 15]), Me[Be - 16]);
  var Pe = this.h[0], Te = this.h[1], je = this.h[2], Ve = this.h[3], fi = this.h[4], Ue = this.h[5], bi = this.h[6], vi = this.h[7];
  for (assert$e(this.k.length === Me.length), Be = 0; Be < Me.length; Be++) {
    var mi = sum32_5(vi, s1_256(fi), ch32(fi, Ue, bi), this.k[Be], Me[Be]), _i = sum32$1(s0_256(Pe), maj32(Pe, Te, je));
    vi = bi, bi = Ue, Ue = fi, fi = sum32$1(Ve, mi), Ve = je, je = Te, Te = Pe, Pe = sum32$1(mi, _i);
  }
  this.h[0] = sum32$1(this.h[0], Pe), this.h[1] = sum32$1(this.h[1], Te), this.h[2] = sum32$1(this.h[2], je), this.h[3] = sum32$1(this.h[3], Ve), this.h[4] = sum32$1(this.h[4], fi), this.h[5] = sum32$1(this.h[5], Ue), this.h[6] = sum32$1(this.h[6], bi), this.h[7] = sum32$1(this.h[7], vi);
};
SHA256$1.prototype._digest = function(t) {
  return t === "hex" ? utils$b.toHex32(this.h, "big") : utils$b.split32(this.h, "big");
};
var utils$a = utils$f, SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$a.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function(t) {
  return t === "hex" ? utils$a.toHex32(this.h.slice(0, 7), "big") : utils$a.split32(this.h.slice(0, 7), "big");
};
var utils$9 = utils$f, common$1 = common$5, assert$d = minimalisticAssert$1, rotr64_hi = utils$9.rotr64_hi, rotr64_lo = utils$9.rotr64_lo, shr64_hi = utils$9.shr64_hi, shr64_lo = utils$9.shr64_lo, sum64 = utils$9.sum64, sum64_hi = utils$9.sum64_hi, sum64_lo = utils$9.sum64_lo, sum64_4_hi = utils$9.sum64_4_hi, sum64_4_lo = utils$9.sum64_4_lo, sum64_5_hi = utils$9.sum64_5_hi, sum64_5_lo = utils$9.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$9.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function(t, Ie) {
  for (var Me = this.W, Be = 0; Be < 32; Be++)
    Me[Be] = t[Ie + Be];
  for (; Be < Me.length; Be += 2) {
    var Pe = g1_512_hi(Me[Be - 4], Me[Be - 3]), Te = g1_512_lo(Me[Be - 4], Me[Be - 3]), je = Me[Be - 14], Ve = Me[Be - 13], fi = g0_512_hi(Me[Be - 30], Me[Be - 29]), Ue = g0_512_lo(Me[Be - 30], Me[Be - 29]), bi = Me[Be - 32], vi = Me[Be - 31];
    Me[Be] = sum64_4_hi(
      Pe,
      Te,
      je,
      Ve,
      fi,
      Ue,
      bi,
      vi
    ), Me[Be + 1] = sum64_4_lo(
      Pe,
      Te,
      je,
      Ve,
      fi,
      Ue,
      bi,
      vi
    );
  }
};
SHA512$1.prototype._update = function(t, Ie) {
  this._prepareBlock(t, Ie);
  var Me = this.W, Be = this.h[0], Pe = this.h[1], Te = this.h[2], je = this.h[3], Ve = this.h[4], fi = this.h[5], Ue = this.h[6], bi = this.h[7], vi = this.h[8], mi = this.h[9], _i = this.h[10], Ei = this.h[11], Pi = this.h[12], Ii = this.h[13], Ci = this.h[14], Wi = this.h[15];
  assert$d(this.k.length === Me.length);
  for (var zi = 0; zi < Me.length; zi += 2) {
    var Xi = Ci, Qi = Wi, Oi = s1_512_hi(vi, mi), Yi = s1_512_lo(vi, mi), ns = ch64_hi(vi, mi, _i, Ei, Pi), ls = ch64_lo(vi, mi, _i, Ei, Pi, Ii), vn = this.k[zi], Mi = this.k[zi + 1], Ai = Me[zi], wi = Me[zi + 1], $i = sum64_5_hi(
      Xi,
      Qi,
      Oi,
      Yi,
      ns,
      ls,
      vn,
      Mi,
      Ai,
      wi
    ), Li = sum64_5_lo(
      Xi,
      Qi,
      Oi,
      Yi,
      ns,
      ls,
      vn,
      Mi,
      Ai,
      wi
    );
    Xi = s0_512_hi(Be, Pe), Qi = s0_512_lo(Be, Pe), Oi = maj64_hi(Be, Pe, Te, je, Ve), Yi = maj64_lo(Be, Pe, Te, je, Ve, fi);
    var qi = sum64_hi(Xi, Qi, Oi, Yi), Ni = sum64_lo(Xi, Qi, Oi, Yi);
    Ci = Pi, Wi = Ii, Pi = _i, Ii = Ei, _i = vi, Ei = mi, vi = sum64_hi(Ue, bi, $i, Li), mi = sum64_lo(bi, bi, $i, Li), Ue = Ve, bi = fi, Ve = Te, fi = je, Te = Be, je = Pe, Be = sum64_hi($i, Li, qi, Ni), Pe = sum64_lo($i, Li, qi, Ni);
  }
  sum64(this.h, 0, Be, Pe), sum64(this.h, 2, Te, je), sum64(this.h, 4, Ve, fi), sum64(this.h, 6, Ue, bi), sum64(this.h, 8, vi, mi), sum64(this.h, 10, _i, Ei), sum64(this.h, 12, Pi, Ii), sum64(this.h, 14, Ci, Wi);
};
SHA512$1.prototype._digest = function(t) {
  return t === "hex" ? utils$9.toHex32(this.h, "big") : utils$9.split32(this.h, "big");
};
function ch64_hi(Ae, t, Ie, Me, Be) {
  var Pe = Ae & Ie ^ ~Ae & Be;
  return Pe < 0 && (Pe += 4294967296), Pe;
}
function ch64_lo(Ae, t, Ie, Me, Be, Pe) {
  var Te = t & Me ^ ~t & Pe;
  return Te < 0 && (Te += 4294967296), Te;
}
function maj64_hi(Ae, t, Ie, Me, Be) {
  var Pe = Ae & Ie ^ Ae & Be ^ Ie & Be;
  return Pe < 0 && (Pe += 4294967296), Pe;
}
function maj64_lo(Ae, t, Ie, Me, Be, Pe) {
  var Te = t & Me ^ t & Pe ^ Me & Pe;
  return Te < 0 && (Te += 4294967296), Te;
}
function s0_512_hi(Ae, t) {
  var Ie = rotr64_hi(Ae, t, 28), Me = rotr64_hi(t, Ae, 2), Be = rotr64_hi(t, Ae, 7), Pe = Ie ^ Me ^ Be;
  return Pe < 0 && (Pe += 4294967296), Pe;
}
function s0_512_lo(Ae, t) {
  var Ie = rotr64_lo(Ae, t, 28), Me = rotr64_lo(t, Ae, 2), Be = rotr64_lo(t, Ae, 7), Pe = Ie ^ Me ^ Be;
  return Pe < 0 && (Pe += 4294967296), Pe;
}
function s1_512_hi(Ae, t) {
  var Ie = rotr64_hi(Ae, t, 14), Me = rotr64_hi(Ae, t, 18), Be = rotr64_hi(t, Ae, 9), Pe = Ie ^ Me ^ Be;
  return Pe < 0 && (Pe += 4294967296), Pe;
}
function s1_512_lo(Ae, t) {
  var Ie = rotr64_lo(Ae, t, 14), Me = rotr64_lo(Ae, t, 18), Be = rotr64_lo(t, Ae, 9), Pe = Ie ^ Me ^ Be;
  return Pe < 0 && (Pe += 4294967296), Pe;
}
function g0_512_hi(Ae, t) {
  var Ie = rotr64_hi(Ae, t, 1), Me = rotr64_hi(Ae, t, 8), Be = shr64_hi(Ae, t, 7), Pe = Ie ^ Me ^ Be;
  return Pe < 0 && (Pe += 4294967296), Pe;
}
function g0_512_lo(Ae, t) {
  var Ie = rotr64_lo(Ae, t, 1), Me = rotr64_lo(Ae, t, 8), Be = shr64_lo(Ae, t, 7), Pe = Ie ^ Me ^ Be;
  return Pe < 0 && (Pe += 4294967296), Pe;
}
function g1_512_hi(Ae, t) {
  var Ie = rotr64_hi(Ae, t, 19), Me = rotr64_hi(t, Ae, 29), Be = shr64_hi(Ae, t, 6), Pe = Ie ^ Me ^ Be;
  return Pe < 0 && (Pe += 4294967296), Pe;
}
function g1_512_lo(Ae, t) {
  var Ie = rotr64_lo(Ae, t, 19), Me = rotr64_lo(t, Ae, 29), Be = shr64_lo(Ae, t, 6), Pe = Ie ^ Me ^ Be;
  return Pe < 0 && (Pe += 4294967296), Pe;
}
var utils$8 = utils$f, SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$8.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function(t) {
  return t === "hex" ? utils$8.toHex32(this.h.slice(0, 12), "big") : utils$8.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {}, utils$7 = utils$f, common = common$5, rotl32 = utils$7.rotl32, sum32 = utils$7.sum32, sum32_3 = utils$7.sum32_3, sum32_4 = utils$7.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$7.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function(t, Ie) {
  for (var Me = this.h[0], Be = this.h[1], Pe = this.h[2], Te = this.h[3], je = this.h[4], Ve = Me, fi = Be, Ue = Pe, bi = Te, vi = je, mi = 0; mi < 80; mi++) {
    var _i = sum32(
      rotl32(
        sum32_4(Me, f$3(mi, Be, Pe, Te), t[r$1[mi] + Ie], K$3(mi)),
        s[mi]
      ),
      je
    );
    Me = je, je = Te, Te = rotl32(Pe, 10), Pe = Be, Be = _i, _i = sum32(
      rotl32(
        sum32_4(Ve, f$3(79 - mi, fi, Ue, bi), t[rh[mi] + Ie], Kh(mi)),
        sh[mi]
      ),
      vi
    ), Ve = vi, vi = bi, bi = rotl32(Ue, 10), Ue = fi, fi = _i;
  }
  _i = sum32_3(this.h[1], Pe, bi), this.h[1] = sum32_3(this.h[2], Te, vi), this.h[2] = sum32_3(this.h[3], je, Ve), this.h[3] = sum32_3(this.h[4], Me, fi), this.h[4] = sum32_3(this.h[0], Be, Ue), this.h[0] = _i;
};
RIPEMD160.prototype._digest = function(t) {
  return t === "hex" ? utils$7.toHex32(this.h, "little") : utils$7.split32(this.h, "little");
};
function f$3(Ae, t, Ie, Me) {
  return Ae <= 15 ? t ^ Ie ^ Me : Ae <= 31 ? t & Ie | ~t & Me : Ae <= 47 ? (t | ~Ie) ^ Me : Ae <= 63 ? t & Me | Ie & ~Me : t ^ (Ie | ~Me);
}
function K$3(Ae) {
  return Ae <= 15 ? 0 : Ae <= 31 ? 1518500249 : Ae <= 47 ? 1859775393 : Ae <= 63 ? 2400959708 : 2840853838;
}
function Kh(Ae) {
  return Ae <= 15 ? 1352829926 : Ae <= 31 ? 1548603684 : Ae <= 47 ? 1836072691 : Ae <= 63 ? 2053994217 : 0;
}
var r$1 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils$6 = utils$f, assert$c = minimalisticAssert$1;
function Hmac(Ae, t, Ie) {
  if (!(this instanceof Hmac))
    return new Hmac(Ae, t, Ie);
  this.Hash = Ae, this.blockSize = Ae.blockSize / 8, this.outSize = Ae.outSize / 8, this.inner = null, this.outer = null, this._init(utils$6.toArray(t, Ie));
}
var hmac$2 = Hmac;
Hmac.prototype._init = function(t) {
  t.length > this.blockSize && (t = new this.Hash().update(t).digest()), assert$c(t.length <= this.blockSize);
  for (var Ie = t.length; Ie < this.blockSize; Ie++)
    t.push(0);
  for (Ie = 0; Ie < t.length; Ie++)
    t[Ie] ^= 54;
  for (this.inner = new this.Hash().update(t), Ie = 0; Ie < t.length; Ie++)
    t[Ie] ^= 106;
  this.outer = new this.Hash().update(t);
};
Hmac.prototype.update = function(t, Ie) {
  return this.inner.update(t, Ie), this;
};
Hmac.prototype.digest = function(t) {
  return this.outer.update(this.inner.digest()), this.outer.digest(t);
};
(function(Ae) {
  var t = Ae;
  t.utils = utils$f, t.common = common$5, t.sha = sha, t.ripemd = ripemd, t.hmac = hmac$2, t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
})(hash$4);
const hash$3 = /* @__PURE__ */ getDefaultExportFromCjs(hash$4);
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
(function(Ae) {
  var t = Ae, Ie = hash$4, Me = curve, Be = utils$l, Pe = Be.assert;
  function Te(fi) {
    fi.type === "short" ? this.curve = new Me.short(fi) : fi.type === "edwards" ? this.curve = new Me.edwards(fi) : this.curve = new Me.mont(fi), this.g = this.curve.g, this.n = this.curve.n, this.hash = fi.hash, Pe(this.g.validate(), "Invalid curve"), Pe(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  t.PresetCurve = Te;
  function je(fi, Ue) {
    Object.defineProperty(t, fi, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var bi = new Te(Ue);
        return Object.defineProperty(t, fi, {
          configurable: !0,
          enumerable: !0,
          value: bi
        }), bi;
      }
    });
  }
  je("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: Ie.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), je("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: Ie.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), je("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: Ie.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), je("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: Ie.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), je("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: Ie.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), je("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Ie.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), je("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Ie.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var Ve;
  try {
    Ve = requireSecp256k1();
  } catch {
    Ve = void 0;
  }
  je("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: Ie.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      Ve
    ]
  });
})(curves$1);
var hash$2 = hash$4, utils$5 = utils$k, assert$b = minimalisticAssert$1;
function HmacDRBG$1(Ae) {
  if (!(this instanceof HmacDRBG$1))
    return new HmacDRBG$1(Ae);
  this.hash = Ae.hash, this.predResist = !!Ae.predResist, this.outLen = this.hash.outSize, this.minEntropy = Ae.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var t = utils$5.toArray(Ae.entropy, Ae.entropyEnc || "hex"), Ie = utils$5.toArray(Ae.nonce, Ae.nonceEnc || "hex"), Me = utils$5.toArray(Ae.pers, Ae.persEnc || "hex");
  assert$b(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(t, Ie, Me);
}
var hmacDrbg$1 = HmacDRBG$1;
HmacDRBG$1.prototype._init = function(t, Ie, Me) {
  var Be = t.concat(Ie).concat(Me);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var Pe = 0; Pe < this.V.length; Pe++)
    this.K[Pe] = 0, this.V[Pe] = 1;
  this._update(Be), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG$1.prototype._hmac = function() {
  return new hash$2.hmac(this.hash, this.K);
};
HmacDRBG$1.prototype._update = function(t) {
  var Ie = this._hmac().update(this.V).update([0]);
  t && (Ie = Ie.update(t)), this.K = Ie.digest(), this.V = this._hmac().update(this.V).digest(), t && (this.K = this._hmac().update(this.V).update([1]).update(t).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG$1.prototype.reseed = function(t, Ie, Me, Be) {
  typeof Ie != "string" && (Be = Me, Me = Ie, Ie = null), t = utils$5.toArray(t, Ie), Me = utils$5.toArray(Me, Be), assert$b(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(t.concat(Me || [])), this._reseed = 1;
};
HmacDRBG$1.prototype.generate = function(t, Ie, Me, Be) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof Ie != "string" && (Be = Me, Me = Ie, Ie = null), Me && (Me = utils$5.toArray(Me, Be || "hex"), this._update(Me));
  for (var Pe = []; Pe.length < t; )
    this.V = this._hmac().update(this.V).digest(), Pe = Pe.concat(this.V);
  var Te = Pe.slice(0, t);
  return this._update(Me), this._reseed++, utils$5.encode(Te, Ie);
};
var BN$3 = bnExports$1, utils$4 = utils$l, assert$a = utils$4.assert;
function KeyPair$3(Ae, t) {
  this.ec = Ae, this.priv = null, this.pub = null, t.priv && this._importPrivate(t.priv, t.privEnc), t.pub && this._importPublic(t.pub, t.pubEnc);
}
var key$2 = KeyPair$3;
KeyPair$3.fromPublic = function(t, Ie, Me) {
  return Ie instanceof KeyPair$3 ? Ie : new KeyPair$3(t, {
    pub: Ie,
    pubEnc: Me
  });
};
KeyPair$3.fromPrivate = function(t, Ie, Me) {
  return Ie instanceof KeyPair$3 ? Ie : new KeyPair$3(t, {
    priv: Ie,
    privEnc: Me
  });
};
KeyPair$3.prototype.validate = function() {
  var t = this.getPublic();
  return t.isInfinity() ? { result: !1, reason: "Invalid public key" } : t.validate() ? t.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair$3.prototype.getPublic = function(t, Ie) {
  return typeof t == "string" && (Ie = t, t = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), Ie ? this.pub.encode(Ie, t) : this.pub;
};
KeyPair$3.prototype.getPrivate = function(t) {
  return t === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair$3.prototype._importPrivate = function(t, Ie) {
  this.priv = new BN$3(t, Ie || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$3.prototype._importPublic = function(t, Ie) {
  if (t.x || t.y) {
    this.ec.curve.type === "mont" ? assert$a(t.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$a(t.x && t.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(t.x, t.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(t, Ie);
};
KeyPair$3.prototype.derive = function(t) {
  return t.validate() || assert$a(t.validate(), "public point not validated"), t.mul(this.priv).getX();
};
KeyPair$3.prototype.sign = function(t, Ie, Me) {
  return this.ec.sign(t, this, Ie, Me);
};
KeyPair$3.prototype.verify = function(t, Ie) {
  return this.ec.verify(t, Ie, this);
};
KeyPair$3.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$2 = bnExports$1, utils$3 = utils$l, assert$9 = utils$3.assert;
function Signature$3(Ae, t) {
  if (Ae instanceof Signature$3)
    return Ae;
  this._importDER(Ae, t) || (assert$9(Ae.r && Ae.s, "Signature without r or s"), this.r = new BN$2(Ae.r, 16), this.s = new BN$2(Ae.s, 16), Ae.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = Ae.recoveryParam);
}
var signature$2 = Signature$3;
function Position$1() {
  this.place = 0;
}
function getLength$1(Ae, t) {
  var Ie = Ae[t.place++];
  if (!(Ie & 128))
    return Ie;
  var Me = Ie & 15;
  if (Me === 0 || Me > 4 || Ae[t.place] === 0)
    return !1;
  for (var Be = 0, Pe = 0, Te = t.place; Pe < Me; Pe++, Te++)
    Be <<= 8, Be |= Ae[Te], Be >>>= 0;
  return Be <= 127 ? !1 : (t.place = Te, Be);
}
function rmPadding$1(Ae) {
  for (var t = 0, Ie = Ae.length - 1; !Ae[t] && !(Ae[t + 1] & 128) && t < Ie; )
    t++;
  return t === 0 ? Ae : Ae.slice(t);
}
Signature$3.prototype._importDER = function(t, Ie) {
  t = utils$3.toArray(t, Ie);
  var Me = new Position$1();
  if (t[Me.place++] !== 48)
    return !1;
  var Be = getLength$1(t, Me);
  if (Be === !1 || Be + Me.place !== t.length || t[Me.place++] !== 2)
    return !1;
  var Pe = getLength$1(t, Me);
  if (Pe === !1 || t[Me.place] & 128)
    return !1;
  var Te = t.slice(Me.place, Pe + Me.place);
  if (Me.place += Pe, t[Me.place++] !== 2)
    return !1;
  var je = getLength$1(t, Me);
  if (je === !1 || t.length !== je + Me.place || t[Me.place] & 128)
    return !1;
  var Ve = t.slice(Me.place, je + Me.place);
  if (Te[0] === 0)
    if (Te[1] & 128)
      Te = Te.slice(1);
    else
      return !1;
  if (Ve[0] === 0)
    if (Ve[1] & 128)
      Ve = Ve.slice(1);
    else
      return !1;
  return this.r = new BN$2(Te), this.s = new BN$2(Ve), this.recoveryParam = null, !0;
};
function constructLength$1(Ae, t) {
  if (t < 128) {
    Ae.push(t);
    return;
  }
  var Ie = 1 + (Math.log(t) / Math.LN2 >>> 3);
  for (Ae.push(Ie | 128); --Ie; )
    Ae.push(t >>> (Ie << 3) & 255);
  Ae.push(t);
}
Signature$3.prototype.toDER = function(t) {
  var Ie = this.r.toArray(), Me = this.s.toArray();
  for (Ie[0] & 128 && (Ie = [0].concat(Ie)), Me[0] & 128 && (Me = [0].concat(Me)), Ie = rmPadding$1(Ie), Me = rmPadding$1(Me); !Me[0] && !(Me[1] & 128); )
    Me = Me.slice(1);
  var Be = [2];
  constructLength$1(Be, Ie.length), Be = Be.concat(Ie), Be.push(2), constructLength$1(Be, Me.length);
  var Pe = Be.concat(Me), Te = [48];
  return constructLength$1(Te, Pe.length), Te = Te.concat(Pe), utils$3.encode(Te, t);
};
var ec$1, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec$1;
  hasRequiredEc = 1;
  var Ae = bnExports$1, t = hmacDrbg$1, Ie = utils$l, Me = curves$1, Be = requireBrorand(), Pe = Ie.assert, Te = key$2, je = signature$2;
  function Ve(fi) {
    if (!(this instanceof Ve))
      return new Ve(fi);
    typeof fi == "string" && (Pe(
      Object.prototype.hasOwnProperty.call(Me, fi),
      "Unknown curve " + fi
    ), fi = Me[fi]), fi instanceof Me.PresetCurve && (fi = { curve: fi }), this.curve = fi.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = fi.curve.g, this.g.precompute(fi.curve.n.bitLength() + 1), this.hash = fi.hash || fi.curve.hash;
  }
  return ec$1 = Ve, Ve.prototype.keyPair = function(Ue) {
    return new Te(this, Ue);
  }, Ve.prototype.keyFromPrivate = function(Ue, bi) {
    return Te.fromPrivate(this, Ue, bi);
  }, Ve.prototype.keyFromPublic = function(Ue, bi) {
    return Te.fromPublic(this, Ue, bi);
  }, Ve.prototype.genKeyPair = function(Ue) {
    Ue || (Ue = {});
    for (var bi = new t({
      hash: this.hash,
      pers: Ue.pers,
      persEnc: Ue.persEnc || "utf8",
      entropy: Ue.entropy || Be(this.hash.hmacStrength),
      entropyEnc: Ue.entropy && Ue.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), vi = this.n.byteLength(), mi = this.n.sub(new Ae(2)); ; ) {
      var _i = new Ae(bi.generate(vi));
      if (!(_i.cmp(mi) > 0))
        return _i.iaddn(1), this.keyFromPrivate(_i);
    }
  }, Ve.prototype._truncateToN = function(Ue, bi) {
    var vi = Ue.byteLength() * 8 - this.n.bitLength();
    return vi > 0 && (Ue = Ue.ushrn(vi)), !bi && Ue.cmp(this.n) >= 0 ? Ue.sub(this.n) : Ue;
  }, Ve.prototype.sign = function(Ue, bi, vi, mi) {
    typeof vi == "object" && (mi = vi, vi = null), mi || (mi = {}), bi = this.keyFromPrivate(bi, vi), Ue = this._truncateToN(new Ae(Ue, 16));
    for (var _i = this.n.byteLength(), Ei = bi.getPrivate().toArray("be", _i), Pi = Ue.toArray("be", _i), Ii = new t({
      hash: this.hash,
      entropy: Ei,
      nonce: Pi,
      pers: mi.pers,
      persEnc: mi.persEnc || "utf8"
    }), Ci = this.n.sub(new Ae(1)), Wi = 0; ; Wi++) {
      var zi = mi.k ? mi.k(Wi) : new Ae(Ii.generate(this.n.byteLength()));
      if (zi = this._truncateToN(zi, !0), !(zi.cmpn(1) <= 0 || zi.cmp(Ci) >= 0)) {
        var Xi = this.g.mul(zi);
        if (!Xi.isInfinity()) {
          var Qi = Xi.getX(), Oi = Qi.umod(this.n);
          if (Oi.cmpn(0) !== 0) {
            var Yi = zi.invm(this.n).mul(Oi.mul(bi.getPrivate()).iadd(Ue));
            if (Yi = Yi.umod(this.n), Yi.cmpn(0) !== 0) {
              var ns = (Xi.getY().isOdd() ? 1 : 0) | (Qi.cmp(Oi) !== 0 ? 2 : 0);
              return mi.canonical && Yi.cmp(this.nh) > 0 && (Yi = this.n.sub(Yi), ns ^= 1), new je({ r: Oi, s: Yi, recoveryParam: ns });
            }
          }
        }
      }
    }
  }, Ve.prototype.verify = function(Ue, bi, vi, mi) {
    Ue = this._truncateToN(new Ae(Ue, 16)), vi = this.keyFromPublic(vi, mi), bi = new je(bi, "hex");
    var _i = bi.r, Ei = bi.s;
    if (_i.cmpn(1) < 0 || _i.cmp(this.n) >= 0 || Ei.cmpn(1) < 0 || Ei.cmp(this.n) >= 0)
      return !1;
    var Pi = Ei.invm(this.n), Ii = Pi.mul(Ue).umod(this.n), Ci = Pi.mul(_i).umod(this.n), Wi;
    return this.curve._maxwellTrick ? (Wi = this.g.jmulAdd(Ii, vi.getPublic(), Ci), Wi.isInfinity() ? !1 : Wi.eqXToP(_i)) : (Wi = this.g.mulAdd(Ii, vi.getPublic(), Ci), Wi.isInfinity() ? !1 : Wi.getX().umod(this.n).cmp(_i) === 0);
  }, Ve.prototype.recoverPubKey = function(fi, Ue, bi, vi) {
    Pe((3 & bi) === bi, "The recovery param is more than two bits"), Ue = new je(Ue, vi);
    var mi = this.n, _i = new Ae(fi), Ei = Ue.r, Pi = Ue.s, Ii = bi & 1, Ci = bi >> 1;
    if (Ei.cmp(this.curve.p.umod(this.curve.n)) >= 0 && Ci)
      throw new Error("Unable to find sencond key candinate");
    Ci ? Ei = this.curve.pointFromX(Ei.add(this.curve.n), Ii) : Ei = this.curve.pointFromX(Ei, Ii);
    var Wi = Ue.r.invm(mi), zi = mi.sub(_i).mul(Wi).umod(mi), Xi = Pi.mul(Wi).umod(mi);
    return this.g.mulAdd(zi, Ei, Xi);
  }, Ve.prototype.getKeyRecoveryParam = function(fi, Ue, bi, vi) {
    if (Ue = new je(Ue, vi), Ue.recoveryParam !== null)
      return Ue.recoveryParam;
    for (var mi = 0; mi < 4; mi++) {
      var _i;
      try {
        _i = this.recoverPubKey(fi, Ue, mi);
      } catch {
        continue;
      }
      if (_i.eq(bi))
        return mi;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec$1;
}
var utils$2 = utils$l, assert$8 = utils$2.assert, parseBytes$2 = utils$2.parseBytes, cachedProperty$1 = utils$2.cachedProperty;
function KeyPair$2(Ae, t) {
  this.eddsa = Ae, this._secret = parseBytes$2(t.secret), Ae.isPoint(t.pub) ? this._pub = t.pub : this._pubBytes = parseBytes$2(t.pub);
}
KeyPair$2.fromPublic = function(t, Ie) {
  return Ie instanceof KeyPair$2 ? Ie : new KeyPair$2(t, { pub: Ie });
};
KeyPair$2.fromSecret = function(t, Ie) {
  return Ie instanceof KeyPair$2 ? Ie : new KeyPair$2(t, { secret: Ie });
};
KeyPair$2.prototype.secret = function() {
  return this._secret;
};
cachedProperty$1(KeyPair$2, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$2, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$2, "privBytes", function() {
  var t = this.eddsa, Ie = this.hash(), Me = t.encodingLength - 1, Be = Ie.slice(0, t.encodingLength);
  return Be[0] &= 248, Be[Me] &= 127, Be[Me] |= 64, Be;
});
cachedProperty$1(KeyPair$2, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$2, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$2, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$2.prototype.sign = function(t) {
  return assert$8(this._secret, "KeyPair can only verify"), this.eddsa.sign(t, this);
};
KeyPair$2.prototype.verify = function(t, Ie) {
  return this.eddsa.verify(t, Ie, this);
};
KeyPair$2.prototype.getSecret = function(t) {
  return assert$8(this._secret, "KeyPair is public only"), utils$2.encode(this.secret(), t);
};
KeyPair$2.prototype.getPublic = function(t) {
  return utils$2.encode(this.pubBytes(), t);
};
var key$1 = KeyPair$2, BN$1 = bnExports$1, utils$1 = utils$l, assert$7 = utils$1.assert, cachedProperty = utils$1.cachedProperty, parseBytes$1 = utils$1.parseBytes;
function Signature$2(Ae, t) {
  this.eddsa = Ae, typeof t != "object" && (t = parseBytes$1(t)), Array.isArray(t) && (assert$7(t.length === Ae.encodingLength * 2, "Signature has invalid size"), t = {
    R: t.slice(0, Ae.encodingLength),
    S: t.slice(Ae.encodingLength)
  }), assert$7(t.R && t.S, "Signature without R or S"), Ae.isPoint(t.R) && (this._R = t.R), t.S instanceof BN$1 && (this._S = t.S), this._Rencoded = Array.isArray(t.R) ? t.R : t.Rencoded, this._Sencoded = Array.isArray(t.S) ? t.S : t.Sencoded;
}
cachedProperty(Signature$2, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$2, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$2, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$2, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
Signature$2.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$2.prototype.toHex = function() {
  return utils$1.encode(this.toBytes(), "hex").toUpperCase();
};
var signature$1 = Signature$2, hash$1 = hash$4, curves = curves$1, utils = utils$l, assert$6 = utils.assert, parseBytes = utils.parseBytes, KeyPair$1 = key$1, Signature$1 = signature$1;
function EDDSA(Ae) {
  if (assert$6(Ae === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
    return new EDDSA(Ae);
  Ae = curves[Ae].curve, this.curve = Ae, this.g = Ae.g, this.g.precompute(Ae.n.bitLength() + 1), this.pointClass = Ae.point().constructor, this.encodingLength = Math.ceil(Ae.n.bitLength() / 8), this.hash = hash$1.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function(t, Ie) {
  t = parseBytes(t);
  var Me = this.keyFromSecret(Ie), Be = this.hashInt(Me.messagePrefix(), t), Pe = this.g.mul(Be), Te = this.encodePoint(Pe), je = this.hashInt(Te, Me.pubBytes(), t).mul(Me.priv()), Ve = Be.add(je).umod(this.curve.n);
  return this.makeSignature({ R: Pe, S: Ve, Rencoded: Te });
};
EDDSA.prototype.verify = function(t, Ie, Me) {
  if (t = parseBytes(t), Ie = this.makeSignature(Ie), Ie.S().gte(Ie.eddsa.curve.n) || Ie.S().isNeg())
    return !1;
  var Be = this.keyFromPublic(Me), Pe = this.hashInt(Ie.Rencoded(), Be.pubBytes(), t), Te = this.g.mul(Ie.S()), je = Ie.R().add(Be.pub().mul(Pe));
  return je.eq(Te);
};
EDDSA.prototype.hashInt = function() {
  for (var t = this.hash(), Ie = 0; Ie < arguments.length; Ie++)
    t.update(arguments[Ie]);
  return utils.intFromLE(t.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function(t) {
  return KeyPair$1.fromPublic(this, t);
};
EDDSA.prototype.keyFromSecret = function(t) {
  return KeyPair$1.fromSecret(this, t);
};
EDDSA.prototype.makeSignature = function(t) {
  return t instanceof Signature$1 ? t : new Signature$1(this, t);
};
EDDSA.prototype.encodePoint = function(t) {
  var Ie = t.getY().toArray("le", this.encodingLength);
  return Ie[this.encodingLength - 1] |= t.getX().isOdd() ? 128 : 0, Ie;
};
EDDSA.prototype.decodePoint = function(t) {
  t = utils.parseBytes(t);
  var Ie = t.length - 1, Me = t.slice(0, Ie).concat(t[Ie] & -129), Be = (t[Ie] & 128) !== 0, Pe = utils.intFromLE(Me);
  return this.curve.pointFromY(Pe, Be);
};
EDDSA.prototype.encodeInt = function(t) {
  return t.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function(t) {
  return utils.intFromLE(t);
};
EDDSA.prototype.isPoint = function(t) {
  return t instanceof this.pointClass;
};
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(Ae) {
    var t = Ae;
    t.version = require$$0$1.version, t.utils = utils$l, t.rand = requireBrorand(), t.curve = curve, t.curves = curves$1, t.ec = requireEc(), t.eddsa = eddsa;
  }(elliptic)), elliptic;
}
var asn1$1 = {}, asn1 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(Ae, t) {
      if (Ae.indexOf) return Ae.indexOf(t);
      for (var Ie = 0; Ie < Ae.length; Ie++)
        if (Ae[Ie] === t) return Ie;
      return -1;
    }, Object_keys = function(Ae) {
      if (Object.keys) return Object.keys(Ae);
      var t = [];
      for (var Ie in Ae) t.push(Ie);
      return t;
    }, forEach = function(Ae, t) {
      if (Ae.forEach) return Ae.forEach(t);
      for (var Ie = 0; Ie < Ae.length; Ie++)
        t(Ae[Ie], Ie, Ae);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(Ae, t, Ie) {
          Object.defineProperty(Ae, t, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: Ie
          });
        };
      } catch {
        return function(t, Ie, Me) {
          t[Ie] = Me;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(t) {
      if (!(this instanceof Script)) return new Script(t);
      this.code = t;
    };
    Script.prototype.runInContext = function(Ae) {
      if (!(Ae instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var t = document.createElement("iframe");
      t.style || (t.style = {}), t.style.display = "none", document.body.appendChild(t);
      var Ie = t.contentWindow, Me = Ie.eval, Be = Ie.execScript;
      !Me && Be && (Be.call(Ie, "null"), Me = Ie.eval), forEach(Object_keys(Ae), function(je) {
        Ie[je] = Ae[je];
      }), forEach(globals, function(je) {
        Ae[je] && (Ie[je] = Ae[je]);
      });
      var Pe = Object_keys(Ie), Te = Me.call(Ie, this.code);
      return forEach(Object_keys(Ie), function(je) {
        (je in Ae || indexOf(Pe, je) === -1) && (Ae[je] = Ie[je]);
      }), forEach(globals, function(je) {
        je in Ae || defineProp(Ae, je, Ie[je]);
      }), document.body.removeChild(t), Te;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(Ae) {
      var t = Script.createContext(Ae), Ie = this.runInContext(t);
      return Ae && forEach(Object_keys(t), function(Me) {
        Ae[Me] = t[Me];
      }), Ie;
    }, forEach(Object_keys(Script.prototype), function(Ae) {
      exports[Ae] = Script[Ae] = function(t) {
        var Ie = Script(t);
        return Ie[Ae].apply(Ie, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(Ae) {
      return Ae instanceof Context;
    }, exports.createScript = function(Ae) {
      return exports.Script(Ae);
    }, exports.createContext = Script.createContext = function(Ae) {
      var t = new Context();
      return typeof Ae == "object" && forEach(Object_keys(Ae), function(Ie) {
        t[Ie] = Ae[Ie];
      }), t;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(Ae) {
    var t = requireAsn1$1(), Ie = inherits_browserExports, Me = Ae;
    Me.define = function(Te, je) {
      return new Be(Te, je);
    };
    function Be(Pe, Te) {
      this.name = Pe, this.body = Te, this.decoders = {}, this.encoders = {};
    }
    Be.prototype._createNamed = function(Te) {
      var je;
      try {
        je = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        je = function(fi) {
          this._initNamed(fi);
        };
      }
      return Ie(je, Te), je.prototype._initNamed = function(fi) {
        Te.call(this, fi);
      }, new je(this);
    }, Be.prototype._getDecoder = function(Te) {
      return Te = Te || "der", this.decoders.hasOwnProperty(Te) || (this.decoders[Te] = this._createNamed(t.decoders[Te])), this.decoders[Te];
    }, Be.prototype.decode = function(Te, je, Ve) {
      return this._getDecoder(je).decode(Te, Ve);
    }, Be.prototype._getEncoder = function(Te) {
      return Te = Te || "der", this.encoders.hasOwnProperty(Te) || (this.encoders[Te] = this._createNamed(t.encoders[Te])), this.encoders[Te];
    }, Be.prototype.encode = function(Te, je, Ve) {
      return this._getEncoder(je).encode(Te, Ve);
    };
  }(api)), api;
}
var base$2 = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter) return reporter;
  hasRequiredReporter = 1;
  var Ae = inherits_browserExports;
  function t(Me) {
    this._reporterState = {
      obj: null,
      path: [],
      options: Me || {},
      errors: []
    };
  }
  reporter.Reporter = t, t.prototype.isError = function(Be) {
    return Be instanceof Ie;
  }, t.prototype.save = function() {
    var Be = this._reporterState;
    return { obj: Be.obj, pathLen: Be.path.length };
  }, t.prototype.restore = function(Be) {
    var Pe = this._reporterState;
    Pe.obj = Be.obj, Pe.path = Pe.path.slice(0, Be.pathLen);
  }, t.prototype.enterKey = function(Be) {
    return this._reporterState.path.push(Be);
  }, t.prototype.exitKey = function(Be) {
    var Pe = this._reporterState;
    Pe.path = Pe.path.slice(0, Be - 1);
  }, t.prototype.leaveKey = function(Be, Pe, Te) {
    var je = this._reporterState;
    this.exitKey(Be), je.obj !== null && (je.obj[Pe] = Te);
  }, t.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, t.prototype.enterObject = function() {
    var Be = this._reporterState, Pe = Be.obj;
    return Be.obj = {}, Pe;
  }, t.prototype.leaveObject = function(Be) {
    var Pe = this._reporterState, Te = Pe.obj;
    return Pe.obj = Be, Te;
  }, t.prototype.error = function(Be) {
    var Pe, Te = this._reporterState, je = Be instanceof Ie;
    if (je ? Pe = Be : Pe = new Ie(Te.path.map(function(Ve) {
      return "[" + JSON.stringify(Ve) + "]";
    }).join(""), Be.message || Be, Be.stack), !Te.options.partial)
      throw Pe;
    return je || Te.errors.push(Pe), Pe;
  }, t.prototype.wrapResult = function(Be) {
    var Pe = this._reporterState;
    return Pe.options.partial ? {
      result: this.isError(Be) ? null : Be,
      errors: Pe.errors
    } : Be;
  };
  function Ie(Me, Be) {
    this.path = Me, this.rethrow(Be);
  }
  return Ae(Ie, Error), Ie.prototype.rethrow = function(Be) {
    if (this.message = Be + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, Ie), !this.stack)
      try {
        throw new Error(this.message);
      } catch (Pe) {
        this.stack = Pe.stack;
      }
    return this;
  }, reporter;
}
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var Ae = inherits_browserExports, t = requireBase().Reporter, Ie = require$$1$2.Buffer;
  function Me(Pe, Te) {
    if (t.call(this, Te), !Ie.isBuffer(Pe)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = Pe, this.offset = 0, this.length = Pe.length;
  }
  Ae(Me, t), buffer.DecoderBuffer = Me, Me.prototype.save = function() {
    return { offset: this.offset, reporter: t.prototype.save.call(this) };
  }, Me.prototype.restore = function(Te) {
    var je = new Me(this.base);
    return je.offset = Te.offset, je.length = this.offset, this.offset = Te.offset, t.prototype.restore.call(this, Te.reporter), je;
  }, Me.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, Me.prototype.readUInt8 = function(Te) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(Te || "DecoderBuffer overrun");
  }, Me.prototype.skip = function(Te, je) {
    if (!(this.offset + Te <= this.length))
      return this.error(je || "DecoderBuffer overrun");
    var Ve = new Me(this.base);
    return Ve._reporterState = this._reporterState, Ve.offset = this.offset, Ve.length = this.offset + Te, this.offset += Te, Ve;
  }, Me.prototype.raw = function(Te) {
    return this.base.slice(Te ? Te.offset : this.offset, this.length);
  };
  function Be(Pe, Te) {
    if (Array.isArray(Pe))
      this.length = 0, this.value = Pe.map(function(je) {
        return je instanceof Be || (je = new Be(je, Te)), this.length += je.length, je;
      }, this);
    else if (typeof Pe == "number") {
      if (!(0 <= Pe && Pe <= 255))
        return Te.error("non-byte EncoderBuffer value");
      this.value = Pe, this.length = 1;
    } else if (typeof Pe == "string")
      this.value = Pe, this.length = Ie.byteLength(Pe);
    else if (Ie.isBuffer(Pe))
      this.value = Pe, this.length = Pe.length;
    else
      return Te.error("Unsupported type: " + typeof Pe);
  }
  return buffer.EncoderBuffer = Be, Be.prototype.join = function(Te, je) {
    return Te || (Te = new Ie(this.length)), je || (je = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(Ve) {
      Ve.join(Te, je), je += Ve.length;
    }) : (typeof this.value == "number" ? Te[je] = this.value : typeof this.value == "string" ? Te.write(this.value, je) : Ie.isBuffer(this.value) && this.value.copy(Te, je), je += this.length)), Te;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var Ae = requireBase().Reporter, t = requireBase().EncoderBuffer, Ie = requireBase().DecoderBuffer, Me = minimalisticAssert$1, Be = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], Pe = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(Be), Te = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function je(fi, Ue) {
    var bi = {};
    this._baseState = bi, bi.enc = fi, bi.parent = Ue || null, bi.children = null, bi.tag = null, bi.args = null, bi.reverseArgs = null, bi.choice = null, bi.optional = !1, bi.any = !1, bi.obj = !1, bi.use = null, bi.useDecoder = null, bi.key = null, bi.default = null, bi.explicit = null, bi.implicit = null, bi.contains = null, bi.parent || (bi.children = [], this._wrap());
  }
  node = je;
  var Ve = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return je.prototype.clone = function() {
    var Ue = this._baseState, bi = {};
    Ve.forEach(function(mi) {
      bi[mi] = Ue[mi];
    });
    var vi = new this.constructor(bi.parent);
    return vi._baseState = bi, vi;
  }, je.prototype._wrap = function() {
    var Ue = this._baseState;
    Pe.forEach(function(bi) {
      this[bi] = function() {
        var mi = new this.constructor(this);
        return Ue.children.push(mi), mi[bi].apply(mi, arguments);
      };
    }, this);
  }, je.prototype._init = function(Ue) {
    var bi = this._baseState;
    Me(bi.parent === null), Ue.call(this), bi.children = bi.children.filter(function(vi) {
      return vi._baseState.parent === this;
    }, this), Me.equal(bi.children.length, 1, "Root node can have only one child");
  }, je.prototype._useArgs = function(Ue) {
    var bi = this._baseState, vi = Ue.filter(function(mi) {
      return mi instanceof this.constructor;
    }, this);
    Ue = Ue.filter(function(mi) {
      return !(mi instanceof this.constructor);
    }, this), vi.length !== 0 && (Me(bi.children === null), bi.children = vi, vi.forEach(function(mi) {
      mi._baseState.parent = this;
    }, this)), Ue.length !== 0 && (Me(bi.args === null), bi.args = Ue, bi.reverseArgs = Ue.map(function(mi) {
      if (typeof mi != "object" || mi.constructor !== Object)
        return mi;
      var _i = {};
      return Object.keys(mi).forEach(function(Ei) {
        Ei == (Ei | 0) && (Ei |= 0);
        var Pi = mi[Ei];
        _i[Pi] = Ei;
      }), _i;
    }));
  }, Te.forEach(function(fi) {
    je.prototype[fi] = function() {
      var bi = this._baseState;
      throw new Error(fi + " not implemented for encoding: " + bi.enc);
    };
  }), Be.forEach(function(fi) {
    je.prototype[fi] = function() {
      var bi = this._baseState, vi = Array.prototype.slice.call(arguments);
      return Me(bi.tag === null), bi.tag = fi, this._useArgs(vi), this;
    };
  }), je.prototype.use = function(Ue) {
    Me(Ue);
    var bi = this._baseState;
    return Me(bi.use === null), bi.use = Ue, this;
  }, je.prototype.optional = function() {
    var Ue = this._baseState;
    return Ue.optional = !0, this;
  }, je.prototype.def = function(Ue) {
    var bi = this._baseState;
    return Me(bi.default === null), bi.default = Ue, bi.optional = !0, this;
  }, je.prototype.explicit = function(Ue) {
    var bi = this._baseState;
    return Me(bi.explicit === null && bi.implicit === null), bi.explicit = Ue, this;
  }, je.prototype.implicit = function(Ue) {
    var bi = this._baseState;
    return Me(bi.explicit === null && bi.implicit === null), bi.implicit = Ue, this;
  }, je.prototype.obj = function() {
    var Ue = this._baseState, bi = Array.prototype.slice.call(arguments);
    return Ue.obj = !0, bi.length !== 0 && this._useArgs(bi), this;
  }, je.prototype.key = function(Ue) {
    var bi = this._baseState;
    return Me(bi.key === null), bi.key = Ue, this;
  }, je.prototype.any = function() {
    var Ue = this._baseState;
    return Ue.any = !0, this;
  }, je.prototype.choice = function(Ue) {
    var bi = this._baseState;
    return Me(bi.choice === null), bi.choice = Ue, this._useArgs(Object.keys(Ue).map(function(vi) {
      return Ue[vi];
    })), this;
  }, je.prototype.contains = function(Ue) {
    var bi = this._baseState;
    return Me(bi.use === null), bi.contains = Ue, this;
  }, je.prototype._decode = function(Ue, bi) {
    var vi = this._baseState;
    if (vi.parent === null)
      return Ue.wrapResult(vi.children[0]._decode(Ue, bi));
    var mi = vi.default, _i = !0, Ei = null;
    if (vi.key !== null && (Ei = Ue.enterKey(vi.key)), vi.optional) {
      var Pi = null;
      if (vi.explicit !== null ? Pi = vi.explicit : vi.implicit !== null ? Pi = vi.implicit : vi.tag !== null && (Pi = vi.tag), Pi === null && !vi.any) {
        var Ii = Ue.save();
        try {
          vi.choice === null ? this._decodeGeneric(vi.tag, Ue, bi) : this._decodeChoice(Ue, bi), _i = !0;
        } catch {
          _i = !1;
        }
        Ue.restore(Ii);
      } else if (_i = this._peekTag(Ue, Pi, vi.any), Ue.isError(_i))
        return _i;
    }
    var Ci;
    if (vi.obj && _i && (Ci = Ue.enterObject()), _i) {
      if (vi.explicit !== null) {
        var Wi = this._decodeTag(Ue, vi.explicit);
        if (Ue.isError(Wi))
          return Wi;
        Ue = Wi;
      }
      var zi = Ue.offset;
      if (vi.use === null && vi.choice === null) {
        if (vi.any)
          var Ii = Ue.save();
        var Xi = this._decodeTag(
          Ue,
          vi.implicit !== null ? vi.implicit : vi.tag,
          vi.any
        );
        if (Ue.isError(Xi))
          return Xi;
        vi.any ? mi = Ue.raw(Ii) : Ue = Xi;
      }
      if (bi && bi.track && vi.tag !== null && bi.track(Ue.path(), zi, Ue.length, "tagged"), bi && bi.track && vi.tag !== null && bi.track(Ue.path(), Ue.offset, Ue.length, "content"), vi.any ? mi = mi : vi.choice === null ? mi = this._decodeGeneric(vi.tag, Ue, bi) : mi = this._decodeChoice(Ue, bi), Ue.isError(mi))
        return mi;
      if (!vi.any && vi.choice === null && vi.children !== null && vi.children.forEach(function(Yi) {
        Yi._decode(Ue, bi);
      }), vi.contains && (vi.tag === "octstr" || vi.tag === "bitstr")) {
        var Qi = new Ie(mi);
        mi = this._getUse(vi.contains, Ue._reporterState.obj)._decode(Qi, bi);
      }
    }
    return vi.obj && _i && (mi = Ue.leaveObject(Ci)), vi.key !== null && (mi !== null || _i === !0) ? Ue.leaveKey(Ei, vi.key, mi) : Ei !== null && Ue.exitKey(Ei), mi;
  }, je.prototype._decodeGeneric = function(Ue, bi, vi) {
    var mi = this._baseState;
    return Ue === "seq" || Ue === "set" ? null : Ue === "seqof" || Ue === "setof" ? this._decodeList(bi, Ue, mi.args[0], vi) : /str$/.test(Ue) ? this._decodeStr(bi, Ue, vi) : Ue === "objid" && mi.args ? this._decodeObjid(bi, mi.args[0], mi.args[1], vi) : Ue === "objid" ? this._decodeObjid(bi, null, null, vi) : Ue === "gentime" || Ue === "utctime" ? this._decodeTime(bi, Ue, vi) : Ue === "null_" ? this._decodeNull(bi, vi) : Ue === "bool" ? this._decodeBool(bi, vi) : Ue === "objDesc" ? this._decodeStr(bi, Ue, vi) : Ue === "int" || Ue === "enum" ? this._decodeInt(bi, mi.args && mi.args[0], vi) : mi.use !== null ? this._getUse(mi.use, bi._reporterState.obj)._decode(bi, vi) : bi.error("unknown tag: " + Ue);
  }, je.prototype._getUse = function(Ue, bi) {
    var vi = this._baseState;
    return vi.useDecoder = this._use(Ue, bi), Me(vi.useDecoder._baseState.parent === null), vi.useDecoder = vi.useDecoder._baseState.children[0], vi.implicit !== vi.useDecoder._baseState.implicit && (vi.useDecoder = vi.useDecoder.clone(), vi.useDecoder._baseState.implicit = vi.implicit), vi.useDecoder;
  }, je.prototype._decodeChoice = function(Ue, bi) {
    var vi = this._baseState, mi = null, _i = !1;
    return Object.keys(vi.choice).some(function(Ei) {
      var Pi = Ue.save(), Ii = vi.choice[Ei];
      try {
        var Ci = Ii._decode(Ue, bi);
        if (Ue.isError(Ci))
          return !1;
        mi = { type: Ei, value: Ci }, _i = !0;
      } catch {
        return Ue.restore(Pi), !1;
      }
      return !0;
    }, this), _i ? mi : Ue.error("Choice not matched");
  }, je.prototype._createEncoderBuffer = function(Ue) {
    return new t(Ue, this.reporter);
  }, je.prototype._encode = function(Ue, bi, vi) {
    var mi = this._baseState;
    if (!(mi.default !== null && mi.default === Ue)) {
      var _i = this._encodeValue(Ue, bi, vi);
      if (_i !== void 0 && !this._skipDefault(_i, bi, vi))
        return _i;
    }
  }, je.prototype._encodeValue = function(Ue, bi, vi) {
    var mi = this._baseState;
    if (mi.parent === null)
      return mi.children[0]._encode(Ue, bi || new Ae());
    var Ii = null;
    if (this.reporter = bi, mi.optional && Ue === void 0)
      if (mi.default !== null)
        Ue = mi.default;
      else
        return;
    var _i = null, Ei = !1;
    if (mi.any)
      Ii = this._createEncoderBuffer(Ue);
    else if (mi.choice)
      Ii = this._encodeChoice(Ue, bi);
    else if (mi.contains)
      _i = this._getUse(mi.contains, vi)._encode(Ue, bi), Ei = !0;
    else if (mi.children)
      _i = mi.children.map(function(zi) {
        if (zi._baseState.tag === "null_")
          return zi._encode(null, bi, Ue);
        if (zi._baseState.key === null)
          return bi.error("Child should have a key");
        var Xi = bi.enterKey(zi._baseState.key);
        if (typeof Ue != "object")
          return bi.error("Child expected, but input is not object");
        var Qi = zi._encode(Ue[zi._baseState.key], bi, Ue);
        return bi.leaveKey(Xi), Qi;
      }, this).filter(function(zi) {
        return zi;
      }), _i = this._createEncoderBuffer(_i);
    else if (mi.tag === "seqof" || mi.tag === "setof") {
      if (!(mi.args && mi.args.length === 1))
        return bi.error("Too many args for : " + mi.tag);
      if (!Array.isArray(Ue))
        return bi.error("seqof/setof, but data is not Array");
      var Pi = this.clone();
      Pi._baseState.implicit = null, _i = this._createEncoderBuffer(Ue.map(function(zi) {
        var Xi = this._baseState;
        return this._getUse(Xi.args[0], Ue)._encode(zi, bi);
      }, Pi));
    } else mi.use !== null ? Ii = this._getUse(mi.use, vi)._encode(Ue, bi) : (_i = this._encodePrimitive(mi.tag, Ue), Ei = !0);
    var Ii;
    if (!mi.any && mi.choice === null) {
      var Ci = mi.implicit !== null ? mi.implicit : mi.tag, Wi = mi.implicit === null ? "universal" : "context";
      Ci === null ? mi.use === null && bi.error("Tag could be omitted only for .use()") : mi.use === null && (Ii = this._encodeComposite(Ci, Ei, Wi, _i));
    }
    return mi.explicit !== null && (Ii = this._encodeComposite(mi.explicit, !1, "context", Ii)), Ii;
  }, je.prototype._encodeChoice = function(Ue, bi) {
    var vi = this._baseState, mi = vi.choice[Ue.type];
    return mi || Me(
      !1,
      Ue.type + " not found in " + JSON.stringify(Object.keys(vi.choice))
    ), mi._encode(Ue.value, bi);
  }, je.prototype._encodePrimitive = function(Ue, bi) {
    var vi = this._baseState;
    if (/str$/.test(Ue))
      return this._encodeStr(bi, Ue);
    if (Ue === "objid" && vi.args)
      return this._encodeObjid(bi, vi.reverseArgs[0], vi.args[1]);
    if (Ue === "objid")
      return this._encodeObjid(bi, null, null);
    if (Ue === "gentime" || Ue === "utctime")
      return this._encodeTime(bi, Ue);
    if (Ue === "null_")
      return this._encodeNull();
    if (Ue === "int" || Ue === "enum")
      return this._encodeInt(bi, vi.args && vi.reverseArgs[0]);
    if (Ue === "bool")
      return this._encodeBool(bi);
    if (Ue === "objDesc")
      return this._encodeStr(bi, Ue);
    throw new Error("Unsupported tag: " + Ue);
  }, je.prototype._isNumstr = function(Ue) {
    return /^[0-9 ]*$/.test(Ue);
  }, je.prototype._isPrintstr = function(Ue) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(Ue);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(Ae) {
    var t = Ae;
    t.Reporter = requireReporter().Reporter, t.DecoderBuffer = requireBuffer().DecoderBuffer, t.EncoderBuffer = requireBuffer().EncoderBuffer, t.Node = requireNode();
  }(base$2)), base$2;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(Ae) {
    var t = requireConstants();
    Ae.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, Ae.tagClassByName = t._reverse(Ae.tagClass), Ae.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, Ae.tagByName = t._reverse(Ae.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(Ae) {
    var t = Ae;
    t._reverse = function(Me) {
      var Be = {};
      return Object.keys(Me).forEach(function(Pe) {
        (Pe | 0) == Pe && (Pe = Pe | 0);
        var Te = Me[Pe];
        Be[Te] = Pe;
      }), Be;
    }, t.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var Ae = inherits_browserExports, t = requireAsn1$1(), Ie = t.base, Me = t.bignum, Be = t.constants.der;
  function Pe(fi) {
    this.enc = "der", this.name = fi.name, this.entity = fi, this.tree = new Te(), this.tree._init(fi.body);
  }
  der_1$1 = Pe, Pe.prototype.decode = function(Ue, bi) {
    return Ue instanceof Ie.DecoderBuffer || (Ue = new Ie.DecoderBuffer(Ue, bi)), this.tree._decode(Ue, bi);
  };
  function Te(fi) {
    Ie.Node.call(this, "der", fi);
  }
  Ae(Te, Ie.Node), Te.prototype._peekTag = function(Ue, bi, vi) {
    if (Ue.isEmpty())
      return !1;
    var mi = Ue.save(), _i = je(Ue, 'Failed to peek tag: "' + bi + '"');
    return Ue.isError(_i) ? _i : (Ue.restore(mi), _i.tag === bi || _i.tagStr === bi || _i.tagStr + "of" === bi || vi);
  }, Te.prototype._decodeTag = function(Ue, bi, vi) {
    var mi = je(
      Ue,
      'Failed to decode tag of "' + bi + '"'
    );
    if (Ue.isError(mi))
      return mi;
    var _i = Ve(
      Ue,
      mi.primitive,
      'Failed to get length of "' + bi + '"'
    );
    if (Ue.isError(_i))
      return _i;
    if (!vi && mi.tag !== bi && mi.tagStr !== bi && mi.tagStr + "of" !== bi)
      return Ue.error('Failed to match tag: "' + bi + '"');
    if (mi.primitive || _i !== null)
      return Ue.skip(_i, 'Failed to match body of: "' + bi + '"');
    var Ei = Ue.save(), Pi = this._skipUntilEnd(
      Ue,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return Ue.isError(Pi) ? Pi : (_i = Ue.offset - Ei.offset, Ue.restore(Ei), Ue.skip(_i, 'Failed to match body of: "' + bi + '"'));
  }, Te.prototype._skipUntilEnd = function(Ue, bi) {
    for (; ; ) {
      var vi = je(Ue, bi);
      if (Ue.isError(vi))
        return vi;
      var mi = Ve(Ue, vi.primitive, bi);
      if (Ue.isError(mi))
        return mi;
      var _i;
      if (vi.primitive || mi !== null ? _i = Ue.skip(mi) : _i = this._skipUntilEnd(Ue, bi), Ue.isError(_i))
        return _i;
      if (vi.tagStr === "end")
        break;
    }
  }, Te.prototype._decodeList = function(Ue, bi, vi, mi) {
    for (var _i = []; !Ue.isEmpty(); ) {
      var Ei = this._peekTag(Ue, "end");
      if (Ue.isError(Ei))
        return Ei;
      var Pi = vi.decode(Ue, "der", mi);
      if (Ue.isError(Pi) && Ei)
        break;
      _i.push(Pi);
    }
    return _i;
  }, Te.prototype._decodeStr = function(Ue, bi) {
    if (bi === "bitstr") {
      var vi = Ue.readUInt8();
      return Ue.isError(vi) ? vi : { unused: vi, data: Ue.raw() };
    } else if (bi === "bmpstr") {
      var mi = Ue.raw();
      if (mi.length % 2 === 1)
        return Ue.error("Decoding of string type: bmpstr length mismatch");
      for (var _i = "", Ei = 0; Ei < mi.length / 2; Ei++)
        _i += String.fromCharCode(mi.readUInt16BE(Ei * 2));
      return _i;
    } else if (bi === "numstr") {
      var Pi = Ue.raw().toString("ascii");
      return this._isNumstr(Pi) ? Pi : Ue.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (bi === "octstr")
        return Ue.raw();
      if (bi === "objDesc")
        return Ue.raw();
      if (bi === "printstr") {
        var Ii = Ue.raw().toString("ascii");
        return this._isPrintstr(Ii) ? Ii : Ue.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(bi) ? Ue.raw().toString() : Ue.error("Decoding of string type: " + bi + " unsupported");
    }
  }, Te.prototype._decodeObjid = function(Ue, bi, vi) {
    for (var mi, _i = [], Ei = 0; !Ue.isEmpty(); ) {
      var Pi = Ue.readUInt8();
      Ei <<= 7, Ei |= Pi & 127, Pi & 128 || (_i.push(Ei), Ei = 0);
    }
    Pi & 128 && _i.push(Ei);
    var Ii = _i[0] / 40 | 0, Ci = _i[0] % 40;
    if (vi ? mi = _i : mi = [Ii, Ci].concat(_i.slice(1)), bi) {
      var Wi = bi[mi.join(" ")];
      Wi === void 0 && (Wi = bi[mi.join(".")]), Wi !== void 0 && (mi = Wi);
    }
    return mi;
  }, Te.prototype._decodeTime = function(Ue, bi) {
    var vi = Ue.raw().toString();
    if (bi === "gentime")
      var mi = vi.slice(0, 4) | 0, _i = vi.slice(4, 6) | 0, Ei = vi.slice(6, 8) | 0, Pi = vi.slice(8, 10) | 0, Ii = vi.slice(10, 12) | 0, Ci = vi.slice(12, 14) | 0;
    else if (bi === "utctime") {
      var mi = vi.slice(0, 2) | 0, _i = vi.slice(2, 4) | 0, Ei = vi.slice(4, 6) | 0, Pi = vi.slice(6, 8) | 0, Ii = vi.slice(8, 10) | 0, Ci = vi.slice(10, 12) | 0;
      mi < 70 ? mi = 2e3 + mi : mi = 1900 + mi;
    } else
      return Ue.error("Decoding " + bi + " time is not supported yet");
    return Date.UTC(mi, _i - 1, Ei, Pi, Ii, Ci, 0);
  }, Te.prototype._decodeNull = function(Ue) {
    return null;
  }, Te.prototype._decodeBool = function(Ue) {
    var bi = Ue.readUInt8();
    return Ue.isError(bi) ? bi : bi !== 0;
  }, Te.prototype._decodeInt = function(Ue, bi) {
    var vi = Ue.raw(), mi = new Me(vi);
    return bi && (mi = bi[mi.toString(10)] || mi), mi;
  }, Te.prototype._use = function(Ue, bi) {
    return typeof Ue == "function" && (Ue = Ue(bi)), Ue._getDecoder("der").tree;
  };
  function je(fi, Ue) {
    var bi = fi.readUInt8(Ue);
    if (fi.isError(bi))
      return bi;
    var vi = Be.tagClass[bi >> 6], mi = (bi & 32) === 0;
    if ((bi & 31) === 31) {
      var _i = bi;
      for (bi = 0; (_i & 128) === 128; ) {
        if (_i = fi.readUInt8(Ue), fi.isError(_i))
          return _i;
        bi <<= 7, bi |= _i & 127;
      }
    } else
      bi &= 31;
    var Ei = Be.tag[bi];
    return {
      cls: vi,
      primitive: mi,
      tag: bi,
      tagStr: Ei
    };
  }
  function Ve(fi, Ue, bi) {
    var vi = fi.readUInt8(bi);
    if (fi.isError(vi))
      return vi;
    if (!Ue && vi === 128)
      return null;
    if (!(vi & 128))
      return vi;
    var mi = vi & 127;
    if (mi > 4)
      return fi.error("length octect is too long");
    vi = 0;
    for (var _i = 0; _i < mi; _i++) {
      vi <<= 8;
      var Ei = fi.readUInt8(bi);
      if (fi.isError(Ei))
        return Ei;
      vi |= Ei;
    }
    return vi;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var Ae = inherits_browserExports, t = require$$1$2.Buffer, Ie = requireDer$1();
  function Me(Be) {
    Ie.call(this, Be), this.enc = "pem";
  }
  return Ae(Me, Ie), pem$1 = Me, Me.prototype.decode = function(Pe, Te) {
    for (var je = Pe.toString().split(/[\r\n]+/g), Ve = Te.label.toUpperCase(), fi = /^-----(BEGIN|END) ([^-]+)-----$/, Ue = -1, bi = -1, vi = 0; vi < je.length; vi++) {
      var mi = je[vi].match(fi);
      if (mi !== null && mi[2] === Ve)
        if (Ue === -1) {
          if (mi[1] !== "BEGIN")
            break;
          Ue = vi;
        } else {
          if (mi[1] !== "END")
            break;
          bi = vi;
          break;
        }
    }
    if (Ue === -1 || bi === -1)
      throw new Error("PEM section not found for: " + Ve);
    var _i = je.slice(Ue + 1, bi).join("");
    _i.replace(/[^a-z0-9\+\/=]+/gi, "");
    var Ei = new t(_i, "base64");
    return Ie.prototype.decode.call(this, Ei, Te);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(Ae) {
    var t = Ae;
    t.der = requireDer$1(), t.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var Ae = inherits_browserExports, t = require$$1$2.Buffer, Ie = requireAsn1$1(), Me = Ie.base, Be = Ie.constants.der;
  function Pe(fi) {
    this.enc = "der", this.name = fi.name, this.entity = fi, this.tree = new Te(), this.tree._init(fi.body);
  }
  der_1 = Pe, Pe.prototype.encode = function(Ue, bi) {
    return this.tree._encode(Ue, bi).join();
  };
  function Te(fi) {
    Me.Node.call(this, "der", fi);
  }
  Ae(Te, Me.Node), Te.prototype._encodeComposite = function(Ue, bi, vi, mi) {
    var _i = Ve(Ue, bi, vi, this.reporter);
    if (mi.length < 128) {
      var Ii = new t(2);
      return Ii[0] = _i, Ii[1] = mi.length, this._createEncoderBuffer([Ii, mi]);
    }
    for (var Ei = 1, Pi = mi.length; Pi >= 256; Pi >>= 8)
      Ei++;
    var Ii = new t(2 + Ei);
    Ii[0] = _i, Ii[1] = 128 | Ei;
    for (var Pi = 1 + Ei, Ci = mi.length; Ci > 0; Pi--, Ci >>= 8)
      Ii[Pi] = Ci & 255;
    return this._createEncoderBuffer([Ii, mi]);
  }, Te.prototype._encodeStr = function(Ue, bi) {
    if (bi === "bitstr")
      return this._createEncoderBuffer([Ue.unused | 0, Ue.data]);
    if (bi === "bmpstr") {
      for (var vi = new t(Ue.length * 2), mi = 0; mi < Ue.length; mi++)
        vi.writeUInt16BE(Ue.charCodeAt(mi), mi * 2);
      return this._createEncoderBuffer(vi);
    } else return bi === "numstr" ? this._isNumstr(Ue) ? this._createEncoderBuffer(Ue) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : bi === "printstr" ? this._isPrintstr(Ue) ? this._createEncoderBuffer(Ue) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(bi) ? this._createEncoderBuffer(Ue) : bi === "objDesc" ? this._createEncoderBuffer(Ue) : this.reporter.error("Encoding of string type: " + bi + " unsupported");
  }, Te.prototype._encodeObjid = function(Ue, bi, vi) {
    if (typeof Ue == "string") {
      if (!bi)
        return this.reporter.error("string objid given, but no values map found");
      if (!bi.hasOwnProperty(Ue))
        return this.reporter.error("objid not found in values map");
      Ue = bi[Ue].split(/[\s\.]+/g);
      for (var mi = 0; mi < Ue.length; mi++)
        Ue[mi] |= 0;
    } else if (Array.isArray(Ue)) {
      Ue = Ue.slice();
      for (var mi = 0; mi < Ue.length; mi++)
        Ue[mi] |= 0;
    }
    if (!Array.isArray(Ue))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(Ue));
    if (!vi) {
      if (Ue[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      Ue.splice(0, 2, Ue[0] * 40 + Ue[1]);
    }
    for (var _i = 0, mi = 0; mi < Ue.length; mi++) {
      var Ei = Ue[mi];
      for (_i++; Ei >= 128; Ei >>= 7)
        _i++;
    }
    for (var Pi = new t(_i), Ii = Pi.length - 1, mi = Ue.length - 1; mi >= 0; mi--) {
      var Ei = Ue[mi];
      for (Pi[Ii--] = Ei & 127; (Ei >>= 7) > 0; )
        Pi[Ii--] = 128 | Ei & 127;
    }
    return this._createEncoderBuffer(Pi);
  };
  function je(fi) {
    return fi < 10 ? "0" + fi : fi;
  }
  Te.prototype._encodeTime = function(Ue, bi) {
    var vi, mi = new Date(Ue);
    return bi === "gentime" ? vi = [
      je(mi.getFullYear()),
      je(mi.getUTCMonth() + 1),
      je(mi.getUTCDate()),
      je(mi.getUTCHours()),
      je(mi.getUTCMinutes()),
      je(mi.getUTCSeconds()),
      "Z"
    ].join("") : bi === "utctime" ? vi = [
      je(mi.getFullYear() % 100),
      je(mi.getUTCMonth() + 1),
      je(mi.getUTCDate()),
      je(mi.getUTCHours()),
      je(mi.getUTCMinutes()),
      je(mi.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + bi + " time is not supported yet"), this._encodeStr(vi, "octstr");
  }, Te.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, Te.prototype._encodeInt = function(Ue, bi) {
    if (typeof Ue == "string") {
      if (!bi)
        return this.reporter.error("String int or enum given, but no values map");
      if (!bi.hasOwnProperty(Ue))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(Ue));
      Ue = bi[Ue];
    }
    if (typeof Ue != "number" && !t.isBuffer(Ue)) {
      var vi = Ue.toArray();
      !Ue.sign && vi[0] & 128 && vi.unshift(0), Ue = new t(vi);
    }
    if (t.isBuffer(Ue)) {
      var mi = Ue.length;
      Ue.length === 0 && mi++;
      var Ei = new t(mi);
      return Ue.copy(Ei), Ue.length === 0 && (Ei[0] = 0), this._createEncoderBuffer(Ei);
    }
    if (Ue < 128)
      return this._createEncoderBuffer(Ue);
    if (Ue < 256)
      return this._createEncoderBuffer([0, Ue]);
    for (var mi = 1, _i = Ue; _i >= 256; _i >>= 8)
      mi++;
    for (var Ei = new Array(mi), _i = Ei.length - 1; _i >= 0; _i--)
      Ei[_i] = Ue & 255, Ue >>= 8;
    return Ei[0] & 128 && Ei.unshift(0), this._createEncoderBuffer(new t(Ei));
  }, Te.prototype._encodeBool = function(Ue) {
    return this._createEncoderBuffer(Ue ? 255 : 0);
  }, Te.prototype._use = function(Ue, bi) {
    return typeof Ue == "function" && (Ue = Ue(bi)), Ue._getEncoder("der").tree;
  }, Te.prototype._skipDefault = function(Ue, bi, vi) {
    var mi = this._baseState, _i;
    if (mi.default === null)
      return !1;
    var Ei = Ue.join();
    if (mi.defaultBuffer === void 0 && (mi.defaultBuffer = this._encodeValue(mi.default, bi, vi).join()), Ei.length !== mi.defaultBuffer.length)
      return !1;
    for (_i = 0; _i < Ei.length; _i++)
      if (Ei[_i] !== mi.defaultBuffer[_i])
        return !1;
    return !0;
  };
  function Ve(fi, Ue, bi, vi) {
    var mi;
    if (fi === "seqof" ? fi = "seq" : fi === "setof" && (fi = "set"), Be.tagByName.hasOwnProperty(fi))
      mi = Be.tagByName[fi];
    else if (typeof fi == "number" && (fi | 0) === fi)
      mi = fi;
    else
      return vi.error("Unknown tag: " + fi);
    return mi >= 31 ? vi.error("Multi-octet tag encoding unsupported") : (Ue || (mi |= 32), mi |= Be.tagClassByName[bi || "universal"] << 6, mi);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var Ae = inherits_browserExports, t = requireDer();
  function Ie(Me) {
    t.call(this, Me), this.enc = "pem";
  }
  return Ae(Ie, t), pem = Ie, Ie.prototype.encode = function(Be, Pe) {
    for (var Te = t.prototype.encode.call(this, Be), je = Te.toString("base64"), Ve = ["-----BEGIN " + Pe.label + "-----"], fi = 0; fi < je.length; fi += 64)
      Ve.push(je.slice(fi, fi + 64));
    return Ve.push("-----END " + Pe.label + "-----"), Ve.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(Ae) {
    var t = Ae;
    t.der = requireDer(), t.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
  return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, function(Ae) {
    var t = Ae;
    t.bignum = bnExports$1, t.define = requireApi().define, t.base = requireBase(), t.constants = requireConstants(), t.decoders = requireDecoders(), t.encoders = requireEncoders();
  }(asn1)), asn1;
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate) return certificate;
  hasRequiredCertificate = 1;
  var Ae = requireAsn1$1(), t = Ae.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), Ie = Ae.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), Me = Ae.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), Be = Ae.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(Me),
      this.key("subjectPublicKey").bitstr()
    );
  }), Pe = Ae.define("RelativeDistinguishedName", function() {
    this.setof(Ie);
  }), Te = Ae.define("RDNSequence", function() {
    this.seqof(Pe);
  }), je = Ae.define("Name", function() {
    this.choice({
      rdnSequence: this.use(Te)
    });
  }), Ve = Ae.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(t),
      this.key("notAfter").use(t)
    );
  }), fi = Ae.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), Ue = Ae.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(Me),
      this.key("issuer").use(je),
      this.key("validity").use(Ve),
      this.key("subject").use(je),
      this.key("subjectPublicKeyInfo").use(Be),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(fi).optional()
    );
  }), bi = Ae.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(Ue),
      this.key("signatureAlgorithm").use(Me),
      this.key("signatureValue").bitstr()
    );
  });
  return certificate = bi, certificate;
}
var hasRequiredAsn1;
function requireAsn1() {
  if (hasRequiredAsn1) return asn1$1;
  hasRequiredAsn1 = 1;
  var Ae = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var t = Ae.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  asn1$1.RSAPrivateKey = t;
  var Ie = Ae.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  asn1$1.RSAPublicKey = Ie;
  var Me = Ae.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), Be = Ae.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(Me),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1.PublicKey = Be;
  var Pe = Ae.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(Me),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.PrivateKey = Pe;
  var Te = Ae.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.EncryptedPrivateKey = Te;
  var je = Ae.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  asn1$1.DSAPrivateKey = je, asn1$1.DSAparam = Ae.define("DSAparam", function() {
    this.int();
  });
  var Ve = Ae.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  }), fi = Ae.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(Ve),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  return asn1$1.ECPrivateKey = fi, asn1$1.signature = Ae.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), asn1$1;
}
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
  if (hasRequiredFixProc) return fixProc;
  hasRequiredFixProc = 1;
  var Ae = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, t = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, Ie = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, Me = requireEvp_bytestokey(), Be = requireBrowser$6(), Pe = requireSafeBuffer$1().Buffer;
  return fixProc = function(Te, je) {
    var Ve = Te.toString(), fi = Ve.match(Ae), Ue;
    if (fi) {
      var vi = "aes" + fi[1], mi = Pe.from(fi[2], "hex"), _i = Pe.from(fi[3].replace(/[\r\n]/g, ""), "base64"), Ei = Me(je, mi.slice(0, 8), parseInt(fi[1], 10)).key, Pi = [], Ii = Be.createDecipheriv(vi, Ei, mi);
      Pi.push(Ii.update(_i)), Pi.push(Ii.final()), Ue = Pe.concat(Pi);
    } else {
      var bi = Ve.match(Ie);
      Ue = Pe.from(bi[2].replace(/[\r\n]/g, ""), "base64");
    }
    var Ci = Ve.match(t)[1];
    return {
      tag: Ci,
      data: Ue
    };
  }, fixProc;
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
  if (hasRequiredParseAsn1) return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var Ae = requireAsn1(), t = require$$1, Ie = requireFixProc(), Me = requireBrowser$6(), Be = requireBrowser$7(), Pe = requireSafeBuffer$1().Buffer;
  function Te(Ve, fi) {
    var Ue = Ve.algorithm.decrypt.kde.kdeparams.salt, bi = parseInt(Ve.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), vi = t[Ve.algorithm.decrypt.cipher.algo.join(".")], mi = Ve.algorithm.decrypt.cipher.iv, _i = Ve.subjectPrivateKey, Ei = parseInt(vi.split("-")[1], 10) / 8, Pi = Be.pbkdf2Sync(fi, Ue, bi, Ei, "sha1"), Ii = Me.createDecipheriv(vi, Pi, mi), Ci = [];
    return Ci.push(Ii.update(_i)), Ci.push(Ii.final()), Pe.concat(Ci);
  }
  function je(Ve) {
    var fi;
    typeof Ve == "object" && !Pe.isBuffer(Ve) && (fi = Ve.passphrase, Ve = Ve.key), typeof Ve == "string" && (Ve = Pe.from(Ve));
    var Ue = Ie(Ve, fi), bi = Ue.tag, vi = Ue.data, mi, _i;
    switch (bi) {
      case "CERTIFICATE":
        _i = Ae.certificate.decode(vi, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (_i || (_i = Ae.PublicKey.decode(vi, "der")), mi = _i.algorithm.algorithm.join("."), mi) {
          case "1.2.840.113549.1.1.1":
            return Ae.RSAPublicKey.decode(_i.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return _i.subjectPrivateKey = _i.subjectPublicKey, {
              type: "ec",
              data: _i
            };
          case "1.2.840.10040.4.1":
            return _i.algorithm.params.pub_key = Ae.DSAparam.decode(_i.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: _i.algorithm.params
            };
          default:
            throw new Error("unknown key id " + mi);
        }
      case "ENCRYPTED PRIVATE KEY":
        vi = Ae.EncryptedPrivateKey.decode(vi, "der"), vi = Te(vi, fi);
      case "PRIVATE KEY":
        switch (_i = Ae.PrivateKey.decode(vi, "der"), mi = _i.algorithm.algorithm.join("."), mi) {
          case "1.2.840.113549.1.1.1":
            return Ae.RSAPrivateKey.decode(_i.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: _i.algorithm.curve,
              privateKey: Ae.ECPrivateKey.decode(_i.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return _i.algorithm.params.priv_key = Ae.DSAparam.decode(_i.subjectPrivateKey, "der"), {
              type: "dsa",
              params: _i.algorithm.params
            };
          default:
            throw new Error("unknown key id " + mi);
        }
      case "RSA PUBLIC KEY":
        return Ae.RSAPublicKey.decode(vi, "der");
      case "RSA PRIVATE KEY":
        return Ae.RSAPrivateKey.decode(vi, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: Ae.DSAPrivateKey.decode(vi, "der")
        };
      case "EC PRIVATE KEY":
        return vi = Ae.ECPrivateKey.decode(vi, "der"), {
          curve: vi.parameters.value,
          privateKey: vi.privateKey
        };
      default:
        throw new Error("unknown key type " + bi);
    }
  }
  return je.signature = Ae.signature, parseAsn1 = je, parseAsn1;
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requireBrowser$8(), Ie = requireBrowserifyRsa(), Me = requireElliptic().ec, Be = bnExports, Pe = requireParseAsn1(), Te = require$$4, je = 1;
  function Ve(Ii, Ci, Wi, zi, Xi) {
    var Qi = Pe(Ci);
    if (Qi.curve) {
      if (zi !== "ecdsa" && zi !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return fi(Ii, Qi);
    } else if (Qi.type === "dsa") {
      if (zi !== "dsa")
        throw new Error("wrong private key type");
      return Ue(Ii, Qi, Wi);
    }
    if (zi !== "rsa" && zi !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (Ci.padding !== void 0 && Ci.padding !== je)
      throw new Error("illegal or unsupported padding mode");
    Ii = Ae.concat([Xi, Ii]);
    for (var Oi = Qi.modulus.byteLength(), Yi = [0, 1]; Ii.length + Yi.length + 1 < Oi; )
      Yi.push(255);
    Yi.push(0);
    for (var ns = -1; ++ns < Ii.length; )
      Yi.push(Ii[ns]);
    var ls = Ie(Yi, Qi);
    return ls;
  }
  function fi(Ii, Ci) {
    var Wi = Te[Ci.curve.join(".")];
    if (!Wi)
      throw new Error("unknown curve " + Ci.curve.join("."));
    var zi = new Me(Wi), Xi = zi.keyFromPrivate(Ci.privateKey), Qi = Xi.sign(Ii);
    return Ae.from(Qi.toDER());
  }
  function Ue(Ii, Ci, Wi) {
    for (var zi = Ci.params.priv_key, Xi = Ci.params.p, Qi = Ci.params.q, Oi = Ci.params.g, Yi = new Be(0), ns, ls = mi(Ii, Qi).mod(Qi), vn = !1, Mi = vi(zi, Qi, Ii, Wi); vn === !1; )
      ns = Ei(Qi, Mi, Wi), Yi = Pi(Oi, ns, Xi, Qi), vn = ns.invm(Qi).imul(ls.add(zi.mul(Yi))).mod(Qi), vn.cmpn(0) === 0 && (vn = !1, Yi = new Be(0));
    return bi(Yi, vn);
  }
  function bi(Ii, Ci) {
    Ii = Ii.toArray(), Ci = Ci.toArray(), Ii[0] & 128 && (Ii = [0].concat(Ii)), Ci[0] & 128 && (Ci = [0].concat(Ci));
    var Wi = Ii.length + Ci.length + 4, zi = [
      48,
      Wi,
      2,
      Ii.length
    ];
    return zi = zi.concat(Ii, [2, Ci.length], Ci), Ae.from(zi);
  }
  function vi(Ii, Ci, Wi, zi) {
    if (Ii = Ae.from(Ii.toArray()), Ii.length < Ci.byteLength()) {
      var Xi = Ae.alloc(Ci.byteLength() - Ii.length);
      Ii = Ae.concat([Xi, Ii]);
    }
    var Qi = Wi.length, Oi = _i(Wi, Ci), Yi = Ae.alloc(Qi);
    Yi.fill(1);
    var ns = Ae.alloc(Qi);
    return ns = t(zi, ns).update(Yi).update(Ae.from([0])).update(Ii).update(Oi).digest(), Yi = t(zi, ns).update(Yi).digest(), ns = t(zi, ns).update(Yi).update(Ae.from([1])).update(Ii).update(Oi).digest(), Yi = t(zi, ns).update(Yi).digest(), { k: ns, v: Yi };
  }
  function mi(Ii, Ci) {
    var Wi = new Be(Ii), zi = (Ii.length << 3) - Ci.bitLength();
    return zi > 0 && Wi.ishrn(zi), Wi;
  }
  function _i(Ii, Ci) {
    Ii = mi(Ii, Ci), Ii = Ii.mod(Ci);
    var Wi = Ae.from(Ii.toArray());
    if (Wi.length < Ci.byteLength()) {
      var zi = Ae.alloc(Ci.byteLength() - Wi.length);
      Wi = Ae.concat([zi, Wi]);
    }
    return Wi;
  }
  function Ei(Ii, Ci, Wi) {
    var zi, Xi;
    do {
      for (zi = Ae.alloc(0); zi.length * 8 < Ii.bitLength(); )
        Ci.v = t(Wi, Ci.k).update(Ci.v).digest(), zi = Ae.concat([zi, Ci.v]);
      Xi = mi(zi, Ii), Ci.k = t(Wi, Ci.k).update(Ci.v).update(Ae.from([0])).digest(), Ci.v = t(Wi, Ci.k).update(Ci.v).digest();
    } while (Xi.cmp(Ii) !== -1);
    return Xi;
  }
  function Pi(Ii, Ci, Wi, zi) {
    return Ii.toRed(Be.mont(Wi)).redPow(Ci).fromRed().mod(zi);
  }
  return sign.exports = Ve, sign.exports.getKey = vi, sign.exports.makeKey = Ei, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = bnExports, Ie = requireElliptic().ec, Me = requireParseAsn1(), Be = require$$4;
  function Pe(fi, Ue, bi, vi, mi) {
    var _i = Me(bi);
    if (_i.type === "ec") {
      if (vi !== "ecdsa" && vi !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return Te(fi, Ue, _i);
    } else if (_i.type === "dsa") {
      if (vi !== "dsa")
        throw new Error("wrong public key type");
      return je(fi, Ue, _i);
    }
    if (vi !== "rsa" && vi !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    Ue = Ae.concat([mi, Ue]);
    for (var Ei = _i.modulus.byteLength(), Pi = [1], Ii = 0; Ue.length + Pi.length + 2 < Ei; )
      Pi.push(255), Ii += 1;
    Pi.push(0);
    for (var Ci = -1; ++Ci < Ue.length; )
      Pi.push(Ue[Ci]);
    Pi = Ae.from(Pi);
    var Wi = t.mont(_i.modulus);
    fi = new t(fi).toRed(Wi), fi = fi.redPow(new t(_i.publicExponent)), fi = Ae.from(fi.fromRed().toArray());
    var zi = Ii < 8 ? 1 : 0;
    for (Ei = Math.min(fi.length, Pi.length), fi.length !== Pi.length && (zi = 1), Ci = -1; ++Ci < Ei; )
      zi |= fi[Ci] ^ Pi[Ci];
    return zi === 0;
  }
  function Te(fi, Ue, bi) {
    var vi = Be[bi.data.algorithm.curve.join(".")];
    if (!vi)
      throw new Error("unknown curve " + bi.data.algorithm.curve.join("."));
    var mi = new Ie(vi), _i = bi.data.subjectPrivateKey.data;
    return mi.verify(Ue, fi, _i);
  }
  function je(fi, Ue, bi) {
    var vi = bi.data.p, mi = bi.data.q, _i = bi.data.g, Ei = bi.data.pub_key, Pi = Me.signature.decode(fi, "der"), Ii = Pi.s, Ci = Pi.r;
    Ve(Ii, mi), Ve(Ci, mi);
    var Wi = t.mont(vi), zi = Ii.invm(mi), Xi = _i.toRed(Wi).redPow(new t(Ue).mul(zi).mod(mi)).fromRed().mul(Ei.toRed(Wi).redPow(Ci.mul(zi).mod(mi)).fromRed()).mod(vi).mod(mi);
    return Xi.cmp(Ci) === 0;
  }
  function Ve(fi, Ue) {
    if (fi.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (fi.cmp(Ue) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = Pe, verify_1;
}
var browser$4, hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3) return browser$4;
  hasRequiredBrowser$3 = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requireBrowser$9(), Ie = requireReadableBrowser(), Me = inherits_browserExports, Be = requireSign(), Pe = requireVerify(), Te = require$$6;
  Object.keys(Te).forEach(function(bi) {
    Te[bi].id = Ae.from(Te[bi].id, "hex"), Te[bi.toLowerCase()] = Te[bi];
  });
  function je(bi) {
    Ie.Writable.call(this);
    var vi = Te[bi];
    if (!vi)
      throw new Error("Unknown message digest");
    this._hashType = vi.hash, this._hash = t(vi.hash), this._tag = vi.id, this._signType = vi.sign;
  }
  Me(je, Ie.Writable), je.prototype._write = function(vi, mi, _i) {
    this._hash.update(vi), _i();
  }, je.prototype.update = function(vi, mi) {
    return this._hash.update(typeof vi == "string" ? Ae.from(vi, mi) : vi), this;
  }, je.prototype.sign = function(vi, mi) {
    this.end();
    var _i = this._hash.digest(), Ei = Be(_i, vi, this._hashType, this._signType, this._tag);
    return mi ? Ei.toString(mi) : Ei;
  };
  function Ve(bi) {
    Ie.Writable.call(this);
    var vi = Te[bi];
    if (!vi)
      throw new Error("Unknown message digest");
    this._hash = t(vi.hash), this._tag = vi.id, this._signType = vi.sign;
  }
  Me(Ve, Ie.Writable), Ve.prototype._write = function(vi, mi, _i) {
    this._hash.update(vi), _i();
  }, Ve.prototype.update = function(vi, mi) {
    return this._hash.update(typeof vi == "string" ? Ae.from(vi, mi) : vi), this;
  }, Ve.prototype.verify = function(vi, mi, _i) {
    var Ei = typeof mi == "string" ? Ae.from(mi, _i) : mi;
    this.end();
    var Pi = this._hash.digest();
    return Pe(Ei, Pi, vi, this._signType, this._tag);
  };
  function fi(bi) {
    return new je(bi);
  }
  function Ue(bi) {
    return new Ve(bi);
  }
  return browser$4 = {
    Sign: fi,
    Verify: Ue,
    createSign: fi,
    createVerify: Ue
  }, browser$4;
}
var browser$3, hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$3;
  hasRequiredBrowser$2 = 1;
  var Ae = requireElliptic(), t = bnExports$1;
  browser$3 = function(Te) {
    return new Me(Te);
  };
  var Ie = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  Ie.p224 = Ie.secp224r1, Ie.p256 = Ie.secp256r1 = Ie.prime256v1, Ie.p192 = Ie.secp192r1 = Ie.prime192v1, Ie.p384 = Ie.secp384r1, Ie.p521 = Ie.secp521r1;
  function Me(Pe) {
    this.curveType = Ie[Pe], this.curveType || (this.curveType = {
      name: Pe
    }), this.curve = new Ae.ec(this.curveType.name), this.keys = void 0;
  }
  Me.prototype.generateKeys = function(Pe, Te) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(Pe, Te);
  }, Me.prototype.computeSecret = function(Pe, Te, je) {
    Te = Te || "utf8", Buffer.isBuffer(Pe) || (Pe = new Buffer(Pe, Te));
    var Ve = this.curve.keyFromPublic(Pe).getPublic(), fi = Ve.mul(this.keys.getPrivate()).getX();
    return Be(fi, je, this.curveType.byteLength);
  }, Me.prototype.getPublicKey = function(Pe, Te) {
    var je = this.keys.getPublic(Te === "compressed", !0);
    return Te === "hybrid" && (je[je.length - 1] % 2 ? je[0] = 7 : je[0] = 6), Be(je, Pe);
  }, Me.prototype.getPrivateKey = function(Pe) {
    return Be(this.keys.getPrivate(), Pe);
  }, Me.prototype.setPublicKey = function(Pe, Te) {
    return Te = Te || "utf8", Buffer.isBuffer(Pe) || (Pe = new Buffer(Pe, Te)), this.keys._importPublic(Pe), this;
  }, Me.prototype.setPrivateKey = function(Pe, Te) {
    Te = Te || "utf8", Buffer.isBuffer(Pe) || (Pe = new Buffer(Pe, Te));
    var je = new t(Pe);
    return je = je.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(je), this;
  };
  function Be(Pe, Te, je) {
    Array.isArray(Pe) || (Pe = Pe.toArray());
    var Ve = new Buffer(Pe);
    if (je && Ve.length < je) {
      var fi = new Buffer(je - Ve.length);
      fi.fill(0), Ve = Buffer.concat([fi, Ve]);
    }
    return Te ? Ve.toString(Te) : Ve;
  }
  return browser$3;
}
var browser$2 = {}, mgf, hasRequiredMgf;
function requireMgf() {
  if (hasRequiredMgf) return mgf;
  hasRequiredMgf = 1;
  var Ae = requireBrowser$9(), t = requireSafeBuffer$1().Buffer;
  mgf = function(Me, Be) {
    for (var Pe = t.alloc(0), Te = 0, je; Pe.length < Be; )
      je = Ie(Te++), Pe = t.concat([Pe, Ae("sha1").update(Me).update(je).digest()]);
    return Pe.slice(0, Be);
  };
  function Ie(Me) {
    var Be = t.allocUnsafe(4);
    return Be.writeUInt32BE(Me, 0), Be;
  }
  return mgf;
}
var xor, hasRequiredXor;
function requireXor() {
  return hasRequiredXor || (hasRequiredXor = 1, xor = function(t, Ie) {
    for (var Me = t.length, Be = -1; ++Be < Me; )
      t[Be] ^= Ie[Be];
    return t;
  }), xor;
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
  if (hasRequiredWithPublic) return withPublic_1;
  hasRequiredWithPublic = 1;
  var Ae = bnExports$1, t = requireSafeBuffer$1().Buffer;
  function Ie(Me, Be) {
    return t.from(Me.toRed(Ae.mont(Be.modulus)).redPow(new Ae(Be.publicExponent)).fromRed().toArray());
  }
  return withPublic_1 = Ie, withPublic_1;
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt) return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var Ae = requireParseAsn1(), t = requireBrowser$b(), Ie = requireBrowser$9(), Me = requireMgf(), Be = requireXor(), Pe = bnExports$1, Te = requireWithPublic(), je = requireBrowserifyRsa(), Ve = requireSafeBuffer$1().Buffer;
  publicEncrypt = function(mi, _i, Ei) {
    var Pi;
    mi.padding ? Pi = mi.padding : Ei ? Pi = 1 : Pi = 4;
    var Ii = Ae(mi), Ci;
    if (Pi === 4)
      Ci = fi(Ii, _i);
    else if (Pi === 1)
      Ci = Ue(Ii, _i, Ei);
    else if (Pi === 3) {
      if (Ci = new Pe(_i), Ci.cmp(Ii.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return Ei ? je(Ci, Ii) : Te(Ci, Ii);
  };
  function fi(vi, mi) {
    var _i = vi.modulus.byteLength(), Ei = mi.length, Pi = Ie("sha1").update(Ve.alloc(0)).digest(), Ii = Pi.length, Ci = 2 * Ii;
    if (Ei > _i - Ci - 2)
      throw new Error("message too long");
    var Wi = Ve.alloc(_i - Ei - Ci - 2), zi = _i - Ii - 1, Xi = t(Ii), Qi = Be(Ve.concat([Pi, Wi, Ve.alloc(1, 1), mi], zi), Me(Xi, zi)), Oi = Be(Xi, Me(Qi, Ii));
    return new Pe(Ve.concat([Ve.alloc(1), Oi, Qi], _i));
  }
  function Ue(vi, mi, _i) {
    var Ei = mi.length, Pi = vi.modulus.byteLength();
    if (Ei > Pi - 11)
      throw new Error("message too long");
    var Ii;
    return _i ? Ii = Ve.alloc(Pi - Ei - 3, 255) : Ii = bi(Pi - Ei - 3), new Pe(Ve.concat([Ve.from([0, _i ? 1 : 2]), Ii, Ve.alloc(1), mi], Pi));
  }
  function bi(vi) {
    for (var mi = Ve.allocUnsafe(vi), _i = 0, Ei = t(vi * 2), Pi = 0, Ii; _i < vi; )
      Pi === Ei.length && (Ei = t(vi * 2), Pi = 0), Ii = Ei[Pi++], Ii && (mi[_i++] = Ii);
    return mi;
  }
  return publicEncrypt;
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt) return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var Ae = requireParseAsn1(), t = requireMgf(), Ie = requireXor(), Me = bnExports$1, Be = requireBrowserifyRsa(), Pe = requireBrowser$9(), Te = requireWithPublic(), je = requireSafeBuffer$1().Buffer;
  privateDecrypt = function(vi, mi, _i) {
    var Ei;
    vi.padding ? Ei = vi.padding : _i ? Ei = 1 : Ei = 4;
    var Pi = Ae(vi), Ii = Pi.modulus.byteLength();
    if (mi.length > Ii || new Me(mi).cmp(Pi.modulus) >= 0)
      throw new Error("decryption error");
    var Ci;
    _i ? Ci = Te(new Me(mi), Pi) : Ci = Be(mi, Pi);
    var Wi = je.alloc(Ii - Ci.length);
    if (Ci = je.concat([Wi, Ci], Ii), Ei === 4)
      return Ve(Pi, Ci);
    if (Ei === 1)
      return fi(Pi, Ci, _i);
    if (Ei === 3)
      return Ci;
    throw new Error("unknown padding");
  };
  function Ve(bi, vi) {
    var mi = bi.modulus.byteLength(), _i = Pe("sha1").update(je.alloc(0)).digest(), Ei = _i.length;
    if (vi[0] !== 0)
      throw new Error("decryption error");
    var Pi = vi.slice(1, Ei + 1), Ii = vi.slice(Ei + 1), Ci = Ie(Pi, t(Ii, Ei)), Wi = Ie(Ii, t(Ci, mi - Ei - 1));
    if (Ue(_i, Wi.slice(0, Ei)))
      throw new Error("decryption error");
    for (var zi = Ei; Wi[zi] === 0; )
      zi++;
    if (Wi[zi++] !== 1)
      throw new Error("decryption error");
    return Wi.slice(zi);
  }
  function fi(bi, vi, mi) {
    for (var _i = vi.slice(0, 2), Ei = 2, Pi = 0; vi[Ei++] !== 0; )
      if (Ei >= vi.length) {
        Pi++;
        break;
      }
    var Ii = vi.slice(2, Ei - 1);
    if ((_i.toString("hex") !== "0002" && !mi || _i.toString("hex") !== "0001" && mi) && Pi++, Ii.length < 8 && Pi++, Pi)
      throw new Error("decryption error");
    return vi.slice(Ei);
  }
  function Ue(bi, vi) {
    bi = je.from(bi), vi = je.from(vi);
    var mi = 0, _i = bi.length;
    bi.length !== vi.length && (mi++, _i = Math.min(bi.length, vi.length));
    for (var Ei = -1; ++Ei < _i; )
      mi += bi[Ei] ^ vi[Ei];
    return mi;
  }
  return privateDecrypt;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function(Ae) {
    Ae.publicEncrypt = requirePublicEncrypt(), Ae.privateDecrypt = requirePrivateDecrypt(), Ae.privateEncrypt = function(Ie, Me) {
      return Ae.publicEncrypt(Ie, Me, !0);
    }, Ae.publicDecrypt = function(Ie, Me) {
      return Ae.privateDecrypt(Ie, Me, !0);
    };
  }(browser$2)), browser$2;
}
var browser$1 = {}, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser$1;
  hasRequiredBrowser = 1;
  function Ae() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var t = requireSafeBuffer$1(), Ie = requireBrowser$b(), Me = t.Buffer, Be = t.kMaxLength, Pe = commonjsGlobal.crypto || commonjsGlobal.msCrypto, Te = Math.pow(2, 32) - 1;
  function je(vi, mi) {
    if (typeof vi != "number" || vi !== vi)
      throw new TypeError("offset must be a number");
    if (vi > Te || vi < 0)
      throw new TypeError("offset must be a uint32");
    if (vi > Be || vi > mi)
      throw new RangeError("offset out of range");
  }
  function Ve(vi, mi, _i) {
    if (typeof vi != "number" || vi !== vi)
      throw new TypeError("size must be a number");
    if (vi > Te || vi < 0)
      throw new TypeError("size must be a uint32");
    if (vi + mi > _i || vi > Be)
      throw new RangeError("buffer too small");
  }
  Pe && Pe.getRandomValues || !process$1.browser ? (browser$1.randomFill = fi, browser$1.randomFillSync = bi) : (browser$1.randomFill = Ae, browser$1.randomFillSync = Ae);
  function fi(vi, mi, _i, Ei) {
    if (!Me.isBuffer(vi) && !(vi instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof mi == "function")
      Ei = mi, mi = 0, _i = vi.length;
    else if (typeof _i == "function")
      Ei = _i, _i = vi.length - mi;
    else if (typeof Ei != "function")
      throw new TypeError('"cb" argument must be a function');
    return je(mi, vi.length), Ve(_i, mi, vi.length), Ue(vi, mi, _i, Ei);
  }
  function Ue(vi, mi, _i, Ei) {
    if (process$1.browser) {
      var Pi = vi.buffer, Ii = new Uint8Array(Pi, mi, _i);
      if (Pe.getRandomValues(Ii), Ei) {
        process$1.nextTick(function() {
          Ei(null, vi);
        });
        return;
      }
      return vi;
    }
    if (Ei) {
      Ie(_i, function(Wi, zi) {
        if (Wi)
          return Ei(Wi);
        zi.copy(vi, mi), Ei(null, vi);
      });
      return;
    }
    var Ci = Ie(_i);
    return Ci.copy(vi, mi), vi;
  }
  function bi(vi, mi, _i) {
    if (typeof mi > "u" && (mi = 0), !Me.isBuffer(vi) && !(vi instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return je(mi, vi.length), _i === void 0 && (_i = vi.length - mi), Ve(_i, mi, vi.length), Ue(vi, mi, _i);
  }
  return browser$1;
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$b(), cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
  var Ae = requireAlgos(), t = Object.keys(Ae), Ie = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(t);
  cryptoBrowserify.getHashes = function() {
    return Ie;
  };
  var Me = requireBrowser$7();
  cryptoBrowserify.pbkdf2 = Me.pbkdf2, cryptoBrowserify.pbkdf2Sync = Me.pbkdf2Sync;
  var Be = requireBrowser$5();
  cryptoBrowserify.Cipher = Be.Cipher, cryptoBrowserify.createCipher = Be.createCipher, cryptoBrowserify.Cipheriv = Be.Cipheriv, cryptoBrowserify.createCipheriv = Be.createCipheriv, cryptoBrowserify.Decipher = Be.Decipher, cryptoBrowserify.createDecipher = Be.createDecipher, cryptoBrowserify.Decipheriv = Be.Decipheriv, cryptoBrowserify.createDecipheriv = Be.createDecipheriv, cryptoBrowserify.getCiphers = Be.getCiphers, cryptoBrowserify.listCiphers = Be.listCiphers;
  var Pe = requireBrowser$4();
  cryptoBrowserify.DiffieHellmanGroup = Pe.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = Pe.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = Pe.getDiffieHellman, cryptoBrowserify.createDiffieHellman = Pe.createDiffieHellman, cryptoBrowserify.DiffieHellman = Pe.DiffieHellman;
  var Te = requireBrowser$3();
  cryptoBrowserify.createSign = Te.createSign, cryptoBrowserify.Sign = Te.Sign, cryptoBrowserify.createVerify = Te.createVerify, cryptoBrowserify.Verify = Te.Verify, cryptoBrowserify.createECDH = requireBrowser$2();
  var je = requireBrowser$1();
  cryptoBrowserify.publicEncrypt = je.publicEncrypt, cryptoBrowserify.privateEncrypt = je.privateEncrypt, cryptoBrowserify.publicDecrypt = je.publicDecrypt, cryptoBrowserify.privateDecrypt = je.privateDecrypt;
  var Ve = requireBrowser();
  return cryptoBrowserify.randomFill = Ve.randomFill, cryptoBrowserify.randomFillSync = Ve.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
Object.defineProperty(node$1, "__esModule", { value: !0 });
node$1.NodeRandomSource = void 0;
const wipe_1$3 = wipe$1;
class NodeRandomSource {
  constructor() {
    if (this.isAvailable = !1, this.isInstantiated = !1, typeof commonjsRequire$1 < "u") {
      const t = requireCryptoBrowserify();
      t && t.randomBytes && (this._crypto = t, this.isAvailable = !0, this.isInstantiated = !0);
    }
  }
  randomBytes(t) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Node.js random byte generator is not available.");
    let Ie = this._crypto.randomBytes(t);
    if (Ie.length !== t)
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    const Me = new Uint8Array(t);
    for (let Be = 0; Be < Me.length; Be++)
      Me[Be] = Ie[Be];
    return (0, wipe_1$3.wipe)(Ie), Me;
  }
}
node$1.NodeRandomSource = NodeRandomSource;
Object.defineProperty(system, "__esModule", { value: !0 });
system.SystemRandomSource = void 0;
const browser_1 = browser$d, node_1 = node$1;
class SystemRandomSource {
  constructor() {
    if (this.isAvailable = !1, this.name = "", this._source = new browser_1.BrowserRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Browser";
      return;
    }
    if (this._source = new node_1.NodeRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Node";
      return;
    }
  }
  randomBytes(t) {
    if (!this.isAvailable)
      throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(t);
  }
}
system.SystemRandomSource = SystemRandomSource;
var binary = {}, int = {};
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  function t(je, Ve) {
    var fi = je >>> 16 & 65535, Ue = je & 65535, bi = Ve >>> 16 & 65535, vi = Ve & 65535;
    return Ue * vi + (fi * vi + Ue * bi << 16 >>> 0) | 0;
  }
  Ae.mul = Math.imul || t;
  function Ie(je, Ve) {
    return je + Ve | 0;
  }
  Ae.add = Ie;
  function Me(je, Ve) {
    return je - Ve | 0;
  }
  Ae.sub = Me;
  function Be(je, Ve) {
    return je << Ve | je >>> 32 - Ve;
  }
  Ae.rotl = Be;
  function Pe(je, Ve) {
    return je << 32 - Ve | je >>> Ve;
  }
  Ae.rotr = Pe;
  function Te(je) {
    return typeof je == "number" && isFinite(je) && Math.floor(je) === je;
  }
  Ae.isInteger = Number.isInteger || Te, Ae.MAX_SAFE_INTEGER = 9007199254740991, Ae.isSafeInteger = function(je) {
    return Ae.isInteger(je) && je >= -Ae.MAX_SAFE_INTEGER && je <= Ae.MAX_SAFE_INTEGER;
  };
})(int);
Object.defineProperty(binary, "__esModule", { value: !0 });
var int_1 = int;
function readInt16BE(Ae, t) {
  return t === void 0 && (t = 0), (Ae[t + 0] << 8 | Ae[t + 1]) << 16 >> 16;
}
binary.readInt16BE = readInt16BE;
function readUint16BE(Ae, t) {
  return t === void 0 && (t = 0), (Ae[t + 0] << 8 | Ae[t + 1]) >>> 0;
}
binary.readUint16BE = readUint16BE;
function readInt16LE(Ae, t) {
  return t === void 0 && (t = 0), (Ae[t + 1] << 8 | Ae[t]) << 16 >> 16;
}
binary.readInt16LE = readInt16LE;
function readUint16LE(Ae, t) {
  return t === void 0 && (t = 0), (Ae[t + 1] << 8 | Ae[t]) >>> 0;
}
binary.readUint16LE = readUint16LE;
function writeUint16BE(Ae, t, Ie) {
  return t === void 0 && (t = new Uint8Array(2)), Ie === void 0 && (Ie = 0), t[Ie + 0] = Ae >>> 8, t[Ie + 1] = Ae >>> 0, t;
}
binary.writeUint16BE = writeUint16BE;
binary.writeInt16BE = writeUint16BE;
function writeUint16LE(Ae, t, Ie) {
  return t === void 0 && (t = new Uint8Array(2)), Ie === void 0 && (Ie = 0), t[Ie + 0] = Ae >>> 0, t[Ie + 1] = Ae >>> 8, t;
}
binary.writeUint16LE = writeUint16LE;
binary.writeInt16LE = writeUint16LE;
function readInt32BE(Ae, t) {
  return t === void 0 && (t = 0), Ae[t] << 24 | Ae[t + 1] << 16 | Ae[t + 2] << 8 | Ae[t + 3];
}
binary.readInt32BE = readInt32BE;
function readUint32BE(Ae, t) {
  return t === void 0 && (t = 0), (Ae[t] << 24 | Ae[t + 1] << 16 | Ae[t + 2] << 8 | Ae[t + 3]) >>> 0;
}
binary.readUint32BE = readUint32BE;
function readInt32LE(Ae, t) {
  return t === void 0 && (t = 0), Ae[t + 3] << 24 | Ae[t + 2] << 16 | Ae[t + 1] << 8 | Ae[t];
}
binary.readInt32LE = readInt32LE;
function readUint32LE(Ae, t) {
  return t === void 0 && (t = 0), (Ae[t + 3] << 24 | Ae[t + 2] << 16 | Ae[t + 1] << 8 | Ae[t]) >>> 0;
}
binary.readUint32LE = readUint32LE;
function writeUint32BE(Ae, t, Ie) {
  return t === void 0 && (t = new Uint8Array(4)), Ie === void 0 && (Ie = 0), t[Ie + 0] = Ae >>> 24, t[Ie + 1] = Ae >>> 16, t[Ie + 2] = Ae >>> 8, t[Ie + 3] = Ae >>> 0, t;
}
binary.writeUint32BE = writeUint32BE;
binary.writeInt32BE = writeUint32BE;
function writeUint32LE(Ae, t, Ie) {
  return t === void 0 && (t = new Uint8Array(4)), Ie === void 0 && (Ie = 0), t[Ie + 0] = Ae >>> 0, t[Ie + 1] = Ae >>> 8, t[Ie + 2] = Ae >>> 16, t[Ie + 3] = Ae >>> 24, t;
}
binary.writeUint32LE = writeUint32LE;
binary.writeInt32LE = writeUint32LE;
function readInt64BE(Ae, t) {
  t === void 0 && (t = 0);
  var Ie = readInt32BE(Ae, t), Me = readInt32BE(Ae, t + 4);
  return Ie * 4294967296 + Me - (Me >> 31) * 4294967296;
}
binary.readInt64BE = readInt64BE;
function readUint64BE(Ae, t) {
  t === void 0 && (t = 0);
  var Ie = readUint32BE(Ae, t), Me = readUint32BE(Ae, t + 4);
  return Ie * 4294967296 + Me;
}
binary.readUint64BE = readUint64BE;
function readInt64LE(Ae, t) {
  t === void 0 && (t = 0);
  var Ie = readInt32LE(Ae, t), Me = readInt32LE(Ae, t + 4);
  return Me * 4294967296 + Ie - (Ie >> 31) * 4294967296;
}
binary.readInt64LE = readInt64LE;
function readUint64LE(Ae, t) {
  t === void 0 && (t = 0);
  var Ie = readUint32LE(Ae, t), Me = readUint32LE(Ae, t + 4);
  return Me * 4294967296 + Ie;
}
binary.readUint64LE = readUint64LE;
function writeUint64BE(Ae, t, Ie) {
  return t === void 0 && (t = new Uint8Array(8)), Ie === void 0 && (Ie = 0), writeUint32BE(Ae / 4294967296 >>> 0, t, Ie), writeUint32BE(Ae >>> 0, t, Ie + 4), t;
}
binary.writeUint64BE = writeUint64BE;
binary.writeInt64BE = writeUint64BE;
function writeUint64LE(Ae, t, Ie) {
  return t === void 0 && (t = new Uint8Array(8)), Ie === void 0 && (Ie = 0), writeUint32LE(Ae >>> 0, t, Ie), writeUint32LE(Ae / 4294967296 >>> 0, t, Ie + 4), t;
}
binary.writeUint64LE = writeUint64LE;
binary.writeInt64LE = writeUint64LE;
function readUintBE(Ae, t, Ie) {
  if (Ie === void 0 && (Ie = 0), Ae % 8 !== 0)
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (Ae / 8 > t.length - Ie)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var Me = 0, Be = 1, Pe = Ae / 8 + Ie - 1; Pe >= Ie; Pe--)
    Me += t[Pe] * Be, Be *= 256;
  return Me;
}
binary.readUintBE = readUintBE;
function readUintLE(Ae, t, Ie) {
  if (Ie === void 0 && (Ie = 0), Ae % 8 !== 0)
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (Ae / 8 > t.length - Ie)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var Me = 0, Be = 1, Pe = Ie; Pe < Ie + Ae / 8; Pe++)
    Me += t[Pe] * Be, Be *= 256;
  return Me;
}
binary.readUintLE = readUintLE;
function writeUintBE(Ae, t, Ie, Me) {
  if (Ie === void 0 && (Ie = new Uint8Array(Ae / 8)), Me === void 0 && (Me = 0), Ae % 8 !== 0)
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!int_1.isSafeInteger(t))
    throw new Error("writeUintBE value must be an integer");
  for (var Be = 1, Pe = Ae / 8 + Me - 1; Pe >= Me; Pe--)
    Ie[Pe] = t / Be & 255, Be *= 256;
  return Ie;
}
binary.writeUintBE = writeUintBE;
function writeUintLE(Ae, t, Ie, Me) {
  if (Ie === void 0 && (Ie = new Uint8Array(Ae / 8)), Me === void 0 && (Me = 0), Ae % 8 !== 0)
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!int_1.isSafeInteger(t))
    throw new Error("writeUintLE value must be an integer");
  for (var Be = 1, Pe = Me; Pe < Me + Ae / 8; Pe++)
    Ie[Pe] = t / Be & 255, Be *= 256;
  return Ie;
}
binary.writeUintLE = writeUintLE;
function readFloat32BE(Ae, t) {
  t === void 0 && (t = 0);
  var Ie = new DataView(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  return Ie.getFloat32(t);
}
binary.readFloat32BE = readFloat32BE;
function readFloat32LE(Ae, t) {
  t === void 0 && (t = 0);
  var Ie = new DataView(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  return Ie.getFloat32(t, !0);
}
binary.readFloat32LE = readFloat32LE;
function readFloat64BE(Ae, t) {
  t === void 0 && (t = 0);
  var Ie = new DataView(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  return Ie.getFloat64(t);
}
binary.readFloat64BE = readFloat64BE;
function readFloat64LE(Ae, t) {
  t === void 0 && (t = 0);
  var Ie = new DataView(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  return Ie.getFloat64(t, !0);
}
binary.readFloat64LE = readFloat64LE;
function writeFloat32BE(Ae, t, Ie) {
  t === void 0 && (t = new Uint8Array(4)), Ie === void 0 && (Ie = 0);
  var Me = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return Me.setFloat32(Ie, Ae), t;
}
binary.writeFloat32BE = writeFloat32BE;
function writeFloat32LE(Ae, t, Ie) {
  t === void 0 && (t = new Uint8Array(4)), Ie === void 0 && (Ie = 0);
  var Me = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return Me.setFloat32(Ie, Ae, !0), t;
}
binary.writeFloat32LE = writeFloat32LE;
function writeFloat64BE(Ae, t, Ie) {
  t === void 0 && (t = new Uint8Array(8)), Ie === void 0 && (Ie = 0);
  var Me = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return Me.setFloat64(Ie, Ae), t;
}
binary.writeFloat64BE = writeFloat64BE;
function writeFloat64LE(Ae, t, Ie) {
  t === void 0 && (t = new Uint8Array(8)), Ie === void 0 && (Ie = 0);
  var Me = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return Me.setFloat64(Ie, Ae, !0), t;
}
binary.writeFloat64LE = writeFloat64LE;
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 }), Ae.randomStringForEntropy = Ae.randomString = Ae.randomUint32 = Ae.randomBytes = Ae.defaultRandomSource = void 0;
  const t = system, Ie = binary, Me = wipe$1;
  Ae.defaultRandomSource = new t.SystemRandomSource();
  function Be(fi, Ue = Ae.defaultRandomSource) {
    return Ue.randomBytes(fi);
  }
  Ae.randomBytes = Be;
  function Pe(fi = Ae.defaultRandomSource) {
    const Ue = Be(4, fi), bi = (0, Ie.readUint32LE)(Ue);
    return (0, Me.wipe)(Ue), bi;
  }
  Ae.randomUint32 = Pe;
  const Te = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function je(fi, Ue = Te, bi = Ae.defaultRandomSource) {
    if (Ue.length < 2)
      throw new Error("randomString charset is too short");
    if (Ue.length > 256)
      throw new Error("randomString charset is too long");
    let vi = "";
    const mi = Ue.length, _i = 256 - 256 % mi;
    for (; fi > 0; ) {
      const Ei = Be(Math.ceil(fi * 256 / _i), bi);
      for (let Pi = 0; Pi < Ei.length && fi > 0; Pi++) {
        const Ii = Ei[Pi];
        Ii < _i && (vi += Ue.charAt(Ii % mi), fi--);
      }
      (0, Me.wipe)(Ei);
    }
    return vi;
  }
  Ae.randomString = je;
  function Ve(fi, Ue = Te, bi = Ae.defaultRandomSource) {
    const vi = Math.ceil(fi / (Math.log(Ue.length) / Math.LN2));
    return je(vi, Ue, bi);
  }
  Ae.randomStringForEntropy = Ve;
})(random);
var sha512 = {};
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  var t = binary, Ie = wipe$1;
  Ae.DIGEST_LENGTH = 64, Ae.BLOCK_SIZE = 128;
  var Me = (
    /** @class */
    function() {
      function je() {
        this.digestLength = Ae.DIGEST_LENGTH, this.blockSize = Ae.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return je.prototype._initState = function() {
        this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209;
      }, je.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, je.prototype.clean = function() {
        Ie.wipe(this._buffer), Ie.wipe(this._tempHi), Ie.wipe(this._tempLo), this.reset();
      }, je.prototype.update = function(Ve, fi) {
        if (fi === void 0 && (fi = Ve.length), this._finished)
          throw new Error("SHA512: can't update because hash was finished.");
        var Ue = 0;
        if (this._bytesHashed += fi, this._bufferLength > 0) {
          for (; this._bufferLength < Ae.BLOCK_SIZE && fi > 0; )
            this._buffer[this._bufferLength++] = Ve[Ue++], fi--;
          this._bufferLength === this.blockSize && (Pe(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (fi >= this.blockSize && (Ue = Pe(this._tempHi, this._tempLo, this._stateHi, this._stateLo, Ve, Ue, fi), fi %= this.blockSize); fi > 0; )
          this._buffer[this._bufferLength++] = Ve[Ue++], fi--;
        return this;
      }, je.prototype.finish = function(Ve) {
        if (!this._finished) {
          var fi = this._bytesHashed, Ue = this._bufferLength, bi = fi / 536870912 | 0, vi = fi << 3, mi = fi % 128 < 112 ? 128 : 256;
          this._buffer[Ue] = 128;
          for (var _i = Ue + 1; _i < mi - 8; _i++)
            this._buffer[_i] = 0;
          t.writeUint32BE(bi, this._buffer, mi - 8), t.writeUint32BE(vi, this._buffer, mi - 4), Pe(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, mi), this._finished = !0;
        }
        for (var _i = 0; _i < this.digestLength / 8; _i++)
          t.writeUint32BE(this._stateHi[_i], Ve, _i * 8), t.writeUint32BE(this._stateLo[_i], Ve, _i * 8 + 4);
        return this;
      }, je.prototype.digest = function() {
        var Ve = new Uint8Array(this.digestLength);
        return this.finish(Ve), Ve;
      }, je.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, je.prototype.restoreState = function(Ve) {
        return this._stateHi.set(Ve.stateHi), this._stateLo.set(Ve.stateLo), this._bufferLength = Ve.bufferLength, Ve.buffer && this._buffer.set(Ve.buffer), this._bytesHashed = Ve.bytesHashed, this._finished = !1, this;
      }, je.prototype.cleanSavedState = function(Ve) {
        Ie.wipe(Ve.stateHi), Ie.wipe(Ve.stateLo), Ve.buffer && Ie.wipe(Ve.buffer), Ve.bufferLength = 0, Ve.bytesHashed = 0;
      }, je;
    }()
  );
  Ae.SHA512 = Me;
  var Be = new Int32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  function Pe(je, Ve, fi, Ue, bi, vi, mi) {
    for (var _i = fi[0], Ei = fi[1], Pi = fi[2], Ii = fi[3], Ci = fi[4], Wi = fi[5], zi = fi[6], Xi = fi[7], Qi = Ue[0], Oi = Ue[1], Yi = Ue[2], ns = Ue[3], ls = Ue[4], vn = Ue[5], Mi = Ue[6], Ai = Ue[7], wi, $i, Li, qi, Ni, Ti, xi, Fi; mi >= 128; ) {
      for (var Si = 0; Si < 16; Si++) {
        var Vi = 8 * Si + vi;
        je[Si] = t.readUint32BE(bi, Vi), Ve[Si] = t.readUint32BE(bi, Vi + 4);
      }
      for (var Si = 0; Si < 80; Si++) {
        var ts = _i, Hi = Ei, fn = Pi, Bi = Ii, ki = Ci, Ji = Wi, Ri = zi, ji = Xi, Gi = Qi, is = Oi, os = Yi, ds = ns, ps = ls, ea = vn, ia = Mi, hs = Ai;
        if (wi = Xi, $i = Ai, Ni = $i & 65535, Ti = $i >>> 16, xi = wi & 65535, Fi = wi >>> 16, wi = (Ci >>> 14 | ls << 18) ^ (Ci >>> 18 | ls << 14) ^ (ls >>> 9 | Ci << 23), $i = (ls >>> 14 | Ci << 18) ^ (ls >>> 18 | Ci << 14) ^ (Ci >>> 9 | ls << 23), Ni += $i & 65535, Ti += $i >>> 16, xi += wi & 65535, Fi += wi >>> 16, wi = Ci & Wi ^ ~Ci & zi, $i = ls & vn ^ ~ls & Mi, Ni += $i & 65535, Ti += $i >>> 16, xi += wi & 65535, Fi += wi >>> 16, wi = Be[Si * 2], $i = Be[Si * 2 + 1], Ni += $i & 65535, Ti += $i >>> 16, xi += wi & 65535, Fi += wi >>> 16, wi = je[Si % 16], $i = Ve[Si % 16], Ni += $i & 65535, Ti += $i >>> 16, xi += wi & 65535, Fi += wi >>> 16, Ti += Ni >>> 16, xi += Ti >>> 16, Fi += xi >>> 16, Li = xi & 65535 | Fi << 16, qi = Ni & 65535 | Ti << 16, wi = Li, $i = qi, Ni = $i & 65535, Ti = $i >>> 16, xi = wi & 65535, Fi = wi >>> 16, wi = (_i >>> 28 | Qi << 4) ^ (Qi >>> 2 | _i << 30) ^ (Qi >>> 7 | _i << 25), $i = (Qi >>> 28 | _i << 4) ^ (_i >>> 2 | Qi << 30) ^ (_i >>> 7 | Qi << 25), Ni += $i & 65535, Ti += $i >>> 16, xi += wi & 65535, Fi += wi >>> 16, wi = _i & Ei ^ _i & Pi ^ Ei & Pi, $i = Qi & Oi ^ Qi & Yi ^ Oi & Yi, Ni += $i & 65535, Ti += $i >>> 16, xi += wi & 65535, Fi += wi >>> 16, Ti += Ni >>> 16, xi += Ti >>> 16, Fi += xi >>> 16, ji = xi & 65535 | Fi << 16, hs = Ni & 65535 | Ti << 16, wi = Bi, $i = ds, Ni = $i & 65535, Ti = $i >>> 16, xi = wi & 65535, Fi = wi >>> 16, wi = Li, $i = qi, Ni += $i & 65535, Ti += $i >>> 16, xi += wi & 65535, Fi += wi >>> 16, Ti += Ni >>> 16, xi += Ti >>> 16, Fi += xi >>> 16, Bi = xi & 65535 | Fi << 16, ds = Ni & 65535 | Ti << 16, Ei = ts, Pi = Hi, Ii = fn, Ci = Bi, Wi = ki, zi = Ji, Xi = Ri, _i = ji, Oi = Gi, Yi = is, ns = os, ls = ds, vn = ps, Mi = ea, Ai = ia, Qi = hs, Si % 16 === 15)
          for (var Vi = 0; Vi < 16; Vi++)
            wi = je[Vi], $i = Ve[Vi], Ni = $i & 65535, Ti = $i >>> 16, xi = wi & 65535, Fi = wi >>> 16, wi = je[(Vi + 9) % 16], $i = Ve[(Vi + 9) % 16], Ni += $i & 65535, Ti += $i >>> 16, xi += wi & 65535, Fi += wi >>> 16, Li = je[(Vi + 1) % 16], qi = Ve[(Vi + 1) % 16], wi = (Li >>> 1 | qi << 31) ^ (Li >>> 8 | qi << 24) ^ Li >>> 7, $i = (qi >>> 1 | Li << 31) ^ (qi >>> 8 | Li << 24) ^ (qi >>> 7 | Li << 25), Ni += $i & 65535, Ti += $i >>> 16, xi += wi & 65535, Fi += wi >>> 16, Li = je[(Vi + 14) % 16], qi = Ve[(Vi + 14) % 16], wi = (Li >>> 19 | qi << 13) ^ (qi >>> 29 | Li << 3) ^ Li >>> 6, $i = (qi >>> 19 | Li << 13) ^ (Li >>> 29 | qi << 3) ^ (qi >>> 6 | Li << 26), Ni += $i & 65535, Ti += $i >>> 16, xi += wi & 65535, Fi += wi >>> 16, Ti += Ni >>> 16, xi += Ti >>> 16, Fi += xi >>> 16, je[Vi] = xi & 65535 | Fi << 16, Ve[Vi] = Ni & 65535 | Ti << 16;
      }
      wi = _i, $i = Qi, Ni = $i & 65535, Ti = $i >>> 16, xi = wi & 65535, Fi = wi >>> 16, wi = fi[0], $i = Ue[0], Ni += $i & 65535, Ti += $i >>> 16, xi += wi & 65535, Fi += wi >>> 16, Ti += Ni >>> 16, xi += Ti >>> 16, Fi += xi >>> 16, fi[0] = _i = xi & 65535 | Fi << 16, Ue[0] = Qi = Ni & 65535 | Ti << 16, wi = Ei, $i = Oi, Ni = $i & 65535, Ti = $i >>> 16, xi = wi & 65535, Fi = wi >>> 16, wi = fi[1], $i = Ue[1], Ni += $i & 65535, Ti += $i >>> 16, xi += wi & 65535, Fi += wi >>> 16, Ti += Ni >>> 16, xi += Ti >>> 16, Fi += xi >>> 16, fi[1] = Ei = xi & 65535 | Fi << 16, Ue[1] = Oi = Ni & 65535 | Ti << 16, wi = Pi, $i = Yi, Ni = $i & 65535, Ti = $i >>> 16, xi = wi & 65535, Fi = wi >>> 16, wi = fi[2], $i = Ue[2], Ni += $i & 65535, Ti += $i >>> 16, xi += wi & 65535, Fi += wi >>> 16, Ti += Ni >>> 16, xi += Ti >>> 16, Fi += xi >>> 16, fi[2] = Pi = xi & 65535 | Fi << 16, Ue[2] = Yi = Ni & 65535 | Ti << 16, wi = Ii, $i = ns, Ni = $i & 65535, Ti = $i >>> 16, xi = wi & 65535, Fi = wi >>> 16, wi = fi[3], $i = Ue[3], Ni += $i & 65535, Ti += $i >>> 16, xi += wi & 65535, Fi += wi >>> 16, Ti += Ni >>> 16, xi += Ti >>> 16, Fi += xi >>> 16, fi[3] = Ii = xi & 65535 | Fi << 16, Ue[3] = ns = Ni & 65535 | Ti << 16, wi = Ci, $i = ls, Ni = $i & 65535, Ti = $i >>> 16, xi = wi & 65535, Fi = wi >>> 16, wi = fi[4], $i = Ue[4], Ni += $i & 65535, Ti += $i >>> 16, xi += wi & 65535, Fi += wi >>> 16, Ti += Ni >>> 16, xi += Ti >>> 16, Fi += xi >>> 16, fi[4] = Ci = xi & 65535 | Fi << 16, Ue[4] = ls = Ni & 65535 | Ti << 16, wi = Wi, $i = vn, Ni = $i & 65535, Ti = $i >>> 16, xi = wi & 65535, Fi = wi >>> 16, wi = fi[5], $i = Ue[5], Ni += $i & 65535, Ti += $i >>> 16, xi += wi & 65535, Fi += wi >>> 16, Ti += Ni >>> 16, xi += Ti >>> 16, Fi += xi >>> 16, fi[5] = Wi = xi & 65535 | Fi << 16, Ue[5] = vn = Ni & 65535 | Ti << 16, wi = zi, $i = Mi, Ni = $i & 65535, Ti = $i >>> 16, xi = wi & 65535, Fi = wi >>> 16, wi = fi[6], $i = Ue[6], Ni += $i & 65535, Ti += $i >>> 16, xi += wi & 65535, Fi += wi >>> 16, Ti += Ni >>> 16, xi += Ti >>> 16, Fi += xi >>> 16, fi[6] = zi = xi & 65535 | Fi << 16, Ue[6] = Mi = Ni & 65535 | Ti << 16, wi = Xi, $i = Ai, Ni = $i & 65535, Ti = $i >>> 16, xi = wi & 65535, Fi = wi >>> 16, wi = fi[7], $i = Ue[7], Ni += $i & 65535, Ti += $i >>> 16, xi += wi & 65535, Fi += wi >>> 16, Ti += Ni >>> 16, xi += Ti >>> 16, Fi += xi >>> 16, fi[7] = Xi = xi & 65535 | Fi << 16, Ue[7] = Ai = Ni & 65535 | Ti << 16, vi += 128, mi -= 128;
    }
    return vi;
  }
  function Te(je) {
    var Ve = new Me();
    Ve.update(je);
    var fi = Ve.digest();
    return Ve.clean(), fi;
  }
  Ae.hash = Te;
})(sha512);
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 }), Ae.convertSecretKeyToX25519 = Ae.convertPublicKeyToX25519 = Ae.verify = Ae.sign = Ae.extractPublicKeyFromSecretKey = Ae.generateKeyPair = Ae.generateKeyPairFromSeed = Ae.SEED_LENGTH = Ae.SECRET_KEY_LENGTH = Ae.PUBLIC_KEY_LENGTH = Ae.SIGNATURE_LENGTH = void 0;
  const t = random, Ie = sha512, Me = wipe$1;
  Ae.SIGNATURE_LENGTH = 64, Ae.PUBLIC_KEY_LENGTH = 32, Ae.SECRET_KEY_LENGTH = 64, Ae.SEED_LENGTH = 32;
  function Be(Bi) {
    const ki = new Float64Array(16);
    if (Bi)
      for (let Ji = 0; Ji < Bi.length; Ji++)
        ki[Ji] = Bi[Ji];
    return ki;
  }
  const Pe = new Uint8Array(32);
  Pe[0] = 9;
  const Te = Be(), je = Be([1]), Ve = Be([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]), fi = Be([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]), Ue = Be([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]), bi = Be([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]), vi = Be([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function mi(Bi, ki) {
    for (let Ji = 0; Ji < 16; Ji++)
      Bi[Ji] = ki[Ji] | 0;
  }
  function _i(Bi) {
    let ki = 1;
    for (let Ji = 0; Ji < 16; Ji++) {
      let Ri = Bi[Ji] + ki + 65535;
      ki = Math.floor(Ri / 65536), Bi[Ji] = Ri - ki * 65536;
    }
    Bi[0] += ki - 1 + 37 * (ki - 1);
  }
  function Ei(Bi, ki, Ji) {
    const Ri = ~(Ji - 1);
    for (let ji = 0; ji < 16; ji++) {
      const Gi = Ri & (Bi[ji] ^ ki[ji]);
      Bi[ji] ^= Gi, ki[ji] ^= Gi;
    }
  }
  function Pi(Bi, ki) {
    const Ji = Be(), Ri = Be();
    for (let ji = 0; ji < 16; ji++)
      Ri[ji] = ki[ji];
    _i(Ri), _i(Ri), _i(Ri);
    for (let ji = 0; ji < 2; ji++) {
      Ji[0] = Ri[0] - 65517;
      for (let is = 1; is < 15; is++)
        Ji[is] = Ri[is] - 65535 - (Ji[is - 1] >> 16 & 1), Ji[is - 1] &= 65535;
      Ji[15] = Ri[15] - 32767 - (Ji[14] >> 16 & 1);
      const Gi = Ji[15] >> 16 & 1;
      Ji[14] &= 65535, Ei(Ri, Ji, 1 - Gi);
    }
    for (let ji = 0; ji < 16; ji++)
      Bi[2 * ji] = Ri[ji] & 255, Bi[2 * ji + 1] = Ri[ji] >> 8;
  }
  function Ii(Bi, ki) {
    let Ji = 0;
    for (let Ri = 0; Ri < 32; Ri++)
      Ji |= Bi[Ri] ^ ki[Ri];
    return (1 & Ji - 1 >>> 8) - 1;
  }
  function Ci(Bi, ki) {
    const Ji = new Uint8Array(32), Ri = new Uint8Array(32);
    return Pi(Ji, Bi), Pi(Ri, ki), Ii(Ji, Ri);
  }
  function Wi(Bi) {
    const ki = new Uint8Array(32);
    return Pi(ki, Bi), ki[0] & 1;
  }
  function zi(Bi, ki) {
    for (let Ji = 0; Ji < 16; Ji++)
      Bi[Ji] = ki[2 * Ji] + (ki[2 * Ji + 1] << 8);
    Bi[15] &= 32767;
  }
  function Xi(Bi, ki, Ji) {
    for (let Ri = 0; Ri < 16; Ri++)
      Bi[Ri] = ki[Ri] + Ji[Ri];
  }
  function Qi(Bi, ki, Ji) {
    for (let Ri = 0; Ri < 16; Ri++)
      Bi[Ri] = ki[Ri] - Ji[Ri];
  }
  function Oi(Bi, ki, Ji) {
    let Ri, ji, Gi = 0, is = 0, os = 0, ds = 0, ps = 0, ea = 0, ia = 0, hs = 0, fa = 0, gs = 0, sa = 0, aa = 0, Ds = 0, ra = 0, ca = 0, ta = 0, oa = 0, da = 0, Zi = 0, Ui = 0, Ki = 0, En = 0, ss = 0, as = 0, us = 0, ua = 0, ma = 0, na = 0, wa = 0, ga = 0, Ea = 0, xa = Ji[0], $a = Ji[1], la = Ji[2], Sa = Ji[3], Aa = Ji[4], ha = Ji[5], Ma = Ji[6], Da = Ji[7], va = Ji[8], Ba = Ji[9], Pa = Ji[10], pa = Ji[11], Ra = Ji[12], _a = Ji[13], ya = Ji[14], qa = Ji[15];
    Ri = ki[0], Gi += Ri * xa, is += Ri * $a, os += Ri * la, ds += Ri * Sa, ps += Ri * Aa, ea += Ri * ha, ia += Ri * Ma, hs += Ri * Da, fa += Ri * va, gs += Ri * Ba, sa += Ri * Pa, aa += Ri * pa, Ds += Ri * Ra, ra += Ri * _a, ca += Ri * ya, ta += Ri * qa, Ri = ki[1], is += Ri * xa, os += Ri * $a, ds += Ri * la, ps += Ri * Sa, ea += Ri * Aa, ia += Ri * ha, hs += Ri * Ma, fa += Ri * Da, gs += Ri * va, sa += Ri * Ba, aa += Ri * Pa, Ds += Ri * pa, ra += Ri * Ra, ca += Ri * _a, ta += Ri * ya, oa += Ri * qa, Ri = ki[2], os += Ri * xa, ds += Ri * $a, ps += Ri * la, ea += Ri * Sa, ia += Ri * Aa, hs += Ri * ha, fa += Ri * Ma, gs += Ri * Da, sa += Ri * va, aa += Ri * Ba, Ds += Ri * Pa, ra += Ri * pa, ca += Ri * Ra, ta += Ri * _a, oa += Ri * ya, da += Ri * qa, Ri = ki[3], ds += Ri * xa, ps += Ri * $a, ea += Ri * la, ia += Ri * Sa, hs += Ri * Aa, fa += Ri * ha, gs += Ri * Ma, sa += Ri * Da, aa += Ri * va, Ds += Ri * Ba, ra += Ri * Pa, ca += Ri * pa, ta += Ri * Ra, oa += Ri * _a, da += Ri * ya, Zi += Ri * qa, Ri = ki[4], ps += Ri * xa, ea += Ri * $a, ia += Ri * la, hs += Ri * Sa, fa += Ri * Aa, gs += Ri * ha, sa += Ri * Ma, aa += Ri * Da, Ds += Ri * va, ra += Ri * Ba, ca += Ri * Pa, ta += Ri * pa, oa += Ri * Ra, da += Ri * _a, Zi += Ri * ya, Ui += Ri * qa, Ri = ki[5], ea += Ri * xa, ia += Ri * $a, hs += Ri * la, fa += Ri * Sa, gs += Ri * Aa, sa += Ri * ha, aa += Ri * Ma, Ds += Ri * Da, ra += Ri * va, ca += Ri * Ba, ta += Ri * Pa, oa += Ri * pa, da += Ri * Ra, Zi += Ri * _a, Ui += Ri * ya, Ki += Ri * qa, Ri = ki[6], ia += Ri * xa, hs += Ri * $a, fa += Ri * la, gs += Ri * Sa, sa += Ri * Aa, aa += Ri * ha, Ds += Ri * Ma, ra += Ri * Da, ca += Ri * va, ta += Ri * Ba, oa += Ri * Pa, da += Ri * pa, Zi += Ri * Ra, Ui += Ri * _a, Ki += Ri * ya, En += Ri * qa, Ri = ki[7], hs += Ri * xa, fa += Ri * $a, gs += Ri * la, sa += Ri * Sa, aa += Ri * Aa, Ds += Ri * ha, ra += Ri * Ma, ca += Ri * Da, ta += Ri * va, oa += Ri * Ba, da += Ri * Pa, Zi += Ri * pa, Ui += Ri * Ra, Ki += Ri * _a, En += Ri * ya, ss += Ri * qa, Ri = ki[8], fa += Ri * xa, gs += Ri * $a, sa += Ri * la, aa += Ri * Sa, Ds += Ri * Aa, ra += Ri * ha, ca += Ri * Ma, ta += Ri * Da, oa += Ri * va, da += Ri * Ba, Zi += Ri * Pa, Ui += Ri * pa, Ki += Ri * Ra, En += Ri * _a, ss += Ri * ya, as += Ri * qa, Ri = ki[9], gs += Ri * xa, sa += Ri * $a, aa += Ri * la, Ds += Ri * Sa, ra += Ri * Aa, ca += Ri * ha, ta += Ri * Ma, oa += Ri * Da, da += Ri * va, Zi += Ri * Ba, Ui += Ri * Pa, Ki += Ri * pa, En += Ri * Ra, ss += Ri * _a, as += Ri * ya, us += Ri * qa, Ri = ki[10], sa += Ri * xa, aa += Ri * $a, Ds += Ri * la, ra += Ri * Sa, ca += Ri * Aa, ta += Ri * ha, oa += Ri * Ma, da += Ri * Da, Zi += Ri * va, Ui += Ri * Ba, Ki += Ri * Pa, En += Ri * pa, ss += Ri * Ra, as += Ri * _a, us += Ri * ya, ua += Ri * qa, Ri = ki[11], aa += Ri * xa, Ds += Ri * $a, ra += Ri * la, ca += Ri * Sa, ta += Ri * Aa, oa += Ri * ha, da += Ri * Ma, Zi += Ri * Da, Ui += Ri * va, Ki += Ri * Ba, En += Ri * Pa, ss += Ri * pa, as += Ri * Ra, us += Ri * _a, ua += Ri * ya, ma += Ri * qa, Ri = ki[12], Ds += Ri * xa, ra += Ri * $a, ca += Ri * la, ta += Ri * Sa, oa += Ri * Aa, da += Ri * ha, Zi += Ri * Ma, Ui += Ri * Da, Ki += Ri * va, En += Ri * Ba, ss += Ri * Pa, as += Ri * pa, us += Ri * Ra, ua += Ri * _a, ma += Ri * ya, na += Ri * qa, Ri = ki[13], ra += Ri * xa, ca += Ri * $a, ta += Ri * la, oa += Ri * Sa, da += Ri * Aa, Zi += Ri * ha, Ui += Ri * Ma, Ki += Ri * Da, En += Ri * va, ss += Ri * Ba, as += Ri * Pa, us += Ri * pa, ua += Ri * Ra, ma += Ri * _a, na += Ri * ya, wa += Ri * qa, Ri = ki[14], ca += Ri * xa, ta += Ri * $a, oa += Ri * la, da += Ri * Sa, Zi += Ri * Aa, Ui += Ri * ha, Ki += Ri * Ma, En += Ri * Da, ss += Ri * va, as += Ri * Ba, us += Ri * Pa, ua += Ri * pa, ma += Ri * Ra, na += Ri * _a, wa += Ri * ya, ga += Ri * qa, Ri = ki[15], ta += Ri * xa, oa += Ri * $a, da += Ri * la, Zi += Ri * Sa, Ui += Ri * Aa, Ki += Ri * ha, En += Ri * Ma, ss += Ri * Da, as += Ri * va, us += Ri * Ba, ua += Ri * Pa, ma += Ri * pa, na += Ri * Ra, wa += Ri * _a, ga += Ri * ya, Ea += Ri * qa, Gi += 38 * oa, is += 38 * da, os += 38 * Zi, ds += 38 * Ui, ps += 38 * Ki, ea += 38 * En, ia += 38 * ss, hs += 38 * as, fa += 38 * us, gs += 38 * ua, sa += 38 * ma, aa += 38 * na, Ds += 38 * wa, ra += 38 * ga, ca += 38 * Ea, ji = 1, Ri = Gi + ji + 65535, ji = Math.floor(Ri / 65536), Gi = Ri - ji * 65536, Ri = is + ji + 65535, ji = Math.floor(Ri / 65536), is = Ri - ji * 65536, Ri = os + ji + 65535, ji = Math.floor(Ri / 65536), os = Ri - ji * 65536, Ri = ds + ji + 65535, ji = Math.floor(Ri / 65536), ds = Ri - ji * 65536, Ri = ps + ji + 65535, ji = Math.floor(Ri / 65536), ps = Ri - ji * 65536, Ri = ea + ji + 65535, ji = Math.floor(Ri / 65536), ea = Ri - ji * 65536, Ri = ia + ji + 65535, ji = Math.floor(Ri / 65536), ia = Ri - ji * 65536, Ri = hs + ji + 65535, ji = Math.floor(Ri / 65536), hs = Ri - ji * 65536, Ri = fa + ji + 65535, ji = Math.floor(Ri / 65536), fa = Ri - ji * 65536, Ri = gs + ji + 65535, ji = Math.floor(Ri / 65536), gs = Ri - ji * 65536, Ri = sa + ji + 65535, ji = Math.floor(Ri / 65536), sa = Ri - ji * 65536, Ri = aa + ji + 65535, ji = Math.floor(Ri / 65536), aa = Ri - ji * 65536, Ri = Ds + ji + 65535, ji = Math.floor(Ri / 65536), Ds = Ri - ji * 65536, Ri = ra + ji + 65535, ji = Math.floor(Ri / 65536), ra = Ri - ji * 65536, Ri = ca + ji + 65535, ji = Math.floor(Ri / 65536), ca = Ri - ji * 65536, Ri = ta + ji + 65535, ji = Math.floor(Ri / 65536), ta = Ri - ji * 65536, Gi += ji - 1 + 37 * (ji - 1), ji = 1, Ri = Gi + ji + 65535, ji = Math.floor(Ri / 65536), Gi = Ri - ji * 65536, Ri = is + ji + 65535, ji = Math.floor(Ri / 65536), is = Ri - ji * 65536, Ri = os + ji + 65535, ji = Math.floor(Ri / 65536), os = Ri - ji * 65536, Ri = ds + ji + 65535, ji = Math.floor(Ri / 65536), ds = Ri - ji * 65536, Ri = ps + ji + 65535, ji = Math.floor(Ri / 65536), ps = Ri - ji * 65536, Ri = ea + ji + 65535, ji = Math.floor(Ri / 65536), ea = Ri - ji * 65536, Ri = ia + ji + 65535, ji = Math.floor(Ri / 65536), ia = Ri - ji * 65536, Ri = hs + ji + 65535, ji = Math.floor(Ri / 65536), hs = Ri - ji * 65536, Ri = fa + ji + 65535, ji = Math.floor(Ri / 65536), fa = Ri - ji * 65536, Ri = gs + ji + 65535, ji = Math.floor(Ri / 65536), gs = Ri - ji * 65536, Ri = sa + ji + 65535, ji = Math.floor(Ri / 65536), sa = Ri - ji * 65536, Ri = aa + ji + 65535, ji = Math.floor(Ri / 65536), aa = Ri - ji * 65536, Ri = Ds + ji + 65535, ji = Math.floor(Ri / 65536), Ds = Ri - ji * 65536, Ri = ra + ji + 65535, ji = Math.floor(Ri / 65536), ra = Ri - ji * 65536, Ri = ca + ji + 65535, ji = Math.floor(Ri / 65536), ca = Ri - ji * 65536, Ri = ta + ji + 65535, ji = Math.floor(Ri / 65536), ta = Ri - ji * 65536, Gi += ji - 1 + 37 * (ji - 1), Bi[0] = Gi, Bi[1] = is, Bi[2] = os, Bi[3] = ds, Bi[4] = ps, Bi[5] = ea, Bi[6] = ia, Bi[7] = hs, Bi[8] = fa, Bi[9] = gs, Bi[10] = sa, Bi[11] = aa, Bi[12] = Ds, Bi[13] = ra, Bi[14] = ca, Bi[15] = ta;
  }
  function Yi(Bi, ki) {
    Oi(Bi, ki, ki);
  }
  function ns(Bi, ki) {
    const Ji = Be();
    let Ri;
    for (Ri = 0; Ri < 16; Ri++)
      Ji[Ri] = ki[Ri];
    for (Ri = 253; Ri >= 0; Ri--)
      Yi(Ji, Ji), Ri !== 2 && Ri !== 4 && Oi(Ji, Ji, ki);
    for (Ri = 0; Ri < 16; Ri++)
      Bi[Ri] = Ji[Ri];
  }
  function ls(Bi, ki) {
    const Ji = Be();
    let Ri;
    for (Ri = 0; Ri < 16; Ri++)
      Ji[Ri] = ki[Ri];
    for (Ri = 250; Ri >= 0; Ri--)
      Yi(Ji, Ji), Ri !== 1 && Oi(Ji, Ji, ki);
    for (Ri = 0; Ri < 16; Ri++)
      Bi[Ri] = Ji[Ri];
  }
  function vn(Bi, ki) {
    const Ji = Be(), Ri = Be(), ji = Be(), Gi = Be(), is = Be(), os = Be(), ds = Be(), ps = Be(), ea = Be();
    Qi(Ji, Bi[1], Bi[0]), Qi(ea, ki[1], ki[0]), Oi(Ji, Ji, ea), Xi(Ri, Bi[0], Bi[1]), Xi(ea, ki[0], ki[1]), Oi(Ri, Ri, ea), Oi(ji, Bi[3], ki[3]), Oi(ji, ji, fi), Oi(Gi, Bi[2], ki[2]), Xi(Gi, Gi, Gi), Qi(is, Ri, Ji), Qi(os, Gi, ji), Xi(ds, Gi, ji), Xi(ps, Ri, Ji), Oi(Bi[0], is, os), Oi(Bi[1], ps, ds), Oi(Bi[2], ds, os), Oi(Bi[3], is, ps);
  }
  function Mi(Bi, ki, Ji) {
    for (let Ri = 0; Ri < 4; Ri++)
      Ei(Bi[Ri], ki[Ri], Ji);
  }
  function Ai(Bi, ki) {
    const Ji = Be(), Ri = Be(), ji = Be();
    ns(ji, ki[2]), Oi(Ji, ki[0], ji), Oi(Ri, ki[1], ji), Pi(Bi, Ri), Bi[31] ^= Wi(Ji) << 7;
  }
  function wi(Bi, ki, Ji) {
    mi(Bi[0], Te), mi(Bi[1], je), mi(Bi[2], je), mi(Bi[3], Te);
    for (let Ri = 255; Ri >= 0; --Ri) {
      const ji = Ji[Ri / 8 | 0] >> (Ri & 7) & 1;
      Mi(Bi, ki, ji), vn(ki, Bi), vn(Bi, Bi), Mi(Bi, ki, ji);
    }
  }
  function $i(Bi, ki) {
    const Ji = [Be(), Be(), Be(), Be()];
    mi(Ji[0], Ue), mi(Ji[1], bi), mi(Ji[2], je), Oi(Ji[3], Ue, bi), wi(Bi, Ji, ki);
  }
  function Li(Bi) {
    if (Bi.length !== Ae.SEED_LENGTH)
      throw new Error(`ed25519: seed must be ${Ae.SEED_LENGTH} bytes`);
    const ki = (0, Ie.hash)(Bi);
    ki[0] &= 248, ki[31] &= 127, ki[31] |= 64;
    const Ji = new Uint8Array(32), Ri = [Be(), Be(), Be(), Be()];
    $i(Ri, ki), Ai(Ji, Ri);
    const ji = new Uint8Array(64);
    return ji.set(Bi), ji.set(Ji, 32), {
      publicKey: Ji,
      secretKey: ji
    };
  }
  Ae.generateKeyPairFromSeed = Li;
  function qi(Bi) {
    const ki = (0, t.randomBytes)(32, Bi), Ji = Li(ki);
    return (0, Me.wipe)(ki), Ji;
  }
  Ae.generateKeyPair = qi;
  function Ni(Bi) {
    if (Bi.length !== Ae.SECRET_KEY_LENGTH)
      throw new Error(`ed25519: secret key must be ${Ae.SECRET_KEY_LENGTH} bytes`);
    return new Uint8Array(Bi.subarray(32));
  }
  Ae.extractPublicKeyFromSecretKey = Ni;
  const Ti = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function xi(Bi, ki) {
    let Ji, Ri, ji, Gi;
    for (Ri = 63; Ri >= 32; --Ri) {
      for (Ji = 0, ji = Ri - 32, Gi = Ri - 12; ji < Gi; ++ji)
        ki[ji] += Ji - 16 * ki[Ri] * Ti[ji - (Ri - 32)], Ji = Math.floor((ki[ji] + 128) / 256), ki[ji] -= Ji * 256;
      ki[ji] += Ji, ki[Ri] = 0;
    }
    for (Ji = 0, ji = 0; ji < 32; ji++)
      ki[ji] += Ji - (ki[31] >> 4) * Ti[ji], Ji = ki[ji] >> 8, ki[ji] &= 255;
    for (ji = 0; ji < 32; ji++)
      ki[ji] -= Ji * Ti[ji];
    for (Ri = 0; Ri < 32; Ri++)
      ki[Ri + 1] += ki[Ri] >> 8, Bi[Ri] = ki[Ri] & 255;
  }
  function Fi(Bi) {
    const ki = new Float64Array(64);
    for (let Ji = 0; Ji < 64; Ji++)
      ki[Ji] = Bi[Ji];
    for (let Ji = 0; Ji < 64; Ji++)
      Bi[Ji] = 0;
    xi(Bi, ki);
  }
  function Si(Bi, ki) {
    const Ji = new Float64Array(64), Ri = [Be(), Be(), Be(), Be()], ji = (0, Ie.hash)(Bi.subarray(0, 32));
    ji[0] &= 248, ji[31] &= 127, ji[31] |= 64;
    const Gi = new Uint8Array(64);
    Gi.set(ji.subarray(32), 32);
    const is = new Ie.SHA512();
    is.update(Gi.subarray(32)), is.update(ki);
    const os = is.digest();
    is.clean(), Fi(os), $i(Ri, os), Ai(Gi, Ri), is.reset(), is.update(Gi.subarray(0, 32)), is.update(Bi.subarray(32)), is.update(ki);
    const ds = is.digest();
    Fi(ds);
    for (let ps = 0; ps < 32; ps++)
      Ji[ps] = os[ps];
    for (let ps = 0; ps < 32; ps++)
      for (let ea = 0; ea < 32; ea++)
        Ji[ps + ea] += ds[ps] * ji[ea];
    return xi(Gi.subarray(32), Ji), Gi;
  }
  Ae.sign = Si;
  function Vi(Bi, ki) {
    const Ji = Be(), Ri = Be(), ji = Be(), Gi = Be(), is = Be(), os = Be(), ds = Be();
    return mi(Bi[2], je), zi(Bi[1], ki), Yi(ji, Bi[1]), Oi(Gi, ji, Ve), Qi(ji, ji, Bi[2]), Xi(Gi, Bi[2], Gi), Yi(is, Gi), Yi(os, is), Oi(ds, os, is), Oi(Ji, ds, ji), Oi(Ji, Ji, Gi), ls(Ji, Ji), Oi(Ji, Ji, ji), Oi(Ji, Ji, Gi), Oi(Ji, Ji, Gi), Oi(Bi[0], Ji, Gi), Yi(Ri, Bi[0]), Oi(Ri, Ri, Gi), Ci(Ri, ji) && Oi(Bi[0], Bi[0], vi), Yi(Ri, Bi[0]), Oi(Ri, Ri, Gi), Ci(Ri, ji) ? -1 : (Wi(Bi[0]) === ki[31] >> 7 && Qi(Bi[0], Te, Bi[0]), Oi(Bi[3], Bi[0], Bi[1]), 0);
  }
  function ts(Bi, ki, Ji) {
    const Ri = new Uint8Array(32), ji = [Be(), Be(), Be(), Be()], Gi = [Be(), Be(), Be(), Be()];
    if (Ji.length !== Ae.SIGNATURE_LENGTH)
      throw new Error(`ed25519: signature must be ${Ae.SIGNATURE_LENGTH} bytes`);
    if (Vi(Gi, Bi))
      return !1;
    const is = new Ie.SHA512();
    is.update(Ji.subarray(0, 32)), is.update(Bi), is.update(ki);
    const os = is.digest();
    return Fi(os), wi(ji, Gi, os), $i(Gi, Ji.subarray(32)), vn(ji, Gi), Ai(Ri, ji), !Ii(Ji, Ri);
  }
  Ae.verify = ts;
  function Hi(Bi) {
    let ki = [Be(), Be(), Be(), Be()];
    if (Vi(ki, Bi))
      throw new Error("Ed25519: invalid public key");
    let Ji = Be(), Ri = Be(), ji = ki[1];
    Xi(Ji, je, ji), Qi(Ri, je, ji), ns(Ri, Ri), Oi(Ji, Ji, Ri);
    let Gi = new Uint8Array(32);
    return Pi(Gi, Ji), Gi;
  }
  Ae.convertPublicKeyToX25519 = Hi;
  function fn(Bi) {
    const ki = (0, Ie.hash)(Bi.subarray(0, 32));
    ki[0] &= 248, ki[31] &= 127, ki[31] |= 64;
    const Ji = new Uint8Array(ki.subarray(0, 32));
    return (0, Me.wipe)(ki), Ji;
  }
  Ae.convertSecretKeyToX25519 = fn;
})(ed25519);
const JWT_IRIDIUM_ALG = "EdDSA", JWT_IRIDIUM_TYP = "JWT", JWT_DELIMITER = ".", JWT_ENCODING = "base64url", JSON_ENCODING = "utf8", DATA_ENCODING = "utf8", DID_DELIMITER = ":", DID_PREFIX = "did", DID_METHOD = "key", MULTICODEC_ED25519_ENCODING = "base58btc", MULTICODEC_ED25519_BASE = "z", MULTICODEC_ED25519_HEADER = "K36", KEY_PAIR_SEED_LENGTH = 32;
function allocUnsafe(Ae = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(Ae) : new Uint8Array(Ae);
}
function concat$1(Ae, t) {
  t || (t = Ae.reduce((Be, Pe) => Be + Pe.length, 0));
  const Ie = allocUnsafe(t);
  let Me = 0;
  for (const Be of Ae)
    Ie.set(Be, Me), Me += Be.length;
  return Ie;
}
function base$1(Ae, t) {
  if (Ae.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var Ie = new Uint8Array(256), Me = 0; Me < Ie.length; Me++)
    Ie[Me] = 255;
  for (var Be = 0; Be < Ae.length; Be++) {
    var Pe = Ae.charAt(Be), Te = Pe.charCodeAt(0);
    if (Ie[Te] !== 255)
      throw new TypeError(Pe + " is ambiguous");
    Ie[Te] = Be;
  }
  var je = Ae.length, Ve = Ae.charAt(0), fi = Math.log(je) / Math.log(256), Ue = Math.log(256) / Math.log(je);
  function bi(_i) {
    if (_i instanceof Uint8Array || (ArrayBuffer.isView(_i) ? _i = new Uint8Array(_i.buffer, _i.byteOffset, _i.byteLength) : Array.isArray(_i) && (_i = Uint8Array.from(_i))), !(_i instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (_i.length === 0)
      return "";
    for (var Ei = 0, Pi = 0, Ii = 0, Ci = _i.length; Ii !== Ci && _i[Ii] === 0; )
      Ii++, Ei++;
    for (var Wi = (Ci - Ii) * Ue + 1 >>> 0, zi = new Uint8Array(Wi); Ii !== Ci; ) {
      for (var Xi = _i[Ii], Qi = 0, Oi = Wi - 1; (Xi !== 0 || Qi < Pi) && Oi !== -1; Oi--, Qi++)
        Xi += 256 * zi[Oi] >>> 0, zi[Oi] = Xi % je >>> 0, Xi = Xi / je >>> 0;
      if (Xi !== 0)
        throw new Error("Non-zero carry");
      Pi = Qi, Ii++;
    }
    for (var Yi = Wi - Pi; Yi !== Wi && zi[Yi] === 0; )
      Yi++;
    for (var ns = Ve.repeat(Ei); Yi < Wi; ++Yi)
      ns += Ae.charAt(zi[Yi]);
    return ns;
  }
  function vi(_i) {
    if (typeof _i != "string")
      throw new TypeError("Expected String");
    if (_i.length === 0)
      return new Uint8Array();
    var Ei = 0;
    if (_i[Ei] !== " ") {
      for (var Pi = 0, Ii = 0; _i[Ei] === Ve; )
        Pi++, Ei++;
      for (var Ci = (_i.length - Ei) * fi + 1 >>> 0, Wi = new Uint8Array(Ci); _i[Ei]; ) {
        var zi = Ie[_i.charCodeAt(Ei)];
        if (zi === 255)
          return;
        for (var Xi = 0, Qi = Ci - 1; (zi !== 0 || Xi < Ii) && Qi !== -1; Qi--, Xi++)
          zi += je * Wi[Qi] >>> 0, Wi[Qi] = zi % 256 >>> 0, zi = zi / 256 >>> 0;
        if (zi !== 0)
          throw new Error("Non-zero carry");
        Ii = Xi, Ei++;
      }
      if (_i[Ei] !== " ") {
        for (var Oi = Ci - Ii; Oi !== Ci && Wi[Oi] === 0; )
          Oi++;
        for (var Yi = new Uint8Array(Pi + (Ci - Oi)), ns = Pi; Oi !== Ci; )
          Yi[ns++] = Wi[Oi++];
        return Yi;
      }
    }
  }
  function mi(_i) {
    var Ei = vi(_i);
    if (Ei)
      return Ei;
    throw new Error(`Non-${t} character`);
  }
  return {
    encode: bi,
    decodeUnsafe: vi,
    decode: mi
  };
}
var src = base$1, _brrp__multiformats_scope_baseX = src;
const coerce = (Ae) => {
  if (Ae instanceof Uint8Array && Ae.constructor.name === "Uint8Array")
    return Ae;
  if (Ae instanceof ArrayBuffer)
    return new Uint8Array(Ae);
  if (ArrayBuffer.isView(Ae))
    return new Uint8Array(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  throw new Error("Unknown type, must be binary type");
}, fromString$1 = (Ae) => new TextEncoder().encode(Ae), toString$1 = (Ae) => new TextDecoder().decode(Ae);
class Encoder {
  constructor(t, Ie, Me) {
    this.name = t, this.prefix = Ie, this.baseEncode = Me;
  }
  encode(t) {
    if (t instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Decoder {
  constructor(t, Ie, Me) {
    if (this.name = t, this.prefix = Ie, Ie.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = Ie.codePointAt(0), this.baseDecode = Me;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(t) {
    return or$2(this, t);
  }
}
class ComposedDecoder {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return or$2(this, t);
  }
  decode(t) {
    const Ie = t[0], Me = this.decoders[Ie];
    if (Me)
      return Me.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const or$2 = (Ae, t) => new ComposedDecoder({
  ...Ae.decoders || { [Ae.prefix]: Ae },
  ...t.decoders || { [t.prefix]: t }
});
class Codec {
  constructor(t, Ie, Me, Be) {
    this.name = t, this.prefix = Ie, this.baseEncode = Me, this.baseDecode = Be, this.encoder = new Encoder(t, Ie, Me), this.decoder = new Decoder(t, Ie, Be);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
}
const from = ({ name: Ae, prefix: t, encode: Ie, decode: Me }) => new Codec(Ae, t, Ie, Me), baseX = ({ prefix: Ae, name: t, alphabet: Ie }) => {
  const { encode: Me, decode: Be } = _brrp__multiformats_scope_baseX(Ie, t);
  return from({
    prefix: Ae,
    name: t,
    encode: Me,
    decode: (Pe) => coerce(Be(Pe))
  });
}, decode$2 = (Ae, t, Ie, Me) => {
  const Be = {};
  for (let Ue = 0; Ue < t.length; ++Ue)
    Be[t[Ue]] = Ue;
  let Pe = Ae.length;
  for (; Ae[Pe - 1] === "="; )
    --Pe;
  const Te = new Uint8Array(Pe * Ie / 8 | 0);
  let je = 0, Ve = 0, fi = 0;
  for (let Ue = 0; Ue < Pe; ++Ue) {
    const bi = Be[Ae[Ue]];
    if (bi === void 0)
      throw new SyntaxError(`Non-${Me} character`);
    Ve = Ve << Ie | bi, je += Ie, je >= 8 && (je -= 8, Te[fi++] = 255 & Ve >> je);
  }
  if (je >= Ie || 255 & Ve << 8 - je)
    throw new SyntaxError("Unexpected end of data");
  return Te;
}, encode$1 = (Ae, t, Ie) => {
  const Me = t[t.length - 1] === "=", Be = (1 << Ie) - 1;
  let Pe = "", Te = 0, je = 0;
  for (let Ve = 0; Ve < Ae.length; ++Ve)
    for (je = je << 8 | Ae[Ve], Te += 8; Te > Ie; )
      Te -= Ie, Pe += t[Be & je >> Te];
  if (Te && (Pe += t[Be & je << Ie - Te]), Me)
    for (; Pe.length * Ie & 7; )
      Pe += "=";
  return Pe;
}, rfc4648 = ({ name: Ae, prefix: t, bitsPerChar: Ie, alphabet: Me }) => from({
  prefix: t,
  name: Ae,
  encode(Be) {
    return encode$1(Be, Me, Ie);
  },
  decode(Be) {
    return decode$2(Be, Me, Ie, Ae);
  }
}), identity = from({
  prefix: "\0",
  name: "identity",
  encode: (Ae) => toString$1(Ae),
  decode: (Ae) => fromString$1(Ae)
}), identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity
}, Symbol.toStringTag, { value: "Module" })), base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" })), base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" })), base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" })), base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" })), base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32,
  base32hex,
  base32hexpad,
  base32hexpadupper,
  base32hexupper,
  base32pad,
  base32padupper,
  base32upper,
  base32z
}, Symbol.toStringTag, { value: "Module" })), base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" })), base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc,
  base58flickr
}, Symbol.toStringTag, { value: "Module" })), base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), base64$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" })), alphabet = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), alphabetBytesToChars = alphabet.reduce((Ae, t, Ie) => (Ae[Ie] = t, Ae), []), alphabetCharsToBytes = alphabet.reduce((Ae, t, Ie) => (Ae[t.codePointAt(0)] = Ie, Ae), []);
function encode(Ae) {
  return Ae.reduce((t, Ie) => (t += alphabetBytesToChars[Ie], t), "");
}
function decode$1(Ae) {
  const t = [];
  for (const Ie of Ae) {
    const Me = alphabetCharsToBytes[Ie.codePointAt(0)];
    if (Me === void 0)
      throw new Error(`Non-base256emoji character: ${Ie}`);
    t.push(Me);
  }
  return new Uint8Array(t);
}
const base256emoji = from({
  prefix: "🚀",
  name: "base256emoji",
  encode,
  decode: decode$1
}), base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const bases = {
  ...identityBase,
  ...base2$1,
  ...base8$1,
  ...base10$1,
  ...base16$1,
  ...base32$1,
  ...base36$1,
  ...base58,
  ...base64$1,
  ...base256emoji$1
};
function createCodec(Ae, t, Ie, Me) {
  return {
    name: Ae,
    prefix: t,
    encoder: {
      name: Ae,
      prefix: t,
      encode: Ie
    },
    decoder: { decode: Me }
  };
}
const string = createCodec("utf8", "u", (Ae) => "u" + new TextDecoder("utf8").decode(Ae), (Ae) => new TextEncoder().encode(Ae.substring(1))), ascii = createCodec("ascii", "a", (Ae) => {
  let t = "a";
  for (let Ie = 0; Ie < Ae.length; Ie++)
    t += String.fromCharCode(Ae[Ie]);
  return t;
}, (Ae) => {
  Ae = Ae.substring(1);
  const t = allocUnsafe(Ae.length);
  for (let Ie = 0; Ie < Ae.length; Ie++)
    t[Ie] = Ae.charCodeAt(Ie);
  return t;
}), BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function toString(Ae, t = "utf8") {
  const Ie = BASES[t];
  if (!Ie)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(Ae.buffer, Ae.byteOffset, Ae.byteLength).toString("utf8") : Ie.encoder.encode(Ae).substring(1);
}
function fromString(Ae, t = "utf8") {
  const Ie = BASES[t];
  if (!Ie)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(Ae, "utf8") : Ie.decoder.decode(`${Ie.prefix}${Ae}`);
}
function decodeJSON(Ae) {
  return safeJsonParse(toString(fromString(Ae, JWT_ENCODING), JSON_ENCODING));
}
function encodeJSON(Ae) {
  return toString(fromString(safeJsonStringify(Ae), JSON_ENCODING), JWT_ENCODING);
}
function encodeIss(Ae) {
  const t = fromString(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING), Ie = MULTICODEC_ED25519_BASE + toString(concat$1([t, Ae]), MULTICODEC_ED25519_ENCODING);
  return [DID_PREFIX, DID_METHOD, Ie].join(DID_DELIMITER);
}
function encodeSig(Ae) {
  return toString(Ae, JWT_ENCODING);
}
function decodeSig(Ae) {
  return fromString(Ae, JWT_ENCODING);
}
function encodeData(Ae) {
  return fromString([encodeJSON(Ae.header), encodeJSON(Ae.payload)].join(JWT_DELIMITER), DATA_ENCODING);
}
function encodeJWT(Ae) {
  return [
    encodeJSON(Ae.header),
    encodeJSON(Ae.payload),
    encodeSig(Ae.signature)
  ].join(JWT_DELIMITER);
}
function decodeJWT(Ae) {
  const t = Ae.split(JWT_DELIMITER), Ie = decodeJSON(t[0]), Me = decodeJSON(t[1]), Be = decodeSig(t[2]), Pe = fromString(t.slice(0, 2).join(JWT_DELIMITER), DATA_ENCODING);
  return { header: Ie, payload: Me, signature: Be, data: Pe };
}
function generateKeyPair(Ae = random.randomBytes(KEY_PAIR_SEED_LENGTH)) {
  return ed25519.generateKeyPairFromSeed(Ae);
}
async function signJWT(Ae, t, Ie, Me, Be = cjs$3.fromMiliseconds(Date.now())) {
  const Pe = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP }, Te = encodeIss(Me.publicKey), je = Be + Ie, Ve = { iss: Te, sub: Ae, aud: t, iat: Be, exp: je }, fi = encodeData({ header: Pe, payload: Ve }), Ue = ed25519.sign(Me.secretKey, fi);
  return encodeJWT({ header: Pe, payload: Ve, signature: Ue });
}
var __spreadArray = function(Ae, t, Ie) {
  if (Ie || arguments.length === 2) for (var Me = 0, Be = t.length, Pe; Me < Be; Me++)
    (Pe || !(Me in t)) && (Pe || (Pe = Array.prototype.slice.call(t, 0, Me)), Pe[Me] = t[Me]);
  return Ae.concat(Pe || Array.prototype.slice.call(t));
}, BrowserInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function Ae(t, Ie, Me) {
      this.name = t, this.version = Ie, this.os = Me, this.type = "browser";
    }
    return Ae;
  }()
), NodeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function Ae(t) {
      this.version = t, this.type = "node", this.name = "node", this.os = process$1.platform;
    }
    return Ae;
  }()
), SearchBotDeviceInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function Ae(t, Ie, Me, Be) {
      this.name = t, this.version = Ie, this.os = Me, this.bot = Be, this.type = "bot-device";
    }
    return Ae;
  }()
), BotInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function Ae() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return Ae;
  }()
), ReactNativeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function Ae() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return Ae;
  }()
), SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, REQUIRED_VERSION_PARTS = 3, userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
], operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(Ae) {
  return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new ReactNativeInfo() : typeof navigator < "u" ? parseUserAgent(navigator.userAgent) : getNodeVersion();
}
function matchUserAgent(Ae) {
  return Ae !== "" && userAgentRules.reduce(function(t, Ie) {
    var Me = Ie[0], Be = Ie[1];
    if (t)
      return t;
    var Pe = Be.exec(Ae);
    return !!Pe && [Me, Pe];
  }, !1);
}
function parseUserAgent(Ae) {
  var t = matchUserAgent(Ae);
  if (!t)
    return null;
  var Ie = t[0], Me = t[1];
  if (Ie === "searchbot")
    return new BotInfo();
  var Be = Me[1] && Me[1].split(".").join("_").split("_").slice(0, 3);
  Be ? Be.length < REQUIRED_VERSION_PARTS && (Be = __spreadArray(__spreadArray([], Be, !0), createVersionParts(REQUIRED_VERSION_PARTS - Be.length), !0)) : Be = [];
  var Pe = Be.join("."), Te = detectOS(Ae), je = SEARCHBOT_OS_REGEX.exec(Ae);
  return je && je[1] ? new SearchBotDeviceInfo(Ie, Pe, Te, je[1]) : new BrowserInfo(Ie, Pe, Te);
}
function detectOS(Ae) {
  for (var t = 0, Ie = operatingSystemRules.length; t < Ie; t++) {
    var Me = operatingSystemRules[t], Be = Me[0], Pe = Me[1], Te = Pe.exec(Ae);
    if (Te)
      return Be;
  }
  return null;
}
function getNodeVersion() {
  var Ae = typeof process$1 < "u" && process$1.version;
  return Ae ? new NodeInfo(process$1.version.slice(1)) : null;
}
function createVersionParts(Ae) {
  for (var t = [], Ie = 0; Ie < Ae; Ie++)
    t.push("0");
  return t;
}
var cjs$2 = {};
Object.defineProperty(cjs$2, "__esModule", { value: !0 });
cjs$2.getLocalStorage = cjs$2.getLocalStorageOrThrow = cjs$2.getCrypto = cjs$2.getCryptoOrThrow = getLocation_1 = cjs$2.getLocation = cjs$2.getLocationOrThrow = getNavigator_1 = cjs$2.getNavigator = cjs$2.getNavigatorOrThrow = getDocument_1 = cjs$2.getDocument = cjs$2.getDocumentOrThrow = cjs$2.getFromWindowOrThrow = cjs$2.getFromWindow = void 0;
function getFromWindow(Ae) {
  let t;
  return typeof window < "u" && typeof window[Ae] < "u" && (t = window[Ae]), t;
}
cjs$2.getFromWindow = getFromWindow;
function getFromWindowOrThrow(Ae) {
  const t = getFromWindow(Ae);
  if (!t)
    throw new Error(`${Ae} is not defined in Window`);
  return t;
}
cjs$2.getFromWindowOrThrow = getFromWindowOrThrow;
function getDocumentOrThrow() {
  return getFromWindowOrThrow("document");
}
cjs$2.getDocumentOrThrow = getDocumentOrThrow;
function getDocument() {
  return getFromWindow("document");
}
var getDocument_1 = cjs$2.getDocument = getDocument;
function getNavigatorOrThrow() {
  return getFromWindowOrThrow("navigator");
}
cjs$2.getNavigatorOrThrow = getNavigatorOrThrow;
function getNavigator() {
  return getFromWindow("navigator");
}
var getNavigator_1 = cjs$2.getNavigator = getNavigator;
function getLocationOrThrow() {
  return getFromWindowOrThrow("location");
}
cjs$2.getLocationOrThrow = getLocationOrThrow;
function getLocation() {
  return getFromWindow("location");
}
var getLocation_1 = cjs$2.getLocation = getLocation;
function getCryptoOrThrow() {
  return getFromWindowOrThrow("crypto");
}
cjs$2.getCryptoOrThrow = getCryptoOrThrow;
function getCrypto() {
  return getFromWindow("crypto");
}
cjs$2.getCrypto = getCrypto;
function getLocalStorageOrThrow() {
  return getFromWindowOrThrow("localStorage");
}
cjs$2.getLocalStorageOrThrow = getLocalStorageOrThrow;
function getLocalStorage() {
  return getFromWindow("localStorage");
}
cjs$2.getLocalStorage = getLocalStorage;
var cjs$1 = {};
Object.defineProperty(cjs$1, "__esModule", { value: !0 });
var getWindowMetadata_1 = cjs$1.getWindowMetadata = void 0;
const window_getters_1 = cjs$2;
function getWindowMetadata() {
  let Ae, t;
  try {
    Ae = window_getters_1.getDocumentOrThrow(), t = window_getters_1.getLocationOrThrow();
  } catch {
    return null;
  }
  function Ie() {
    const bi = Ae.getElementsByTagName("link"), vi = [];
    for (let mi = 0; mi < bi.length; mi++) {
      const _i = bi[mi], Ei = _i.getAttribute("rel");
      if (Ei && Ei.toLowerCase().indexOf("icon") > -1) {
        const Pi = _i.getAttribute("href");
        if (Pi)
          if (Pi.toLowerCase().indexOf("https:") === -1 && Pi.toLowerCase().indexOf("http:") === -1 && Pi.indexOf("//") !== 0) {
            let Ii = t.protocol + "//" + t.host;
            if (Pi.indexOf("/") === 0)
              Ii += Pi;
            else {
              const Ci = t.pathname.split("/");
              Ci.pop();
              const Wi = Ci.join("/");
              Ii += Wi + "/" + Pi;
            }
            vi.push(Ii);
          } else if (Pi.indexOf("//") === 0) {
            const Ii = t.protocol + Pi;
            vi.push(Ii);
          } else
            vi.push(Pi);
      }
    }
    return vi;
  }
  function Me(...bi) {
    const vi = Ae.getElementsByTagName("meta");
    for (let mi = 0; mi < vi.length; mi++) {
      const _i = vi[mi], Ei = ["itemprop", "property", "name"].map((Pi) => _i.getAttribute(Pi)).filter((Pi) => Pi ? bi.includes(Pi) : !1);
      if (Ei.length && Ei) {
        const Pi = _i.getAttribute("content");
        if (Pi)
          return Pi;
      }
    }
    return "";
  }
  function Be() {
    let bi = Me("name", "og:site_name", "og:title", "twitter:title");
    return bi || (bi = Ae.title), bi;
  }
  function Pe() {
    return Me("description", "og:description", "twitter:description", "keywords");
  }
  const Te = Be(), je = Pe(), Ve = t.origin, fi = Ie();
  return {
    description: je,
    url: Ve,
    icons: fi,
    name: Te
  };
}
getWindowMetadata_1 = cjs$1.getWindowMetadata = getWindowMetadata;
var queryString = {}, strictUriEncode = (Ae) => encodeURIComponent(Ae).replace(/[!'()*]/g, (t) => `%${t.charCodeAt(0).toString(16).toUpperCase()}`), token = "%[a-f0-9]{2}", singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi"), multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(Ae, t) {
  try {
    return [decodeURIComponent(Ae.join(""))];
  } catch {
  }
  if (Ae.length === 1)
    return Ae;
  t = t || 1;
  var Ie = Ae.slice(0, t), Me = Ae.slice(t);
  return Array.prototype.concat.call([], decodeComponents(Ie), decodeComponents(Me));
}
function decode(Ae) {
  try {
    return decodeURIComponent(Ae);
  } catch {
    for (var t = Ae.match(singleMatcher) || [], Ie = 1; Ie < t.length; Ie++)
      Ae = decodeComponents(t, Ie).join(""), t = Ae.match(singleMatcher) || [];
    return Ae;
  }
}
function customDecodeURIComponent(Ae) {
  for (var t = {
    "%FE%FF": "��",
    "%FF%FE": "��"
  }, Ie = multiMatcher.exec(Ae); Ie; ) {
    try {
      t[Ie[0]] = decodeURIComponent(Ie[0]);
    } catch {
      var Me = decode(Ie[0]);
      Me !== Ie[0] && (t[Ie[0]] = Me);
    }
    Ie = multiMatcher.exec(Ae);
  }
  t["%C2"] = "�";
  for (var Be = Object.keys(t), Pe = 0; Pe < Be.length; Pe++) {
    var Te = Be[Pe];
    Ae = Ae.replace(new RegExp(Te, "g"), t[Te]);
  }
  return Ae;
}
var decodeUriComponent = function(Ae) {
  if (typeof Ae != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof Ae + "`");
  try {
    return Ae = Ae.replace(/\+/g, " "), decodeURIComponent(Ae);
  } catch {
    return customDecodeURIComponent(Ae);
  }
}, splitOnFirst = (Ae, t) => {
  if (!(typeof Ae == "string" && typeof t == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (t === "")
    return [Ae];
  const Ie = Ae.indexOf(t);
  return Ie === -1 ? [Ae] : [
    Ae.slice(0, Ie),
    Ae.slice(Ie + t.length)
  ];
}, filterObj = function(Ae, t) {
  for (var Ie = {}, Me = Object.keys(Ae), Be = Array.isArray(t), Pe = 0; Pe < Me.length; Pe++) {
    var Te = Me[Pe], je = Ae[Te];
    (Be ? t.indexOf(Te) !== -1 : t(Te, je, Ae)) && (Ie[Te] = je);
  }
  return Ie;
};
(function(Ae) {
  const t = strictUriEncode, Ie = decodeUriComponent, Me = splitOnFirst, Be = filterObj, Pe = (Ci) => Ci == null, Te = Symbol("encodeFragmentIdentifier");
  function je(Ci) {
    switch (Ci.arrayFormat) {
      case "index":
        return (Wi) => (zi, Xi) => {
          const Qi = zi.length;
          return Xi === void 0 || Ci.skipNull && Xi === null || Ci.skipEmptyString && Xi === "" ? zi : Xi === null ? [...zi, [Ue(Wi, Ci), "[", Qi, "]"].join("")] : [
            ...zi,
            [Ue(Wi, Ci), "[", Ue(Qi, Ci), "]=", Ue(Xi, Ci)].join("")
          ];
        };
      case "bracket":
        return (Wi) => (zi, Xi) => Xi === void 0 || Ci.skipNull && Xi === null || Ci.skipEmptyString && Xi === "" ? zi : Xi === null ? [...zi, [Ue(Wi, Ci), "[]"].join("")] : [...zi, [Ue(Wi, Ci), "[]=", Ue(Xi, Ci)].join("")];
      case "colon-list-separator":
        return (Wi) => (zi, Xi) => Xi === void 0 || Ci.skipNull && Xi === null || Ci.skipEmptyString && Xi === "" ? zi : Xi === null ? [...zi, [Ue(Wi, Ci), ":list="].join("")] : [...zi, [Ue(Wi, Ci), ":list=", Ue(Xi, Ci)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const Wi = Ci.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (zi) => (Xi, Qi) => Qi === void 0 || Ci.skipNull && Qi === null || Ci.skipEmptyString && Qi === "" ? Xi : (Qi = Qi === null ? "" : Qi, Xi.length === 0 ? [[Ue(zi, Ci), Wi, Ue(Qi, Ci)].join("")] : [[Xi, Ue(Qi, Ci)].join(Ci.arrayFormatSeparator)]);
      }
      default:
        return (Wi) => (zi, Xi) => Xi === void 0 || Ci.skipNull && Xi === null || Ci.skipEmptyString && Xi === "" ? zi : Xi === null ? [...zi, Ue(Wi, Ci)] : [...zi, [Ue(Wi, Ci), "=", Ue(Xi, Ci)].join("")];
    }
  }
  function Ve(Ci) {
    let Wi;
    switch (Ci.arrayFormat) {
      case "index":
        return (zi, Xi, Qi) => {
          if (Wi = /\[(\d*)\]$/.exec(zi), zi = zi.replace(/\[\d*\]$/, ""), !Wi) {
            Qi[zi] = Xi;
            return;
          }
          Qi[zi] === void 0 && (Qi[zi] = {}), Qi[zi][Wi[1]] = Xi;
        };
      case "bracket":
        return (zi, Xi, Qi) => {
          if (Wi = /(\[\])$/.exec(zi), zi = zi.replace(/\[\]$/, ""), !Wi) {
            Qi[zi] = Xi;
            return;
          }
          if (Qi[zi] === void 0) {
            Qi[zi] = [Xi];
            return;
          }
          Qi[zi] = [].concat(Qi[zi], Xi);
        };
      case "colon-list-separator":
        return (zi, Xi, Qi) => {
          if (Wi = /(:list)$/.exec(zi), zi = zi.replace(/:list$/, ""), !Wi) {
            Qi[zi] = Xi;
            return;
          }
          if (Qi[zi] === void 0) {
            Qi[zi] = [Xi];
            return;
          }
          Qi[zi] = [].concat(Qi[zi], Xi);
        };
      case "comma":
      case "separator":
        return (zi, Xi, Qi) => {
          const Oi = typeof Xi == "string" && Xi.includes(Ci.arrayFormatSeparator), Yi = typeof Xi == "string" && !Oi && bi(Xi, Ci).includes(Ci.arrayFormatSeparator);
          Xi = Yi ? bi(Xi, Ci) : Xi;
          const ns = Oi || Yi ? Xi.split(Ci.arrayFormatSeparator).map((ls) => bi(ls, Ci)) : Xi === null ? Xi : bi(Xi, Ci);
          Qi[zi] = ns;
        };
      case "bracket-separator":
        return (zi, Xi, Qi) => {
          const Oi = /(\[\])$/.test(zi);
          if (zi = zi.replace(/\[\]$/, ""), !Oi) {
            Qi[zi] = Xi && bi(Xi, Ci);
            return;
          }
          const Yi = Xi === null ? [] : Xi.split(Ci.arrayFormatSeparator).map((ns) => bi(ns, Ci));
          if (Qi[zi] === void 0) {
            Qi[zi] = Yi;
            return;
          }
          Qi[zi] = [].concat(Qi[zi], Yi);
        };
      default:
        return (zi, Xi, Qi) => {
          if (Qi[zi] === void 0) {
            Qi[zi] = Xi;
            return;
          }
          Qi[zi] = [].concat(Qi[zi], Xi);
        };
    }
  }
  function fi(Ci) {
    if (typeof Ci != "string" || Ci.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function Ue(Ci, Wi) {
    return Wi.encode ? Wi.strict ? t(Ci) : encodeURIComponent(Ci) : Ci;
  }
  function bi(Ci, Wi) {
    return Wi.decode ? Ie(Ci) : Ci;
  }
  function vi(Ci) {
    return Array.isArray(Ci) ? Ci.sort() : typeof Ci == "object" ? vi(Object.keys(Ci)).sort((Wi, zi) => Number(Wi) - Number(zi)).map((Wi) => Ci[Wi]) : Ci;
  }
  function mi(Ci) {
    const Wi = Ci.indexOf("#");
    return Wi !== -1 && (Ci = Ci.slice(0, Wi)), Ci;
  }
  function _i(Ci) {
    let Wi = "";
    const zi = Ci.indexOf("#");
    return zi !== -1 && (Wi = Ci.slice(zi)), Wi;
  }
  function Ei(Ci) {
    Ci = mi(Ci);
    const Wi = Ci.indexOf("?");
    return Wi === -1 ? "" : Ci.slice(Wi + 1);
  }
  function Pi(Ci, Wi) {
    return Wi.parseNumbers && !Number.isNaN(Number(Ci)) && typeof Ci == "string" && Ci.trim() !== "" ? Ci = Number(Ci) : Wi.parseBooleans && Ci !== null && (Ci.toLowerCase() === "true" || Ci.toLowerCase() === "false") && (Ci = Ci.toLowerCase() === "true"), Ci;
  }
  function Ii(Ci, Wi) {
    Wi = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, Wi), fi(Wi.arrayFormatSeparator);
    const zi = Ve(Wi), Xi = /* @__PURE__ */ Object.create(null);
    if (typeof Ci != "string" || (Ci = Ci.trim().replace(/^[?#&]/, ""), !Ci))
      return Xi;
    for (const Qi of Ci.split("&")) {
      if (Qi === "")
        continue;
      let [Oi, Yi] = Me(Wi.decode ? Qi.replace(/\+/g, " ") : Qi, "=");
      Yi = Yi === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(Wi.arrayFormat) ? Yi : bi(Yi, Wi), zi(bi(Oi, Wi), Yi, Xi);
    }
    for (const Qi of Object.keys(Xi)) {
      const Oi = Xi[Qi];
      if (typeof Oi == "object" && Oi !== null)
        for (const Yi of Object.keys(Oi))
          Oi[Yi] = Pi(Oi[Yi], Wi);
      else
        Xi[Qi] = Pi(Oi, Wi);
    }
    return Wi.sort === !1 ? Xi : (Wi.sort === !0 ? Object.keys(Xi).sort() : Object.keys(Xi).sort(Wi.sort)).reduce((Qi, Oi) => {
      const Yi = Xi[Oi];
      return Yi && typeof Yi == "object" && !Array.isArray(Yi) ? Qi[Oi] = vi(Yi) : Qi[Oi] = Yi, Qi;
    }, /* @__PURE__ */ Object.create(null));
  }
  Ae.extract = Ei, Ae.parse = Ii, Ae.stringify = (Ci, Wi) => {
    if (!Ci)
      return "";
    Wi = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, Wi), fi(Wi.arrayFormatSeparator);
    const zi = (Yi) => Wi.skipNull && Pe(Ci[Yi]) || Wi.skipEmptyString && Ci[Yi] === "", Xi = je(Wi), Qi = {};
    for (const Yi of Object.keys(Ci))
      zi(Yi) || (Qi[Yi] = Ci[Yi]);
    const Oi = Object.keys(Qi);
    return Wi.sort !== !1 && Oi.sort(Wi.sort), Oi.map((Yi) => {
      const ns = Ci[Yi];
      return ns === void 0 ? "" : ns === null ? Ue(Yi, Wi) : Array.isArray(ns) ? ns.length === 0 && Wi.arrayFormat === "bracket-separator" ? Ue(Yi, Wi) + "[]" : ns.reduce(Xi(Yi), []).join("&") : Ue(Yi, Wi) + "=" + Ue(ns, Wi);
    }).filter((Yi) => Yi.length > 0).join("&");
  }, Ae.parseUrl = (Ci, Wi) => {
    Wi = Object.assign({
      decode: !0
    }, Wi);
    const [zi, Xi] = Me(Ci, "#");
    return Object.assign(
      {
        url: zi.split("?")[0] || "",
        query: Ii(Ei(Ci), Wi)
      },
      Wi && Wi.parseFragmentIdentifier && Xi ? { fragmentIdentifier: bi(Xi, Wi) } : {}
    );
  }, Ae.stringifyUrl = (Ci, Wi) => {
    Wi = Object.assign({
      encode: !0,
      strict: !0,
      [Te]: !0
    }, Wi);
    const zi = mi(Ci.url).split("?")[0] || "", Xi = Ae.extract(Ci.url), Qi = Ae.parse(Xi, { sort: !1 }), Oi = Object.assign(Qi, Ci.query);
    let Yi = Ae.stringify(Oi, Wi);
    Yi && (Yi = `?${Yi}`);
    let ns = _i(Ci.url);
    return Ci.fragmentIdentifier && (ns = `#${Wi[Te] ? Ue(Ci.fragmentIdentifier, Wi) : Ci.fragmentIdentifier}`), `${zi}${Yi}${ns}`;
  }, Ae.pick = (Ci, Wi, zi) => {
    zi = Object.assign({
      parseFragmentIdentifier: !0,
      [Te]: !1
    }, zi);
    const { url: Xi, query: Qi, fragmentIdentifier: Oi } = Ae.parseUrl(Ci, zi);
    return Ae.stringifyUrl({
      url: Xi,
      query: Be(Qi, Wi),
      fragmentIdentifier: Oi
    }, zi);
  }, Ae.exclude = (Ci, Wi, zi) => {
    const Xi = Array.isArray(Wi) ? (Qi) => !Wi.includes(Qi) : (Qi, Oi) => !Wi(Qi, Oi);
    return Ae.pick(Ci, Xi, zi);
  };
})(queryString);
var sha3$1 = { exports: {} };
(function(Ae) {
  (function() {
    var t = "input is invalid type", Ie = "finalize already called", Me = typeof window == "object", Be = Me ? window : {};
    Be.JS_SHA3_NO_WINDOW && (Me = !1);
    var Pe = !Me && typeof self == "object", Te = !Be.JS_SHA3_NO_NODE_JS && typeof process$1 == "object" && process$1.versions && process$1.versions.node;
    Te ? Be = commonjsGlobal : Pe && (Be = self);
    var je = !Be.JS_SHA3_NO_COMMON_JS && !0 && Ae.exports, Ve = !Be.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", fi = "0123456789abcdef".split(""), Ue = [31, 7936, 2031616, 520093696], bi = [4, 1024, 262144, 67108864], vi = [1, 256, 65536, 16777216], mi = [6, 1536, 393216, 100663296], _i = [0, 8, 16, 24], Ei = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ], Pi = [224, 256, 384, 512], Ii = [128, 256], Ci = ["hex", "buffer", "arrayBuffer", "array", "digest"], Wi = {
      128: 168,
      256: 136
    };
    (Be.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(Hi) {
      return Object.prototype.toString.call(Hi) === "[object Array]";
    }), Ve && (Be.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(Hi) {
      return typeof Hi == "object" && Hi.buffer && Hi.buffer.constructor === ArrayBuffer;
    });
    for (var zi = function(Hi, fn, Bi) {
      return function(ki) {
        return new Si(Hi, fn, Hi).update(ki)[Bi]();
      };
    }, Xi = function(Hi, fn, Bi) {
      return function(ki, Ji) {
        return new Si(Hi, fn, Ji).update(ki)[Bi]();
      };
    }, Qi = function(Hi, fn, Bi) {
      return function(ki, Ji, Ri, ji) {
        return wi["cshake" + Hi].update(ki, Ji, Ri, ji)[Bi]();
      };
    }, Oi = function(Hi, fn, Bi) {
      return function(ki, Ji, Ri, ji) {
        return wi["kmac" + Hi].update(ki, Ji, Ri, ji)[Bi]();
      };
    }, Yi = function(Hi, fn, Bi, ki) {
      for (var Ji = 0; Ji < Ci.length; ++Ji) {
        var Ri = Ci[Ji];
        Hi[Ri] = fn(Bi, ki, Ri);
      }
      return Hi;
    }, ns = function(Hi, fn) {
      var Bi = zi(Hi, fn, "hex");
      return Bi.create = function() {
        return new Si(Hi, fn, Hi);
      }, Bi.update = function(ki) {
        return Bi.create().update(ki);
      }, Yi(Bi, zi, Hi, fn);
    }, ls = function(Hi, fn) {
      var Bi = Xi(Hi, fn, "hex");
      return Bi.create = function(ki) {
        return new Si(Hi, fn, ki);
      }, Bi.update = function(ki, Ji) {
        return Bi.create(Ji).update(ki);
      }, Yi(Bi, Xi, Hi, fn);
    }, vn = function(Hi, fn) {
      var Bi = Wi[Hi], ki = Qi(Hi, fn, "hex");
      return ki.create = function(Ji, Ri, ji) {
        return !Ri && !ji ? wi["shake" + Hi].create(Ji) : new Si(Hi, fn, Ji).bytepad([Ri, ji], Bi);
      }, ki.update = function(Ji, Ri, ji, Gi) {
        return ki.create(Ri, ji, Gi).update(Ji);
      }, Yi(ki, Qi, Hi, fn);
    }, Mi = function(Hi, fn) {
      var Bi = Wi[Hi], ki = Oi(Hi, fn, "hex");
      return ki.create = function(Ji, Ri, ji) {
        return new Vi(Hi, fn, Ri).bytepad(["KMAC", ji], Bi).bytepad([Ji], Bi);
      }, ki.update = function(Ji, Ri, ji, Gi) {
        return ki.create(Ji, ji, Gi).update(Ri);
      }, Yi(ki, Oi, Hi, fn);
    }, Ai = [
      { name: "keccak", padding: vi, bits: Pi, createMethod: ns },
      { name: "sha3", padding: mi, bits: Pi, createMethod: ns },
      { name: "shake", padding: Ue, bits: Ii, createMethod: ls },
      { name: "cshake", padding: bi, bits: Ii, createMethod: vn },
      { name: "kmac", padding: bi, bits: Ii, createMethod: Mi }
    ], wi = {}, $i = [], Li = 0; Li < Ai.length; ++Li)
      for (var qi = Ai[Li], Ni = qi.bits, Ti = 0; Ti < Ni.length; ++Ti) {
        var xi = qi.name + "_" + Ni[Ti];
        if ($i.push(xi), wi[xi] = qi.createMethod(Ni[Ti], qi.padding), qi.name !== "sha3") {
          var Fi = qi.name + Ni[Ti];
          $i.push(Fi), wi[Fi] = wi[xi];
        }
      }
    function Si(Hi, fn, Bi) {
      this.blocks = [], this.s = [], this.padding = fn, this.outputBits = Bi, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (Hi << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = Bi >> 5, this.extraBytes = (Bi & 31) >> 3;
      for (var ki = 0; ki < 50; ++ki)
        this.s[ki] = 0;
    }
    Si.prototype.update = function(Hi) {
      if (this.finalized)
        throw new Error(Ie);
      var fn, Bi = typeof Hi;
      if (Bi !== "string") {
        if (Bi === "object") {
          if (Hi === null)
            throw new Error(t);
          if (Ve && Hi.constructor === ArrayBuffer)
            Hi = new Uint8Array(Hi);
          else if (!Array.isArray(Hi) && (!Ve || !ArrayBuffer.isView(Hi)))
            throw new Error(t);
        } else
          throw new Error(t);
        fn = !0;
      }
      for (var ki = this.blocks, Ji = this.byteCount, Ri = Hi.length, ji = this.blockCount, Gi = 0, is = this.s, os, ds; Gi < Ri; ) {
        if (this.reset)
          for (this.reset = !1, ki[0] = this.block, os = 1; os < ji + 1; ++os)
            ki[os] = 0;
        if (fn)
          for (os = this.start; Gi < Ri && os < Ji; ++Gi)
            ki[os >> 2] |= Hi[Gi] << _i[os++ & 3];
        else
          for (os = this.start; Gi < Ri && os < Ji; ++Gi)
            ds = Hi.charCodeAt(Gi), ds < 128 ? ki[os >> 2] |= ds << _i[os++ & 3] : ds < 2048 ? (ki[os >> 2] |= (192 | ds >> 6) << _i[os++ & 3], ki[os >> 2] |= (128 | ds & 63) << _i[os++ & 3]) : ds < 55296 || ds >= 57344 ? (ki[os >> 2] |= (224 | ds >> 12) << _i[os++ & 3], ki[os >> 2] |= (128 | ds >> 6 & 63) << _i[os++ & 3], ki[os >> 2] |= (128 | ds & 63) << _i[os++ & 3]) : (ds = 65536 + ((ds & 1023) << 10 | Hi.charCodeAt(++Gi) & 1023), ki[os >> 2] |= (240 | ds >> 18) << _i[os++ & 3], ki[os >> 2] |= (128 | ds >> 12 & 63) << _i[os++ & 3], ki[os >> 2] |= (128 | ds >> 6 & 63) << _i[os++ & 3], ki[os >> 2] |= (128 | ds & 63) << _i[os++ & 3]);
        if (this.lastByteIndex = os, os >= Ji) {
          for (this.start = os - Ji, this.block = ki[ji], os = 0; os < ji; ++os)
            is[os] ^= ki[os];
          ts(is), this.reset = !0;
        } else
          this.start = os;
      }
      return this;
    }, Si.prototype.encode = function(Hi, fn) {
      var Bi = Hi & 255, ki = 1, Ji = [Bi];
      for (Hi = Hi >> 8, Bi = Hi & 255; Bi > 0; )
        Ji.unshift(Bi), Hi = Hi >> 8, Bi = Hi & 255, ++ki;
      return fn ? Ji.push(ki) : Ji.unshift(ki), this.update(Ji), Ji.length;
    }, Si.prototype.encodeString = function(Hi) {
      var fn, Bi = typeof Hi;
      if (Bi !== "string") {
        if (Bi === "object") {
          if (Hi === null)
            throw new Error(t);
          if (Ve && Hi.constructor === ArrayBuffer)
            Hi = new Uint8Array(Hi);
          else if (!Array.isArray(Hi) && (!Ve || !ArrayBuffer.isView(Hi)))
            throw new Error(t);
        } else
          throw new Error(t);
        fn = !0;
      }
      var ki = 0, Ji = Hi.length;
      if (fn)
        ki = Ji;
      else
        for (var Ri = 0; Ri < Hi.length; ++Ri) {
          var ji = Hi.charCodeAt(Ri);
          ji < 128 ? ki += 1 : ji < 2048 ? ki += 2 : ji < 55296 || ji >= 57344 ? ki += 3 : (ji = 65536 + ((ji & 1023) << 10 | Hi.charCodeAt(++Ri) & 1023), ki += 4);
        }
      return ki += this.encode(ki * 8), this.update(Hi), ki;
    }, Si.prototype.bytepad = function(Hi, fn) {
      for (var Bi = this.encode(fn), ki = 0; ki < Hi.length; ++ki)
        Bi += this.encodeString(Hi[ki]);
      var Ji = fn - Bi % fn, Ri = [];
      return Ri.length = Ji, this.update(Ri), this;
    }, Si.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var Hi = this.blocks, fn = this.lastByteIndex, Bi = this.blockCount, ki = this.s;
        if (Hi[fn >> 2] |= this.padding[fn & 3], this.lastByteIndex === this.byteCount)
          for (Hi[0] = Hi[Bi], fn = 1; fn < Bi + 1; ++fn)
            Hi[fn] = 0;
        for (Hi[Bi - 1] |= 2147483648, fn = 0; fn < Bi; ++fn)
          ki[fn] ^= Hi[fn];
        ts(ki);
      }
    }, Si.prototype.toString = Si.prototype.hex = function() {
      this.finalize();
      for (var Hi = this.blockCount, fn = this.s, Bi = this.outputBlocks, ki = this.extraBytes, Ji = 0, Ri = 0, ji = "", Gi; Ri < Bi; ) {
        for (Ji = 0; Ji < Hi && Ri < Bi; ++Ji, ++Ri)
          Gi = fn[Ji], ji += fi[Gi >> 4 & 15] + fi[Gi & 15] + fi[Gi >> 12 & 15] + fi[Gi >> 8 & 15] + fi[Gi >> 20 & 15] + fi[Gi >> 16 & 15] + fi[Gi >> 28 & 15] + fi[Gi >> 24 & 15];
        Ri % Hi === 0 && (ts(fn), Ji = 0);
      }
      return ki && (Gi = fn[Ji], ji += fi[Gi >> 4 & 15] + fi[Gi & 15], ki > 1 && (ji += fi[Gi >> 12 & 15] + fi[Gi >> 8 & 15]), ki > 2 && (ji += fi[Gi >> 20 & 15] + fi[Gi >> 16 & 15])), ji;
    }, Si.prototype.arrayBuffer = function() {
      this.finalize();
      var Hi = this.blockCount, fn = this.s, Bi = this.outputBlocks, ki = this.extraBytes, Ji = 0, Ri = 0, ji = this.outputBits >> 3, Gi;
      ki ? Gi = new ArrayBuffer(Bi + 1 << 2) : Gi = new ArrayBuffer(ji);
      for (var is = new Uint32Array(Gi); Ri < Bi; ) {
        for (Ji = 0; Ji < Hi && Ri < Bi; ++Ji, ++Ri)
          is[Ri] = fn[Ji];
        Ri % Hi === 0 && ts(fn);
      }
      return ki && (is[Ji] = fn[Ji], Gi = Gi.slice(0, ji)), Gi;
    }, Si.prototype.buffer = Si.prototype.arrayBuffer, Si.prototype.digest = Si.prototype.array = function() {
      this.finalize();
      for (var Hi = this.blockCount, fn = this.s, Bi = this.outputBlocks, ki = this.extraBytes, Ji = 0, Ri = 0, ji = [], Gi, is; Ri < Bi; ) {
        for (Ji = 0; Ji < Hi && Ri < Bi; ++Ji, ++Ri)
          Gi = Ri << 2, is = fn[Ji], ji[Gi] = is & 255, ji[Gi + 1] = is >> 8 & 255, ji[Gi + 2] = is >> 16 & 255, ji[Gi + 3] = is >> 24 & 255;
        Ri % Hi === 0 && ts(fn);
      }
      return ki && (Gi = Ri << 2, is = fn[Ji], ji[Gi] = is & 255, ki > 1 && (ji[Gi + 1] = is >> 8 & 255), ki > 2 && (ji[Gi + 2] = is >> 16 & 255)), ji;
    };
    function Vi(Hi, fn, Bi) {
      Si.call(this, Hi, fn, Bi);
    }
    Vi.prototype = new Si(), Vi.prototype.finalize = function() {
      return this.encode(this.outputBits, !0), Si.prototype.finalize.call(this);
    };
    var ts = function(Hi) {
      var fn, Bi, ki, Ji, Ri, ji, Gi, is, os, ds, ps, ea, ia, hs, fa, gs, sa, aa, Ds, ra, ca, ta, oa, da, Zi, Ui, Ki, En, ss, as, us, ua, ma, na, wa, ga, Ea, xa, $a, la, Sa, Aa, ha, Ma, Da, va, Ba, Pa, pa, Ra, _a, ya, qa, Na, Ia, Fa, Oa, Ta, Va, Ga, Ja, Xa, ja;
      for (ki = 0; ki < 48; ki += 2)
        Ji = Hi[0] ^ Hi[10] ^ Hi[20] ^ Hi[30] ^ Hi[40], Ri = Hi[1] ^ Hi[11] ^ Hi[21] ^ Hi[31] ^ Hi[41], ji = Hi[2] ^ Hi[12] ^ Hi[22] ^ Hi[32] ^ Hi[42], Gi = Hi[3] ^ Hi[13] ^ Hi[23] ^ Hi[33] ^ Hi[43], is = Hi[4] ^ Hi[14] ^ Hi[24] ^ Hi[34] ^ Hi[44], os = Hi[5] ^ Hi[15] ^ Hi[25] ^ Hi[35] ^ Hi[45], ds = Hi[6] ^ Hi[16] ^ Hi[26] ^ Hi[36] ^ Hi[46], ps = Hi[7] ^ Hi[17] ^ Hi[27] ^ Hi[37] ^ Hi[47], ea = Hi[8] ^ Hi[18] ^ Hi[28] ^ Hi[38] ^ Hi[48], ia = Hi[9] ^ Hi[19] ^ Hi[29] ^ Hi[39] ^ Hi[49], fn = ea ^ (ji << 1 | Gi >>> 31), Bi = ia ^ (Gi << 1 | ji >>> 31), Hi[0] ^= fn, Hi[1] ^= Bi, Hi[10] ^= fn, Hi[11] ^= Bi, Hi[20] ^= fn, Hi[21] ^= Bi, Hi[30] ^= fn, Hi[31] ^= Bi, Hi[40] ^= fn, Hi[41] ^= Bi, fn = Ji ^ (is << 1 | os >>> 31), Bi = Ri ^ (os << 1 | is >>> 31), Hi[2] ^= fn, Hi[3] ^= Bi, Hi[12] ^= fn, Hi[13] ^= Bi, Hi[22] ^= fn, Hi[23] ^= Bi, Hi[32] ^= fn, Hi[33] ^= Bi, Hi[42] ^= fn, Hi[43] ^= Bi, fn = ji ^ (ds << 1 | ps >>> 31), Bi = Gi ^ (ps << 1 | ds >>> 31), Hi[4] ^= fn, Hi[5] ^= Bi, Hi[14] ^= fn, Hi[15] ^= Bi, Hi[24] ^= fn, Hi[25] ^= Bi, Hi[34] ^= fn, Hi[35] ^= Bi, Hi[44] ^= fn, Hi[45] ^= Bi, fn = is ^ (ea << 1 | ia >>> 31), Bi = os ^ (ia << 1 | ea >>> 31), Hi[6] ^= fn, Hi[7] ^= Bi, Hi[16] ^= fn, Hi[17] ^= Bi, Hi[26] ^= fn, Hi[27] ^= Bi, Hi[36] ^= fn, Hi[37] ^= Bi, Hi[46] ^= fn, Hi[47] ^= Bi, fn = ds ^ (Ji << 1 | Ri >>> 31), Bi = ps ^ (Ri << 1 | Ji >>> 31), Hi[8] ^= fn, Hi[9] ^= Bi, Hi[18] ^= fn, Hi[19] ^= Bi, Hi[28] ^= fn, Hi[29] ^= Bi, Hi[38] ^= fn, Hi[39] ^= Bi, Hi[48] ^= fn, Hi[49] ^= Bi, hs = Hi[0], fa = Hi[1], va = Hi[11] << 4 | Hi[10] >>> 28, Ba = Hi[10] << 4 | Hi[11] >>> 28, En = Hi[20] << 3 | Hi[21] >>> 29, ss = Hi[21] << 3 | Hi[20] >>> 29, Ga = Hi[31] << 9 | Hi[30] >>> 23, Ja = Hi[30] << 9 | Hi[31] >>> 23, Aa = Hi[40] << 18 | Hi[41] >>> 14, ha = Hi[41] << 18 | Hi[40] >>> 14, na = Hi[2] << 1 | Hi[3] >>> 31, wa = Hi[3] << 1 | Hi[2] >>> 31, gs = Hi[13] << 12 | Hi[12] >>> 20, sa = Hi[12] << 12 | Hi[13] >>> 20, Pa = Hi[22] << 10 | Hi[23] >>> 22, pa = Hi[23] << 10 | Hi[22] >>> 22, as = Hi[33] << 13 | Hi[32] >>> 19, us = Hi[32] << 13 | Hi[33] >>> 19, Xa = Hi[42] << 2 | Hi[43] >>> 30, ja = Hi[43] << 2 | Hi[42] >>> 30, Na = Hi[5] << 30 | Hi[4] >>> 2, Ia = Hi[4] << 30 | Hi[5] >>> 2, ga = Hi[14] << 6 | Hi[15] >>> 26, Ea = Hi[15] << 6 | Hi[14] >>> 26, aa = Hi[25] << 11 | Hi[24] >>> 21, Ds = Hi[24] << 11 | Hi[25] >>> 21, Ra = Hi[34] << 15 | Hi[35] >>> 17, _a = Hi[35] << 15 | Hi[34] >>> 17, ua = Hi[45] << 29 | Hi[44] >>> 3, ma = Hi[44] << 29 | Hi[45] >>> 3, da = Hi[6] << 28 | Hi[7] >>> 4, Zi = Hi[7] << 28 | Hi[6] >>> 4, Fa = Hi[17] << 23 | Hi[16] >>> 9, Oa = Hi[16] << 23 | Hi[17] >>> 9, xa = Hi[26] << 25 | Hi[27] >>> 7, $a = Hi[27] << 25 | Hi[26] >>> 7, ra = Hi[36] << 21 | Hi[37] >>> 11, ca = Hi[37] << 21 | Hi[36] >>> 11, ya = Hi[47] << 24 | Hi[46] >>> 8, qa = Hi[46] << 24 | Hi[47] >>> 8, Ma = Hi[8] << 27 | Hi[9] >>> 5, Da = Hi[9] << 27 | Hi[8] >>> 5, Ui = Hi[18] << 20 | Hi[19] >>> 12, Ki = Hi[19] << 20 | Hi[18] >>> 12, Ta = Hi[29] << 7 | Hi[28] >>> 25, Va = Hi[28] << 7 | Hi[29] >>> 25, la = Hi[38] << 8 | Hi[39] >>> 24, Sa = Hi[39] << 8 | Hi[38] >>> 24, ta = Hi[48] << 14 | Hi[49] >>> 18, oa = Hi[49] << 14 | Hi[48] >>> 18, Hi[0] = hs ^ ~gs & aa, Hi[1] = fa ^ ~sa & Ds, Hi[10] = da ^ ~Ui & En, Hi[11] = Zi ^ ~Ki & ss, Hi[20] = na ^ ~ga & xa, Hi[21] = wa ^ ~Ea & $a, Hi[30] = Ma ^ ~va & Pa, Hi[31] = Da ^ ~Ba & pa, Hi[40] = Na ^ ~Fa & Ta, Hi[41] = Ia ^ ~Oa & Va, Hi[2] = gs ^ ~aa & ra, Hi[3] = sa ^ ~Ds & ca, Hi[12] = Ui ^ ~En & as, Hi[13] = Ki ^ ~ss & us, Hi[22] = ga ^ ~xa & la, Hi[23] = Ea ^ ~$a & Sa, Hi[32] = va ^ ~Pa & Ra, Hi[33] = Ba ^ ~pa & _a, Hi[42] = Fa ^ ~Ta & Ga, Hi[43] = Oa ^ ~Va & Ja, Hi[4] = aa ^ ~ra & ta, Hi[5] = Ds ^ ~ca & oa, Hi[14] = En ^ ~as & ua, Hi[15] = ss ^ ~us & ma, Hi[24] = xa ^ ~la & Aa, Hi[25] = $a ^ ~Sa & ha, Hi[34] = Pa ^ ~Ra & ya, Hi[35] = pa ^ ~_a & qa, Hi[44] = Ta ^ ~Ga & Xa, Hi[45] = Va ^ ~Ja & ja, Hi[6] = ra ^ ~ta & hs, Hi[7] = ca ^ ~oa & fa, Hi[16] = as ^ ~ua & da, Hi[17] = us ^ ~ma & Zi, Hi[26] = la ^ ~Aa & na, Hi[27] = Sa ^ ~ha & wa, Hi[36] = Ra ^ ~ya & Ma, Hi[37] = _a ^ ~qa & Da, Hi[46] = Ga ^ ~Xa & Na, Hi[47] = Ja ^ ~ja & Ia, Hi[8] = ta ^ ~hs & gs, Hi[9] = oa ^ ~fa & sa, Hi[18] = ua ^ ~da & Ui, Hi[19] = ma ^ ~Zi & Ki, Hi[28] = Aa ^ ~na & ga, Hi[29] = ha ^ ~wa & Ea, Hi[38] = ya ^ ~Ma & va, Hi[39] = qa ^ ~Da & Ba, Hi[48] = Xa ^ ~Na & Fa, Hi[49] = ja ^ ~Ia & Oa, Hi[0] ^= Ei[ki], Hi[1] ^= Ei[ki + 1];
    };
    if (je)
      Ae.exports = wi;
    else
      for (Li = 0; Li < $i.length; ++Li)
        Be[$i[Li]] = wi[$i[Li]];
  })();
})(sha3$1);
var sha3Exports = sha3$1.exports;
const sha3 = /* @__PURE__ */ getDefaultExportFromCjs(sha3Exports), version$4 = "logger/5.7.0";
let _permanentCensorErrors = !1, _censorErrors = !1;
const LogLevels = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels.default, _globalLogger = null;
function _checkNormalize() {
  try {
    const Ae = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((t) => {
      try {
        if ("test".normalize(t) !== "test")
          throw new Error("bad normalize");
      } catch {
        Ae.push(t);
      }
    }), Ae.length)
      throw new Error("missing " + Ae.join(", "));
    if ("é".normalize("NFD") !== "é")
      throw new Error("broken implementation");
  } catch (Ae) {
    return Ae.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(Ae) {
  Ae.DEBUG = "DEBUG", Ae.INFO = "INFO", Ae.WARNING = "WARNING", Ae.ERROR = "ERROR", Ae.OFF = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(Ae) {
  Ae.UNKNOWN_ERROR = "UNKNOWN_ERROR", Ae.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", Ae.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", Ae.NETWORK_ERROR = "NETWORK_ERROR", Ae.SERVER_ERROR = "SERVER_ERROR", Ae.TIMEOUT = "TIMEOUT", Ae.BUFFER_OVERRUN = "BUFFER_OVERRUN", Ae.NUMERIC_FAULT = "NUMERIC_FAULT", Ae.MISSING_NEW = "MISSING_NEW", Ae.INVALID_ARGUMENT = "INVALID_ARGUMENT", Ae.MISSING_ARGUMENT = "MISSING_ARGUMENT", Ae.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", Ae.CALL_EXCEPTION = "CALL_EXCEPTION", Ae.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", Ae.NONCE_EXPIRED = "NONCE_EXPIRED", Ae.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", Ae.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", Ae.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", Ae.ACTION_REJECTED = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(t) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: t,
      writable: !1
    });
  }
  _log(t, Ie) {
    const Me = t.toLowerCase();
    LogLevels[Me] == null && this.throwArgumentError("invalid log level name", "logLevel", t), !(_logLevel > LogLevels[Me]) && console.log.apply(console, Ie);
  }
  debug(...t) {
    this._log(Logger.levels.DEBUG, t);
  }
  info(...t) {
    this._log(Logger.levels.INFO, t);
  }
  warn(...t) {
    this._log(Logger.levels.WARNING, t);
  }
  makeError(t, Ie, Me) {
    if (_censorErrors)
      return this.makeError("censored error", Ie, {});
    Ie || (Ie = Logger.errors.UNKNOWN_ERROR), Me || (Me = {});
    const Be = [];
    Object.keys(Me).forEach((Ve) => {
      const fi = Me[Ve];
      try {
        if (fi instanceof Uint8Array) {
          let Ue = "";
          for (let bi = 0; bi < fi.length; bi++)
            Ue += HEX[fi[bi] >> 4], Ue += HEX[fi[bi] & 15];
          Be.push(Ve + "=Uint8Array(0x" + Ue + ")");
        } else
          Be.push(Ve + "=" + JSON.stringify(fi));
      } catch {
        Be.push(Ve + "=" + JSON.stringify(Me[Ve].toString()));
      }
    }), Be.push(`code=${Ie}`), Be.push(`version=${this.version}`);
    const Pe = t;
    let Te = "";
    switch (Ie) {
      case ErrorCode.NUMERIC_FAULT: {
        Te = "NUMERIC_FAULT";
        const Ve = t;
        switch (Ve) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            Te += "-" + Ve;
            break;
          case "negative-power":
          case "negative-width":
            Te += "-unsupported";
            break;
          case "unbound-bitwise-result":
            Te += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        Te = Ie;
        break;
    }
    Te && (t += " [ See: https://links.ethers.org/v5-errors-" + Te + " ]"), Be.length && (t += " (" + Be.join(", ") + ")");
    const je = new Error(t);
    return je.reason = Pe, je.code = Ie, Object.keys(Me).forEach(function(Ve) {
      je[Ve] = Me[Ve];
    }), je;
  }
  throwError(t, Ie, Me) {
    throw this.makeError(t, Ie, Me);
  }
  throwArgumentError(t, Ie, Me) {
    return this.throwError(t, Logger.errors.INVALID_ARGUMENT, {
      argument: Ie,
      value: Me
    });
  }
  assert(t, Ie, Me, Be) {
    t || this.throwError(Ie, Me, Be);
  }
  assertArgument(t, Ie, Me, Be) {
    t || this.throwArgumentError(Ie, Me, Be);
  }
  checkNormalize(t) {
    _normalizeError && this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: _normalizeError
    });
  }
  checkSafeUint53(t, Ie) {
    typeof t == "number" && (Ie == null && (Ie = "value not safe"), (t < 0 || t >= 9007199254740991) && this.throwError(Ie, Logger.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: t
    }), t % 1 && this.throwError(Ie, Logger.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: t
    }));
  }
  checkArgumentCount(t, Ie, Me) {
    Me ? Me = ": " + Me : Me = "", t < Ie && this.throwError("missing argument" + Me, Logger.errors.MISSING_ARGUMENT, {
      count: t,
      expectedCount: Ie
    }), t > Ie && this.throwError("too many arguments" + Me, Logger.errors.UNEXPECTED_ARGUMENT, {
      count: t,
      expectedCount: Ie
    });
  }
  checkNew(t, Ie) {
    (t === Object || t == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: Ie.name });
  }
  checkAbstract(t, Ie) {
    t === Ie ? this.throwError("cannot instantiate abstract class " + JSON.stringify(Ie.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: t.name, operation: "new" }) : (t === Object || t == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: Ie.name });
  }
  static globalLogger() {
    return _globalLogger || (_globalLogger = new Logger(version$4)), _globalLogger;
  }
  static setCensorship(t, Ie) {
    if (!t && Ie && this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), _permanentCensorErrors) {
      if (!t)
        return;
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!t, _permanentCensorErrors = !!Ie;
  }
  static setLogLevel(t) {
    const Ie = LogLevels[t.toLowerCase()];
    if (Ie == null) {
      Logger.globalLogger().warn("invalid log level - " + t);
      return;
    }
    _logLevel = Ie;
  }
  static from(t) {
    return new Logger(t);
  }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
const version$3 = "bytes/5.7.0", logger$3 = new Logger(version$3);
function isHexable(Ae) {
  return !!Ae.toHexString;
}
function addSlice(Ae) {
  return Ae.slice || (Ae.slice = function() {
    const t = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(Ae, t)));
  }), Ae;
}
function isBytesLike(Ae) {
  return isHexString(Ae) && !(Ae.length % 2) || isBytes(Ae);
}
function isInteger(Ae) {
  return typeof Ae == "number" && Ae == Ae && Ae % 1 === 0;
}
function isBytes(Ae) {
  if (Ae == null)
    return !1;
  if (Ae.constructor === Uint8Array)
    return !0;
  if (typeof Ae == "string" || !isInteger(Ae.length) || Ae.length < 0)
    return !1;
  for (let t = 0; t < Ae.length; t++) {
    const Ie = Ae[t];
    if (!isInteger(Ie) || Ie < 0 || Ie >= 256)
      return !1;
  }
  return !0;
}
function arrayify(Ae, t) {
  if (t || (t = {}), typeof Ae == "number") {
    logger$3.checkSafeUint53(Ae, "invalid arrayify value");
    const Ie = [];
    for (; Ae; )
      Ie.unshift(Ae & 255), Ae = parseInt(String(Ae / 256));
    return Ie.length === 0 && Ie.push(0), addSlice(new Uint8Array(Ie));
  }
  if (t.allowMissingPrefix && typeof Ae == "string" && Ae.substring(0, 2) !== "0x" && (Ae = "0x" + Ae), isHexable(Ae) && (Ae = Ae.toHexString()), isHexString(Ae)) {
    let Ie = Ae.substring(2);
    Ie.length % 2 && (t.hexPad === "left" ? Ie = "0" + Ie : t.hexPad === "right" ? Ie += "0" : logger$3.throwArgumentError("hex data is odd-length", "value", Ae));
    const Me = [];
    for (let Be = 0; Be < Ie.length; Be += 2)
      Me.push(parseInt(Ie.substring(Be, Be + 2), 16));
    return addSlice(new Uint8Array(Me));
  }
  return isBytes(Ae) ? addSlice(new Uint8Array(Ae)) : logger$3.throwArgumentError("invalid arrayify value", "value", Ae);
}
function concat(Ae) {
  const t = Ae.map((Be) => arrayify(Be)), Ie = t.reduce((Be, Pe) => Be + Pe.length, 0), Me = new Uint8Array(Ie);
  return t.reduce((Be, Pe) => (Me.set(Pe, Be), Be + Pe.length), 0), addSlice(Me);
}
function zeroPad(Ae, t) {
  Ae = arrayify(Ae), Ae.length > t && logger$3.throwArgumentError("value out of range", "value", arguments[0]);
  const Ie = new Uint8Array(t);
  return Ie.set(Ae, t - Ae.length), addSlice(Ie);
}
function isHexString(Ae, t) {
  return !(typeof Ae != "string" || !Ae.match(/^0x[0-9A-Fa-f]*$/) || t && Ae.length !== 2 + 2 * t);
}
const HexCharacters = "0123456789abcdef";
function hexlify(Ae, t) {
  if (t || (t = {}), typeof Ae == "number") {
    logger$3.checkSafeUint53(Ae, "invalid hexlify value");
    let Ie = "";
    for (; Ae; )
      Ie = HexCharacters[Ae & 15] + Ie, Ae = Math.floor(Ae / 16);
    return Ie.length ? (Ie.length % 2 && (Ie = "0" + Ie), "0x" + Ie) : "0x00";
  }
  if (typeof Ae == "bigint")
    return Ae = Ae.toString(16), Ae.length % 2 ? "0x0" + Ae : "0x" + Ae;
  if (t.allowMissingPrefix && typeof Ae == "string" && Ae.substring(0, 2) !== "0x" && (Ae = "0x" + Ae), isHexable(Ae))
    return Ae.toHexString();
  if (isHexString(Ae))
    return Ae.length % 2 && (t.hexPad === "left" ? Ae = "0x0" + Ae.substring(2) : t.hexPad === "right" ? Ae += "0" : logger$3.throwArgumentError("hex data is odd-length", "value", Ae)), Ae.toLowerCase();
  if (isBytes(Ae)) {
    let Ie = "0x";
    for (let Me = 0; Me < Ae.length; Me++) {
      let Be = Ae[Me];
      Ie += HexCharacters[(Be & 240) >> 4] + HexCharacters[Be & 15];
    }
    return Ie;
  }
  return logger$3.throwArgumentError("invalid hexlify value", "value", Ae);
}
function hexDataLength(Ae) {
  if (typeof Ae != "string")
    Ae = hexlify(Ae);
  else if (!isHexString(Ae) || Ae.length % 2)
    return null;
  return (Ae.length - 2) / 2;
}
function hexDataSlice(Ae, t, Ie) {
  return typeof Ae != "string" ? Ae = hexlify(Ae) : (!isHexString(Ae) || Ae.length % 2) && logger$3.throwArgumentError("invalid hexData", "value", Ae), t = 2 + 2 * t, "0x" + Ae.substring(t);
}
function hexZeroPad(Ae, t) {
  for (typeof Ae != "string" ? Ae = hexlify(Ae) : isHexString(Ae) || logger$3.throwArgumentError("invalid hex string", "value", Ae), Ae.length > 2 * t + 2 && logger$3.throwArgumentError("value out of range", "value", arguments[1]); Ae.length < 2 * t + 2; )
    Ae = "0x0" + Ae.substring(2);
  return Ae;
}
function splitSignature(Ae) {
  const t = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(Ae)) {
    let Ie = arrayify(Ae);
    Ie.length === 64 ? (t.v = 27 + (Ie[32] >> 7), Ie[32] &= 127, t.r = hexlify(Ie.slice(0, 32)), t.s = hexlify(Ie.slice(32, 64))) : Ie.length === 65 ? (t.r = hexlify(Ie.slice(0, 32)), t.s = hexlify(Ie.slice(32, 64)), t.v = Ie[64]) : logger$3.throwArgumentError("invalid signature string", "signature", Ae), t.v < 27 && (t.v === 0 || t.v === 1 ? t.v += 27 : logger$3.throwArgumentError("signature invalid v byte", "signature", Ae)), t.recoveryParam = 1 - t.v % 2, t.recoveryParam && (Ie[32] |= 128), t._vs = hexlify(Ie.slice(32, 64));
  } else {
    if (t.r = Ae.r, t.s = Ae.s, t.v = Ae.v, t.recoveryParam = Ae.recoveryParam, t._vs = Ae._vs, t._vs != null) {
      const Be = zeroPad(arrayify(t._vs), 32);
      t._vs = hexlify(Be);
      const Pe = Be[0] >= 128 ? 1 : 0;
      t.recoveryParam == null ? t.recoveryParam = Pe : t.recoveryParam !== Pe && logger$3.throwArgumentError("signature recoveryParam mismatch _vs", "signature", Ae), Be[0] &= 127;
      const Te = hexlify(Be);
      t.s == null ? t.s = Te : t.s !== Te && logger$3.throwArgumentError("signature v mismatch _vs", "signature", Ae);
    }
    if (t.recoveryParam == null)
      t.v == null ? logger$3.throwArgumentError("signature missing v and recoveryParam", "signature", Ae) : t.v === 0 || t.v === 1 ? t.recoveryParam = t.v : t.recoveryParam = 1 - t.v % 2;
    else if (t.v == null)
      t.v = 27 + t.recoveryParam;
    else {
      const Be = t.v === 0 || t.v === 1 ? t.v : 1 - t.v % 2;
      t.recoveryParam !== Be && logger$3.throwArgumentError("signature recoveryParam mismatch v", "signature", Ae);
    }
    t.r == null || !isHexString(t.r) ? logger$3.throwArgumentError("signature missing or invalid r", "signature", Ae) : t.r = hexZeroPad(t.r, 32), t.s == null || !isHexString(t.s) ? logger$3.throwArgumentError("signature missing or invalid s", "signature", Ae) : t.s = hexZeroPad(t.s, 32);
    const Ie = arrayify(t.s);
    Ie[0] >= 128 && logger$3.throwArgumentError("signature s out of range", "signature", Ae), t.recoveryParam && (Ie[0] |= 128);
    const Me = hexlify(Ie);
    t._vs && (isHexString(t._vs) || logger$3.throwArgumentError("signature invalid _vs", "signature", Ae), t._vs = hexZeroPad(t._vs, 32)), t._vs == null ? t._vs = Me : t._vs !== Me && logger$3.throwArgumentError("signature _vs mismatch v and s", "signature", Ae);
  }
  return t.yParityAndS = t._vs, t.compact = t.r + t.yParityAndS.substring(2), t;
}
function keccak256(Ae) {
  return "0x" + sha3.keccak_256(arrayify(Ae));
}
var BN = BN$8.BN;
function _base36To16(Ae) {
  return new BN(Ae, 36).toString(16);
}
const version$2 = "strings/5.7.0", logger$2 = new Logger(version$2);
var UnicodeNormalizationForm;
(function(Ae) {
  Ae.current = "", Ae.NFC = "NFC", Ae.NFD = "NFD", Ae.NFKC = "NFKC", Ae.NFKD = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Ae) {
  Ae.UNEXPECTED_CONTINUE = "unexpected continuation byte", Ae.BAD_PREFIX = "bad codepoint prefix", Ae.OVERRUN = "string overrun", Ae.MISSING_CONTINUE = "missing continuation byte", Ae.OUT_OF_RANGE = "out of UTF-8 range", Ae.UTF16_SURROGATE = "UTF-16 surrogate", Ae.OVERLONG = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function toUtf8Bytes(Ae, t = UnicodeNormalizationForm.current) {
  t != UnicodeNormalizationForm.current && (logger$2.checkNormalize(), Ae = Ae.normalize(t));
  let Ie = [];
  for (let Me = 0; Me < Ae.length; Me++) {
    const Be = Ae.charCodeAt(Me);
    if (Be < 128)
      Ie.push(Be);
    else if (Be < 2048)
      Ie.push(Be >> 6 | 192), Ie.push(Be & 63 | 128);
    else if ((Be & 64512) == 55296) {
      Me++;
      const Pe = Ae.charCodeAt(Me);
      if (Me >= Ae.length || (Pe & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const Te = 65536 + ((Be & 1023) << 10) + (Pe & 1023);
      Ie.push(Te >> 18 | 240), Ie.push(Te >> 12 & 63 | 128), Ie.push(Te >> 6 & 63 | 128), Ie.push(Te & 63 | 128);
    } else
      Ie.push(Be >> 12 | 224), Ie.push(Be >> 6 & 63 | 128), Ie.push(Be & 63 | 128);
  }
  return arrayify(Ie);
}
const messagePrefix = `Ethereum Signed Message:
`;
function hashMessage(Ae) {
  return typeof Ae == "string" && (Ae = toUtf8Bytes(Ae)), keccak256(concat([
    toUtf8Bytes(messagePrefix),
    toUtf8Bytes(String(Ae.length)),
    Ae
  ]));
}
const version$1 = "address/5.7.0", logger$1 = new Logger(version$1);
function getChecksumAddress(Ae) {
  isHexString(Ae, 20) || logger$1.throwArgumentError("invalid address", "address", Ae), Ae = Ae.toLowerCase();
  const t = Ae.substring(2).split(""), Ie = new Uint8Array(40);
  for (let Be = 0; Be < 40; Be++)
    Ie[Be] = t[Be].charCodeAt(0);
  const Me = arrayify(keccak256(Ie));
  for (let Be = 0; Be < 40; Be += 2)
    Me[Be >> 1] >> 4 >= 8 && (t[Be] = t[Be].toUpperCase()), (Me[Be >> 1] & 15) >= 8 && (t[Be + 1] = t[Be + 1].toUpperCase());
  return "0x" + t.join("");
}
const MAX_SAFE_INTEGER = 9007199254740991;
function log10(Ae) {
  return Math.log10 ? Math.log10(Ae) : Math.log(Ae) / Math.LN10;
}
const ibanLookup = {};
for (let Ae = 0; Ae < 10; Ae++)
  ibanLookup[String(Ae)] = String(Ae);
for (let Ae = 0; Ae < 26; Ae++)
  ibanLookup[String.fromCharCode(65 + Ae)] = String(10 + Ae);
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(Ae) {
  Ae = Ae.toUpperCase(), Ae = Ae.substring(4) + Ae.substring(0, 2) + "00";
  let t = Ae.split("").map((Me) => ibanLookup[Me]).join("");
  for (; t.length >= safeDigits; ) {
    let Me = t.substring(0, safeDigits);
    t = parseInt(Me, 10) % 97 + t.substring(Me.length);
  }
  let Ie = String(98 - parseInt(t, 10) % 97);
  for (; Ie.length < 2; )
    Ie = "0" + Ie;
  return Ie;
}
function getAddress(Ae) {
  let t = null;
  if (typeof Ae != "string" && logger$1.throwArgumentError("invalid address", "address", Ae), Ae.match(/^(0x)?[0-9a-fA-F]{40}$/))
    Ae.substring(0, 2) !== "0x" && (Ae = "0x" + Ae), t = getChecksumAddress(Ae), Ae.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && t !== Ae && logger$1.throwArgumentError("bad address checksum", "address", Ae);
  else if (Ae.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (Ae.substring(2, 4) !== ibanChecksum(Ae) && logger$1.throwArgumentError("bad icap checksum", "address", Ae), t = _base36To16(Ae.substring(4)); t.length < 40; )
      t = "0" + t;
    t = getChecksumAddress("0x" + t);
  } else
    logger$1.throwArgumentError("invalid address", "address", Ae);
  return t;
}
function defineReadOnly(Ae, t, Ie) {
  Object.defineProperty(Ae, t, {
    enumerable: !0,
    value: Ie,
    writable: !1
  });
}
function createCommonjsModule(Ae, t, Ie) {
  return Ie = {
    path: t,
    exports: {},
    require: function(Me, Be) {
      return commonjsRequire(Me, Be ?? Ie.path);
    }
  }, Ae(Ie, Ie.exports), Ie.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert;
function assert(Ae, t) {
  if (!Ae)
    throw new Error(t || "Assertion failed");
}
assert.equal = function Ae(t, Ie, Me) {
  if (t != Ie)
    throw new Error(Me || "Assertion failed: " + t + " != " + Ie);
};
var utils_1 = createCommonjsModule(function(Ae, t) {
  var Ie = t;
  function Me(Te, je) {
    if (Array.isArray(Te))
      return Te.slice();
    if (!Te)
      return [];
    var Ve = [];
    if (typeof Te != "string") {
      for (var fi = 0; fi < Te.length; fi++)
        Ve[fi] = Te[fi] | 0;
      return Ve;
    }
    if (je === "hex") {
      Te = Te.replace(/[^a-z0-9]+/ig, ""), Te.length % 2 !== 0 && (Te = "0" + Te);
      for (var fi = 0; fi < Te.length; fi += 2)
        Ve.push(parseInt(Te[fi] + Te[fi + 1], 16));
    } else
      for (var fi = 0; fi < Te.length; fi++) {
        var Ue = Te.charCodeAt(fi), bi = Ue >> 8, vi = Ue & 255;
        bi ? Ve.push(bi, vi) : Ve.push(vi);
      }
    return Ve;
  }
  Ie.toArray = Me;
  function Be(Te) {
    return Te.length === 1 ? "0" + Te : Te;
  }
  Ie.zero2 = Be;
  function Pe(Te) {
    for (var je = "", Ve = 0; Ve < Te.length; Ve++)
      je += Be(Te[Ve].toString(16));
    return je;
  }
  Ie.toHex = Pe, Ie.encode = function(je, Ve) {
    return Ve === "hex" ? Pe(je) : je;
  };
}), utils_1$1 = createCommonjsModule(function(Ae, t) {
  var Ie = t;
  Ie.assert = minimalisticAssert, Ie.toArray = utils_1.toArray, Ie.zero2 = utils_1.zero2, Ie.toHex = utils_1.toHex, Ie.encode = utils_1.encode;
  function Me(Ve, fi, Ue) {
    var bi = new Array(Math.max(Ve.bitLength(), Ue) + 1);
    bi.fill(0);
    for (var vi = 1 << fi + 1, mi = Ve.clone(), _i = 0; _i < bi.length; _i++) {
      var Ei, Pi = mi.andln(vi - 1);
      mi.isOdd() ? (Pi > (vi >> 1) - 1 ? Ei = (vi >> 1) - Pi : Ei = Pi, mi.isubn(Ei)) : Ei = 0, bi[_i] = Ei, mi.iushrn(1);
    }
    return bi;
  }
  Ie.getNAF = Me;
  function Be(Ve, fi) {
    var Ue = [
      [],
      []
    ];
    Ve = Ve.clone(), fi = fi.clone();
    for (var bi = 0, vi = 0, mi; Ve.cmpn(-bi) > 0 || fi.cmpn(-vi) > 0; ) {
      var _i = Ve.andln(3) + bi & 3, Ei = fi.andln(3) + vi & 3;
      _i === 3 && (_i = -1), Ei === 3 && (Ei = -1);
      var Pi;
      _i & 1 ? (mi = Ve.andln(7) + bi & 7, (mi === 3 || mi === 5) && Ei === 2 ? Pi = -_i : Pi = _i) : Pi = 0, Ue[0].push(Pi);
      var Ii;
      Ei & 1 ? (mi = fi.andln(7) + vi & 7, (mi === 3 || mi === 5) && _i === 2 ? Ii = -Ei : Ii = Ei) : Ii = 0, Ue[1].push(Ii), 2 * bi === Pi + 1 && (bi = 1 - bi), 2 * vi === Ii + 1 && (vi = 1 - vi), Ve.iushrn(1), fi.iushrn(1);
    }
    return Ue;
  }
  Ie.getJSF = Be;
  function Pe(Ve, fi, Ue) {
    var bi = "_" + fi;
    Ve.prototype[fi] = function() {
      return this[bi] !== void 0 ? this[bi] : this[bi] = Ue.call(this);
    };
  }
  Ie.cachedProperty = Pe;
  function Te(Ve) {
    return typeof Ve == "string" ? Ie.toArray(Ve, "hex") : Ve;
  }
  Ie.parseBytes = Te;
  function je(Ve) {
    return new BN$8(Ve, "hex", "le");
  }
  Ie.intFromLE = je;
}), getNAF = utils_1$1.getNAF, getJSF = utils_1$1.getJSF, assert$1 = utils_1$1.assert;
function BaseCurve(Ae, t) {
  this.type = Ae, this.p = new BN$8(t.p, 16), this.red = t.prime ? BN$8.red(t.prime) : BN$8.mont(this.p), this.zero = new BN$8(0).toRed(this.red), this.one = new BN$8(1).toRed(this.red), this.two = new BN$8(2).toRed(this.red), this.n = t.n && new BN$8(t.n, 16), this.g = t.g && this.pointFromJSON(t.g, t.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var Ie = this.n && this.p.div(this.n);
  !Ie || Ie.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base = BaseCurve;
BaseCurve.prototype.point = function Ae() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function Ae() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function Ae(t, Ie) {
  assert$1(t.precomputed);
  var Me = t._getDoubles(), Be = getNAF(Ie, 1, this._bitLength), Pe = (1 << Me.step + 1) - (Me.step % 2 === 0 ? 2 : 1);
  Pe /= 3;
  var Te = [], je, Ve;
  for (je = 0; je < Be.length; je += Me.step) {
    Ve = 0;
    for (var fi = je + Me.step - 1; fi >= je; fi--)
      Ve = (Ve << 1) + Be[fi];
    Te.push(Ve);
  }
  for (var Ue = this.jpoint(null, null, null), bi = this.jpoint(null, null, null), vi = Pe; vi > 0; vi--) {
    for (je = 0; je < Te.length; je++)
      Ve = Te[je], Ve === vi ? bi = bi.mixedAdd(Me.points[je]) : Ve === -vi && (bi = bi.mixedAdd(Me.points[je].neg()));
    Ue = Ue.add(bi);
  }
  return Ue.toP();
};
BaseCurve.prototype._wnafMul = function Ae(t, Ie) {
  var Me = 4, Be = t._getNAFPoints(Me);
  Me = Be.wnd;
  for (var Pe = Be.points, Te = getNAF(Ie, Me, this._bitLength), je = this.jpoint(null, null, null), Ve = Te.length - 1; Ve >= 0; Ve--) {
    for (var fi = 0; Ve >= 0 && Te[Ve] === 0; Ve--)
      fi++;
    if (Ve >= 0 && fi++, je = je.dblp(fi), Ve < 0)
      break;
    var Ue = Te[Ve];
    assert$1(Ue !== 0), t.type === "affine" ? Ue > 0 ? je = je.mixedAdd(Pe[Ue - 1 >> 1]) : je = je.mixedAdd(Pe[-Ue - 1 >> 1].neg()) : Ue > 0 ? je = je.add(Pe[Ue - 1 >> 1]) : je = je.add(Pe[-Ue - 1 >> 1].neg());
  }
  return t.type === "affine" ? je.toP() : je;
};
BaseCurve.prototype._wnafMulAdd = function Ae(t, Ie, Me, Be, Pe) {
  var Te = this._wnafT1, je = this._wnafT2, Ve = this._wnafT3, fi = 0, Ue, bi, vi;
  for (Ue = 0; Ue < Be; Ue++) {
    vi = Ie[Ue];
    var mi = vi._getNAFPoints(t);
    Te[Ue] = mi.wnd, je[Ue] = mi.points;
  }
  for (Ue = Be - 1; Ue >= 1; Ue -= 2) {
    var _i = Ue - 1, Ei = Ue;
    if (Te[_i] !== 1 || Te[Ei] !== 1) {
      Ve[_i] = getNAF(Me[_i], Te[_i], this._bitLength), Ve[Ei] = getNAF(Me[Ei], Te[Ei], this._bitLength), fi = Math.max(Ve[_i].length, fi), fi = Math.max(Ve[Ei].length, fi);
      continue;
    }
    var Pi = [
      Ie[_i],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      Ie[Ei]
      /* 7 */
    ];
    Ie[_i].y.cmp(Ie[Ei].y) === 0 ? (Pi[1] = Ie[_i].add(Ie[Ei]), Pi[2] = Ie[_i].toJ().mixedAdd(Ie[Ei].neg())) : Ie[_i].y.cmp(Ie[Ei].y.redNeg()) === 0 ? (Pi[1] = Ie[_i].toJ().mixedAdd(Ie[Ei]), Pi[2] = Ie[_i].add(Ie[Ei].neg())) : (Pi[1] = Ie[_i].toJ().mixedAdd(Ie[Ei]), Pi[2] = Ie[_i].toJ().mixedAdd(Ie[Ei].neg()));
    var Ii = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], Ci = getJSF(Me[_i], Me[Ei]);
    for (fi = Math.max(Ci[0].length, fi), Ve[_i] = new Array(fi), Ve[Ei] = new Array(fi), bi = 0; bi < fi; bi++) {
      var Wi = Ci[0][bi] | 0, zi = Ci[1][bi] | 0;
      Ve[_i][bi] = Ii[(Wi + 1) * 3 + (zi + 1)], Ve[Ei][bi] = 0, je[_i] = Pi;
    }
  }
  var Xi = this.jpoint(null, null, null), Qi = this._wnafT4;
  for (Ue = fi; Ue >= 0; Ue--) {
    for (var Oi = 0; Ue >= 0; ) {
      var Yi = !0;
      for (bi = 0; bi < Be; bi++)
        Qi[bi] = Ve[bi][Ue] | 0, Qi[bi] !== 0 && (Yi = !1);
      if (!Yi)
        break;
      Oi++, Ue--;
    }
    if (Ue >= 0 && Oi++, Xi = Xi.dblp(Oi), Ue < 0)
      break;
    for (bi = 0; bi < Be; bi++) {
      var ns = Qi[bi];
      ns !== 0 && (ns > 0 ? vi = je[bi][ns - 1 >> 1] : ns < 0 && (vi = je[bi][-ns - 1 >> 1].neg()), vi.type === "affine" ? Xi = Xi.mixedAdd(vi) : Xi = Xi.add(vi));
    }
  }
  for (Ue = 0; Ue < Be; Ue++)
    je[Ue] = null;
  return Pe ? Xi : Xi.toP();
};
function BasePoint(Ae, t) {
  this.curve = Ae, this.type = t, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function Ae() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function Ae() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function Ae(t, Ie) {
  t = utils_1$1.toArray(t, Ie);
  var Me = this.p.byteLength();
  if ((t[0] === 4 || t[0] === 6 || t[0] === 7) && t.length - 1 === 2 * Me) {
    t[0] === 6 ? assert$1(t[t.length - 1] % 2 === 0) : t[0] === 7 && assert$1(t[t.length - 1] % 2 === 1);
    var Be = this.point(
      t.slice(1, 1 + Me),
      t.slice(1 + Me, 1 + 2 * Me)
    );
    return Be;
  } else if ((t[0] === 2 || t[0] === 3) && t.length - 1 === Me)
    return this.pointFromX(t.slice(1, 1 + Me), t[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function Ae(t) {
  return this.encode(t, !0);
};
BasePoint.prototype._encode = function Ae(t) {
  var Ie = this.curve.p.byteLength(), Me = this.getX().toArray("be", Ie);
  return t ? [this.getY().isEven() ? 2 : 3].concat(Me) : [4].concat(Me, this.getY().toArray("be", Ie));
};
BasePoint.prototype.encode = function Ae(t, Ie) {
  return utils_1$1.encode(this._encode(Ie), t);
};
BasePoint.prototype.precompute = function Ae(t) {
  if (this.precomputed)
    return this;
  var Ie = {
    doubles: null,
    naf: null,
    beta: null
  };
  return Ie.naf = this._getNAFPoints(8), Ie.doubles = this._getDoubles(4, t), Ie.beta = this._getBeta(), this.precomputed = Ie, this;
};
BasePoint.prototype._hasDoubles = function Ae(t) {
  if (!this.precomputed)
    return !1;
  var Ie = this.precomputed.doubles;
  return Ie ? Ie.points.length >= Math.ceil((t.bitLength() + 1) / Ie.step) : !1;
};
BasePoint.prototype._getDoubles = function Ae(t, Ie) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var Me = [this], Be = this, Pe = 0; Pe < Ie; Pe += t) {
    for (var Te = 0; Te < t; Te++)
      Be = Be.dbl();
    Me.push(Be);
  }
  return {
    step: t,
    points: Me
  };
};
BasePoint.prototype._getNAFPoints = function Ae(t) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var Ie = [this], Me = (1 << t) - 1, Be = Me === 1 ? null : this.dbl(), Pe = 1; Pe < Me; Pe++)
    Ie[Pe] = Ie[Pe - 1].add(Be);
  return {
    wnd: t,
    points: Ie
  };
};
BasePoint.prototype._getBeta = function Ae() {
  return null;
};
BasePoint.prototype.dblp = function Ae(t) {
  for (var Ie = this, Me = 0; Me < t; Me++)
    Ie = Ie.dbl();
  return Ie;
};
var inherits_browser = createCommonjsModule(function(Ae) {
  typeof Object.create == "function" ? Ae.exports = function(Ie, Me) {
    Me && (Ie.super_ = Me, Ie.prototype = Object.create(Me.prototype, {
      constructor: {
        value: Ie,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : Ae.exports = function(Ie, Me) {
    if (Me) {
      Ie.super_ = Me;
      var Be = function() {
      };
      Be.prototype = Me.prototype, Ie.prototype = new Be(), Ie.prototype.constructor = Ie;
    }
  };
}), assert$2 = utils_1$1.assert;
function ShortCurve(Ae) {
  base.call(this, "short", Ae), this.a = new BN$8(Ae.a, 16).toRed(this.red), this.b = new BN$8(Ae.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(Ae), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function Ae(t) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var Ie, Me;
    if (t.beta)
      Ie = new BN$8(t.beta, 16).toRed(this.red);
    else {
      var Be = this._getEndoRoots(this.p);
      Ie = Be[0].cmp(Be[1]) < 0 ? Be[0] : Be[1], Ie = Ie.toRed(this.red);
    }
    if (t.lambda)
      Me = new BN$8(t.lambda, 16);
    else {
      var Pe = this._getEndoRoots(this.n);
      this.g.mul(Pe[0]).x.cmp(this.g.x.redMul(Ie)) === 0 ? Me = Pe[0] : (Me = Pe[1], assert$2(this.g.mul(Me).x.cmp(this.g.x.redMul(Ie)) === 0));
    }
    var Te;
    return t.basis ? Te = t.basis.map(function(je) {
      return {
        a: new BN$8(je.a, 16),
        b: new BN$8(je.b, 16)
      };
    }) : Te = this._getEndoBasis(Me), {
      beta: Ie,
      lambda: Me,
      basis: Te
    };
  }
};
ShortCurve.prototype._getEndoRoots = function Ae(t) {
  var Ie = t === this.p ? this.red : BN$8.mont(t), Me = new BN$8(2).toRed(Ie).redInvm(), Be = Me.redNeg(), Pe = new BN$8(3).toRed(Ie).redNeg().redSqrt().redMul(Me), Te = Be.redAdd(Pe).fromRed(), je = Be.redSub(Pe).fromRed();
  return [Te, je];
};
ShortCurve.prototype._getEndoBasis = function Ae(t) {
  for (var Ie = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), Me = t, Be = this.n.clone(), Pe = new BN$8(1), Te = new BN$8(0), je = new BN$8(0), Ve = new BN$8(1), fi, Ue, bi, vi, mi, _i, Ei, Pi = 0, Ii, Ci; Me.cmpn(0) !== 0; ) {
    var Wi = Be.div(Me);
    Ii = Be.sub(Wi.mul(Me)), Ci = je.sub(Wi.mul(Pe));
    var zi = Ve.sub(Wi.mul(Te));
    if (!bi && Ii.cmp(Ie) < 0)
      fi = Ei.neg(), Ue = Pe, bi = Ii.neg(), vi = Ci;
    else if (bi && ++Pi === 2)
      break;
    Ei = Ii, Be = Me, Me = Ii, je = Pe, Pe = Ci, Ve = Te, Te = zi;
  }
  mi = Ii.neg(), _i = Ci;
  var Xi = bi.sqr().add(vi.sqr()), Qi = mi.sqr().add(_i.sqr());
  return Qi.cmp(Xi) >= 0 && (mi = fi, _i = Ue), bi.negative && (bi = bi.neg(), vi = vi.neg()), mi.negative && (mi = mi.neg(), _i = _i.neg()), [
    { a: bi, b: vi },
    { a: mi, b: _i }
  ];
};
ShortCurve.prototype._endoSplit = function Ae(t) {
  var Ie = this.endo.basis, Me = Ie[0], Be = Ie[1], Pe = Be.b.mul(t).divRound(this.n), Te = Me.b.neg().mul(t).divRound(this.n), je = Pe.mul(Me.a), Ve = Te.mul(Be.a), fi = Pe.mul(Me.b), Ue = Te.mul(Be.b), bi = t.sub(je).sub(Ve), vi = fi.add(Ue).neg();
  return { k1: bi, k2: vi };
};
ShortCurve.prototype.pointFromX = function Ae(t, Ie) {
  t = new BN$8(t, 16), t.red || (t = t.toRed(this.red));
  var Me = t.redSqr().redMul(t).redIAdd(t.redMul(this.a)).redIAdd(this.b), Be = Me.redSqrt();
  if (Be.redSqr().redSub(Me).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var Pe = Be.fromRed().isOdd();
  return (Ie && !Pe || !Ie && Pe) && (Be = Be.redNeg()), this.point(t, Be);
};
ShortCurve.prototype.validate = function Ae(t) {
  if (t.inf)
    return !0;
  var Ie = t.x, Me = t.y, Be = this.a.redMul(Ie), Pe = Ie.redSqr().redMul(Ie).redIAdd(Be).redIAdd(this.b);
  return Me.redSqr().redISub(Pe).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function Ae(t, Ie, Me) {
  for (var Be = this._endoWnafT1, Pe = this._endoWnafT2, Te = 0; Te < t.length; Te++) {
    var je = this._endoSplit(Ie[Te]), Ve = t[Te], fi = Ve._getBeta();
    je.k1.negative && (je.k1.ineg(), Ve = Ve.neg(!0)), je.k2.negative && (je.k2.ineg(), fi = fi.neg(!0)), Be[Te * 2] = Ve, Be[Te * 2 + 1] = fi, Pe[Te * 2] = je.k1, Pe[Te * 2 + 1] = je.k2;
  }
  for (var Ue = this._wnafMulAdd(1, Be, Pe, Te * 2, Me), bi = 0; bi < Te * 2; bi++)
    Be[bi] = null, Pe[bi] = null;
  return Ue;
};
function Point(Ae, t, Ie, Me) {
  base.BasePoint.call(this, Ae, "affine"), t === null && Ie === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$8(t, 16), this.y = new BN$8(Ie, 16), Me && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits_browser(Point, base.BasePoint);
ShortCurve.prototype.point = function Ae(t, Ie, Me) {
  return new Point(this, t, Ie, Me);
};
ShortCurve.prototype.pointFromJSON = function Ae(t, Ie) {
  return Point.fromJSON(this, t, Ie);
};
Point.prototype._getBeta = function Ae() {
  if (this.curve.endo) {
    var t = this.precomputed;
    if (t && t.beta)
      return t.beta;
    var Ie = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (t) {
      var Me = this.curve, Be = function(Pe) {
        return Me.point(Pe.x.redMul(Me.endo.beta), Pe.y);
      };
      t.beta = Ie, Ie.precomputed = {
        beta: null,
        naf: t.naf && {
          wnd: t.naf.wnd,
          points: t.naf.points.map(Be)
        },
        doubles: t.doubles && {
          step: t.doubles.step,
          points: t.doubles.points.map(Be)
        }
      };
    }
    return Ie;
  }
};
Point.prototype.toJSON = function Ae() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point.fromJSON = function Ae(t, Ie, Me) {
  typeof Ie == "string" && (Ie = JSON.parse(Ie));
  var Be = t.point(Ie[0], Ie[1], Me);
  if (!Ie[2])
    return Be;
  function Pe(je) {
    return t.point(je[0], je[1], Me);
  }
  var Te = Ie[2];
  return Be.precomputed = {
    beta: null,
    doubles: Te.doubles && {
      step: Te.doubles.step,
      points: [Be].concat(Te.doubles.points.map(Pe))
    },
    naf: Te.naf && {
      wnd: Te.naf.wnd,
      points: [Be].concat(Te.naf.points.map(Pe))
    }
  }, Be;
};
Point.prototype.inspect = function Ae() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function Ae() {
  return this.inf;
};
Point.prototype.add = function Ae(t) {
  if (this.inf)
    return t;
  if (t.inf)
    return this;
  if (this.eq(t))
    return this.dbl();
  if (this.neg().eq(t))
    return this.curve.point(null, null);
  if (this.x.cmp(t.x) === 0)
    return this.curve.point(null, null);
  var Ie = this.y.redSub(t.y);
  Ie.cmpn(0) !== 0 && (Ie = Ie.redMul(this.x.redSub(t.x).redInvm()));
  var Me = Ie.redSqr().redISub(this.x).redISub(t.x), Be = Ie.redMul(this.x.redSub(Me)).redISub(this.y);
  return this.curve.point(Me, Be);
};
Point.prototype.dbl = function Ae() {
  if (this.inf)
    return this;
  var t = this.y.redAdd(this.y);
  if (t.cmpn(0) === 0)
    return this.curve.point(null, null);
  var Ie = this.curve.a, Me = this.x.redSqr(), Be = t.redInvm(), Pe = Me.redAdd(Me).redIAdd(Me).redIAdd(Ie).redMul(Be), Te = Pe.redSqr().redISub(this.x.redAdd(this.x)), je = Pe.redMul(this.x.redSub(Te)).redISub(this.y);
  return this.curve.point(Te, je);
};
Point.prototype.getX = function Ae() {
  return this.x.fromRed();
};
Point.prototype.getY = function Ae() {
  return this.y.fromRed();
};
Point.prototype.mul = function Ae(t) {
  return t = new BN$8(t, 16), this.isInfinity() ? this : this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [t]) : this.curve._wnafMul(this, t);
};
Point.prototype.mulAdd = function Ae(t, Ie, Me) {
  var Be = [this, Ie], Pe = [t, Me];
  return this.curve.endo ? this.curve._endoWnafMulAdd(Be, Pe) : this.curve._wnafMulAdd(1, Be, Pe, 2);
};
Point.prototype.jmulAdd = function Ae(t, Ie, Me) {
  var Be = [this, Ie], Pe = [t, Me];
  return this.curve.endo ? this.curve._endoWnafMulAdd(Be, Pe, !0) : this.curve._wnafMulAdd(1, Be, Pe, 2, !0);
};
Point.prototype.eq = function Ae(t) {
  return this === t || this.inf === t.inf && (this.inf || this.x.cmp(t.x) === 0 && this.y.cmp(t.y) === 0);
};
Point.prototype.neg = function Ae(t) {
  if (this.inf)
    return this;
  var Ie = this.curve.point(this.x, this.y.redNeg());
  if (t && this.precomputed) {
    var Me = this.precomputed, Be = function(Pe) {
      return Pe.neg();
    };
    Ie.precomputed = {
      naf: Me.naf && {
        wnd: Me.naf.wnd,
        points: Me.naf.points.map(Be)
      },
      doubles: Me.doubles && {
        step: Me.doubles.step,
        points: Me.doubles.points.map(Be)
      }
    };
  }
  return Ie;
};
Point.prototype.toJ = function Ae() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var t = this.curve.jpoint(this.x, this.y, this.curve.one);
  return t;
};
function JPoint(Ae, t, Ie, Me) {
  base.BasePoint.call(this, Ae, "jacobian"), t === null && Ie === null && Me === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$8(0)) : (this.x = new BN$8(t, 16), this.y = new BN$8(Ie, 16), this.z = new BN$8(Me, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base.BasePoint);
ShortCurve.prototype.jpoint = function Ae(t, Ie, Me) {
  return new JPoint(this, t, Ie, Me);
};
JPoint.prototype.toP = function Ae() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var t = this.z.redInvm(), Ie = t.redSqr(), Me = this.x.redMul(Ie), Be = this.y.redMul(Ie).redMul(t);
  return this.curve.point(Me, Be);
};
JPoint.prototype.neg = function Ae() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function Ae(t) {
  if (this.isInfinity())
    return t;
  if (t.isInfinity())
    return this;
  var Ie = t.z.redSqr(), Me = this.z.redSqr(), Be = this.x.redMul(Ie), Pe = t.x.redMul(Me), Te = this.y.redMul(Ie.redMul(t.z)), je = t.y.redMul(Me.redMul(this.z)), Ve = Be.redSub(Pe), fi = Te.redSub(je);
  if (Ve.cmpn(0) === 0)
    return fi.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var Ue = Ve.redSqr(), bi = Ue.redMul(Ve), vi = Be.redMul(Ue), mi = fi.redSqr().redIAdd(bi).redISub(vi).redISub(vi), _i = fi.redMul(vi.redISub(mi)).redISub(Te.redMul(bi)), Ei = this.z.redMul(t.z).redMul(Ve);
  return this.curve.jpoint(mi, _i, Ei);
};
JPoint.prototype.mixedAdd = function Ae(t) {
  if (this.isInfinity())
    return t.toJ();
  if (t.isInfinity())
    return this;
  var Ie = this.z.redSqr(), Me = this.x, Be = t.x.redMul(Ie), Pe = this.y, Te = t.y.redMul(Ie).redMul(this.z), je = Me.redSub(Be), Ve = Pe.redSub(Te);
  if (je.cmpn(0) === 0)
    return Ve.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var fi = je.redSqr(), Ue = fi.redMul(je), bi = Me.redMul(fi), vi = Ve.redSqr().redIAdd(Ue).redISub(bi).redISub(bi), mi = Ve.redMul(bi.redISub(vi)).redISub(Pe.redMul(Ue)), _i = this.z.redMul(je);
  return this.curve.jpoint(vi, mi, _i);
};
JPoint.prototype.dblp = function Ae(t) {
  if (t === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!t)
    return this.dbl();
  var Ie;
  if (this.curve.zeroA || this.curve.threeA) {
    var Me = this;
    for (Ie = 0; Ie < t; Ie++)
      Me = Me.dbl();
    return Me;
  }
  var Be = this.curve.a, Pe = this.curve.tinv, Te = this.x, je = this.y, Ve = this.z, fi = Ve.redSqr().redSqr(), Ue = je.redAdd(je);
  for (Ie = 0; Ie < t; Ie++) {
    var bi = Te.redSqr(), vi = Ue.redSqr(), mi = vi.redSqr(), _i = bi.redAdd(bi).redIAdd(bi).redIAdd(Be.redMul(fi)), Ei = Te.redMul(vi), Pi = _i.redSqr().redISub(Ei.redAdd(Ei)), Ii = Ei.redISub(Pi), Ci = _i.redMul(Ii);
    Ci = Ci.redIAdd(Ci).redISub(mi);
    var Wi = Ue.redMul(Ve);
    Ie + 1 < t && (fi = fi.redMul(mi)), Te = Pi, Ve = Wi, Ue = Ci;
  }
  return this.curve.jpoint(Te, Ue.redMul(Pe), Ve);
};
JPoint.prototype.dbl = function Ae() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function Ae() {
  var t, Ie, Me;
  if (this.zOne) {
    var Be = this.x.redSqr(), Pe = this.y.redSqr(), Te = Pe.redSqr(), je = this.x.redAdd(Pe).redSqr().redISub(Be).redISub(Te);
    je = je.redIAdd(je);
    var Ve = Be.redAdd(Be).redIAdd(Be), fi = Ve.redSqr().redISub(je).redISub(je), Ue = Te.redIAdd(Te);
    Ue = Ue.redIAdd(Ue), Ue = Ue.redIAdd(Ue), t = fi, Ie = Ve.redMul(je.redISub(fi)).redISub(Ue), Me = this.y.redAdd(this.y);
  } else {
    var bi = this.x.redSqr(), vi = this.y.redSqr(), mi = vi.redSqr(), _i = this.x.redAdd(vi).redSqr().redISub(bi).redISub(mi);
    _i = _i.redIAdd(_i);
    var Ei = bi.redAdd(bi).redIAdd(bi), Pi = Ei.redSqr(), Ii = mi.redIAdd(mi);
    Ii = Ii.redIAdd(Ii), Ii = Ii.redIAdd(Ii), t = Pi.redISub(_i).redISub(_i), Ie = Ei.redMul(_i.redISub(t)).redISub(Ii), Me = this.y.redMul(this.z), Me = Me.redIAdd(Me);
  }
  return this.curve.jpoint(t, Ie, Me);
};
JPoint.prototype._threeDbl = function Ae() {
  var t, Ie, Me;
  if (this.zOne) {
    var Be = this.x.redSqr(), Pe = this.y.redSqr(), Te = Pe.redSqr(), je = this.x.redAdd(Pe).redSqr().redISub(Be).redISub(Te);
    je = je.redIAdd(je);
    var Ve = Be.redAdd(Be).redIAdd(Be).redIAdd(this.curve.a), fi = Ve.redSqr().redISub(je).redISub(je);
    t = fi;
    var Ue = Te.redIAdd(Te);
    Ue = Ue.redIAdd(Ue), Ue = Ue.redIAdd(Ue), Ie = Ve.redMul(je.redISub(fi)).redISub(Ue), Me = this.y.redAdd(this.y);
  } else {
    var bi = this.z.redSqr(), vi = this.y.redSqr(), mi = this.x.redMul(vi), _i = this.x.redSub(bi).redMul(this.x.redAdd(bi));
    _i = _i.redAdd(_i).redIAdd(_i);
    var Ei = mi.redIAdd(mi);
    Ei = Ei.redIAdd(Ei);
    var Pi = Ei.redAdd(Ei);
    t = _i.redSqr().redISub(Pi), Me = this.y.redAdd(this.z).redSqr().redISub(vi).redISub(bi);
    var Ii = vi.redSqr();
    Ii = Ii.redIAdd(Ii), Ii = Ii.redIAdd(Ii), Ii = Ii.redIAdd(Ii), Ie = _i.redMul(Ei.redISub(t)).redISub(Ii);
  }
  return this.curve.jpoint(t, Ie, Me);
};
JPoint.prototype._dbl = function Ae() {
  var t = this.curve.a, Ie = this.x, Me = this.y, Be = this.z, Pe = Be.redSqr().redSqr(), Te = Ie.redSqr(), je = Me.redSqr(), Ve = Te.redAdd(Te).redIAdd(Te).redIAdd(t.redMul(Pe)), fi = Ie.redAdd(Ie);
  fi = fi.redIAdd(fi);
  var Ue = fi.redMul(je), bi = Ve.redSqr().redISub(Ue.redAdd(Ue)), vi = Ue.redISub(bi), mi = je.redSqr();
  mi = mi.redIAdd(mi), mi = mi.redIAdd(mi), mi = mi.redIAdd(mi);
  var _i = Ve.redMul(vi).redISub(mi), Ei = Me.redAdd(Me).redMul(Be);
  return this.curve.jpoint(bi, _i, Ei);
};
JPoint.prototype.trpl = function Ae() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var t = this.x.redSqr(), Ie = this.y.redSqr(), Me = this.z.redSqr(), Be = Ie.redSqr(), Pe = t.redAdd(t).redIAdd(t), Te = Pe.redSqr(), je = this.x.redAdd(Ie).redSqr().redISub(t).redISub(Be);
  je = je.redIAdd(je), je = je.redAdd(je).redIAdd(je), je = je.redISub(Te);
  var Ve = je.redSqr(), fi = Be.redIAdd(Be);
  fi = fi.redIAdd(fi), fi = fi.redIAdd(fi), fi = fi.redIAdd(fi);
  var Ue = Pe.redIAdd(je).redSqr().redISub(Te).redISub(Ve).redISub(fi), bi = Ie.redMul(Ue);
  bi = bi.redIAdd(bi), bi = bi.redIAdd(bi);
  var vi = this.x.redMul(Ve).redISub(bi);
  vi = vi.redIAdd(vi), vi = vi.redIAdd(vi);
  var mi = this.y.redMul(Ue.redMul(fi.redISub(Ue)).redISub(je.redMul(Ve)));
  mi = mi.redIAdd(mi), mi = mi.redIAdd(mi), mi = mi.redIAdd(mi);
  var _i = this.z.redAdd(je).redSqr().redISub(Me).redISub(Ve);
  return this.curve.jpoint(vi, mi, _i);
};
JPoint.prototype.mul = function Ae(t, Ie) {
  return t = new BN$8(t, Ie), this.curve._wnafMul(this, t);
};
JPoint.prototype.eq = function Ae(t) {
  if (t.type === "affine")
    return this.eq(t.toJ());
  if (this === t)
    return !0;
  var Ie = this.z.redSqr(), Me = t.z.redSqr();
  if (this.x.redMul(Me).redISub(t.x.redMul(Ie)).cmpn(0) !== 0)
    return !1;
  var Be = Ie.redMul(this.z), Pe = Me.redMul(t.z);
  return this.y.redMul(Pe).redISub(t.y.redMul(Be)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function Ae(t) {
  var Ie = this.z.redSqr(), Me = t.toRed(this.curve.red).redMul(Ie);
  if (this.x.cmp(Me) === 0)
    return !0;
  for (var Be = t.clone(), Pe = this.curve.redN.redMul(Ie); ; ) {
    if (Be.iadd(this.curve.n), Be.cmp(this.curve.p) >= 0)
      return !1;
    if (Me.redIAdd(Pe), this.x.cmp(Me) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function Ae() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function Ae() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(Ae, t) {
  var Ie = t;
  Ie.base = base, Ie.short = short_1, Ie.mont = /*RicMoo:ethers:require(./mont)*/
  null, Ie.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
}), curves_1 = createCommonjsModule(function(Ae, t) {
  var Ie = t, Me = utils_1$1.assert;
  function Be(je) {
    je.type === "short" ? this.curve = new curve_1.short(je) : je.type === "edwards" ? this.curve = new curve_1.edwards(je) : this.curve = new curve_1.mont(je), this.g = this.curve.g, this.n = this.curve.n, this.hash = je.hash, Me(this.g.validate(), "Invalid curve"), Me(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  Ie.PresetCurve = Be;
  function Pe(je, Ve) {
    Object.defineProperty(Ie, je, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var fi = new Be(Ve);
        return Object.defineProperty(Ie, je, {
          configurable: !0,
          enumerable: !0,
          value: fi
        }), fi;
      }
    });
  }
  Pe("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash$3.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), Pe("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash$3.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), Pe("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash$3.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), Pe("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash$3.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), Pe("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash$3.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), Pe("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$3.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), Pe("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$3.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var Te;
  try {
    Te = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch {
    Te = void 0;
  }
  Pe("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash$3.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      Te
    ]
  });
});
function HmacDRBG(Ae) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(Ae);
  this.hash = Ae.hash, this.predResist = !!Ae.predResist, this.outLen = this.hash.outSize, this.minEntropy = Ae.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var t = utils_1.toArray(Ae.entropy, Ae.entropyEnc || "hex"), Ie = utils_1.toArray(Ae.nonce, Ae.nonceEnc || "hex"), Me = utils_1.toArray(Ae.pers, Ae.persEnc || "hex");
  minimalisticAssert(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(t, Ie, Me);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function Ae(t, Ie, Me) {
  var Be = t.concat(Ie).concat(Me);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var Pe = 0; Pe < this.V.length; Pe++)
    this.K[Pe] = 0, this.V[Pe] = 1;
  this._update(Be), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function Ae() {
  return new hash$3.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function Ae(t) {
  var Ie = this._hmac().update(this.V).update([0]);
  t && (Ie = Ie.update(t)), this.K = Ie.digest(), this.V = this._hmac().update(this.V).digest(), t && (this.K = this._hmac().update(this.V).update([1]).update(t).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG.prototype.reseed = function Ae(t, Ie, Me, Be) {
  typeof Ie != "string" && (Be = Me, Me = Ie, Ie = null), t = utils_1.toArray(t, Ie), Me = utils_1.toArray(Me, Be), minimalisticAssert(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(t.concat(Me || [])), this._reseed = 1;
};
HmacDRBG.prototype.generate = function Ae(t, Ie, Me, Be) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof Ie != "string" && (Be = Me, Me = Ie, Ie = null), Me && (Me = utils_1.toArray(Me, Be || "hex"), this._update(Me));
  for (var Pe = []; Pe.length < t; )
    this.V = this._hmac().update(this.V).digest(), Pe = Pe.concat(this.V);
  var Te = Pe.slice(0, t);
  return this._update(Me), this._reseed++, utils_1.encode(Te, Ie);
};
var assert$3 = utils_1$1.assert;
function KeyPair(Ae, t) {
  this.ec = Ae, this.priv = null, this.pub = null, t.priv && this._importPrivate(t.priv, t.privEnc), t.pub && this._importPublic(t.pub, t.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function Ae(t, Ie, Me) {
  return Ie instanceof KeyPair ? Ie : new KeyPair(t, {
    pub: Ie,
    pubEnc: Me
  });
};
KeyPair.fromPrivate = function Ae(t, Ie, Me) {
  return Ie instanceof KeyPair ? Ie : new KeyPair(t, {
    priv: Ie,
    privEnc: Me
  });
};
KeyPair.prototype.validate = function Ae() {
  var t = this.getPublic();
  return t.isInfinity() ? { result: !1, reason: "Invalid public key" } : t.validate() ? t.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair.prototype.getPublic = function Ae(t, Ie) {
  return typeof t == "string" && (Ie = t, t = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), Ie ? this.pub.encode(Ie, t) : this.pub;
};
KeyPair.prototype.getPrivate = function Ae(t) {
  return t === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair.prototype._importPrivate = function Ae(t, Ie) {
  this.priv = new BN$8(t, Ie || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function Ae(t, Ie) {
  if (t.x || t.y) {
    this.ec.curve.type === "mont" ? assert$3(t.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$3(t.x && t.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(t.x, t.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(t, Ie);
};
KeyPair.prototype.derive = function Ae(t) {
  return t.validate() || assert$3(t.validate(), "public point not validated"), t.mul(this.priv).getX();
};
KeyPair.prototype.sign = function Ae(t, Ie, Me) {
  return this.ec.sign(t, this, Ie, Me);
};
KeyPair.prototype.verify = function Ae(t, Ie) {
  return this.ec.verify(t, Ie, this);
};
KeyPair.prototype.inspect = function Ae() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4 = utils_1$1.assert;
function Signature(Ae, t) {
  if (Ae instanceof Signature)
    return Ae;
  this._importDER(Ae, t) || (assert$4(Ae.r && Ae.s, "Signature without r or s"), this.r = new BN$8(Ae.r, 16), this.s = new BN$8(Ae.s, 16), Ae.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = Ae.recoveryParam);
}
var signature = Signature;
function Position() {
  this.place = 0;
}
function getLength(Ae, t) {
  var Ie = Ae[t.place++];
  if (!(Ie & 128))
    return Ie;
  var Me = Ie & 15;
  if (Me === 0 || Me > 4)
    return !1;
  for (var Be = 0, Pe = 0, Te = t.place; Pe < Me; Pe++, Te++)
    Be <<= 8, Be |= Ae[Te], Be >>>= 0;
  return Be <= 127 ? !1 : (t.place = Te, Be);
}
function rmPadding(Ae) {
  for (var t = 0, Ie = Ae.length - 1; !Ae[t] && !(Ae[t + 1] & 128) && t < Ie; )
    t++;
  return t === 0 ? Ae : Ae.slice(t);
}
Signature.prototype._importDER = function Ae(t, Ie) {
  t = utils_1$1.toArray(t, Ie);
  var Me = new Position();
  if (t[Me.place++] !== 48)
    return !1;
  var Be = getLength(t, Me);
  if (Be === !1 || Be + Me.place !== t.length || t[Me.place++] !== 2)
    return !1;
  var Pe = getLength(t, Me);
  if (Pe === !1)
    return !1;
  var Te = t.slice(Me.place, Pe + Me.place);
  if (Me.place += Pe, t[Me.place++] !== 2)
    return !1;
  var je = getLength(t, Me);
  if (je === !1 || t.length !== je + Me.place)
    return !1;
  var Ve = t.slice(Me.place, je + Me.place);
  if (Te[0] === 0)
    if (Te[1] & 128)
      Te = Te.slice(1);
    else
      return !1;
  if (Ve[0] === 0)
    if (Ve[1] & 128)
      Ve = Ve.slice(1);
    else
      return !1;
  return this.r = new BN$8(Te), this.s = new BN$8(Ve), this.recoveryParam = null, !0;
};
function constructLength(Ae, t) {
  if (t < 128) {
    Ae.push(t);
    return;
  }
  var Ie = 1 + (Math.log(t) / Math.LN2 >>> 3);
  for (Ae.push(Ie | 128); --Ie; )
    Ae.push(t >>> (Ie << 3) & 255);
  Ae.push(t);
}
Signature.prototype.toDER = function Ae(t) {
  var Ie = this.r.toArray(), Me = this.s.toArray();
  for (Ie[0] & 128 && (Ie = [0].concat(Ie)), Me[0] & 128 && (Me = [0].concat(Me)), Ie = rmPadding(Ie), Me = rmPadding(Me); !Me[0] && !(Me[1] & 128); )
    Me = Me.slice(1);
  var Be = [2];
  constructLength(Be, Ie.length), Be = Be.concat(Ie), Be.push(2), constructLength(Be, Me.length);
  var Pe = Be.concat(Me), Te = [48];
  return constructLength(Te, Pe.length), Te = Te.concat(Pe), utils_1$1.encode(Te, t);
};
var rand = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
), assert$5 = utils_1$1.assert;
function EC(Ae) {
  if (!(this instanceof EC))
    return new EC(Ae);
  typeof Ae == "string" && (assert$5(
    Object.prototype.hasOwnProperty.call(curves_1, Ae),
    "Unknown curve " + Ae
  ), Ae = curves_1[Ae]), Ae instanceof curves_1.PresetCurve && (Ae = { curve: Ae }), this.curve = Ae.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = Ae.curve.g, this.g.precompute(Ae.curve.n.bitLength() + 1), this.hash = Ae.hash || Ae.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function Ae(t) {
  return new key(this, t);
};
EC.prototype.keyFromPrivate = function Ae(t, Ie) {
  return key.fromPrivate(this, t, Ie);
};
EC.prototype.keyFromPublic = function Ae(t, Ie) {
  return key.fromPublic(this, t, Ie);
};
EC.prototype.genKeyPair = function Ae(t) {
  t || (t = {});
  for (var Ie = new hmacDrbg({
    hash: this.hash,
    pers: t.pers,
    persEnc: t.persEnc || "utf8",
    entropy: t.entropy || rand(this.hash.hmacStrength),
    entropyEnc: t.entropy && t.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), Me = this.n.byteLength(), Be = this.n.sub(new BN$8(2)); ; ) {
    var Pe = new BN$8(Ie.generate(Me));
    if (!(Pe.cmp(Be) > 0))
      return Pe.iaddn(1), this.keyFromPrivate(Pe);
  }
};
EC.prototype._truncateToN = function Ae(t, Ie) {
  var Me = t.byteLength() * 8 - this.n.bitLength();
  return Me > 0 && (t = t.ushrn(Me)), !Ie && t.cmp(this.n) >= 0 ? t.sub(this.n) : t;
};
EC.prototype.sign = function Ae(t, Ie, Me, Be) {
  typeof Me == "object" && (Be = Me, Me = null), Be || (Be = {}), Ie = this.keyFromPrivate(Ie, Me), t = this._truncateToN(new BN$8(t, 16));
  for (var Pe = this.n.byteLength(), Te = Ie.getPrivate().toArray("be", Pe), je = t.toArray("be", Pe), Ve = new hmacDrbg({
    hash: this.hash,
    entropy: Te,
    nonce: je,
    pers: Be.pers,
    persEnc: Be.persEnc || "utf8"
  }), fi = this.n.sub(new BN$8(1)), Ue = 0; ; Ue++) {
    var bi = Be.k ? Be.k(Ue) : new BN$8(Ve.generate(this.n.byteLength()));
    if (bi = this._truncateToN(bi, !0), !(bi.cmpn(1) <= 0 || bi.cmp(fi) >= 0)) {
      var vi = this.g.mul(bi);
      if (!vi.isInfinity()) {
        var mi = vi.getX(), _i = mi.umod(this.n);
        if (_i.cmpn(0) !== 0) {
          var Ei = bi.invm(this.n).mul(_i.mul(Ie.getPrivate()).iadd(t));
          if (Ei = Ei.umod(this.n), Ei.cmpn(0) !== 0) {
            var Pi = (vi.getY().isOdd() ? 1 : 0) | (mi.cmp(_i) !== 0 ? 2 : 0);
            return Be.canonical && Ei.cmp(this.nh) > 0 && (Ei = this.n.sub(Ei), Pi ^= 1), new signature({ r: _i, s: Ei, recoveryParam: Pi });
          }
        }
      }
    }
  }
};
EC.prototype.verify = function Ae(t, Ie, Me, Be) {
  t = this._truncateToN(new BN$8(t, 16)), Me = this.keyFromPublic(Me, Be), Ie = new signature(Ie, "hex");
  var Pe = Ie.r, Te = Ie.s;
  if (Pe.cmpn(1) < 0 || Pe.cmp(this.n) >= 0 || Te.cmpn(1) < 0 || Te.cmp(this.n) >= 0)
    return !1;
  var je = Te.invm(this.n), Ve = je.mul(t).umod(this.n), fi = je.mul(Pe).umod(this.n), Ue;
  return this.curve._maxwellTrick ? (Ue = this.g.jmulAdd(Ve, Me.getPublic(), fi), Ue.isInfinity() ? !1 : Ue.eqXToP(Pe)) : (Ue = this.g.mulAdd(Ve, Me.getPublic(), fi), Ue.isInfinity() ? !1 : Ue.getX().umod(this.n).cmp(Pe) === 0);
};
EC.prototype.recoverPubKey = function(Ae, t, Ie, Me) {
  assert$5((3 & Ie) === Ie, "The recovery param is more than two bits"), t = new signature(t, Me);
  var Be = this.n, Pe = new BN$8(Ae), Te = t.r, je = t.s, Ve = Ie & 1, fi = Ie >> 1;
  if (Te.cmp(this.curve.p.umod(this.curve.n)) >= 0 && fi)
    throw new Error("Unable to find sencond key candinate");
  fi ? Te = this.curve.pointFromX(Te.add(this.curve.n), Ve) : Te = this.curve.pointFromX(Te, Ve);
  var Ue = t.r.invm(Be), bi = Be.sub(Pe).mul(Ue).umod(Be), vi = je.mul(Ue).umod(Be);
  return this.g.mulAdd(bi, Te, vi);
};
EC.prototype.getKeyRecoveryParam = function(Ae, t, Ie, Me) {
  if (t = new signature(t, Me), t.recoveryParam !== null)
    return t.recoveryParam;
  for (var Be = 0; Be < 4; Be++) {
    var Pe;
    try {
      Pe = this.recoverPubKey(Ae, t, Be);
    } catch {
      continue;
    }
    if (Pe.eq(Ie))
      return Be;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(Ae, t) {
  var Ie = t;
  Ie.version = "6.5.4", Ie.utils = utils_1$1, Ie.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }, Ie.curve = curve_1, Ie.curves = curves_1, Ie.ec = ec, Ie.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
}), EC$1 = elliptic_1.ec;
const version = "signing-key/5.7.0", logger = new Logger(version);
let _curve = null;
function getCurve() {
  return _curve || (_curve = new EC$1("secp256k1")), _curve;
}
class SigningKey {
  constructor(t) {
    defineReadOnly(this, "curve", "secp256k1"), defineReadOnly(this, "privateKey", hexlify(t)), hexDataLength(this.privateKey) !== 32 && logger.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    const Ie = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + Ie.getPublic(!1, "hex")), defineReadOnly(this, "compressedPublicKey", "0x" + Ie.getPublic(!0, "hex")), defineReadOnly(this, "_isSigningKey", !0);
  }
  _addPoint(t) {
    const Ie = getCurve().keyFromPublic(arrayify(this.publicKey)), Me = getCurve().keyFromPublic(arrayify(t));
    return "0x" + Ie.pub.add(Me.pub).encodeCompressed("hex");
  }
  signDigest(t) {
    const Ie = getCurve().keyFromPrivate(arrayify(this.privateKey)), Me = arrayify(t);
    Me.length !== 32 && logger.throwArgumentError("bad digest length", "digest", t);
    const Be = Ie.sign(Me, { canonical: !0 });
    return splitSignature({
      recoveryParam: Be.recoveryParam,
      r: hexZeroPad("0x" + Be.r.toString(16), 32),
      s: hexZeroPad("0x" + Be.s.toString(16), 32)
    });
  }
  computeSharedSecret(t) {
    const Ie = getCurve().keyFromPrivate(arrayify(this.privateKey)), Me = getCurve().keyFromPublic(arrayify(computePublicKey(t)));
    return hexZeroPad("0x" + Ie.derive(Me.getPublic()).toString(16), 32);
  }
  static isSigningKey(t) {
    return !!(t && t._isSigningKey);
  }
}
function recoverPublicKey(Ae, t) {
  const Ie = splitSignature(t), Me = { r: arrayify(Ie.r), s: arrayify(Ie.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(Ae), Me, Ie.recoveryParam).encode("hex", !1);
}
function computePublicKey(Ae, t) {
  const Ie = arrayify(Ae);
  return Ie.length === 32 ? new SigningKey(Ie).publicKey : Ie.length === 33 ? "0x" + getCurve().keyFromPublic(Ie).getPublic(!1, "hex") : Ie.length === 65 ? hexlify(Ie) : logger.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
var TransactionTypes;
(function(Ae) {
  Ae[Ae.legacy = 0] = "legacy", Ae[Ae.eip2930 = 1] = "eip2930", Ae[Ae.eip1559 = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function computeAddress(Ae) {
  const t = computePublicKey(Ae);
  return getAddress(hexDataSlice(keccak256(hexDataSlice(t, 1)), 12));
}
function recoverAddress(Ae, t) {
  return computeAddress(recoverPublicKey(arrayify(Ae), t));
}
var chacha20poly1305 = {}, chacha = {};
Object.defineProperty(chacha, "__esModule", { value: !0 });
var binary_1 = binary, wipe_1$2 = wipe$1, ROUNDS = 20;
function core(Ae, t, Ie) {
  for (var Me = 1634760805, Be = 857760878, Pe = 2036477234, Te = 1797285236, je = Ie[3] << 24 | Ie[2] << 16 | Ie[1] << 8 | Ie[0], Ve = Ie[7] << 24 | Ie[6] << 16 | Ie[5] << 8 | Ie[4], fi = Ie[11] << 24 | Ie[10] << 16 | Ie[9] << 8 | Ie[8], Ue = Ie[15] << 24 | Ie[14] << 16 | Ie[13] << 8 | Ie[12], bi = Ie[19] << 24 | Ie[18] << 16 | Ie[17] << 8 | Ie[16], vi = Ie[23] << 24 | Ie[22] << 16 | Ie[21] << 8 | Ie[20], mi = Ie[27] << 24 | Ie[26] << 16 | Ie[25] << 8 | Ie[24], _i = Ie[31] << 24 | Ie[30] << 16 | Ie[29] << 8 | Ie[28], Ei = t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0], Pi = t[7] << 24 | t[6] << 16 | t[5] << 8 | t[4], Ii = t[11] << 24 | t[10] << 16 | t[9] << 8 | t[8], Ci = t[15] << 24 | t[14] << 16 | t[13] << 8 | t[12], Wi = Me, zi = Be, Xi = Pe, Qi = Te, Oi = je, Yi = Ve, ns = fi, ls = Ue, vn = bi, Mi = vi, Ai = mi, wi = _i, $i = Ei, Li = Pi, qi = Ii, Ni = Ci, Ti = 0; Ti < ROUNDS; Ti += 2)
    Wi = Wi + Oi | 0, $i ^= Wi, $i = $i >>> 16 | $i << 16, vn = vn + $i | 0, Oi ^= vn, Oi = Oi >>> 20 | Oi << 12, zi = zi + Yi | 0, Li ^= zi, Li = Li >>> 16 | Li << 16, Mi = Mi + Li | 0, Yi ^= Mi, Yi = Yi >>> 20 | Yi << 12, Xi = Xi + ns | 0, qi ^= Xi, qi = qi >>> 16 | qi << 16, Ai = Ai + qi | 0, ns ^= Ai, ns = ns >>> 20 | ns << 12, Qi = Qi + ls | 0, Ni ^= Qi, Ni = Ni >>> 16 | Ni << 16, wi = wi + Ni | 0, ls ^= wi, ls = ls >>> 20 | ls << 12, Xi = Xi + ns | 0, qi ^= Xi, qi = qi >>> 24 | qi << 8, Ai = Ai + qi | 0, ns ^= Ai, ns = ns >>> 25 | ns << 7, Qi = Qi + ls | 0, Ni ^= Qi, Ni = Ni >>> 24 | Ni << 8, wi = wi + Ni | 0, ls ^= wi, ls = ls >>> 25 | ls << 7, zi = zi + Yi | 0, Li ^= zi, Li = Li >>> 24 | Li << 8, Mi = Mi + Li | 0, Yi ^= Mi, Yi = Yi >>> 25 | Yi << 7, Wi = Wi + Oi | 0, $i ^= Wi, $i = $i >>> 24 | $i << 8, vn = vn + $i | 0, Oi ^= vn, Oi = Oi >>> 25 | Oi << 7, Wi = Wi + Yi | 0, Ni ^= Wi, Ni = Ni >>> 16 | Ni << 16, Ai = Ai + Ni | 0, Yi ^= Ai, Yi = Yi >>> 20 | Yi << 12, zi = zi + ns | 0, $i ^= zi, $i = $i >>> 16 | $i << 16, wi = wi + $i | 0, ns ^= wi, ns = ns >>> 20 | ns << 12, Xi = Xi + ls | 0, Li ^= Xi, Li = Li >>> 16 | Li << 16, vn = vn + Li | 0, ls ^= vn, ls = ls >>> 20 | ls << 12, Qi = Qi + Oi | 0, qi ^= Qi, qi = qi >>> 16 | qi << 16, Mi = Mi + qi | 0, Oi ^= Mi, Oi = Oi >>> 20 | Oi << 12, Xi = Xi + ls | 0, Li ^= Xi, Li = Li >>> 24 | Li << 8, vn = vn + Li | 0, ls ^= vn, ls = ls >>> 25 | ls << 7, Qi = Qi + Oi | 0, qi ^= Qi, qi = qi >>> 24 | qi << 8, Mi = Mi + qi | 0, Oi ^= Mi, Oi = Oi >>> 25 | Oi << 7, zi = zi + ns | 0, $i ^= zi, $i = $i >>> 24 | $i << 8, wi = wi + $i | 0, ns ^= wi, ns = ns >>> 25 | ns << 7, Wi = Wi + Yi | 0, Ni ^= Wi, Ni = Ni >>> 24 | Ni << 8, Ai = Ai + Ni | 0, Yi ^= Ai, Yi = Yi >>> 25 | Yi << 7;
  binary_1.writeUint32LE(Wi + Me | 0, Ae, 0), binary_1.writeUint32LE(zi + Be | 0, Ae, 4), binary_1.writeUint32LE(Xi + Pe | 0, Ae, 8), binary_1.writeUint32LE(Qi + Te | 0, Ae, 12), binary_1.writeUint32LE(Oi + je | 0, Ae, 16), binary_1.writeUint32LE(Yi + Ve | 0, Ae, 20), binary_1.writeUint32LE(ns + fi | 0, Ae, 24), binary_1.writeUint32LE(ls + Ue | 0, Ae, 28), binary_1.writeUint32LE(vn + bi | 0, Ae, 32), binary_1.writeUint32LE(Mi + vi | 0, Ae, 36), binary_1.writeUint32LE(Ai + mi | 0, Ae, 40), binary_1.writeUint32LE(wi + _i | 0, Ae, 44), binary_1.writeUint32LE($i + Ei | 0, Ae, 48), binary_1.writeUint32LE(Li + Pi | 0, Ae, 52), binary_1.writeUint32LE(qi + Ii | 0, Ae, 56), binary_1.writeUint32LE(Ni + Ci | 0, Ae, 60);
}
function streamXOR(Ae, t, Ie, Me, Be) {
  if (Be === void 0 && (Be = 0), Ae.length !== 32)
    throw new Error("ChaCha: key size must be 32 bytes");
  if (Me.length < Ie.length)
    throw new Error("ChaCha: destination is shorter than source");
  var Pe, Te;
  if (Be === 0) {
    if (t.length !== 8 && t.length !== 12)
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    Pe = new Uint8Array(16), Te = Pe.length - t.length, Pe.set(t, Te);
  } else {
    if (t.length !== 16)
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    Pe = t, Te = Be;
  }
  for (var je = new Uint8Array(64), Ve = 0; Ve < Ie.length; Ve += 64) {
    core(je, Pe, Ae);
    for (var fi = Ve; fi < Ve + 64 && fi < Ie.length; fi++)
      Me[fi] = Ie[fi] ^ je[fi - Ve];
    incrementCounter(Pe, 0, Te);
  }
  return wipe_1$2.wipe(je), Be === 0 && wipe_1$2.wipe(Pe), Me;
}
chacha.streamXOR = streamXOR;
function stream(Ae, t, Ie, Me) {
  return Me === void 0 && (Me = 0), wipe_1$2.wipe(Ie), streamXOR(Ae, t, Ie, Ie, Me);
}
chacha.stream = stream;
function incrementCounter(Ae, t, Ie) {
  for (var Me = 1; Ie--; )
    Me = Me + (Ae[t] & 255) | 0, Ae[t] = Me & 255, Me >>>= 8, t++;
  if (Me > 0)
    throw new Error("ChaCha: counter overflow");
}
var poly1305 = {}, constantTime = {};
Object.defineProperty(constantTime, "__esModule", { value: !0 });
function select(Ae, t, Ie) {
  return ~(Ae - 1) & t | Ae - 1 & Ie;
}
constantTime.select = select;
function lessOrEqual(Ae, t) {
  return (Ae | 0) - (t | 0) - 1 >>> 31 & 1;
}
constantTime.lessOrEqual = lessOrEqual;
function compare(Ae, t) {
  if (Ae.length !== t.length)
    return 0;
  for (var Ie = 0, Me = 0; Me < Ae.length; Me++)
    Ie |= Ae[Me] ^ t[Me];
  return 1 & Ie - 1 >>> 8;
}
constantTime.compare = compare;
function equal(Ae, t) {
  return Ae.length === 0 || t.length === 0 ? !1 : compare(Ae, t) !== 0;
}
constantTime.equal = equal;
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  var t = constantTime, Ie = wipe$1;
  Ae.DIGEST_LENGTH = 16;
  var Me = (
    /** @class */
    function() {
      function Te(je) {
        this.digestLength = Ae.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
        var Ve = je[0] | je[1] << 8;
        this._r[0] = Ve & 8191;
        var fi = je[2] | je[3] << 8;
        this._r[1] = (Ve >>> 13 | fi << 3) & 8191;
        var Ue = je[4] | je[5] << 8;
        this._r[2] = (fi >>> 10 | Ue << 6) & 7939;
        var bi = je[6] | je[7] << 8;
        this._r[3] = (Ue >>> 7 | bi << 9) & 8191;
        var vi = je[8] | je[9] << 8;
        this._r[4] = (bi >>> 4 | vi << 12) & 255, this._r[5] = vi >>> 1 & 8190;
        var mi = je[10] | je[11] << 8;
        this._r[6] = (vi >>> 14 | mi << 2) & 8191;
        var _i = je[12] | je[13] << 8;
        this._r[7] = (mi >>> 11 | _i << 5) & 8065;
        var Ei = je[14] | je[15] << 8;
        this._r[8] = (_i >>> 8 | Ei << 8) & 8191, this._r[9] = Ei >>> 5 & 127, this._pad[0] = je[16] | je[17] << 8, this._pad[1] = je[18] | je[19] << 8, this._pad[2] = je[20] | je[21] << 8, this._pad[3] = je[22] | je[23] << 8, this._pad[4] = je[24] | je[25] << 8, this._pad[5] = je[26] | je[27] << 8, this._pad[6] = je[28] | je[29] << 8, this._pad[7] = je[30] | je[31] << 8;
      }
      return Te.prototype._blocks = function(je, Ve, fi) {
        for (var Ue = this._fin ? 0 : 2048, bi = this._h[0], vi = this._h[1], mi = this._h[2], _i = this._h[3], Ei = this._h[4], Pi = this._h[5], Ii = this._h[6], Ci = this._h[7], Wi = this._h[8], zi = this._h[9], Xi = this._r[0], Qi = this._r[1], Oi = this._r[2], Yi = this._r[3], ns = this._r[4], ls = this._r[5], vn = this._r[6], Mi = this._r[7], Ai = this._r[8], wi = this._r[9]; fi >= 16; ) {
          var $i = je[Ve + 0] | je[Ve + 1] << 8;
          bi += $i & 8191;
          var Li = je[Ve + 2] | je[Ve + 3] << 8;
          vi += ($i >>> 13 | Li << 3) & 8191;
          var qi = je[Ve + 4] | je[Ve + 5] << 8;
          mi += (Li >>> 10 | qi << 6) & 8191;
          var Ni = je[Ve + 6] | je[Ve + 7] << 8;
          _i += (qi >>> 7 | Ni << 9) & 8191;
          var Ti = je[Ve + 8] | je[Ve + 9] << 8;
          Ei += (Ni >>> 4 | Ti << 12) & 8191, Pi += Ti >>> 1 & 8191;
          var xi = je[Ve + 10] | je[Ve + 11] << 8;
          Ii += (Ti >>> 14 | xi << 2) & 8191;
          var Fi = je[Ve + 12] | je[Ve + 13] << 8;
          Ci += (xi >>> 11 | Fi << 5) & 8191;
          var Si = je[Ve + 14] | je[Ve + 15] << 8;
          Wi += (Fi >>> 8 | Si << 8) & 8191, zi += Si >>> 5 | Ue;
          var Vi = 0, ts = Vi;
          ts += bi * Xi, ts += vi * (5 * wi), ts += mi * (5 * Ai), ts += _i * (5 * Mi), ts += Ei * (5 * vn), Vi = ts >>> 13, ts &= 8191, ts += Pi * (5 * ls), ts += Ii * (5 * ns), ts += Ci * (5 * Yi), ts += Wi * (5 * Oi), ts += zi * (5 * Qi), Vi += ts >>> 13, ts &= 8191;
          var Hi = Vi;
          Hi += bi * Qi, Hi += vi * Xi, Hi += mi * (5 * wi), Hi += _i * (5 * Ai), Hi += Ei * (5 * Mi), Vi = Hi >>> 13, Hi &= 8191, Hi += Pi * (5 * vn), Hi += Ii * (5 * ls), Hi += Ci * (5 * ns), Hi += Wi * (5 * Yi), Hi += zi * (5 * Oi), Vi += Hi >>> 13, Hi &= 8191;
          var fn = Vi;
          fn += bi * Oi, fn += vi * Qi, fn += mi * Xi, fn += _i * (5 * wi), fn += Ei * (5 * Ai), Vi = fn >>> 13, fn &= 8191, fn += Pi * (5 * Mi), fn += Ii * (5 * vn), fn += Ci * (5 * ls), fn += Wi * (5 * ns), fn += zi * (5 * Yi), Vi += fn >>> 13, fn &= 8191;
          var Bi = Vi;
          Bi += bi * Yi, Bi += vi * Oi, Bi += mi * Qi, Bi += _i * Xi, Bi += Ei * (5 * wi), Vi = Bi >>> 13, Bi &= 8191, Bi += Pi * (5 * Ai), Bi += Ii * (5 * Mi), Bi += Ci * (5 * vn), Bi += Wi * (5 * ls), Bi += zi * (5 * ns), Vi += Bi >>> 13, Bi &= 8191;
          var ki = Vi;
          ki += bi * ns, ki += vi * Yi, ki += mi * Oi, ki += _i * Qi, ki += Ei * Xi, Vi = ki >>> 13, ki &= 8191, ki += Pi * (5 * wi), ki += Ii * (5 * Ai), ki += Ci * (5 * Mi), ki += Wi * (5 * vn), ki += zi * (5 * ls), Vi += ki >>> 13, ki &= 8191;
          var Ji = Vi;
          Ji += bi * ls, Ji += vi * ns, Ji += mi * Yi, Ji += _i * Oi, Ji += Ei * Qi, Vi = Ji >>> 13, Ji &= 8191, Ji += Pi * Xi, Ji += Ii * (5 * wi), Ji += Ci * (5 * Ai), Ji += Wi * (5 * Mi), Ji += zi * (5 * vn), Vi += Ji >>> 13, Ji &= 8191;
          var Ri = Vi;
          Ri += bi * vn, Ri += vi * ls, Ri += mi * ns, Ri += _i * Yi, Ri += Ei * Oi, Vi = Ri >>> 13, Ri &= 8191, Ri += Pi * Qi, Ri += Ii * Xi, Ri += Ci * (5 * wi), Ri += Wi * (5 * Ai), Ri += zi * (5 * Mi), Vi += Ri >>> 13, Ri &= 8191;
          var ji = Vi;
          ji += bi * Mi, ji += vi * vn, ji += mi * ls, ji += _i * ns, ji += Ei * Yi, Vi = ji >>> 13, ji &= 8191, ji += Pi * Oi, ji += Ii * Qi, ji += Ci * Xi, ji += Wi * (5 * wi), ji += zi * (5 * Ai), Vi += ji >>> 13, ji &= 8191;
          var Gi = Vi;
          Gi += bi * Ai, Gi += vi * Mi, Gi += mi * vn, Gi += _i * ls, Gi += Ei * ns, Vi = Gi >>> 13, Gi &= 8191, Gi += Pi * Yi, Gi += Ii * Oi, Gi += Ci * Qi, Gi += Wi * Xi, Gi += zi * (5 * wi), Vi += Gi >>> 13, Gi &= 8191;
          var is = Vi;
          is += bi * wi, is += vi * Ai, is += mi * Mi, is += _i * vn, is += Ei * ls, Vi = is >>> 13, is &= 8191, is += Pi * ns, is += Ii * Yi, is += Ci * Oi, is += Wi * Qi, is += zi * Xi, Vi += is >>> 13, is &= 8191, Vi = (Vi << 2) + Vi | 0, Vi = Vi + ts | 0, ts = Vi & 8191, Vi = Vi >>> 13, Hi += Vi, bi = ts, vi = Hi, mi = fn, _i = Bi, Ei = ki, Pi = Ji, Ii = Ri, Ci = ji, Wi = Gi, zi = is, Ve += 16, fi -= 16;
        }
        this._h[0] = bi, this._h[1] = vi, this._h[2] = mi, this._h[3] = _i, this._h[4] = Ei, this._h[5] = Pi, this._h[6] = Ii, this._h[7] = Ci, this._h[8] = Wi, this._h[9] = zi;
      }, Te.prototype.finish = function(je, Ve) {
        Ve === void 0 && (Ve = 0);
        var fi = new Uint16Array(10), Ue, bi, vi, mi;
        if (this._leftover) {
          for (mi = this._leftover, this._buffer[mi++] = 1; mi < 16; mi++)
            this._buffer[mi] = 0;
          this._fin = 1, this._blocks(this._buffer, 0, 16);
        }
        for (Ue = this._h[1] >>> 13, this._h[1] &= 8191, mi = 2; mi < 10; mi++)
          this._h[mi] += Ue, Ue = this._h[mi] >>> 13, this._h[mi] &= 8191;
        for (this._h[0] += Ue * 5, Ue = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += Ue, Ue = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += Ue, fi[0] = this._h[0] + 5, Ue = fi[0] >>> 13, fi[0] &= 8191, mi = 1; mi < 10; mi++)
          fi[mi] = this._h[mi] + Ue, Ue = fi[mi] >>> 13, fi[mi] &= 8191;
        for (fi[9] -= 8192, bi = (Ue ^ 1) - 1, mi = 0; mi < 10; mi++)
          fi[mi] &= bi;
        for (bi = ~bi, mi = 0; mi < 10; mi++)
          this._h[mi] = this._h[mi] & bi | fi[mi];
        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, vi = this._h[0] + this._pad[0], this._h[0] = vi & 65535, mi = 1; mi < 8; mi++)
          vi = (this._h[mi] + this._pad[mi] | 0) + (vi >>> 16) | 0, this._h[mi] = vi & 65535;
        return je[Ve + 0] = this._h[0] >>> 0, je[Ve + 1] = this._h[0] >>> 8, je[Ve + 2] = this._h[1] >>> 0, je[Ve + 3] = this._h[1] >>> 8, je[Ve + 4] = this._h[2] >>> 0, je[Ve + 5] = this._h[2] >>> 8, je[Ve + 6] = this._h[3] >>> 0, je[Ve + 7] = this._h[3] >>> 8, je[Ve + 8] = this._h[4] >>> 0, je[Ve + 9] = this._h[4] >>> 8, je[Ve + 10] = this._h[5] >>> 0, je[Ve + 11] = this._h[5] >>> 8, je[Ve + 12] = this._h[6] >>> 0, je[Ve + 13] = this._h[6] >>> 8, je[Ve + 14] = this._h[7] >>> 0, je[Ve + 15] = this._h[7] >>> 8, this._finished = !0, this;
      }, Te.prototype.update = function(je) {
        var Ve = 0, fi = je.length, Ue;
        if (this._leftover) {
          Ue = 16 - this._leftover, Ue > fi && (Ue = fi);
          for (var bi = 0; bi < Ue; bi++)
            this._buffer[this._leftover + bi] = je[Ve + bi];
          if (fi -= Ue, Ve += Ue, this._leftover += Ue, this._leftover < 16)
            return this;
          this._blocks(this._buffer, 0, 16), this._leftover = 0;
        }
        if (fi >= 16 && (Ue = fi - fi % 16, this._blocks(je, Ve, Ue), Ve += Ue, fi -= Ue), fi) {
          for (var bi = 0; bi < fi; bi++)
            this._buffer[this._leftover + bi] = je[Ve + bi];
          this._leftover += fi;
        }
        return this;
      }, Te.prototype.digest = function() {
        if (this._finished)
          throw new Error("Poly1305 was finished");
        var je = new Uint8Array(16);
        return this.finish(je), je;
      }, Te.prototype.clean = function() {
        return Ie.wipe(this._buffer), Ie.wipe(this._r), Ie.wipe(this._h), Ie.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;
      }, Te;
    }()
  );
  Ae.Poly1305 = Me;
  function Be(Te, je) {
    var Ve = new Me(Te);
    Ve.update(je);
    var fi = Ve.digest();
    return Ve.clean(), fi;
  }
  Ae.oneTimeAuth = Be;
  function Pe(Te, je) {
    return Te.length !== Ae.DIGEST_LENGTH || je.length !== Ae.DIGEST_LENGTH ? !1 : t.equal(Te, je);
  }
  Ae.equal = Pe;
})(poly1305);
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  var t = chacha, Ie = poly1305, Me = wipe$1, Be = binary, Pe = constantTime;
  Ae.KEY_LENGTH = 32, Ae.NONCE_LENGTH = 12, Ae.TAG_LENGTH = 16;
  var Te = new Uint8Array(16), je = (
    /** @class */
    function() {
      function Ve(fi) {
        if (this.nonceLength = Ae.NONCE_LENGTH, this.tagLength = Ae.TAG_LENGTH, fi.length !== Ae.KEY_LENGTH)
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(fi);
      }
      return Ve.prototype.seal = function(fi, Ue, bi, vi) {
        if (fi.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        var mi = new Uint8Array(16);
        mi.set(fi, mi.length - fi.length);
        var _i = new Uint8Array(32);
        t.stream(this._key, mi, _i, 4);
        var Ei = Ue.length + this.tagLength, Pi;
        if (vi) {
          if (vi.length !== Ei)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          Pi = vi;
        } else
          Pi = new Uint8Array(Ei);
        return t.streamXOR(this._key, mi, Ue, Pi, 4), this._authenticate(Pi.subarray(Pi.length - this.tagLength, Pi.length), _i, Pi.subarray(0, Pi.length - this.tagLength), bi), Me.wipe(mi), Pi;
      }, Ve.prototype.open = function(fi, Ue, bi, vi) {
        if (fi.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        if (Ue.length < this.tagLength)
          return null;
        var mi = new Uint8Array(16);
        mi.set(fi, mi.length - fi.length);
        var _i = new Uint8Array(32);
        t.stream(this._key, mi, _i, 4);
        var Ei = new Uint8Array(this.tagLength);
        if (this._authenticate(Ei, _i, Ue.subarray(0, Ue.length - this.tagLength), bi), !Pe.equal(Ei, Ue.subarray(Ue.length - this.tagLength, Ue.length)))
          return null;
        var Pi = Ue.length - this.tagLength, Ii;
        if (vi) {
          if (vi.length !== Pi)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          Ii = vi;
        } else
          Ii = new Uint8Array(Pi);
        return t.streamXOR(this._key, mi, Ue.subarray(0, Ue.length - this.tagLength), Ii, 4), Me.wipe(mi), Ii;
      }, Ve.prototype.clean = function() {
        return Me.wipe(this._key), this;
      }, Ve.prototype._authenticate = function(fi, Ue, bi, vi) {
        var mi = new Ie.Poly1305(Ue);
        vi && (mi.update(vi), vi.length % 16 > 0 && mi.update(Te.subarray(vi.length % 16))), mi.update(bi), bi.length % 16 > 0 && mi.update(Te.subarray(bi.length % 16));
        var _i = new Uint8Array(8);
        vi && Be.writeUint64LE(vi.length, _i), mi.update(_i), Be.writeUint64LE(bi.length, _i), mi.update(_i);
        for (var Ei = mi.digest(), Pi = 0; Pi < Ei.length; Pi++)
          fi[Pi] = Ei[Pi];
        mi.clean(), Me.wipe(Ei), Me.wipe(_i);
      }, Ve;
    }()
  );
  Ae.ChaCha20Poly1305 = je;
})(chacha20poly1305);
var hkdf = {}, hmac$1 = {}, hash = {};
Object.defineProperty(hash, "__esModule", { value: !0 });
function isSerializableHash(Ae) {
  return typeof Ae.saveState < "u" && typeof Ae.restoreState < "u" && typeof Ae.cleanSavedState < "u";
}
hash.isSerializableHash = isSerializableHash;
Object.defineProperty(hmac$1, "__esModule", { value: !0 });
var hash_1 = hash, constant_time_1 = constantTime, wipe_1$1 = wipe$1, HMAC = (
  /** @class */
  function() {
    function Ae(t, Ie) {
      this._finished = !1, this._inner = new t(), this._outer = new t(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
      var Me = new Uint8Array(this.blockSize);
      Ie.length > this.blockSize ? this._inner.update(Ie).finish(Me).clean() : Me.set(Ie);
      for (var Be = 0; Be < Me.length; Be++)
        Me[Be] ^= 54;
      this._inner.update(Me);
      for (var Be = 0; Be < Me.length; Be++)
        Me[Be] ^= 106;
      this._outer.update(Me), hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), wipe_1$1.wipe(Me);
    }
    return Ae.prototype.reset = function() {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer))
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, Ae.prototype.clean = function() {
      hash_1.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), hash_1.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();
    }, Ae.prototype.update = function(t) {
      return this._inner.update(t), this;
    }, Ae.prototype.finish = function(t) {
      return this._finished ? (this._outer.finish(t), this) : (this._inner.finish(t), this._outer.update(t.subarray(0, this.digestLength)).finish(t), this._finished = !0, this);
    }, Ae.prototype.digest = function() {
      var t = new Uint8Array(this.digestLength);
      return this.finish(t), t;
    }, Ae.prototype.saveState = function() {
      if (!hash_1.isSerializableHash(this._inner))
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      return this._inner.saveState();
    }, Ae.prototype.restoreState = function(t) {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer))
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      return this._inner.restoreState(t), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, Ae.prototype.cleanSavedState = function(t) {
      if (!hash_1.isSerializableHash(this._inner))
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      this._inner.cleanSavedState(t);
    }, Ae;
  }()
);
hmac$1.HMAC = HMAC;
function hmac(Ae, t, Ie) {
  var Me = new HMAC(Ae, t);
  Me.update(Ie);
  var Be = Me.digest();
  return Me.clean(), Be;
}
hmac$1.hmac = hmac;
hmac$1.equal = constant_time_1.equal;
Object.defineProperty(hkdf, "__esModule", { value: !0 });
var hmac_1 = hmac$1, wipe_1 = wipe$1, HKDF = (
  /** @class */
  function() {
    function Ae(t, Ie, Me, Be) {
      Me === void 0 && (Me = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = t, this._info = Be;
      var Pe = hmac_1.hmac(this._hash, Me, Ie);
      this._hmac = new hmac_1.HMAC(t, Pe), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;
    }
    return Ae.prototype._fillBuffer = function() {
      this._counter[0]++;
      var t = this._counter[0];
      if (t === 0)
        throw new Error("hkdf: cannot expand more");
      this._hmac.reset(), t > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;
    }, Ae.prototype.expand = function(t) {
      for (var Ie = new Uint8Array(t), Me = 0; Me < Ie.length; Me++)
        this._bufpos === this._buffer.length && this._fillBuffer(), Ie[Me] = this._buffer[this._bufpos++];
      return Ie;
    }, Ae.prototype.clean = function() {
      this._hmac.clean(), wipe_1.wipe(this._buffer), wipe_1.wipe(this._counter), this._bufpos = 0;
    }, Ae;
  }()
), HKDF_1 = hkdf.HKDF = HKDF, sha256 = {};
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  var t = binary, Ie = wipe$1;
  Ae.DIGEST_LENGTH = 32, Ae.BLOCK_SIZE = 64;
  var Me = (
    /** @class */
    function() {
      function je() {
        this.digestLength = Ae.DIGEST_LENGTH, this.blockSize = Ae.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return je.prototype._initState = function() {
        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
      }, je.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, je.prototype.clean = function() {
        Ie.wipe(this._buffer), Ie.wipe(this._temp), this.reset();
      }, je.prototype.update = function(Ve, fi) {
        if (fi === void 0 && (fi = Ve.length), this._finished)
          throw new Error("SHA256: can't update because hash was finished.");
        var Ue = 0;
        if (this._bytesHashed += fi, this._bufferLength > 0) {
          for (; this._bufferLength < this.blockSize && fi > 0; )
            this._buffer[this._bufferLength++] = Ve[Ue++], fi--;
          this._bufferLength === this.blockSize && (Pe(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (fi >= this.blockSize && (Ue = Pe(this._temp, this._state, Ve, Ue, fi), fi %= this.blockSize); fi > 0; )
          this._buffer[this._bufferLength++] = Ve[Ue++], fi--;
        return this;
      }, je.prototype.finish = function(Ve) {
        if (!this._finished) {
          var fi = this._bytesHashed, Ue = this._bufferLength, bi = fi / 536870912 | 0, vi = fi << 3, mi = fi % 64 < 56 ? 64 : 128;
          this._buffer[Ue] = 128;
          for (var _i = Ue + 1; _i < mi - 8; _i++)
            this._buffer[_i] = 0;
          t.writeUint32BE(bi, this._buffer, mi - 8), t.writeUint32BE(vi, this._buffer, mi - 4), Pe(this._temp, this._state, this._buffer, 0, mi), this._finished = !0;
        }
        for (var _i = 0; _i < this.digestLength / 4; _i++)
          t.writeUint32BE(this._state[_i], Ve, _i * 4);
        return this;
      }, je.prototype.digest = function() {
        var Ve = new Uint8Array(this.digestLength);
        return this.finish(Ve), Ve;
      }, je.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, je.prototype.restoreState = function(Ve) {
        return this._state.set(Ve.state), this._bufferLength = Ve.bufferLength, Ve.buffer && this._buffer.set(Ve.buffer), this._bytesHashed = Ve.bytesHashed, this._finished = !1, this;
      }, je.prototype.cleanSavedState = function(Ve) {
        Ie.wipe(Ve.state), Ve.buffer && Ie.wipe(Ve.buffer), Ve.bufferLength = 0, Ve.bytesHashed = 0;
      }, je;
    }()
  );
  Ae.SHA256 = Me;
  var Be = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function Pe(je, Ve, fi, Ue, bi) {
    for (; bi >= 64; ) {
      for (var vi = Ve[0], mi = Ve[1], _i = Ve[2], Ei = Ve[3], Pi = Ve[4], Ii = Ve[5], Ci = Ve[6], Wi = Ve[7], zi = 0; zi < 16; zi++) {
        var Xi = Ue + zi * 4;
        je[zi] = t.readUint32BE(fi, Xi);
      }
      for (var zi = 16; zi < 64; zi++) {
        var Qi = je[zi - 2], Oi = (Qi >>> 17 | Qi << 15) ^ (Qi >>> 19 | Qi << 13) ^ Qi >>> 10;
        Qi = je[zi - 15];
        var Yi = (Qi >>> 7 | Qi << 25) ^ (Qi >>> 18 | Qi << 14) ^ Qi >>> 3;
        je[zi] = (Oi + je[zi - 7] | 0) + (Yi + je[zi - 16] | 0);
      }
      for (var zi = 0; zi < 64; zi++) {
        var Oi = (((Pi >>> 6 | Pi << 26) ^ (Pi >>> 11 | Pi << 21) ^ (Pi >>> 25 | Pi << 7)) + (Pi & Ii ^ ~Pi & Ci) | 0) + (Wi + (Be[zi] + je[zi] | 0) | 0) | 0, Yi = ((vi >>> 2 | vi << 30) ^ (vi >>> 13 | vi << 19) ^ (vi >>> 22 | vi << 10)) + (vi & mi ^ vi & _i ^ mi & _i) | 0;
        Wi = Ci, Ci = Ii, Ii = Pi, Pi = Ei + Oi | 0, Ei = _i, _i = mi, mi = vi, vi = Oi + Yi | 0;
      }
      Ve[0] += vi, Ve[1] += mi, Ve[2] += _i, Ve[3] += Ei, Ve[4] += Pi, Ve[5] += Ii, Ve[6] += Ci, Ve[7] += Wi, Ue += 64, bi -= 64;
    }
    return Ue;
  }
  function Te(je) {
    var Ve = new Me();
    Ve.update(je);
    var fi = Ve.digest();
    return Ve.clean(), fi;
  }
  Ae.hash = Te;
})(sha256);
var x25519 = {};
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 }), Ae.sharedKey = Ae.generateKeyPair = Ae.generateKeyPairFromSeed = Ae.scalarMultBase = Ae.scalarMult = Ae.SHARED_KEY_LENGTH = Ae.SECRET_KEY_LENGTH = Ae.PUBLIC_KEY_LENGTH = void 0;
  const t = random, Ie = wipe$1;
  Ae.PUBLIC_KEY_LENGTH = 32, Ae.SECRET_KEY_LENGTH = 32, Ae.SHARED_KEY_LENGTH = 32;
  function Me(zi) {
    const Xi = new Float64Array(16);
    if (zi)
      for (let Qi = 0; Qi < zi.length; Qi++)
        Xi[Qi] = zi[Qi];
    return Xi;
  }
  const Be = new Uint8Array(32);
  Be[0] = 9;
  const Pe = Me([56129, 1]);
  function Te(zi) {
    let Xi = 1;
    for (let Qi = 0; Qi < 16; Qi++) {
      let Oi = zi[Qi] + Xi + 65535;
      Xi = Math.floor(Oi / 65536), zi[Qi] = Oi - Xi * 65536;
    }
    zi[0] += Xi - 1 + 37 * (Xi - 1);
  }
  function je(zi, Xi, Qi) {
    const Oi = ~(Qi - 1);
    for (let Yi = 0; Yi < 16; Yi++) {
      const ns = Oi & (zi[Yi] ^ Xi[Yi]);
      zi[Yi] ^= ns, Xi[Yi] ^= ns;
    }
  }
  function Ve(zi, Xi) {
    const Qi = Me(), Oi = Me();
    for (let Yi = 0; Yi < 16; Yi++)
      Oi[Yi] = Xi[Yi];
    Te(Oi), Te(Oi), Te(Oi);
    for (let Yi = 0; Yi < 2; Yi++) {
      Qi[0] = Oi[0] - 65517;
      for (let ls = 1; ls < 15; ls++)
        Qi[ls] = Oi[ls] - 65535 - (Qi[ls - 1] >> 16 & 1), Qi[ls - 1] &= 65535;
      Qi[15] = Oi[15] - 32767 - (Qi[14] >> 16 & 1);
      const ns = Qi[15] >> 16 & 1;
      Qi[14] &= 65535, je(Oi, Qi, 1 - ns);
    }
    for (let Yi = 0; Yi < 16; Yi++)
      zi[2 * Yi] = Oi[Yi] & 255, zi[2 * Yi + 1] = Oi[Yi] >> 8;
  }
  function fi(zi, Xi) {
    for (let Qi = 0; Qi < 16; Qi++)
      zi[Qi] = Xi[2 * Qi] + (Xi[2 * Qi + 1] << 8);
    zi[15] &= 32767;
  }
  function Ue(zi, Xi, Qi) {
    for (let Oi = 0; Oi < 16; Oi++)
      zi[Oi] = Xi[Oi] + Qi[Oi];
  }
  function bi(zi, Xi, Qi) {
    for (let Oi = 0; Oi < 16; Oi++)
      zi[Oi] = Xi[Oi] - Qi[Oi];
  }
  function vi(zi, Xi, Qi) {
    let Oi, Yi, ns = 0, ls = 0, vn = 0, Mi = 0, Ai = 0, wi = 0, $i = 0, Li = 0, qi = 0, Ni = 0, Ti = 0, xi = 0, Fi = 0, Si = 0, Vi = 0, ts = 0, Hi = 0, fn = 0, Bi = 0, ki = 0, Ji = 0, Ri = 0, ji = 0, Gi = 0, is = 0, os = 0, ds = 0, ps = 0, ea = 0, ia = 0, hs = 0, fa = Qi[0], gs = Qi[1], sa = Qi[2], aa = Qi[3], Ds = Qi[4], ra = Qi[5], ca = Qi[6], ta = Qi[7], oa = Qi[8], da = Qi[9], Zi = Qi[10], Ui = Qi[11], Ki = Qi[12], En = Qi[13], ss = Qi[14], as = Qi[15];
    Oi = Xi[0], ns += Oi * fa, ls += Oi * gs, vn += Oi * sa, Mi += Oi * aa, Ai += Oi * Ds, wi += Oi * ra, $i += Oi * ca, Li += Oi * ta, qi += Oi * oa, Ni += Oi * da, Ti += Oi * Zi, xi += Oi * Ui, Fi += Oi * Ki, Si += Oi * En, Vi += Oi * ss, ts += Oi * as, Oi = Xi[1], ls += Oi * fa, vn += Oi * gs, Mi += Oi * sa, Ai += Oi * aa, wi += Oi * Ds, $i += Oi * ra, Li += Oi * ca, qi += Oi * ta, Ni += Oi * oa, Ti += Oi * da, xi += Oi * Zi, Fi += Oi * Ui, Si += Oi * Ki, Vi += Oi * En, ts += Oi * ss, Hi += Oi * as, Oi = Xi[2], vn += Oi * fa, Mi += Oi * gs, Ai += Oi * sa, wi += Oi * aa, $i += Oi * Ds, Li += Oi * ra, qi += Oi * ca, Ni += Oi * ta, Ti += Oi * oa, xi += Oi * da, Fi += Oi * Zi, Si += Oi * Ui, Vi += Oi * Ki, ts += Oi * En, Hi += Oi * ss, fn += Oi * as, Oi = Xi[3], Mi += Oi * fa, Ai += Oi * gs, wi += Oi * sa, $i += Oi * aa, Li += Oi * Ds, qi += Oi * ra, Ni += Oi * ca, Ti += Oi * ta, xi += Oi * oa, Fi += Oi * da, Si += Oi * Zi, Vi += Oi * Ui, ts += Oi * Ki, Hi += Oi * En, fn += Oi * ss, Bi += Oi * as, Oi = Xi[4], Ai += Oi * fa, wi += Oi * gs, $i += Oi * sa, Li += Oi * aa, qi += Oi * Ds, Ni += Oi * ra, Ti += Oi * ca, xi += Oi * ta, Fi += Oi * oa, Si += Oi * da, Vi += Oi * Zi, ts += Oi * Ui, Hi += Oi * Ki, fn += Oi * En, Bi += Oi * ss, ki += Oi * as, Oi = Xi[5], wi += Oi * fa, $i += Oi * gs, Li += Oi * sa, qi += Oi * aa, Ni += Oi * Ds, Ti += Oi * ra, xi += Oi * ca, Fi += Oi * ta, Si += Oi * oa, Vi += Oi * da, ts += Oi * Zi, Hi += Oi * Ui, fn += Oi * Ki, Bi += Oi * En, ki += Oi * ss, Ji += Oi * as, Oi = Xi[6], $i += Oi * fa, Li += Oi * gs, qi += Oi * sa, Ni += Oi * aa, Ti += Oi * Ds, xi += Oi * ra, Fi += Oi * ca, Si += Oi * ta, Vi += Oi * oa, ts += Oi * da, Hi += Oi * Zi, fn += Oi * Ui, Bi += Oi * Ki, ki += Oi * En, Ji += Oi * ss, Ri += Oi * as, Oi = Xi[7], Li += Oi * fa, qi += Oi * gs, Ni += Oi * sa, Ti += Oi * aa, xi += Oi * Ds, Fi += Oi * ra, Si += Oi * ca, Vi += Oi * ta, ts += Oi * oa, Hi += Oi * da, fn += Oi * Zi, Bi += Oi * Ui, ki += Oi * Ki, Ji += Oi * En, Ri += Oi * ss, ji += Oi * as, Oi = Xi[8], qi += Oi * fa, Ni += Oi * gs, Ti += Oi * sa, xi += Oi * aa, Fi += Oi * Ds, Si += Oi * ra, Vi += Oi * ca, ts += Oi * ta, Hi += Oi * oa, fn += Oi * da, Bi += Oi * Zi, ki += Oi * Ui, Ji += Oi * Ki, Ri += Oi * En, ji += Oi * ss, Gi += Oi * as, Oi = Xi[9], Ni += Oi * fa, Ti += Oi * gs, xi += Oi * sa, Fi += Oi * aa, Si += Oi * Ds, Vi += Oi * ra, ts += Oi * ca, Hi += Oi * ta, fn += Oi * oa, Bi += Oi * da, ki += Oi * Zi, Ji += Oi * Ui, Ri += Oi * Ki, ji += Oi * En, Gi += Oi * ss, is += Oi * as, Oi = Xi[10], Ti += Oi * fa, xi += Oi * gs, Fi += Oi * sa, Si += Oi * aa, Vi += Oi * Ds, ts += Oi * ra, Hi += Oi * ca, fn += Oi * ta, Bi += Oi * oa, ki += Oi * da, Ji += Oi * Zi, Ri += Oi * Ui, ji += Oi * Ki, Gi += Oi * En, is += Oi * ss, os += Oi * as, Oi = Xi[11], xi += Oi * fa, Fi += Oi * gs, Si += Oi * sa, Vi += Oi * aa, ts += Oi * Ds, Hi += Oi * ra, fn += Oi * ca, Bi += Oi * ta, ki += Oi * oa, Ji += Oi * da, Ri += Oi * Zi, ji += Oi * Ui, Gi += Oi * Ki, is += Oi * En, os += Oi * ss, ds += Oi * as, Oi = Xi[12], Fi += Oi * fa, Si += Oi * gs, Vi += Oi * sa, ts += Oi * aa, Hi += Oi * Ds, fn += Oi * ra, Bi += Oi * ca, ki += Oi * ta, Ji += Oi * oa, Ri += Oi * da, ji += Oi * Zi, Gi += Oi * Ui, is += Oi * Ki, os += Oi * En, ds += Oi * ss, ps += Oi * as, Oi = Xi[13], Si += Oi * fa, Vi += Oi * gs, ts += Oi * sa, Hi += Oi * aa, fn += Oi * Ds, Bi += Oi * ra, ki += Oi * ca, Ji += Oi * ta, Ri += Oi * oa, ji += Oi * da, Gi += Oi * Zi, is += Oi * Ui, os += Oi * Ki, ds += Oi * En, ps += Oi * ss, ea += Oi * as, Oi = Xi[14], Vi += Oi * fa, ts += Oi * gs, Hi += Oi * sa, fn += Oi * aa, Bi += Oi * Ds, ki += Oi * ra, Ji += Oi * ca, Ri += Oi * ta, ji += Oi * oa, Gi += Oi * da, is += Oi * Zi, os += Oi * Ui, ds += Oi * Ki, ps += Oi * En, ea += Oi * ss, ia += Oi * as, Oi = Xi[15], ts += Oi * fa, Hi += Oi * gs, fn += Oi * sa, Bi += Oi * aa, ki += Oi * Ds, Ji += Oi * ra, Ri += Oi * ca, ji += Oi * ta, Gi += Oi * oa, is += Oi * da, os += Oi * Zi, ds += Oi * Ui, ps += Oi * Ki, ea += Oi * En, ia += Oi * ss, hs += Oi * as, ns += 38 * Hi, ls += 38 * fn, vn += 38 * Bi, Mi += 38 * ki, Ai += 38 * Ji, wi += 38 * Ri, $i += 38 * ji, Li += 38 * Gi, qi += 38 * is, Ni += 38 * os, Ti += 38 * ds, xi += 38 * ps, Fi += 38 * ea, Si += 38 * ia, Vi += 38 * hs, Yi = 1, Oi = ns + Yi + 65535, Yi = Math.floor(Oi / 65536), ns = Oi - Yi * 65536, Oi = ls + Yi + 65535, Yi = Math.floor(Oi / 65536), ls = Oi - Yi * 65536, Oi = vn + Yi + 65535, Yi = Math.floor(Oi / 65536), vn = Oi - Yi * 65536, Oi = Mi + Yi + 65535, Yi = Math.floor(Oi / 65536), Mi = Oi - Yi * 65536, Oi = Ai + Yi + 65535, Yi = Math.floor(Oi / 65536), Ai = Oi - Yi * 65536, Oi = wi + Yi + 65535, Yi = Math.floor(Oi / 65536), wi = Oi - Yi * 65536, Oi = $i + Yi + 65535, Yi = Math.floor(Oi / 65536), $i = Oi - Yi * 65536, Oi = Li + Yi + 65535, Yi = Math.floor(Oi / 65536), Li = Oi - Yi * 65536, Oi = qi + Yi + 65535, Yi = Math.floor(Oi / 65536), qi = Oi - Yi * 65536, Oi = Ni + Yi + 65535, Yi = Math.floor(Oi / 65536), Ni = Oi - Yi * 65536, Oi = Ti + Yi + 65535, Yi = Math.floor(Oi / 65536), Ti = Oi - Yi * 65536, Oi = xi + Yi + 65535, Yi = Math.floor(Oi / 65536), xi = Oi - Yi * 65536, Oi = Fi + Yi + 65535, Yi = Math.floor(Oi / 65536), Fi = Oi - Yi * 65536, Oi = Si + Yi + 65535, Yi = Math.floor(Oi / 65536), Si = Oi - Yi * 65536, Oi = Vi + Yi + 65535, Yi = Math.floor(Oi / 65536), Vi = Oi - Yi * 65536, Oi = ts + Yi + 65535, Yi = Math.floor(Oi / 65536), ts = Oi - Yi * 65536, ns += Yi - 1 + 37 * (Yi - 1), Yi = 1, Oi = ns + Yi + 65535, Yi = Math.floor(Oi / 65536), ns = Oi - Yi * 65536, Oi = ls + Yi + 65535, Yi = Math.floor(Oi / 65536), ls = Oi - Yi * 65536, Oi = vn + Yi + 65535, Yi = Math.floor(Oi / 65536), vn = Oi - Yi * 65536, Oi = Mi + Yi + 65535, Yi = Math.floor(Oi / 65536), Mi = Oi - Yi * 65536, Oi = Ai + Yi + 65535, Yi = Math.floor(Oi / 65536), Ai = Oi - Yi * 65536, Oi = wi + Yi + 65535, Yi = Math.floor(Oi / 65536), wi = Oi - Yi * 65536, Oi = $i + Yi + 65535, Yi = Math.floor(Oi / 65536), $i = Oi - Yi * 65536, Oi = Li + Yi + 65535, Yi = Math.floor(Oi / 65536), Li = Oi - Yi * 65536, Oi = qi + Yi + 65535, Yi = Math.floor(Oi / 65536), qi = Oi - Yi * 65536, Oi = Ni + Yi + 65535, Yi = Math.floor(Oi / 65536), Ni = Oi - Yi * 65536, Oi = Ti + Yi + 65535, Yi = Math.floor(Oi / 65536), Ti = Oi - Yi * 65536, Oi = xi + Yi + 65535, Yi = Math.floor(Oi / 65536), xi = Oi - Yi * 65536, Oi = Fi + Yi + 65535, Yi = Math.floor(Oi / 65536), Fi = Oi - Yi * 65536, Oi = Si + Yi + 65535, Yi = Math.floor(Oi / 65536), Si = Oi - Yi * 65536, Oi = Vi + Yi + 65535, Yi = Math.floor(Oi / 65536), Vi = Oi - Yi * 65536, Oi = ts + Yi + 65535, Yi = Math.floor(Oi / 65536), ts = Oi - Yi * 65536, ns += Yi - 1 + 37 * (Yi - 1), zi[0] = ns, zi[1] = ls, zi[2] = vn, zi[3] = Mi, zi[4] = Ai, zi[5] = wi, zi[6] = $i, zi[7] = Li, zi[8] = qi, zi[9] = Ni, zi[10] = Ti, zi[11] = xi, zi[12] = Fi, zi[13] = Si, zi[14] = Vi, zi[15] = ts;
  }
  function mi(zi, Xi) {
    vi(zi, Xi, Xi);
  }
  function _i(zi, Xi) {
    const Qi = Me();
    for (let Oi = 0; Oi < 16; Oi++)
      Qi[Oi] = Xi[Oi];
    for (let Oi = 253; Oi >= 0; Oi--)
      mi(Qi, Qi), Oi !== 2 && Oi !== 4 && vi(Qi, Qi, Xi);
    for (let Oi = 0; Oi < 16; Oi++)
      zi[Oi] = Qi[Oi];
  }
  function Ei(zi, Xi) {
    const Qi = new Uint8Array(32), Oi = new Float64Array(80), Yi = Me(), ns = Me(), ls = Me(), vn = Me(), Mi = Me(), Ai = Me();
    for (let qi = 0; qi < 31; qi++)
      Qi[qi] = zi[qi];
    Qi[31] = zi[31] & 127 | 64, Qi[0] &= 248, fi(Oi, Xi);
    for (let qi = 0; qi < 16; qi++)
      ns[qi] = Oi[qi];
    Yi[0] = vn[0] = 1;
    for (let qi = 254; qi >= 0; --qi) {
      const Ni = Qi[qi >>> 3] >>> (qi & 7) & 1;
      je(Yi, ns, Ni), je(ls, vn, Ni), Ue(Mi, Yi, ls), bi(Yi, Yi, ls), Ue(ls, ns, vn), bi(ns, ns, vn), mi(vn, Mi), mi(Ai, Yi), vi(Yi, ls, Yi), vi(ls, ns, Mi), Ue(Mi, Yi, ls), bi(Yi, Yi, ls), mi(ns, Yi), bi(ls, vn, Ai), vi(Yi, ls, Pe), Ue(Yi, Yi, vn), vi(ls, ls, Yi), vi(Yi, vn, Ai), vi(vn, ns, Oi), mi(ns, Mi), je(Yi, ns, Ni), je(ls, vn, Ni);
    }
    for (let qi = 0; qi < 16; qi++)
      Oi[qi + 16] = Yi[qi], Oi[qi + 32] = ls[qi], Oi[qi + 48] = ns[qi], Oi[qi + 64] = vn[qi];
    const wi = Oi.subarray(32), $i = Oi.subarray(16);
    _i(wi, wi), vi($i, $i, wi);
    const Li = new Uint8Array(32);
    return Ve(Li, $i), Li;
  }
  Ae.scalarMult = Ei;
  function Pi(zi) {
    return Ei(zi, Be);
  }
  Ae.scalarMultBase = Pi;
  function Ii(zi) {
    if (zi.length !== Ae.SECRET_KEY_LENGTH)
      throw new Error(`x25519: seed must be ${Ae.SECRET_KEY_LENGTH} bytes`);
    const Xi = new Uint8Array(zi);
    return {
      publicKey: Pi(Xi),
      secretKey: Xi
    };
  }
  Ae.generateKeyPairFromSeed = Ii;
  function Ci(zi) {
    const Xi = (0, t.randomBytes)(32, zi), Qi = Ii(Xi);
    return (0, Ie.wipe)(Xi), Qi;
  }
  Ae.generateKeyPair = Ci;
  function Wi(zi, Xi, Qi = !1) {
    if (zi.length !== Ae.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect secret key length");
    if (Xi.length !== Ae.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect public key length");
    const Oi = Ei(zi, Xi);
    if (Qi) {
      let Yi = 0;
      for (let ns = 0; ns < Oi.length; ns++)
        Yi |= Oi[ns];
      if (Yi === 0)
        throw new Error("X25519: invalid shared key");
    }
    return Oi;
  }
  Ae.sharedKey = Wi;
})(x25519);
var ellipticExports = requireElliptic();
const C$2 = { waku: { publish: "waku_publish", batchPublish: "waku_batchPublish", subscribe: "waku_subscribe", batchSubscribe: "waku_batchSubscribe", subscription: "waku_subscription", unsubscribe: "waku_unsubscribe", batchUnsubscribe: "waku_batchUnsubscribe", batchFetchMessages: "waku_batchFetchMessages" }, irn: { publish: "irn_publish", batchPublish: "irn_batchPublish", subscribe: "irn_subscribe", batchSubscribe: "irn_batchSubscribe", subscription: "irn_subscription", unsubscribe: "irn_unsubscribe", batchUnsubscribe: "irn_batchUnsubscribe", batchFetchMessages: "irn_batchFetchMessages" }, iridium: { publish: "iridium_publish", batchPublish: "iridium_batchPublish", subscribe: "iridium_subscribe", batchSubscribe: "iridium_batchSubscribe", subscription: "iridium_subscription", unsubscribe: "iridium_unsubscribe", batchUnsubscribe: "iridium_batchUnsubscribe", batchFetchMessages: "iridium_batchFetchMessages" } }, H$1 = ":";
function re$2(Ae) {
  const [t, Ie] = Ae.split(H$1);
  return { namespace: t, reference: Ie };
}
function W$2(Ae, t) {
  return Ae.includes(":") ? [Ae] : t.chains || [];
}
var gt$3 = Object.defineProperty, Ke = Object.getOwnPropertySymbols, vt$2 = Object.prototype.hasOwnProperty, bt$2 = Object.prototype.propertyIsEnumerable, Le$1 = (Ae, t, Ie) => t in Ae ? gt$3(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, Fe = (Ae, t) => {
  for (var Ie in t || (t = {})) vt$2.call(t, Ie) && Le$1(Ae, Ie, t[Ie]);
  if (Ke) for (var Ie of Ke(t)) bt$2.call(t, Ie) && Le$1(Ae, Ie, t[Ie]);
  return Ae;
};
const qe = "ReactNative", y$1 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, He = "js";
function ce$1() {
  return typeof process$1 < "u" && typeof process$1.versions < "u" && typeof process$1.versions.node < "u";
}
function _$1() {
  return !getDocument_1() && !!getNavigator_1() && navigator.product === qe;
}
function V$3() {
  return !ce$1() && !!getNavigator_1() && !!getDocument_1();
}
function P$2() {
  return _$1() ? y$1.reactNative : ce$1() ? y$1.node : V$3() ? y$1.browser : y$1.unknown;
}
function Ot$2() {
  var Ae;
  try {
    return _$1() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (Ae = global.Application) == null ? void 0 : Ae.applicationId : void 0;
  } catch {
    return;
  }
}
function We$2(Ae, t) {
  let Ie = queryString.parse(Ae);
  return Ie = Fe(Fe({}, Ie), t), Ae = queryString.stringify(Ie), Ae;
}
function Nt$2() {
  return getWindowMetadata_1() || { name: "", description: "", url: "", icons: [""] };
}
function Je$1() {
  if (P$2() === y$1.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: Ie, Version: Me } = global.Platform;
    return [Ie, Me].join("-");
  }
  const Ae = detect();
  if (Ae === null) return "unknown";
  const t = Ae.os ? Ae.os.replace(" ", "").toLowerCase() : "unknown";
  return Ae.type === "browser" ? [t, Ae.name, Ae.version].join("-") : [t, Ae.version].join("-");
}
function ze() {
  var Ae;
  const t = P$2();
  return t === y$1.browser ? [t, ((Ae = getLocation_1()) == null ? void 0 : Ae.host) || "unknown"].join(":") : t;
}
function Ge(Ae, t, Ie) {
  const Me = Je$1(), Be = ze();
  return [[Ae, t].join("-"), [He, Ie].join("-"), Me, Be].join("/");
}
function $t$2({ protocol: Ae, version: t, relayUrl: Ie, sdkVersion: Me, auth: Be, projectId: Pe, useOnCloseEvent: Te, bundleId: je }) {
  const Ve = Ie.split("?"), fi = Ge(Ae, t, Me), Ue = { auth: Be, ua: fi, projectId: Pe, useOnCloseEvent: Te || void 0, origin: je || void 0 }, bi = We$2(Ve[1] || "", Ue);
  return Ve[0] + "?" + bi;
}
function $$2(Ae, t) {
  return Ae.filter((Ie) => t.includes(Ie)).length === Ae.length;
}
function Tt$2(Ae) {
  return Object.fromEntries(Ae.entries());
}
function Pt$2(Ae) {
  return new Map(Object.entries(Ae));
}
function _t$2(Ae = cjs$3.FIVE_MINUTES, t) {
  const Ie = cjs$3.toMiliseconds(Ae || cjs$3.FIVE_MINUTES);
  let Me, Be, Pe;
  return { resolve: (Te) => {
    Pe && Me && (clearTimeout(Pe), Me(Te));
  }, reject: (Te) => {
    Pe && Be && (clearTimeout(Pe), Be(Te));
  }, done: () => new Promise((Te, je) => {
    Pe = setTimeout(() => {
      je(new Error(t));
    }, Ie), Me = Te, Be = je;
  }) };
}
function kt$2(Ae, t, Ie) {
  return new Promise(async (Me, Be) => {
    const Pe = setTimeout(() => Be(new Error(Ie)), t);
    try {
      const Te = await Ae;
      Me(Te);
    } catch (Te) {
      Be(Te);
    }
    clearTimeout(Pe);
  });
}
function ae$2(Ae, t) {
  if (typeof t == "string" && t.startsWith(`${Ae}:`)) return t;
  if (Ae.toLowerCase() === "topic") {
    if (typeof t != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${t}`;
  } else if (Ae.toLowerCase() === "id") {
    if (typeof t != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${t}`;
  }
  throw new Error(`Unknown expirer target type: ${Ae}`);
}
function Dt$2(Ae) {
  return ae$2("topic", Ae);
}
function xt$2(Ae) {
  return ae$2("id", Ae);
}
function Vt$2(Ae) {
  const [t, Ie] = Ae.split(":"), Me = { id: void 0, topic: void 0 };
  if (t === "topic" && typeof Ie == "string") Me.topic = Ie;
  else if (t === "id" && Number.isInteger(Number(Ie))) Me.id = Number(Ie);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${Ie}`);
  return Me;
}
function Mt$2(Ae, t) {
  return cjs$3.fromMiliseconds(Date.now() + cjs$3.toMiliseconds(Ae));
}
function Kt$2(Ae) {
  return Date.now() >= cjs$3.toMiliseconds(Ae);
}
function Lt$2(Ae, t) {
  return `${Ae}${t ? `:${t}` : ""}`;
}
function N(Ae = [], t = []) {
  return [.../* @__PURE__ */ new Set([...Ae, ...t])];
}
async function Ft$2({ id: Ae, topic: t, wcDeepLink: Ie }) {
  var Me;
  try {
    if (!Ie) return;
    const Be = typeof Ie == "string" ? JSON.parse(Ie) : Ie, Pe = Be == null ? void 0 : Be.href;
    if (typeof Pe != "string") return;
    const Te = Xe$1(Pe, Ae, t), je = P$2();
    if (je === y$1.browser) {
      if (!((Me = getDocument_1()) != null && Me.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      Te.startsWith("https://") || Te.startsWith("http://") ? window.open(Te, "_blank", "noreferrer noopener") : window.open(Te, en$1() ? "_blank" : "_self", "noreferrer noopener");
    } else je === y$1.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(Te);
  } catch (Be) {
    console.error(Be);
  }
}
function Xe$1(Ae, t, Ie) {
  const Me = `requestId=${t}&sessionTopic=${Ie}`;
  Ae.endsWith("/") && (Ae = Ae.slice(0, -1));
  let Be = `${Ae}`;
  if (Ae.startsWith("https://t.me")) {
    const Pe = Ae.includes("?") ? "&startapp=" : "?startapp=";
    Be = `${Be}${Pe}${nn$1(Me, !0)}`;
  } else Be = `${Be}/wc?${Me}`;
  return Be;
}
async function qt$2(Ae, t) {
  let Ie = "";
  try {
    if (V$3() && (Ie = localStorage.getItem(t), Ie)) return Ie;
    Ie = await Ae.getItem(t);
  } catch (Me) {
    console.error(Me);
  }
  return Ie;
}
function Bt$2(Ae, t) {
  if (!Ae.includes(t)) return null;
  const Ie = Ae.split(/([&,?,=])/), Me = Ie.indexOf(t);
  return Ie[Me + 2];
}
function Ht$2() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (Ae) => {
    const t = Math.random() * 16 | 0;
    return (Ae === "x" ? t : t & 3 | 8).toString(16);
  });
}
function Wt$2() {
  return typeof process$1 < "u" && process$1.env.IS_VITEST === "true";
}
function en$1() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function nn$1(Ae, t = !1) {
  const Ie = Buffer.from(Ae).toString("base64");
  return t ? Ie.replace(/[=]/g, "") : Ie;
}
function le$1(Ae) {
  return Buffer.from(Ae, "base64").toString("utf-8");
}
const Jt$2 = "https://rpc.walletconnect.org/v1";
async function tn$1(Ae, t, Ie, Me, Be, Pe) {
  switch (Ie.t) {
    case "eip191":
      return rn$1(Ae, t, Ie.s);
    case "eip1271":
      return await on$1(Ae, t, Ie.s, Me, Be, Pe);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${Ie.t}`);
  }
}
function rn$1(Ae, t, Ie) {
  return recoverAddress(hashMessage(t), Ie).toLowerCase() === Ae.toLowerCase();
}
async function on$1(Ae, t, Ie, Me, Be, Pe) {
  const Te = re$2(Me);
  if (!Te.namespace || !Te.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${Me}`);
  try {
    const je = "0x1626ba7e", Ve = "0000000000000000000000000000000000000000000000000000000000000040", fi = "0000000000000000000000000000000000000000000000000000000000000041", Ue = Ie.substring(2), bi = hashMessage(t).substring(2), vi = je + bi + Ve + fi + Ue, mi = await fetch(`${Pe || Jt$2}/?chainId=${Me}&projectId=${Be}`, { method: "POST", body: JSON.stringify({ id: zt$2(), jsonrpc: "2.0", method: "eth_call", params: [{ to: Ae, data: vi }, "latest"] }) }), { result: _i } = await mi.json();
    return _i ? _i.slice(0, je.length).toLowerCase() === je.toLowerCase() : !1;
  } catch (je) {
    return console.error("isValidEip1271Signature: ", je), !1;
  }
}
function zt$2() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
var Gt$2 = Object.defineProperty, Yt$2 = Object.defineProperties, Qt$2 = Object.getOwnPropertyDescriptors, sn$1 = Object.getOwnPropertySymbols, Zt$2 = Object.prototype.hasOwnProperty, Xt$2 = Object.prototype.propertyIsEnumerable, cn$1 = (Ae, t, Ie) => t in Ae ? Gt$2(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, de$1 = (Ae, t) => {
  for (var Ie in t || (t = {})) Zt$2.call(t, Ie) && cn$1(Ae, Ie, t[Ie]);
  if (sn$1) for (var Ie of sn$1(t)) Xt$2.call(t, Ie) && cn$1(Ae, Ie, t[Ie]);
  return Ae;
}, an$1 = (Ae, t) => Yt$2(Ae, Qt$2(t));
const er$2 = "did:pkh:", z$4 = (Ae) => Ae == null ? void 0 : Ae.split(":"), un$1 = (Ae) => {
  const t = Ae && z$4(Ae);
  if (t) return Ae.includes(er$2) ? t[3] : t[1];
}, ln$1 = (Ae) => {
  const t = Ae && z$4(Ae);
  if (t) return t[2] + ":" + t[3];
}, fe$2 = (Ae) => {
  const t = Ae && z$4(Ae);
  if (t) return t.pop();
};
async function nr$2(Ae) {
  const { cacao: t, projectId: Ie } = Ae, { s: Me, p: Be } = t, Pe = dn$1(Be, Be.iss), Te = fe$2(Be.iss);
  return await tn$1(Te, Pe, Me, ln$1(Be.iss), Ie);
}
const dn$1 = (Ae, t) => {
  const Ie = `${Ae.domain} wants you to sign in with your Ethereum account:`, Me = fe$2(t);
  if (!Ae.aud && !Ae.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let Be = Ae.statement || void 0;
  const Pe = `URI: ${Ae.aud || Ae.uri}`, Te = `Version: ${Ae.version}`, je = `Chain ID: ${un$1(t)}`, Ve = `Nonce: ${Ae.nonce}`, fi = `Issued At: ${Ae.iat}`, Ue = Ae.exp ? `Expiration Time: ${Ae.exp}` : void 0, bi = Ae.nbf ? `Not Before: ${Ae.nbf}` : void 0, vi = Ae.requestId ? `Request ID: ${Ae.requestId}` : void 0, mi = Ae.resources ? `Resources:${Ae.resources.map((Ei) => `
- ${Ei}`).join("")}` : void 0, _i = Y$2(Ae.resources);
  if (_i) {
    const Ei = R$2(_i);
    Be = he$1(Be, Ei);
  }
  return [Ie, Me, "", Be, "", Pe, Te, je, Ve, fi, Ue, bi, vi, mi].filter((Ei) => Ei != null).join(`
`);
};
function hn$1(Ae) {
  return Buffer.from(JSON.stringify(Ae)).toString("base64");
}
function yn$1(Ae) {
  return JSON.parse(Buffer.from(Ae, "base64").toString("utf-8"));
}
function O$3(Ae) {
  if (!Ae) throw new Error("No recap provided, value is undefined");
  if (!Ae.att) throw new Error("No `att` property found");
  const t = Object.keys(Ae.att);
  if (!(t != null && t.length)) throw new Error("No resources found in `att` property");
  t.forEach((Ie) => {
    const Me = Ae.att[Ie];
    if (Array.isArray(Me)) throw new Error(`Resource must be an object: ${Ie}`);
    if (typeof Me != "object") throw new Error(`Resource must be an object: ${Ie}`);
    if (!Object.keys(Me).length) throw new Error(`Resource object is empty: ${Ie}`);
    Object.keys(Me).forEach((Be) => {
      const Pe = Me[Be];
      if (!Array.isArray(Pe)) throw new Error(`Ability limits ${Be} must be an array of objects, found: ${Pe}`);
      if (!Pe.length) throw new Error(`Value of ${Be} is empty array, must be an array with objects`);
      Pe.forEach((Te) => {
        if (typeof Te != "object") throw new Error(`Ability limits (${Be}) must be an array of objects, found: ${Te}`);
      });
    });
  });
}
function gn$1(Ae, t, Ie, Me = {}) {
  return Ie == null || Ie.sort((Be, Pe) => Be.localeCompare(Pe)), { att: { [Ae]: pe$1(t, Ie, Me) } };
}
function pe$1(Ae, t, Ie = {}) {
  t = t == null ? void 0 : t.sort((Be, Pe) => Be.localeCompare(Pe));
  const Me = t.map((Be) => ({ [`${Ae}/${Be}`]: [Ie] }));
  return Object.assign({}, ...Me);
}
function G$1(Ae) {
  return O$3(Ae), `urn:recap:${hn$1(Ae).replace(/=/g, "")}`;
}
function R$2(Ae) {
  const t = yn$1(Ae.replace("urn:recap:", ""));
  return O$3(t), t;
}
function ir$2(Ae, t, Ie) {
  const Me = gn$1(Ae, t, Ie);
  return G$1(Me);
}
function me$3(Ae) {
  return Ae && Ae.includes("urn:recap:");
}
function cr$2(Ae, t) {
  const Ie = R$2(Ae), Me = R$2(t), Be = bn$1(Ie, Me);
  return G$1(Be);
}
function bn$1(Ae, t) {
  O$3(Ae), O$3(t);
  const Ie = Object.keys(Ae.att).concat(Object.keys(t.att)).sort((Be, Pe) => Be.localeCompare(Pe)), Me = { att: {} };
  return Ie.forEach((Be) => {
    var Pe, Te;
    Object.keys(((Pe = Ae.att) == null ? void 0 : Pe[Be]) || {}).concat(Object.keys(((Te = t.att) == null ? void 0 : Te[Be]) || {})).sort((je, Ve) => je.localeCompare(Ve)).forEach((je) => {
      var Ve, fi;
      Me.att[Be] = an$1(de$1({}, Me.att[Be]), { [je]: ((Ve = Ae.att[Be]) == null ? void 0 : Ve[je]) || ((fi = t.att[Be]) == null ? void 0 : fi[je]) });
    });
  }), Me;
}
function he$1(Ae = "", t) {
  O$3(t);
  const Ie = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (Ae.includes(Ie)) return Ae;
  const Me = [];
  let Be = 0;
  Object.keys(t.att).forEach((je) => {
    const Ve = Object.keys(t.att[je]).map((bi) => ({ ability: bi.split("/")[0], action: bi.split("/")[1] }));
    Ve.sort((bi, vi) => bi.action.localeCompare(vi.action));
    const fi = {};
    Ve.forEach((bi) => {
      fi[bi.ability] || (fi[bi.ability] = []), fi[bi.ability].push(bi.action);
    });
    const Ue = Object.keys(fi).map((bi) => (Be++, `(${Be}) '${bi}': '${fi[bi].join("', '")}' for '${je}'.`));
    Me.push(Ue.join(", ").replace(".,", "."));
  });
  const Pe = Me.join(" "), Te = `${Ie}${Pe}`;
  return `${Ae ? Ae + " " : ""}${Te}`;
}
function ar$2(Ae) {
  var t;
  const Ie = R$2(Ae);
  O$3(Ie);
  const Me = (t = Ie.att) == null ? void 0 : t.eip155;
  return Me ? Object.keys(Me).map((Be) => Be.split("/")[1]) : [];
}
function ur$2(Ae) {
  const t = R$2(Ae);
  O$3(t);
  const Ie = [];
  return Object.values(t.att).forEach((Me) => {
    Object.values(Me).forEach((Be) => {
      var Pe;
      (Pe = Be == null ? void 0 : Be[0]) != null && Pe.chains && Ie.push(Be[0].chains);
    });
  }), [...new Set(Ie.flat())];
}
function Y$2(Ae) {
  if (!Ae) return;
  const t = Ae == null ? void 0 : Ae[Ae.length - 1];
  return me$3(t) ? t : void 0;
}
const ye$3 = "base10", g$1 = "base16", ge$1 = "base64pad", lr$2 = "base64url", k$1 = "utf8", ve$1 = 0, D$2 = 1, M$2 = 2, dr$2 = 0, wn = 1, K$2 = 12, be$3 = 32;
function fr$2() {
  const Ae = x25519.generateKeyPair();
  return { privateKey: toString(Ae.secretKey, g$1), publicKey: toString(Ae.publicKey, g$1) };
}
function pr$2() {
  const Ae = random.randomBytes(be$3);
  return toString(Ae, g$1);
}
function mr$2(Ae, t) {
  const Ie = x25519.sharedKey(fromString(Ae, g$1), fromString(t, g$1), !0), Me = new HKDF_1(sha256.SHA256, Ie).expand(be$3);
  return toString(Me, g$1);
}
function hr$2(Ae) {
  const t = sha256.hash(fromString(Ae, g$1));
  return toString(t, g$1);
}
function yr$2(Ae) {
  const t = sha256.hash(fromString(Ae, k$1));
  return toString(t, g$1);
}
function Ee$2(Ae) {
  return fromString(`${Ae}`, ye$3);
}
function A(Ae) {
  return Number(toString(Ae, ye$3));
}
function gr$2(Ae) {
  const t = Ee$2(typeof Ae.type < "u" ? Ae.type : ve$1);
  if (A(t) === D$2 && typeof Ae.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const Ie = typeof Ae.senderPublicKey < "u" ? fromString(Ae.senderPublicKey, g$1) : void 0, Me = typeof Ae.iv < "u" ? fromString(Ae.iv, g$1) : random.randomBytes(K$2), Be = new chacha20poly1305.ChaCha20Poly1305(fromString(Ae.symKey, g$1)).seal(Me, fromString(Ae.message, k$1));
  return we$3({ type: t, sealed: Be, iv: Me, senderPublicKey: Ie, encoding: Ae.encoding });
}
function vr$2(Ae, t) {
  const Ie = Ee$2(M$2), Me = random.randomBytes(K$2), Be = fromString(Ae, k$1);
  return we$3({ type: Ie, sealed: Be, iv: Me, encoding: t });
}
function br$2(Ae) {
  const t = new chacha20poly1305.ChaCha20Poly1305(fromString(Ae.symKey, g$1)), { sealed: Ie, iv: Me } = Q$1({ encoded: Ae.encoded, encoding: Ae == null ? void 0 : Ae.encoding }), Be = t.open(Me, Ie);
  if (Be === null) throw new Error("Failed to decrypt");
  return toString(Be, k$1);
}
function Er$2(Ae, t) {
  const { sealed: Ie } = Q$1({ encoded: Ae, encoding: t });
  return toString(Ie, k$1);
}
function we$3(Ae) {
  const { encoding: t = ge$1 } = Ae;
  if (A(Ae.type) === M$2) return toString(concat$1([Ae.type, Ae.sealed]), t);
  if (A(Ae.type) === D$2) {
    if (typeof Ae.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat$1([Ae.type, Ae.senderPublicKey, Ae.iv, Ae.sealed]), t);
  }
  return toString(concat$1([Ae.type, Ae.iv, Ae.sealed]), t);
}
function Q$1(Ae) {
  const { encoded: t, encoding: Ie = ge$1 } = Ae, Me = fromString(t, Ie), Be = Me.slice(dr$2, wn), Pe = wn;
  if (A(Be) === D$2) {
    const fi = Pe + be$3, Ue = fi + K$2, bi = Me.slice(Pe, fi), vi = Me.slice(fi, Ue), mi = Me.slice(Ue);
    return { type: Be, sealed: mi, iv: vi, senderPublicKey: bi };
  }
  if (A(Be) === M$2) {
    const fi = Me.slice(Pe), Ue = random.randomBytes(K$2);
    return { type: Be, sealed: fi, iv: Ue };
  }
  const Te = Pe + K$2, je = Me.slice(Pe, Te), Ve = Me.slice(Te);
  return { type: Be, sealed: Ve, iv: je };
}
function wr$2(Ae, t) {
  const Ie = Q$1({ encoded: Ae, encoding: t == null ? void 0 : t.encoding });
  return On({ type: A(Ie.type), senderPublicKey: typeof Ie.senderPublicKey < "u" ? toString(Ie.senderPublicKey, g$1) : void 0, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey });
}
function On(Ae) {
  const t = (Ae == null ? void 0 : Ae.type) || ve$1;
  if (t === D$2) {
    if (typeof (Ae == null ? void 0 : Ae.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (Ae == null ? void 0 : Ae.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: t, senderPublicKey: Ae == null ? void 0 : Ae.senderPublicKey, receiverPublicKey: Ae == null ? void 0 : Ae.receiverPublicKey };
}
function Or$2(Ae) {
  return Ae.type === D$2 && typeof Ae.senderPublicKey == "string" && typeof Ae.receiverPublicKey == "string";
}
function Nr$2(Ae) {
  return Ae.type === M$2;
}
function Nn(Ae) {
  return new ellipticExports.ec("p256").keyFromPublic({ x: Buffer.from(Ae.x, "base64").toString("hex"), y: Buffer.from(Ae.y, "base64").toString("hex") }, "hex");
}
function Sr$2(Ae) {
  let t = Ae.replace(/-/g, "+").replace(/_/g, "/");
  const Ie = t.length % 4;
  return Ie > 0 && (t += "=".repeat(4 - Ie)), t;
}
function $r$2(Ae) {
  return Buffer.from(Sr$2(Ae), "base64");
}
function Rr$2(Ae, t) {
  const [Ie, Me, Be] = Ae.split("."), Pe = $r$2(Be);
  if (Pe.length !== 64) throw new Error("Invalid signature length");
  const Te = Pe.slice(0, 32).toString("hex"), je = Pe.slice(32, 64).toString("hex"), Ve = `${Ie}.${Me}`, fi = new sha256.SHA256().update(Buffer.from(Ve)).digest(), Ue = Nn(t), bi = Buffer.from(fi).toString("hex");
  if (!Ue.verify(bi, { r: Te, s: je })) throw new Error("Invalid signature");
  return decodeJWT(Ae).payload;
}
const Sn = "irn";
function Ir$1(Ae) {
  return (Ae == null ? void 0 : Ae.relay) || { protocol: Sn };
}
function jr$1(Ae) {
  const t = C$2[Ae];
  if (typeof t > "u") throw new Error(`Relay Protocol not supported: ${Ae}`);
  return t;
}
var Tr$2 = Object.defineProperty, Pr$2 = Object.defineProperties, Ar$2 = Object.getOwnPropertyDescriptors, $n = Object.getOwnPropertySymbols, Cr$2 = Object.prototype.hasOwnProperty, Ur$1 = Object.prototype.propertyIsEnumerable, Rn = (Ae, t, Ie) => t in Ae ? Tr$2(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, In = (Ae, t) => {
  for (var Ie in t || (t = {})) Cr$2.call(t, Ie) && Rn(Ae, Ie, t[Ie]);
  if ($n) for (var Ie of $n(t)) Ur$1.call(t, Ie) && Rn(Ae, Ie, t[Ie]);
  return Ae;
}, _r$2 = (Ae, t) => Pr$2(Ae, Ar$2(t));
function jn(Ae, t = "-") {
  const Ie = {}, Me = "relay" + t;
  return Object.keys(Ae).forEach((Be) => {
    if (Be.startsWith(Me)) {
      const Pe = Be.replace(Me, ""), Te = Ae[Be];
      Ie[Pe] = Te;
    }
  }), Ie;
}
function kr$1(Ae) {
  if (!Ae.includes("wc:")) {
    const Ve = le$1(Ae);
    Ve != null && Ve.includes("wc:") && (Ae = Ve);
  }
  Ae = Ae.includes("wc://") ? Ae.replace("wc://", "") : Ae, Ae = Ae.includes("wc:") ? Ae.replace("wc:", "") : Ae;
  const t = Ae.indexOf(":"), Ie = Ae.indexOf("?") !== -1 ? Ae.indexOf("?") : void 0, Me = Ae.substring(0, t), Be = Ae.substring(t + 1, Ie).split("@"), Pe = typeof Ie < "u" ? Ae.substring(Ie) : "", Te = queryString.parse(Pe), je = typeof Te.methods == "string" ? Te.methods.split(",") : void 0;
  return { protocol: Me, topic: Tn(Be[0]), version: parseInt(Be[1], 10), symKey: Te.symKey, relay: jn(Te), methods: je, expiryTimestamp: Te.expiryTimestamp ? parseInt(Te.expiryTimestamp, 10) : void 0 };
}
function Tn(Ae) {
  return Ae.startsWith("//") ? Ae.substring(2) : Ae;
}
function Pn(Ae, t = "-") {
  const Ie = "relay", Me = {};
  return Object.keys(Ae).forEach((Be) => {
    const Pe = Ie + t + Be;
    Ae[Be] && (Me[Pe] = Ae[Be]);
  }), Me;
}
function Dr$2(Ae) {
  return `${Ae.protocol}:${Ae.topic}@${Ae.version}?` + queryString.stringify(In(_r$2(In({ symKey: Ae.symKey }, Pn(Ae.relay)), { expiryTimestamp: Ae.expiryTimestamp }), Ae.methods ? { methods: Ae.methods.join(",") } : {}));
}
function xr$2(Ae, t, Ie) {
  return `${Ae}?wc_ev=${Ie}&topic=${t}`;
}
var Vr$1 = Object.defineProperty, Mr$1 = Object.defineProperties, Kr$1 = Object.getOwnPropertyDescriptors, An = Object.getOwnPropertySymbols, Lr$1 = Object.prototype.hasOwnProperty, Fr$2 = Object.prototype.propertyIsEnumerable, Cn = (Ae, t, Ie) => t in Ae ? Vr$1(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, qr$1 = (Ae, t) => {
  for (var Ie in t || (t = {})) Lr$1.call(t, Ie) && Cn(Ae, Ie, t[Ie]);
  if (An) for (var Ie of An(t)) Fr$2.call(t, Ie) && Cn(Ae, Ie, t[Ie]);
  return Ae;
}, Br$2 = (Ae, t) => Mr$1(Ae, Kr$1(t));
function C$1(Ae) {
  const t = [];
  return Ae.forEach((Ie) => {
    const [Me, Be] = Ie.split(":");
    t.push(`${Me}:${Be}`);
  }), t;
}
function Un(Ae) {
  const t = [];
  return Object.values(Ae).forEach((Ie) => {
    t.push(...C$1(Ie.accounts));
  }), t;
}
function _n(Ae, t) {
  const Ie = [];
  return Object.values(Ae).forEach((Me) => {
    C$1(Me.accounts).includes(t) && Ie.push(...Me.methods);
  }), Ie;
}
function kn(Ae, t) {
  const Ie = [];
  return Object.values(Ae).forEach((Me) => {
    C$1(Me.accounts).includes(t) && Ie.push(...Me.events);
  }), Ie;
}
function Wr$1(Ae) {
  const { proposal: { requiredNamespaces: t, optionalNamespaces: Ie = {} }, supportedNamespaces: Me } = Ae, Be = Ne(t), Pe = Ne(Ie), Te = {};
  Object.keys(Me).forEach((fi) => {
    const Ue = Me[fi].chains, bi = Me[fi].methods, vi = Me[fi].events, mi = Me[fi].accounts;
    Ue.forEach((_i) => {
      if (!mi.some((Ei) => Ei.includes(_i))) throw new Error(`No accounts provided for chain ${_i} in namespace ${fi}`);
    }), Te[fi] = { chains: Ue, methods: bi, events: vi, accounts: mi };
  });
  const je = zn(t, Te, "approve()");
  if (je) throw new Error(je.message);
  const Ve = {};
  return !Object.keys(t).length && !Object.keys(Ie).length ? Te : (Object.keys(Be).forEach((fi) => {
    const Ue = Me[fi].chains.filter((_i) => {
      var Ei, Pi;
      return (Pi = (Ei = Be[fi]) == null ? void 0 : Ei.chains) == null ? void 0 : Pi.includes(_i);
    }), bi = Me[fi].methods.filter((_i) => {
      var Ei, Pi;
      return (Pi = (Ei = Be[fi]) == null ? void 0 : Ei.methods) == null ? void 0 : Pi.includes(_i);
    }), vi = Me[fi].events.filter((_i) => {
      var Ei, Pi;
      return (Pi = (Ei = Be[fi]) == null ? void 0 : Ei.events) == null ? void 0 : Pi.includes(_i);
    }), mi = Ue.map((_i) => Me[fi].accounts.filter((Ei) => Ei.includes(`${_i}:`))).flat();
    Ve[fi] = { chains: Ue, methods: bi, events: vi, accounts: mi };
  }), Object.keys(Pe).forEach((fi) => {
    var Ue, bi, vi, mi, _i, Ei;
    if (!Me[fi]) return;
    const Pi = (bi = (Ue = Pe[fi]) == null ? void 0 : Ue.chains) == null ? void 0 : bi.filter((zi) => Me[fi].chains.includes(zi)), Ii = Me[fi].methods.filter((zi) => {
      var Xi, Qi;
      return (Qi = (Xi = Pe[fi]) == null ? void 0 : Xi.methods) == null ? void 0 : Qi.includes(zi);
    }), Ci = Me[fi].events.filter((zi) => {
      var Xi, Qi;
      return (Qi = (Xi = Pe[fi]) == null ? void 0 : Xi.events) == null ? void 0 : Qi.includes(zi);
    }), Wi = Pi == null ? void 0 : Pi.map((zi) => Me[fi].accounts.filter((Xi) => Xi.includes(`${zi}:`))).flat();
    Ve[fi] = { chains: N((vi = Ve[fi]) == null ? void 0 : vi.chains, Pi), methods: N((mi = Ve[fi]) == null ? void 0 : mi.methods, Ii), events: N((_i = Ve[fi]) == null ? void 0 : _i.events, Ci), accounts: N((Ei = Ve[fi]) == null ? void 0 : Ei.accounts, Wi) };
  }), Ve);
}
function Oe(Ae) {
  return Ae.includes(":");
}
function Dn$1(Ae) {
  return Oe(Ae) ? Ae.split(":")[0] : Ae;
}
function Ne(Ae) {
  var t, Ie, Me;
  const Be = {};
  if (!Z$3(Ae)) return Be;
  for (const [Pe, Te] of Object.entries(Ae)) {
    const je = Oe(Pe) ? [Pe] : Te.chains, Ve = Te.methods || [], fi = Te.events || [], Ue = Dn$1(Pe);
    Be[Ue] = Br$2(qr$1({}, Be[Ue]), { chains: N(je, (t = Be[Ue]) == null ? void 0 : t.chains), methods: N(Ve, (Ie = Be[Ue]) == null ? void 0 : Ie.methods), events: N(fi, (Me = Be[Ue]) == null ? void 0 : Me.events) });
  }
  return Be;
}
function xn(Ae) {
  const t = {};
  return Ae == null || Ae.forEach((Ie) => {
    const [Me, Be] = Ie.split(":");
    t[Me] || (t[Me] = { accounts: [], chains: [], events: [] }), t[Me].accounts.push(Ie), t[Me].chains.push(`${Me}:${Be}`);
  }), t;
}
function Jr$1(Ae, t) {
  t = t.map((Me) => Me.replace("did:pkh:", ""));
  const Ie = xn(t);
  for (const [Me, Be] of Object.entries(Ie)) Be.methods ? Be.methods = N(Be.methods, Ae) : Be.methods = Ae, Be.events = ["chainChanged", "accountsChanged"];
  return Ie;
}
const Vn = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, Mn = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function S$4(Ae, t) {
  const { message: Ie, code: Me } = Mn[Ae];
  return { message: t ? `${Ie} ${t}` : Ie, code: Me };
}
function U$2(Ae, t) {
  const { message: Ie, code: Me } = Vn[Ae];
  return { message: t ? `${Ie} ${t}` : Ie, code: Me };
}
function L$2(Ae, t) {
  return !!Array.isArray(Ae);
}
function Z$3(Ae) {
  return Object.getPrototypeOf(Ae) === Object.prototype && Object.keys(Ae).length;
}
function I$3(Ae) {
  return typeof Ae > "u";
}
function b$2(Ae, t) {
  return t && I$3(Ae) ? !0 : typeof Ae == "string" && !!Ae.trim().length;
}
function X$1(Ae, t) {
  return typeof Ae == "number" && !isNaN(Ae);
}
function zr$2(Ae, t) {
  const { requiredNamespaces: Ie } = t, Me = Object.keys(Ae.namespaces), Be = Object.keys(Ie);
  let Pe = !0;
  return $$2(Be, Me) ? (Me.forEach((Te) => {
    const { accounts: je, methods: Ve, events: fi } = Ae.namespaces[Te], Ue = C$1(je), bi = Ie[Te];
    (!$$2(W$2(Te, bi), Ue) || !$$2(bi.methods, Ve) || !$$2(bi.events, fi)) && (Pe = !1);
  }), Pe) : !1;
}
function F$2(Ae) {
  return b$2(Ae, !1) && Ae.includes(":") ? Ae.split(":").length === 2 : !1;
}
function Kn(Ae) {
  if (b$2(Ae, !1) && Ae.includes(":")) {
    const t = Ae.split(":");
    if (t.length === 3) {
      const Ie = t[0] + ":" + t[1];
      return !!t[2] && F$2(Ie);
    }
  }
  return !1;
}
function Gr$1(Ae) {
  function t(Ie) {
    try {
      return typeof new URL(Ie) < "u";
    } catch {
      return !1;
    }
  }
  try {
    if (b$2(Ae, !1)) {
      if (t(Ae)) return !0;
      const Ie = le$1(Ae);
      return t(Ie);
    }
  } catch {
  }
  return !1;
}
function Yr$1(Ae) {
  var t;
  return (t = Ae == null ? void 0 : Ae.proposer) == null ? void 0 : t.publicKey;
}
function Qr$1(Ae) {
  return Ae == null ? void 0 : Ae.topic;
}
function Zr$1(Ae, t) {
  let Ie = null;
  return b$2(Ae == null ? void 0 : Ae.publicKey, !1) || (Ie = S$4("MISSING_OR_INVALID", `${t} controller public key should be a string`)), Ie;
}
function Se(Ae) {
  let t = !0;
  return L$2(Ae) ? Ae.length && (t = Ae.every((Ie) => b$2(Ie, !1))) : t = !1, t;
}
function Ln(Ae, t, Ie) {
  let Me = null;
  return L$2(t) && t.length ? t.forEach((Be) => {
    Me || F$2(Be) || (Me = U$2("UNSUPPORTED_CHAINS", `${Ie}, chain ${Be} should be a string and conform to "namespace:chainId" format`));
  }) : F$2(Ae) || (Me = U$2("UNSUPPORTED_CHAINS", `${Ie}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), Me;
}
function Fn(Ae, t, Ie) {
  let Me = null;
  return Object.entries(Ae).forEach(([Be, Pe]) => {
    if (Me) return;
    const Te = Ln(Be, W$2(Be, Pe), `${t} ${Ie}`);
    Te && (Me = Te);
  }), Me;
}
function qn(Ae, t) {
  let Ie = null;
  return L$2(Ae) ? Ae.forEach((Me) => {
    Ie || Kn(Me) || (Ie = U$2("UNSUPPORTED_ACCOUNTS", `${t}, account ${Me} should be a string and conform to "namespace:chainId:address" format`));
  }) : Ie = U$2("UNSUPPORTED_ACCOUNTS", `${t}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), Ie;
}
function Bn(Ae, t) {
  let Ie = null;
  return Object.values(Ae).forEach((Me) => {
    if (Ie) return;
    const Be = qn(Me == null ? void 0 : Me.accounts, `${t} namespace`);
    Be && (Ie = Be);
  }), Ie;
}
function Hn(Ae, t) {
  let Ie = null;
  return Se(Ae == null ? void 0 : Ae.methods) ? Se(Ae == null ? void 0 : Ae.events) || (Ie = U$2("UNSUPPORTED_EVENTS", `${t}, events should be an array of strings or empty array for no events`)) : Ie = U$2("UNSUPPORTED_METHODS", `${t}, methods should be an array of strings or empty array for no methods`), Ie;
}
function $e(Ae, t) {
  let Ie = null;
  return Object.values(Ae).forEach((Me) => {
    if (Ie) return;
    const Be = Hn(Me, `${t}, namespace`);
    Be && (Ie = Be);
  }), Ie;
}
function Xr$1(Ae, t, Ie) {
  let Me = null;
  if (Ae && Z$3(Ae)) {
    const Be = $e(Ae, t);
    Be && (Me = Be);
    const Pe = Fn(Ae, t, Ie);
    Pe && (Me = Pe);
  } else Me = S$4("MISSING_OR_INVALID", `${t}, ${Ie} should be an object with data`);
  return Me;
}
function Wn(Ae, t) {
  let Ie = null;
  if (Ae && Z$3(Ae)) {
    const Me = $e(Ae, t);
    Me && (Ie = Me);
    const Be = Bn(Ae, t);
    Be && (Ie = Be);
  } else Ie = S$4("MISSING_OR_INVALID", `${t}, namespaces should be an object with data`);
  return Ie;
}
function Jn(Ae) {
  return b$2(Ae.protocol, !0);
}
function eo(Ae, t) {
  let Ie = !1;
  return Ae ? Ae && L$2(Ae) && Ae.length && Ae.forEach((Me) => {
    Ie = Jn(Me);
  }) : Ie = !0, Ie;
}
function no(Ae) {
  return typeof Ae == "number";
}
function to(Ae) {
  return typeof Ae < "u" && typeof Ae !== null;
}
function ro(Ae) {
  return !(!Ae || typeof Ae != "object" || !Ae.code || !X$1(Ae.code) || !Ae.message || !b$2(Ae.message, !1));
}
function oo(Ae) {
  return !(I$3(Ae) || !b$2(Ae.method, !1));
}
function so(Ae) {
  return !(I$3(Ae) || I$3(Ae.result) && I$3(Ae.error) || !X$1(Ae.id) || !b$2(Ae.jsonrpc, !1));
}
function io(Ae) {
  return !(I$3(Ae) || !b$2(Ae.name, !1));
}
function co(Ae, t) {
  return !(!F$2(t) || !Un(Ae).includes(t));
}
function ao(Ae, t, Ie) {
  return b$2(Ie, !1) ? _n(Ae, t).includes(Ie) : !1;
}
function uo(Ae, t, Ie) {
  return b$2(Ie, !1) ? kn(Ae, t).includes(Ie) : !1;
}
function zn(Ae, t, Ie) {
  let Me = null;
  const Be = lo(Ae), Pe = fo(t), Te = Object.keys(Be), je = Object.keys(Pe), Ve = Gn(Object.keys(Ae)), fi = Gn(Object.keys(t)), Ue = Ve.filter((bi) => !fi.includes(bi));
  return Ue.length && (Me = S$4("NON_CONFORMING_NAMESPACES", `${Ie} namespaces keys don't satisfy requiredNamespaces.
      Required: ${Ue.toString()}
      Received: ${Object.keys(t).toString()}`)), $$2(Te, je) || (Me = S$4("NON_CONFORMING_NAMESPACES", `${Ie} namespaces chains don't satisfy required namespaces.
      Required: ${Te.toString()}
      Approved: ${je.toString()}`)), Object.keys(t).forEach((bi) => {
    if (!bi.includes(":") || Me) return;
    const vi = C$1(t[bi].accounts);
    vi.includes(bi) || (Me = S$4("NON_CONFORMING_NAMESPACES", `${Ie} namespaces accounts don't satisfy namespace accounts for ${bi}
        Required: ${bi}
        Approved: ${vi.toString()}`));
  }), Te.forEach((bi) => {
    Me || ($$2(Be[bi].methods, Pe[bi].methods) ? $$2(Be[bi].events, Pe[bi].events) || (Me = S$4("NON_CONFORMING_NAMESPACES", `${Ie} namespaces events don't satisfy namespace events for ${bi}`)) : Me = S$4("NON_CONFORMING_NAMESPACES", `${Ie} namespaces methods don't satisfy namespace methods for ${bi}`));
  }), Me;
}
function lo(Ae) {
  const t = {};
  return Object.keys(Ae).forEach((Ie) => {
    var Me;
    Ie.includes(":") ? t[Ie] = Ae[Ie] : (Me = Ae[Ie].chains) == null || Me.forEach((Be) => {
      t[Be] = { methods: Ae[Ie].methods, events: Ae[Ie].events };
    });
  }), t;
}
function Gn(Ae) {
  return [...new Set(Ae.map((t) => t.includes(":") ? t.split(":")[0] : t))];
}
function fo(Ae) {
  const t = {};
  return Object.keys(Ae).forEach((Ie) => {
    if (Ie.includes(":")) t[Ie] = Ae[Ie];
    else {
      const Me = C$1(Ae[Ie].accounts);
      Me == null || Me.forEach((Be) => {
        t[Be] = { accounts: Ae[Ie].accounts.filter((Pe) => Pe.includes(`${Be}:`)), methods: Ae[Ie].methods, events: Ae[Ie].events };
      });
    }
  }), t;
}
function po(Ae, t) {
  return X$1(Ae) && Ae <= t.max && Ae >= t.min;
}
function mo() {
  const Ae = P$2();
  return new Promise((t) => {
    switch (Ae) {
      case y$1.browser:
        t(Yn());
        break;
      case y$1.reactNative:
        t(Qn());
        break;
      case y$1.node:
        t(Zn());
        break;
      default:
        t(!0);
    }
  });
}
function Yn() {
  return V$3() && (navigator == null ? void 0 : navigator.onLine);
}
async function Qn() {
  if (_$1() && typeof global < "u" && global != null && global.NetInfo) {
    const Ae = await (global == null ? void 0 : global.NetInfo.fetch());
    return Ae == null ? void 0 : Ae.isConnected;
  }
  return !0;
}
function Zn() {
  return !0;
}
function ho(Ae) {
  switch (P$2()) {
    case y$1.browser:
      Xn(Ae);
      break;
    case y$1.reactNative:
      et$2(Ae);
      break;
  }
}
function Xn(Ae) {
  !_$1() && V$3() && (window.addEventListener("online", () => Ae(!0)), window.addEventListener("offline", () => Ae(!1)));
}
function et$2(Ae) {
  _$1() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener((t) => Ae(t == null ? void 0 : t.isConnected)));
}
const Re = {};
class yo {
  static get(t) {
    return Re[t];
  }
  static set(t, Ie) {
    Re[t] = Ie;
  }
  static delete(t) {
    delete Re[t];
  }
}
const PARSE_ERROR = "PARSE_ERROR", INVALID_REQUEST = "INVALID_REQUEST", METHOD_NOT_FOUND = "METHOD_NOT_FOUND", INVALID_PARAMS = "INVALID_PARAMS", INTERNAL_ERROR = "INTERNAL_ERROR", SERVER_ERROR = "SERVER_ERROR", RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603], STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
}, DEFAULT_ERROR = SERVER_ERROR;
function isReservedErrorCode(Ae) {
  return RESERVED_ERROR_CODES.includes(Ae);
}
function getError(Ae) {
  return Object.keys(STANDARD_ERROR_MAP).includes(Ae) ? STANDARD_ERROR_MAP[Ae] : STANDARD_ERROR_MAP[DEFAULT_ERROR];
}
function getErrorByCode(Ae) {
  const t = Object.values(STANDARD_ERROR_MAP).find((Ie) => Ie.code === Ae);
  return t || STANDARD_ERROR_MAP[DEFAULT_ERROR];
}
function parseConnectionError(Ae, t, Ie) {
  return Ae.message.includes("getaddrinfo ENOTFOUND") || Ae.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${Ie} RPC url at ${t}`) : Ae;
}
var cjs = {}, crypto$1 = {}, hasRequiredCrypto;
function requireCrypto() {
  if (hasRequiredCrypto) return crypto$1;
  hasRequiredCrypto = 1, Object.defineProperty(crypto$1, "__esModule", { value: !0 }), crypto$1.isBrowserCryptoAvailable = crypto$1.getSubtleCrypto = crypto$1.getBrowerCrypto = void 0;
  function Ae() {
    return (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.crypto) || (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.msCrypto) || {};
  }
  crypto$1.getBrowerCrypto = Ae;
  function t() {
    const Me = Ae();
    return Me.subtle || Me.webkitSubtle;
  }
  crypto$1.getSubtleCrypto = t;
  function Ie() {
    return !!Ae() && !!t();
  }
  return crypto$1.isBrowserCryptoAvailable = Ie, crypto$1;
}
var env = {}, hasRequiredEnv;
function requireEnv() {
  if (hasRequiredEnv) return env;
  hasRequiredEnv = 1, Object.defineProperty(env, "__esModule", { value: !0 }), env.isBrowser = env.isNode = env.isReactNative = void 0;
  function Ae() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  env.isReactNative = Ae;
  function t() {
    return typeof process$1 < "u" && typeof process$1.versions < "u" && typeof process$1.versions.node < "u";
  }
  env.isNode = t;
  function Ie() {
    return !Ae() && !t();
  }
  return env.isBrowser = Ie, env;
}
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  const t = require$$0$2;
  t.__exportStar(requireCrypto(), Ae), t.__exportStar(requireEnv(), Ae);
})(cjs);
function payloadId(Ae = 3) {
  const t = Date.now() * Math.pow(10, Ae), Ie = Math.floor(Math.random() * Math.pow(10, Ae));
  return t + Ie;
}
function getBigIntRpcId(Ae = 6) {
  return BigInt(payloadId(Ae));
}
function formatJsonRpcRequest(Ae, t, Ie) {
  return {
    id: Ie || payloadId(),
    jsonrpc: "2.0",
    method: Ae,
    params: t
  };
}
function formatJsonRpcResult(Ae, t) {
  return {
    id: Ae,
    jsonrpc: "2.0",
    result: t
  };
}
function formatJsonRpcError(Ae, t, Ie) {
  return {
    id: Ae,
    jsonrpc: "2.0",
    error: formatErrorMessage(t)
  };
}
function formatErrorMessage(Ae, t) {
  return typeof Ae > "u" ? getError(INTERNAL_ERROR) : (typeof Ae == "string" && (Ae = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: Ae })), isReservedErrorCode(Ae.code) && (Ae = getErrorByCode(Ae.code)), Ae);
}
class e {
}
class n extends e {
  constructor() {
    super();
  }
}
class r extends n {
  constructor(t) {
    super();
  }
}
const WS_REGEX = "^wss?:";
function getUrlProtocol(Ae) {
  const t = Ae.match(new RegExp(/^\w+:/, "gi"));
  if (!(!t || !t.length))
    return t[0];
}
function matchRegexProtocol(Ae, t) {
  const Ie = getUrlProtocol(Ae);
  return typeof Ie > "u" ? !1 : new RegExp(t).test(Ie);
}
function isWsUrl(Ae) {
  return matchRegexProtocol(Ae, WS_REGEX);
}
function isLocalhostUrl(Ae) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(Ae);
}
function isJsonRpcPayload(Ae) {
  return typeof Ae == "object" && "id" in Ae && "jsonrpc" in Ae && Ae.jsonrpc === "2.0";
}
function isJsonRpcRequest(Ae) {
  return isJsonRpcPayload(Ae) && "method" in Ae;
}
function isJsonRpcResponse(Ae) {
  return isJsonRpcPayload(Ae) && (isJsonRpcResult(Ae) || isJsonRpcError(Ae));
}
function isJsonRpcResult(Ae) {
  return "result" in Ae;
}
function isJsonRpcError(Ae) {
  return "error" in Ae;
}
let o$1 = class extends r {
  constructor(t) {
    super(t), this.events = new eventsExports.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(t), this.connection.connected && this.registerEventListeners();
  }
  async connect(t = this.connection) {
    await this.open(t);
  }
  async disconnect() {
    await this.close();
  }
  on(t, Ie) {
    this.events.on(t, Ie);
  }
  once(t, Ie) {
    this.events.once(t, Ie);
  }
  off(t, Ie) {
    this.events.off(t, Ie);
  }
  removeListener(t, Ie) {
    this.events.removeListener(t, Ie);
  }
  async request(t, Ie) {
    return this.requestStrict(formatJsonRpcRequest(t.method, t.params || [], t.id || getBigIntRpcId().toString()), Ie);
  }
  async requestStrict(t, Ie) {
    return new Promise(async (Me, Be) => {
      if (!this.connection.connected) try {
        await this.open();
      } catch (Pe) {
        Be(Pe);
      }
      this.events.on(`${t.id}`, (Pe) => {
        isJsonRpcError(Pe) ? Be(Pe.error) : Me(Pe.result);
      });
      try {
        await this.connection.send(t, Ie);
      } catch (Pe) {
        Be(Pe);
      }
    });
  }
  setConnection(t = this.connection) {
    return t;
  }
  onPayload(t) {
    this.events.emit("payload", t), isJsonRpcResponse(t) ? this.events.emit(`${t.id}`, t) : this.events.emit("message", { type: t.method, data: t.params });
  }
  onClose(t) {
    t && t.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${t.code} ${t.reason ? `(${t.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(t = this.connection) {
    this.connection === t && this.connection.connected || (this.connection.connected && this.close(), typeof t == "string" && (await this.connection.open(t), t = this.connection), this.connection = this.setConnection(t), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (t) => this.onPayload(t)), this.connection.on("close", (t) => this.onClose(t)), this.connection.on("error", (t) => this.events.emit("error", t)), this.connection.on("register_error", (t) => this.onClose()), this.hasRegisteredEventListeners = !0);
  }
};
const w$1 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"), b$1 = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", a = (Ae) => Ae.split("?")[0], h = 10, S$3 = w$1();
let f$2 = class {
  constructor(t) {
    if (this.url = t, this.events = new eventsExports.EventEmitter(), this.registering = !1, !isWsUrl(t)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${t}`);
    this.url = t;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(t, Ie) {
    this.events.on(t, Ie);
  }
  once(t, Ie) {
    this.events.once(t, Ie);
  }
  off(t, Ie) {
    this.events.off(t, Ie);
  }
  removeListener(t, Ie) {
    this.events.removeListener(t, Ie);
  }
  async open(t = this.url) {
    await this.register(t);
  }
  async close() {
    return new Promise((t, Ie) => {
      if (typeof this.socket > "u") {
        Ie(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (Me) => {
        this.onClose(Me), t();
      }, this.socket.close();
    });
  }
  async send(t) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(t));
    } catch (Ie) {
      this.onError(t.id, Ie);
    }
  }
  register(t = this.url) {
    if (!isWsUrl(t)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${t}`);
    if (this.registering) {
      const Ie = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= Ie || this.events.listenerCount("open") >= Ie) && this.events.setMaxListeners(Ie + 1), new Promise((Me, Be) => {
        this.events.once("register_error", (Pe) => {
          this.resetMaxListeners(), Be(Pe);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return Be(new Error("WebSocket connection is missing or invalid"));
          Me(this.socket);
        });
      });
    }
    return this.url = t, this.registering = !0, new Promise((Ie, Me) => {
      const Be = new URLSearchParams(t).get("origin"), Pe = cjs.isReactNative() ? { headers: { origin: Be } } : { rejectUnauthorized: !isLocalhostUrl(t) }, Te = new S$3(t, [], Pe);
      b$1() ? Te.onerror = (je) => {
        const Ve = je;
        Me(this.emitError(Ve.error));
      } : Te.on("error", (je) => {
        Me(this.emitError(je));
      }), Te.onopen = () => {
        this.onOpen(Te), Ie(Te);
      };
    });
  }
  onOpen(t) {
    t.onmessage = (Ie) => this.onPayload(Ie), t.onclose = (Ie) => this.onClose(Ie), this.socket = t, this.registering = !1, this.events.emit("open");
  }
  onClose(t) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", t);
  }
  onPayload(t) {
    if (typeof t.data > "u") return;
    const Ie = typeof t.data == "string" ? safeJsonParse(t.data) : t.data;
    this.events.emit("payload", Ie);
  }
  onError(t, Ie) {
    const Me = this.parseError(Ie), Be = Me.message || Me.toString(), Pe = formatJsonRpcError(t, Be);
    this.events.emit("payload", Pe);
  }
  parseError(t, Ie = this.url) {
    return parseConnectionError(t, a(Ie), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h && this.events.setMaxListeners(h);
  }
  emitError(t) {
    const Ie = this.parseError(new Error((t == null ? void 0 : t.message) || `WebSocket connection failed for host: ${a(this.url)}`));
    return this.events.emit("register_error", Ie), Ie;
  }
};
var lodash_isequal = { exports: {} };
lodash_isequal.exports;
(function(Ae, t) {
  var Ie = 200, Me = "__lodash_hash_undefined__", Be = 1, Pe = 2, Te = 9007199254740991, je = "[object Arguments]", Ve = "[object Array]", fi = "[object AsyncFunction]", Ue = "[object Boolean]", bi = "[object Date]", vi = "[object Error]", mi = "[object Function]", _i = "[object GeneratorFunction]", Ei = "[object Map]", Pi = "[object Number]", Ii = "[object Null]", Ci = "[object Object]", Wi = "[object Promise]", zi = "[object Proxy]", Xi = "[object RegExp]", Qi = "[object Set]", Oi = "[object String]", Yi = "[object Symbol]", ns = "[object Undefined]", ls = "[object WeakMap]", vn = "[object ArrayBuffer]", Mi = "[object DataView]", Ai = "[object Float32Array]", wi = "[object Float64Array]", $i = "[object Int8Array]", Li = "[object Int16Array]", qi = "[object Int32Array]", Ni = "[object Uint8Array]", Ti = "[object Uint8ClampedArray]", xi = "[object Uint16Array]", Fi = "[object Uint32Array]", Si = /[\\^$.*+?()[\]{}|]/g, Vi = /^\[object .+?Constructor\]$/, ts = /^(?:0|[1-9]\d*)$/, Hi = {};
  Hi[Ai] = Hi[wi] = Hi[$i] = Hi[Li] = Hi[qi] = Hi[Ni] = Hi[Ti] = Hi[xi] = Hi[Fi] = !0, Hi[je] = Hi[Ve] = Hi[vn] = Hi[Ue] = Hi[Mi] = Hi[bi] = Hi[vi] = Hi[mi] = Hi[Ei] = Hi[Pi] = Hi[Ci] = Hi[Xi] = Hi[Qi] = Hi[Oi] = Hi[ls] = !1;
  var fn = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, Bi = typeof self == "object" && self && self.Object === Object && self, ki = fn || Bi || Function("return this")(), Ji = t && !t.nodeType && t, Ri = Ji && !0 && Ae && !Ae.nodeType && Ae, ji = Ri && Ri.exports === Ji, Gi = ji && fn.process, is = function() {
    try {
      return Gi && Gi.binding && Gi.binding("util");
    } catch {
    }
  }(), os = is && is.isTypedArray;
  function ds(rs, cs) {
    for (var bs = -1, ba = rs == null ? 0 : rs.length, La = 0, Ca = []; ++bs < ba; ) {
      var Ua = rs[bs];
      cs(Ua, bs, rs) && (Ca[La++] = Ua);
    }
    return Ca;
  }
  function ps(rs, cs) {
    for (var bs = -1, ba = cs.length, La = rs.length; ++bs < ba; )
      rs[La + bs] = cs[bs];
    return rs;
  }
  function ea(rs, cs) {
    for (var bs = -1, ba = rs == null ? 0 : rs.length; ++bs < ba; )
      if (cs(rs[bs], bs, rs))
        return !0;
    return !1;
  }
  function ia(rs, cs) {
    for (var bs = -1, ba = Array(rs); ++bs < rs; )
      ba[bs] = cs(bs);
    return ba;
  }
  function hs(rs) {
    return function(cs) {
      return rs(cs);
    };
  }
  function fa(rs, cs) {
    return rs.has(cs);
  }
  function gs(rs, cs) {
    return rs == null ? void 0 : rs[cs];
  }
  function sa(rs) {
    var cs = -1, bs = Array(rs.size);
    return rs.forEach(function(ba, La) {
      bs[++cs] = [La, ba];
    }), bs;
  }
  function aa(rs, cs) {
    return function(bs) {
      return rs(cs(bs));
    };
  }
  function Ds(rs) {
    var cs = -1, bs = Array(rs.size);
    return rs.forEach(function(ba) {
      bs[++cs] = ba;
    }), bs;
  }
  var ra = Array.prototype, ca = Function.prototype, ta = Object.prototype, oa = ki["__core-js_shared__"], da = ca.toString, Zi = ta.hasOwnProperty, Ui = function() {
    var rs = /[^.]+$/.exec(oa && oa.keys && oa.keys.IE_PROTO || "");
    return rs ? "Symbol(src)_1." + rs : "";
  }(), Ki = ta.toString, En = RegExp(
    "^" + da.call(Zi).replace(Si, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), ss = ji ? ki.Buffer : void 0, as = ki.Symbol, us = ki.Uint8Array, ua = ta.propertyIsEnumerable, ma = ra.splice, na = as ? as.toStringTag : void 0, wa = Object.getOwnPropertySymbols, ga = ss ? ss.isBuffer : void 0, Ea = aa(Object.keys, Object), xa = Co(ki, "DataView"), $a = Co(ki, "Map"), la = Co(ki, "Promise"), Sa = Co(ki, "Set"), Aa = Co(ki, "WeakMap"), ha = Co(Object, "create"), Ma = Po(xa), Da = Po($a), va = Po(la), Ba = Po(Sa), Pa = Po(Aa), pa = as ? as.prototype : void 0, Ra = pa ? pa.valueOf : void 0;
  function _a(rs) {
    var cs = -1, bs = rs == null ? 0 : rs.length;
    for (this.clear(); ++cs < bs; ) {
      var ba = rs[cs];
      this.set(ba[0], ba[1]);
    }
  }
  function ya() {
    this.__data__ = ha ? ha(null) : {}, this.size = 0;
  }
  function qa(rs) {
    var cs = this.has(rs) && delete this.__data__[rs];
    return this.size -= cs ? 1 : 0, cs;
  }
  function Na(rs) {
    var cs = this.__data__;
    if (ha) {
      var bs = cs[rs];
      return bs === Me ? void 0 : bs;
    }
    return Zi.call(cs, rs) ? cs[rs] : void 0;
  }
  function Ia(rs) {
    var cs = this.__data__;
    return ha ? cs[rs] !== void 0 : Zi.call(cs, rs);
  }
  function Fa(rs, cs) {
    var bs = this.__data__;
    return this.size += this.has(rs) ? 0 : 1, bs[rs] = ha && cs === void 0 ? Me : cs, this;
  }
  _a.prototype.clear = ya, _a.prototype.delete = qa, _a.prototype.get = Na, _a.prototype.has = Ia, _a.prototype.set = Fa;
  function Oa(rs) {
    var cs = -1, bs = rs == null ? 0 : rs.length;
    for (this.clear(); ++cs < bs; ) {
      var ba = rs[cs];
      this.set(ba[0], ba[1]);
    }
  }
  function Ta() {
    this.__data__ = [], this.size = 0;
  }
  function Va(rs) {
    var cs = this.__data__, bs = Lo(cs, rs);
    if (bs < 0)
      return !1;
    var ba = cs.length - 1;
    return bs == ba ? cs.pop() : ma.call(cs, bs, 1), --this.size, !0;
  }
  function Ga(rs) {
    var cs = this.__data__, bs = Lo(cs, rs);
    return bs < 0 ? void 0 : cs[bs][1];
  }
  function Ja(rs) {
    return Lo(this.__data__, rs) > -1;
  }
  function Xa(rs, cs) {
    var bs = this.__data__, ba = Lo(bs, rs);
    return ba < 0 ? (++this.size, bs.push([rs, cs])) : bs[ba][1] = cs, this;
  }
  Oa.prototype.clear = Ta, Oa.prototype.delete = Va, Oa.prototype.get = Ga, Oa.prototype.has = Ja, Oa.prototype.set = Xa;
  function ja(rs) {
    var cs = -1, bs = rs == null ? 0 : rs.length;
    for (this.clear(); ++cs < bs; ) {
      var ba = rs[cs];
      this.set(ba[0], ba[1]);
    }
  }
  function go() {
    this.size = 0, this.__data__ = {
      hash: new _a(),
      map: new ($a || Oa)(),
      string: new _a()
    };
  }
  function wo(rs) {
    var cs = ko(this, rs).delete(rs);
    return this.size -= cs ? 1 : 0, cs;
  }
  function _o(rs) {
    return ko(this, rs).get(rs);
  }
  function Eo(rs) {
    return ko(this, rs).has(rs);
  }
  function $o(rs, cs) {
    var bs = ko(this, rs), ba = bs.size;
    return bs.set(rs, cs), this.size += bs.size == ba ? 0 : 1, this;
  }
  ja.prototype.clear = go, ja.prototype.delete = wo, ja.prototype.get = _o, ja.prototype.has = Eo, ja.prototype.set = $o;
  function Za(rs) {
    var cs = -1, bs = rs == null ? 0 : rs.length;
    for (this.__data__ = new ja(); ++cs < bs; )
      this.add(rs[cs]);
  }
  function xo(rs) {
    return this.__data__.set(rs, Me), this;
  }
  function So(rs) {
    return this.__data__.has(rs);
  }
  Za.prototype.add = Za.prototype.push = xo, Za.prototype.has = So;
  function Ha(rs) {
    var cs = this.__data__ = new Oa(rs);
    this.size = cs.size;
  }
  function Ao() {
    this.__data__ = new Oa(), this.size = 0;
  }
  function Ro(rs) {
    var cs = this.__data__, bs = cs.delete(rs);
    return this.size = cs.size, bs;
  }
  function Io(rs) {
    return this.__data__.get(rs);
  }
  function Oo(rs) {
    return this.__data__.has(rs);
  }
  function To(rs, cs) {
    var bs = this.__data__;
    if (bs instanceof Oa) {
      var ba = bs.__data__;
      if (!$a || ba.length < Ie - 1)
        return ba.push([rs, cs]), this.size = ++bs.size, this;
      bs = this.__data__ = new ja(ba);
    }
    return bs.set(rs, cs), this.size = bs.size, this;
  }
  Ha.prototype.clear = Ao, Ha.prototype.delete = Ro, Ha.prototype.get = Io, Ha.prototype.has = Oo, Ha.prototype.set = To;
  function sf(rs, cs) {
    var bs = Uo(rs), ba = !bs && wf(rs), La = !bs && !ba && Ko(rs), Ca = !bs && !ba && !La && Qo(rs), Ua = bs || ba || La || Ca, za = Ua ? ia(rs.length, String) : [], Ka = za.length;
    for (var ka in rs)
      Zi.call(rs, ka) && !(Ua && // Safari 9 has enumerable `arguments.length` in strict mode.
      (ka == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      La && (ka == "offset" || ka == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      Ca && (ka == "buffer" || ka == "byteLength" || ka == "byteOffset") || // Skip index properties.
      bf(ka, Ka))) && za.push(ka);
    return za;
  }
  function Lo(rs, cs) {
    for (var bs = rs.length; bs--; )
      if (Jo(rs[bs][0], cs))
        return bs;
    return -1;
  }
  function af(rs, cs, bs) {
    var ba = cs(rs);
    return Uo(rs) ? ba : ps(ba, bs(rs));
  }
  function No(rs) {
    return rs == null ? rs === void 0 ? ns : Ii : na && na in Object(rs) ? df(rs) : mf(rs);
  }
  function Ho(rs) {
    return Fo(rs) && No(rs) == je;
  }
  function Wo(rs, cs, bs, ba, La) {
    return rs === cs ? !0 : rs == null || cs == null || !Fo(rs) && !Fo(cs) ? rs !== rs && cs !== cs : of(rs, cs, bs, ba, Wo, La);
  }
  function of(rs, cs, bs, ba, La, Ca) {
    var Ua = Uo(rs), za = Uo(cs), Ka = Ua ? Ve : Do(rs), ka = za ? Ve : Do(cs);
    Ka = Ka == je ? Ci : Ka, ka = ka == je ? Ci : ka;
    var Ya = Ka == Ci, vo = ka == Ci, Wa = Ka == ka;
    if (Wa && Ko(rs)) {
      if (!Ko(cs))
        return !1;
      Ua = !0, Ya = !1;
    }
    if (Wa && !Ya)
      return Ca || (Ca = new Ha()), Ua || Qo(rs) ? Vo(rs, cs, bs, ba, La, Ca) : hf(rs, cs, Ka, bs, ba, La, Ca);
    if (!(bs & Be)) {
      var Qa = Ya && Zi.call(rs, "__wrapped__"), bo = vo && Zi.call(cs, "__wrapped__");
      if (Qa || bo) {
        var Bo = Qa ? rs.value() : rs, Mo = bo ? cs.value() : cs;
        return Ca || (Ca = new Ha()), La(Bo, Mo, bs, ba, Ca);
      }
    }
    return Wa ? (Ca || (Ca = new Ha()), lf(rs, cs, bs, ba, La, Ca)) : !1;
  }
  function ff(rs) {
    if (!Zo(rs) || yf(rs))
      return !1;
    var cs = Xo(rs) ? En : Vi;
    return cs.test(Po(rs));
  }
  function cf(rs) {
    return Fo(rs) && Yo(rs.length) && !!Hi[No(rs)];
  }
  function uf(rs) {
    if (!gf(rs))
      return Ea(rs);
    var cs = [];
    for (var bs in Object(rs))
      Zi.call(rs, bs) && bs != "constructor" && cs.push(bs);
    return cs;
  }
  function Vo(rs, cs, bs, ba, La, Ca) {
    var Ua = bs & Be, za = rs.length, Ka = cs.length;
    if (za != Ka && !(Ua && Ka > za))
      return !1;
    var ka = Ca.get(rs);
    if (ka && Ca.get(cs))
      return ka == cs;
    var Ya = -1, vo = !0, Wa = bs & Pe ? new Za() : void 0;
    for (Ca.set(rs, cs), Ca.set(cs, rs); ++Ya < za; ) {
      var Qa = rs[Ya], bo = cs[Ya];
      if (ba)
        var Bo = Ua ? ba(bo, Qa, Ya, cs, rs, Ca) : ba(Qa, bo, Ya, rs, cs, Ca);
      if (Bo !== void 0) {
        if (Bo)
          continue;
        vo = !1;
        break;
      }
      if (Wa) {
        if (!ea(cs, function(Mo, qo) {
          if (!fa(Wa, qo) && (Qa === Mo || La(Qa, Mo, bs, ba, Ca)))
            return Wa.push(qo);
        })) {
          vo = !1;
          break;
        }
      } else if (!(Qa === bo || La(Qa, bo, bs, ba, Ca))) {
        vo = !1;
        break;
      }
    }
    return Ca.delete(rs), Ca.delete(cs), vo;
  }
  function hf(rs, cs, bs, ba, La, Ca, Ua) {
    switch (bs) {
      case Mi:
        if (rs.byteLength != cs.byteLength || rs.byteOffset != cs.byteOffset)
          return !1;
        rs = rs.buffer, cs = cs.buffer;
      case vn:
        return !(rs.byteLength != cs.byteLength || !Ca(new us(rs), new us(cs)));
      case Ue:
      case bi:
      case Pi:
        return Jo(+rs, +cs);
      case vi:
        return rs.name == cs.name && rs.message == cs.message;
      case Xi:
      case Oi:
        return rs == cs + "";
      case Ei:
        var za = sa;
      case Qi:
        var Ka = ba & Be;
        if (za || (za = Ds), rs.size != cs.size && !Ka)
          return !1;
        var ka = Ua.get(rs);
        if (ka)
          return ka == cs;
        ba |= Pe, Ua.set(rs, cs);
        var Ya = Vo(za(rs), za(cs), ba, La, Ca, Ua);
        return Ua.delete(rs), Ya;
      case Yi:
        if (Ra)
          return Ra.call(rs) == Ra.call(cs);
    }
    return !1;
  }
  function lf(rs, cs, bs, ba, La, Ca) {
    var Ua = bs & Be, za = Go(rs), Ka = za.length, ka = Go(cs), Ya = ka.length;
    if (Ka != Ya && !Ua)
      return !1;
    for (var vo = Ka; vo--; ) {
      var Wa = za[vo];
      if (!(Ua ? Wa in cs : Zi.call(cs, Wa)))
        return !1;
    }
    var Qa = Ca.get(rs);
    if (Qa && Ca.get(cs))
      return Qa == cs;
    var bo = !0;
    Ca.set(rs, cs), Ca.set(cs, rs);
    for (var Bo = Ua; ++vo < Ka; ) {
      Wa = za[vo];
      var Mo = rs[Wa], qo = cs[Wa];
      if (ba)
        var ef = Ua ? ba(qo, Mo, Wa, cs, rs, Ca) : ba(Mo, qo, Wa, rs, cs, Ca);
      if (!(ef === void 0 ? Mo === qo || La(Mo, qo, bs, ba, Ca) : ef)) {
        bo = !1;
        break;
      }
      Bo || (Bo = Wa == "constructor");
    }
    if (bo && !Bo) {
      var jo = rs.constructor, zo = cs.constructor;
      jo != zo && "constructor" in rs && "constructor" in cs && !(typeof jo == "function" && jo instanceof jo && typeof zo == "function" && zo instanceof zo) && (bo = !1);
    }
    return Ca.delete(rs), Ca.delete(cs), bo;
  }
  function Go(rs) {
    return af(rs, $f, pf);
  }
  function ko(rs, cs) {
    var bs = rs.__data__;
    return vf(cs) ? bs[typeof cs == "string" ? "string" : "hash"] : bs.map;
  }
  function Co(rs, cs) {
    var bs = gs(rs, cs);
    return ff(bs) ? bs : void 0;
  }
  function df(rs) {
    var cs = Zi.call(rs, na), bs = rs[na];
    try {
      rs[na] = void 0;
      var ba = !0;
    } catch {
    }
    var La = Ki.call(rs);
    return ba && (cs ? rs[na] = bs : delete rs[na]), La;
  }
  var pf = wa ? function(rs) {
    return rs == null ? [] : (rs = Object(rs), ds(wa(rs), function(cs) {
      return ua.call(rs, cs);
    }));
  } : xf, Do = No;
  (xa && Do(new xa(new ArrayBuffer(1))) != Mi || $a && Do(new $a()) != Ei || la && Do(la.resolve()) != Wi || Sa && Do(new Sa()) != Qi || Aa && Do(new Aa()) != ls) && (Do = function(rs) {
    var cs = No(rs), bs = cs == Ci ? rs.constructor : void 0, ba = bs ? Po(bs) : "";
    if (ba)
      switch (ba) {
        case Ma:
          return Mi;
        case Da:
          return Ei;
        case va:
          return Wi;
        case Ba:
          return Qi;
        case Pa:
          return ls;
      }
    return cs;
  });
  function bf(rs, cs) {
    return cs = cs ?? Te, !!cs && (typeof rs == "number" || ts.test(rs)) && rs > -1 && rs % 1 == 0 && rs < cs;
  }
  function vf(rs) {
    var cs = typeof rs;
    return cs == "string" || cs == "number" || cs == "symbol" || cs == "boolean" ? rs !== "__proto__" : rs === null;
  }
  function yf(rs) {
    return !!Ui && Ui in rs;
  }
  function gf(rs) {
    var cs = rs && rs.constructor, bs = typeof cs == "function" && cs.prototype || ta;
    return rs === bs;
  }
  function mf(rs) {
    return Ki.call(rs);
  }
  function Po(rs) {
    if (rs != null) {
      try {
        return da.call(rs);
      } catch {
      }
      try {
        return rs + "";
      } catch {
      }
    }
    return "";
  }
  function Jo(rs, cs) {
    return rs === cs || rs !== rs && cs !== cs;
  }
  var wf = Ho(/* @__PURE__ */ function() {
    return arguments;
  }()) ? Ho : function(rs) {
    return Fo(rs) && Zi.call(rs, "callee") && !ua.call(rs, "callee");
  }, Uo = Array.isArray;
  function _f(rs) {
    return rs != null && Yo(rs.length) && !Xo(rs);
  }
  var Ko = ga || Sf;
  function Ef(rs, cs) {
    return Wo(rs, cs);
  }
  function Xo(rs) {
    if (!Zo(rs))
      return !1;
    var cs = No(rs);
    return cs == mi || cs == _i || cs == fi || cs == zi;
  }
  function Yo(rs) {
    return typeof rs == "number" && rs > -1 && rs % 1 == 0 && rs <= Te;
  }
  function Zo(rs) {
    var cs = typeof rs;
    return rs != null && (cs == "object" || cs == "function");
  }
  function Fo(rs) {
    return rs != null && typeof rs == "object";
  }
  var Qo = os ? hs(os) : cf;
  function $f(rs) {
    return _f(rs) ? sf(rs) : uf(rs);
  }
  function xf() {
    return [];
  }
  function Sf() {
    return !1;
  }
  Ae.exports = Ef;
})(lodash_isequal, lodash_isequal.exports);
var lodash_isequalExports = lodash_isequal.exports;
const ys$1 = /* @__PURE__ */ getDefaultExportFromCjs(lodash_isequalExports), ye$2 = "wc", De$1 = 2, ie$2 = "core", x$3 = `${ye$2}@2:${ie$2}:`, Ye = { name: ie$2, logger: "error" }, Je = { database: ":memory:" }, Xe = "crypto", me$2 = "client_ed25519_seed", We$1 = cjs$3.ONE_DAY, Ze$1 = "keychain", Qe = "0.3", et$1 = "messages", tt$1 = "0.3", it$2 = cjs$3.SIX_HOURS, st$2 = "publisher", rt$2 = "irn", nt$2 = "error", be$2 = "wss://relay.walletconnect.org", ot$2 = "relayer", v$2 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" }, at$2 = "_subscription", I$2 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, ht$2 = 0.1, se$2 = "2.17.1", M$1 = { link_mode: "link_mode", relay: "relay" }, ct$2 = "0.3", lt$2 = "WALLETCONNECT_CLIENT_ID", fe$1 = "WALLETCONNECT_LINK_MODE_APPS", O$2 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, ut$2 = "subscription", dt$2 = "0.3", pt$2 = cjs$3.FIVE_SECONDS * 1e3, gt$2 = "pairing", yt$2 = "0.3", B$2 = { wc_pairingDelete: { req: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: cjs$3.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: cjs$3.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 0 } } }, V$2 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" }, P$1 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, Dt$1 = "history", mt$1 = "0.3", bt$1 = "expirer", S$2 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, ft$1 = "0.3", _t$1 = "verify-api", vs$1 = "https://verify.walletconnect.com", Et$1 = "https://verify.walletconnect.org", J$1 = Et$1, vt$1 = `${J$1}/v3`, wt$1 = [vs$1, Et$1], It$1 = "echo", Tt$1 = "https://echo.walletconnect.com", z$3 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" }, $$1 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" }, Is$1 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" }, Ts$1 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" }, Cs = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" }, Ps$1 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" }, Ct$1 = 0.1, Pt$1 = "event-client", St$1 = 86400, Rt$1 = "https://pulse.walletconnect.org/batch";
function Ss$1(Ae, t) {
  if (Ae.length >= 255) throw new TypeError("Alphabet too long");
  for (var Ie = new Uint8Array(256), Me = 0; Me < Ie.length; Me++) Ie[Me] = 255;
  for (var Be = 0; Be < Ae.length; Be++) {
    var Pe = Ae.charAt(Be), Te = Pe.charCodeAt(0);
    if (Ie[Te] !== 255) throw new TypeError(Pe + " is ambiguous");
    Ie[Te] = Be;
  }
  var je = Ae.length, Ve = Ae.charAt(0), fi = Math.log(je) / Math.log(256), Ue = Math.log(256) / Math.log(je);
  function bi(_i) {
    if (_i instanceof Uint8Array || (ArrayBuffer.isView(_i) ? _i = new Uint8Array(_i.buffer, _i.byteOffset, _i.byteLength) : Array.isArray(_i) && (_i = Uint8Array.from(_i))), !(_i instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (_i.length === 0) return "";
    for (var Ei = 0, Pi = 0, Ii = 0, Ci = _i.length; Ii !== Ci && _i[Ii] === 0; ) Ii++, Ei++;
    for (var Wi = (Ci - Ii) * Ue + 1 >>> 0, zi = new Uint8Array(Wi); Ii !== Ci; ) {
      for (var Xi = _i[Ii], Qi = 0, Oi = Wi - 1; (Xi !== 0 || Qi < Pi) && Oi !== -1; Oi--, Qi++) Xi += 256 * zi[Oi] >>> 0, zi[Oi] = Xi % je >>> 0, Xi = Xi / je >>> 0;
      if (Xi !== 0) throw new Error("Non-zero carry");
      Pi = Qi, Ii++;
    }
    for (var Yi = Wi - Pi; Yi !== Wi && zi[Yi] === 0; ) Yi++;
    for (var ns = Ve.repeat(Ei); Yi < Wi; ++Yi) ns += Ae.charAt(zi[Yi]);
    return ns;
  }
  function vi(_i) {
    if (typeof _i != "string") throw new TypeError("Expected String");
    if (_i.length === 0) return new Uint8Array();
    var Ei = 0;
    if (_i[Ei] !== " ") {
      for (var Pi = 0, Ii = 0; _i[Ei] === Ve; ) Pi++, Ei++;
      for (var Ci = (_i.length - Ei) * fi + 1 >>> 0, Wi = new Uint8Array(Ci); _i[Ei]; ) {
        var zi = Ie[_i.charCodeAt(Ei)];
        if (zi === 255) return;
        for (var Xi = 0, Qi = Ci - 1; (zi !== 0 || Xi < Ii) && Qi !== -1; Qi--, Xi++) zi += je * Wi[Qi] >>> 0, Wi[Qi] = zi % 256 >>> 0, zi = zi / 256 >>> 0;
        if (zi !== 0) throw new Error("Non-zero carry");
        Ii = Xi, Ei++;
      }
      if (_i[Ei] !== " ") {
        for (var Oi = Ci - Ii; Oi !== Ci && Wi[Oi] === 0; ) Oi++;
        for (var Yi = new Uint8Array(Pi + (Ci - Oi)), ns = Pi; Oi !== Ci; ) Yi[ns++] = Wi[Oi++];
        return Yi;
      }
    }
  }
  function mi(_i) {
    var Ei = vi(_i);
    if (Ei) return Ei;
    throw new Error(`Non-${t} character`);
  }
  return { encode: bi, decodeUnsafe: vi, decode: mi };
}
var Rs$1 = Ss$1, xs = Rs$1;
const xt$1 = (Ae) => {
  if (Ae instanceof Uint8Array && Ae.constructor.name === "Uint8Array") return Ae;
  if (Ae instanceof ArrayBuffer) return new Uint8Array(Ae);
  if (ArrayBuffer.isView(Ae)) return new Uint8Array(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  throw new Error("Unknown type, must be binary type");
}, Os = (Ae) => new TextEncoder().encode(Ae), As = (Ae) => new TextDecoder().decode(Ae);
let Ns$1 = class {
  constructor(t, Ie, Me) {
    this.name = t, this.prefix = Ie, this.baseEncode = Me;
  }
  encode(t) {
    if (t instanceof Uint8Array) return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
};
class zs {
  constructor(t, Ie, Me) {
    if (this.name = t, this.prefix = Ie, Ie.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = Ie.codePointAt(0), this.baseDecode = Me;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(t) {
    return Ot$1(this, t);
  }
}
class Ls {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return Ot$1(this, t);
  }
  decode(t) {
    const Ie = t[0], Me = this.decoders[Ie];
    if (Me) return Me.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const Ot$1 = (Ae, t) => new Ls({ ...Ae.decoders || { [Ae.prefix]: Ae }, ...t.decoders || { [t.prefix]: t } });
class $s {
  constructor(t, Ie, Me, Be) {
    this.name = t, this.prefix = Ie, this.baseEncode = Me, this.baseDecode = Be, this.encoder = new Ns$1(t, Ie, Me), this.decoder = new zs(t, Ie, Be);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
}
const re$1 = ({ name: Ae, prefix: t, encode: Ie, decode: Me }) => new $s(Ae, t, Ie, Me), X = ({ prefix: Ae, name: t, alphabet: Ie }) => {
  const { encode: Me, decode: Be } = xs(Ie, t);
  return re$1({ prefix: Ae, name: t, encode: Me, decode: (Pe) => xt$1(Be(Pe)) });
}, ks = (Ae, t, Ie, Me) => {
  const Be = {};
  for (let Ue = 0; Ue < t.length; ++Ue) Be[t[Ue]] = Ue;
  let Pe = Ae.length;
  for (; Ae[Pe - 1] === "="; ) --Pe;
  const Te = new Uint8Array(Pe * Ie / 8 | 0);
  let je = 0, Ve = 0, fi = 0;
  for (let Ue = 0; Ue < Pe; ++Ue) {
    const bi = Be[Ae[Ue]];
    if (bi === void 0) throw new SyntaxError(`Non-${Me} character`);
    Ve = Ve << Ie | bi, je += Ie, je >= 8 && (je -= 8, Te[fi++] = 255 & Ve >> je);
  }
  if (je >= Ie || 255 & Ve << 8 - je) throw new SyntaxError("Unexpected end of data");
  return Te;
}, Ms = (Ae, t, Ie) => {
  const Me = t[t.length - 1] === "=", Be = (1 << Ie) - 1;
  let Pe = "", Te = 0, je = 0;
  for (let Ve = 0; Ve < Ae.length; ++Ve) for (je = je << 8 | Ae[Ve], Te += 8; Te > Ie; ) Te -= Ie, Pe += t[Be & je >> Te];
  if (Te && (Pe += t[Be & je << Ie - Te]), Me) for (; Pe.length * Ie & 7; ) Pe += "=";
  return Pe;
}, f$1 = ({ name: Ae, prefix: t, bitsPerChar: Ie, alphabet: Me }) => re$1({ prefix: t, name: Ae, encode(Be) {
  return Ms(Be, Me, Ie);
}, decode(Be) {
  return ks(Be, Me, Ie, Ae);
} }), Us = re$1({ prefix: "\0", name: "identity", encode: (Ae) => As(Ae), decode: (Ae) => Os(Ae) });
var Fs = Object.freeze({ __proto__: null, identity: Us });
const Ks = f$1({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Bs = Object.freeze({ __proto__: null, base2: Ks });
const Vs = f$1({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var js = Object.freeze({ __proto__: null, base8: Vs });
const qs$1 = X({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Gs = Object.freeze({ __proto__: null, base10: qs$1 });
const Hs = f$1({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), Ys = f$1({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Js = Object.freeze({ __proto__: null, base16: Hs, base16upper: Ys });
const Xs = f$1({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), Ws = f$1({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), Zs = f$1({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), Qs = f$1({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), er$1 = f$1({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), tr$1 = f$1({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), ir$1 = f$1({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), sr$1 = f$1({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), rr$1 = f$1({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var nr$1 = Object.freeze({ __proto__: null, base32: Xs, base32upper: Ws, base32pad: Zs, base32padupper: Qs, base32hex: er$1, base32hexupper: tr$1, base32hexpad: ir$1, base32hexpadupper: sr$1, base32z: rr$1 });
const or$1 = X({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), ar$1 = X({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var hr$1 = Object.freeze({ __proto__: null, base36: or$1, base36upper: ar$1 });
const cr$1 = X({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), lr$1 = X({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var ur$1 = Object.freeze({ __proto__: null, base58btc: cr$1, base58flickr: lr$1 });
const dr$1 = f$1({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), pr$1 = f$1({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), gr$1 = f$1({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), yr$1 = f$1({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Dr$1 = Object.freeze({ __proto__: null, base64: dr$1, base64pad: pr$1, base64url: gr$1, base64urlpad: yr$1 });
const At$1 = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), mr$1 = At$1.reduce((Ae, t, Ie) => (Ae[Ie] = t, Ae), []), br$1 = At$1.reduce((Ae, t, Ie) => (Ae[t.codePointAt(0)] = Ie, Ae), []);
function fr$1(Ae) {
  return Ae.reduce((t, Ie) => (t += mr$1[Ie], t), "");
}
function _r$1(Ae) {
  const t = [];
  for (const Ie of Ae) {
    const Me = br$1[Ie.codePointAt(0)];
    if (Me === void 0) throw new Error(`Non-base256emoji character: ${Ie}`);
    t.push(Me);
  }
  return new Uint8Array(t);
}
const Er$1 = re$1({ prefix: "🚀", name: "base256emoji", encode: fr$1, decode: _r$1 });
var vr$1 = Object.freeze({ __proto__: null, base256emoji: Er$1 }), wr$1 = zt$1, Nt$1 = 128, Ir = 127, Tr$1 = ~Ir, Cr$1 = Math.pow(2, 31);
function zt$1(Ae, t, Ie) {
  t = t || [], Ie = Ie || 0;
  for (var Me = Ie; Ae >= Cr$1; ) t[Ie++] = Ae & 255 | Nt$1, Ae /= 128;
  for (; Ae & Tr$1; ) t[Ie++] = Ae & 255 | Nt$1, Ae >>>= 7;
  return t[Ie] = Ae | 0, zt$1.bytes = Ie - Me + 1, t;
}
var Pr$1 = _e$1, Sr$1 = 128, Lt$1 = 127;
function _e$1(Ae, Me) {
  var Ie = 0, Me = Me || 0, Be = 0, Pe = Me, Te, je = Ae.length;
  do {
    if (Pe >= je) throw _e$1.bytes = 0, new RangeError("Could not decode varint");
    Te = Ae[Pe++], Ie += Be < 28 ? (Te & Lt$1) << Be : (Te & Lt$1) * Math.pow(2, Be), Be += 7;
  } while (Te >= Sr$1);
  return _e$1.bytes = Pe - Me, Ie;
}
var Rr$1 = Math.pow(2, 7), xr$1 = Math.pow(2, 14), Or$1 = Math.pow(2, 21), Ar$1 = Math.pow(2, 28), Nr$1 = Math.pow(2, 35), zr$1 = Math.pow(2, 42), Lr = Math.pow(2, 49), $r$1 = Math.pow(2, 56), kr = Math.pow(2, 63), Mr = function(Ae) {
  return Ae < Rr$1 ? 1 : Ae < xr$1 ? 2 : Ae < Or$1 ? 3 : Ae < Ar$1 ? 4 : Ae < Nr$1 ? 5 : Ae < zr$1 ? 6 : Ae < Lr ? 7 : Ae < $r$1 ? 8 : Ae < kr ? 9 : 10;
}, Ur = { encode: wr$1, decode: Pr$1, encodingLength: Mr }, $t$1 = Ur;
const kt$1 = (Ae, t, Ie = 0) => ($t$1.encode(Ae, t, Ie), t), Mt$1 = (Ae) => $t$1.encodingLength(Ae), Ee$1 = (Ae, t) => {
  const Ie = t.byteLength, Me = Mt$1(Ae), Be = Me + Mt$1(Ie), Pe = new Uint8Array(Be + Ie);
  return kt$1(Ae, Pe, 0), kt$1(Ie, Pe, Me), Pe.set(t, Be), new Fr$1(Ae, Ie, t, Pe);
};
let Fr$1 = class {
  constructor(t, Ie, Me, Be) {
    this.code = t, this.size = Ie, this.digest = Me, this.bytes = Be;
  }
};
const Ut$1 = ({ name: Ae, code: t, encode: Ie }) => new Kr(Ae, t, Ie);
class Kr {
  constructor(t, Ie, Me) {
    this.name = t, this.code = Ie, this.encode = Me;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const Ie = this.encode(t);
      return Ie instanceof Uint8Array ? Ee$1(this.code, Ie) : Ie.then((Me) => Ee$1(this.code, Me));
    } else throw Error("Unknown type, must be binary type");
  }
}
const Ft$1 = (Ae) => async (t) => new Uint8Array(await crypto.subtle.digest(Ae, t)), Br$1 = Ut$1({ name: "sha2-256", code: 18, encode: Ft$1("SHA-256") }), Vr = Ut$1({ name: "sha2-512", code: 19, encode: Ft$1("SHA-512") });
var jr = Object.freeze({ __proto__: null, sha256: Br$1, sha512: Vr });
const Kt$1 = 0, qr = "identity", Bt$1 = xt$1, Gr = (Ae) => Ee$1(Kt$1, Bt$1(Ae)), Hr = { code: Kt$1, name: qr, encode: Bt$1, digest: Gr };
var Yr = Object.freeze({ __proto__: null, identity: Hr });
new TextEncoder(), new TextDecoder();
const Vt$1 = { ...Fs, ...Bs, ...js, ...Gs, ...Js, ...nr$1, ...hr$1, ...ur$1, ...Dr$1, ...vr$1 };
({ ...jr, ...Yr });
function Jr(Ae = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(Ae) : new Uint8Array(Ae);
}
function jt$1(Ae, t, Ie, Me) {
  return { name: Ae, prefix: t, encoder: { name: Ae, prefix: t, encode: Ie }, decoder: { decode: Me } };
}
const qt$1 = jt$1("utf8", "u", (Ae) => "u" + new TextDecoder("utf8").decode(Ae), (Ae) => new TextEncoder().encode(Ae.substring(1))), ve = jt$1("ascii", "a", (Ae) => {
  let t = "a";
  for (let Ie = 0; Ie < Ae.length; Ie++) t += String.fromCharCode(Ae[Ie]);
  return t;
}, (Ae) => {
  Ae = Ae.substring(1);
  const t = Jr(Ae.length);
  for (let Ie = 0; Ie < Ae.length; Ie++) t[Ie] = Ae.charCodeAt(Ie);
  return t;
}), Xr = { utf8: qt$1, "utf-8": qt$1, hex: Vt$1.base16, latin1: ve, ascii: ve, binary: ve, ...Vt$1 };
function Wr(Ae, t = "utf8") {
  const Ie = Xr[t];
  if (!Ie) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(Ae, "utf8") : Ie.decoder.decode(`${Ie.prefix}${Ae}`);
}
let Gt$1 = class {
  constructor(t, Ie) {
    this.core = t, this.logger = Ie, this.keychain = /* @__PURE__ */ new Map(), this.name = Ze$1, this.version = Qe, this.initialized = !1, this.storagePrefix = x$3, this.init = async () => {
      if (!this.initialized) {
        const Me = await this.getKeyChain();
        typeof Me < "u" && (this.keychain = Me), this.initialized = !0;
      }
    }, this.has = (Me) => (this.isInitialized(), this.keychain.has(Me)), this.set = async (Me, Be) => {
      this.isInitialized(), this.keychain.set(Me, Be), await this.persist();
    }, this.get = (Me) => {
      this.isInitialized();
      const Be = this.keychain.get(Me);
      if (typeof Be > "u") {
        const { message: Pe } = S$4("NO_MATCHING_KEY", `${this.name}: ${Me}`);
        throw new Error(Pe);
      }
      return Be;
    }, this.del = async (Me) => {
      this.isInitialized(), this.keychain.delete(Me), await this.persist();
    }, this.core = t, this.logger = E$1(Ie, this.name);
  }
  get context() {
    return y$3(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(t) {
    await this.core.storage.setItem(this.storageKey, Tt$2(t));
  }
  async getKeyChain() {
    const t = await this.core.storage.getItem(this.storageKey);
    return typeof t < "u" ? Pt$2(t) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}, Ht$1 = class {
  constructor(t, Ie, Me) {
    this.core = t, this.logger = Ie, this.name = Xe, this.randomSessionIdentifier = pr$2(), this.initialized = !1, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0);
    }, this.hasKeys = (Be) => (this.isInitialized(), this.keychain.has(Be)), this.getClientId = async () => {
      this.isInitialized();
      const Be = await this.getClientSeed(), Pe = generateKeyPair(Be);
      return encodeIss(Pe.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const Be = fr$2();
      return this.setPrivateKey(Be.publicKey, Be.privateKey);
    }, this.signJWT = async (Be) => {
      this.isInitialized();
      const Pe = await this.getClientSeed(), Te = generateKeyPair(Pe), je = this.randomSessionIdentifier;
      return await signJWT(je, Be, We$1, Te);
    }, this.generateSharedKey = (Be, Pe, Te) => {
      this.isInitialized();
      const je = this.getPrivateKey(Be), Ve = mr$2(je, Pe);
      return this.setSymKey(Ve, Te);
    }, this.setSymKey = async (Be, Pe) => {
      this.isInitialized();
      const Te = Pe || hr$2(Be);
      return await this.keychain.set(Te, Be), Te;
    }, this.deleteKeyPair = async (Be) => {
      this.isInitialized(), await this.keychain.del(Be);
    }, this.deleteSymKey = async (Be) => {
      this.isInitialized(), await this.keychain.del(Be);
    }, this.encode = async (Be, Pe, Te) => {
      this.isInitialized();
      const je = On(Te), Ve = safeJsonStringify(Pe);
      if (Nr$2(je)) return vr$2(Ve, Te == null ? void 0 : Te.encoding);
      if (Or$2(je)) {
        const vi = je.senderPublicKey, mi = je.receiverPublicKey;
        Be = await this.generateSharedKey(vi, mi);
      }
      const fi = this.getSymKey(Be), { type: Ue, senderPublicKey: bi } = je;
      return gr$2({ type: Ue, symKey: fi, message: Ve, senderPublicKey: bi, encoding: Te == null ? void 0 : Te.encoding });
    }, this.decode = async (Be, Pe, Te) => {
      this.isInitialized();
      const je = wr$2(Pe, Te);
      if (Nr$2(je)) {
        const Ve = Er$2(Pe, Te == null ? void 0 : Te.encoding);
        return safeJsonParse(Ve);
      }
      if (Or$2(je)) {
        const Ve = je.receiverPublicKey, fi = je.senderPublicKey;
        Be = await this.generateSharedKey(Ve, fi);
      }
      try {
        const Ve = this.getSymKey(Be), fi = br$2({ symKey: Ve, encoded: Pe, encoding: Te == null ? void 0 : Te.encoding });
        return safeJsonParse(fi);
      } catch (Ve) {
        this.logger.error(`Failed to decode message from topic: '${Be}', clientId: '${await this.getClientId()}'`), this.logger.error(Ve);
      }
    }, this.getPayloadType = (Be, Pe = ge$1) => {
      const Te = Q$1({ encoded: Be, encoding: Pe });
      return A(Te.type);
    }, this.getPayloadSenderPublicKey = (Be, Pe = ge$1) => {
      const Te = Q$1({ encoded: Be, encoding: Pe });
      return Te.senderPublicKey ? toString(Te.senderPublicKey, g$1) : void 0;
    }, this.core = t, this.logger = E$1(Ie, this.name), this.keychain = Me || new Gt$1(this.core, this.logger);
  }
  get context() {
    return y$3(this.logger);
  }
  async setPrivateKey(t, Ie) {
    return await this.keychain.set(t, Ie), t;
  }
  getPrivateKey(t) {
    return this.keychain.get(t);
  }
  async getClientSeed() {
    let t = "";
    try {
      t = this.keychain.get(me$2);
    } catch {
      t = pr$2(), await this.keychain.set(me$2, t);
    }
    return Wr(t, "base16");
  }
  getSymKey(t) {
    return this.keychain.get(t);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}, Yt$1 = class extends a$1 {
  constructor(t, Ie) {
    super(t, Ie), this.logger = t, this.core = Ie, this.messages = /* @__PURE__ */ new Map(), this.name = et$1, this.version = tt$1, this.initialized = !1, this.storagePrefix = x$3, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const Me = await this.getRelayerMessages();
          typeof Me < "u" && (this.messages = Me), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (Me) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(Me);
        } finally {
          this.initialized = !0;
        }
      }
    }, this.set = async (Me, Be) => {
      this.isInitialized();
      const Pe = yr$2(Be);
      let Te = this.messages.get(Me);
      return typeof Te > "u" && (Te = {}), typeof Te[Pe] < "u" || (Te[Pe] = Be, this.messages.set(Me, Te), await this.persist()), Pe;
    }, this.get = (Me) => {
      this.isInitialized();
      let Be = this.messages.get(Me);
      return typeof Be > "u" && (Be = {}), Be;
    }, this.has = (Me, Be) => {
      this.isInitialized();
      const Pe = this.get(Me), Te = yr$2(Be);
      return typeof Pe[Te] < "u";
    }, this.del = async (Me) => {
      this.isInitialized(), this.messages.delete(Me), await this.persist();
    }, this.logger = E$1(t, this.name), this.core = Ie;
  }
  get context() {
    return y$3(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(t) {
    await this.core.storage.setItem(this.storageKey, Tt$2(t));
  }
  async getRelayerMessages() {
    const t = await this.core.storage.getItem(this.storageKey);
    return typeof t < "u" ? Pt$2(t) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
};
class Zr extends g$2 {
  constructor(t, Ie) {
    super(t, Ie), this.relayer = t, this.logger = Ie, this.events = new eventsExports.EventEmitter(), this.name = st$2, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = cjs$3.toMiliseconds(cjs$3.ONE_MINUTE), this.failedPublishTimeout = cjs$3.toMiliseconds(cjs$3.ONE_SECOND), this.needsTransportRestart = !1, this.publish = async (Me, Be, Pe) => {
      var Te;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: Me, message: Be, opts: Pe } });
      const je = (Pe == null ? void 0 : Pe.ttl) || it$2, Ve = Ir$1(Pe), fi = (Pe == null ? void 0 : Pe.prompt) || !1, Ue = (Pe == null ? void 0 : Pe.tag) || 0, bi = (Pe == null ? void 0 : Pe.id) || getBigIntRpcId().toString(), vi = { topic: Me, message: Be, opts: { ttl: je, relay: Ve, prompt: fi, tag: Ue, id: bi, attestation: Pe == null ? void 0 : Pe.attestation } }, mi = `Failed to publish payload, please try again. id:${bi} tag:${Ue}`, _i = Date.now();
      let Ei, Pi = 1;
      try {
        for (; Ei === void 0; ) {
          if (Date.now() - _i > this.publishTimeout) throw new Error(mi);
          this.logger.trace({ id: bi, attempts: Pi }, `publisher.publish - attempt ${Pi}`), Ei = await await kt$2(this.rpcPublish(Me, Be, je, Ve, fi, Ue, bi, Pe == null ? void 0 : Pe.attestation).catch((Ii) => this.logger.warn(Ii)), this.publishTimeout, mi), Pi++, Ei || await new Promise((Ii) => setTimeout(Ii, this.failedPublishTimeout));
        }
        this.relayer.events.emit(v$2.publish, vi), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { id: bi, topic: Me, message: Be, opts: Pe } });
      } catch (Ii) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(Ii), (Te = Pe == null ? void 0 : Pe.internal) != null && Te.throwOnFailedPublish) throw Ii;
        this.queue.set(bi, vi);
      }
    }, this.on = (Me, Be) => {
      this.events.on(Me, Be);
    }, this.once = (Me, Be) => {
      this.events.once(Me, Be);
    }, this.off = (Me, Be) => {
      this.events.off(Me, Be);
    }, this.removeListener = (Me, Be) => {
      this.events.removeListener(Me, Be);
    }, this.relayer = t, this.logger = E$1(Ie, this.name), this.registerEventListeners();
  }
  get context() {
    return y$3(this.logger);
  }
  rpcPublish(t, Ie, Me, Be, Pe, Te, je, Ve) {
    var fi, Ue, bi, vi;
    const mi = { method: jr$1(Be.protocol).publish, params: { topic: t, message: Ie, ttl: Me, prompt: Pe, tag: Te, attestation: Ve }, id: je };
    return I$3((fi = mi.params) == null ? void 0 : fi.prompt) && ((Ue = mi.params) == null || delete Ue.prompt), I$3((bi = mi.params) == null ? void 0 : bi.tag) && ((vi = mi.params) == null || delete vi.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: mi }), this.relayer.request(mi);
  }
  removeRequestFromQueue(t) {
    this.queue.delete(t);
  }
  checkQueue() {
    this.queue.forEach(async (t) => {
      const { topic: Ie, message: Me, opts: Be } = t;
      await this.publish(Ie, Me, Be);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r$2.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = !1, this.relayer.events.emit(v$2.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(v$2.message_ack, (t) => {
      this.removeRequestFromQueue(t.id.toString());
    });
  }
}
class Qr {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (t, Ie) => {
      const Me = this.get(t);
      this.exists(t, Ie) || this.map.set(t, [...Me, Ie]);
    }, this.get = (t) => this.map.get(t) || [], this.exists = (t, Ie) => this.get(t).includes(Ie), this.delete = (t, Ie) => {
      if (typeof Ie > "u") {
        this.map.delete(t);
        return;
      }
      if (!this.map.has(t)) return;
      const Me = this.get(t);
      if (!this.exists(t, Ie)) return;
      const Be = Me.filter((Pe) => Pe !== Ie);
      if (!Be.length) {
        this.map.delete(t);
        return;
      }
      this.map.set(t, Be);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var en = Object.defineProperty, tn = Object.defineProperties, sn = Object.getOwnPropertyDescriptors, Jt$1 = Object.getOwnPropertySymbols, rn = Object.prototype.hasOwnProperty, nn = Object.prototype.propertyIsEnumerable, Xt$1 = (Ae, t, Ie) => t in Ae ? en(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, W$1 = (Ae, t) => {
  for (var Ie in t || (t = {})) rn.call(t, Ie) && Xt$1(Ae, Ie, t[Ie]);
  if (Jt$1) for (var Ie of Jt$1(t)) nn.call(t, Ie) && Xt$1(Ae, Ie, t[Ie]);
  return Ae;
}, we$2 = (Ae, t) => tn(Ae, sn(t));
let Wt$1 = class extends d$1 {
  constructor(t, Ie) {
    super(t, Ie), this.relayer = t, this.logger = Ie, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new Qr(), this.events = new eventsExports.EventEmitter(), this.name = ut$2, this.version = dt$2, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = x$3, this.subscribeTimeout = cjs$3.toMiliseconds(cjs$3.ONE_MINUTE), this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.pendingBatchMessages = [], this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = !0;
    }, this.subscribe = async (Me, Be) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: Me, opts: Be } });
      try {
        const Pe = Ir$1(Be), Te = { topic: Me, relay: Pe, transportType: Be == null ? void 0 : Be.transportType };
        this.pending.set(Me, Te);
        const je = await this.rpcSubscribe(Me, Pe, Be);
        return typeof je == "string" && (this.onSubscribe(je, Te), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: Me, opts: Be } })), je;
      } catch (Pe) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(Pe), Pe;
      }
    }, this.unsubscribe = async (Me, Be) => {
      await this.restartToComplete(), this.isInitialized(), typeof (Be == null ? void 0 : Be.id) < "u" ? await this.unsubscribeById(Me, Be.id, Be) : await this.unsubscribeByTopic(Me, Be);
    }, this.isSubscribed = async (Me) => {
      if (this.topics.includes(Me)) return !0;
      const Be = `${this.pendingSubscriptionWatchLabel}_${Me}`;
      return await new Promise((Pe, Te) => {
        const je = new cjs$3.Watch();
        je.start(Be);
        const Ve = setInterval(() => {
          !this.pending.has(Me) && this.topics.includes(Me) && (clearInterval(Ve), je.stop(Be), Pe(!0)), je.elapsed(Be) >= pt$2 && (clearInterval(Ve), je.stop(Be), Te(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => !1);
    }, this.on = (Me, Be) => {
      this.events.on(Me, Be);
    }, this.once = (Me, Be) => {
      this.events.once(Me, Be);
    }, this.off = (Me, Be) => {
      this.events.off(Me, Be);
    }, this.removeListener = (Me, Be) => {
      this.events.removeListener(Me, Be);
    }, this.start = async () => {
      await this.onConnect();
    }, this.stop = async () => {
      await this.onDisconnect();
    }, this.restart = async () => {
      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;
    }, this.relayer = t, this.logger = E$1(Ie, this.name), this.clientId = "";
  }
  get context() {
    return y$3(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(t, Ie) {
    let Me = !1;
    try {
      Me = this.getSubscription(t).topic === Ie;
    } catch {
    }
    return Me;
  }
  onEnable() {
    this.cached = [], this.initialized = !0;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(t, Ie) {
    const Me = this.topicMap.get(t);
    await Promise.all(Me.map(async (Be) => await this.unsubscribeById(t, Be, Ie)));
  }
  async unsubscribeById(t, Ie, Me) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: t, id: Ie, opts: Me } });
    try {
      const Be = Ir$1(Me);
      await this.rpcUnsubscribe(t, Ie, Be);
      const Pe = U$2("USER_DISCONNECTED", `${this.name}, ${t}`);
      await this.onUnsubscribe(t, Ie, Pe), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: t, id: Ie, opts: Me } });
    } catch (Be) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(Be), Be;
    }
  }
  async rpcSubscribe(t, Ie, Me) {
    var Be;
    (Me == null ? void 0 : Me.transportType) === M$1.relay && await this.restartToComplete();
    const Pe = { method: jr$1(Ie.protocol).subscribe, params: { topic: t } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: Pe });
    const Te = (Be = Me == null ? void 0 : Me.internal) == null ? void 0 : Be.throwOnFailedPublish;
    try {
      const je = yr$2(t + this.clientId);
      if ((Me == null ? void 0 : Me.transportType) === M$1.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(Pe).catch((fi) => this.logger.warn(fi));
      }, cjs$3.toMiliseconds(cjs$3.ONE_SECOND)), je;
      const Ve = await kt$2(this.relayer.request(Pe).catch((fi) => this.logger.warn(fi)), this.subscribeTimeout, `Subscribing to ${t} failed, please try again`);
      if (!Ve && Te) throw new Error(`Subscribing to ${t} failed, please try again`);
      return Ve ? je : null;
    } catch (je) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(v$2.connection_stalled), Te) throw je;
    }
    return null;
  }
  async rpcBatchSubscribe(t) {
    if (!t.length) return;
    const Ie = t[0].relay, Me = { method: jr$1(Ie.protocol).batchSubscribe, params: { topics: t.map((Be) => Be.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: Me });
    try {
      return await await kt$2(this.relayer.request(Me).catch((Be) => this.logger.warn(Be)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(v$2.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(t) {
    if (!t.length) return;
    const Ie = t[0].relay, Me = { method: jr$1(Ie.protocol).batchFetchMessages, params: { topics: t.map((Pe) => Pe.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: Me });
    let Be;
    try {
      Be = await await kt$2(this.relayer.request(Me).catch((Pe) => this.logger.warn(Pe)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(v$2.connection_stalled);
    }
    return Be;
  }
  rpcUnsubscribe(t, Ie, Me) {
    const Be = { method: jr$1(Me.protocol).unsubscribe, params: { topic: t, id: Ie } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: Be }), this.relayer.request(Be);
  }
  onSubscribe(t, Ie) {
    this.setSubscription(t, we$2(W$1({}, Ie), { id: t })), this.pending.delete(Ie.topic);
  }
  onBatchSubscribe(t) {
    t.length && t.forEach((Ie) => {
      this.setSubscription(Ie.id, W$1({}, Ie)), this.pending.delete(Ie.topic);
    });
  }
  async onUnsubscribe(t, Ie, Me) {
    this.events.removeAllListeners(Ie), this.hasSubscription(Ie, t) && this.deleteSubscription(Ie, Me), await this.relayer.messages.del(t);
  }
  async setRelayerSubscriptions(t) {
    await this.relayer.core.storage.setItem(this.storageKey, t);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(t, Ie) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: t, subscription: Ie }), this.addSubscription(t, Ie);
  }
  addSubscription(t, Ie) {
    this.subscriptions.set(t, W$1({}, Ie)), this.topicMap.set(Ie.topic, t), this.events.emit(O$2.created, Ie);
  }
  getSubscription(t) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: t });
    const Ie = this.subscriptions.get(t);
    if (!Ie) {
      const { message: Me } = S$4("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw new Error(Me);
    }
    return Ie;
  }
  deleteSubscription(t, Ie) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: t, reason: Ie });
    const Me = this.getSubscription(t);
    this.subscriptions.delete(t), this.topicMap.delete(Me.topic, t), this.events.emit(O$2.deleted, we$2(W$1({}, Me), { reason: Ie }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(O$2.sync);
  }
  async reset() {
    if (this.cached.length) {
      const t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let Ie = 0; Ie < t; Ie++) {
        const Me = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchFetchMessages(Me), await this.batchSubscribe(Me);
      }
    }
    this.events.emit(O$2.resubscribed);
  }
  async restore() {
    try {
      const t = await this.getRelayerSubscriptions();
      if (typeof t > "u" || !t.length) return;
      if (this.subscriptions.size) {
        const { message: Ie } = S$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Ie), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(Ie);
      }
      this.cached = t, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(t);
    }
  }
  async batchSubscribe(t) {
    if (!t.length) return;
    const Ie = await this.rpcBatchSubscribe(t);
    L$2(Ie) && this.onBatchSubscribe(Ie.map((Me, Be) => we$2(W$1({}, t[Be]), { id: Me })));
  }
  async batchFetchMessages(t) {
    if (!t.length) return;
    this.logger.trace(`Fetching batch messages for ${t.length} subscriptions`);
    const Ie = await this.rpcBatchFetchMessages(t);
    Ie && Ie.messages && (this.pendingBatchMessages = this.pendingBatchMessages.concat(Ie.messages));
  }
  async onConnect() {
    await this.restart(), this.onEnable();
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || !this.relayer.connected) return;
    const t = [];
    this.pending.forEach((Ie) => {
      t.push(Ie);
    }), await this.batchSubscribe(t), this.pendingBatchMessages.length && (await this.relayer.handleBatchMessageEvents(this.pendingBatchMessages), this.pendingBatchMessages = []);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r$2.pulse, async () => {
      await this.checkPending();
    }), this.events.on(O$2.created, async (t) => {
      const Ie = O$2.created;
      this.logger.info(`Emitting ${Ie}`), this.logger.debug({ type: "event", event: Ie, data: t }), await this.persist();
    }), this.events.on(O$2.deleted, async (t) => {
      const Ie = O$2.deleted;
      this.logger.info(`Emitting ${Ie}`), this.logger.debug({ type: "event", event: Ie, data: t }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  async restartToComplete() {
    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen(), this.restartInProgress && await new Promise((t) => {
      const Ie = setInterval(() => {
        this.restartInProgress || (clearInterval(Ie), t());
      }, this.pollingInterval);
    });
  }
};
var on = Object.defineProperty, Zt$1 = Object.getOwnPropertySymbols, an = Object.prototype.hasOwnProperty, hn = Object.prototype.propertyIsEnumerable, Qt$1 = (Ae, t, Ie) => t in Ae ? on(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, ei = (Ae, t) => {
  for (var Ie in t || (t = {})) an.call(t, Ie) && Qt$1(Ae, Ie, t[Ie]);
  if (Zt$1) for (var Ie of Zt$1(t)) hn.call(t, Ie) && Qt$1(Ae, Ie, t[Ie]);
  return Ae;
};
class ti extends u {
  constructor(t) {
    super(t), this.protocol = "wc", this.version = 2, this.events = new eventsExports.EventEmitter(), this.name = ot$2, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "stalled", "interrupted"], this.hasExperiencedNetworkDisruption = !1, this.requestsInFlight = /* @__PURE__ */ new Map(), this.heartBeatTimeout = cjs$3.toMiliseconds(cjs$3.THIRTY_SECONDS + cjs$3.ONE_SECOND), this.request = async (Ie) => {
      var Me, Be;
      this.logger.debug("Publishing Request Payload");
      const Pe = Ie.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        const Te = this.provider.request(Ie);
        this.requestsInFlight.set(Pe, { promise: Te, request: Ie }), this.logger.trace({ id: Pe, method: Ie.method, topic: (Me = Ie.params) == null ? void 0 : Me.topic }, "relayer.request - attempt to publish...");
        const je = await new Promise(async (Ve, fi) => {
          const Ue = () => {
            fi(new Error(`relayer.request - publish interrupted, id: ${Pe}`));
          };
          this.provider.on(I$2.disconnect, Ue);
          const bi = await Te;
          this.provider.off(I$2.disconnect, Ue), Ve(bi);
        });
        return this.logger.trace({ id: Pe, method: Ie.method, topic: (Be = Ie.params) == null ? void 0 : Be.topic }, "relayer.request - published"), je;
      } catch (Te) {
        throw this.logger.debug(`Failed to Publish Request: ${Pe}`), Te;
      } finally {
        this.requestsInFlight.delete(Pe);
      }
    }, this.resetPingTimeout = () => {
      if (ce$1()) try {
        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
          var Ie, Me, Be;
          (Be = (Me = (Ie = this.provider) == null ? void 0 : Ie.connection) == null ? void 0 : Me.socket) == null || Be.terminate();
        }, this.heartBeatTimeout);
      } catch (Ie) {
        this.logger.warn(Ie);
      }
    }, this.onPayloadHandler = (Ie) => {
      this.onProviderPayload(Ie), this.resetPingTimeout();
    }, this.onConnectHandler = () => {
      this.logger.trace("relayer connected"), this.startPingTimeout(), this.events.emit(v$2.connect);
    }, this.onDisconnectHandler = () => {
      this.logger.trace("relayer disconnected"), this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (Ie) => {
      this.logger.error(Ie), this.events.emit(v$2.error, Ie), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(I$2.payload, this.onPayloadHandler), this.provider.on(I$2.connect, this.onConnectHandler), this.provider.on(I$2.disconnect, this.onDisconnectHandler), this.provider.on(I$2.error, this.onProviderErrorHandler);
    }, this.core = t.core, this.logger = typeof t.logger < "u" && typeof t.logger != "string" ? E$1(t.logger, this.name) : qt$3(k$2({ level: t.logger || nt$2 })), this.messages = new Yt$1(this.logger, t.core), this.subscriber = new Wt$1(this, this.logger), this.publisher = new Zr(this, this.logger), this.relayUrl = (t == null ? void 0 : t.relayUrl) || be$2, this.projectId = t.projectId, this.bundleId = Ot$2(), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = !0, this.subscriber.cached.length > 0) try {
      await this.transportOpen();
    } catch (t) {
      this.logger.warn(t);
    }
  }
  get context() {
    return y$3(this.logger);
  }
  get connected() {
    var t, Ie, Me;
    return ((Me = (Ie = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : Ie.socket) == null ? void 0 : Me.readyState) === 1;
  }
  get connecting() {
    var t, Ie, Me;
    return ((Me = (Ie = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : Ie.socket) == null ? void 0 : Me.readyState) === 0;
  }
  async publish(t, Ie, Me) {
    this.isInitialized(), await this.publisher.publish(t, Ie, Me), await this.recordMessageEvent({ topic: t, message: Ie, publishedAt: Date.now(), transportType: M$1.relay });
  }
  async subscribe(t, Ie) {
    var Me, Be, Pe;
    this.isInitialized(), (Ie == null ? void 0 : Ie.transportType) === "relay" && await this.toEstablishConnection();
    const Te = typeof ((Me = Ie == null ? void 0 : Ie.internal) == null ? void 0 : Me.throwOnFailedPublish) > "u" ? !0 : (Be = Ie == null ? void 0 : Ie.internal) == null ? void 0 : Be.throwOnFailedPublish;
    let je = ((Pe = this.subscriber.topicMap.get(t)) == null ? void 0 : Pe[0]) || "", Ve;
    const fi = (Ue) => {
      Ue.topic === t && (this.subscriber.off(O$2.created, fi), Ve());
    };
    return await Promise.all([new Promise((Ue) => {
      Ve = Ue, this.subscriber.on(O$2.created, fi);
    }), new Promise(async (Ue, bi) => {
      je = await this.subscriber.subscribe(t, ei({ internal: { throwOnFailedPublish: Te } }, Ie)).catch((vi) => {
        Te && bi(vi);
      }) || je, Ue();
    })]), je;
  }
  async unsubscribe(t, Ie) {
    this.isInitialized(), await this.subscriber.unsubscribe(t, Ie);
  }
  on(t, Ie) {
    this.events.on(t, Ie);
  }
  once(t, Ie) {
    this.events.once(t, Ie);
  }
  off(t, Ie) {
    this.events.off(t, Ie);
  }
  removeListener(t, Ie) {
    this.events.removeListener(t, Ie);
  }
  async transportDisconnect() {
    if (!this.hasExperiencedNetworkDisruption && this.connected && this.requestsInFlight.size > 0) try {
      await Promise.all(Array.from(this.requestsInFlight.values()).map((t) => t.promise));
    } catch (t) {
      this.logger.warn(t);
    }
    this.hasExperiencedNetworkDisruption || this.connected ? await kt$2(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = !0, await this.transportDisconnect();
  }
  async transportOpen(t) {
    await this.confirmOnlineStateOrThrow(), t && t !== this.relayUrl && (this.relayUrl = t, await this.transportDisconnect()), await this.createProvider(), this.connectionAttemptInProgress = !0, this.transportExplicitlyClosed = !1;
    try {
      await new Promise(async (Ie, Me) => {
        const Be = () => {
          this.provider.off(I$2.disconnect, Be), Me(new Error("Connection interrupted while trying to subscribe"));
        };
        this.provider.on(I$2.disconnect, Be), await kt$2(this.provider.connect(), cjs$3.toMiliseconds(cjs$3.ONE_MINUTE), `Socket stalled when trying to connect to ${this.relayUrl}`).catch((Pe) => {
          Me(Pe);
        }).finally(() => {
          clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;
        }), this.subscriber.start().catch((Pe) => {
          this.logger.error(Pe), this.onDisconnectHandler();
        }), this.hasExperiencedNetworkDisruption = !1, Ie();
      });
    } catch (Ie) {
      this.logger.error(Ie);
      const Me = Ie;
      if (this.hasExperiencedNetworkDisruption = !0, !this.isConnectionStalled(Me.message)) throw Ie;
    } finally {
      this.connectionAttemptInProgress = !1;
    }
  }
  async restartTransport(t) {
    this.connectionAttemptInProgress || (this.relayUrl = t || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await mo()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(t) {
    if ((t == null ? void 0 : t.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const Ie = t.sort((Me, Be) => Me.publishedAt - Be.publishedAt);
    this.logger.trace(`Batch of ${Ie.length} message events sorted`);
    for (const Me of Ie) try {
      await this.onMessageEvent(Me);
    } catch (Be) {
      this.logger.warn(Be);
    }
    this.logger.trace(`Batch of ${Ie.length} message events processed`);
  }
  async onLinkMessageEvent(t, Ie) {
    const { topic: Me } = t;
    if (!Ie.sessionExists) {
      const Be = Mt$2(cjs$3.FIVE_MINUTES), Pe = { topic: Me, expiry: Be, relay: { protocol: "irn" }, active: !1 };
      await this.core.pairing.pairings.set(Me, Pe);
    }
    this.events.emit(v$2.message, t), await this.recordMessageEvent(t);
  }
  startPingTimeout() {
    var t, Ie, Me, Be, Pe;
    if (ce$1()) try {
      (Ie = (t = this.provider) == null ? void 0 : t.connection) != null && Ie.socket && ((Pe = (Be = (Me = this.provider) == null ? void 0 : Me.connection) == null ? void 0 : Be.socket) == null || Pe.once("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (Te) {
      this.logger.warn(Te);
    }
  }
  isConnectionStalled(t) {
    return this.staleConnectionErrors.some((Ie) => t.includes(Ie));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const t = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o$1(new f$2($t$2({ sdkVersion: se$2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: t, useOnCloseEvent: !0, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(t) {
    const { topic: Ie, message: Me } = t;
    await this.messages.set(Ie, Me);
  }
  async shouldIgnoreMessageEvent(t) {
    const { topic: Ie, message: Me } = t;
    if (!Me || Me.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${Me}`), !0;
    if (!await this.subscriber.isSubscribed(Ie)) return this.logger.debug(`Ignoring message for non-subscribed topic ${Ie}`), !0;
    const Be = this.messages.has(Ie, Me);
    return Be && this.logger.debug(`Ignoring duplicate message: ${Me}`), Be;
  }
  async onProviderPayload(t) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: t }), isJsonRpcRequest(t)) {
      if (!t.method.endsWith(at$2)) return;
      const Ie = t.params, { topic: Me, message: Be, publishedAt: Pe, attestation: Te } = Ie.data, je = { topic: Me, message: Be, publishedAt: Pe, transportType: M$1.relay, attestation: Te };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(ei({ type: "event", event: Ie.id }, je)), this.events.emit(Ie.id, je), await this.acknowledgePayload(t), await this.onMessageEvent(je);
    } else isJsonRpcResponse(t) && this.events.emit(v$2.message_ack, t);
  }
  async onMessageEvent(t) {
    await this.shouldIgnoreMessageEvent(t) || (this.events.emit(v$2.message, t), await this.recordMessageEvent(t));
  }
  async acknowledgePayload(t) {
    const Ie = formatJsonRpcResult(t.id, !0);
    await this.provider.connection.send(Ie);
  }
  unregisterProviderListeners() {
    this.provider.off(I$2.payload, this.onPayloadHandler), this.provider.off(I$2.connect, this.onConnectHandler), this.provider.off(I$2.disconnect, this.onDisconnectHandler), this.provider.off(I$2.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let t = await mo();
    ho(async (Ie) => {
      t !== Ie && (t = Ie, Ie ? await this.restartTransport().catch((Me) => this.logger.error(Me)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportDisconnect(), this.transportExplicitlyClosed = !1));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), this.requestsInFlight.clear(), clearTimeout(this.pingTimeout), this.events.emit(v$2.disconnect), this.connectionAttemptInProgress = !1, !this.transportExplicitlyClosed && (this.reconnectTimeout || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((t) => this.logger.error(t));
    }, cjs$3.toMiliseconds(ht$2))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (this.connectionAttemptInProgress && await new Promise((t) => {
      const Ie = setInterval(() => {
        this.connected && (clearInterval(Ie), t());
      }, this.connectionStatusPollingInterval);
    }), await this.transportOpen());
  }
}
var cn = Object.defineProperty, ii = Object.getOwnPropertySymbols, ln = Object.prototype.hasOwnProperty, un = Object.prototype.propertyIsEnumerable, si = (Ae, t, Ie) => t in Ae ? cn(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, ri = (Ae, t) => {
  for (var Ie in t || (t = {})) ln.call(t, Ie) && si(Ae, Ie, t[Ie]);
  if (ii) for (var Ie of ii(t)) un.call(t, Ie) && si(Ae, Ie, t[Ie]);
  return Ae;
};
class ni extends p$1 {
  constructor(t, Ie, Me, Be = x$3, Pe = void 0) {
    super(t, Ie, Me, Be), this.core = t, this.logger = Ie, this.name = Me, this.map = /* @__PURE__ */ new Map(), this.version = ct$2, this.cached = [], this.initialized = !1, this.storagePrefix = x$3, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((Te) => {
        this.getKey && Te !== null && !I$3(Te) ? this.map.set(this.getKey(Te), Te) : Yr$1(Te) ? this.map.set(Te.id, Te) : Qr$1(Te) && this.map.set(Te.topic, Te);
      }), this.cached = [], this.initialized = !0);
    }, this.set = async (Te, je) => {
      this.isInitialized(), this.map.has(Te) ? await this.update(Te, je) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: Te, value: je }), this.map.set(Te, je), await this.persist());
    }, this.get = (Te) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: Te }), this.getData(Te)), this.getAll = (Te) => (this.isInitialized(), Te ? this.values.filter((je) => Object.keys(Te).every((Ve) => ys$1(je[Ve], Te[Ve]))) : this.values), this.update = async (Te, je) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: Te, update: je });
      const Ve = ri(ri({}, this.getData(Te)), je);
      this.map.set(Te, Ve), await this.persist();
    }, this.delete = async (Te, je) => {
      this.isInitialized(), this.map.has(Te) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: Te, reason: je }), this.map.delete(Te), this.addToRecentlyDeleted(Te), await this.persist());
    }, this.logger = E$1(Ie, this.name), this.storagePrefix = Be, this.getKey = Pe;
  }
  get context() {
    return y$3(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(t) {
    this.recentlyDeleted.push(t), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(t) {
    await this.core.storage.setItem(this.storageKey, t);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(t) {
    const Ie = this.map.get(t);
    if (!Ie) {
      if (this.recentlyDeleted.includes(t)) {
        const { message: Be } = S$4("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${t}`);
        throw this.logger.error(Be), new Error(Be);
      }
      const { message: Me } = S$4("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw this.logger.error(Me), new Error(Me);
    }
    return Ie;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const t = await this.getDataStore();
      if (typeof t > "u" || !t.length) return;
      if (this.map.size) {
        const { message: Ie } = S$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Ie), new Error(Ie);
      }
      this.cached = t, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(t);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class oi {
  constructor(t, Ie) {
    this.core = t, this.logger = Ie, this.name = gt$2, this.version = yt$2, this.events = new es(), this.initialized = !1, this.storagePrefix = x$3, this.ignoredPayloadTypes = [D$2], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
    }, this.register = ({ methods: Me }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...Me])];
    }, this.create = async (Me) => {
      this.isInitialized();
      const Be = pr$2(), Pe = await this.core.crypto.setSymKey(Be), Te = Mt$2(cjs$3.FIVE_MINUTES), je = { protocol: rt$2 }, Ve = { topic: Pe, expiry: Te, relay: je, active: !1, methods: Me == null ? void 0 : Me.methods }, fi = Dr$2({ protocol: this.core.protocol, version: this.core.version, topic: Pe, symKey: Be, relay: je, expiryTimestamp: Te, methods: Me == null ? void 0 : Me.methods });
      return this.events.emit(V$2.create, Ve), this.core.expirer.set(Pe, Te), await this.pairings.set(Pe, Ve), await this.core.relayer.subscribe(Pe, { transportType: Me == null ? void 0 : Me.transportType }), { topic: Pe, uri: fi };
    }, this.pair = async (Me) => {
      this.isInitialized();
      const Be = this.core.eventClient.createEvent({ properties: { topic: Me == null ? void 0 : Me.uri, trace: [z$3.pairing_started] } });
      this.isValidPair(Me, Be);
      const { topic: Pe, symKey: Te, relay: je, expiryTimestamp: Ve, methods: fi } = kr$1(Me.uri);
      Be.props.properties.topic = Pe, Be.addTrace(z$3.pairing_uri_validation_success), Be.addTrace(z$3.pairing_uri_not_expired);
      let Ue;
      if (this.pairings.keys.includes(Pe)) {
        if (Ue = this.pairings.get(Pe), Be.addTrace(z$3.existing_pairing), Ue.active) throw Be.setError($$1.active_pairing_already_exists), new Error(`Pairing already exists: ${Pe}. Please try again with a new connection URI.`);
        Be.addTrace(z$3.pairing_not_expired);
      }
      const bi = Ve || Mt$2(cjs$3.FIVE_MINUTES), vi = { topic: Pe, relay: je, expiry: bi, active: !1, methods: fi };
      this.core.expirer.set(Pe, bi), await this.pairings.set(Pe, vi), Be.addTrace(z$3.store_new_pairing), Me.activatePairing && await this.activate({ topic: Pe }), this.events.emit(V$2.create, vi), Be.addTrace(z$3.emit_inactive_pairing), this.core.crypto.keychain.has(Pe) || await this.core.crypto.setSymKey(Te, Pe), Be.addTrace(z$3.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        Be.setError($$1.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(Pe, { relay: je });
      } catch (mi) {
        throw Be.setError($$1.subscribe_pairing_topic_failure), mi;
      }
      return Be.addTrace(z$3.subscribe_pairing_topic_success), vi;
    }, this.activate = async ({ topic: Me }) => {
      this.isInitialized();
      const Be = Mt$2(cjs$3.THIRTY_DAYS);
      this.core.expirer.set(Me, Be), await this.pairings.update(Me, { active: !0, expiry: Be });
    }, this.ping = async (Me) => {
      this.isInitialized(), await this.isValidPing(Me);
      const { topic: Be } = Me;
      if (this.pairings.keys.includes(Be)) {
        const Pe = await this.sendRequest(Be, "wc_pairingPing", {}), { done: Te, resolve: je, reject: Ve } = _t$2();
        this.events.once(Lt$2("pairing_ping", Pe), ({ error: fi }) => {
          fi ? Ve(fi) : je();
        }), await Te();
      }
    }, this.updateExpiry = async ({ topic: Me, expiry: Be }) => {
      this.isInitialized(), await this.pairings.update(Me, { expiry: Be });
    }, this.updateMetadata = async ({ topic: Me, metadata: Be }) => {
      this.isInitialized(), await this.pairings.update(Me, { peerMetadata: Be });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (Me) => {
      this.isInitialized(), await this.isValidDisconnect(Me);
      const { topic: Be } = Me;
      this.pairings.keys.includes(Be) && (await this.sendRequest(Be, "wc_pairingDelete", U$2("USER_DISCONNECTED")), await this.deletePairing(Be));
    }, this.formatUriFromPairing = (Me) => {
      this.isInitialized();
      const { topic: Be, relay: Pe, expiry: Te, methods: je } = Me, Ve = this.core.crypto.keychain.get(Be);
      return Dr$2({ protocol: this.core.protocol, version: this.core.version, topic: Be, symKey: Ve, relay: Pe, expiryTimestamp: Te, methods: je });
    }, this.sendRequest = async (Me, Be, Pe) => {
      const Te = formatJsonRpcRequest(Be, Pe), je = await this.core.crypto.encode(Me, Te), Ve = B$2[Be].req;
      return this.core.history.set(Me, Te), this.core.relayer.publish(Me, je, Ve), Te.id;
    }, this.sendResult = async (Me, Be, Pe) => {
      const Te = formatJsonRpcResult(Me, Pe), je = await this.core.crypto.encode(Be, Te), Ve = await this.core.history.get(Be, Me), fi = B$2[Ve.request.method].res;
      await this.core.relayer.publish(Be, je, fi), await this.core.history.resolve(Te);
    }, this.sendError = async (Me, Be, Pe) => {
      const Te = formatJsonRpcError(Me, Pe), je = await this.core.crypto.encode(Be, Te), Ve = await this.core.history.get(Be, Me), fi = B$2[Ve.request.method] ? B$2[Ve.request.method].res : B$2.unregistered_method.res;
      await this.core.relayer.publish(Be, je, fi), await this.core.history.resolve(Te);
    }, this.deletePairing = async (Me, Be) => {
      await this.core.relayer.unsubscribe(Me), await Promise.all([this.pairings.delete(Me, U$2("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(Me), Be ? Promise.resolve() : this.core.expirer.del(Me)]);
    }, this.cleanup = async () => {
      const Me = this.pairings.getAll().filter((Be) => Kt$2(Be.expiry));
      await Promise.all(Me.map((Be) => this.deletePairing(Be.topic)));
    }, this.onRelayEventRequest = (Me) => {
      const { topic: Be, payload: Pe } = Me;
      switch (Pe.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(Be, Pe);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(Be, Pe);
        default:
          return this.onUnknownRpcMethodRequest(Be, Pe);
      }
    }, this.onRelayEventResponse = async (Me) => {
      const { topic: Be, payload: Pe } = Me, Te = (await this.core.history.get(Be, Pe.id)).request.method;
      switch (Te) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(Be, Pe);
        default:
          return this.onUnknownRpcMethodResponse(Te);
      }
    }, this.onPairingPingRequest = async (Me, Be) => {
      const { id: Pe } = Be;
      try {
        this.isValidPing({ topic: Me }), await this.sendResult(Pe, Me, !0), this.events.emit(V$2.ping, { id: Pe, topic: Me });
      } catch (Te) {
        await this.sendError(Pe, Me, Te), this.logger.error(Te);
      }
    }, this.onPairingPingResponse = (Me, Be) => {
      const { id: Pe } = Be;
      setTimeout(() => {
        isJsonRpcResult(Be) ? this.events.emit(Lt$2("pairing_ping", Pe), {}) : isJsonRpcError(Be) && this.events.emit(Lt$2("pairing_ping", Pe), { error: Be.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (Me, Be) => {
      const { id: Pe } = Be;
      try {
        this.isValidDisconnect({ topic: Me }), await this.deletePairing(Me), this.events.emit(V$2.delete, { id: Pe, topic: Me });
      } catch (Te) {
        await this.sendError(Pe, Me, Te), this.logger.error(Te);
      }
    }, this.onUnknownRpcMethodRequest = async (Me, Be) => {
      const { id: Pe, method: Te } = Be;
      try {
        if (this.registeredMethods.includes(Te)) return;
        const je = U$2("WC_METHOD_UNSUPPORTED", Te);
        await this.sendError(Pe, Me, je), this.logger.error(je);
      } catch (je) {
        await this.sendError(Pe, Me, je), this.logger.error(je);
      }
    }, this.onUnknownRpcMethodResponse = (Me) => {
      this.registeredMethods.includes(Me) || this.logger.error(U$2("WC_METHOD_UNSUPPORTED", Me));
    }, this.isValidPair = (Me, Be) => {
      var Pe;
      if (!to(Me)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `pair() params: ${Me}`);
        throw Be.setError($$1.malformed_pairing_uri), new Error(je);
      }
      if (!Gr$1(Me.uri)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `pair() uri: ${Me.uri}`);
        throw Be.setError($$1.malformed_pairing_uri), new Error(je);
      }
      const Te = kr$1(Me == null ? void 0 : Me.uri);
      if (!((Pe = Te == null ? void 0 : Te.relay) != null && Pe.protocol)) {
        const { message: je } = S$4("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw Be.setError($$1.malformed_pairing_uri), new Error(je);
      }
      if (!(Te != null && Te.symKey)) {
        const { message: je } = S$4("MISSING_OR_INVALID", "pair() uri#symKey");
        throw Be.setError($$1.malformed_pairing_uri), new Error(je);
      }
      if (Te != null && Te.expiryTimestamp && cjs$3.toMiliseconds(Te == null ? void 0 : Te.expiryTimestamp) < Date.now()) {
        Be.setError($$1.pairing_expired);
        const { message: je } = S$4("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(je);
      }
    }, this.isValidPing = async (Me) => {
      if (!to(Me)) {
        const { message: Pe } = S$4("MISSING_OR_INVALID", `ping() params: ${Me}`);
        throw new Error(Pe);
      }
      const { topic: Be } = Me;
      await this.isValidPairingTopic(Be);
    }, this.isValidDisconnect = async (Me) => {
      if (!to(Me)) {
        const { message: Pe } = S$4("MISSING_OR_INVALID", `disconnect() params: ${Me}`);
        throw new Error(Pe);
      }
      const { topic: Be } = Me;
      await this.isValidPairingTopic(Be);
    }, this.isValidPairingTopic = async (Me) => {
      if (!b$2(Me, !1)) {
        const { message: Be } = S$4("MISSING_OR_INVALID", `pairing topic should be a string: ${Me}`);
        throw new Error(Be);
      }
      if (!this.pairings.keys.includes(Me)) {
        const { message: Be } = S$4("NO_MATCHING_KEY", `pairing topic doesn't exist: ${Me}`);
        throw new Error(Be);
      }
      if (Kt$2(this.pairings.get(Me).expiry)) {
        await this.deletePairing(Me);
        const { message: Be } = S$4("EXPIRED", `pairing topic: ${Me}`);
        throw new Error(Be);
      }
    }, this.core = t, this.logger = E$1(Ie, this.name), this.pairings = new ni(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y$3(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(v$2.message, async (t) => {
      const { topic: Ie, message: Me, transportType: Be } = t;
      if (!this.pairings.keys.includes(Ie) || Be === M$1.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(Me))) return;
      const Pe = await this.core.crypto.decode(Ie, Me);
      try {
        isJsonRpcRequest(Pe) ? (this.core.history.set(Ie, Pe), this.onRelayEventRequest({ topic: Ie, payload: Pe })) : isJsonRpcResponse(Pe) && (await this.core.history.resolve(Pe), await this.onRelayEventResponse({ topic: Ie, payload: Pe }), this.core.history.delete(Ie, Pe.id));
      } catch (Te) {
        this.logger.error(Te);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(S$2.expired, async (t) => {
      const { topic: Ie } = Vt$2(t.target);
      Ie && this.pairings.keys.includes(Ie) && (await this.deletePairing(Ie, !0), this.events.emit(V$2.expire, { topic: Ie }));
    });
  }
}
class ai extends h$1 {
  constructor(t, Ie) {
    super(t, Ie), this.core = t, this.logger = Ie, this.records = /* @__PURE__ */ new Map(), this.events = new eventsExports.EventEmitter(), this.name = Dt$1, this.version = mt$1, this.cached = [], this.initialized = !1, this.storagePrefix = x$3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((Me) => this.records.set(Me.id, Me)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.set = (Me, Be, Pe) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: Me, request: Be, chainId: Pe }), this.records.has(Be.id)) return;
      const Te = { id: Be.id, topic: Me, request: { method: Be.method, params: Be.params || null }, chainId: Pe, expiry: Mt$2(cjs$3.THIRTY_DAYS) };
      this.records.set(Te.id, Te), this.persist(), this.events.emit(P$1.created, Te);
    }, this.resolve = async (Me) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: Me }), !this.records.has(Me.id)) return;
      const Be = await this.getRecord(Me.id);
      typeof Be.response > "u" && (Be.response = isJsonRpcError(Me) ? { error: Me.error } : { result: Me.result }, this.records.set(Be.id, Be), this.persist(), this.events.emit(P$1.updated, Be));
    }, this.get = async (Me, Be) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: Me, id: Be }), await this.getRecord(Be)), this.delete = (Me, Be) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: Be }), this.values.forEach((Pe) => {
        if (Pe.topic === Me) {
          if (typeof Be < "u" && Pe.id !== Be) return;
          this.records.delete(Pe.id), this.events.emit(P$1.deleted, Pe);
        }
      }), this.persist();
    }, this.exists = async (Me, Be) => (this.isInitialized(), this.records.has(Be) ? (await this.getRecord(Be)).topic === Me : !1), this.on = (Me, Be) => {
      this.events.on(Me, Be);
    }, this.once = (Me, Be) => {
      this.events.once(Me, Be);
    }, this.off = (Me, Be) => {
      this.events.off(Me, Be);
    }, this.removeListener = (Me, Be) => {
      this.events.removeListener(Me, Be);
    }, this.logger = E$1(Ie, this.name);
  }
  get context() {
    return y$3(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const t = [];
    return this.values.forEach((Ie) => {
      if (typeof Ie.response < "u") return;
      const Me = { topic: Ie.topic, request: formatJsonRpcRequest(Ie.request.method, Ie.request.params, Ie.id), chainId: Ie.chainId };
      return t.push(Me);
    }), t;
  }
  async setJsonRpcRecords(t) {
    await this.core.storage.setItem(this.storageKey, t);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(t) {
    this.isInitialized();
    const Ie = this.records.get(t);
    if (!Ie) {
      const { message: Me } = S$4("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw new Error(Me);
    }
    return Ie;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(P$1.sync);
  }
  async restore() {
    try {
      const t = await this.getJsonRpcRecords();
      if (typeof t > "u" || !t.length) return;
      if (this.records.size) {
        const { message: Ie } = S$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Ie), new Error(Ie);
      }
      this.cached = t, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(t);
    }
  }
  registerEventListeners() {
    this.events.on(P$1.created, (t) => {
      const Ie = P$1.created;
      this.logger.info(`Emitting ${Ie}`), this.logger.debug({ type: "event", event: Ie, record: t });
    }), this.events.on(P$1.updated, (t) => {
      const Ie = P$1.updated;
      this.logger.info(`Emitting ${Ie}`), this.logger.debug({ type: "event", event: Ie, record: t });
    }), this.events.on(P$1.deleted, (t) => {
      const Ie = P$1.deleted;
      this.logger.info(`Emitting ${Ie}`), this.logger.debug({ type: "event", event: Ie, record: t });
    }), this.core.heartbeat.on(r$2.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let t = !1;
      this.records.forEach((Ie) => {
        cjs$3.toMiliseconds(Ie.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${Ie.id}`), this.records.delete(Ie.id), this.events.emit(P$1.deleted, Ie, !1), t = !0);
      }), t && this.persist();
    } catch (t) {
      this.logger.warn(t);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class hi extends x$4 {
  constructor(t, Ie) {
    super(t, Ie), this.core = t, this.logger = Ie, this.expirations = /* @__PURE__ */ new Map(), this.events = new eventsExports.EventEmitter(), this.name = bt$1, this.version = ft$1, this.cached = [], this.initialized = !1, this.storagePrefix = x$3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((Me) => this.expirations.set(Me.target, Me)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.has = (Me) => {
      try {
        const Be = this.formatTarget(Me);
        return typeof this.getExpiration(Be) < "u";
      } catch {
        return !1;
      }
    }, this.set = (Me, Be) => {
      this.isInitialized();
      const Pe = this.formatTarget(Me), Te = { target: Pe, expiry: Be };
      this.expirations.set(Pe, Te), this.checkExpiry(Pe, Te), this.events.emit(S$2.created, { target: Pe, expiration: Te });
    }, this.get = (Me) => {
      this.isInitialized();
      const Be = this.formatTarget(Me);
      return this.getExpiration(Be);
    }, this.del = (Me) => {
      if (this.isInitialized(), this.has(Me)) {
        const Be = this.formatTarget(Me), Pe = this.getExpiration(Be);
        this.expirations.delete(Be), this.events.emit(S$2.deleted, { target: Be, expiration: Pe });
      }
    }, this.on = (Me, Be) => {
      this.events.on(Me, Be);
    }, this.once = (Me, Be) => {
      this.events.once(Me, Be);
    }, this.off = (Me, Be) => {
      this.events.off(Me, Be);
    }, this.removeListener = (Me, Be) => {
      this.events.removeListener(Me, Be);
    }, this.logger = E$1(Ie, this.name);
  }
  get context() {
    return y$3(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(t) {
    if (typeof t == "string") return Dt$2(t);
    if (typeof t == "number") return xt$2(t);
    const { message: Ie } = S$4("UNKNOWN_TYPE", `Target type: ${typeof t}`);
    throw new Error(Ie);
  }
  async setExpirations(t) {
    await this.core.storage.setItem(this.storageKey, t);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(S$2.sync);
  }
  async restore() {
    try {
      const t = await this.getExpirations();
      if (typeof t > "u" || !t.length) return;
      if (this.expirations.size) {
        const { message: Ie } = S$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Ie), new Error(Ie);
      }
      this.cached = t, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(t);
    }
  }
  getExpiration(t) {
    const Ie = this.expirations.get(t);
    if (!Ie) {
      const { message: Me } = S$4("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw this.logger.warn(Me), new Error(Me);
    }
    return Ie;
  }
  checkExpiry(t, Ie) {
    const { expiry: Me } = Ie;
    cjs$3.toMiliseconds(Me) - Date.now() <= 0 && this.expire(t, Ie);
  }
  expire(t, Ie) {
    this.expirations.delete(t), this.events.emit(S$2.expired, { target: t, expiration: Ie });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((t, Ie) => this.checkExpiry(Ie, t));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r$2.pulse, () => this.checkExpirations()), this.events.on(S$2.created, (t) => {
      const Ie = S$2.created;
      this.logger.info(`Emitting ${Ie}`), this.logger.debug({ type: "event", event: Ie, data: t }), this.persist();
    }), this.events.on(S$2.expired, (t) => {
      const Ie = S$2.expired;
      this.logger.info(`Emitting ${Ie}`), this.logger.debug({ type: "event", event: Ie, data: t }), this.persist();
    }), this.events.on(S$2.deleted, (t) => {
      const Ie = S$2.deleted;
      this.logger.info(`Emitting ${Ie}`), this.logger.debug({ type: "event", event: Ie, data: t }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class ci extends y$2 {
  constructor(t, Ie, Me) {
    super(t, Ie, Me), this.core = t, this.logger = Ie, this.store = Me, this.name = _t$1, this.verifyUrlV3 = vt$1, this.storagePrefix = x$3, this.version = De$1, this.init = async () => {
      var Be;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && cjs$3.toMiliseconds((Be = this.publicKey) == null ? void 0 : Be.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }, this.register = async (Be) => {
      if (!V$3() || this.isDevEnv) return;
      const Pe = window.location.origin, { id: Te, decryptedId: je } = Be, Ve = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${Pe}&id=${Te}&decryptedId=${je}`;
      try {
        const fi = getDocument_1(), Ue = this.startAbortTimer(cjs$3.ONE_SECOND * 5), bi = await new Promise((vi, mi) => {
          const _i = () => {
            window.removeEventListener("message", Pi), fi.body.removeChild(Ei), mi("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", _i);
          const Ei = fi.createElement("iframe");
          Ei.src = Ve, Ei.style.display = "none", Ei.addEventListener("error", _i, { signal: this.abortController.signal });
          const Pi = (Ii) => {
            if (Ii.data && typeof Ii.data == "string") try {
              const Ci = JSON.parse(Ii.data);
              if (Ci.type === "verify_attestation") {
                if (decodeJWT(Ci.attestation).payload.id !== Te) return;
                clearInterval(Ue), fi.body.removeChild(Ei), this.abortController.signal.removeEventListener("abort", _i), window.removeEventListener("message", Pi), vi(Ci.attestation === null ? "" : Ci.attestation);
              }
            } catch (Ci) {
              this.logger.warn(Ci);
            }
          };
          fi.body.appendChild(Ei), window.addEventListener("message", Pi, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", bi), bi;
      } catch (fi) {
        this.logger.warn(fi);
      }
      return "";
    }, this.resolve = async (Be) => {
      if (this.isDevEnv) return "";
      const { attestationId: Pe, hash: Te, encryptedId: je } = Be;
      if (Pe === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (Pe) {
        if (decodeJWT(Pe).payload.id !== je) return;
        const fi = await this.isValidJwtAttestation(Pe);
        if (fi) {
          if (!fi.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return fi;
        }
      }
      if (!Te) return;
      const Ve = this.getVerifyUrl(Be == null ? void 0 : Be.verifyUrl);
      return this.fetchAttestation(Te, Ve);
    }, this.fetchAttestation = async (Be, Pe) => {
      this.logger.debug(`resolving attestation: ${Be} from url: ${Pe}`);
      const Te = this.startAbortTimer(cjs$3.ONE_SECOND * 5), je = await fetch(`${Pe}/attestation/${Be}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(Te), je.status === 200 ? await je.json() : void 0;
    }, this.getVerifyUrl = (Be) => {
      let Pe = Be || J$1;
      return wt$1.includes(Pe) || (this.logger.info(`verify url: ${Pe}, not included in trusted list, assigning default: ${J$1}`), Pe = J$1), Pe;
    }, this.fetchPublicKey = async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const Be = this.startAbortTimer(cjs$3.FIVE_SECONDS), Pe = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(Be), await Pe.json();
      } catch (Be) {
        this.logger.warn(Be);
      }
    }, this.persistPublicKey = async (Be) => {
      this.logger.debug("persisting public key to local storage", Be), await this.store.setItem(this.storeKey, Be), this.publicKey = Be;
    }, this.removePublicKey = async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }, this.isValidJwtAttestation = async (Be) => {
      const Pe = await this.getPublicKey();
      try {
        if (Pe) return this.validateAttestation(Be, Pe);
      } catch (je) {
        this.logger.error(je), this.logger.warn("error validating attestation");
      }
      const Te = await this.fetchAndPersistPublicKey();
      try {
        if (Te) return this.validateAttestation(Be, Te);
      } catch (je) {
        this.logger.error(je), this.logger.warn("error validating attestation");
      }
    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (Pe) => {
        const Te = await this.fetchPublicKey();
        Te && (await this.persistPublicKey(Te), Pe(Te));
      });
      const Be = await this.fetchPromise;
      return this.fetchPromise = void 0, Be;
    }, this.validateAttestation = (Be, Pe) => {
      const Te = Rr$2(Be, Pe.publicKey), je = { hasExpired: cjs$3.toMiliseconds(Te.exp) < Date.now(), payload: Te };
      if (je.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: je.payload.origin, isScam: je.payload.isScam, isVerified: je.payload.isVerified };
    }, this.logger = E$1(Ie, this.name), this.abortController = new AbortController(), this.isDevEnv = Wt$2(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y$3(this.logger);
  }
  startAbortTimer(t) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), cjs$3.toMiliseconds(t));
  }
}
class li extends v$3 {
  constructor(t, Ie) {
    super(t, Ie), this.projectId = t, this.logger = Ie, this.context = It$1, this.registerDeviceToken = async (Me) => {
      const { clientId: Be, token: Pe, notificationType: Te, enableEncrypted: je = !1 } = Me, Ve = `${Tt$1}/${this.projectId}/clients`;
      await fetch(Ve, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: Be, type: Te, token: Pe, always_raw: je }) });
    }, this.logger = E$1(Ie, this.context);
  }
}
var dn = Object.defineProperty, ui = Object.getOwnPropertySymbols, pn = Object.prototype.hasOwnProperty, gn = Object.prototype.propertyIsEnumerable, di = (Ae, t, Ie) => t in Ae ? dn(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, Z$2 = (Ae, t) => {
  for (var Ie in t || (t = {})) pn.call(t, Ie) && di(Ae, Ie, t[Ie]);
  if (ui) for (var Ie of ui(t)) gn.call(t, Ie) && di(Ae, Ie, t[Ie]);
  return Ae;
};
class pi extends C$3 {
  constructor(t, Ie, Me = !0) {
    super(t, Ie, Me), this.core = t, this.logger = Ie, this.context = Pt$1, this.storagePrefix = x$3, this.storageVersion = Ct$1, this.events = /* @__PURE__ */ new Map(), this.shouldPersist = !1, this.init = async () => {
      if (!Wt$2()) try {
        const Be = { eventId: Ht$2(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Ge(this.core.relayer.protocol, this.core.relayer.version, se$2) } } };
        await this.sendEvent([Be]);
      } catch (Be) {
        this.logger.warn(Be);
      }
    }, this.createEvent = (Be) => {
      const { event: Pe = "ERROR", type: Te = "", properties: { topic: je, trace: Ve } } = Be, fi = Ht$2(), Ue = this.core.projectId || "", bi = Date.now(), vi = Z$2({ eventId: fi, timestamp: bi, props: { event: Pe, type: Te, properties: { topic: je, trace: Ve } }, bundleId: Ue, domain: this.getAppDomain() }, this.setMethods(fi));
      return this.telemetryEnabled && (this.events.set(fi, vi), this.shouldPersist = !0), vi;
    }, this.getEvent = (Be) => {
      const { eventId: Pe, topic: Te } = Be;
      if (Pe) return this.events.get(Pe);
      const je = Array.from(this.events.values()).find((Ve) => Ve.props.properties.topic === Te);
      if (je) return Z$2(Z$2({}, je), this.setMethods(je.eventId));
    }, this.deleteEvent = (Be) => {
      const { eventId: Pe } = Be;
      this.events.delete(Pe), this.shouldPersist = !0;
    }, this.setEventListeners = () => {
      this.core.heartbeat.on(r$2.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((Be) => {
          cjs$3.fromMiliseconds(Date.now()) - cjs$3.fromMiliseconds(Be.timestamp) > St$1 && (this.events.delete(Be.eventId), this.shouldPersist = !0);
        });
      });
    }, this.setMethods = (Be) => ({ addTrace: (Pe) => this.addTrace(Be, Pe), setError: (Pe) => this.setError(Be, Pe) }), this.addTrace = (Be, Pe) => {
      const Te = this.events.get(Be);
      Te && (Te.props.properties.trace.push(Pe), this.events.set(Be, Te), this.shouldPersist = !0);
    }, this.setError = (Be, Pe) => {
      const Te = this.events.get(Be);
      Te && (Te.props.type = Pe, Te.timestamp = Date.now(), this.events.set(Be, Te), this.shouldPersist = !0);
    }, this.persist = async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = !1;
    }, this.restore = async () => {
      try {
        const Be = await this.core.storage.getItem(this.storageKey) || [];
        if (!Be.length) return;
        Be.forEach((Pe) => {
          this.events.set(Pe.eventId, Z$2(Z$2({}, Pe), this.setMethods(Pe.eventId)));
        });
      } catch (Be) {
        this.logger.warn(Be);
      }
    }, this.submit = async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const Be = [];
      for (const [Pe, Te] of this.events) Te.props.type && Be.push(Te);
      if (Be.length !== 0) try {
        if ((await this.sendEvent(Be)).ok) for (const Pe of Be) this.events.delete(Pe.eventId), this.shouldPersist = !0;
      } catch (Pe) {
        this.logger.warn(Pe);
      }
    }, this.sendEvent = async (Be) => {
      const Pe = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${Rt$1}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${se$2}${Pe}`, { method: "POST", body: JSON.stringify(Be) });
    }, this.getAppDomain = () => Nt$2().url, this.logger = E$1(Ie, this.context), this.telemetryEnabled = Me, Me ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
}
var yn = Object.defineProperty, gi = Object.getOwnPropertySymbols, Dn = Object.prototype.hasOwnProperty, mn = Object.prototype.propertyIsEnumerable, yi = (Ae, t, Ie) => t in Ae ? yn(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, Di = (Ae, t) => {
  for (var Ie in t || (t = {})) Dn.call(t, Ie) && yi(Ae, Ie, t[Ie]);
  if (gi) for (var Ie of gi(t)) mn.call(t, Ie) && yi(Ae, Ie, t[Ie]);
  return Ae;
};
let ne$2 = class rf extends n$1 {
  constructor(t) {
    var Ie;
    super(t), this.protocol = ye$2, this.version = De$1, this.name = ie$2, this.events = new eventsExports.EventEmitter(), this.initialized = !1, this.on = (Te, je) => this.events.on(Te, je), this.once = (Te, je) => this.events.once(Te, je), this.off = (Te, je) => this.events.off(Te, je), this.removeListener = (Te, je) => this.events.removeListener(Te, je), this.dispatchEnvelope = ({ topic: Te, message: je, sessionExists: Ve }) => {
      if (!Te || !je) return;
      const fi = { topic: Te, message: je, publishedAt: Date.now(), transportType: M$1.link_mode };
      this.relayer.onLinkMessageEvent(fi, { sessionExists: Ve });
    }, this.projectId = t == null ? void 0 : t.projectId, this.relayUrl = (t == null ? void 0 : t.relayUrl) || be$2, this.customStoragePrefix = t != null && t.customStoragePrefix ? `:${t.customStoragePrefix}` : "";
    const Me = k$2({ level: typeof (t == null ? void 0 : t.logger) == "string" && t.logger ? t.logger : Ye.logger }), { logger: Be, chunkLoggerController: Pe } = A$1({ opts: Me, maxSizeInBytes: t == null ? void 0 : t.maxLogBlobSizeInBytes, loggerOverride: t == null ? void 0 : t.logger });
    this.logChunkController = Pe, (Ie = this.logChunkController) != null && Ie.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var Te, je;
      (Te = this.logChunkController) != null && Te.downloadLogsBlobInBrowser && ((je = this.logChunkController) == null || je.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E$1(Be, this.name), this.heartbeat = new i$1(), this.crypto = new Ht$1(this, this.logger, t == null ? void 0 : t.keychain), this.history = new ai(this, this.logger), this.expirer = new hi(this, this.logger), this.storage = t != null && t.storage ? t.storage : new h$2(Di(Di({}, Je), t == null ? void 0 : t.storageOptions)), this.relayer = new ti({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new oi(this, this.logger), this.verify = new ci(this, this.logger, this.storage), this.echoClient = new li(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new pi(this, this.logger, t == null ? void 0 : t.telemetryEnabled);
  }
  static async init(t) {
    const Ie = new rf(t);
    await Ie.initialize();
    const Me = await Ie.crypto.getClientId();
    return await Ie.storage.setItem(lt$2, Me), Ie;
  }
  get context() {
    return y$3(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var t;
    return (t = this.logChunkController) == null ? void 0 : t.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(t) {
    this.linkModeSupportedApps.includes(t) || (this.linkModeSupportedApps.push(t), await this.storage.setItem(fe$1, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.eventClient.init(), this.linkModeSupportedApps = await this.storage.getItem(fe$1) || [], this.initialized = !0, this.logger.info("Core Initialization Success");
    } catch (t) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, t), this.logger.error(t.message), t;
    }
  }
};
const bn = ne$2;
function unfetch_module(Ae, t) {
  return t = t || {}, new Promise(function(Ie, Me) {
    var Be = new XMLHttpRequest(), Pe = [], Te = [], je = {}, Ve = function() {
      return { ok: (Be.status / 100 | 0) == 2, statusText: Be.statusText, status: Be.status, url: Be.responseURL, text: function() {
        return Promise.resolve(Be.responseText);
      }, json: function() {
        return Promise.resolve(Be.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([Be.response]));
      }, clone: Ve, headers: { keys: function() {
        return Pe;
      }, entries: function() {
        return Te;
      }, get: function(Ue) {
        return je[Ue.toLowerCase()];
      }, has: function(Ue) {
        return Ue.toLowerCase() in je;
      } } };
    };
    for (var fi in Be.open(t.method || "get", Ae, !0), Be.onload = function() {
      Be.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(Ue, bi, vi) {
        Pe.push(bi = bi.toLowerCase()), Te.push([bi, vi]), je[bi] = je[bi] ? je[bi] + "," + vi : vi;
      }), Ie(Ve());
    }, Be.onerror = Me, Be.withCredentials = t.credentials == "include", t.headers) Be.setRequestHeader(fi, t.headers[fi]);
    Be.send(t.body || null);
  });
}
const unfetch_module$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: unfetch_module
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(unfetch_module$1);
var browser = self.fetch || (self.fetch = require$$0.default || require$$0);
const ke = /* @__PURE__ */ getDefaultExportFromCjs(browser);
class G {
  constructor(t) {
    this.client = t;
  }
}
class H {
  constructor(t) {
    this.opts = t;
  }
}
const Y$1 = "https://rpc.walletconnect.com/v1", R$1 = { wc_authRequest: { req: { ttl: cjs$3.ONE_DAY, prompt: !0, tag: 3e3 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 3001 } } }, U$1 = { min: cjs$3.FIVE_MINUTES, max: cjs$3.SEVEN_DAYS }, $ = "wc", Q = 1, Z$1 = "auth", B$1 = "authClient", F$1 = `${$}@1:${Z$1}:`, x$2 = `${F$1}:PUB_KEY`;
function z$2(Ae) {
  return Ae == null ? void 0 : Ae.split(":");
}
function Ze(Ae) {
  const t = Ae && z$2(Ae);
  if (t) return t[3];
}
function We(Ae) {
  const t = Ae && z$2(Ae);
  if (t) return t[2] + ":" + t[3];
}
function W(Ae) {
  const t = Ae && z$2(Ae);
  if (t) return t.pop();
}
async function et(Ae, t, Ie, Me, Be) {
  switch (Ie.t) {
    case "eip191":
      return tt(Ae, t, Ie.s);
    case "eip1271":
      return await rt$1(Ae, t, Ie.s, Me, Be);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${Ie.t}`);
  }
}
function tt(Ae, t, Ie) {
  return recoverAddress(hashMessage(t), Ie).toLowerCase() === Ae.toLowerCase();
}
async function rt$1(Ae, t, Ie, Me, Be) {
  try {
    const Pe = "0x1626ba7e", Te = "0000000000000000000000000000000000000000000000000000000000000040", je = "0000000000000000000000000000000000000000000000000000000000000041", Ve = Ie.substring(2), fi = hashMessage(t).substring(2), Ue = Pe + fi + Te + je + Ve, bi = await ke(`${Y$1}/?chainId=${Me}&projectId=${Be}`, { method: "POST", body: JSON.stringify({ id: it$1(), jsonrpc: "2.0", method: "eth_call", params: [{ to: Ae, data: Ue }, "latest"] }) }), { result: vi } = await bi.json();
    return vi ? vi.slice(0, Pe.length).toLowerCase() === Pe.toLowerCase() : !1;
  } catch (Pe) {
    return console.error("isValidEip1271Signature: ", Pe), !1;
  }
}
function it$1() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function ee$1(Ae) {
  return Ae.getAll().filter((t) => "requester" in t);
}
function te$1(Ae, t) {
  return ee$1(Ae).find((Ie) => Ie.id === t);
}
function nt$1(Ae) {
  const t = Gr$1(Ae.aud), Ie = new RegExp(`${Ae.domain}`).test(Ae.aud), Me = !!Ae.nonce, Be = Ae.type ? Ae.type === "eip4361" : !0, Pe = Ae.expiry;
  if (Pe && !po(Pe, U$1)) {
    const { message: Te } = S$4("MISSING_OR_INVALID", `request() expiry: ${Pe}. Expiry must be a number (in seconds) between ${U$1.min} and ${U$1.max}`);
    throw new Error(Te);
  }
  return !!(t && Ie && Me && Be);
}
function st$1(Ae, t) {
  return !!te$1(t, Ae.id);
}
function ot$1(Ae = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(Ae) : new Uint8Array(Ae);
}
function ut$1(Ae, t) {
  if (Ae.length >= 255) throw new TypeError("Alphabet too long");
  for (var Ie = new Uint8Array(256), Me = 0; Me < Ie.length; Me++) Ie[Me] = 255;
  for (var Be = 0; Be < Ae.length; Be++) {
    var Pe = Ae.charAt(Be), Te = Pe.charCodeAt(0);
    if (Ie[Te] !== 255) throw new TypeError(Pe + " is ambiguous");
    Ie[Te] = Be;
  }
  var je = Ae.length, Ve = Ae.charAt(0), fi = Math.log(je) / Math.log(256), Ue = Math.log(256) / Math.log(je);
  function bi(_i) {
    if (_i instanceof Uint8Array || (ArrayBuffer.isView(_i) ? _i = new Uint8Array(_i.buffer, _i.byteOffset, _i.byteLength) : Array.isArray(_i) && (_i = Uint8Array.from(_i))), !(_i instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (_i.length === 0) return "";
    for (var Ei = 0, Pi = 0, Ii = 0, Ci = _i.length; Ii !== Ci && _i[Ii] === 0; ) Ii++, Ei++;
    for (var Wi = (Ci - Ii) * Ue + 1 >>> 0, zi = new Uint8Array(Wi); Ii !== Ci; ) {
      for (var Xi = _i[Ii], Qi = 0, Oi = Wi - 1; (Xi !== 0 || Qi < Pi) && Oi !== -1; Oi--, Qi++) Xi += 256 * zi[Oi] >>> 0, zi[Oi] = Xi % je >>> 0, Xi = Xi / je >>> 0;
      if (Xi !== 0) throw new Error("Non-zero carry");
      Pi = Qi, Ii++;
    }
    for (var Yi = Wi - Pi; Yi !== Wi && zi[Yi] === 0; ) Yi++;
    for (var ns = Ve.repeat(Ei); Yi < Wi; ++Yi) ns += Ae.charAt(zi[Yi]);
    return ns;
  }
  function vi(_i) {
    if (typeof _i != "string") throw new TypeError("Expected String");
    if (_i.length === 0) return new Uint8Array();
    var Ei = 0;
    if (_i[Ei] !== " ") {
      for (var Pi = 0, Ii = 0; _i[Ei] === Ve; ) Pi++, Ei++;
      for (var Ci = (_i.length - Ei) * fi + 1 >>> 0, Wi = new Uint8Array(Ci); _i[Ei]; ) {
        var zi = Ie[_i.charCodeAt(Ei)];
        if (zi === 255) return;
        for (var Xi = 0, Qi = Ci - 1; (zi !== 0 || Xi < Ii) && Qi !== -1; Qi--, Xi++) zi += je * Wi[Qi] >>> 0, Wi[Qi] = zi % 256 >>> 0, zi = zi / 256 >>> 0;
        if (zi !== 0) throw new Error("Non-zero carry");
        Ii = Xi, Ei++;
      }
      if (_i[Ei] !== " ") {
        for (var Oi = Ci - Ii; Oi !== Ci && Wi[Oi] === 0; ) Oi++;
        for (var Yi = new Uint8Array(Pi + (Ci - Oi)), ns = Pi; Oi !== Ci; ) Yi[ns++] = Wi[Oi++];
        return Yi;
      }
    }
  }
  function mi(_i) {
    var Ei = vi(_i);
    if (Ei) return Ei;
    throw new Error(`Non-${t} character`);
  }
  return { encode: bi, decodeUnsafe: vi, decode: mi };
}
var at$1 = ut$1, Dt = at$1;
const re = (Ae) => {
  if (Ae instanceof Uint8Array && Ae.constructor.name === "Uint8Array") return Ae;
  if (Ae instanceof ArrayBuffer) return new Uint8Array(Ae);
  if (ArrayBuffer.isView(Ae)) return new Uint8Array(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  throw new Error("Unknown type, must be binary type");
}, ct$1 = (Ae) => new TextEncoder().encode(Ae), ht$1 = (Ae) => new TextDecoder().decode(Ae);
let lt$1 = class {
  constructor(t, Ie, Me) {
    this.name = t, this.prefix = Ie, this.baseEncode = Me;
  }
  encode(t) {
    if (t instanceof Uint8Array) return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
}, dt$1 = class {
  constructor(t, Ie, Me) {
    if (this.name = t, this.prefix = Ie, Ie.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = Ie.codePointAt(0), this.baseDecode = Me;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(t) {
    return ie$1(this, t);
  }
}, pt$1 = class {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return ie$1(this, t);
  }
  decode(t) {
    const Ie = t[0], Me = this.decoders[Ie];
    if (Me) return Me.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
const ie$1 = (Ae, t) => new pt$1({ ...Ae.decoders || { [Ae.prefix]: Ae }, ...t.decoders || { [t.prefix]: t } });
class ft {
  constructor(t, Ie, Me, Be) {
    this.name = t, this.prefix = Ie, this.baseEncode = Me, this.baseDecode = Be, this.encoder = new lt$1(t, Ie, Me), this.decoder = new dt$1(t, Ie, Be);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
}
const O$1 = ({ name: Ae, prefix: t, encode: Ie, decode: Me }) => new ft(Ae, t, Ie, Me), T$1 = ({ prefix: Ae, name: t, alphabet: Ie }) => {
  const { encode: Me, decode: Be } = Dt(Ie, t);
  return O$1({ prefix: Ae, name: t, encode: Me, decode: (Pe) => re(Be(Pe)) });
}, gt$1 = (Ae, t, Ie, Me) => {
  const Be = {};
  for (let Ue = 0; Ue < t.length; ++Ue) Be[t[Ue]] = Ue;
  let Pe = Ae.length;
  for (; Ae[Pe - 1] === "="; ) --Pe;
  const Te = new Uint8Array(Pe * Ie / 8 | 0);
  let je = 0, Ve = 0, fi = 0;
  for (let Ue = 0; Ue < Pe; ++Ue) {
    const bi = Be[Ae[Ue]];
    if (bi === void 0) throw new SyntaxError(`Non-${Me} character`);
    Ve = Ve << Ie | bi, je += Ie, je >= 8 && (je -= 8, Te[fi++] = 255 & Ve >> je);
  }
  if (je >= Ie || 255 & Ve << 8 - je) throw new SyntaxError("Unexpected end of data");
  return Te;
}, Et = (Ae, t, Ie) => {
  const Me = t[t.length - 1] === "=", Be = (1 << Ie) - 1;
  let Pe = "", Te = 0, je = 0;
  for (let Ve = 0; Ve < Ae.length; ++Ve) for (je = je << 8 | Ae[Ve], Te += 8; Te > Ie; ) Te -= Ie, Pe += t[Be & je >> Te];
  if (Te && (Pe += t[Be & je << Ie - Te]), Me) for (; Pe.length * Ie & 7; ) Pe += "=";
  return Pe;
}, d = ({ name: Ae, prefix: t, bitsPerChar: Ie, alphabet: Me }) => O$1({ prefix: t, name: Ae, encode(Be) {
  return Et(Be, Me, Ie);
}, decode(Be) {
  return gt$1(Be, Me, Ie, Ae);
} }), bt = O$1({ prefix: "\0", name: "identity", encode: (Ae) => ht$1(Ae), decode: (Ae) => ct$1(Ae) });
var yt$1 = Object.freeze({ __proto__: null, identity: bt });
const wt = d({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Ct = Object.freeze({ __proto__: null, base2: wt });
const mt = d({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var vt = Object.freeze({ __proto__: null, base8: mt });
const At = T$1({ prefix: "9", name: "base10", alphabet: "0123456789" });
var _t = Object.freeze({ __proto__: null, base10: At });
const xt = d({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), Rt = d({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ft = Object.freeze({ __proto__: null, base16: xt, base16upper: Rt });
const Tt = d({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), It = d({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), qt = d({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), Ut = d({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), Ot = d({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), St = d({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), Pt = d({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), Nt = d({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), $t = d({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Bt = Object.freeze({ __proto__: null, base32: Tt, base32upper: It, base32pad: qt, base32padupper: Ut, base32hex: Ot, base32hexupper: St, base32hexpad: Pt, base32hexpadupper: Nt, base32z: $t });
const zt = T$1({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), jt = T$1({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Mt = Object.freeze({ __proto__: null, base36: zt, base36upper: jt });
const Lt = T$1({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), Kt = T$1({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Vt = Object.freeze({ __proto__: null, base58btc: Lt, base58flickr: Kt });
const kt = d({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), Jt = d({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), Xt = d({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), Gt = d({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ht = Object.freeze({ __proto__: null, base64: kt, base64pad: Jt, base64url: Xt, base64urlpad: Gt });
const ne$1 = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), Yt = ne$1.reduce((Ae, t, Ie) => (Ae[Ie] = t, Ae), []), Qt = ne$1.reduce((Ae, t, Ie) => (Ae[t.codePointAt(0)] = Ie, Ae), []);
function Zt(Ae) {
  return Ae.reduce((t, Ie) => (t += Yt[Ie], t), "");
}
function Wt(Ae) {
  const t = [];
  for (const Ie of Ae) {
    const Me = Qt[Ie.codePointAt(0)];
    if (Me === void 0) throw new Error(`Non-base256emoji character: ${Ie}`);
    t.push(Me);
  }
  return new Uint8Array(t);
}
const er = O$1({ prefix: "🚀", name: "base256emoji", encode: Zt, decode: Wt });
var tr = Object.freeze({ __proto__: null, base256emoji: er }), rr = oe$1, se$1 = 128, ir = 127, nr = ~ir, sr = Math.pow(2, 31);
function oe$1(Ae, t, Ie) {
  t = t || [], Ie = Ie || 0;
  for (var Me = Ie; Ae >= sr; ) t[Ie++] = Ae & 255 | se$1, Ae /= 128;
  for (; Ae & nr; ) t[Ie++] = Ae & 255 | se$1, Ae >>>= 7;
  return t[Ie] = Ae | 0, oe$1.bytes = Ie - Me + 1, t;
}
var or = j$1, ur = 128, ue = 127;
function j$1(Ae, Me) {
  var Ie = 0, Me = Me || 0, Be = 0, Pe = Me, Te, je = Ae.length;
  do {
    if (Pe >= je) throw j$1.bytes = 0, new RangeError("Could not decode varint");
    Te = Ae[Pe++], Ie += Be < 28 ? (Te & ue) << Be : (Te & ue) * Math.pow(2, Be), Be += 7;
  } while (Te >= ur);
  return j$1.bytes = Pe - Me, Ie;
}
var ar = Math.pow(2, 7), Dr = Math.pow(2, 14), cr = Math.pow(2, 21), hr = Math.pow(2, 28), lr = Math.pow(2, 35), dr = Math.pow(2, 42), pr = Math.pow(2, 49), fr = Math.pow(2, 56), gr = Math.pow(2, 63), Er = function(Ae) {
  return Ae < ar ? 1 : Ae < Dr ? 2 : Ae < cr ? 3 : Ae < hr ? 4 : Ae < lr ? 5 : Ae < dr ? 6 : Ae < pr ? 7 : Ae < fr ? 8 : Ae < gr ? 9 : 10;
}, br = { encode: rr, decode: or, encodingLength: Er }, ae$1 = br;
const De = (Ae, t, Ie = 0) => (ae$1.encode(Ae, t, Ie), t), ce = (Ae) => ae$1.encodingLength(Ae), M = (Ae, t) => {
  const Ie = t.byteLength, Me = ce(Ae), Be = Me + ce(Ie), Pe = new Uint8Array(Be + Ie);
  return De(Ae, Pe, 0), De(Ie, Pe, Me), Pe.set(t, Be), new yr(Ae, Ie, t, Pe);
};
class yr {
  constructor(t, Ie, Me, Be) {
    this.code = t, this.size = Ie, this.digest = Me, this.bytes = Be;
  }
}
const he = ({ name: Ae, code: t, encode: Ie }) => new wr(Ae, t, Ie);
class wr {
  constructor(t, Ie, Me) {
    this.name = t, this.code = Ie, this.encode = Me;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const Ie = this.encode(t);
      return Ie instanceof Uint8Array ? M(this.code, Ie) : Ie.then((Me) => M(this.code, Me));
    } else throw Error("Unknown type, must be binary type");
  }
}
const le = (Ae) => async (t) => new Uint8Array(await crypto.subtle.digest(Ae, t)), Cr = he({ name: "sha2-256", code: 18, encode: le("SHA-256") }), mr = he({ name: "sha2-512", code: 19, encode: le("SHA-512") });
var vr = Object.freeze({ __proto__: null, sha256: Cr, sha512: mr });
const de = 0, Ar = "identity", pe = re, _r = (Ae) => M(de, pe(Ae)), xr = { code: de, name: Ar, encode: pe, digest: _r };
var Rr = Object.freeze({ __proto__: null, identity: xr });
new TextEncoder(), new TextDecoder();
const fe = { ...yt$1, ...Ct, ...vt, ..._t, ...Ft, ...Bt, ...Mt, ...Vt, ...Ht, ...tr };
({ ...vr, ...Rr });
function ge(Ae, t, Ie, Me) {
  return { name: Ae, prefix: t, encoder: { name: Ae, prefix: t, encode: Ie }, decoder: { decode: Me } };
}
const Ee = ge("utf8", "u", (Ae) => "u" + new TextDecoder("utf8").decode(Ae), (Ae) => new TextEncoder().encode(Ae.substring(1))), L$1 = ge("ascii", "a", (Ae) => {
  let t = "a";
  for (let Ie = 0; Ie < Ae.length; Ie++) t += String.fromCharCode(Ae[Ie]);
  return t;
}, (Ae) => {
  Ae = Ae.substring(1);
  const t = ot$1(Ae.length);
  for (let Ie = 0; Ie < Ae.length; Ie++) t[Ie] = Ae.charCodeAt(Ie);
  return t;
}), be$1 = { utf8: Ee, "utf-8": Ee, hex: fe.base16, latin1: L$1, ascii: L$1, binary: L$1, ...fe };
function Fr(Ae, t = "utf8") {
  const Ie = be$1[t];
  if (!Ie) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(Ae, "utf8") : Ie.decoder.decode(`${Ie.prefix}${Ae}`);
}
function Tr(Ae, t = "utf8") {
  const Ie = be$1[t];
  if (!Ie) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(Ae.buffer, Ae.byteOffset, Ae.byteLength).toString("utf8") : Ie.encoder.encode(Ae).substring(1);
}
const ye$1 = "base16", we$1 = "utf8";
function K$1(Ae) {
  const t = sha256.hash(Fr(Ae, we$1));
  return Tr(t, ye$1);
}
var Or = Object.defineProperty, Sr = Object.defineProperties, Pr = Object.getOwnPropertyDescriptors, Ce$1 = Object.getOwnPropertySymbols, Nr = Object.prototype.hasOwnProperty, $r = Object.prototype.propertyIsEnumerable, me$1 = (Ae, t, Ie) => t in Ae ? Or(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, I$1 = (Ae, t) => {
  for (var Ie in t || (t = {})) Nr.call(t, Ie) && me$1(Ae, Ie, t[Ie]);
  if (Ce$1) for (var Ie of Ce$1(t)) $r.call(t, Ie) && me$1(Ae, Ie, t[Ie]);
  return Ae;
}, V$1 = (Ae, t) => Sr(Ae, Pr(t));
class Br extends G {
  constructor(t) {
    super(t), this.initialized = !1, this.name = "authEngine", this.init = () => {
      this.initialized || (this.registerRelayerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(R$1) }), this.initialized = !0);
    }, this.request = async (Ie, Me) => {
      if (this.isInitialized(), !nt$1(Ie)) throw new Error("Invalid request");
      if (Me != null && Me.topic) return await this.requestOnKnownPairing(Me.topic, Ie);
      const { chainId: Be, statement: Pe, aud: Te, domain: je, nonce: Ve, type: fi, exp: Ue, nbf: bi } = Ie, { topic: vi, uri: mi } = await this.client.core.pairing.create();
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: vi, uri: mi } });
      const _i = await this.client.core.crypto.generateKeyPair(), Ei = hr$2(_i);
      await this.client.authKeys.set(x$2, { responseTopic: Ei, publicKey: _i }), await this.client.pairingTopics.set(Ei, { topic: Ei, pairingTopic: vi }), await this.client.core.relayer.subscribe(Ei), this.client.logger.info(`sending request to new pairing topic: ${vi}`);
      const Pi = await this.sendRequest(vi, "wc_authRequest", { payloadParams: { type: fi ?? "eip4361", chainId: Be, statement: Pe, aud: Te, domain: je, version: "1", nonce: Ve, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: Ue, nbf: bi }, requester: { publicKey: _i, metadata: this.client.metadata } }, {}, Ie.expiry);
      return this.client.logger.info(`sent request to new pairing topic: ${vi}`), { uri: mi, id: Pi };
    }, this.respond = async (Ie, Me) => {
      if (this.isInitialized(), !st$1(Ie, this.client.requests)) throw new Error("Invalid response");
      const Be = te$1(this.client.requests, Ie.id);
      if (!Be) throw new Error(`Could not find pending auth request with id ${Ie.id}`);
      const Pe = Be.requester.publicKey, Te = await this.client.core.crypto.generateKeyPair(), je = hr$2(Pe), Ve = { type: D$2, receiverPublicKey: Pe, senderPublicKey: Te };
      if ("error" in Ie) {
        await this.sendError(Be.id, je, Ie, Ve);
        return;
      }
      const fi = { h: { t: "eip4361" }, p: V$1(I$1({}, Be.cacaoPayload), { iss: Me }), s: Ie.signature };
      await this.sendResult(Be.id, je, fi, Ve), await this.client.core.pairing.activate({ topic: Be.pairingTopic }), await this.client.requests.update(Be.id, I$1({}, fi));
    }, this.getPendingRequests = () => ee$1(this.client.requests), this.formatMessage = (Ie, Me) => {
      this.client.logger.debug(`formatMessage, cacao is: ${JSON.stringify(Ie)}`);
      const Be = `${Ie.domain} wants you to sign in with your Ethereum account:`, Pe = W(Me), Te = Ie.statement, je = `URI: ${Ie.aud}`, Ve = `Version: ${Ie.version}`, fi = `Chain ID: ${Ze(Me)}`, Ue = `Nonce: ${Ie.nonce}`, bi = `Issued At: ${Ie.iat}`, vi = Ie.exp ? `Expiry: ${Ie.exp}` : void 0, mi = Ie.resources && Ie.resources.length > 0 ? `Resources:
${Ie.resources.map((_i) => `- ${_i}`).join(`
`)}` : void 0;
      return [Be, Pe, "", Te, "", je, Ve, fi, Ue, bi, vi, mi].filter((_i) => _i != null).join(`
`);
    }, this.setExpiry = async (Ie, Me) => {
      this.client.core.pairing.pairings.keys.includes(Ie) && await this.client.core.pairing.updateExpiry({ topic: Ie, expiry: Me }), this.client.core.expirer.set(Ie, Me);
    }, this.sendRequest = async (Ie, Me, Be, Pe, Te) => {
      const je = formatJsonRpcRequest(Me, Be), Ve = await this.client.core.crypto.encode(Ie, je, Pe), fi = R$1[Me].req;
      if (Te && (fi.ttl = Te), this.client.core.history.set(Ie, je), V$3()) {
        const Ue = K$1(JSON.stringify(je));
        this.client.core.verify.register({ attestationId: Ue });
      }
      return await this.client.core.relayer.publish(Ie, Ve, V$1(I$1({}, fi), { internal: { throwOnFailedPublish: !0 } })), je.id;
    }, this.sendResult = async (Ie, Me, Be, Pe) => {
      const Te = formatJsonRpcResult(Ie, Be), je = await this.client.core.crypto.encode(Me, Te, Pe), Ve = await this.client.core.history.get(Me, Ie), fi = R$1[Ve.request.method].res;
      return await this.client.core.relayer.publish(Me, je, V$1(I$1({}, fi), { internal: { throwOnFailedPublish: !0 } })), await this.client.core.history.resolve(Te), Te.id;
    }, this.sendError = async (Ie, Me, Be, Pe) => {
      const Te = formatJsonRpcError(Ie, Be.error), je = await this.client.core.crypto.encode(Me, Te, Pe), Ve = await this.client.core.history.get(Me, Ie), fi = R$1[Ve.request.method].res;
      return await this.client.core.relayer.publish(Me, je, fi), await this.client.core.history.resolve(Te), Te.id;
    }, this.requestOnKnownPairing = async (Ie, Me) => {
      const Be = this.client.core.pairing.pairings.getAll({ active: !0 }).find((mi) => mi.topic === Ie);
      if (!Be) throw new Error(`Could not find pairing for provided topic ${Ie}`);
      const { publicKey: Pe } = this.client.authKeys.get(x$2), { chainId: Te, statement: je, aud: Ve, domain: fi, nonce: Ue, type: bi } = Me, vi = await this.sendRequest(Be.topic, "wc_authRequest", { payloadParams: { type: bi ?? "eip4361", chainId: Te, statement: je, aud: Ve, domain: fi, version: "1", nonce: Ue, iat: (/* @__PURE__ */ new Date()).toISOString() }, requester: { publicKey: Pe, metadata: this.client.metadata } }, {}, Me.expiry);
      return this.client.logger.info(`sent request to known pairing topic: ${Be.topic}`), { id: vi };
    }, this.onPairingCreated = (Ie) => {
      const Me = this.getPendingRequests();
      if (Me) {
        const Be = Object.values(Me).find((Pe) => Pe.pairingTopic === Ie.topic);
        Be && this.handleAuthRequest(Be);
      }
    }, this.onRelayEventRequest = (Ie) => {
      const { topic: Me, payload: Be } = Ie, Pe = Be.method;
      switch (Pe) {
        case "wc_authRequest":
          return this.onAuthRequest(Me, Be);
        default:
          return this.client.logger.info(`Unsupported request method ${Pe}`);
      }
    }, this.onRelayEventResponse = async (Ie) => {
      const { topic: Me, payload: Be } = Ie, Pe = (await this.client.core.history.get(Me, Be.id)).request.method;
      switch (Pe) {
        case "wc_authRequest":
          return this.onAuthResponse(Me, Be);
        default:
          return this.client.logger.info(`Unsupported response method ${Pe}`);
      }
    }, this.onAuthRequest = async (Ie, Me) => {
      const { requester: Be, payloadParams: Pe } = Me.params;
      this.client.logger.info({ type: "onAuthRequest", topic: Ie, payload: Me });
      const Te = K$1(JSON.stringify(Me)), je = await this.getVerifyContext(Te, this.client.metadata), Ve = { requester: Be, pairingTopic: Ie, id: Me.id, cacaoPayload: Pe, verifyContext: je };
      await this.client.requests.set(Me.id, Ve), this.handleAuthRequest(Ve);
    }, this.handleAuthRequest = async (Ie) => {
      const { id: Me, pairingTopic: Be, requester: Pe, cacaoPayload: Te, verifyContext: je } = Ie;
      try {
        this.client.emit("auth_request", { id: Me, topic: Be, params: { requester: Pe, cacaoPayload: Te }, verifyContext: je });
      } catch (Ve) {
        await this.sendError(Ie.id, Ie.pairingTopic, Ve), this.client.logger.error(Ve);
      }
    }, this.onAuthResponse = async (Ie, Me) => {
      const { id: Be } = Me;
      if (this.client.logger.info({ type: "onAuthResponse", topic: Ie, response: Me }), isJsonRpcResult(Me)) {
        const { pairingTopic: Pe } = this.client.pairingTopics.get(Ie);
        await this.client.core.pairing.activate({ topic: Pe });
        const { s: Te, p: je } = Me.result;
        await this.client.requests.set(Be, I$1({ id: Be, pairingTopic: Pe }, Me.result));
        const Ve = this.formatMessage(je, je.iss);
        this.client.logger.debug(`reconstructed message:
`, JSON.stringify(Ve)), this.client.logger.debug("payload.iss:", je.iss), this.client.logger.debug("signature:", Te);
        const fi = W(je.iss), Ue = We(je.iss);
        if (!fi) throw new Error("Could not derive address from `payload.iss`");
        if (!Ue) throw new Error("Could not derive chainId from `payload.iss`");
        this.client.logger.debug("walletAddress extracted from `payload.iss`:", fi), await et(fi, Ve, Te, Ue, this.client.projectId) ? this.client.emit("auth_response", { id: Be, topic: Ie, params: Me }) : this.client.emit("auth_response", { id: Be, topic: Ie, params: { message: "Invalid signature", code: -1 } });
      } else isJsonRpcError(Me) && this.client.emit("auth_response", { id: Be, topic: Ie, params: Me });
    }, this.getVerifyContext = async (Ie, Me) => {
      const Be = { verified: { verifyUrl: Me.verifyUrl || "", validation: "UNKNOWN", origin: Me.url || "" } };
      try {
        const Pe = await this.client.core.verify.resolve({ attestationId: Ie, verifyUrl: Me.verifyUrl });
        Pe && (Be.verified.origin = Pe.origin, Be.verified.isScam = Pe.isScam, Be.verified.validation = origin === new URL(Me.url).origin ? "VALID" : "INVALID");
      } catch (Pe) {
        this.client.logger.error(Pe);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(Be)}`), Be;
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(v$2.message, async (t) => {
      const { topic: Ie, message: Me } = t, { responseTopic: Be, publicKey: Pe } = this.client.authKeys.keys.includes(x$2) ? this.client.authKeys.get(x$2) : { responseTopic: void 0, publicKey: void 0 };
      if (Be && Ie !== Be) {
        this.client.logger.debug("[Auth] Ignoring message from unknown topic", Ie);
        return;
      }
      const Te = await this.client.core.crypto.decode(Ie, Me, { receiverPublicKey: Pe });
      isJsonRpcRequest(Te) ? (this.client.core.history.set(Ie, Te), this.onRelayEventRequest({ topic: Ie, payload: Te })) : isJsonRpcResponse(Te) && (await this.client.core.history.resolve(Te), this.onRelayEventResponse({ topic: Ie, payload: Te }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(V$2.create, (t) => this.onPairingCreated(t));
  }
}
let S$1 = class nf extends H {
  constructor(t) {
    super(t), this.protocol = $, this.version = Q, this.name = B$1, this.events = new eventsExports.EventEmitter(), this.emit = (Me, Be) => this.events.emit(Me, Be), this.on = (Me, Be) => this.events.on(Me, Be), this.once = (Me, Be) => this.events.once(Me, Be), this.off = (Me, Be) => this.events.off(Me, Be), this.removeListener = (Me, Be) => this.events.removeListener(Me, Be), this.request = async (Me, Be) => {
      try {
        return await this.engine.request(Me, Be);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.respond = async (Me, Be) => {
      try {
        return await this.engine.respond(Me, Be);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.getPendingRequests = () => {
      try {
        return this.engine.getPendingRequests();
      } catch (Me) {
        throw this.logger.error(Me.message), Me;
      }
    }, this.formatMessage = (Me, Be) => {
      try {
        return this.engine.formatMessage(Me, Be);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    };
    const Ie = typeof t.logger < "u" && typeof t.logger != "string" ? t.logger : qt$3(k$2({ level: t.logger || "error" }));
    this.name = (t == null ? void 0 : t.name) || B$1, this.metadata = t.metadata, this.projectId = t.projectId, this.core = t.core || new bn(t), this.logger = E$1(Ie, this.name), this.authKeys = new ni(this.core, this.logger, "authKeys", F$1, () => x$2), this.pairingTopics = new ni(this.core, this.logger, "pairingTopics", F$1), this.requests = new ni(this.core, this.logger, "requests", F$1, (Me) => Me.id), this.engine = new Br(this);
  }
  static async init(t) {
    const Ie = new nf(t);
    return await Ie.initialize(), Ie;
  }
  get context() {
    return y$3(this.logger);
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.authKeys.init(), await this.requests.init(), await this.pairingTopics.init(), await this.engine.init(), this.logger.info("AuthClient Initialization Success"), this.logger.info({ authClient: this });
    } catch (t) {
      throw this.logger.info("AuthClient Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
const zr = S$1, be = "wc", Ce = 2, Le = "client", ye = `${be}@${Ce}:${Le}:`, we = { name: Le, logger: "error", controller: !1, relayUrl: "wss://relay.walletconnect.org" }, xe = "WALLETCONNECT_DEEPLINK_CHOICE", st = "proposal", it = "Proposal expired", rt = "session", z$1 = cjs$3.SEVEN_DAYS, nt = "engine", v$1 = { wc_sessionPropose: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1101 }, reject: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1120 }, autoReject: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1121 } }, wc_sessionSettle: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1114 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: cjs$3.ONE_HOUR, prompt: !0, tag: 1116 }, res: { ttl: cjs$3.ONE_HOUR, prompt: !1, tag: 1117 }, reject: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1118 }, autoReject: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1119 } } }, me = { min: cjs$3.FIVE_MINUTES, max: cjs$3.SEVEN_DAYS }, x$1 = { idle: "IDLE", active: "ACTIVE" }, ot = "request", at = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"], ct = "wc", lt = "auth", pt = "authKeys", ht = "pairingTopics", dt = "requests", oe = `${ct}@${1.5}:${lt}:`, ae = `${oe}:PUB_KEY`;
var ys = Object.defineProperty, ws = Object.defineProperties, ms = Object.getOwnPropertyDescriptors, ut = Object.getOwnPropertySymbols, _s = Object.prototype.hasOwnProperty, Es = Object.prototype.propertyIsEnumerable, gt = (Ae, t, Ie) => t in Ae ? ys(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, I = (Ae, t) => {
  for (var Ie in t || (t = {})) _s.call(t, Ie) && gt(Ae, Ie, t[Ie]);
  if (ut) for (var Ie of ut(t)) Es.call(t, Ie) && gt(Ae, Ie, t[Ie]);
  return Ae;
}, D$1 = (Ae, t) => ws(Ae, ms(t));
class Rs extends M$3 {
  constructor(t) {
    super(t), this.name = nt, this.events = new es(), this.initialized = !1, this.requestQueue = { state: x$1.idle, queue: [] }, this.sessionRequestQueue = { state: x$1.idle, queue: [] }, this.requestQueueDelay = cjs$3.ONE_SECOND, this.expectedPairingMethodMap = /* @__PURE__ */ new Map(), this.recentlyDeletedMap = /* @__PURE__ */ new Map(), this.recentlyDeletedLimit = 200, this.relayMessageCache = [], this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(v$1) }), this.initialized = !0, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, cjs$3.toMiliseconds(this.requestQueueDelay)));
    }, this.connect = async (Ie) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const Me = D$1(I({}, Ie), { requiredNamespaces: Ie.requiredNamespaces || {}, optionalNamespaces: Ie.optionalNamespaces || {} });
      await this.isValidConnect(Me);
      const { pairingTopic: Be, requiredNamespaces: Pe, optionalNamespaces: Te, sessionProperties: je, relays: Ve } = Me;
      let fi = Be, Ue, bi = !1;
      try {
        fi && (bi = this.client.core.pairing.pairings.get(fi).active);
      } catch (zi) {
        throw this.client.logger.error(`connect() -> pairing.get(${fi}) failed`), zi;
      }
      if (!fi || !bi) {
        const { topic: zi, uri: Xi } = await this.client.core.pairing.create();
        fi = zi, Ue = Xi;
      }
      if (!fi) {
        const { message: zi } = S$4("NO_MATCHING_KEY", `connect() pairing topic: ${fi}`);
        throw new Error(zi);
      }
      const vi = await this.client.core.crypto.generateKeyPair(), mi = v$1.wc_sessionPropose.req.ttl || cjs$3.FIVE_MINUTES, _i = Mt$2(mi), Ei = I({ requiredNamespaces: Pe, optionalNamespaces: Te, relays: Ve ?? [{ protocol: rt$2 }], proposer: { publicKey: vi, metadata: this.client.metadata }, expiryTimestamp: _i, pairingTopic: fi }, je && { sessionProperties: je }), { reject: Pi, resolve: Ii, done: Ci } = _t$2(mi, it);
      this.events.once(Lt$2("session_connect"), async ({ error: zi, session: Xi }) => {
        if (zi) Pi(zi);
        else if (Xi) {
          Xi.self.publicKey = vi;
          const Qi = D$1(I({}, Xi), { pairingTopic: Ei.pairingTopic, requiredNamespaces: Ei.requiredNamespaces, optionalNamespaces: Ei.optionalNamespaces, transportType: M$1.relay });
          await this.client.session.set(Xi.topic, Qi), await this.setExpiry(Xi.topic, Xi.expiry), fi && await this.client.core.pairing.updateMetadata({ topic: fi, metadata: Xi.peer.metadata }), this.cleanupDuplicatePairings(Qi), Ii(Qi);
        }
      });
      const Wi = await this.sendRequest({ topic: fi, method: "wc_sessionPropose", params: Ei, throwOnFailedPublish: !0 });
      return await this.setProposal(Wi, I({ id: Wi }, Ei)), { uri: Ue, approval: Ci };
    }, this.pair = async (Ie) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(Ie);
      } catch (Me) {
        throw this.client.logger.error("pair() failed"), Me;
      }
    }, this.approve = async (Ie) => {
      var Me, Be, Pe;
      const Te = this.client.core.eventClient.createEvent({ properties: { topic: (Me = Ie == null ? void 0 : Ie.id) == null ? void 0 : Me.toString(), trace: [Is$1.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (Yi) {
        throw Te.setError(Ts$1.no_internet_connection), Yi;
      }
      try {
        await this.isValidProposalId(Ie == null ? void 0 : Ie.id);
      } catch (Yi) {
        throw this.client.logger.error(`approve() -> proposal.get(${Ie == null ? void 0 : Ie.id}) failed`), Te.setError(Ts$1.proposal_not_found), Yi;
      }
      try {
        await this.isValidApprove(Ie);
      } catch (Yi) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), Te.setError(Ts$1.session_approve_namespace_validation_failure), Yi;
      }
      const { id: je, relayProtocol: Ve, namespaces: fi, sessionProperties: Ue, sessionConfig: bi } = Ie, vi = this.client.proposal.get(je);
      this.client.core.eventClient.deleteEvent({ eventId: Te.eventId });
      const { pairingTopic: mi, proposer: _i, requiredNamespaces: Ei, optionalNamespaces: Pi } = vi;
      let Ii = (Be = this.client.core.eventClient) == null ? void 0 : Be.getEvent({ topic: mi });
      Ii || (Ii = (Pe = this.client.core.eventClient) == null ? void 0 : Pe.createEvent({ type: Is$1.session_approve_started, properties: { topic: mi, trace: [Is$1.session_approve_started, Is$1.session_namespaces_validation_success] } }));
      const Ci = await this.client.core.crypto.generateKeyPair(), Wi = _i.publicKey, zi = await this.client.core.crypto.generateSharedKey(Ci, Wi), Xi = I(I({ relay: { protocol: Ve ?? "irn" }, namespaces: fi, controller: { publicKey: Ci, metadata: this.client.metadata }, expiry: Mt$2(z$1) }, Ue && { sessionProperties: Ue }), bi && { sessionConfig: bi }), Qi = M$1.relay;
      Ii.addTrace(Is$1.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(zi, { transportType: Qi });
      } catch (Yi) {
        throw Ii.setError(Ts$1.subscribe_session_topic_failure), Yi;
      }
      Ii.addTrace(Is$1.subscribe_session_topic_success);
      const Oi = D$1(I({}, Xi), { topic: zi, requiredNamespaces: Ei, optionalNamespaces: Pi, pairingTopic: mi, acknowledged: !1, self: Xi.controller, peer: { publicKey: _i.publicKey, metadata: _i.metadata }, controller: Ci, transportType: M$1.relay });
      await this.client.session.set(zi, Oi), Ii.addTrace(Is$1.store_session);
      try {
        Ii.addTrace(Is$1.publishing_session_settle), await this.sendRequest({ topic: zi, method: "wc_sessionSettle", params: Xi, throwOnFailedPublish: !0 }).catch((Yi) => {
          throw Ii == null || Ii.setError(Ts$1.session_settle_publish_failure), Yi;
        }), Ii.addTrace(Is$1.session_settle_publish_success), Ii.addTrace(Is$1.publishing_session_approve), await this.sendResult({ id: je, topic: mi, result: { relay: { protocol: Ve ?? "irn" }, responderPublicKey: Ci }, throwOnFailedPublish: !0 }).catch((Yi) => {
          throw Ii == null || Ii.setError(Ts$1.session_approve_publish_failure), Yi;
        }), Ii.addTrace(Is$1.session_approve_publish_success);
      } catch (Yi) {
        throw this.client.logger.error(Yi), this.client.session.delete(zi, U$2("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(zi), Yi;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: Ii.eventId }), await this.client.core.pairing.updateMetadata({ topic: mi, metadata: _i.metadata }), await this.client.proposal.delete(je, U$2("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: mi }), await this.setExpiry(zi, Mt$2(z$1)), { topic: zi, acknowledged: () => Promise.resolve(this.client.session.get(zi)) };
    }, this.reject = async (Ie) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(Ie);
      } catch (Te) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), Te;
      }
      const { id: Me, reason: Be } = Ie;
      let Pe;
      try {
        Pe = this.client.proposal.get(Me).pairingTopic;
      } catch (Te) {
        throw this.client.logger.error(`reject() -> proposal.get(${Me}) failed`), Te;
      }
      Pe && (await this.sendError({ id: Me, topic: Pe, error: Be, rpcOpts: v$1.wc_sessionPropose.reject }), await this.client.proposal.delete(Me, U$2("USER_DISCONNECTED")));
    }, this.update = async (Ie) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(Ie);
      } catch (bi) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), bi;
      }
      const { topic: Me, namespaces: Be } = Ie, { done: Pe, resolve: Te, reject: je } = _t$2(), Ve = payloadId(), fi = getBigIntRpcId().toString(), Ue = this.client.session.get(Me).namespaces;
      return this.events.once(Lt$2("session_update", Ve), ({ error: bi }) => {
        bi ? je(bi) : Te();
      }), await this.client.session.update(Me, { namespaces: Be }), await this.sendRequest({ topic: Me, method: "wc_sessionUpdate", params: { namespaces: Be }, throwOnFailedPublish: !0, clientRpcId: Ve, relayRpcId: fi }).catch((bi) => {
        this.client.logger.error(bi), this.client.session.update(Me, { namespaces: Ue }), je(bi);
      }), { acknowledged: Pe };
    }, this.extend = async (Ie) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(Ie);
      } catch (Ve) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), Ve;
      }
      const { topic: Me } = Ie, Be = payloadId(), { done: Pe, resolve: Te, reject: je } = _t$2();
      return this.events.once(Lt$2("session_extend", Be), ({ error: Ve }) => {
        Ve ? je(Ve) : Te();
      }), await this.setExpiry(Me, Mt$2(z$1)), this.sendRequest({ topic: Me, method: "wc_sessionExtend", params: {}, clientRpcId: Be, throwOnFailedPublish: !0 }).catch((Ve) => {
        je(Ve);
      }), { acknowledged: Pe };
    }, this.request = async (Ie) => {
      this.isInitialized();
      try {
        await this.isValidRequest(Ie);
      } catch (_i) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), _i;
      }
      const { chainId: Me, request: Be, topic: Pe, expiry: Te = v$1.wc_sessionRequest.req.ttl } = Ie, je = this.client.session.get(Pe);
      (je == null ? void 0 : je.transportType) === M$1.relay && await this.confirmOnlineStateOrThrow();
      const Ve = payloadId(), fi = getBigIntRpcId().toString(), { done: Ue, resolve: bi, reject: vi } = _t$2(Te, "Request expired. Please try again.");
      this.events.once(Lt$2("session_request", Ve), ({ error: _i, result: Ei }) => {
        _i ? vi(_i) : bi(Ei);
      });
      const mi = this.getAppLinkIfEnabled(je.peer.metadata, je.transportType);
      return mi ? (await this.sendRequest({ clientRpcId: Ve, relayRpcId: fi, topic: Pe, method: "wc_sessionRequest", params: { request: D$1(I({}, Be), { expiryTimestamp: Mt$2(Te) }), chainId: Me }, expiry: Te, throwOnFailedPublish: !0, appLink: mi }).catch((_i) => vi(_i)), this.client.events.emit("session_request_sent", { topic: Pe, request: Be, chainId: Me, id: Ve }), await Ue()) : await Promise.all([new Promise(async (_i) => {
        await this.sendRequest({ clientRpcId: Ve, relayRpcId: fi, topic: Pe, method: "wc_sessionRequest", params: { request: D$1(I({}, Be), { expiryTimestamp: Mt$2(Te) }), chainId: Me }, expiry: Te, throwOnFailedPublish: !0 }).catch((Ei) => vi(Ei)), this.client.events.emit("session_request_sent", { topic: Pe, request: Be, chainId: Me, id: Ve }), _i();
      }), new Promise(async (_i) => {
        var Ei;
        if (!((Ei = je.sessionConfig) != null && Ei.disableDeepLink)) {
          const Pi = await qt$2(this.client.core.storage, xe);
          await Ft$2({ id: Ve, topic: Pe, wcDeepLink: Pi });
        }
        _i();
      }), Ue()]).then((_i) => _i[2]);
    }, this.respond = async (Ie) => {
      this.isInitialized(), await this.isValidRespond(Ie);
      const { topic: Me, response: Be } = Ie, { id: Pe } = Be, Te = this.client.session.get(Me);
      Te.transportType === M$1.relay && await this.confirmOnlineStateOrThrow();
      const je = this.getAppLinkIfEnabled(Te.peer.metadata, Te.transportType);
      isJsonRpcResult(Be) ? await this.sendResult({ id: Pe, topic: Me, result: Be.result, throwOnFailedPublish: !0, appLink: je }) : isJsonRpcError(Be) && await this.sendError({ id: Pe, topic: Me, error: Be.error, appLink: je }), this.cleanupAfterResponse(Ie);
    }, this.ping = async (Ie) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(Ie);
      } catch (Be) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), Be;
      }
      const { topic: Me } = Ie;
      if (this.client.session.keys.includes(Me)) {
        const Be = payloadId(), Pe = getBigIntRpcId().toString(), { done: Te, resolve: je, reject: Ve } = _t$2();
        this.events.once(Lt$2("session_ping", Be), ({ error: fi }) => {
          fi ? Ve(fi) : je();
        }), await Promise.all([this.sendRequest({ topic: Me, method: "wc_sessionPing", params: {}, throwOnFailedPublish: !0, clientRpcId: Be, relayRpcId: Pe }), Te()]);
      } else this.client.core.pairing.pairings.keys.includes(Me) && await this.client.core.pairing.ping({ topic: Me });
    }, this.emit = async (Ie) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(Ie);
      const { topic: Me, event: Be, chainId: Pe } = Ie, Te = getBigIntRpcId().toString();
      await this.sendRequest({ topic: Me, method: "wc_sessionEvent", params: { event: Be, chainId: Pe }, throwOnFailedPublish: !0, relayRpcId: Te });
    }, this.disconnect = async (Ie) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(Ie);
      const { topic: Me } = Ie;
      if (this.client.session.keys.includes(Me)) await this.sendRequest({ topic: Me, method: "wc_sessionDelete", params: U$2("USER_DISCONNECTED"), throwOnFailedPublish: !0 }), await this.deleteSession({ topic: Me, emitEvent: !1 });
      else if (this.client.core.pairing.pairings.keys.includes(Me)) await this.client.core.pairing.disconnect({ topic: Me });
      else {
        const { message: Be } = S$4("MISMATCHED_TOPIC", `Session or pairing topic not found: ${Me}`);
        throw new Error(Be);
      }
    }, this.find = (Ie) => (this.isInitialized(), this.client.session.getAll().filter((Me) => zr$2(Me, Ie))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (Ie, Me) => {
      var Be;
      this.isInitialized(), this.isValidAuthenticate(Ie);
      const Pe = Me && this.client.core.linkModeSupportedApps.includes(Me) && ((Be = this.client.metadata.redirect) == null ? void 0 : Be.linkMode), Te = Pe ? M$1.link_mode : M$1.relay;
      Te === M$1.relay && await this.confirmOnlineStateOrThrow();
      const { chains: je, statement: Ve = "", uri: fi, domain: Ue, nonce: bi, type: vi, exp: mi, nbf: _i, methods: Ei = [], expiry: Pi } = Ie, Ii = [...Ie.resources || []], { topic: Ci, uri: Wi } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: Te });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: Ci, uri: Wi } });
      const zi = await this.client.core.crypto.generateKeyPair(), Xi = hr$2(zi);
      if (await Promise.all([this.client.auth.authKeys.set(ae, { responseTopic: Xi, publicKey: zi }), this.client.auth.pairingTopics.set(Xi, { topic: Xi, pairingTopic: Ci })]), await this.client.core.relayer.subscribe(Xi, { transportType: Te }), this.client.logger.info(`sending request to new pairing topic: ${Ci}`), Ei.length > 0) {
        const { namespace: Ni } = re$2(je[0]);
        let Ti = ir$2(Ni, "request", Ei);
        Y$2(Ii) && (Ti = cr$2(Ti, Ii.pop())), Ii.push(Ti);
      }
      const Qi = Pi && Pi > v$1.wc_sessionAuthenticate.req.ttl ? Pi : v$1.wc_sessionAuthenticate.req.ttl, Oi = { authPayload: { type: vi ?? "caip122", chains: je, statement: Ve, aud: fi, domain: Ue, version: "1", nonce: bi, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: mi, nbf: _i, resources: Ii }, requester: { publicKey: zi, metadata: this.client.metadata }, expiryTimestamp: Mt$2(Qi) }, Yi = { eip155: { chains: je, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...Ei])], events: ["chainChanged", "accountsChanged"] } }, ns = { requiredNamespaces: {}, optionalNamespaces: Yi, relays: [{ protocol: "irn" }], pairingTopic: Ci, proposer: { publicKey: zi, metadata: this.client.metadata }, expiryTimestamp: Mt$2(v$1.wc_sessionPropose.req.ttl) }, { done: ls, resolve: vn, reject: Mi } = _t$2(Qi, "Request expired"), Ai = async ({ error: Ni, session: Ti }) => {
        if (this.events.off(Lt$2("session_request", $i), wi), Ni) Mi(Ni);
        else if (Ti) {
          Ti.self.publicKey = zi, await this.client.session.set(Ti.topic, Ti), await this.setExpiry(Ti.topic, Ti.expiry), Ci && await this.client.core.pairing.updateMetadata({ topic: Ci, metadata: Ti.peer.metadata });
          const xi = this.client.session.get(Ti.topic);
          await this.deleteProposal(Li), vn({ session: xi });
        }
      }, wi = async (Ni) => {
        var Ti, xi, Fi;
        if (await this.deletePendingAuthRequest($i, { message: "fulfilled", code: 0 }), Ni.error) {
          const ki = U$2("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return Ni.error.code === ki.code ? void 0 : (this.events.off(Lt$2("session_connect"), Ai), Mi(Ni.error.message));
        }
        await this.deleteProposal(Li), this.events.off(Lt$2("session_connect"), Ai);
        const { cacaos: Si, responder: Vi } = Ni.result, ts = [], Hi = [];
        for (const ki of Si) {
          await nr$2({ cacao: ki, projectId: this.client.core.projectId }) || (this.client.logger.error(ki, "Signature verification failed"), Mi(U$2("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: Ji } = ki, Ri = Y$2(Ji.resources), ji = [ln$1(Ji.iss)], Gi = fe$2(Ji.iss);
          if (Ri) {
            const is = ar$2(Ri), os = ur$2(Ri);
            ts.push(...is), ji.push(...os);
          }
          for (const is of ji) Hi.push(`${is}:${Gi}`);
        }
        const fn = await this.client.core.crypto.generateSharedKey(zi, Vi.publicKey);
        let Bi;
        ts.length > 0 && (Bi = { topic: fn, acknowledged: !0, self: { publicKey: zi, metadata: this.client.metadata }, peer: Vi, controller: Vi.publicKey, expiry: Mt$2(z$1), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: Ci, namespaces: Jr$1([...new Set(ts)], [...new Set(Hi)]), transportType: Te }, await this.client.core.relayer.subscribe(fn, { transportType: Te }), await this.client.session.set(fn, Bi), Ci && await this.client.core.pairing.updateMetadata({ topic: Ci, metadata: Vi.metadata }), Bi = this.client.session.get(fn)), (Ti = this.client.metadata.redirect) != null && Ti.linkMode && (xi = Vi.metadata.redirect) != null && xi.linkMode && (Fi = Vi.metadata.redirect) != null && Fi.universal && Me && (this.client.core.addLinkModeSupportedApp(Vi.metadata.redirect.universal), this.client.session.update(fn, { transportType: M$1.link_mode })), vn({ auths: Si, session: Bi });
      }, $i = payloadId(), Li = payloadId();
      this.events.once(Lt$2("session_connect"), Ai), this.events.once(Lt$2("session_request", $i), wi);
      let qi;
      try {
        if (Pe) {
          const Ni = formatJsonRpcRequest("wc_sessionAuthenticate", Oi, $i);
          this.client.core.history.set(Ci, Ni);
          const Ti = await this.client.core.crypto.encode("", Ni, { type: M$2, encoding: lr$2 });
          qi = xr$2(Me, Ci, Ti);
        } else await Promise.all([this.sendRequest({ topic: Ci, method: "wc_sessionAuthenticate", params: Oi, expiry: Ie.expiry, throwOnFailedPublish: !0, clientRpcId: $i }), this.sendRequest({ topic: Ci, method: "wc_sessionPropose", params: ns, expiry: v$1.wc_sessionPropose.req.ttl, throwOnFailedPublish: !0, clientRpcId: Li })]);
      } catch (Ni) {
        throw this.events.off(Lt$2("session_connect"), Ai), this.events.off(Lt$2("session_request", $i), wi), Ni;
      }
      return await this.setProposal(Li, I({ id: Li }, ns)), await this.setAuthRequest($i, { request: D$1(I({}, Oi), { verifyContext: {} }), pairingTopic: Ci, transportType: Te }), { uri: qi ?? Wi, response: ls };
    }, this.approveSessionAuthenticate = async (Ie) => {
      const { id: Me, auths: Be } = Ie, Pe = this.client.core.eventClient.createEvent({ properties: { topic: Me.toString(), trace: [Cs.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (Pi) {
        throw Pe.setError(Ps$1.no_internet_connection), Pi;
      }
      const Te = this.getPendingAuthRequest(Me);
      if (!Te) throw Pe.setError(Ps$1.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${Me}`);
      const je = Te.transportType || M$1.relay;
      je === M$1.relay && await this.confirmOnlineStateOrThrow();
      const Ve = Te.requester.publicKey, fi = await this.client.core.crypto.generateKeyPair(), Ue = hr$2(Ve), bi = { type: D$2, receiverPublicKey: Ve, senderPublicKey: fi }, vi = [], mi = [];
      for (const Pi of Be) {
        if (!await nr$2({ cacao: Pi, projectId: this.client.core.projectId })) {
          Pe.setError(Ps$1.invalid_cacao);
          const Xi = U$2("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: Me, topic: Ue, error: Xi, encodeOpts: bi }), new Error(Xi.message);
        }
        Pe.addTrace(Cs.cacaos_verified);
        const { p: Ii } = Pi, Ci = Y$2(Ii.resources), Wi = [ln$1(Ii.iss)], zi = fe$2(Ii.iss);
        if (Ci) {
          const Xi = ar$2(Ci), Qi = ur$2(Ci);
          vi.push(...Xi), Wi.push(...Qi);
        }
        for (const Xi of Wi) mi.push(`${Xi}:${zi}`);
      }
      const _i = await this.client.core.crypto.generateSharedKey(fi, Ve);
      Pe.addTrace(Cs.create_authenticated_session_topic);
      let Ei;
      if ((vi == null ? void 0 : vi.length) > 0) {
        Ei = { topic: _i, acknowledged: !0, self: { publicKey: fi, metadata: this.client.metadata }, peer: { publicKey: Ve, metadata: Te.requester.metadata }, controller: Ve, expiry: Mt$2(z$1), authentication: Be, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: Te.pairingTopic, namespaces: Jr$1([...new Set(vi)], [...new Set(mi)]), transportType: je }, Pe.addTrace(Cs.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(_i, { transportType: je });
        } catch (Pi) {
          throw Pe.setError(Ps$1.subscribe_authenticated_session_topic_failure), Pi;
        }
        Pe.addTrace(Cs.subscribe_authenticated_session_topic_success), await this.client.session.set(_i, Ei), Pe.addTrace(Cs.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: Te.pairingTopic, metadata: Te.requester.metadata });
      }
      Pe.addTrace(Cs.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: Ue, id: Me, result: { cacaos: Be, responder: { publicKey: fi, metadata: this.client.metadata } }, encodeOpts: bi, throwOnFailedPublish: !0, appLink: this.getAppLinkIfEnabled(Te.requester.metadata, je) });
      } catch (Pi) {
        throw Pe.setError(Ps$1.authenticated_session_approve_publish_failure), Pi;
      }
      return await this.client.auth.requests.delete(Me, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: Te.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: Pe.eventId }), { session: Ei };
    }, this.rejectSessionAuthenticate = async (Ie) => {
      this.isInitialized();
      const { id: Me, reason: Be } = Ie, Pe = this.getPendingAuthRequest(Me);
      if (!Pe) throw new Error(`Could not find pending auth request with id ${Me}`);
      Pe.transportType === M$1.relay && await this.confirmOnlineStateOrThrow();
      const Te = Pe.requester.publicKey, je = await this.client.core.crypto.generateKeyPair(), Ve = hr$2(Te), fi = { type: D$2, receiverPublicKey: Te, senderPublicKey: je };
      await this.sendError({ id: Me, topic: Ve, error: Be, encodeOpts: fi, rpcOpts: v$1.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(Pe.requester.metadata, Pe.transportType) }), await this.client.auth.requests.delete(Me, { message: "rejected", code: 0 }), await this.client.proposal.delete(Me, U$2("USER_DISCONNECTED"));
    }, this.formatAuthMessage = (Ie) => {
      this.isInitialized();
      const { request: Me, iss: Be } = Ie;
      return dn$1(Me, Be);
    }, this.processRelayMessageCache = () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const Ie = this.relayMessageCache.shift();
          Ie && await this.onRelayMessage(Ie);
        } catch (Ie) {
          this.client.logger.error(Ie);
        }
      }, 50);
    }, this.cleanupDuplicatePairings = async (Ie) => {
      if (Ie.pairingTopic) try {
        const Me = this.client.core.pairing.pairings.get(Ie.pairingTopic), Be = this.client.core.pairing.pairings.getAll().filter((Pe) => {
          var Te, je;
          return ((Te = Pe.peerMetadata) == null ? void 0 : Te.url) && ((je = Pe.peerMetadata) == null ? void 0 : je.url) === Ie.peer.metadata.url && Pe.topic && Pe.topic !== Me.topic;
        });
        if (Be.length === 0) return;
        this.client.logger.info(`Cleaning up ${Be.length} duplicate pairing(s)`), await Promise.all(Be.map((Pe) => this.client.core.pairing.disconnect({ topic: Pe.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (Me) {
        this.client.logger.error(Me);
      }
    }, this.deleteSession = async (Ie) => {
      var Me;
      const { topic: Be, expirerHasDeleted: Pe = !1, emitEvent: Te = !0, id: je = 0 } = Ie, { self: Ve } = this.client.session.get(Be);
      await this.client.core.relayer.unsubscribe(Be), await this.client.session.delete(Be, U$2("USER_DISCONNECTED")), this.addToRecentlyDeleted(Be, "session"), this.client.core.crypto.keychain.has(Ve.publicKey) && await this.client.core.crypto.deleteKeyPair(Ve.publicKey), this.client.core.crypto.keychain.has(Be) && await this.client.core.crypto.deleteSymKey(Be), Pe || this.client.core.expirer.del(Be), this.client.core.storage.removeItem(xe).catch((fi) => this.client.logger.warn(fi)), this.getPendingSessionRequests().forEach((fi) => {
        fi.topic === Be && this.deletePendingSessionRequest(fi.id, U$2("USER_DISCONNECTED"));
      }), Be === ((Me = this.sessionRequestQueue.queue[0]) == null ? void 0 : Me.topic) && (this.sessionRequestQueue.state = x$1.idle), Te && this.client.events.emit("session_delete", { id: je, topic: Be });
    }, this.deleteProposal = async (Ie, Me) => {
      if (Me) try {
        const Be = this.client.proposal.get(Ie), Pe = this.client.core.eventClient.getEvent({ topic: Be.pairingTopic });
        Pe == null || Pe.setError(Ts$1.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(Ie, U$2("USER_DISCONNECTED")), Me ? Promise.resolve() : this.client.core.expirer.del(Ie)]), this.addToRecentlyDeleted(Ie, "proposal");
    }, this.deletePendingSessionRequest = async (Ie, Me, Be = !1) => {
      await Promise.all([this.client.pendingRequest.delete(Ie, Me), Be ? Promise.resolve() : this.client.core.expirer.del(Ie)]), this.addToRecentlyDeleted(Ie, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((Pe) => Pe.id !== Ie), Be && (this.sessionRequestQueue.state = x$1.idle, this.client.events.emit("session_request_expire", { id: Ie }));
    }, this.deletePendingAuthRequest = async (Ie, Me, Be = !1) => {
      await Promise.all([this.client.auth.requests.delete(Ie, Me), Be ? Promise.resolve() : this.client.core.expirer.del(Ie)]);
    }, this.setExpiry = async (Ie, Me) => {
      this.client.session.keys.includes(Ie) && (this.client.core.expirer.set(Ie, Me), await this.client.session.update(Ie, { expiry: Me }));
    }, this.setProposal = async (Ie, Me) => {
      this.client.core.expirer.set(Ie, Mt$2(v$1.wc_sessionPropose.req.ttl)), await this.client.proposal.set(Ie, Me);
    }, this.setAuthRequest = async (Ie, Me) => {
      const { request: Be, pairingTopic: Pe, transportType: Te = M$1.relay } = Me;
      this.client.core.expirer.set(Ie, Be.expiryTimestamp), await this.client.auth.requests.set(Ie, { authPayload: Be.authPayload, requester: Be.requester, expiryTimestamp: Be.expiryTimestamp, id: Ie, pairingTopic: Pe, verifyContext: Be.verifyContext, transportType: Te });
    }, this.setPendingSessionRequest = async (Ie) => {
      const { id: Me, topic: Be, params: Pe, verifyContext: Te } = Ie, je = Pe.request.expiryTimestamp || Mt$2(v$1.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(Me, je), await this.client.pendingRequest.set(Me, { id: Me, topic: Be, params: Pe, verifyContext: Te });
    }, this.sendRequest = async (Ie) => {
      const { topic: Me, method: Be, params: Pe, expiry: Te, relayRpcId: je, clientRpcId: Ve, throwOnFailedPublish: fi, appLink: Ue } = Ie, bi = formatJsonRpcRequest(Be, Pe, Ve);
      let vi;
      const mi = !!Ue;
      try {
        const Pi = mi ? lr$2 : ge$1;
        vi = await this.client.core.crypto.encode(Me, bi, { encoding: Pi });
      } catch (Pi) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${Me} failed`), Pi;
      }
      let _i;
      if (at.includes(Be)) {
        const Pi = yr$2(JSON.stringify(bi)), Ii = yr$2(vi);
        _i = await this.client.core.verify.register({ id: Ii, decryptedId: Pi });
      }
      const Ei = v$1[Be].req;
      if (Ei.attestation = _i, Te && (Ei.ttl = Te), je && (Ei.id = je), this.client.core.history.set(Me, bi), mi) {
        const Pi = xr$2(Ue, Me, vi);
        await global.Linking.openURL(Pi, this.client.name);
      } else {
        const Pi = v$1[Be].req;
        Te && (Pi.ttl = Te), je && (Pi.id = je), fi ? (Pi.internal = D$1(I({}, Pi.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(Me, vi, Pi)) : this.client.core.relayer.publish(Me, vi, Pi).catch((Ii) => this.client.logger.error(Ii));
      }
      return bi.id;
    }, this.sendResult = async (Ie) => {
      const { id: Me, topic: Be, result: Pe, throwOnFailedPublish: Te, encodeOpts: je, appLink: Ve } = Ie, fi = formatJsonRpcResult(Me, Pe);
      let Ue;
      const bi = Ve && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const mi = bi ? lr$2 : ge$1;
        Ue = await this.client.core.crypto.encode(Be, fi, D$1(I({}, je || {}), { encoding: mi }));
      } catch (mi) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${Be} failed`), mi;
      }
      let vi;
      try {
        vi = await this.client.core.history.get(Be, Me);
      } catch (mi) {
        throw this.client.logger.error(`sendResult() -> history.get(${Be}, ${Me}) failed`), mi;
      }
      if (bi) {
        const mi = xr$2(Ve, Be, Ue);
        await global.Linking.openURL(mi, this.client.name);
      } else {
        const mi = v$1[vi.request.method].res;
        Te ? (mi.internal = D$1(I({}, mi.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(Be, Ue, mi)) : this.client.core.relayer.publish(Be, Ue, mi).catch((_i) => this.client.logger.error(_i));
      }
      await this.client.core.history.resolve(fi);
    }, this.sendError = async (Ie) => {
      const { id: Me, topic: Be, error: Pe, encodeOpts: Te, rpcOpts: je, appLink: Ve } = Ie, fi = formatJsonRpcError(Me, Pe);
      let Ue;
      const bi = Ve && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const mi = bi ? lr$2 : ge$1;
        Ue = await this.client.core.crypto.encode(Be, fi, D$1(I({}, Te || {}), { encoding: mi }));
      } catch (mi) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${Be} failed`), mi;
      }
      let vi;
      try {
        vi = await this.client.core.history.get(Be, Me);
      } catch (mi) {
        throw this.client.logger.error(`sendError() -> history.get(${Be}, ${Me}) failed`), mi;
      }
      if (bi) {
        const mi = xr$2(Ve, Be, Ue);
        await global.Linking.openURL(mi, this.client.name);
      } else {
        const mi = je || v$1[vi.request.method].res;
        this.client.core.relayer.publish(Be, Ue, mi);
      }
      await this.client.core.history.resolve(fi);
    }, this.cleanup = async () => {
      const Ie = [], Me = [];
      this.client.session.getAll().forEach((Be) => {
        let Pe = !1;
        Kt$2(Be.expiry) && (Pe = !0), this.client.core.crypto.keychain.has(Be.topic) || (Pe = !0), Pe && Ie.push(Be.topic);
      }), this.client.proposal.getAll().forEach((Be) => {
        Kt$2(Be.expiryTimestamp) && Me.push(Be.id);
      }), await Promise.all([...Ie.map((Be) => this.deleteSession({ topic: Be })), ...Me.map((Be) => this.deleteProposal(Be))]);
    }, this.onRelayEventRequest = async (Ie) => {
      this.requestQueue.queue.push(Ie), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === x$1.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = x$1.active;
        const Ie = this.requestQueue.queue.shift();
        if (Ie) try {
          await this.processRequest(Ie);
        } catch (Me) {
          this.client.logger.warn(Me);
        }
      }
      this.requestQueue.state = x$1.idle;
    }, this.processRequest = async (Ie) => {
      const { topic: Me, payload: Be, attestation: Pe, transportType: Te, encryptedId: je } = Ie, Ve = Be.method;
      if (!this.shouldIgnorePairingRequest({ topic: Me, requestMethod: Ve })) switch (Ve) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: Me, payload: Be, attestation: Pe, encryptedId: je });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(Me, Be);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(Me, Be);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(Me, Be);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(Me, Be);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(Me, Be);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: Me, payload: Be, attestation: Pe, encryptedId: je, transportType: Te });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(Me, Be);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: Me, payload: Be, attestation: Pe, encryptedId: je, transportType: Te });
        default:
          return this.client.logger.info(`Unsupported request method ${Ve}`);
      }
    }, this.onRelayEventResponse = async (Ie) => {
      const { topic: Me, payload: Be, transportType: Pe } = Ie, Te = (await this.client.core.history.get(Me, Be.id)).request.method;
      switch (Te) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(Me, Be, Pe);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(Me, Be);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(Me, Be);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(Me, Be);
        case "wc_sessionPing":
          return this.onSessionPingResponse(Me, Be);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(Me, Be);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(Me, Be);
        default:
          return this.client.logger.info(`Unsupported response method ${Te}`);
      }
    }, this.onRelayEventUnknownPayload = (Ie) => {
      const { topic: Me } = Ie, { message: Be } = S$4("MISSING_OR_INVALID", `Decoded payload on topic ${Me} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(Be);
    }, this.shouldIgnorePairingRequest = (Ie) => {
      const { topic: Me, requestMethod: Be } = Ie, Pe = this.expectedPairingMethodMap.get(Me);
      return !Pe || Pe.includes(Be) ? !1 : !!(Pe.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }, this.onSessionProposeRequest = async (Ie) => {
      const { topic: Me, payload: Be, attestation: Pe, encryptedId: Te } = Ie, { params: je, id: Ve } = Be;
      try {
        const fi = this.client.core.eventClient.getEvent({ topic: Me });
        this.isValidConnect(I({}, Be.params));
        const Ue = je.expiryTimestamp || Mt$2(v$1.wc_sessionPropose.req.ttl), bi = I({ id: Ve, pairingTopic: Me, expiryTimestamp: Ue }, je);
        await this.setProposal(Ve, bi);
        const vi = await this.getVerifyContext({ attestationId: Pe, hash: yr$2(JSON.stringify(Be)), encryptedId: Te, metadata: bi.proposer.metadata });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), fi == null || fi.setError($$1.proposal_listener_not_found)), fi == null || fi.addTrace(z$3.emit_session_proposal), this.client.events.emit("session_proposal", { id: Ve, params: bi, verifyContext: vi });
      } catch (fi) {
        await this.sendError({ id: Ve, topic: Me, error: fi, rpcOpts: v$1.wc_sessionPropose.autoReject }), this.client.logger.error(fi);
      }
    }, this.onSessionProposeResponse = async (Ie, Me, Be) => {
      const { id: Pe } = Me;
      if (isJsonRpcResult(Me)) {
        const { result: Te } = Me;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: Te });
        const je = this.client.proposal.get(Pe);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: je });
        const Ve = je.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: Ve });
        const fi = Te.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: fi });
        const Ue = await this.client.core.crypto.generateSharedKey(Ve, fi);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: Ue });
        const bi = await this.client.core.relayer.subscribe(Ue, { transportType: Be });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: bi }), await this.client.core.pairing.activate({ topic: Ie });
      } else if (isJsonRpcError(Me)) {
        await this.client.proposal.delete(Pe, U$2("USER_DISCONNECTED"));
        const Te = Lt$2("session_connect");
        if (this.events.listenerCount(Te) === 0) throw new Error(`emitting ${Te} without any listeners, 954`);
        this.events.emit(Lt$2("session_connect"), { error: Me.error });
      }
    }, this.onSessionSettleRequest = async (Ie, Me) => {
      const { id: Be, params: Pe } = Me;
      try {
        this.isValidSessionSettleRequest(Pe);
        const { relay: Te, controller: je, expiry: Ve, namespaces: fi, sessionProperties: Ue, sessionConfig: bi } = Me.params, vi = D$1(I(I({ topic: Ie, relay: Te, expiry: Ve, namespaces: fi, acknowledged: !0, pairingTopic: "", requiredNamespaces: {}, optionalNamespaces: {}, controller: je.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: je.publicKey, metadata: je.metadata } }, Ue && { sessionProperties: Ue }), bi && { sessionConfig: bi }), { transportType: M$1.relay }), mi = Lt$2("session_connect");
        if (this.events.listenerCount(mi) === 0) throw new Error(`emitting ${mi} without any listeners 997`);
        this.events.emit(Lt$2("session_connect"), { session: vi }), await this.sendResult({ id: Me.id, topic: Ie, result: !0, throwOnFailedPublish: !0 });
      } catch (Te) {
        await this.sendError({ id: Be, topic: Ie, error: Te }), this.client.logger.error(Te);
      }
    }, this.onSessionSettleResponse = async (Ie, Me) => {
      const { id: Be } = Me;
      isJsonRpcResult(Me) ? (await this.client.session.update(Ie, { acknowledged: !0 }), this.events.emit(Lt$2("session_approve", Be), {})) : isJsonRpcError(Me) && (await this.client.session.delete(Ie, U$2("USER_DISCONNECTED")), this.events.emit(Lt$2("session_approve", Be), { error: Me.error }));
    }, this.onSessionUpdateRequest = async (Ie, Me) => {
      const { params: Be, id: Pe } = Me;
      try {
        const Te = `${Ie}_session_update`, je = yo.get(Te);
        if (je && this.isRequestOutOfSync(je, Pe)) {
          this.client.logger.info(`Discarding out of sync request - ${Pe}`), this.sendError({ id: Pe, topic: Ie, error: U$2("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(I({ topic: Ie }, Be));
        try {
          yo.set(Te, Pe), await this.client.session.update(Ie, { namespaces: Be.namespaces }), await this.sendResult({ id: Pe, topic: Ie, result: !0, throwOnFailedPublish: !0 });
        } catch (Ve) {
          throw yo.delete(Te), Ve;
        }
        this.client.events.emit("session_update", { id: Pe, topic: Ie, params: Be });
      } catch (Te) {
        await this.sendError({ id: Pe, topic: Ie, error: Te }), this.client.logger.error(Te);
      }
    }, this.isRequestOutOfSync = (Ie, Me) => parseInt(Me.toString().slice(0, -3)) <= parseInt(Ie.toString().slice(0, -3)), this.onSessionUpdateResponse = (Ie, Me) => {
      const { id: Be } = Me, Pe = Lt$2("session_update", Be);
      if (this.events.listenerCount(Pe) === 0) throw new Error(`emitting ${Pe} without any listeners`);
      isJsonRpcResult(Me) ? this.events.emit(Lt$2("session_update", Be), {}) : isJsonRpcError(Me) && this.events.emit(Lt$2("session_update", Be), { error: Me.error });
    }, this.onSessionExtendRequest = async (Ie, Me) => {
      const { id: Be } = Me;
      try {
        this.isValidExtend({ topic: Ie }), await this.setExpiry(Ie, Mt$2(z$1)), await this.sendResult({ id: Be, topic: Ie, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_extend", { id: Be, topic: Ie });
      } catch (Pe) {
        await this.sendError({ id: Be, topic: Ie, error: Pe }), this.client.logger.error(Pe);
      }
    }, this.onSessionExtendResponse = (Ie, Me) => {
      const { id: Be } = Me, Pe = Lt$2("session_extend", Be);
      if (this.events.listenerCount(Pe) === 0) throw new Error(`emitting ${Pe} without any listeners`);
      isJsonRpcResult(Me) ? this.events.emit(Lt$2("session_extend", Be), {}) : isJsonRpcError(Me) && this.events.emit(Lt$2("session_extend", Be), { error: Me.error });
    }, this.onSessionPingRequest = async (Ie, Me) => {
      const { id: Be } = Me;
      try {
        this.isValidPing({ topic: Ie }), await this.sendResult({ id: Be, topic: Ie, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_ping", { id: Be, topic: Ie });
      } catch (Pe) {
        await this.sendError({ id: Be, topic: Ie, error: Pe }), this.client.logger.error(Pe);
      }
    }, this.onSessionPingResponse = (Ie, Me) => {
      const { id: Be } = Me, Pe = Lt$2("session_ping", Be);
      if (this.events.listenerCount(Pe) === 0) throw new Error(`emitting ${Pe} without any listeners`);
      setTimeout(() => {
        isJsonRpcResult(Me) ? this.events.emit(Lt$2("session_ping", Be), {}) : isJsonRpcError(Me) && this.events.emit(Lt$2("session_ping", Be), { error: Me.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (Ie, Me) => {
      const { id: Be } = Me;
      try {
        this.isValidDisconnect({ topic: Ie, reason: Me.params }), Promise.all([new Promise((Pe) => {
          this.client.core.relayer.once(v$2.publish, async () => {
            Pe(await this.deleteSession({ topic: Ie, id: Be }));
          });
        }), this.sendResult({ id: Be, topic: Ie, result: !0, throwOnFailedPublish: !0 }), this.cleanupPendingSentRequestsForTopic({ topic: Ie, error: U$2("USER_DISCONNECTED") })]).catch((Pe) => this.client.logger.error(Pe));
      } catch (Pe) {
        this.client.logger.error(Pe);
      }
    }, this.onSessionRequest = async (Ie) => {
      var Me, Be, Pe;
      const { topic: Te, payload: je, attestation: Ve, encryptedId: fi, transportType: Ue } = Ie, { id: bi, params: vi } = je;
      try {
        await this.isValidRequest(I({ topic: Te }, vi));
        const mi = this.client.session.get(Te), _i = await this.getVerifyContext({ attestationId: Ve, hash: yr$2(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", vi, bi))), encryptedId: fi, metadata: mi.peer.metadata, transportType: Ue }), Ei = { id: bi, topic: Te, params: vi, verifyContext: _i };
        await this.setPendingSessionRequest(Ei), Ue === M$1.link_mode && (Me = mi.peer.metadata.redirect) != null && Me.universal && this.client.core.addLinkModeSupportedApp((Be = mi.peer.metadata.redirect) == null ? void 0 : Be.universal), (Pe = this.client.signConfig) != null && Pe.disableRequestQueue ? this.emitSessionRequest(Ei) : (this.addSessionRequestToSessionRequestQueue(Ei), this.processSessionRequestQueue());
      } catch (mi) {
        await this.sendError({ id: bi, topic: Te, error: mi }), this.client.logger.error(mi);
      }
    }, this.onSessionRequestResponse = (Ie, Me) => {
      const { id: Be } = Me, Pe = Lt$2("session_request", Be);
      if (this.events.listenerCount(Pe) === 0) throw new Error(`emitting ${Pe} without any listeners`);
      isJsonRpcResult(Me) ? this.events.emit(Lt$2("session_request", Be), { result: Me.result }) : isJsonRpcError(Me) && this.events.emit(Lt$2("session_request", Be), { error: Me.error });
    }, this.onSessionEventRequest = async (Ie, Me) => {
      const { id: Be, params: Pe } = Me;
      try {
        const Te = `${Ie}_session_event_${Pe.event.name}`, je = yo.get(Te);
        if (je && this.isRequestOutOfSync(je, Be)) {
          this.client.logger.info(`Discarding out of sync request - ${Be}`);
          return;
        }
        this.isValidEmit(I({ topic: Ie }, Pe)), this.client.events.emit("session_event", { id: Be, topic: Ie, params: Pe }), yo.set(Te, Be);
      } catch (Te) {
        await this.sendError({ id: Be, topic: Ie, error: Te }), this.client.logger.error(Te);
      }
    }, this.onSessionAuthenticateResponse = (Ie, Me) => {
      const { id: Be } = Me;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: Ie, payload: Me }), isJsonRpcResult(Me) ? this.events.emit(Lt$2("session_request", Be), { result: Me.result }) : isJsonRpcError(Me) && this.events.emit(Lt$2("session_request", Be), { error: Me.error });
    }, this.onSessionAuthenticateRequest = async (Ie) => {
      var Me;
      const { topic: Be, payload: Pe, attestation: Te, encryptedId: je, transportType: Ve } = Ie;
      try {
        const { requester: fi, authPayload: Ue, expiryTimestamp: bi } = Pe.params, vi = await this.getVerifyContext({ attestationId: Te, hash: yr$2(JSON.stringify(Pe)), encryptedId: je, metadata: fi.metadata, transportType: Ve }), mi = { requester: fi, pairingTopic: Be, id: Pe.id, authPayload: Ue, verifyContext: vi, expiryTimestamp: bi };
        await this.setAuthRequest(Pe.id, { request: mi, pairingTopic: Be, transportType: Ve }), Ve === M$1.link_mode && (Me = fi.metadata.redirect) != null && Me.universal && this.client.core.addLinkModeSupportedApp(fi.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: Be, params: Pe.params, id: Pe.id, verifyContext: vi });
      } catch (fi) {
        this.client.logger.error(fi);
        const Ue = Pe.params.requester.publicKey, bi = await this.client.core.crypto.generateKeyPair(), vi = this.getAppLinkIfEnabled(Pe.params.requester.metadata, Ve), mi = { type: D$2, receiverPublicKey: Ue, senderPublicKey: bi };
        await this.sendError({ id: Pe.id, topic: Be, error: fi, encodeOpts: mi, rpcOpts: v$1.wc_sessionAuthenticate.autoReject, appLink: vi });
      }
    }, this.addSessionRequestToSessionRequestQueue = (Ie) => {
      this.sessionRequestQueue.queue.push(Ie);
    }, this.cleanupAfterResponse = (Ie) => {
      this.deletePendingSessionRequest(Ie.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = x$1.idle, this.processSessionRequestQueue();
      }, cjs$3.toMiliseconds(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: Ie, error: Me }) => {
      const Be = this.client.core.history.pending;
      Be.length > 0 && Be.filter((Pe) => Pe.topic === Ie && Pe.request.method === "wc_sessionRequest").forEach((Pe) => {
        const Te = Pe.request.id, je = Lt$2("session_request", Te);
        if (this.events.listenerCount(je) === 0) throw new Error(`emitting ${je} without any listeners`);
        this.events.emit(Lt$2("session_request", Pe.request.id), { error: Me });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === x$1.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const Ie = this.sessionRequestQueue.queue[0];
      if (!Ie) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = x$1.active, this.emitSessionRequest(Ie);
      } catch (Me) {
        this.client.logger.error(Me);
      }
    }, this.emitSessionRequest = (Ie) => {
      this.client.events.emit("session_request", Ie);
    }, this.onPairingCreated = (Ie) => {
      if (Ie.methods && this.expectedPairingMethodMap.set(Ie.topic, Ie.methods), Ie.active) return;
      const Me = this.client.proposal.getAll().find((Be) => Be.pairingTopic === Ie.topic);
      Me && this.onSessionProposeRequest({ topic: Ie.topic, payload: formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: Me.requiredNamespaces, optionalNamespaces: Me.optionalNamespaces, relays: Me.relays, proposer: Me.proposer, sessionProperties: Me.sessionProperties }, Me.id) });
    }, this.isValidConnect = async (Ie) => {
      if (!to(Ie)) {
        const { message: Ve } = S$4("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(Ie)}`);
        throw new Error(Ve);
      }
      const { pairingTopic: Me, requiredNamespaces: Be, optionalNamespaces: Pe, sessionProperties: Te, relays: je } = Ie;
      if (I$3(Me) || await this.isValidPairingTopic(Me), !eo(je)) {
        const { message: Ve } = S$4("MISSING_OR_INVALID", `connect() relays: ${je}`);
        throw new Error(Ve);
      }
      !I$3(Be) && Z$3(Be) !== 0 && this.validateNamespaces(Be, "requiredNamespaces"), !I$3(Pe) && Z$3(Pe) !== 0 && this.validateNamespaces(Pe, "optionalNamespaces"), I$3(Te) || this.validateSessionProps(Te, "sessionProperties");
    }, this.validateNamespaces = (Ie, Me) => {
      const Be = Xr$1(Ie, "connect()", Me);
      if (Be) throw new Error(Be.message);
    }, this.isValidApprove = async (Ie) => {
      if (!to(Ie)) throw new Error(S$4("MISSING_OR_INVALID", `approve() params: ${Ie}`).message);
      const { id: Me, namespaces: Be, relayProtocol: Pe, sessionProperties: Te } = Ie;
      this.checkRecentlyDeleted(Me), await this.isValidProposalId(Me);
      const je = this.client.proposal.get(Me), Ve = Wn(Be, "approve()");
      if (Ve) throw new Error(Ve.message);
      const fi = zn(je.requiredNamespaces, Be, "approve()");
      if (fi) throw new Error(fi.message);
      if (!b$2(Pe, !0)) {
        const { message: Ue } = S$4("MISSING_OR_INVALID", `approve() relayProtocol: ${Pe}`);
        throw new Error(Ue);
      }
      I$3(Te) || this.validateSessionProps(Te, "sessionProperties");
    }, this.isValidReject = async (Ie) => {
      if (!to(Ie)) {
        const { message: Pe } = S$4("MISSING_OR_INVALID", `reject() params: ${Ie}`);
        throw new Error(Pe);
      }
      const { id: Me, reason: Be } = Ie;
      if (this.checkRecentlyDeleted(Me), await this.isValidProposalId(Me), !ro(Be)) {
        const { message: Pe } = S$4("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(Be)}`);
        throw new Error(Pe);
      }
    }, this.isValidSessionSettleRequest = (Ie) => {
      if (!to(Ie)) {
        const { message: fi } = S$4("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${Ie}`);
        throw new Error(fi);
      }
      const { relay: Me, controller: Be, namespaces: Pe, expiry: Te } = Ie;
      if (!Jn(Me)) {
        const { message: fi } = S$4("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(fi);
      }
      const je = Zr$1(Be, "onSessionSettleRequest()");
      if (je) throw new Error(je.message);
      const Ve = Wn(Pe, "onSessionSettleRequest()");
      if (Ve) throw new Error(Ve.message);
      if (Kt$2(Te)) {
        const { message: fi } = S$4("EXPIRED", "onSessionSettleRequest()");
        throw new Error(fi);
      }
    }, this.isValidUpdate = async (Ie) => {
      if (!to(Ie)) {
        const { message: Ve } = S$4("MISSING_OR_INVALID", `update() params: ${Ie}`);
        throw new Error(Ve);
      }
      const { topic: Me, namespaces: Be } = Ie;
      this.checkRecentlyDeleted(Me), await this.isValidSessionTopic(Me);
      const Pe = this.client.session.get(Me), Te = Wn(Be, "update()");
      if (Te) throw new Error(Te.message);
      const je = zn(Pe.requiredNamespaces, Be, "update()");
      if (je) throw new Error(je.message);
    }, this.isValidExtend = async (Ie) => {
      if (!to(Ie)) {
        const { message: Be } = S$4("MISSING_OR_INVALID", `extend() params: ${Ie}`);
        throw new Error(Be);
      }
      const { topic: Me } = Ie;
      this.checkRecentlyDeleted(Me), await this.isValidSessionTopic(Me);
    }, this.isValidRequest = async (Ie) => {
      if (!to(Ie)) {
        const { message: Ve } = S$4("MISSING_OR_INVALID", `request() params: ${Ie}`);
        throw new Error(Ve);
      }
      const { topic: Me, request: Be, chainId: Pe, expiry: Te } = Ie;
      this.checkRecentlyDeleted(Me), await this.isValidSessionTopic(Me);
      const { namespaces: je } = this.client.session.get(Me);
      if (!co(je, Pe)) {
        const { message: Ve } = S$4("MISSING_OR_INVALID", `request() chainId: ${Pe}`);
        throw new Error(Ve);
      }
      if (!oo(Be)) {
        const { message: Ve } = S$4("MISSING_OR_INVALID", `request() ${JSON.stringify(Be)}`);
        throw new Error(Ve);
      }
      if (!ao(je, Pe, Be.method)) {
        const { message: Ve } = S$4("MISSING_OR_INVALID", `request() method: ${Be.method}`);
        throw new Error(Ve);
      }
      if (Te && !po(Te, me)) {
        const { message: Ve } = S$4("MISSING_OR_INVALID", `request() expiry: ${Te}. Expiry must be a number (in seconds) between ${me.min} and ${me.max}`);
        throw new Error(Ve);
      }
    }, this.isValidRespond = async (Ie) => {
      var Me;
      if (!to(Ie)) {
        const { message: Te } = S$4("MISSING_OR_INVALID", `respond() params: ${Ie}`);
        throw new Error(Te);
      }
      const { topic: Be, response: Pe } = Ie;
      try {
        await this.isValidSessionTopic(Be);
      } catch (Te) {
        throw (Me = Ie == null ? void 0 : Ie.response) != null && Me.id && this.cleanupAfterResponse(Ie), Te;
      }
      if (!so(Pe)) {
        const { message: Te } = S$4("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(Pe)}`);
        throw new Error(Te);
      }
    }, this.isValidPing = async (Ie) => {
      if (!to(Ie)) {
        const { message: Be } = S$4("MISSING_OR_INVALID", `ping() params: ${Ie}`);
        throw new Error(Be);
      }
      const { topic: Me } = Ie;
      await this.isValidSessionOrPairingTopic(Me);
    }, this.isValidEmit = async (Ie) => {
      if (!to(Ie)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `emit() params: ${Ie}`);
        throw new Error(je);
      }
      const { topic: Me, event: Be, chainId: Pe } = Ie;
      await this.isValidSessionTopic(Me);
      const { namespaces: Te } = this.client.session.get(Me);
      if (!co(Te, Pe)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `emit() chainId: ${Pe}`);
        throw new Error(je);
      }
      if (!io(Be)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(Be)}`);
        throw new Error(je);
      }
      if (!uo(Te, Pe, Be.name)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(Be)}`);
        throw new Error(je);
      }
    }, this.isValidDisconnect = async (Ie) => {
      if (!to(Ie)) {
        const { message: Be } = S$4("MISSING_OR_INVALID", `disconnect() params: ${Ie}`);
        throw new Error(Be);
      }
      const { topic: Me } = Ie;
      await this.isValidSessionOrPairingTopic(Me);
    }, this.isValidAuthenticate = (Ie) => {
      const { chains: Me, uri: Be, domain: Pe, nonce: Te } = Ie;
      if (!Array.isArray(Me) || Me.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!b$2(Be, !1)) throw new Error("uri is required parameter");
      if (!b$2(Pe, !1)) throw new Error("domain is required parameter");
      if (!b$2(Te, !1)) throw new Error("nonce is required parameter");
      if ([...new Set(Me.map((Ve) => re$2(Ve).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: je } = re$2(Me[0]);
      if (je !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }, this.getVerifyContext = async (Ie) => {
      const { attestationId: Me, hash: Be, encryptedId: Pe, metadata: Te, transportType: je } = Ie, Ve = { verified: { verifyUrl: Te.verifyUrl || J$1, validation: "UNKNOWN", origin: Te.url || "" } };
      try {
        if (je === M$1.link_mode) {
          const Ue = this.getAppLinkIfEnabled(Te, je);
          return Ve.verified.validation = Ue && new URL(Ue).origin === new URL(Te.url).origin ? "VALID" : "INVALID", Ve;
        }
        const fi = await this.client.core.verify.resolve({ attestationId: Me, hash: Be, encryptedId: Pe, verifyUrl: Te.verifyUrl });
        fi && (Ve.verified.origin = fi.origin, Ve.verified.isScam = fi.isScam, Ve.verified.validation = fi.origin === new URL(Te.url).origin ? "VALID" : "INVALID");
      } catch (fi) {
        this.client.logger.warn(fi);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(Ve)}`), Ve;
    }, this.validateSessionProps = (Ie, Me) => {
      Object.values(Ie).forEach((Be) => {
        if (!b$2(Be, !1)) {
          const { message: Pe } = S$4("MISSING_OR_INVALID", `${Me} must be in Record<string, string> format. Received: ${JSON.stringify(Be)}`);
          throw new Error(Pe);
        }
      });
    }, this.getPendingAuthRequest = (Ie) => {
      const Me = this.client.auth.requests.get(Ie);
      return typeof Me == "object" ? Me : void 0;
    }, this.addToRecentlyDeleted = (Ie, Me) => {
      if (this.recentlyDeletedMap.set(Ie, Me), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let Be = 0;
        const Pe = this.recentlyDeletedLimit / 2;
        for (const Te of this.recentlyDeletedMap.keys()) {
          if (Be++ >= Pe) break;
          this.recentlyDeletedMap.delete(Te);
        }
      }
    }, this.checkRecentlyDeleted = (Ie) => {
      const Me = this.recentlyDeletedMap.get(Ie);
      if (Me) {
        const { message: Be } = S$4("MISSING_OR_INVALID", `Record was recently deleted - ${Me}: ${Ie}`);
        throw new Error(Be);
      }
    }, this.isLinkModeEnabled = (Ie, Me) => {
      var Be, Pe, Te, je, Ve, fi, Ue, bi, vi;
      return !Ie || Me !== M$1.link_mode ? !1 : ((Pe = (Be = this.client.metadata) == null ? void 0 : Be.redirect) == null ? void 0 : Pe.linkMode) === !0 && ((je = (Te = this.client.metadata) == null ? void 0 : Te.redirect) == null ? void 0 : je.universal) !== void 0 && ((fi = (Ve = this.client.metadata) == null ? void 0 : Ve.redirect) == null ? void 0 : fi.universal) !== "" && ((Ue = Ie == null ? void 0 : Ie.redirect) == null ? void 0 : Ue.universal) !== void 0 && ((bi = Ie == null ? void 0 : Ie.redirect) == null ? void 0 : bi.universal) !== "" && ((vi = Ie == null ? void 0 : Ie.redirect) == null ? void 0 : vi.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(Ie.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }, this.getAppLinkIfEnabled = (Ie, Me) => {
      var Be;
      return this.isLinkModeEnabled(Ie, Me) ? (Be = Ie == null ? void 0 : Ie.redirect) == null ? void 0 : Be.universal : void 0;
    }, this.handleLinkModeMessage = ({ url: Ie }) => {
      if (!Ie || !Ie.includes("wc_ev") || !Ie.includes("topic")) return;
      const Me = Bt$2(Ie, "topic") || "", Be = decodeURIComponent(Bt$2(Ie, "wc_ev") || ""), Pe = this.client.session.keys.includes(Me);
      Pe && this.client.session.update(Me, { transportType: M$1.link_mode }), this.client.core.dispatchEnvelope({ topic: Me, message: Be, sessionExists: Pe });
    }, this.registerLinkModeListeners = async () => {
      var Ie;
      if (Wt$2() || _$1() && (Ie = this.client.metadata.redirect) != null && Ie.linkMode) {
        const Me = global == null ? void 0 : global.Linking;
        if (typeof Me < "u") {
          Me.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const Be = await Me.getInitialURL();
          Be && setTimeout(() => {
            this.handleLinkModeMessage({ url: Be });
          }, 50);
        }
      }
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(v$2.message, (t) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(t) : this.onRelayMessage(t);
    });
  }
  async onRelayMessage(t) {
    const { topic: Ie, message: Me, attestation: Be, transportType: Pe } = t, { publicKey: Te } = this.client.auth.authKeys.keys.includes(ae) ? this.client.auth.authKeys.get(ae) : { responseTopic: void 0, publicKey: void 0 }, je = await this.client.core.crypto.decode(Ie, Me, { receiverPublicKey: Te, encoding: Pe === M$1.link_mode ? lr$2 : ge$1 });
    try {
      isJsonRpcRequest(je) ? (this.client.core.history.set(Ie, je), this.onRelayEventRequest({ topic: Ie, payload: je, attestation: Be, transportType: Pe, encryptedId: yr$2(Me) })) : isJsonRpcResponse(je) ? (await this.client.core.history.resolve(je), await this.onRelayEventResponse({ topic: Ie, payload: je, transportType: Pe }), this.client.core.history.delete(Ie, je.id)) : this.onRelayEventUnknownPayload({ topic: Ie, payload: je, transportType: Pe });
    } catch (Ve) {
      this.client.logger.error(Ve);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(S$2.expired, async (t) => {
      const { topic: Ie, id: Me } = Vt$2(t.target);
      if (Me && this.client.pendingRequest.keys.includes(Me)) return await this.deletePendingSessionRequest(Me, S$4("EXPIRED"), !0);
      if (Me && this.client.auth.requests.keys.includes(Me)) return await this.deletePendingAuthRequest(Me, S$4("EXPIRED"), !0);
      Ie ? this.client.session.keys.includes(Ie) && (await this.deleteSession({ topic: Ie, expirerHasDeleted: !0 }), this.client.events.emit("session_expire", { topic: Ie })) : Me && (await this.deleteProposal(Me, !0), this.client.events.emit("proposal_expire", { id: Me }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(V$2.create, (t) => this.onPairingCreated(t)), this.client.core.pairing.events.on(V$2.delete, (t) => {
      this.addToRecentlyDeleted(t.topic, "pairing");
    });
  }
  isValidPairingTopic(t) {
    if (!b$2(t, !1)) {
      const { message: Ie } = S$4("MISSING_OR_INVALID", `pairing topic should be a string: ${t}`);
      throw new Error(Ie);
    }
    if (!this.client.core.pairing.pairings.keys.includes(t)) {
      const { message: Ie } = S$4("NO_MATCHING_KEY", `pairing topic doesn't exist: ${t}`);
      throw new Error(Ie);
    }
    if (Kt$2(this.client.core.pairing.pairings.get(t).expiry)) {
      const { message: Ie } = S$4("EXPIRED", `pairing topic: ${t}`);
      throw new Error(Ie);
    }
  }
  async isValidSessionTopic(t) {
    if (!b$2(t, !1)) {
      const { message: Ie } = S$4("MISSING_OR_INVALID", `session topic should be a string: ${t}`);
      throw new Error(Ie);
    }
    if (this.checkRecentlyDeleted(t), !this.client.session.keys.includes(t)) {
      const { message: Ie } = S$4("NO_MATCHING_KEY", `session topic doesn't exist: ${t}`);
      throw new Error(Ie);
    }
    if (Kt$2(this.client.session.get(t).expiry)) {
      await this.deleteSession({ topic: t });
      const { message: Ie } = S$4("EXPIRED", `session topic: ${t}`);
      throw new Error(Ie);
    }
    if (!this.client.core.crypto.keychain.has(t)) {
      const { message: Ie } = S$4("MISSING_OR_INVALID", `session topic does not exist in keychain: ${t}`);
      throw await this.deleteSession({ topic: t }), new Error(Ie);
    }
  }
  async isValidSessionOrPairingTopic(t) {
    if (this.checkRecentlyDeleted(t), this.client.session.keys.includes(t)) await this.isValidSessionTopic(t);
    else if (this.client.core.pairing.pairings.keys.includes(t)) this.isValidPairingTopic(t);
    else if (b$2(t, !1)) {
      const { message: Ie } = S$4("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${t}`);
      throw new Error(Ie);
    } else {
      const { message: Ie } = S$4("MISSING_OR_INVALID", `session or pairing topic should be a string: ${t}`);
      throw new Error(Ie);
    }
  }
  async isValidProposalId(t) {
    if (!no(t)) {
      const { message: Ie } = S$4("MISSING_OR_INVALID", `proposal id should be a number: ${t}`);
      throw new Error(Ie);
    }
    if (!this.client.proposal.keys.includes(t)) {
      const { message: Ie } = S$4("NO_MATCHING_KEY", `proposal id doesn't exist: ${t}`);
      throw new Error(Ie);
    }
    if (Kt$2(this.client.proposal.get(t).expiryTimestamp)) {
      await this.deleteProposal(t);
      const { message: Ie } = S$4("EXPIRED", `proposal id: ${t}`);
      throw new Error(Ie);
    }
  }
}
class Ss extends ni {
  constructor(t, Ie) {
    super(t, Ie, st, ye), this.core = t, this.logger = Ie;
  }
}
class yt extends ni {
  constructor(t, Ie) {
    super(t, Ie, rt, ye), this.core = t, this.logger = Ie;
  }
}
class Is extends ni {
  constructor(t, Ie) {
    super(t, Ie, ot, ye, (Me) => Me.id), this.core = t, this.logger = Ie;
  }
}
class fs extends ni {
  constructor(t, Ie) {
    super(t, Ie, pt, oe, () => ae), this.core = t, this.logger = Ie;
  }
}
class vs extends ni {
  constructor(t, Ie) {
    super(t, Ie, ht, oe), this.core = t, this.logger = Ie;
  }
}
class qs extends ni {
  constructor(t, Ie) {
    super(t, Ie, dt, oe, (Me) => Me.id), this.core = t, this.logger = Ie;
  }
}
class Ts {
  constructor(t, Ie) {
    this.core = t, this.logger = Ie, this.authKeys = new fs(this.core, this.logger), this.pairingTopics = new vs(this.core, this.logger), this.requests = new qs(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
}
class _e extends S$5 {
  constructor(t) {
    super(t), this.protocol = be, this.version = Ce, this.name = we.name, this.events = new eventsExports.EventEmitter(), this.on = (Me, Be) => this.events.on(Me, Be), this.once = (Me, Be) => this.events.once(Me, Be), this.off = (Me, Be) => this.events.off(Me, Be), this.removeListener = (Me, Be) => this.events.removeListener(Me, Be), this.removeAllListeners = (Me) => this.events.removeAllListeners(Me), this.connect = async (Me) => {
      try {
        return await this.engine.connect(Me);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.pair = async (Me) => {
      try {
        return await this.engine.pair(Me);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.approve = async (Me) => {
      try {
        return await this.engine.approve(Me);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.reject = async (Me) => {
      try {
        return await this.engine.reject(Me);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.update = async (Me) => {
      try {
        return await this.engine.update(Me);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.extend = async (Me) => {
      try {
        return await this.engine.extend(Me);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.request = async (Me) => {
      try {
        return await this.engine.request(Me);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.respond = async (Me) => {
      try {
        return await this.engine.respond(Me);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.ping = async (Me) => {
      try {
        return await this.engine.ping(Me);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.emit = async (Me) => {
      try {
        return await this.engine.emit(Me);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.disconnect = async (Me) => {
      try {
        return await this.engine.disconnect(Me);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.find = (Me) => {
      try {
        return this.engine.find(Me);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (Me) {
        throw this.logger.error(Me.message), Me;
      }
    }, this.authenticate = async (Me, Be) => {
      try {
        return await this.engine.authenticate(Me, Be);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.formatAuthMessage = (Me) => {
      try {
        return this.engine.formatAuthMessage(Me);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.approveSessionAuthenticate = async (Me) => {
      try {
        return await this.engine.approveSessionAuthenticate(Me);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.rejectSessionAuthenticate = async (Me) => {
      try {
        return await this.engine.rejectSessionAuthenticate(Me);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.name = (t == null ? void 0 : t.name) || we.name, this.metadata = (t == null ? void 0 : t.metadata) || Nt$2(), this.signConfig = t == null ? void 0 : t.signConfig;
    const Ie = typeof (t == null ? void 0 : t.logger) < "u" && typeof (t == null ? void 0 : t.logger) != "string" ? t.logger : qt$3(k$2({ level: (t == null ? void 0 : t.logger) || we.logger }));
    this.core = (t == null ? void 0 : t.core) || new bn(t), this.logger = E$1(Ie, this.name), this.session = new yt(this.core, this.logger), this.proposal = new Ss(this.core, this.logger), this.pendingRequest = new Is(this.core, this.logger), this.engine = new Rs(this), this.auth = new Ts(this.core, this.logger);
  }
  static async init(t) {
    const Ie = new _e(t);
    return await Ie.initialize(), Ie;
  }
  get context() {
    return y$3(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), this.engine.processRelayMessageCache();
    } catch (t) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(t.message), t;
    }
  }
}
const Ns = yt, Ps = _e;
var l = { exports: {} }, c = typeof Reflect == "object" ? Reflect : null, y = c && typeof c.apply == "function" ? c.apply : function(Ae, t, Ie) {
  return Function.prototype.apply.call(Ae, t, Ie);
}, f;
c && typeof c.ownKeys == "function" ? f = c.ownKeys : Object.getOwnPropertySymbols ? f = function(Ae) {
  return Object.getOwnPropertyNames(Ae).concat(Object.getOwnPropertySymbols(Ae));
} : f = function(Ae) {
  return Object.getOwnPropertyNames(Ae);
};
function k(Ae) {
  console && console.warn && console.warn(Ae);
}
var w = Number.isNaN || function(Ae) {
  return Ae !== Ae;
};
function o() {
  o.init.call(this);
}
l.exports = o, l.exports.once = K, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
var L = 10;
function g(Ae) {
  if (typeof Ae != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof Ae);
}
Object.defineProperty(o, "defaultMaxListeners", { enumerable: !0, get: function() {
  return L;
}, set: function(Ae) {
  if (typeof Ae != "number" || Ae < 0 || w(Ae)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + Ae + ".");
  L = Ae;
} }), o.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o.prototype.setMaxListeners = function(Ae) {
  if (typeof Ae != "number" || Ae < 0 || w(Ae)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + Ae + ".");
  return this._maxListeners = Ae, this;
};
function _(Ae) {
  return Ae._maxListeners === void 0 ? o.defaultMaxListeners : Ae._maxListeners;
}
o.prototype.getMaxListeners = function() {
  return _(this);
}, o.prototype.emit = function(Ae) {
  for (var t = [], Ie = 1; Ie < arguments.length; Ie++) t.push(arguments[Ie]);
  var Me = Ae === "error", Be = this._events;
  if (Be !== void 0) Me = Me && Be.error === void 0;
  else if (!Me) return !1;
  if (Me) {
    var Pe;
    if (t.length > 0 && (Pe = t[0]), Pe instanceof Error) throw Pe;
    var Te = new Error("Unhandled error." + (Pe ? " (" + Pe.message + ")" : ""));
    throw Te.context = Pe, Te;
  }
  var je = Be[Ae];
  if (je === void 0) return !1;
  if (typeof je == "function") y(je, this, t);
  else for (var Ve = je.length, fi = O(je, Ve), Ie = 0; Ie < Ve; ++Ie) y(fi[Ie], this, t);
  return !0;
};
function S(Ae, t, Ie, Me) {
  var Be, Pe, Te;
  if (g(Ie), Pe = Ae._events, Pe === void 0 ? (Pe = Ae._events = /* @__PURE__ */ Object.create(null), Ae._eventsCount = 0) : (Pe.newListener !== void 0 && (Ae.emit("newListener", t, Ie.listener ? Ie.listener : Ie), Pe = Ae._events), Te = Pe[t]), Te === void 0) Te = Pe[t] = Ie, ++Ae._eventsCount;
  else if (typeof Te == "function" ? Te = Pe[t] = Me ? [Ie, Te] : [Te, Ie] : Me ? Te.unshift(Ie) : Te.push(Ie), Be = _(Ae), Be > 0 && Te.length > Be && !Te.warned) {
    Te.warned = !0;
    var je = new Error("Possible EventEmitter memory leak detected. " + Te.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    je.name = "MaxListenersExceededWarning", je.emitter = Ae, je.type = t, je.count = Te.length, k(je);
  }
  return Ae;
}
o.prototype.addListener = function(Ae, t) {
  return S(this, Ae, t, !1);
}, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(Ae, t) {
  return S(this, Ae, t, !0);
};
function D() {
  if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function C(Ae, t, Ie) {
  var Me = { fired: !1, wrapFn: void 0, target: Ae, type: t, listener: Ie }, Be = D.bind(Me);
  return Be.listener = Ie, Me.wrapFn = Be, Be;
}
o.prototype.once = function(Ae, t) {
  return g(t), this.on(Ae, C(this, Ae, t)), this;
}, o.prototype.prependOnceListener = function(Ae, t) {
  return g(t), this.prependListener(Ae, C(this, Ae, t)), this;
}, o.prototype.removeListener = function(Ae, t) {
  var Ie, Me, Be, Pe, Te;
  if (g(t), Me = this._events, Me === void 0) return this;
  if (Ie = Me[Ae], Ie === void 0) return this;
  if (Ie === t || Ie.listener === t) --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete Me[Ae], Me.removeListener && this.emit("removeListener", Ae, Ie.listener || t));
  else if (typeof Ie != "function") {
    for (Be = -1, Pe = Ie.length - 1; Pe >= 0; Pe--) if (Ie[Pe] === t || Ie[Pe].listener === t) {
      Te = Ie[Pe].listener, Be = Pe;
      break;
    }
    if (Be < 0) return this;
    Be === 0 ? Ie.shift() : F(Ie, Be), Ie.length === 1 && (Me[Ae] = Ie[0]), Me.removeListener !== void 0 && this.emit("removeListener", Ae, Te || t);
  }
  return this;
}, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(Ae) {
  var t, Ie, Me;
  if (Ie = this._events, Ie === void 0) return this;
  if (Ie.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Ie[Ae] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Ie[Ae]), this;
  if (arguments.length === 0) {
    var Be = Object.keys(Ie), Pe;
    for (Me = 0; Me < Be.length; ++Me) Pe = Be[Me], Pe !== "removeListener" && this.removeAllListeners(Pe);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = Ie[Ae], typeof t == "function") this.removeListener(Ae, t);
  else if (t !== void 0) for (Me = t.length - 1; Me >= 0; Me--) this.removeListener(Ae, t[Me]);
  return this;
};
function b(Ae, t, Ie) {
  var Me = Ae._events;
  if (Me === void 0) return [];
  var Be = Me[t];
  return Be === void 0 ? [] : typeof Be == "function" ? Ie ? [Be.listener || Be] : [Be] : Ie ? z(Be) : O(Be, Be.length);
}
o.prototype.listeners = function(Ae) {
  return b(this, Ae, !0);
}, o.prototype.rawListeners = function(Ae) {
  return b(this, Ae, !1);
}, o.listenerCount = function(Ae, t) {
  return typeof Ae.listenerCount == "function" ? Ae.listenerCount(t) : E.call(Ae, t);
}, o.prototype.listenerCount = E;
function E(Ae) {
  var t = this._events;
  if (t !== void 0) {
    var Ie = t[Ae];
    if (typeof Ie == "function") return 1;
    if (Ie !== void 0) return Ie.length;
  }
  return 0;
}
o.prototype.eventNames = function() {
  return this._eventsCount > 0 ? f(this._events) : [];
};
function O(Ae, t) {
  for (var Ie = new Array(t), Me = 0; Me < t; ++Me) Ie[Me] = Ae[Me];
  return Ie;
}
function F(Ae, t) {
  for (; t + 1 < Ae.length; t++) Ae[t] = Ae[t + 1];
  Ae.pop();
}
function z(Ae) {
  for (var t = new Array(Ae.length), Ie = 0; Ie < t.length; ++Ie) t[Ie] = Ae[Ie].listener || Ae[Ie];
  return t;
}
function K(Ae, t) {
  return new Promise(function(Ie, Me) {
    function Be(Te) {
      Ae.removeListener(t, Pe), Me(Te);
    }
    function Pe() {
      typeof Ae.removeListener == "function" && Ae.removeListener("error", Be), Ie([].slice.call(arguments));
    }
    R(Ae, t, Pe, { once: !0 }), t !== "error" && U(Ae, Be, { once: !0 });
  });
}
function U(Ae, t, Ie) {
  typeof Ae.on == "function" && R(Ae, "error", t, Ie);
}
function R(Ae, t, Ie, Me) {
  if (typeof Ae.on == "function") Me.once ? Ae.once(t, Ie) : Ae.on(t, Ie);
  else if (typeof Ae.addEventListener == "function") Ae.addEventListener(t, function Be(Pe) {
    Me.once && Ae.removeEventListener(t, Be), Ie(Pe);
  });
  else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof Ae);
}
const p = "Web3Wallet";
class x {
  constructor(t) {
    this.opts = t;
  }
}
class P {
  constructor(t) {
    this.client = t;
  }
}
var V = Object.defineProperty, B = Object.defineProperties, J = Object.getOwnPropertyDescriptors, q = Object.getOwnPropertySymbols, Y = Object.prototype.hasOwnProperty, Z = Object.prototype.propertyIsEnumerable, j = (Ae, t, Ie) => t in Ae ? V(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, ee = (Ae, t) => {
  for (var Ie in t || (t = {})) Y.call(t, Ie) && j(Ae, Ie, t[Ie]);
  if (q) for (var Ie of q(t)) Z.call(t, Ie) && j(Ae, Ie, t[Ie]);
  return Ae;
}, te = (Ae, t) => B(Ae, J(t));
class se extends P {
  constructor(t) {
    super(t), this.init = async () => {
      this.signClient = await Ps.init({ core: this.client.core, metadata: this.client.metadata, signConfig: this.client.signConfig }), this.authClient = await zr.init({ core: this.client.core, projectId: "", metadata: this.client.metadata });
    }, this.pair = async (Ie) => {
      await this.client.core.pairing.pair(Ie);
    }, this.approveSession = async (Ie) => {
      const { topic: Me, acknowledged: Be } = await this.signClient.approve(te(ee({}, Ie), { id: Ie.id, namespaces: Ie.namespaces, sessionProperties: Ie.sessionProperties, sessionConfig: Ie.sessionConfig }));
      return await Be(), this.signClient.session.get(Me);
    }, this.rejectSession = async (Ie) => await this.signClient.reject(Ie), this.updateSession = async (Ie) => await this.signClient.update(Ie), this.extendSession = async (Ie) => await this.signClient.extend(Ie), this.respondSessionRequest = async (Ie) => await this.signClient.respond(Ie), this.disconnectSession = async (Ie) => await this.signClient.disconnect(Ie), this.emitSessionEvent = async (Ie) => await this.signClient.emit(Ie), this.getActiveSessions = () => this.signClient.session.getAll().reduce((Ie, Me) => (Ie[Me.topic] = Me, Ie), {}), this.getPendingSessionProposals = () => this.signClient.proposal.getAll(), this.getPendingSessionRequests = () => this.signClient.getPendingSessionRequests(), this.respondAuthRequest = async (Ie, Me) => await this.authClient.respond(Ie, Me), this.getPendingAuthRequests = () => this.authClient.requests.getAll().filter((Ie) => "requester" in Ie), this.formatMessage = (Ie, Me) => this.authClient.formatMessage(Ie, Me), this.approveSessionAuthenticate = async (Ie) => await this.signClient.approveSessionAuthenticate(Ie), this.rejectSessionAuthenticate = async (Ie) => await this.signClient.rejectSessionAuthenticate(Ie), this.formatAuthMessage = (Ie) => this.signClient.formatAuthMessage(Ie), this.registerDeviceToken = (Ie) => this.client.core.echoClient.registerDeviceToken(Ie), this.on = (Ie, Me) => (this.setEvent(Ie, "off"), this.setEvent(Ie, "on"), this.client.events.on(Ie, Me)), this.once = (Ie, Me) => (this.setEvent(Ie, "off"), this.setEvent(Ie, "once"), this.client.events.once(Ie, Me)), this.off = (Ie, Me) => (this.setEvent(Ie, "off"), this.client.events.off(Ie, Me)), this.removeListener = (Ie, Me) => (this.setEvent(Ie, "removeListener"), this.client.events.removeListener(Ie, Me)), this.onSessionRequest = (Ie) => {
      this.client.events.emit("session_request", Ie);
    }, this.onSessionProposal = (Ie) => {
      this.client.events.emit("session_proposal", Ie);
    }, this.onSessionDelete = (Ie) => {
      this.client.events.emit("session_delete", Ie);
    }, this.onAuthRequest = (Ie) => {
      this.client.events.emit("auth_request", Ie);
    }, this.onProposalExpire = (Ie) => {
      this.client.events.emit("proposal_expire", Ie);
    }, this.onSessionRequestExpire = (Ie) => {
      this.client.events.emit("session_request_expire", Ie);
    }, this.onSessionRequestAuthenticate = (Ie) => {
      this.client.events.emit("session_authenticate", Ie);
    }, this.setEvent = (Ie, Me) => {
      switch (Ie) {
        case "session_request":
          this.signClient.events[Me]("session_request", this.onSessionRequest);
          break;
        case "session_proposal":
          this.signClient.events[Me]("session_proposal", this.onSessionProposal);
          break;
        case "session_delete":
          this.signClient.events[Me]("session_delete", this.onSessionDelete);
          break;
        case "auth_request":
          this.authClient[Me]("auth_request", this.onAuthRequest);
          break;
        case "proposal_expire":
          this.signClient.events[Me]("proposal_expire", this.onProposalExpire);
          break;
        case "session_request_expire":
          this.signClient.events[Me]("session_request_expire", this.onSessionRequestExpire);
          break;
        case "session_authenticate":
          this.signClient.events[Me]("session_authenticate", this.onSessionRequestAuthenticate);
          break;
      }
    }, this.signClient = {}, this.authClient = {};
  }
}
const ne = { decryptMessage: async (Ae) => {
  const t = { core: new bn({ storageOptions: Ae.storageOptions, storage: Ae.storage }) };
  await t.core.crypto.init();
  const Ie = t.core.crypto.decode(Ae.topic, Ae.encryptedMessage);
  return t.core = null, Ie;
}, getMetadata: async (Ae) => {
  const t = { core: new bn({ storageOptions: Ae.storageOptions, storage: Ae.storage }), sessionStore: null };
  t.sessionStore = new Ns(t.core, t.core.logger), await t.sessionStore.init();
  const Ie = t.sessionStore.get(Ae.topic), Me = Ie == null ? void 0 : Ie.peer.metadata;
  return t.core = null, t.sessionStore = null, Me;
} }, T = class extends x {
  constructor(Ae) {
    super(Ae), this.events = new l.exports(), this.on = (t, Ie) => this.engine.on(t, Ie), this.once = (t, Ie) => this.engine.once(t, Ie), this.off = (t, Ie) => this.engine.off(t, Ie), this.removeListener = (t, Ie) => this.engine.removeListener(t, Ie), this.pair = async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.approveSession = async (t) => {
      try {
        return await this.engine.approveSession(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.rejectSession = async (t) => {
      try {
        return await this.engine.rejectSession(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.updateSession = async (t) => {
      try {
        return await this.engine.updateSession(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.extendSession = async (t) => {
      try {
        return await this.engine.extendSession(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.respondSessionRequest = async (t) => {
      try {
        return await this.engine.respondSessionRequest(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.disconnectSession = async (t) => {
      try {
        return await this.engine.disconnectSession(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.emitSessionEvent = async (t) => {
      try {
        return await this.engine.emitSessionEvent(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.getActiveSessions = () => {
      try {
        return this.engine.getActiveSessions();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionProposals = () => {
      try {
        return this.engine.getPendingSessionProposals();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.respondAuthRequest = async (t, Ie) => {
      try {
        return await this.engine.respondAuthRequest(t, Ie);
      } catch (Me) {
        throw this.logger.error(Me.message), Me;
      }
    }, this.getPendingAuthRequests = () => {
      try {
        return this.engine.getPendingAuthRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.formatMessage = (t, Ie) => {
      try {
        return this.engine.formatMessage(t, Ie);
      } catch (Me) {
        throw this.logger.error(Me.message), Me;
      }
    }, this.registerDeviceToken = (t) => {
      try {
        return this.engine.registerDeviceToken(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.approveSessionAuthenticate = (t) => {
      try {
        return this.engine.approveSessionAuthenticate(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.rejectSessionAuthenticate = (t) => {
      try {
        return this.engine.rejectSessionAuthenticate(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.formatAuthMessage = (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.metadata = Ae.metadata, this.name = Ae.name || p, this.signConfig = Ae.signConfig, this.core = Ae.core, this.logger = this.core.logger, this.engine = new se(this);
  }
  static async init(Ae) {
    const t = new T(Ae);
    return await t.initialize(), t;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.engine.init(), this.logger.info("Web3Wallet Initialization Success");
    } catch (Ae) {
      throw this.logger.info("Web3Wallet Initialization Failure"), this.logger.error(Ae.message), Ae;
    }
  }
};
let v = T;
v.notifications = ne;
const ie = v;
export {
  Buffer as B,
  U$2 as U,
  Wr$1 as W,
  bn as b,
  global as g,
  ie as i
};

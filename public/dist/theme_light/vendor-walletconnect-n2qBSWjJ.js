import { g as getAugmentedNamespace, c as commonjsGlobal, d as getDefaultExportFromCjs, p as process$1 } from "./vendor-react-BG344YhI.js";
var buffer$1 = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len = code.length; i$2 < len; ++i$2)
  lookup[i$2] = code[i$2], revLookup[code.charCodeAt(i$2)] = i$2;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(Ae) {
  var t = Ae.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var Me = Ae.indexOf("=");
  Me === -1 && (Me = t);
  var Ie = Me === t ? 0 : 4 - Me % 4;
  return [Me, Ie];
}
function byteLength(Ae) {
  var t = getLens(Ae), Me = t[0], Ie = t[1];
  return (Me + Ie) * 3 / 4 - Ie;
}
function _byteLength(Ae, t, Me) {
  return (t + Me) * 3 / 4 - Me;
}
function toByteArray(Ae) {
  var t, Me = getLens(Ae), Ie = Me[0], Pe = Me[1], Be = new Arr(_byteLength(Ae, Ie, Pe)), Te = 0, je = Pe > 0 ? Ie - 4 : Ie, Ve;
  for (Ve = 0; Ve < je; Ve += 4)
    t = revLookup[Ae.charCodeAt(Ve)] << 18 | revLookup[Ae.charCodeAt(Ve + 1)] << 12 | revLookup[Ae.charCodeAt(Ve + 2)] << 6 | revLookup[Ae.charCodeAt(Ve + 3)], Be[Te++] = t >> 16 & 255, Be[Te++] = t >> 8 & 255, Be[Te++] = t & 255;
  return Pe === 2 && (t = revLookup[Ae.charCodeAt(Ve)] << 2 | revLookup[Ae.charCodeAt(Ve + 1)] >> 4, Be[Te++] = t & 255), Pe === 1 && (t = revLookup[Ae.charCodeAt(Ve)] << 10 | revLookup[Ae.charCodeAt(Ve + 1)] << 4 | revLookup[Ae.charCodeAt(Ve + 2)] >> 2, Be[Te++] = t >> 8 & 255, Be[Te++] = t & 255), Be;
}
function tripletToBase64(Ae) {
  return lookup[Ae >> 18 & 63] + lookup[Ae >> 12 & 63] + lookup[Ae >> 6 & 63] + lookup[Ae & 63];
}
function encodeChunk(Ae, t, Me) {
  for (var Ie, Pe = [], Be = t; Be < Me; Be += 3)
    Ie = (Ae[Be] << 16 & 16711680) + (Ae[Be + 1] << 8 & 65280) + (Ae[Be + 2] & 255), Pe.push(tripletToBase64(Ie));
  return Pe.join("");
}
function fromByteArray(Ae) {
  for (var t, Me = Ae.length, Ie = Me % 3, Pe = [], Be = 16383, Te = 0, je = Me - Ie; Te < je; Te += Be)
    Pe.push(encodeChunk(Ae, Te, Te + Be > je ? je : Te + Be));
  return Ie === 1 ? (t = Ae[Me - 1], Pe.push(
    lookup[t >> 2] + lookup[t << 4 & 63] + "=="
  )) : Ie === 2 && (t = (Ae[Me - 2] << 8) + Ae[Me - 1], Pe.push(
    lookup[t >> 10] + lookup[t >> 4 & 63] + lookup[t << 2 & 63] + "="
  )), Pe.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(Ae, t, Me, Ie, Pe) {
  var Be, Te, je = Pe * 8 - Ie - 1, Ve = (1 << je) - 1, fi = Ve >> 1, Ue = -7, bi = Me ? Pe - 1 : 0, vi = Me ? -1 : 1, mi = Ae[t + bi];
  for (bi += vi, Be = mi & (1 << -Ue) - 1, mi >>= -Ue, Ue += je; Ue > 0; Be = Be * 256 + Ae[t + bi], bi += vi, Ue -= 8)
    ;
  for (Te = Be & (1 << -Ue) - 1, Be >>= -Ue, Ue += Ie; Ue > 0; Te = Te * 256 + Ae[t + bi], bi += vi, Ue -= 8)
    ;
  if (Be === 0)
    Be = 1 - fi;
  else {
    if (Be === Ve)
      return Te ? NaN : (mi ? -1 : 1) * (1 / 0);
    Te = Te + Math.pow(2, Ie), Be = Be - fi;
  }
  return (mi ? -1 : 1) * Te * Math.pow(2, Be - Ie);
};
ieee754.write = function(Ae, t, Me, Ie, Pe, Be) {
  var Te, je, Ve, fi = Be * 8 - Pe - 1, Ue = (1 << fi) - 1, bi = Ue >> 1, vi = Pe === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, mi = Ie ? 0 : Be - 1, _i = Ie ? 1 : -1, $i = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (je = isNaN(t) ? 1 : 0, Te = Ue) : (Te = Math.floor(Math.log(t) / Math.LN2), t * (Ve = Math.pow(2, -Te)) < 1 && (Te--, Ve *= 2), Te + bi >= 1 ? t += vi / Ve : t += vi * Math.pow(2, 1 - bi), t * Ve >= 2 && (Te++, Ve /= 2), Te + bi >= Ue ? (je = 0, Te = Ue) : Te + bi >= 1 ? (je = (t * Ve - 1) * Math.pow(2, Pe), Te = Te + bi) : (je = t * Math.pow(2, bi - 1) * Math.pow(2, Pe), Te = 0)); Pe >= 8; Ae[Me + mi] = je & 255, mi += _i, je /= 256, Pe -= 8)
    ;
  for (Te = Te << Pe | je, fi += Pe; fi > 0; Ae[Me + mi] = Te & 255, mi += _i, Te /= 256, fi -= 8)
    ;
  Ae[Me + mi - _i] |= $i * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(Ae) {
  const t = base64Js, Me = ieee754, Ie = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  Ae.Buffer = Ue, Ae.SlowBuffer = Zi, Ae.INSPECT_MAX_BYTES = 50;
  const Pe = 2147483647;
  Ae.kMaxLength = Pe;
  const { Uint8Array: Be, ArrayBuffer: Te, SharedArrayBuffer: je } = globalThis;
  Ue.TYPED_ARRAY_SUPPORT = Ve(), !Ue.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function Ve() {
    try {
      const Yi = new Be(1), Li = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(Li, Be.prototype), Object.setPrototypeOf(Yi, Li), Yi.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(Ue.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (Ue.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(Ue.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (Ue.isBuffer(this))
        return this.byteOffset;
    }
  });
  function fi(Yi) {
    if (Yi > Pe)
      throw new RangeError('The value "' + Yi + '" is invalid for option "size"');
    const Li = new Be(Yi);
    return Object.setPrototypeOf(Li, Ue.prototype), Li;
  }
  function Ue(Yi, Li, zi) {
    if (typeof Yi == "number") {
      if (typeof Li == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return _i(Yi);
    }
    return bi(Yi, Li, zi);
  }
  Ue.poolSize = 8192;
  function bi(Yi, Li, zi) {
    if (typeof Yi == "string")
      return $i(Yi, Li);
    if (Te.isView(Yi))
      return Ui(Yi);
    if (Yi == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Yi
      );
    if (ra(Yi, Te) || Yi && ra(Yi.buffer, Te) || typeof je < "u" && (ra(Yi, je) || Yi && ra(Yi.buffer, je)))
      return ki(Yi, Li, zi);
    if (typeof Yi == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const En = Yi.valueOf && Yi.valueOf();
    if (En != null && En !== Yi)
      return Ue.from(En, Li, zi);
    const ss = Ji(Yi);
    if (ss) return ss;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Yi[Symbol.toPrimitive] == "function")
      return Ue.from(Yi[Symbol.toPrimitive]("string"), Li, zi);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Yi
    );
  }
  Ue.from = function(Yi, Li, zi) {
    return bi(Yi, Li, zi);
  }, Object.setPrototypeOf(Ue.prototype, Be.prototype), Object.setPrototypeOf(Ue, Be);
  function vi(Yi) {
    if (typeof Yi != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Yi < 0)
      throw new RangeError('The value "' + Yi + '" is invalid for option "size"');
  }
  function mi(Yi, Li, zi) {
    return vi(Yi), Yi <= 0 ? fi(Yi) : Li !== void 0 ? typeof zi == "string" ? fi(Yi).fill(Li, zi) : fi(Yi).fill(Li) : fi(Yi);
  }
  Ue.alloc = function(Yi, Li, zi) {
    return mi(Yi, Li, zi);
  };
  function _i(Yi) {
    return vi(Yi), fi(Yi < 0 ? 0 : Hi(Yi) | 0);
  }
  Ue.allocUnsafe = function(Yi) {
    return _i(Yi);
  }, Ue.allocUnsafeSlow = function(Yi) {
    return _i(Yi);
  };
  function $i(Yi, Li) {
    if ((typeof Li != "string" || Li === "") && (Li = "utf8"), !Ue.isEncoding(Li))
      throw new TypeError("Unknown encoding: " + Li);
    const zi = Qi(Yi, Li) | 0;
    let En = fi(zi);
    const ss = En.write(Yi, Li);
    return ss !== zi && (En = En.slice(0, ss)), En;
  }
  function Ci(Yi) {
    const Li = Yi.length < 0 ? 0 : Hi(Yi.length) | 0, zi = fi(Li);
    for (let En = 0; En < Li; En += 1)
      zi[En] = Yi[En] & 255;
    return zi;
  }
  function Ui(Yi) {
    if (ra(Yi, Be)) {
      const Li = new Be(Yi);
      return ki(Li.buffer, Li.byteOffset, Li.byteLength);
    }
    return Ci(Yi);
  }
  function ki(Yi, Li, zi) {
    if (Li < 0 || Yi.byteLength < Li)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Yi.byteLength < Li + (zi || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let En;
    return Li === void 0 && zi === void 0 ? En = new Be(Yi) : zi === void 0 ? En = new Be(Yi, Li) : En = new Be(Yi, Li, zi), Object.setPrototypeOf(En, Ue.prototype), En;
  }
  function Ji(Yi) {
    if (Ue.isBuffer(Yi)) {
      const Li = Hi(Yi.length) | 0, zi = fi(Li);
      return zi.length === 0 || Yi.copy(zi, 0, 0, Li), zi;
    }
    if (Yi.length !== void 0)
      return typeof Yi.length != "number" || ca(Yi.length) ? fi(0) : Ci(Yi);
    if (Yi.type === "Buffer" && Array.isArray(Yi.data))
      return Ci(Yi.data);
  }
  function Hi(Yi) {
    if (Yi >= Pe)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Pe.toString(16) + " bytes");
    return Yi | 0;
  }
  function Zi(Yi) {
    return +Yi != Yi && (Yi = 0), Ue.alloc(+Yi);
  }
  Ue.isBuffer = function(Li) {
    return Li != null && Li._isBuffer === !0 && Li !== Ue.prototype;
  }, Ue.compare = function(Li, zi) {
    if (ra(Li, Be) && (Li = Ue.from(Li, Li.offset, Li.byteLength)), ra(zi, Be) && (zi = Ue.from(zi, zi.offset, zi.byteLength)), !Ue.isBuffer(Li) || !Ue.isBuffer(zi))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (Li === zi) return 0;
    let En = Li.length, ss = zi.length;
    for (let as = 0, us = Math.min(En, ss); as < us; ++as)
      if (Li[as] !== zi[as]) {
        En = Li[as], ss = zi[as];
        break;
      }
    return En < ss ? -1 : ss < En ? 1 : 0;
  }, Ue.isEncoding = function(Li) {
    switch (String(Li).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, Ue.concat = function(Li, zi) {
    if (!Array.isArray(Li))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (Li.length === 0)
      return Ue.alloc(0);
    let En;
    if (zi === void 0)
      for (zi = 0, En = 0; En < Li.length; ++En)
        zi += Li[En].length;
    const ss = Ue.allocUnsafe(zi);
    let as = 0;
    for (En = 0; En < Li.length; ++En) {
      let us = Li[En];
      if (ra(us, Be))
        as + us.length > ss.length ? (Ue.isBuffer(us) || (us = Ue.from(us)), us.copy(ss, as)) : Be.prototype.set.call(
          ss,
          us,
          as
        );
      else if (Ue.isBuffer(us))
        us.copy(ss, as);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      as += us.length;
    }
    return ss;
  };
  function Qi(Yi, Li) {
    if (Ue.isBuffer(Yi))
      return Yi.length;
    if (Te.isView(Yi) || ra(Yi, Te))
      return Yi.byteLength;
    if (typeof Yi != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Yi
      );
    const zi = Yi.length, En = arguments.length > 2 && arguments[2] === !0;
    if (!En && zi === 0) return 0;
    let ss = !1;
    for (; ; )
      switch (Li) {
        case "ascii":
        case "latin1":
        case "binary":
          return zi;
        case "utf8":
        case "utf-8":
          return fa(Yi).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return zi * 2;
        case "hex":
          return zi >>> 1;
        case "base64":
          return aa(Yi).length;
        default:
          if (ss)
            return En ? -1 : fa(Yi).length;
          Li = ("" + Li).toLowerCase(), ss = !0;
      }
  }
  Ue.byteLength = Qi;
  function Bi(Yi, Li, zi) {
    let En = !1;
    if ((Li === void 0 || Li < 0) && (Li = 0), Li > this.length || ((zi === void 0 || zi > this.length) && (zi = this.length), zi <= 0) || (zi >>>= 0, Li >>>= 0, zi <= Li))
      return "";
    for (Yi || (Yi = "utf8"); ; )
      switch (Yi) {
        case "hex":
          return xi(this, Li, zi);
        case "utf8":
        case "utf-8":
          return Pi(this, Li, zi);
        case "ascii":
          return Si(this, Li, zi);
        case "latin1":
        case "binary":
          return Ni(this, Li, zi);
        case "base64":
          return Ti(this, Li, zi);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Wi(this, Li, zi);
        default:
          if (En) throw new TypeError("Unknown encoding: " + Yi);
          Yi = (Yi + "").toLowerCase(), En = !0;
      }
  }
  Ue.prototype._isBuffer = !0;
  function Xi(Yi, Li, zi) {
    const En = Yi[Li];
    Yi[Li] = Yi[zi], Yi[zi] = En;
  }
  Ue.prototype.swap16 = function() {
    const Li = this.length;
    if (Li % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let zi = 0; zi < Li; zi += 2)
      Xi(this, zi, zi + 1);
    return this;
  }, Ue.prototype.swap32 = function() {
    const Li = this.length;
    if (Li % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let zi = 0; zi < Li; zi += 4)
      Xi(this, zi, zi + 3), Xi(this, zi + 1, zi + 2);
    return this;
  }, Ue.prototype.swap64 = function() {
    const Li = this.length;
    if (Li % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let zi = 0; zi < Li; zi += 8)
      Xi(this, zi, zi + 7), Xi(this, zi + 1, zi + 6), Xi(this, zi + 2, zi + 5), Xi(this, zi + 3, zi + 4);
    return this;
  }, Ue.prototype.toString = function() {
    const Li = this.length;
    return Li === 0 ? "" : arguments.length === 0 ? Pi(this, 0, Li) : Bi.apply(this, arguments);
  }, Ue.prototype.toLocaleString = Ue.prototype.toString, Ue.prototype.equals = function(Li) {
    if (!Ue.isBuffer(Li)) throw new TypeError("Argument must be a Buffer");
    return this === Li ? !0 : Ue.compare(this, Li) === 0;
  }, Ue.prototype.inspect = function() {
    let Li = "";
    const zi = Ae.INSPECT_MAX_BYTES;
    return Li = this.toString("hex", 0, zi).replace(/(.{2})/g, "$1 ").trim(), this.length > zi && (Li += " ... "), "<Buffer " + Li + ">";
  }, Ie && (Ue.prototype[Ie] = Ue.prototype.inspect), Ue.prototype.compare = function(Li, zi, En, ss, as) {
    if (ra(Li, Be) && (Li = Ue.from(Li, Li.offset, Li.byteLength)), !Ue.isBuffer(Li))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Li
      );
    if (zi === void 0 && (zi = 0), En === void 0 && (En = Li ? Li.length : 0), ss === void 0 && (ss = 0), as === void 0 && (as = this.length), zi < 0 || En > Li.length || ss < 0 || as > this.length)
      throw new RangeError("out of range index");
    if (ss >= as && zi >= En)
      return 0;
    if (ss >= as)
      return -1;
    if (zi >= En)
      return 1;
    if (zi >>>= 0, En >>>= 0, ss >>>= 0, as >>>= 0, this === Li) return 0;
    let us = as - ss, ua = En - zi;
    const ma = Math.min(us, ua), na = this.slice(ss, as), wa = Li.slice(zi, En);
    for (let ya = 0; ya < ma; ++ya)
      if (na[ya] !== wa[ya]) {
        us = na[ya], ua = wa[ya];
        break;
      }
    return us < ua ? -1 : ua < us ? 1 : 0;
  };
  function ns(Yi, Li, zi, En, ss) {
    if (Yi.length === 0) return -1;
    if (typeof zi == "string" ? (En = zi, zi = 0) : zi > 2147483647 ? zi = 2147483647 : zi < -2147483648 && (zi = -2147483648), zi = +zi, ca(zi) && (zi = ss ? 0 : Yi.length - 1), zi < 0 && (zi = Yi.length + zi), zi >= Yi.length) {
      if (ss) return -1;
      zi = Yi.length - 1;
    } else if (zi < 0)
      if (ss) zi = 0;
      else return -1;
    if (typeof Li == "string" && (Li = Ue.from(Li, En)), Ue.isBuffer(Li))
      return Li.length === 0 ? -1 : ls(Yi, Li, zi, En, ss);
    if (typeof Li == "number")
      return Li = Li & 255, typeof Be.prototype.indexOf == "function" ? ss ? Be.prototype.indexOf.call(Yi, Li, zi) : Be.prototype.lastIndexOf.call(Yi, Li, zi) : ls(Yi, [Li], zi, En, ss);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ls(Yi, Li, zi, En, ss) {
    let as = 1, us = Yi.length, ua = Li.length;
    if (En !== void 0 && (En = String(En).toLowerCase(), En === "ucs2" || En === "ucs-2" || En === "utf16le" || En === "utf-16le")) {
      if (Yi.length < 2 || Li.length < 2)
        return -1;
      as = 2, us /= 2, ua /= 2, zi /= 2;
    }
    function ma(wa, ya) {
      return as === 1 ? wa[ya] : wa.readUInt16BE(ya * as);
    }
    let na;
    if (ss) {
      let wa = -1;
      for (na = zi; na < us; na++)
        if (ma(Yi, na) === ma(Li, wa === -1 ? 0 : na - wa)) {
          if (wa === -1 && (wa = na), na - wa + 1 === ua) return wa * as;
        } else
          wa !== -1 && (na -= na - wa), wa = -1;
    } else
      for (zi + ua > us && (zi = us - ua), na = zi; na >= 0; na--) {
        let wa = !0;
        for (let ya = 0; ya < ua; ya++)
          if (ma(Yi, na + ya) !== ma(Li, ya)) {
            wa = !1;
            break;
          }
        if (wa) return na;
      }
    return -1;
  }
  Ue.prototype.includes = function(Li, zi, En) {
    return this.indexOf(Li, zi, En) !== -1;
  }, Ue.prototype.indexOf = function(Li, zi, En) {
    return ns(this, Li, zi, En, !0);
  }, Ue.prototype.lastIndexOf = function(Li, zi, En) {
    return ns(this, Li, zi, En, !1);
  };
  function vn(Yi, Li, zi, En) {
    zi = Number(zi) || 0;
    const ss = Yi.length - zi;
    En ? (En = Number(En), En > ss && (En = ss)) : En = ss;
    const as = Li.length;
    En > as / 2 && (En = as / 2);
    let us;
    for (us = 0; us < En; ++us) {
      const ua = parseInt(Li.substr(us * 2, 2), 16);
      if (ca(ua)) return us;
      Yi[zi + us] = ua;
    }
    return us;
  }
  function Mi(Yi, Li, zi, En) {
    return Ds(fa(Li, Yi.length - zi), Yi, zi, En);
  }
  function Ai(Yi, Li, zi, En) {
    return Ds(gs(Li), Yi, zi, En);
  }
  function wi(Yi, Li, zi, En) {
    return Ds(aa(Li), Yi, zi, En);
  }
  function Ei(Yi, Li, zi, En) {
    return Ds(sa(Li, Yi.length - zi), Yi, zi, En);
  }
  Ue.prototype.write = function(Li, zi, En, ss) {
    if (zi === void 0)
      ss = "utf8", En = this.length, zi = 0;
    else if (En === void 0 && typeof zi == "string")
      ss = zi, En = this.length, zi = 0;
    else if (isFinite(zi))
      zi = zi >>> 0, isFinite(En) ? (En = En >>> 0, ss === void 0 && (ss = "utf8")) : (ss = En, En = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const as = this.length - zi;
    if ((En === void 0 || En > as) && (En = as), Li.length > 0 && (En < 0 || zi < 0) || zi > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    ss || (ss = "utf8");
    let us = !1;
    for (; ; )
      switch (ss) {
        case "hex":
          return vn(this, Li, zi, En);
        case "utf8":
        case "utf-8":
          return Mi(this, Li, zi, En);
        case "ascii":
        case "latin1":
        case "binary":
          return Ai(this, Li, zi, En);
        case "base64":
          return wi(this, Li, zi, En);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ei(this, Li, zi, En);
        default:
          if (us) throw new TypeError("Unknown encoding: " + ss);
          ss = ("" + ss).toLowerCase(), us = !0;
      }
  }, Ue.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function Ti(Yi, Li, zi) {
    return Li === 0 && zi === Yi.length ? t.fromByteArray(Yi) : t.fromByteArray(Yi.slice(Li, zi));
  }
  function Pi(Yi, Li, zi) {
    zi = Math.min(Yi.length, zi);
    const En = [];
    let ss = Li;
    for (; ss < zi; ) {
      const as = Yi[ss];
      let us = null, ua = as > 239 ? 4 : as > 223 ? 3 : as > 191 ? 2 : 1;
      if (ss + ua <= zi) {
        let ma, na, wa, ya;
        switch (ua) {
          case 1:
            as < 128 && (us = as);
            break;
          case 2:
            ma = Yi[ss + 1], (ma & 192) === 128 && (ya = (as & 31) << 6 | ma & 63, ya > 127 && (us = ya));
            break;
          case 3:
            ma = Yi[ss + 1], na = Yi[ss + 2], (ma & 192) === 128 && (na & 192) === 128 && (ya = (as & 15) << 12 | (ma & 63) << 6 | na & 63, ya > 2047 && (ya < 55296 || ya > 57343) && (us = ya));
            break;
          case 4:
            ma = Yi[ss + 1], na = Yi[ss + 2], wa = Yi[ss + 3], (ma & 192) === 128 && (na & 192) === 128 && (wa & 192) === 128 && (ya = (as & 15) << 18 | (ma & 63) << 12 | (na & 63) << 6 | wa & 63, ya > 65535 && ya < 1114112 && (us = ya));
        }
      }
      us === null ? (us = 65533, ua = 1) : us > 65535 && (us -= 65536, En.push(us >>> 10 & 1023 | 55296), us = 56320 | us & 1023), En.push(us), ss += ua;
    }
    return Oi(En);
  }
  const qi = 4096;
  function Oi(Yi) {
    const Li = Yi.length;
    if (Li <= qi)
      return String.fromCharCode.apply(String, Yi);
    let zi = "", En = 0;
    for (; En < Li; )
      zi += String.fromCharCode.apply(
        String,
        Yi.slice(En, En += qi)
      );
    return zi;
  }
  function Si(Yi, Li, zi) {
    let En = "";
    zi = Math.min(Yi.length, zi);
    for (let ss = Li; ss < zi; ++ss)
      En += String.fromCharCode(Yi[ss] & 127);
    return En;
  }
  function Ni(Yi, Li, zi) {
    let En = "";
    zi = Math.min(Yi.length, zi);
    for (let ss = Li; ss < zi; ++ss)
      En += String.fromCharCode(Yi[ss]);
    return En;
  }
  function xi(Yi, Li, zi) {
    const En = Yi.length;
    (!Li || Li < 0) && (Li = 0), (!zi || zi < 0 || zi > En) && (zi = En);
    let ss = "";
    for (let as = Li; as < zi; ++as)
      ss += ta[Yi[as]];
    return ss;
  }
  function Wi(Yi, Li, zi) {
    const En = Yi.slice(Li, zi);
    let ss = "";
    for (let as = 0; as < En.length - 1; as += 2)
      ss += String.fromCharCode(En[as] + En[as + 1] * 256);
    return ss;
  }
  Ue.prototype.slice = function(Li, zi) {
    const En = this.length;
    Li = ~~Li, zi = zi === void 0 ? En : ~~zi, Li < 0 ? (Li += En, Li < 0 && (Li = 0)) : Li > En && (Li = En), zi < 0 ? (zi += En, zi < 0 && (zi = 0)) : zi > En && (zi = En), zi < Li && (zi = Li);
    const ss = this.subarray(Li, zi);
    return Object.setPrototypeOf(ss, Ue.prototype), ss;
  };
  function ts(Yi, Li, zi) {
    if (Yi % 1 !== 0 || Yi < 0) throw new RangeError("offset is not uint");
    if (Yi + Li > zi) throw new RangeError("Trying to access beyond buffer length");
  }
  Ue.prototype.readUintLE = Ue.prototype.readUIntLE = function(Li, zi, En) {
    Li = Li >>> 0, zi = zi >>> 0, En || ts(Li, zi, this.length);
    let ss = this[Li], as = 1, us = 0;
    for (; ++us < zi && (as *= 256); )
      ss += this[Li + us] * as;
    return ss;
  }, Ue.prototype.readUintBE = Ue.prototype.readUIntBE = function(Li, zi, En) {
    Li = Li >>> 0, zi = zi >>> 0, En || ts(Li, zi, this.length);
    let ss = this[Li + --zi], as = 1;
    for (; zi > 0 && (as *= 256); )
      ss += this[Li + --zi] * as;
    return ss;
  }, Ue.prototype.readUint8 = Ue.prototype.readUInt8 = function(Li, zi) {
    return Li = Li >>> 0, zi || ts(Li, 1, this.length), this[Li];
  }, Ue.prototype.readUint16LE = Ue.prototype.readUInt16LE = function(Li, zi) {
    return Li = Li >>> 0, zi || ts(Li, 2, this.length), this[Li] | this[Li + 1] << 8;
  }, Ue.prototype.readUint16BE = Ue.prototype.readUInt16BE = function(Li, zi) {
    return Li = Li >>> 0, zi || ts(Li, 2, this.length), this[Li] << 8 | this[Li + 1];
  }, Ue.prototype.readUint32LE = Ue.prototype.readUInt32LE = function(Li, zi) {
    return Li = Li >>> 0, zi || ts(Li, 4, this.length), (this[Li] | this[Li + 1] << 8 | this[Li + 2] << 16) + this[Li + 3] * 16777216;
  }, Ue.prototype.readUint32BE = Ue.prototype.readUInt32BE = function(Li, zi) {
    return Li = Li >>> 0, zi || ts(Li, 4, this.length), this[Li] * 16777216 + (this[Li + 1] << 16 | this[Li + 2] << 8 | this[Li + 3]);
  }, Ue.prototype.readBigUInt64LE = oa(function(Li) {
    Li = Li >>> 0, ps(Li, "offset");
    const zi = this[Li], En = this[Li + 7];
    (zi === void 0 || En === void 0) && ea(Li, this.length - 8);
    const ss = zi + this[++Li] * 2 ** 8 + this[++Li] * 2 ** 16 + this[++Li] * 2 ** 24, as = this[++Li] + this[++Li] * 2 ** 8 + this[++Li] * 2 ** 16 + En * 2 ** 24;
    return BigInt(ss) + (BigInt(as) << BigInt(32));
  }), Ue.prototype.readBigUInt64BE = oa(function(Li) {
    Li = Li >>> 0, ps(Li, "offset");
    const zi = this[Li], En = this[Li + 7];
    (zi === void 0 || En === void 0) && ea(Li, this.length - 8);
    const ss = zi * 2 ** 24 + this[++Li] * 2 ** 16 + this[++Li] * 2 ** 8 + this[++Li], as = this[++Li] * 2 ** 24 + this[++Li] * 2 ** 16 + this[++Li] * 2 ** 8 + En;
    return (BigInt(ss) << BigInt(32)) + BigInt(as);
  }), Ue.prototype.readIntLE = function(Li, zi, En) {
    Li = Li >>> 0, zi = zi >>> 0, En || ts(Li, zi, this.length);
    let ss = this[Li], as = 1, us = 0;
    for (; ++us < zi && (as *= 256); )
      ss += this[Li + us] * as;
    return as *= 128, ss >= as && (ss -= Math.pow(2, 8 * zi)), ss;
  }, Ue.prototype.readIntBE = function(Li, zi, En) {
    Li = Li >>> 0, zi = zi >>> 0, En || ts(Li, zi, this.length);
    let ss = zi, as = 1, us = this[Li + --ss];
    for (; ss > 0 && (as *= 256); )
      us += this[Li + --ss] * as;
    return as *= 128, us >= as && (us -= Math.pow(2, 8 * zi)), us;
  }, Ue.prototype.readInt8 = function(Li, zi) {
    return Li = Li >>> 0, zi || ts(Li, 1, this.length), this[Li] & 128 ? (255 - this[Li] + 1) * -1 : this[Li];
  }, Ue.prototype.readInt16LE = function(Li, zi) {
    Li = Li >>> 0, zi || ts(Li, 2, this.length);
    const En = this[Li] | this[Li + 1] << 8;
    return En & 32768 ? En | 4294901760 : En;
  }, Ue.prototype.readInt16BE = function(Li, zi) {
    Li = Li >>> 0, zi || ts(Li, 2, this.length);
    const En = this[Li + 1] | this[Li] << 8;
    return En & 32768 ? En | 4294901760 : En;
  }, Ue.prototype.readInt32LE = function(Li, zi) {
    return Li = Li >>> 0, zi || ts(Li, 4, this.length), this[Li] | this[Li + 1] << 8 | this[Li + 2] << 16 | this[Li + 3] << 24;
  }, Ue.prototype.readInt32BE = function(Li, zi) {
    return Li = Li >>> 0, zi || ts(Li, 4, this.length), this[Li] << 24 | this[Li + 1] << 16 | this[Li + 2] << 8 | this[Li + 3];
  }, Ue.prototype.readBigInt64LE = oa(function(Li) {
    Li = Li >>> 0, ps(Li, "offset");
    const zi = this[Li], En = this[Li + 7];
    (zi === void 0 || En === void 0) && ea(Li, this.length - 8);
    const ss = this[Li + 4] + this[Li + 5] * 2 ** 8 + this[Li + 6] * 2 ** 16 + (En << 24);
    return (BigInt(ss) << BigInt(32)) + BigInt(zi + this[++Li] * 2 ** 8 + this[++Li] * 2 ** 16 + this[++Li] * 2 ** 24);
  }), Ue.prototype.readBigInt64BE = oa(function(Li) {
    Li = Li >>> 0, ps(Li, "offset");
    const zi = this[Li], En = this[Li + 7];
    (zi === void 0 || En === void 0) && ea(Li, this.length - 8);
    const ss = (zi << 24) + // Overflow
    this[++Li] * 2 ** 16 + this[++Li] * 2 ** 8 + this[++Li];
    return (BigInt(ss) << BigInt(32)) + BigInt(this[++Li] * 2 ** 24 + this[++Li] * 2 ** 16 + this[++Li] * 2 ** 8 + En);
  }), Ue.prototype.readFloatLE = function(Li, zi) {
    return Li = Li >>> 0, zi || ts(Li, 4, this.length), Me.read(this, Li, !0, 23, 4);
  }, Ue.prototype.readFloatBE = function(Li, zi) {
    return Li = Li >>> 0, zi || ts(Li, 4, this.length), Me.read(this, Li, !1, 23, 4);
  }, Ue.prototype.readDoubleLE = function(Li, zi) {
    return Li = Li >>> 0, zi || ts(Li, 8, this.length), Me.read(this, Li, !0, 52, 8);
  }, Ue.prototype.readDoubleBE = function(Li, zi) {
    return Li = Li >>> 0, zi || ts(Li, 8, this.length), Me.read(this, Li, !1, 52, 8);
  };
  function Ki(Yi, Li, zi, En, ss, as) {
    if (!Ue.isBuffer(Yi)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (Li > ss || Li < as) throw new RangeError('"value" argument is out of bounds');
    if (zi + En > Yi.length) throw new RangeError("Index out of range");
  }
  Ue.prototype.writeUintLE = Ue.prototype.writeUIntLE = function(Li, zi, En, ss) {
    if (Li = +Li, zi = zi >>> 0, En = En >>> 0, !ss) {
      const ua = Math.pow(2, 8 * En) - 1;
      Ki(this, Li, zi, En, ua, 0);
    }
    let as = 1, us = 0;
    for (this[zi] = Li & 255; ++us < En && (as *= 256); )
      this[zi + us] = Li / as & 255;
    return zi + En;
  }, Ue.prototype.writeUintBE = Ue.prototype.writeUIntBE = function(Li, zi, En, ss) {
    if (Li = +Li, zi = zi >>> 0, En = En >>> 0, !ss) {
      const ua = Math.pow(2, 8 * En) - 1;
      Ki(this, Li, zi, En, ua, 0);
    }
    let as = En - 1, us = 1;
    for (this[zi + as] = Li & 255; --as >= 0 && (us *= 256); )
      this[zi + as] = Li / us & 255;
    return zi + En;
  }, Ue.prototype.writeUint8 = Ue.prototype.writeUInt8 = function(Li, zi, En) {
    return Li = +Li, zi = zi >>> 0, En || Ki(this, Li, zi, 1, 255, 0), this[zi] = Li & 255, zi + 1;
  }, Ue.prototype.writeUint16LE = Ue.prototype.writeUInt16LE = function(Li, zi, En) {
    return Li = +Li, zi = zi >>> 0, En || Ki(this, Li, zi, 2, 65535, 0), this[zi] = Li & 255, this[zi + 1] = Li >>> 8, zi + 2;
  }, Ue.prototype.writeUint16BE = Ue.prototype.writeUInt16BE = function(Li, zi, En) {
    return Li = +Li, zi = zi >>> 0, En || Ki(this, Li, zi, 2, 65535, 0), this[zi] = Li >>> 8, this[zi + 1] = Li & 255, zi + 2;
  }, Ue.prototype.writeUint32LE = Ue.prototype.writeUInt32LE = function(Li, zi, En) {
    return Li = +Li, zi = zi >>> 0, En || Ki(this, Li, zi, 4, 4294967295, 0), this[zi + 3] = Li >>> 24, this[zi + 2] = Li >>> 16, this[zi + 1] = Li >>> 8, this[zi] = Li & 255, zi + 4;
  }, Ue.prototype.writeUint32BE = Ue.prototype.writeUInt32BE = function(Li, zi, En) {
    return Li = +Li, zi = zi >>> 0, En || Ki(this, Li, zi, 4, 4294967295, 0), this[zi] = Li >>> 24, this[zi + 1] = Li >>> 16, this[zi + 2] = Li >>> 8, this[zi + 3] = Li & 255, zi + 4;
  };
  function fn(Yi, Li, zi, En, ss) {
    ds(Li, En, ss, Yi, zi, 7);
    let as = Number(Li & BigInt(4294967295));
    Yi[zi++] = as, as = as >> 8, Yi[zi++] = as, as = as >> 8, Yi[zi++] = as, as = as >> 8, Yi[zi++] = as;
    let us = Number(Li >> BigInt(32) & BigInt(4294967295));
    return Yi[zi++] = us, us = us >> 8, Yi[zi++] = us, us = us >> 8, Yi[zi++] = us, us = us >> 8, Yi[zi++] = us, zi;
  }
  function Ii(Yi, Li, zi, En, ss) {
    ds(Li, En, ss, Yi, zi, 7);
    let as = Number(Li & BigInt(4294967295));
    Yi[zi + 7] = as, as = as >> 8, Yi[zi + 6] = as, as = as >> 8, Yi[zi + 5] = as, as = as >> 8, Yi[zi + 4] = as;
    let us = Number(Li >> BigInt(32) & BigInt(4294967295));
    return Yi[zi + 3] = us, us = us >> 8, Yi[zi + 2] = us, us = us >> 8, Yi[zi + 1] = us, us = us >> 8, Yi[zi] = us, zi + 8;
  }
  Ue.prototype.writeBigUInt64LE = oa(function(Li, zi = 0) {
    return fn(this, Li, zi, BigInt(0), BigInt("0xffffffffffffffff"));
  }), Ue.prototype.writeBigUInt64BE = oa(function(Li, zi = 0) {
    return Ii(this, Li, zi, BigInt(0), BigInt("0xffffffffffffffff"));
  }), Ue.prototype.writeIntLE = function(Li, zi, En, ss) {
    if (Li = +Li, zi = zi >>> 0, !ss) {
      const ma = Math.pow(2, 8 * En - 1);
      Ki(this, Li, zi, En, ma - 1, -ma);
    }
    let as = 0, us = 1, ua = 0;
    for (this[zi] = Li & 255; ++as < En && (us *= 256); )
      Li < 0 && ua === 0 && this[zi + as - 1] !== 0 && (ua = 1), this[zi + as] = (Li / us >> 0) - ua & 255;
    return zi + En;
  }, Ue.prototype.writeIntBE = function(Li, zi, En, ss) {
    if (Li = +Li, zi = zi >>> 0, !ss) {
      const ma = Math.pow(2, 8 * En - 1);
      Ki(this, Li, zi, En, ma - 1, -ma);
    }
    let as = En - 1, us = 1, ua = 0;
    for (this[zi + as] = Li & 255; --as >= 0 && (us *= 256); )
      Li < 0 && ua === 0 && this[zi + as + 1] !== 0 && (ua = 1), this[zi + as] = (Li / us >> 0) - ua & 255;
    return zi + En;
  }, Ue.prototype.writeInt8 = function(Li, zi, En) {
    return Li = +Li, zi = zi >>> 0, En || Ki(this, Li, zi, 1, 127, -128), Li < 0 && (Li = 255 + Li + 1), this[zi] = Li & 255, zi + 1;
  }, Ue.prototype.writeInt16LE = function(Li, zi, En) {
    return Li = +Li, zi = zi >>> 0, En || Ki(this, Li, zi, 2, 32767, -32768), this[zi] = Li & 255, this[zi + 1] = Li >>> 8, zi + 2;
  }, Ue.prototype.writeInt16BE = function(Li, zi, En) {
    return Li = +Li, zi = zi >>> 0, En || Ki(this, Li, zi, 2, 32767, -32768), this[zi] = Li >>> 8, this[zi + 1] = Li & 255, zi + 2;
  }, Ue.prototype.writeInt32LE = function(Li, zi, En) {
    return Li = +Li, zi = zi >>> 0, En || Ki(this, Li, zi, 4, 2147483647, -2147483648), this[zi] = Li & 255, this[zi + 1] = Li >>> 8, this[zi + 2] = Li >>> 16, this[zi + 3] = Li >>> 24, zi + 4;
  }, Ue.prototype.writeInt32BE = function(Li, zi, En) {
    return Li = +Li, zi = zi >>> 0, En || Ki(this, Li, zi, 4, 2147483647, -2147483648), Li < 0 && (Li = 4294967295 + Li + 1), this[zi] = Li >>> 24, this[zi + 1] = Li >>> 16, this[zi + 2] = Li >>> 8, this[zi + 3] = Li & 255, zi + 4;
  }, Ue.prototype.writeBigInt64LE = oa(function(Li, zi = 0) {
    return fn(this, Li, zi, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), Ue.prototype.writeBigInt64BE = oa(function(Li, zi = 0) {
    return Ii(this, Li, zi, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Fi(Yi, Li, zi, En, ss, as) {
    if (zi + En > Yi.length) throw new RangeError("Index out of range");
    if (zi < 0) throw new RangeError("Index out of range");
  }
  function Gi(Yi, Li, zi, En, ss) {
    return Li = +Li, zi = zi >>> 0, ss || Fi(Yi, Li, zi, 4), Me.write(Yi, Li, zi, En, 23, 4), zi + 4;
  }
  Ue.prototype.writeFloatLE = function(Li, zi, En) {
    return Gi(this, Li, zi, !0, En);
  }, Ue.prototype.writeFloatBE = function(Li, zi, En) {
    return Gi(this, Li, zi, !1, En);
  };
  function Ri(Yi, Li, zi, En, ss) {
    return Li = +Li, zi = zi >>> 0, ss || Fi(Yi, Li, zi, 8), Me.write(Yi, Li, zi, En, 52, 8), zi + 8;
  }
  Ue.prototype.writeDoubleLE = function(Li, zi, En) {
    return Ri(this, Li, zi, !0, En);
  }, Ue.prototype.writeDoubleBE = function(Li, zi, En) {
    return Ri(this, Li, zi, !1, En);
  }, Ue.prototype.copy = function(Li, zi, En, ss) {
    if (!Ue.isBuffer(Li)) throw new TypeError("argument should be a Buffer");
    if (En || (En = 0), !ss && ss !== 0 && (ss = this.length), zi >= Li.length && (zi = Li.length), zi || (zi = 0), ss > 0 && ss < En && (ss = En), ss === En || Li.length === 0 || this.length === 0) return 0;
    if (zi < 0)
      throw new RangeError("targetStart out of bounds");
    if (En < 0 || En >= this.length) throw new RangeError("Index out of range");
    if (ss < 0) throw new RangeError("sourceEnd out of bounds");
    ss > this.length && (ss = this.length), Li.length - zi < ss - En && (ss = Li.length - zi + En);
    const as = ss - En;
    return this === Li && typeof Be.prototype.copyWithin == "function" ? this.copyWithin(zi, En, ss) : Be.prototype.set.call(
      Li,
      this.subarray(En, ss),
      zi
    ), as;
  }, Ue.prototype.fill = function(Li, zi, En, ss) {
    if (typeof Li == "string") {
      if (typeof zi == "string" ? (ss = zi, zi = 0, En = this.length) : typeof En == "string" && (ss = En, En = this.length), ss !== void 0 && typeof ss != "string")
        throw new TypeError("encoding must be a string");
      if (typeof ss == "string" && !Ue.isEncoding(ss))
        throw new TypeError("Unknown encoding: " + ss);
      if (Li.length === 1) {
        const us = Li.charCodeAt(0);
        (ss === "utf8" && us < 128 || ss === "latin1") && (Li = us);
      }
    } else typeof Li == "number" ? Li = Li & 255 : typeof Li == "boolean" && (Li = Number(Li));
    if (zi < 0 || this.length < zi || this.length < En)
      throw new RangeError("Out of range index");
    if (En <= zi)
      return this;
    zi = zi >>> 0, En = En === void 0 ? this.length : En >>> 0, Li || (Li = 0);
    let as;
    if (typeof Li == "number")
      for (as = zi; as < En; ++as)
        this[as] = Li;
    else {
      const us = Ue.isBuffer(Li) ? Li : Ue.from(Li, ss), ua = us.length;
      if (ua === 0)
        throw new TypeError('The value "' + Li + '" is invalid for argument "value"');
      for (as = 0; as < En - zi; ++as)
        this[as + zi] = us[as % ua];
    }
    return this;
  };
  const ji = {};
  function Vi(Yi, Li, zi) {
    ji[Yi] = class extends zi {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: Li.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${Yi}]`, this.stack, delete this.name;
      }
      get code() {
        return Yi;
      }
      set code(ss) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: ss,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${Yi}]: ${this.message}`;
      }
    };
  }
  Vi(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(Yi) {
      return Yi ? `${Yi} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Vi(
    "ERR_INVALID_ARG_TYPE",
    function(Yi, Li) {
      return `The "${Yi}" argument must be of type number. Received type ${typeof Li}`;
    },
    TypeError
  ), Vi(
    "ERR_OUT_OF_RANGE",
    function(Yi, Li, zi) {
      let En = `The value of "${Yi}" is out of range.`, ss = zi;
      return Number.isInteger(zi) && Math.abs(zi) > 2 ** 32 ? ss = is(String(zi)) : typeof zi == "bigint" && (ss = String(zi), (zi > BigInt(2) ** BigInt(32) || zi < -(BigInt(2) ** BigInt(32))) && (ss = is(ss)), ss += "n"), En += ` It must be ${Li}. Received ${ss}`, En;
    },
    RangeError
  );
  function is(Yi) {
    let Li = "", zi = Yi.length;
    const En = Yi[0] === "-" ? 1 : 0;
    for (; zi >= En + 4; zi -= 3)
      Li = `_${Yi.slice(zi - 3, zi)}${Li}`;
    return `${Yi.slice(0, zi)}${Li}`;
  }
  function os(Yi, Li, zi) {
    ps(Li, "offset"), (Yi[Li] === void 0 || Yi[Li + zi] === void 0) && ea(Li, Yi.length - (zi + 1));
  }
  function ds(Yi, Li, zi, En, ss, as) {
    if (Yi > zi || Yi < Li) {
      const us = typeof Li == "bigint" ? "n" : "";
      let ua;
      throw Li === 0 || Li === BigInt(0) ? ua = `>= 0${us} and < 2${us} ** ${(as + 1) * 8}${us}` : ua = `>= -(2${us} ** ${(as + 1) * 8 - 1}${us}) and < 2 ** ${(as + 1) * 8 - 1}${us}`, new ji.ERR_OUT_OF_RANGE("value", ua, Yi);
    }
    os(En, ss, as);
  }
  function ps(Yi, Li) {
    if (typeof Yi != "number")
      throw new ji.ERR_INVALID_ARG_TYPE(Li, "number", Yi);
  }
  function ea(Yi, Li, zi) {
    throw Math.floor(Yi) !== Yi ? (ps(Yi, zi), new ji.ERR_OUT_OF_RANGE("offset", "an integer", Yi)) : Li < 0 ? new ji.ERR_BUFFER_OUT_OF_BOUNDS() : new ji.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${Li}`,
      Yi
    );
  }
  const ia = /[^+/0-9A-Za-z-_]/g;
  function hs(Yi) {
    if (Yi = Yi.split("=")[0], Yi = Yi.trim().replace(ia, ""), Yi.length < 2) return "";
    for (; Yi.length % 4 !== 0; )
      Yi = Yi + "=";
    return Yi;
  }
  function fa(Yi, Li) {
    Li = Li || 1 / 0;
    let zi;
    const En = Yi.length;
    let ss = null;
    const as = [];
    for (let us = 0; us < En; ++us) {
      if (zi = Yi.charCodeAt(us), zi > 55295 && zi < 57344) {
        if (!ss) {
          if (zi > 56319) {
            (Li -= 3) > -1 && as.push(239, 191, 189);
            continue;
          } else if (us + 1 === En) {
            (Li -= 3) > -1 && as.push(239, 191, 189);
            continue;
          }
          ss = zi;
          continue;
        }
        if (zi < 56320) {
          (Li -= 3) > -1 && as.push(239, 191, 189), ss = zi;
          continue;
        }
        zi = (ss - 55296 << 10 | zi - 56320) + 65536;
      } else ss && (Li -= 3) > -1 && as.push(239, 191, 189);
      if (ss = null, zi < 128) {
        if ((Li -= 1) < 0) break;
        as.push(zi);
      } else if (zi < 2048) {
        if ((Li -= 2) < 0) break;
        as.push(
          zi >> 6 | 192,
          zi & 63 | 128
        );
      } else if (zi < 65536) {
        if ((Li -= 3) < 0) break;
        as.push(
          zi >> 12 | 224,
          zi >> 6 & 63 | 128,
          zi & 63 | 128
        );
      } else if (zi < 1114112) {
        if ((Li -= 4) < 0) break;
        as.push(
          zi >> 18 | 240,
          zi >> 12 & 63 | 128,
          zi >> 6 & 63 | 128,
          zi & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return as;
  }
  function gs(Yi) {
    const Li = [];
    for (let zi = 0; zi < Yi.length; ++zi)
      Li.push(Yi.charCodeAt(zi) & 255);
    return Li;
  }
  function sa(Yi, Li) {
    let zi, En, ss;
    const as = [];
    for (let us = 0; us < Yi.length && !((Li -= 2) < 0); ++us)
      zi = Yi.charCodeAt(us), En = zi >> 8, ss = zi % 256, as.push(ss), as.push(En);
    return as;
  }
  function aa(Yi) {
    return t.toByteArray(hs(Yi));
  }
  function Ds(Yi, Li, zi, En) {
    let ss;
    for (ss = 0; ss < En && !(ss + zi >= Li.length || ss >= Yi.length); ++ss)
      Li[ss + zi] = Yi[ss];
    return ss;
  }
  function ra(Yi, Li) {
    return Yi instanceof Li || Yi != null && Yi.constructor != null && Yi.constructor.name != null && Yi.constructor.name === Li.name;
  }
  function ca(Yi) {
    return Yi !== Yi;
  }
  const ta = function() {
    const Yi = "0123456789abcdef", Li = new Array(256);
    for (let zi = 0; zi < 16; ++zi) {
      const En = zi * 16;
      for (let ss = 0; ss < 16; ++ss)
        Li[En + ss] = Yi[zi] + Yi[ss];
    }
    return Li;
  }();
  function oa(Yi) {
    return typeof BigInt > "u" ? da : Yi;
  }
  function da() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer$1 = buffer$1.Buffer, Blob$1 = buffer$1.Blob, BlobOptions = buffer$1.BlobOptions, Buffer$1$1 = buffer$1.Buffer, File = buffer$1.File, FileOptions = buffer$1.FileOptions, INSPECT_MAX_BYTES = buffer$1.INSPECT_MAX_BYTES, SlowBuffer = buffer$1.SlowBuffer, TranscodeEncoding = buffer$1.TranscodeEncoding, atob$1 = buffer$1.atob, btoa$1 = buffer$1.btoa, constants$2 = buffer$1.constants, isAscii = buffer$1.isAscii, isUtf8 = buffer$1.isUtf8, kMaxLength = buffer$1.kMaxLength, kStringMaxLength = buffer$1.kStringMaxLength, resolveObjectURL = buffer$1.resolveObjectURL, transcode = buffer$1.transcode, dist = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: Blob$1,
  BlobOptions,
  Buffer: Buffer$1$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob: atob$1,
  btoa: btoa$1,
  constants: constants$2,
  default: Buffer$1,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
var bn$3 = { exports: {} };
const require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(dist);
bn$3.exports;
(function(Ae) {
  (function(t, Me) {
    function Ie(Ai, wi) {
      if (!Ai) throw new Error(wi || "Assertion failed");
    }
    function Pe(Ai, wi) {
      Ai.super_ = wi;
      var Ei = function() {
      };
      Ei.prototype = wi.prototype, Ai.prototype = new Ei(), Ai.prototype.constructor = Ai;
    }
    function Be(Ai, wi, Ei) {
      if (Be.isBN(Ai))
        return Ai;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, Ai !== null && ((wi === "le" || wi === "be") && (Ei = wi, wi = 10), this._init(Ai || 0, wi || 10, Ei || "be"));
    }
    typeof t == "object" ? t.exports = Be : Me.BN = Be, Be.BN = Be, Be.wordSize = 26;
    var Te;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Te = window.Buffer : Te = require$$0$3.Buffer;
    } catch {
    }
    Be.isBN = function(wi) {
      return wi instanceof Be ? !0 : wi !== null && typeof wi == "object" && wi.constructor.wordSize === Be.wordSize && Array.isArray(wi.words);
    }, Be.max = function(wi, Ei) {
      return wi.cmp(Ei) > 0 ? wi : Ei;
    }, Be.min = function(wi, Ei) {
      return wi.cmp(Ei) < 0 ? wi : Ei;
    }, Be.prototype._init = function(wi, Ei, Ti) {
      if (typeof wi == "number")
        return this._initNumber(wi, Ei, Ti);
      if (typeof wi == "object")
        return this._initArray(wi, Ei, Ti);
      Ei === "hex" && (Ei = 16), Ie(Ei === (Ei | 0) && Ei >= 2 && Ei <= 36), wi = wi.toString().replace(/\s+/g, "");
      var Pi = 0;
      wi[0] === "-" && (Pi++, this.negative = 1), Pi < wi.length && (Ei === 16 ? this._parseHex(wi, Pi, Ti) : (this._parseBase(wi, Ei, Pi), Ti === "le" && this._initArray(this.toArray(), Ei, Ti)));
    }, Be.prototype._initNumber = function(wi, Ei, Ti) {
      wi < 0 && (this.negative = 1, wi = -wi), wi < 67108864 ? (this.words = [wi & 67108863], this.length = 1) : wi < 4503599627370496 ? (this.words = [
        wi & 67108863,
        wi / 67108864 & 67108863
      ], this.length = 2) : (Ie(wi < 9007199254740992), this.words = [
        wi & 67108863,
        wi / 67108864 & 67108863,
        1
      ], this.length = 3), Ti === "le" && this._initArray(this.toArray(), Ei, Ti);
    }, Be.prototype._initArray = function(wi, Ei, Ti) {
      if (Ie(typeof wi.length == "number"), wi.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(wi.length / 3), this.words = new Array(this.length);
      for (var Pi = 0; Pi < this.length; Pi++)
        this.words[Pi] = 0;
      var qi, Oi, Si = 0;
      if (Ti === "be")
        for (Pi = wi.length - 1, qi = 0; Pi >= 0; Pi -= 3)
          Oi = wi[Pi] | wi[Pi - 1] << 8 | wi[Pi - 2] << 16, this.words[qi] |= Oi << Si & 67108863, this.words[qi + 1] = Oi >>> 26 - Si & 67108863, Si += 24, Si >= 26 && (Si -= 26, qi++);
      else if (Ti === "le")
        for (Pi = 0, qi = 0; Pi < wi.length; Pi += 3)
          Oi = wi[Pi] | wi[Pi + 1] << 8 | wi[Pi + 2] << 16, this.words[qi] |= Oi << Si & 67108863, this.words[qi + 1] = Oi >>> 26 - Si & 67108863, Si += 24, Si >= 26 && (Si -= 26, qi++);
      return this._strip();
    };
    function je(Ai, wi) {
      var Ei = Ai.charCodeAt(wi);
      if (Ei >= 48 && Ei <= 57)
        return Ei - 48;
      if (Ei >= 65 && Ei <= 70)
        return Ei - 55;
      if (Ei >= 97 && Ei <= 102)
        return Ei - 87;
      Ie(!1, "Invalid character in " + Ai);
    }
    function Ve(Ai, wi, Ei) {
      var Ti = je(Ai, Ei);
      return Ei - 1 >= wi && (Ti |= je(Ai, Ei - 1) << 4), Ti;
    }
    Be.prototype._parseHex = function(wi, Ei, Ti) {
      this.length = Math.ceil((wi.length - Ei) / 6), this.words = new Array(this.length);
      for (var Pi = 0; Pi < this.length; Pi++)
        this.words[Pi] = 0;
      var qi = 0, Oi = 0, Si;
      if (Ti === "be")
        for (Pi = wi.length - 1; Pi >= Ei; Pi -= 2)
          Si = Ve(wi, Ei, Pi) << qi, this.words[Oi] |= Si & 67108863, qi >= 18 ? (qi -= 18, Oi += 1, this.words[Oi] |= Si >>> 26) : qi += 8;
      else {
        var Ni = wi.length - Ei;
        for (Pi = Ni % 2 === 0 ? Ei + 1 : Ei; Pi < wi.length; Pi += 2)
          Si = Ve(wi, Ei, Pi) << qi, this.words[Oi] |= Si & 67108863, qi >= 18 ? (qi -= 18, Oi += 1, this.words[Oi] |= Si >>> 26) : qi += 8;
      }
      this._strip();
    };
    function fi(Ai, wi, Ei, Ti) {
      for (var Pi = 0, qi = 0, Oi = Math.min(Ai.length, Ei), Si = wi; Si < Oi; Si++) {
        var Ni = Ai.charCodeAt(Si) - 48;
        Pi *= Ti, Ni >= 49 ? qi = Ni - 49 + 10 : Ni >= 17 ? qi = Ni - 17 + 10 : qi = Ni, Ie(Ni >= 0 && qi < Ti, "Invalid character"), Pi += qi;
      }
      return Pi;
    }
    Be.prototype._parseBase = function(wi, Ei, Ti) {
      this.words = [0], this.length = 1;
      for (var Pi = 0, qi = 1; qi <= 67108863; qi *= Ei)
        Pi++;
      Pi--, qi = qi / Ei | 0;
      for (var Oi = wi.length - Ti, Si = Oi % Pi, Ni = Math.min(Oi, Oi - Si) + Ti, xi = 0, Wi = Ti; Wi < Ni; Wi += Pi)
        xi = fi(wi, Wi, Wi + Pi, Ei), this.imuln(qi), this.words[0] + xi < 67108864 ? this.words[0] += xi : this._iaddn(xi);
      if (Si !== 0) {
        var ts = 1;
        for (xi = fi(wi, Wi, wi.length, Ei), Wi = 0; Wi < Si; Wi++)
          ts *= Ei;
        this.imuln(ts), this.words[0] + xi < 67108864 ? this.words[0] += xi : this._iaddn(xi);
      }
      this._strip();
    }, Be.prototype.copy = function(wi) {
      wi.words = new Array(this.length);
      for (var Ei = 0; Ei < this.length; Ei++)
        wi.words[Ei] = this.words[Ei];
      wi.length = this.length, wi.negative = this.negative, wi.red = this.red;
    };
    function Ue(Ai, wi) {
      Ai.words = wi.words, Ai.length = wi.length, Ai.negative = wi.negative, Ai.red = wi.red;
    }
    if (Be.prototype._move = function(wi) {
      Ue(wi, this);
    }, Be.prototype.clone = function() {
      var wi = new Be(null);
      return this.copy(wi), wi;
    }, Be.prototype._expand = function(wi) {
      for (; this.length < wi; )
        this.words[this.length++] = 0;
      return this;
    }, Be.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, Be.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        Be.prototype[Symbol.for("nodejs.util.inspect.custom")] = bi;
      } catch {
        Be.prototype.inspect = bi;
      }
    else
      Be.prototype.inspect = bi;
    function bi() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var vi = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], mi = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], _i = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    Be.prototype.toString = function(wi, Ei) {
      wi = wi || 10, Ei = Ei | 0 || 1;
      var Ti;
      if (wi === 16 || wi === "hex") {
        Ti = "";
        for (var Pi = 0, qi = 0, Oi = 0; Oi < this.length; Oi++) {
          var Si = this.words[Oi], Ni = ((Si << Pi | qi) & 16777215).toString(16);
          qi = Si >>> 24 - Pi & 16777215, Pi += 2, Pi >= 26 && (Pi -= 26, Oi--), qi !== 0 || Oi !== this.length - 1 ? Ti = vi[6 - Ni.length] + Ni + Ti : Ti = Ni + Ti;
        }
        for (qi !== 0 && (Ti = qi.toString(16) + Ti); Ti.length % Ei !== 0; )
          Ti = "0" + Ti;
        return this.negative !== 0 && (Ti = "-" + Ti), Ti;
      }
      if (wi === (wi | 0) && wi >= 2 && wi <= 36) {
        var xi = mi[wi], Wi = _i[wi];
        Ti = "";
        var ts = this.clone();
        for (ts.negative = 0; !ts.isZero(); ) {
          var Ki = ts.modrn(Wi).toString(wi);
          ts = ts.idivn(Wi), ts.isZero() ? Ti = Ki + Ti : Ti = vi[xi - Ki.length] + Ki + Ti;
        }
        for (this.isZero() && (Ti = "0" + Ti); Ti.length % Ei !== 0; )
          Ti = "0" + Ti;
        return this.negative !== 0 && (Ti = "-" + Ti), Ti;
      }
      Ie(!1, "Base should be between 2 and 36");
    }, Be.prototype.toNumber = function() {
      var wi = this.words[0];
      return this.length === 2 ? wi += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? wi += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && Ie(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -wi : wi;
    }, Be.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, Te && (Be.prototype.toBuffer = function(wi, Ei) {
      return this.toArrayLike(Te, wi, Ei);
    }), Be.prototype.toArray = function(wi, Ei) {
      return this.toArrayLike(Array, wi, Ei);
    };
    var $i = function(wi, Ei) {
      return wi.allocUnsafe ? wi.allocUnsafe(Ei) : new wi(Ei);
    };
    Be.prototype.toArrayLike = function(wi, Ei, Ti) {
      this._strip();
      var Pi = this.byteLength(), qi = Ti || Math.max(1, Pi);
      Ie(Pi <= qi, "byte array longer than desired length"), Ie(qi > 0, "Requested array length <= 0");
      var Oi = $i(wi, qi), Si = Ei === "le" ? "LE" : "BE";
      return this["_toArrayLike" + Si](Oi, Pi), Oi;
    }, Be.prototype._toArrayLikeLE = function(wi, Ei) {
      for (var Ti = 0, Pi = 0, qi = 0, Oi = 0; qi < this.length; qi++) {
        var Si = this.words[qi] << Oi | Pi;
        wi[Ti++] = Si & 255, Ti < wi.length && (wi[Ti++] = Si >> 8 & 255), Ti < wi.length && (wi[Ti++] = Si >> 16 & 255), Oi === 6 ? (Ti < wi.length && (wi[Ti++] = Si >> 24 & 255), Pi = 0, Oi = 0) : (Pi = Si >>> 24, Oi += 2);
      }
      if (Ti < wi.length)
        for (wi[Ti++] = Pi; Ti < wi.length; )
          wi[Ti++] = 0;
    }, Be.prototype._toArrayLikeBE = function(wi, Ei) {
      for (var Ti = wi.length - 1, Pi = 0, qi = 0, Oi = 0; qi < this.length; qi++) {
        var Si = this.words[qi] << Oi | Pi;
        wi[Ti--] = Si & 255, Ti >= 0 && (wi[Ti--] = Si >> 8 & 255), Ti >= 0 && (wi[Ti--] = Si >> 16 & 255), Oi === 6 ? (Ti >= 0 && (wi[Ti--] = Si >> 24 & 255), Pi = 0, Oi = 0) : (Pi = Si >>> 24, Oi += 2);
      }
      if (Ti >= 0)
        for (wi[Ti--] = Pi; Ti >= 0; )
          wi[Ti--] = 0;
    }, Math.clz32 ? Be.prototype._countBits = function(wi) {
      return 32 - Math.clz32(wi);
    } : Be.prototype._countBits = function(wi) {
      var Ei = wi, Ti = 0;
      return Ei >= 4096 && (Ti += 13, Ei >>>= 13), Ei >= 64 && (Ti += 7, Ei >>>= 7), Ei >= 8 && (Ti += 4, Ei >>>= 4), Ei >= 2 && (Ti += 2, Ei >>>= 2), Ti + Ei;
    }, Be.prototype._zeroBits = function(wi) {
      if (wi === 0) return 26;
      var Ei = wi, Ti = 0;
      return Ei & 8191 || (Ti += 13, Ei >>>= 13), Ei & 127 || (Ti += 7, Ei >>>= 7), Ei & 15 || (Ti += 4, Ei >>>= 4), Ei & 3 || (Ti += 2, Ei >>>= 2), Ei & 1 || Ti++, Ti;
    }, Be.prototype.bitLength = function() {
      var wi = this.words[this.length - 1], Ei = this._countBits(wi);
      return (this.length - 1) * 26 + Ei;
    };
    function Ci(Ai) {
      for (var wi = new Array(Ai.bitLength()), Ei = 0; Ei < wi.length; Ei++) {
        var Ti = Ei / 26 | 0, Pi = Ei % 26;
        wi[Ei] = Ai.words[Ti] >>> Pi & 1;
      }
      return wi;
    }
    Be.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var wi = 0, Ei = 0; Ei < this.length; Ei++) {
        var Ti = this._zeroBits(this.words[Ei]);
        if (wi += Ti, Ti !== 26) break;
      }
      return wi;
    }, Be.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Be.prototype.toTwos = function(wi) {
      return this.negative !== 0 ? this.abs().inotn(wi).iaddn(1) : this.clone();
    }, Be.prototype.fromTwos = function(wi) {
      return this.testn(wi - 1) ? this.notn(wi).iaddn(1).ineg() : this.clone();
    }, Be.prototype.isNeg = function() {
      return this.negative !== 0;
    }, Be.prototype.neg = function() {
      return this.clone().ineg();
    }, Be.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, Be.prototype.iuor = function(wi) {
      for (; this.length < wi.length; )
        this.words[this.length++] = 0;
      for (var Ei = 0; Ei < wi.length; Ei++)
        this.words[Ei] = this.words[Ei] | wi.words[Ei];
      return this._strip();
    }, Be.prototype.ior = function(wi) {
      return Ie((this.negative | wi.negative) === 0), this.iuor(wi);
    }, Be.prototype.or = function(wi) {
      return this.length > wi.length ? this.clone().ior(wi) : wi.clone().ior(this);
    }, Be.prototype.uor = function(wi) {
      return this.length > wi.length ? this.clone().iuor(wi) : wi.clone().iuor(this);
    }, Be.prototype.iuand = function(wi) {
      var Ei;
      this.length > wi.length ? Ei = wi : Ei = this;
      for (var Ti = 0; Ti < Ei.length; Ti++)
        this.words[Ti] = this.words[Ti] & wi.words[Ti];
      return this.length = Ei.length, this._strip();
    }, Be.prototype.iand = function(wi) {
      return Ie((this.negative | wi.negative) === 0), this.iuand(wi);
    }, Be.prototype.and = function(wi) {
      return this.length > wi.length ? this.clone().iand(wi) : wi.clone().iand(this);
    }, Be.prototype.uand = function(wi) {
      return this.length > wi.length ? this.clone().iuand(wi) : wi.clone().iuand(this);
    }, Be.prototype.iuxor = function(wi) {
      var Ei, Ti;
      this.length > wi.length ? (Ei = this, Ti = wi) : (Ei = wi, Ti = this);
      for (var Pi = 0; Pi < Ti.length; Pi++)
        this.words[Pi] = Ei.words[Pi] ^ Ti.words[Pi];
      if (this !== Ei)
        for (; Pi < Ei.length; Pi++)
          this.words[Pi] = Ei.words[Pi];
      return this.length = Ei.length, this._strip();
    }, Be.prototype.ixor = function(wi) {
      return Ie((this.negative | wi.negative) === 0), this.iuxor(wi);
    }, Be.prototype.xor = function(wi) {
      return this.length > wi.length ? this.clone().ixor(wi) : wi.clone().ixor(this);
    }, Be.prototype.uxor = function(wi) {
      return this.length > wi.length ? this.clone().iuxor(wi) : wi.clone().iuxor(this);
    }, Be.prototype.inotn = function(wi) {
      Ie(typeof wi == "number" && wi >= 0);
      var Ei = Math.ceil(wi / 26) | 0, Ti = wi % 26;
      this._expand(Ei), Ti > 0 && Ei--;
      for (var Pi = 0; Pi < Ei; Pi++)
        this.words[Pi] = ~this.words[Pi] & 67108863;
      return Ti > 0 && (this.words[Pi] = ~this.words[Pi] & 67108863 >> 26 - Ti), this._strip();
    }, Be.prototype.notn = function(wi) {
      return this.clone().inotn(wi);
    }, Be.prototype.setn = function(wi, Ei) {
      Ie(typeof wi == "number" && wi >= 0);
      var Ti = wi / 26 | 0, Pi = wi % 26;
      return this._expand(Ti + 1), Ei ? this.words[Ti] = this.words[Ti] | 1 << Pi : this.words[Ti] = this.words[Ti] & ~(1 << Pi), this._strip();
    }, Be.prototype.iadd = function(wi) {
      var Ei;
      if (this.negative !== 0 && wi.negative === 0)
        return this.negative = 0, Ei = this.isub(wi), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && wi.negative !== 0)
        return wi.negative = 0, Ei = this.isub(wi), wi.negative = 1, Ei._normSign();
      var Ti, Pi;
      this.length > wi.length ? (Ti = this, Pi = wi) : (Ti = wi, Pi = this);
      for (var qi = 0, Oi = 0; Oi < Pi.length; Oi++)
        Ei = (Ti.words[Oi] | 0) + (Pi.words[Oi] | 0) + qi, this.words[Oi] = Ei & 67108863, qi = Ei >>> 26;
      for (; qi !== 0 && Oi < Ti.length; Oi++)
        Ei = (Ti.words[Oi] | 0) + qi, this.words[Oi] = Ei & 67108863, qi = Ei >>> 26;
      if (this.length = Ti.length, qi !== 0)
        this.words[this.length] = qi, this.length++;
      else if (Ti !== this)
        for (; Oi < Ti.length; Oi++)
          this.words[Oi] = Ti.words[Oi];
      return this;
    }, Be.prototype.add = function(wi) {
      var Ei;
      return wi.negative !== 0 && this.negative === 0 ? (wi.negative = 0, Ei = this.sub(wi), wi.negative ^= 1, Ei) : wi.negative === 0 && this.negative !== 0 ? (this.negative = 0, Ei = wi.sub(this), this.negative = 1, Ei) : this.length > wi.length ? this.clone().iadd(wi) : wi.clone().iadd(this);
    }, Be.prototype.isub = function(wi) {
      if (wi.negative !== 0) {
        wi.negative = 0;
        var Ei = this.iadd(wi);
        return wi.negative = 1, Ei._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(wi), this.negative = 1, this._normSign();
      var Ti = this.cmp(wi);
      if (Ti === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var Pi, qi;
      Ti > 0 ? (Pi = this, qi = wi) : (Pi = wi, qi = this);
      for (var Oi = 0, Si = 0; Si < qi.length; Si++)
        Ei = (Pi.words[Si] | 0) - (qi.words[Si] | 0) + Oi, Oi = Ei >> 26, this.words[Si] = Ei & 67108863;
      for (; Oi !== 0 && Si < Pi.length; Si++)
        Ei = (Pi.words[Si] | 0) + Oi, Oi = Ei >> 26, this.words[Si] = Ei & 67108863;
      if (Oi === 0 && Si < Pi.length && Pi !== this)
        for (; Si < Pi.length; Si++)
          this.words[Si] = Pi.words[Si];
      return this.length = Math.max(this.length, Si), Pi !== this && (this.negative = 1), this._strip();
    }, Be.prototype.sub = function(wi) {
      return this.clone().isub(wi);
    };
    function Ui(Ai, wi, Ei) {
      Ei.negative = wi.negative ^ Ai.negative;
      var Ti = Ai.length + wi.length | 0;
      Ei.length = Ti, Ti = Ti - 1 | 0;
      var Pi = Ai.words[0] | 0, qi = wi.words[0] | 0, Oi = Pi * qi, Si = Oi & 67108863, Ni = Oi / 67108864 | 0;
      Ei.words[0] = Si;
      for (var xi = 1; xi < Ti; xi++) {
        for (var Wi = Ni >>> 26, ts = Ni & 67108863, Ki = Math.min(xi, wi.length - 1), fn = Math.max(0, xi - Ai.length + 1); fn <= Ki; fn++) {
          var Ii = xi - fn | 0;
          Pi = Ai.words[Ii] | 0, qi = wi.words[fn] | 0, Oi = Pi * qi + ts, Wi += Oi / 67108864 | 0, ts = Oi & 67108863;
        }
        Ei.words[xi] = ts | 0, Ni = Wi | 0;
      }
      return Ni !== 0 ? Ei.words[xi] = Ni | 0 : Ei.length--, Ei._strip();
    }
    var ki = function(wi, Ei, Ti) {
      var Pi = wi.words, qi = Ei.words, Oi = Ti.words, Si = 0, Ni, xi, Wi, ts = Pi[0] | 0, Ki = ts & 8191, fn = ts >>> 13, Ii = Pi[1] | 0, Fi = Ii & 8191, Gi = Ii >>> 13, Ri = Pi[2] | 0, ji = Ri & 8191, Vi = Ri >>> 13, is = Pi[3] | 0, os = is & 8191, ds = is >>> 13, ps = Pi[4] | 0, ea = ps & 8191, ia = ps >>> 13, hs = Pi[5] | 0, fa = hs & 8191, gs = hs >>> 13, sa = Pi[6] | 0, aa = sa & 8191, Ds = sa >>> 13, ra = Pi[7] | 0, ca = ra & 8191, ta = ra >>> 13, oa = Pi[8] | 0, da = oa & 8191, Yi = oa >>> 13, Li = Pi[9] | 0, zi = Li & 8191, En = Li >>> 13, ss = qi[0] | 0, as = ss & 8191, us = ss >>> 13, ua = qi[1] | 0, ma = ua & 8191, na = ua >>> 13, wa = qi[2] | 0, ya = wa & 8191, $a = wa >>> 13, Sa = qi[3] | 0, Ea = Sa & 8191, la = Sa >>> 13, xa = qi[4] | 0, Aa = xa & 8191, ha = xa >>> 13, Ia = qi[5] | 0, Da = Ia & 8191, va = Ia >>> 13, Pa = qi[6] | 0, Ba = Pa & 8191, pa = Pa >>> 13, Ra = qi[7] | 0, _a = Ra & 8191, ga = Ra >>> 13, Ca = qi[8] | 0, Na = Ca & 8191, Ma = Ca >>> 13, Fa = qi[9] | 0, qa = Fa & 8191, Ta = Fa >>> 13;
      Ti.negative = wi.negative ^ Ei.negative, Ti.length = 19, Ni = Math.imul(Ki, as), xi = Math.imul(Ki, us), xi = xi + Math.imul(fn, as) | 0, Wi = Math.imul(fn, us);
      var Va = (Si + Ni | 0) + ((xi & 8191) << 13) | 0;
      Si = (Wi + (xi >>> 13) | 0) + (Va >>> 26) | 0, Va &= 67108863, Ni = Math.imul(Fi, as), xi = Math.imul(Fi, us), xi = xi + Math.imul(Gi, as) | 0, Wi = Math.imul(Gi, us), Ni = Ni + Math.imul(Ki, ma) | 0, xi = xi + Math.imul(Ki, na) | 0, xi = xi + Math.imul(fn, ma) | 0, Wi = Wi + Math.imul(fn, na) | 0;
      var Ga = (Si + Ni | 0) + ((xi & 8191) << 13) | 0;
      Si = (Wi + (xi >>> 13) | 0) + (Ga >>> 26) | 0, Ga &= 67108863, Ni = Math.imul(ji, as), xi = Math.imul(ji, us), xi = xi + Math.imul(Vi, as) | 0, Wi = Math.imul(Vi, us), Ni = Ni + Math.imul(Fi, ma) | 0, xi = xi + Math.imul(Fi, na) | 0, xi = xi + Math.imul(Gi, ma) | 0, Wi = Wi + Math.imul(Gi, na) | 0, Ni = Ni + Math.imul(Ki, ya) | 0, xi = xi + Math.imul(Ki, $a) | 0, xi = xi + Math.imul(fn, ya) | 0, Wi = Wi + Math.imul(fn, $a) | 0;
      var Ja = (Si + Ni | 0) + ((xi & 8191) << 13) | 0;
      Si = (Wi + (xi >>> 13) | 0) + (Ja >>> 26) | 0, Ja &= 67108863, Ni = Math.imul(os, as), xi = Math.imul(os, us), xi = xi + Math.imul(ds, as) | 0, Wi = Math.imul(ds, us), Ni = Ni + Math.imul(ji, ma) | 0, xi = xi + Math.imul(ji, na) | 0, xi = xi + Math.imul(Vi, ma) | 0, Wi = Wi + Math.imul(Vi, na) | 0, Ni = Ni + Math.imul(Fi, ya) | 0, xi = xi + Math.imul(Fi, $a) | 0, xi = xi + Math.imul(Gi, ya) | 0, Wi = Wi + Math.imul(Gi, $a) | 0, Ni = Ni + Math.imul(Ki, Ea) | 0, xi = xi + Math.imul(Ki, la) | 0, xi = xi + Math.imul(fn, Ea) | 0, Wi = Wi + Math.imul(fn, la) | 0;
      var Xa = (Si + Ni | 0) + ((xi & 8191) << 13) | 0;
      Si = (Wi + (xi >>> 13) | 0) + (Xa >>> 26) | 0, Xa &= 67108863, Ni = Math.imul(ea, as), xi = Math.imul(ea, us), xi = xi + Math.imul(ia, as) | 0, Wi = Math.imul(ia, us), Ni = Ni + Math.imul(os, ma) | 0, xi = xi + Math.imul(os, na) | 0, xi = xi + Math.imul(ds, ma) | 0, Wi = Wi + Math.imul(ds, na) | 0, Ni = Ni + Math.imul(ji, ya) | 0, xi = xi + Math.imul(ji, $a) | 0, xi = xi + Math.imul(Vi, ya) | 0, Wi = Wi + Math.imul(Vi, $a) | 0, Ni = Ni + Math.imul(Fi, Ea) | 0, xi = xi + Math.imul(Fi, la) | 0, xi = xi + Math.imul(Gi, Ea) | 0, Wi = Wi + Math.imul(Gi, la) | 0, Ni = Ni + Math.imul(Ki, Aa) | 0, xi = xi + Math.imul(Ki, ha) | 0, xi = xi + Math.imul(fn, Aa) | 0, Wi = Wi + Math.imul(fn, ha) | 0;
      var ja = (Si + Ni | 0) + ((xi & 8191) << 13) | 0;
      Si = (Wi + (xi >>> 13) | 0) + (ja >>> 26) | 0, ja &= 67108863, Ni = Math.imul(fa, as), xi = Math.imul(fa, us), xi = xi + Math.imul(gs, as) | 0, Wi = Math.imul(gs, us), Ni = Ni + Math.imul(ea, ma) | 0, xi = xi + Math.imul(ea, na) | 0, xi = xi + Math.imul(ia, ma) | 0, Wi = Wi + Math.imul(ia, na) | 0, Ni = Ni + Math.imul(os, ya) | 0, xi = xi + Math.imul(os, $a) | 0, xi = xi + Math.imul(ds, ya) | 0, Wi = Wi + Math.imul(ds, $a) | 0, Ni = Ni + Math.imul(ji, Ea) | 0, xi = xi + Math.imul(ji, la) | 0, xi = xi + Math.imul(Vi, Ea) | 0, Wi = Wi + Math.imul(Vi, la) | 0, Ni = Ni + Math.imul(Fi, Aa) | 0, xi = xi + Math.imul(Fi, ha) | 0, xi = xi + Math.imul(Gi, Aa) | 0, Wi = Wi + Math.imul(Gi, ha) | 0, Ni = Ni + Math.imul(Ki, Da) | 0, xi = xi + Math.imul(Ki, va) | 0, xi = xi + Math.imul(fn, Da) | 0, Wi = Wi + Math.imul(fn, va) | 0;
      var go = (Si + Ni | 0) + ((xi & 8191) << 13) | 0;
      Si = (Wi + (xi >>> 13) | 0) + (go >>> 26) | 0, go &= 67108863, Ni = Math.imul(aa, as), xi = Math.imul(aa, us), xi = xi + Math.imul(Ds, as) | 0, Wi = Math.imul(Ds, us), Ni = Ni + Math.imul(fa, ma) | 0, xi = xi + Math.imul(fa, na) | 0, xi = xi + Math.imul(gs, ma) | 0, Wi = Wi + Math.imul(gs, na) | 0, Ni = Ni + Math.imul(ea, ya) | 0, xi = xi + Math.imul(ea, $a) | 0, xi = xi + Math.imul(ia, ya) | 0, Wi = Wi + Math.imul(ia, $a) | 0, Ni = Ni + Math.imul(os, Ea) | 0, xi = xi + Math.imul(os, la) | 0, xi = xi + Math.imul(ds, Ea) | 0, Wi = Wi + Math.imul(ds, la) | 0, Ni = Ni + Math.imul(ji, Aa) | 0, xi = xi + Math.imul(ji, ha) | 0, xi = xi + Math.imul(Vi, Aa) | 0, Wi = Wi + Math.imul(Vi, ha) | 0, Ni = Ni + Math.imul(Fi, Da) | 0, xi = xi + Math.imul(Fi, va) | 0, xi = xi + Math.imul(Gi, Da) | 0, Wi = Wi + Math.imul(Gi, va) | 0, Ni = Ni + Math.imul(Ki, Ba) | 0, xi = xi + Math.imul(Ki, pa) | 0, xi = xi + Math.imul(fn, Ba) | 0, Wi = Wi + Math.imul(fn, pa) | 0;
      var wo = (Si + Ni | 0) + ((xi & 8191) << 13) | 0;
      Si = (Wi + (xi >>> 13) | 0) + (wo >>> 26) | 0, wo &= 67108863, Ni = Math.imul(ca, as), xi = Math.imul(ca, us), xi = xi + Math.imul(ta, as) | 0, Wi = Math.imul(ta, us), Ni = Ni + Math.imul(aa, ma) | 0, xi = xi + Math.imul(aa, na) | 0, xi = xi + Math.imul(Ds, ma) | 0, Wi = Wi + Math.imul(Ds, na) | 0, Ni = Ni + Math.imul(fa, ya) | 0, xi = xi + Math.imul(fa, $a) | 0, xi = xi + Math.imul(gs, ya) | 0, Wi = Wi + Math.imul(gs, $a) | 0, Ni = Ni + Math.imul(ea, Ea) | 0, xi = xi + Math.imul(ea, la) | 0, xi = xi + Math.imul(ia, Ea) | 0, Wi = Wi + Math.imul(ia, la) | 0, Ni = Ni + Math.imul(os, Aa) | 0, xi = xi + Math.imul(os, ha) | 0, xi = xi + Math.imul(ds, Aa) | 0, Wi = Wi + Math.imul(ds, ha) | 0, Ni = Ni + Math.imul(ji, Da) | 0, xi = xi + Math.imul(ji, va) | 0, xi = xi + Math.imul(Vi, Da) | 0, Wi = Wi + Math.imul(Vi, va) | 0, Ni = Ni + Math.imul(Fi, Ba) | 0, xi = xi + Math.imul(Fi, pa) | 0, xi = xi + Math.imul(Gi, Ba) | 0, Wi = Wi + Math.imul(Gi, pa) | 0, Ni = Ni + Math.imul(Ki, _a) | 0, xi = xi + Math.imul(Ki, ga) | 0, xi = xi + Math.imul(fn, _a) | 0, Wi = Wi + Math.imul(fn, ga) | 0;
      var _o = (Si + Ni | 0) + ((xi & 8191) << 13) | 0;
      Si = (Wi + (xi >>> 13) | 0) + (_o >>> 26) | 0, _o &= 67108863, Ni = Math.imul(da, as), xi = Math.imul(da, us), xi = xi + Math.imul(Yi, as) | 0, Wi = Math.imul(Yi, us), Ni = Ni + Math.imul(ca, ma) | 0, xi = xi + Math.imul(ca, na) | 0, xi = xi + Math.imul(ta, ma) | 0, Wi = Wi + Math.imul(ta, na) | 0, Ni = Ni + Math.imul(aa, ya) | 0, xi = xi + Math.imul(aa, $a) | 0, xi = xi + Math.imul(Ds, ya) | 0, Wi = Wi + Math.imul(Ds, $a) | 0, Ni = Ni + Math.imul(fa, Ea) | 0, xi = xi + Math.imul(fa, la) | 0, xi = xi + Math.imul(gs, Ea) | 0, Wi = Wi + Math.imul(gs, la) | 0, Ni = Ni + Math.imul(ea, Aa) | 0, xi = xi + Math.imul(ea, ha) | 0, xi = xi + Math.imul(ia, Aa) | 0, Wi = Wi + Math.imul(ia, ha) | 0, Ni = Ni + Math.imul(os, Da) | 0, xi = xi + Math.imul(os, va) | 0, xi = xi + Math.imul(ds, Da) | 0, Wi = Wi + Math.imul(ds, va) | 0, Ni = Ni + Math.imul(ji, Ba) | 0, xi = xi + Math.imul(ji, pa) | 0, xi = xi + Math.imul(Vi, Ba) | 0, Wi = Wi + Math.imul(Vi, pa) | 0, Ni = Ni + Math.imul(Fi, _a) | 0, xi = xi + Math.imul(Fi, ga) | 0, xi = xi + Math.imul(Gi, _a) | 0, Wi = Wi + Math.imul(Gi, ga) | 0, Ni = Ni + Math.imul(Ki, Na) | 0, xi = xi + Math.imul(Ki, Ma) | 0, xi = xi + Math.imul(fn, Na) | 0, Wi = Wi + Math.imul(fn, Ma) | 0;
      var $o = (Si + Ni | 0) + ((xi & 8191) << 13) | 0;
      Si = (Wi + (xi >>> 13) | 0) + ($o >>> 26) | 0, $o &= 67108863, Ni = Math.imul(zi, as), xi = Math.imul(zi, us), xi = xi + Math.imul(En, as) | 0, Wi = Math.imul(En, us), Ni = Ni + Math.imul(da, ma) | 0, xi = xi + Math.imul(da, na) | 0, xi = xi + Math.imul(Yi, ma) | 0, Wi = Wi + Math.imul(Yi, na) | 0, Ni = Ni + Math.imul(ca, ya) | 0, xi = xi + Math.imul(ca, $a) | 0, xi = xi + Math.imul(ta, ya) | 0, Wi = Wi + Math.imul(ta, $a) | 0, Ni = Ni + Math.imul(aa, Ea) | 0, xi = xi + Math.imul(aa, la) | 0, xi = xi + Math.imul(Ds, Ea) | 0, Wi = Wi + Math.imul(Ds, la) | 0, Ni = Ni + Math.imul(fa, Aa) | 0, xi = xi + Math.imul(fa, ha) | 0, xi = xi + Math.imul(gs, Aa) | 0, Wi = Wi + Math.imul(gs, ha) | 0, Ni = Ni + Math.imul(ea, Da) | 0, xi = xi + Math.imul(ea, va) | 0, xi = xi + Math.imul(ia, Da) | 0, Wi = Wi + Math.imul(ia, va) | 0, Ni = Ni + Math.imul(os, Ba) | 0, xi = xi + Math.imul(os, pa) | 0, xi = xi + Math.imul(ds, Ba) | 0, Wi = Wi + Math.imul(ds, pa) | 0, Ni = Ni + Math.imul(ji, _a) | 0, xi = xi + Math.imul(ji, ga) | 0, xi = xi + Math.imul(Vi, _a) | 0, Wi = Wi + Math.imul(Vi, ga) | 0, Ni = Ni + Math.imul(Fi, Na) | 0, xi = xi + Math.imul(Fi, Ma) | 0, xi = xi + Math.imul(Gi, Na) | 0, Wi = Wi + Math.imul(Gi, Ma) | 0, Ni = Ni + Math.imul(Ki, qa) | 0, xi = xi + Math.imul(Ki, Ta) | 0, xi = xi + Math.imul(fn, qa) | 0, Wi = Wi + Math.imul(fn, Ta) | 0;
      var Eo = (Si + Ni | 0) + ((xi & 8191) << 13) | 0;
      Si = (Wi + (xi >>> 13) | 0) + (Eo >>> 26) | 0, Eo &= 67108863, Ni = Math.imul(zi, ma), xi = Math.imul(zi, na), xi = xi + Math.imul(En, ma) | 0, Wi = Math.imul(En, na), Ni = Ni + Math.imul(da, ya) | 0, xi = xi + Math.imul(da, $a) | 0, xi = xi + Math.imul(Yi, ya) | 0, Wi = Wi + Math.imul(Yi, $a) | 0, Ni = Ni + Math.imul(ca, Ea) | 0, xi = xi + Math.imul(ca, la) | 0, xi = xi + Math.imul(ta, Ea) | 0, Wi = Wi + Math.imul(ta, la) | 0, Ni = Ni + Math.imul(aa, Aa) | 0, xi = xi + Math.imul(aa, ha) | 0, xi = xi + Math.imul(Ds, Aa) | 0, Wi = Wi + Math.imul(Ds, ha) | 0, Ni = Ni + Math.imul(fa, Da) | 0, xi = xi + Math.imul(fa, va) | 0, xi = xi + Math.imul(gs, Da) | 0, Wi = Wi + Math.imul(gs, va) | 0, Ni = Ni + Math.imul(ea, Ba) | 0, xi = xi + Math.imul(ea, pa) | 0, xi = xi + Math.imul(ia, Ba) | 0, Wi = Wi + Math.imul(ia, pa) | 0, Ni = Ni + Math.imul(os, _a) | 0, xi = xi + Math.imul(os, ga) | 0, xi = xi + Math.imul(ds, _a) | 0, Wi = Wi + Math.imul(ds, ga) | 0, Ni = Ni + Math.imul(ji, Na) | 0, xi = xi + Math.imul(ji, Ma) | 0, xi = xi + Math.imul(Vi, Na) | 0, Wi = Wi + Math.imul(Vi, Ma) | 0, Ni = Ni + Math.imul(Fi, qa) | 0, xi = xi + Math.imul(Fi, Ta) | 0, xi = xi + Math.imul(Gi, qa) | 0, Wi = Wi + Math.imul(Gi, Ta) | 0;
      var Za = (Si + Ni | 0) + ((xi & 8191) << 13) | 0;
      Si = (Wi + (xi >>> 13) | 0) + (Za >>> 26) | 0, Za &= 67108863, Ni = Math.imul(zi, ya), xi = Math.imul(zi, $a), xi = xi + Math.imul(En, ya) | 0, Wi = Math.imul(En, $a), Ni = Ni + Math.imul(da, Ea) | 0, xi = xi + Math.imul(da, la) | 0, xi = xi + Math.imul(Yi, Ea) | 0, Wi = Wi + Math.imul(Yi, la) | 0, Ni = Ni + Math.imul(ca, Aa) | 0, xi = xi + Math.imul(ca, ha) | 0, xi = xi + Math.imul(ta, Aa) | 0, Wi = Wi + Math.imul(ta, ha) | 0, Ni = Ni + Math.imul(aa, Da) | 0, xi = xi + Math.imul(aa, va) | 0, xi = xi + Math.imul(Ds, Da) | 0, Wi = Wi + Math.imul(Ds, va) | 0, Ni = Ni + Math.imul(fa, Ba) | 0, xi = xi + Math.imul(fa, pa) | 0, xi = xi + Math.imul(gs, Ba) | 0, Wi = Wi + Math.imul(gs, pa) | 0, Ni = Ni + Math.imul(ea, _a) | 0, xi = xi + Math.imul(ea, ga) | 0, xi = xi + Math.imul(ia, _a) | 0, Wi = Wi + Math.imul(ia, ga) | 0, Ni = Ni + Math.imul(os, Na) | 0, xi = xi + Math.imul(os, Ma) | 0, xi = xi + Math.imul(ds, Na) | 0, Wi = Wi + Math.imul(ds, Ma) | 0, Ni = Ni + Math.imul(ji, qa) | 0, xi = xi + Math.imul(ji, Ta) | 0, xi = xi + Math.imul(Vi, qa) | 0, Wi = Wi + Math.imul(Vi, Ta) | 0;
      var So = (Si + Ni | 0) + ((xi & 8191) << 13) | 0;
      Si = (Wi + (xi >>> 13) | 0) + (So >>> 26) | 0, So &= 67108863, Ni = Math.imul(zi, Ea), xi = Math.imul(zi, la), xi = xi + Math.imul(En, Ea) | 0, Wi = Math.imul(En, la), Ni = Ni + Math.imul(da, Aa) | 0, xi = xi + Math.imul(da, ha) | 0, xi = xi + Math.imul(Yi, Aa) | 0, Wi = Wi + Math.imul(Yi, ha) | 0, Ni = Ni + Math.imul(ca, Da) | 0, xi = xi + Math.imul(ca, va) | 0, xi = xi + Math.imul(ta, Da) | 0, Wi = Wi + Math.imul(ta, va) | 0, Ni = Ni + Math.imul(aa, Ba) | 0, xi = xi + Math.imul(aa, pa) | 0, xi = xi + Math.imul(Ds, Ba) | 0, Wi = Wi + Math.imul(Ds, pa) | 0, Ni = Ni + Math.imul(fa, _a) | 0, xi = xi + Math.imul(fa, ga) | 0, xi = xi + Math.imul(gs, _a) | 0, Wi = Wi + Math.imul(gs, ga) | 0, Ni = Ni + Math.imul(ea, Na) | 0, xi = xi + Math.imul(ea, Ma) | 0, xi = xi + Math.imul(ia, Na) | 0, Wi = Wi + Math.imul(ia, Ma) | 0, Ni = Ni + Math.imul(os, qa) | 0, xi = xi + Math.imul(os, Ta) | 0, xi = xi + Math.imul(ds, qa) | 0, Wi = Wi + Math.imul(ds, Ta) | 0;
      var xo = (Si + Ni | 0) + ((xi & 8191) << 13) | 0;
      Si = (Wi + (xi >>> 13) | 0) + (xo >>> 26) | 0, xo &= 67108863, Ni = Math.imul(zi, Aa), xi = Math.imul(zi, ha), xi = xi + Math.imul(En, Aa) | 0, Wi = Math.imul(En, ha), Ni = Ni + Math.imul(da, Da) | 0, xi = xi + Math.imul(da, va) | 0, xi = xi + Math.imul(Yi, Da) | 0, Wi = Wi + Math.imul(Yi, va) | 0, Ni = Ni + Math.imul(ca, Ba) | 0, xi = xi + Math.imul(ca, pa) | 0, xi = xi + Math.imul(ta, Ba) | 0, Wi = Wi + Math.imul(ta, pa) | 0, Ni = Ni + Math.imul(aa, _a) | 0, xi = xi + Math.imul(aa, ga) | 0, xi = xi + Math.imul(Ds, _a) | 0, Wi = Wi + Math.imul(Ds, ga) | 0, Ni = Ni + Math.imul(fa, Na) | 0, xi = xi + Math.imul(fa, Ma) | 0, xi = xi + Math.imul(gs, Na) | 0, Wi = Wi + Math.imul(gs, Ma) | 0, Ni = Ni + Math.imul(ea, qa) | 0, xi = xi + Math.imul(ea, Ta) | 0, xi = xi + Math.imul(ia, qa) | 0, Wi = Wi + Math.imul(ia, Ta) | 0;
      var Ha = (Si + Ni | 0) + ((xi & 8191) << 13) | 0;
      Si = (Wi + (xi >>> 13) | 0) + (Ha >>> 26) | 0, Ha &= 67108863, Ni = Math.imul(zi, Da), xi = Math.imul(zi, va), xi = xi + Math.imul(En, Da) | 0, Wi = Math.imul(En, va), Ni = Ni + Math.imul(da, Ba) | 0, xi = xi + Math.imul(da, pa) | 0, xi = xi + Math.imul(Yi, Ba) | 0, Wi = Wi + Math.imul(Yi, pa) | 0, Ni = Ni + Math.imul(ca, _a) | 0, xi = xi + Math.imul(ca, ga) | 0, xi = xi + Math.imul(ta, _a) | 0, Wi = Wi + Math.imul(ta, ga) | 0, Ni = Ni + Math.imul(aa, Na) | 0, xi = xi + Math.imul(aa, Ma) | 0, xi = xi + Math.imul(Ds, Na) | 0, Wi = Wi + Math.imul(Ds, Ma) | 0, Ni = Ni + Math.imul(fa, qa) | 0, xi = xi + Math.imul(fa, Ta) | 0, xi = xi + Math.imul(gs, qa) | 0, Wi = Wi + Math.imul(gs, Ta) | 0;
      var Ao = (Si + Ni | 0) + ((xi & 8191) << 13) | 0;
      Si = (Wi + (xi >>> 13) | 0) + (Ao >>> 26) | 0, Ao &= 67108863, Ni = Math.imul(zi, Ba), xi = Math.imul(zi, pa), xi = xi + Math.imul(En, Ba) | 0, Wi = Math.imul(En, pa), Ni = Ni + Math.imul(da, _a) | 0, xi = xi + Math.imul(da, ga) | 0, xi = xi + Math.imul(Yi, _a) | 0, Wi = Wi + Math.imul(Yi, ga) | 0, Ni = Ni + Math.imul(ca, Na) | 0, xi = xi + Math.imul(ca, Ma) | 0, xi = xi + Math.imul(ta, Na) | 0, Wi = Wi + Math.imul(ta, Ma) | 0, Ni = Ni + Math.imul(aa, qa) | 0, xi = xi + Math.imul(aa, Ta) | 0, xi = xi + Math.imul(Ds, qa) | 0, Wi = Wi + Math.imul(Ds, Ta) | 0;
      var Ro = (Si + Ni | 0) + ((xi & 8191) << 13) | 0;
      Si = (Wi + (xi >>> 13) | 0) + (Ro >>> 26) | 0, Ro &= 67108863, Ni = Math.imul(zi, _a), xi = Math.imul(zi, ga), xi = xi + Math.imul(En, _a) | 0, Wi = Math.imul(En, ga), Ni = Ni + Math.imul(da, Na) | 0, xi = xi + Math.imul(da, Ma) | 0, xi = xi + Math.imul(Yi, Na) | 0, Wi = Wi + Math.imul(Yi, Ma) | 0, Ni = Ni + Math.imul(ca, qa) | 0, xi = xi + Math.imul(ca, Ta) | 0, xi = xi + Math.imul(ta, qa) | 0, Wi = Wi + Math.imul(ta, Ta) | 0;
      var Mo = (Si + Ni | 0) + ((xi & 8191) << 13) | 0;
      Si = (Wi + (xi >>> 13) | 0) + (Mo >>> 26) | 0, Mo &= 67108863, Ni = Math.imul(zi, Na), xi = Math.imul(zi, Ma), xi = xi + Math.imul(En, Na) | 0, Wi = Math.imul(En, Ma), Ni = Ni + Math.imul(da, qa) | 0, xi = xi + Math.imul(da, Ta) | 0, xi = xi + Math.imul(Yi, qa) | 0, Wi = Wi + Math.imul(Yi, Ta) | 0;
      var qo = (Si + Ni | 0) + ((xi & 8191) << 13) | 0;
      Si = (Wi + (xi >>> 13) | 0) + (qo >>> 26) | 0, qo &= 67108863, Ni = Math.imul(zi, qa), xi = Math.imul(zi, Ta), xi = xi + Math.imul(En, qa) | 0, Wi = Math.imul(En, Ta);
      var To = (Si + Ni | 0) + ((xi & 8191) << 13) | 0;
      return Si = (Wi + (xi >>> 13) | 0) + (To >>> 26) | 0, To &= 67108863, Oi[0] = Va, Oi[1] = Ga, Oi[2] = Ja, Oi[3] = Xa, Oi[4] = ja, Oi[5] = go, Oi[6] = wo, Oi[7] = _o, Oi[8] = $o, Oi[9] = Eo, Oi[10] = Za, Oi[11] = So, Oi[12] = xo, Oi[13] = Ha, Oi[14] = Ao, Oi[15] = Ro, Oi[16] = Mo, Oi[17] = qo, Oi[18] = To, Si !== 0 && (Oi[19] = Si, Ti.length++), Ti;
    };
    Math.imul || (ki = Ui);
    function Ji(Ai, wi, Ei) {
      Ei.negative = wi.negative ^ Ai.negative, Ei.length = Ai.length + wi.length;
      for (var Ti = 0, Pi = 0, qi = 0; qi < Ei.length - 1; qi++) {
        var Oi = Pi;
        Pi = 0;
        for (var Si = Ti & 67108863, Ni = Math.min(qi, wi.length - 1), xi = Math.max(0, qi - Ai.length + 1); xi <= Ni; xi++) {
          var Wi = qi - xi, ts = Ai.words[Wi] | 0, Ki = wi.words[xi] | 0, fn = ts * Ki, Ii = fn & 67108863;
          Oi = Oi + (fn / 67108864 | 0) | 0, Ii = Ii + Si | 0, Si = Ii & 67108863, Oi = Oi + (Ii >>> 26) | 0, Pi += Oi >>> 26, Oi &= 67108863;
        }
        Ei.words[qi] = Si, Ti = Oi, Oi = Pi;
      }
      return Ti !== 0 ? Ei.words[qi] = Ti : Ei.length--, Ei._strip();
    }
    function Hi(Ai, wi, Ei) {
      return Ji(Ai, wi, Ei);
    }
    Be.prototype.mulTo = function(wi, Ei) {
      var Ti, Pi = this.length + wi.length;
      return this.length === 10 && wi.length === 10 ? Ti = ki(this, wi, Ei) : Pi < 63 ? Ti = Ui(this, wi, Ei) : Pi < 1024 ? Ti = Ji(this, wi, Ei) : Ti = Hi(this, wi, Ei), Ti;
    }, Be.prototype.mul = function(wi) {
      var Ei = new Be(null);
      return Ei.words = new Array(this.length + wi.length), this.mulTo(wi, Ei);
    }, Be.prototype.mulf = function(wi) {
      var Ei = new Be(null);
      return Ei.words = new Array(this.length + wi.length), Hi(this, wi, Ei);
    }, Be.prototype.imul = function(wi) {
      return this.clone().mulTo(wi, this);
    }, Be.prototype.imuln = function(wi) {
      var Ei = wi < 0;
      Ei && (wi = -wi), Ie(typeof wi == "number"), Ie(wi < 67108864);
      for (var Ti = 0, Pi = 0; Pi < this.length; Pi++) {
        var qi = (this.words[Pi] | 0) * wi, Oi = (qi & 67108863) + (Ti & 67108863);
        Ti >>= 26, Ti += qi / 67108864 | 0, Ti += Oi >>> 26, this.words[Pi] = Oi & 67108863;
      }
      return Ti !== 0 && (this.words[Pi] = Ti, this.length++), Ei ? this.ineg() : this;
    }, Be.prototype.muln = function(wi) {
      return this.clone().imuln(wi);
    }, Be.prototype.sqr = function() {
      return this.mul(this);
    }, Be.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Be.prototype.pow = function(wi) {
      var Ei = Ci(wi);
      if (Ei.length === 0) return new Be(1);
      for (var Ti = this, Pi = 0; Pi < Ei.length && Ei[Pi] === 0; Pi++, Ti = Ti.sqr())
        ;
      if (++Pi < Ei.length)
        for (var qi = Ti.sqr(); Pi < Ei.length; Pi++, qi = qi.sqr())
          Ei[Pi] !== 0 && (Ti = Ti.mul(qi));
      return Ti;
    }, Be.prototype.iushln = function(wi) {
      Ie(typeof wi == "number" && wi >= 0);
      var Ei = wi % 26, Ti = (wi - Ei) / 26, Pi = 67108863 >>> 26 - Ei << 26 - Ei, qi;
      if (Ei !== 0) {
        var Oi = 0;
        for (qi = 0; qi < this.length; qi++) {
          var Si = this.words[qi] & Pi, Ni = (this.words[qi] | 0) - Si << Ei;
          this.words[qi] = Ni | Oi, Oi = Si >>> 26 - Ei;
        }
        Oi && (this.words[qi] = Oi, this.length++);
      }
      if (Ti !== 0) {
        for (qi = this.length - 1; qi >= 0; qi--)
          this.words[qi + Ti] = this.words[qi];
        for (qi = 0; qi < Ti; qi++)
          this.words[qi] = 0;
        this.length += Ti;
      }
      return this._strip();
    }, Be.prototype.ishln = function(wi) {
      return Ie(this.negative === 0), this.iushln(wi);
    }, Be.prototype.iushrn = function(wi, Ei, Ti) {
      Ie(typeof wi == "number" && wi >= 0);
      var Pi;
      Ei ? Pi = (Ei - Ei % 26) / 26 : Pi = 0;
      var qi = wi % 26, Oi = Math.min((wi - qi) / 26, this.length), Si = 67108863 ^ 67108863 >>> qi << qi, Ni = Ti;
      if (Pi -= Oi, Pi = Math.max(0, Pi), Ni) {
        for (var xi = 0; xi < Oi; xi++)
          Ni.words[xi] = this.words[xi];
        Ni.length = Oi;
      }
      if (Oi !== 0) if (this.length > Oi)
        for (this.length -= Oi, xi = 0; xi < this.length; xi++)
          this.words[xi] = this.words[xi + Oi];
      else
        this.words[0] = 0, this.length = 1;
      var Wi = 0;
      for (xi = this.length - 1; xi >= 0 && (Wi !== 0 || xi >= Pi); xi--) {
        var ts = this.words[xi] | 0;
        this.words[xi] = Wi << 26 - qi | ts >>> qi, Wi = ts & Si;
      }
      return Ni && Wi !== 0 && (Ni.words[Ni.length++] = Wi), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, Be.prototype.ishrn = function(wi, Ei, Ti) {
      return Ie(this.negative === 0), this.iushrn(wi, Ei, Ti);
    }, Be.prototype.shln = function(wi) {
      return this.clone().ishln(wi);
    }, Be.prototype.ushln = function(wi) {
      return this.clone().iushln(wi);
    }, Be.prototype.shrn = function(wi) {
      return this.clone().ishrn(wi);
    }, Be.prototype.ushrn = function(wi) {
      return this.clone().iushrn(wi);
    }, Be.prototype.testn = function(wi) {
      Ie(typeof wi == "number" && wi >= 0);
      var Ei = wi % 26, Ti = (wi - Ei) / 26, Pi = 1 << Ei;
      if (this.length <= Ti) return !1;
      var qi = this.words[Ti];
      return !!(qi & Pi);
    }, Be.prototype.imaskn = function(wi) {
      Ie(typeof wi == "number" && wi >= 0);
      var Ei = wi % 26, Ti = (wi - Ei) / 26;
      if (Ie(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Ti)
        return this;
      if (Ei !== 0 && Ti++, this.length = Math.min(Ti, this.length), Ei !== 0) {
        var Pi = 67108863 ^ 67108863 >>> Ei << Ei;
        this.words[this.length - 1] &= Pi;
      }
      return this._strip();
    }, Be.prototype.maskn = function(wi) {
      return this.clone().imaskn(wi);
    }, Be.prototype.iaddn = function(wi) {
      return Ie(typeof wi == "number"), Ie(wi < 67108864), wi < 0 ? this.isubn(-wi) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= wi ? (this.words[0] = wi - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(wi), this.negative = 1, this) : this._iaddn(wi);
    }, Be.prototype._iaddn = function(wi) {
      this.words[0] += wi;
      for (var Ei = 0; Ei < this.length && this.words[Ei] >= 67108864; Ei++)
        this.words[Ei] -= 67108864, Ei === this.length - 1 ? this.words[Ei + 1] = 1 : this.words[Ei + 1]++;
      return this.length = Math.max(this.length, Ei + 1), this;
    }, Be.prototype.isubn = function(wi) {
      if (Ie(typeof wi == "number"), Ie(wi < 67108864), wi < 0) return this.iaddn(-wi);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(wi), this.negative = 1, this;
      if (this.words[0] -= wi, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var Ei = 0; Ei < this.length && this.words[Ei] < 0; Ei++)
          this.words[Ei] += 67108864, this.words[Ei + 1] -= 1;
      return this._strip();
    }, Be.prototype.addn = function(wi) {
      return this.clone().iaddn(wi);
    }, Be.prototype.subn = function(wi) {
      return this.clone().isubn(wi);
    }, Be.prototype.iabs = function() {
      return this.negative = 0, this;
    }, Be.prototype.abs = function() {
      return this.clone().iabs();
    }, Be.prototype._ishlnsubmul = function(wi, Ei, Ti) {
      var Pi = wi.length + Ti, qi;
      this._expand(Pi);
      var Oi, Si = 0;
      for (qi = 0; qi < wi.length; qi++) {
        Oi = (this.words[qi + Ti] | 0) + Si;
        var Ni = (wi.words[qi] | 0) * Ei;
        Oi -= Ni & 67108863, Si = (Oi >> 26) - (Ni / 67108864 | 0), this.words[qi + Ti] = Oi & 67108863;
      }
      for (; qi < this.length - Ti; qi++)
        Oi = (this.words[qi + Ti] | 0) + Si, Si = Oi >> 26, this.words[qi + Ti] = Oi & 67108863;
      if (Si === 0) return this._strip();
      for (Ie(Si === -1), Si = 0, qi = 0; qi < this.length; qi++)
        Oi = -(this.words[qi] | 0) + Si, Si = Oi >> 26, this.words[qi] = Oi & 67108863;
      return this.negative = 1, this._strip();
    }, Be.prototype._wordDiv = function(wi, Ei) {
      var Ti = this.length - wi.length, Pi = this.clone(), qi = wi, Oi = qi.words[qi.length - 1] | 0, Si = this._countBits(Oi);
      Ti = 26 - Si, Ti !== 0 && (qi = qi.ushln(Ti), Pi.iushln(Ti), Oi = qi.words[qi.length - 1] | 0);
      var Ni = Pi.length - qi.length, xi;
      if (Ei !== "mod") {
        xi = new Be(null), xi.length = Ni + 1, xi.words = new Array(xi.length);
        for (var Wi = 0; Wi < xi.length; Wi++)
          xi.words[Wi] = 0;
      }
      var ts = Pi.clone()._ishlnsubmul(qi, 1, Ni);
      ts.negative === 0 && (Pi = ts, xi && (xi.words[Ni] = 1));
      for (var Ki = Ni - 1; Ki >= 0; Ki--) {
        var fn = (Pi.words[qi.length + Ki] | 0) * 67108864 + (Pi.words[qi.length + Ki - 1] | 0);
        for (fn = Math.min(fn / Oi | 0, 67108863), Pi._ishlnsubmul(qi, fn, Ki); Pi.negative !== 0; )
          fn--, Pi.negative = 0, Pi._ishlnsubmul(qi, 1, Ki), Pi.isZero() || (Pi.negative ^= 1);
        xi && (xi.words[Ki] = fn);
      }
      return xi && xi._strip(), Pi._strip(), Ei !== "div" && Ti !== 0 && Pi.iushrn(Ti), {
        div: xi || null,
        mod: Pi
      };
    }, Be.prototype.divmod = function(wi, Ei, Ti) {
      if (Ie(!wi.isZero()), this.isZero())
        return {
          div: new Be(0),
          mod: new Be(0)
        };
      var Pi, qi, Oi;
      return this.negative !== 0 && wi.negative === 0 ? (Oi = this.neg().divmod(wi, Ei), Ei !== "mod" && (Pi = Oi.div.neg()), Ei !== "div" && (qi = Oi.mod.neg(), Ti && qi.negative !== 0 && qi.iadd(wi)), {
        div: Pi,
        mod: qi
      }) : this.negative === 0 && wi.negative !== 0 ? (Oi = this.divmod(wi.neg(), Ei), Ei !== "mod" && (Pi = Oi.div.neg()), {
        div: Pi,
        mod: Oi.mod
      }) : this.negative & wi.negative ? (Oi = this.neg().divmod(wi.neg(), Ei), Ei !== "div" && (qi = Oi.mod.neg(), Ti && qi.negative !== 0 && qi.isub(wi)), {
        div: Oi.div,
        mod: qi
      }) : wi.length > this.length || this.cmp(wi) < 0 ? {
        div: new Be(0),
        mod: this
      } : wi.length === 1 ? Ei === "div" ? {
        div: this.divn(wi.words[0]),
        mod: null
      } : Ei === "mod" ? {
        div: null,
        mod: new Be(this.modrn(wi.words[0]))
      } : {
        div: this.divn(wi.words[0]),
        mod: new Be(this.modrn(wi.words[0]))
      } : this._wordDiv(wi, Ei);
    }, Be.prototype.div = function(wi) {
      return this.divmod(wi, "div", !1).div;
    }, Be.prototype.mod = function(wi) {
      return this.divmod(wi, "mod", !1).mod;
    }, Be.prototype.umod = function(wi) {
      return this.divmod(wi, "mod", !0).mod;
    }, Be.prototype.divRound = function(wi) {
      var Ei = this.divmod(wi);
      if (Ei.mod.isZero()) return Ei.div;
      var Ti = Ei.div.negative !== 0 ? Ei.mod.isub(wi) : Ei.mod, Pi = wi.ushrn(1), qi = wi.andln(1), Oi = Ti.cmp(Pi);
      return Oi < 0 || qi === 1 && Oi === 0 ? Ei.div : Ei.div.negative !== 0 ? Ei.div.isubn(1) : Ei.div.iaddn(1);
    }, Be.prototype.modrn = function(wi) {
      var Ei = wi < 0;
      Ei && (wi = -wi), Ie(wi <= 67108863);
      for (var Ti = (1 << 26) % wi, Pi = 0, qi = this.length - 1; qi >= 0; qi--)
        Pi = (Ti * Pi + (this.words[qi] | 0)) % wi;
      return Ei ? -Pi : Pi;
    }, Be.prototype.modn = function(wi) {
      return this.modrn(wi);
    }, Be.prototype.idivn = function(wi) {
      var Ei = wi < 0;
      Ei && (wi = -wi), Ie(wi <= 67108863);
      for (var Ti = 0, Pi = this.length - 1; Pi >= 0; Pi--) {
        var qi = (this.words[Pi] | 0) + Ti * 67108864;
        this.words[Pi] = qi / wi | 0, Ti = qi % wi;
      }
      return this._strip(), Ei ? this.ineg() : this;
    }, Be.prototype.divn = function(wi) {
      return this.clone().idivn(wi);
    }, Be.prototype.egcd = function(wi) {
      Ie(wi.negative === 0), Ie(!wi.isZero());
      var Ei = this, Ti = wi.clone();
      Ei.negative !== 0 ? Ei = Ei.umod(wi) : Ei = Ei.clone();
      for (var Pi = new Be(1), qi = new Be(0), Oi = new Be(0), Si = new Be(1), Ni = 0; Ei.isEven() && Ti.isEven(); )
        Ei.iushrn(1), Ti.iushrn(1), ++Ni;
      for (var xi = Ti.clone(), Wi = Ei.clone(); !Ei.isZero(); ) {
        for (var ts = 0, Ki = 1; !(Ei.words[0] & Ki) && ts < 26; ++ts, Ki <<= 1) ;
        if (ts > 0)
          for (Ei.iushrn(ts); ts-- > 0; )
            (Pi.isOdd() || qi.isOdd()) && (Pi.iadd(xi), qi.isub(Wi)), Pi.iushrn(1), qi.iushrn(1);
        for (var fn = 0, Ii = 1; !(Ti.words[0] & Ii) && fn < 26; ++fn, Ii <<= 1) ;
        if (fn > 0)
          for (Ti.iushrn(fn); fn-- > 0; )
            (Oi.isOdd() || Si.isOdd()) && (Oi.iadd(xi), Si.isub(Wi)), Oi.iushrn(1), Si.iushrn(1);
        Ei.cmp(Ti) >= 0 ? (Ei.isub(Ti), Pi.isub(Oi), qi.isub(Si)) : (Ti.isub(Ei), Oi.isub(Pi), Si.isub(qi));
      }
      return {
        a: Oi,
        b: Si,
        gcd: Ti.iushln(Ni)
      };
    }, Be.prototype._invmp = function(wi) {
      Ie(wi.negative === 0), Ie(!wi.isZero());
      var Ei = this, Ti = wi.clone();
      Ei.negative !== 0 ? Ei = Ei.umod(wi) : Ei = Ei.clone();
      for (var Pi = new Be(1), qi = new Be(0), Oi = Ti.clone(); Ei.cmpn(1) > 0 && Ti.cmpn(1) > 0; ) {
        for (var Si = 0, Ni = 1; !(Ei.words[0] & Ni) && Si < 26; ++Si, Ni <<= 1) ;
        if (Si > 0)
          for (Ei.iushrn(Si); Si-- > 0; )
            Pi.isOdd() && Pi.iadd(Oi), Pi.iushrn(1);
        for (var xi = 0, Wi = 1; !(Ti.words[0] & Wi) && xi < 26; ++xi, Wi <<= 1) ;
        if (xi > 0)
          for (Ti.iushrn(xi); xi-- > 0; )
            qi.isOdd() && qi.iadd(Oi), qi.iushrn(1);
        Ei.cmp(Ti) >= 0 ? (Ei.isub(Ti), Pi.isub(qi)) : (Ti.isub(Ei), qi.isub(Pi));
      }
      var ts;
      return Ei.cmpn(1) === 0 ? ts = Pi : ts = qi, ts.cmpn(0) < 0 && ts.iadd(wi), ts;
    }, Be.prototype.gcd = function(wi) {
      if (this.isZero()) return wi.abs();
      if (wi.isZero()) return this.abs();
      var Ei = this.clone(), Ti = wi.clone();
      Ei.negative = 0, Ti.negative = 0;
      for (var Pi = 0; Ei.isEven() && Ti.isEven(); Pi++)
        Ei.iushrn(1), Ti.iushrn(1);
      do {
        for (; Ei.isEven(); )
          Ei.iushrn(1);
        for (; Ti.isEven(); )
          Ti.iushrn(1);
        var qi = Ei.cmp(Ti);
        if (qi < 0) {
          var Oi = Ei;
          Ei = Ti, Ti = Oi;
        } else if (qi === 0 || Ti.cmpn(1) === 0)
          break;
        Ei.isub(Ti);
      } while (!0);
      return Ti.iushln(Pi);
    }, Be.prototype.invm = function(wi) {
      return this.egcd(wi).a.umod(wi);
    }, Be.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, Be.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, Be.prototype.andln = function(wi) {
      return this.words[0] & wi;
    }, Be.prototype.bincn = function(wi) {
      Ie(typeof wi == "number");
      var Ei = wi % 26, Ti = (wi - Ei) / 26, Pi = 1 << Ei;
      if (this.length <= Ti)
        return this._expand(Ti + 1), this.words[Ti] |= Pi, this;
      for (var qi = Pi, Oi = Ti; qi !== 0 && Oi < this.length; Oi++) {
        var Si = this.words[Oi] | 0;
        Si += qi, qi = Si >>> 26, Si &= 67108863, this.words[Oi] = Si;
      }
      return qi !== 0 && (this.words[Oi] = qi, this.length++), this;
    }, Be.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, Be.prototype.cmpn = function(wi) {
      var Ei = wi < 0;
      if (this.negative !== 0 && !Ei) return -1;
      if (this.negative === 0 && Ei) return 1;
      this._strip();
      var Ti;
      if (this.length > 1)
        Ti = 1;
      else {
        Ei && (wi = -wi), Ie(wi <= 67108863, "Number is too big");
        var Pi = this.words[0] | 0;
        Ti = Pi === wi ? 0 : Pi < wi ? -1 : 1;
      }
      return this.negative !== 0 ? -Ti | 0 : Ti;
    }, Be.prototype.cmp = function(wi) {
      if (this.negative !== 0 && wi.negative === 0) return -1;
      if (this.negative === 0 && wi.negative !== 0) return 1;
      var Ei = this.ucmp(wi);
      return this.negative !== 0 ? -Ei | 0 : Ei;
    }, Be.prototype.ucmp = function(wi) {
      if (this.length > wi.length) return 1;
      if (this.length < wi.length) return -1;
      for (var Ei = 0, Ti = this.length - 1; Ti >= 0; Ti--) {
        var Pi = this.words[Ti] | 0, qi = wi.words[Ti] | 0;
        if (Pi !== qi) {
          Pi < qi ? Ei = -1 : Pi > qi && (Ei = 1);
          break;
        }
      }
      return Ei;
    }, Be.prototype.gtn = function(wi) {
      return this.cmpn(wi) === 1;
    }, Be.prototype.gt = function(wi) {
      return this.cmp(wi) === 1;
    }, Be.prototype.gten = function(wi) {
      return this.cmpn(wi) >= 0;
    }, Be.prototype.gte = function(wi) {
      return this.cmp(wi) >= 0;
    }, Be.prototype.ltn = function(wi) {
      return this.cmpn(wi) === -1;
    }, Be.prototype.lt = function(wi) {
      return this.cmp(wi) === -1;
    }, Be.prototype.lten = function(wi) {
      return this.cmpn(wi) <= 0;
    }, Be.prototype.lte = function(wi) {
      return this.cmp(wi) <= 0;
    }, Be.prototype.eqn = function(wi) {
      return this.cmpn(wi) === 0;
    }, Be.prototype.eq = function(wi) {
      return this.cmp(wi) === 0;
    }, Be.red = function(wi) {
      return new vn(wi);
    }, Be.prototype.toRed = function(wi) {
      return Ie(!this.red, "Already a number in reduction context"), Ie(this.negative === 0, "red works only with positives"), wi.convertTo(this)._forceRed(wi);
    }, Be.prototype.fromRed = function() {
      return Ie(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, Be.prototype._forceRed = function(wi) {
      return this.red = wi, this;
    }, Be.prototype.forceRed = function(wi) {
      return Ie(!this.red, "Already a number in reduction context"), this._forceRed(wi);
    }, Be.prototype.redAdd = function(wi) {
      return Ie(this.red, "redAdd works only with red numbers"), this.red.add(this, wi);
    }, Be.prototype.redIAdd = function(wi) {
      return Ie(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, wi);
    }, Be.prototype.redSub = function(wi) {
      return Ie(this.red, "redSub works only with red numbers"), this.red.sub(this, wi);
    }, Be.prototype.redISub = function(wi) {
      return Ie(this.red, "redISub works only with red numbers"), this.red.isub(this, wi);
    }, Be.prototype.redShl = function(wi) {
      return Ie(this.red, "redShl works only with red numbers"), this.red.shl(this, wi);
    }, Be.prototype.redMul = function(wi) {
      return Ie(this.red, "redMul works only with red numbers"), this.red._verify2(this, wi), this.red.mul(this, wi);
    }, Be.prototype.redIMul = function(wi) {
      return Ie(this.red, "redMul works only with red numbers"), this.red._verify2(this, wi), this.red.imul(this, wi);
    }, Be.prototype.redSqr = function() {
      return Ie(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, Be.prototype.redISqr = function() {
      return Ie(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, Be.prototype.redSqrt = function() {
      return Ie(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, Be.prototype.redInvm = function() {
      return Ie(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, Be.prototype.redNeg = function() {
      return Ie(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, Be.prototype.redPow = function(wi) {
      return Ie(this.red && !wi.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, wi);
    };
    var Zi = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Qi(Ai, wi) {
      this.name = Ai, this.p = new Be(wi, 16), this.n = this.p.bitLength(), this.k = new Be(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Qi.prototype._tmp = function() {
      var wi = new Be(null);
      return wi.words = new Array(Math.ceil(this.n / 13)), wi;
    }, Qi.prototype.ireduce = function(wi) {
      var Ei = wi, Ti;
      do
        this.split(Ei, this.tmp), Ei = this.imulK(Ei), Ei = Ei.iadd(this.tmp), Ti = Ei.bitLength();
      while (Ti > this.n);
      var Pi = Ti < this.n ? -1 : Ei.ucmp(this.p);
      return Pi === 0 ? (Ei.words[0] = 0, Ei.length = 1) : Pi > 0 ? Ei.isub(this.p) : Ei.strip !== void 0 ? Ei.strip() : Ei._strip(), Ei;
    }, Qi.prototype.split = function(wi, Ei) {
      wi.iushrn(this.n, 0, Ei);
    }, Qi.prototype.imulK = function(wi) {
      return wi.imul(this.k);
    };
    function Bi() {
      Qi.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    Pe(Bi, Qi), Bi.prototype.split = function(wi, Ei) {
      for (var Ti = 4194303, Pi = Math.min(wi.length, 9), qi = 0; qi < Pi; qi++)
        Ei.words[qi] = wi.words[qi];
      if (Ei.length = Pi, wi.length <= 9) {
        wi.words[0] = 0, wi.length = 1;
        return;
      }
      var Oi = wi.words[9];
      for (Ei.words[Ei.length++] = Oi & Ti, qi = 10; qi < wi.length; qi++) {
        var Si = wi.words[qi] | 0;
        wi.words[qi - 10] = (Si & Ti) << 4 | Oi >>> 22, Oi = Si;
      }
      Oi >>>= 22, wi.words[qi - 10] = Oi, Oi === 0 && wi.length > 10 ? wi.length -= 10 : wi.length -= 9;
    }, Bi.prototype.imulK = function(wi) {
      wi.words[wi.length] = 0, wi.words[wi.length + 1] = 0, wi.length += 2;
      for (var Ei = 0, Ti = 0; Ti < wi.length; Ti++) {
        var Pi = wi.words[Ti] | 0;
        Ei += Pi * 977, wi.words[Ti] = Ei & 67108863, Ei = Pi * 64 + (Ei / 67108864 | 0);
      }
      return wi.words[wi.length - 1] === 0 && (wi.length--, wi.words[wi.length - 1] === 0 && wi.length--), wi;
    };
    function Xi() {
      Qi.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    Pe(Xi, Qi);
    function ns() {
      Qi.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    Pe(ns, Qi);
    function ls() {
      Qi.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    Pe(ls, Qi), ls.prototype.imulK = function(wi) {
      for (var Ei = 0, Ti = 0; Ti < wi.length; Ti++) {
        var Pi = (wi.words[Ti] | 0) * 19 + Ei, qi = Pi & 67108863;
        Pi >>>= 26, wi.words[Ti] = qi, Ei = Pi;
      }
      return Ei !== 0 && (wi.words[wi.length++] = Ei), wi;
    }, Be._prime = function(wi) {
      if (Zi[wi]) return Zi[wi];
      var Ei;
      if (wi === "k256")
        Ei = new Bi();
      else if (wi === "p224")
        Ei = new Xi();
      else if (wi === "p192")
        Ei = new ns();
      else if (wi === "p25519")
        Ei = new ls();
      else
        throw new Error("Unknown prime " + wi);
      return Zi[wi] = Ei, Ei;
    };
    function vn(Ai) {
      if (typeof Ai == "string") {
        var wi = Be._prime(Ai);
        this.m = wi.p, this.prime = wi;
      } else
        Ie(Ai.gtn(1), "modulus must be greater than 1"), this.m = Ai, this.prime = null;
    }
    vn.prototype._verify1 = function(wi) {
      Ie(wi.negative === 0, "red works only with positives"), Ie(wi.red, "red works only with red numbers");
    }, vn.prototype._verify2 = function(wi, Ei) {
      Ie((wi.negative | Ei.negative) === 0, "red works only with positives"), Ie(
        wi.red && wi.red === Ei.red,
        "red works only with red numbers"
      );
    }, vn.prototype.imod = function(wi) {
      return this.prime ? this.prime.ireduce(wi)._forceRed(this) : (Ue(wi, wi.umod(this.m)._forceRed(this)), wi);
    }, vn.prototype.neg = function(wi) {
      return wi.isZero() ? wi.clone() : this.m.sub(wi)._forceRed(this);
    }, vn.prototype.add = function(wi, Ei) {
      this._verify2(wi, Ei);
      var Ti = wi.add(Ei);
      return Ti.cmp(this.m) >= 0 && Ti.isub(this.m), Ti._forceRed(this);
    }, vn.prototype.iadd = function(wi, Ei) {
      this._verify2(wi, Ei);
      var Ti = wi.iadd(Ei);
      return Ti.cmp(this.m) >= 0 && Ti.isub(this.m), Ti;
    }, vn.prototype.sub = function(wi, Ei) {
      this._verify2(wi, Ei);
      var Ti = wi.sub(Ei);
      return Ti.cmpn(0) < 0 && Ti.iadd(this.m), Ti._forceRed(this);
    }, vn.prototype.isub = function(wi, Ei) {
      this._verify2(wi, Ei);
      var Ti = wi.isub(Ei);
      return Ti.cmpn(0) < 0 && Ti.iadd(this.m), Ti;
    }, vn.prototype.shl = function(wi, Ei) {
      return this._verify1(wi), this.imod(wi.ushln(Ei));
    }, vn.prototype.imul = function(wi, Ei) {
      return this._verify2(wi, Ei), this.imod(wi.imul(Ei));
    }, vn.prototype.mul = function(wi, Ei) {
      return this._verify2(wi, Ei), this.imod(wi.mul(Ei));
    }, vn.prototype.isqr = function(wi) {
      return this.imul(wi, wi.clone());
    }, vn.prototype.sqr = function(wi) {
      return this.mul(wi, wi);
    }, vn.prototype.sqrt = function(wi) {
      if (wi.isZero()) return wi.clone();
      var Ei = this.m.andln(3);
      if (Ie(Ei % 2 === 1), Ei === 3) {
        var Ti = this.m.add(new Be(1)).iushrn(2);
        return this.pow(wi, Ti);
      }
      for (var Pi = this.m.subn(1), qi = 0; !Pi.isZero() && Pi.andln(1) === 0; )
        qi++, Pi.iushrn(1);
      Ie(!Pi.isZero());
      var Oi = new Be(1).toRed(this), Si = Oi.redNeg(), Ni = this.m.subn(1).iushrn(1), xi = this.m.bitLength();
      for (xi = new Be(2 * xi * xi).toRed(this); this.pow(xi, Ni).cmp(Si) !== 0; )
        xi.redIAdd(Si);
      for (var Wi = this.pow(xi, Pi), ts = this.pow(wi, Pi.addn(1).iushrn(1)), Ki = this.pow(wi, Pi), fn = qi; Ki.cmp(Oi) !== 0; ) {
        for (var Ii = Ki, Fi = 0; Ii.cmp(Oi) !== 0; Fi++)
          Ii = Ii.redSqr();
        Ie(Fi < fn);
        var Gi = this.pow(Wi, new Be(1).iushln(fn - Fi - 1));
        ts = ts.redMul(Gi), Wi = Gi.redSqr(), Ki = Ki.redMul(Wi), fn = Fi;
      }
      return ts;
    }, vn.prototype.invm = function(wi) {
      var Ei = wi._invmp(this.m);
      return Ei.negative !== 0 ? (Ei.negative = 0, this.imod(Ei).redNeg()) : this.imod(Ei);
    }, vn.prototype.pow = function(wi, Ei) {
      if (Ei.isZero()) return new Be(1).toRed(this);
      if (Ei.cmpn(1) === 0) return wi.clone();
      var Ti = 4, Pi = new Array(1 << Ti);
      Pi[0] = new Be(1).toRed(this), Pi[1] = wi;
      for (var qi = 2; qi < Pi.length; qi++)
        Pi[qi] = this.mul(Pi[qi - 1], wi);
      var Oi = Pi[0], Si = 0, Ni = 0, xi = Ei.bitLength() % 26;
      for (xi === 0 && (xi = 26), qi = Ei.length - 1; qi >= 0; qi--) {
        for (var Wi = Ei.words[qi], ts = xi - 1; ts >= 0; ts--) {
          var Ki = Wi >> ts & 1;
          if (Oi !== Pi[0] && (Oi = this.sqr(Oi)), Ki === 0 && Si === 0) {
            Ni = 0;
            continue;
          }
          Si <<= 1, Si |= Ki, Ni++, !(Ni !== Ti && (qi !== 0 || ts !== 0)) && (Oi = this.mul(Oi, Pi[Si]), Ni = 0, Si = 0);
        }
        xi = 26;
      }
      return Oi;
    }, vn.prototype.convertTo = function(wi) {
      var Ei = wi.umod(this.m);
      return Ei === wi ? Ei.clone() : Ei;
    }, vn.prototype.convertFrom = function(wi) {
      var Ei = wi.clone();
      return Ei.red = null, Ei;
    }, Be.mont = function(wi) {
      return new Mi(wi);
    };
    function Mi(Ai) {
      vn.call(this, Ai), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new Be(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    Pe(Mi, vn), Mi.prototype.convertTo = function(wi) {
      return this.imod(wi.ushln(this.shift));
    }, Mi.prototype.convertFrom = function(wi) {
      var Ei = this.imod(wi.mul(this.rinv));
      return Ei.red = null, Ei;
    }, Mi.prototype.imul = function(wi, Ei) {
      if (wi.isZero() || Ei.isZero())
        return wi.words[0] = 0, wi.length = 1, wi;
      var Ti = wi.imul(Ei), Pi = Ti.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), qi = Ti.isub(Pi).iushrn(this.shift), Oi = qi;
      return qi.cmp(this.m) >= 0 ? Oi = qi.isub(this.m) : qi.cmpn(0) < 0 && (Oi = qi.iadd(this.m)), Oi._forceRed(this);
    }, Mi.prototype.mul = function(wi, Ei) {
      if (wi.isZero() || Ei.isZero()) return new Be(0)._forceRed(this);
      var Ti = wi.mul(Ei), Pi = Ti.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), qi = Ti.isub(Pi).iushrn(this.shift), Oi = qi;
      return qi.cmp(this.m) >= 0 ? Oi = qi.isub(this.m) : qi.cmpn(0) < 0 && (Oi = qi.iadd(this.m)), Oi._forceRed(this);
    }, Mi.prototype.invm = function(wi) {
      var Ei = this.imod(wi._invmp(this.m).mul(this.r2));
      return Ei._forceRed(this);
    };
  })(Ae, commonjsGlobal);
})(bn$3);
var bnExports$1 = bn$3.exports;
const BN$8 = /* @__PURE__ */ getDefaultExportFromCjs(bnExports$1);
var hash$5 = {}, utils$n = {}, minimalisticAssert$1 = assert$k;
function assert$k(Ae, t) {
  if (!Ae)
    throw new Error(t || "Assertion failed");
}
assert$k.equal = function(t, Me, Ie) {
  if (t != Me)
    throw new Error(Ie || "Assertion failed: " + t + " != " + Me);
};
var inherits_browser$1 = { exports: {} };
typeof Object.create == "function" ? inherits_browser$1.exports = function(t, Me) {
  Me && (t.super_ = Me, t.prototype = Object.create(Me.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser$1.exports = function(t, Me) {
  if (Me) {
    t.super_ = Me;
    var Ie = function() {
    };
    Ie.prototype = Me.prototype, t.prototype = new Ie(), t.prototype.constructor = t;
  }
};
var inherits_browserExports = inherits_browser$1.exports, assert$j = minimalisticAssert$1, inherits$3 = inherits_browserExports;
utils$n.inherits = inherits$3;
function isSurrogatePair(Ae, t) {
  return (Ae.charCodeAt(t) & 64512) !== 55296 || t < 0 || t + 1 >= Ae.length ? !1 : (Ae.charCodeAt(t + 1) & 64512) === 56320;
}
function toArray(Ae, t) {
  if (Array.isArray(Ae))
    return Ae.slice();
  if (!Ae)
    return [];
  var Me = [];
  if (typeof Ae == "string")
    if (t) {
      if (t === "hex")
        for (Ae = Ae.replace(/[^a-z0-9]+/ig, ""), Ae.length % 2 !== 0 && (Ae = "0" + Ae), Pe = 0; Pe < Ae.length; Pe += 2)
          Me.push(parseInt(Ae[Pe] + Ae[Pe + 1], 16));
    } else for (var Ie = 0, Pe = 0; Pe < Ae.length; Pe++) {
      var Be = Ae.charCodeAt(Pe);
      Be < 128 ? Me[Ie++] = Be : Be < 2048 ? (Me[Ie++] = Be >> 6 | 192, Me[Ie++] = Be & 63 | 128) : isSurrogatePair(Ae, Pe) ? (Be = 65536 + ((Be & 1023) << 10) + (Ae.charCodeAt(++Pe) & 1023), Me[Ie++] = Be >> 18 | 240, Me[Ie++] = Be >> 12 & 63 | 128, Me[Ie++] = Be >> 6 & 63 | 128, Me[Ie++] = Be & 63 | 128) : (Me[Ie++] = Be >> 12 | 224, Me[Ie++] = Be >> 6 & 63 | 128, Me[Ie++] = Be & 63 | 128);
    }
  else
    for (Pe = 0; Pe < Ae.length; Pe++)
      Me[Pe] = Ae[Pe] | 0;
  return Me;
}
utils$n.toArray = toArray;
function toHex(Ae) {
  for (var t = "", Me = 0; Me < Ae.length; Me++)
    t += zero2(Ae[Me].toString(16));
  return t;
}
utils$n.toHex = toHex;
function htonl(Ae) {
  var t = Ae >>> 24 | Ae >>> 8 & 65280 | Ae << 8 & 16711680 | (Ae & 255) << 24;
  return t >>> 0;
}
utils$n.htonl = htonl;
function toHex32(Ae, t) {
  for (var Me = "", Ie = 0; Ie < Ae.length; Ie++) {
    var Pe = Ae[Ie];
    t === "little" && (Pe = htonl(Pe)), Me += zero8(Pe.toString(16));
  }
  return Me;
}
utils$n.toHex32 = toHex32;
function zero2(Ae) {
  return Ae.length === 1 ? "0" + Ae : Ae;
}
utils$n.zero2 = zero2;
function zero8(Ae) {
  return Ae.length === 7 ? "0" + Ae : Ae.length === 6 ? "00" + Ae : Ae.length === 5 ? "000" + Ae : Ae.length === 4 ? "0000" + Ae : Ae.length === 3 ? "00000" + Ae : Ae.length === 2 ? "000000" + Ae : Ae.length === 1 ? "0000000" + Ae : Ae;
}
utils$n.zero8 = zero8;
function join32(Ae, t, Me, Ie) {
  var Pe = Me - t;
  assert$j(Pe % 4 === 0);
  for (var Be = new Array(Pe / 4), Te = 0, je = t; Te < Be.length; Te++, je += 4) {
    var Ve;
    Ie === "big" ? Ve = Ae[je] << 24 | Ae[je + 1] << 16 | Ae[je + 2] << 8 | Ae[je + 3] : Ve = Ae[je + 3] << 24 | Ae[je + 2] << 16 | Ae[je + 1] << 8 | Ae[je], Be[Te] = Ve >>> 0;
  }
  return Be;
}
utils$n.join32 = join32;
function split32(Ae, t) {
  for (var Me = new Array(Ae.length * 4), Ie = 0, Pe = 0; Ie < Ae.length; Ie++, Pe += 4) {
    var Be = Ae[Ie];
    t === "big" ? (Me[Pe] = Be >>> 24, Me[Pe + 1] = Be >>> 16 & 255, Me[Pe + 2] = Be >>> 8 & 255, Me[Pe + 3] = Be & 255) : (Me[Pe + 3] = Be >>> 24, Me[Pe + 2] = Be >>> 16 & 255, Me[Pe + 1] = Be >>> 8 & 255, Me[Pe] = Be & 255);
  }
  return Me;
}
utils$n.split32 = split32;
function rotr32$1(Ae, t) {
  return Ae >>> t | Ae << 32 - t;
}
utils$n.rotr32 = rotr32$1;
function rotl32$2(Ae, t) {
  return Ae << t | Ae >>> 32 - t;
}
utils$n.rotl32 = rotl32$2;
function sum32$3(Ae, t) {
  return Ae + t >>> 0;
}
utils$n.sum32 = sum32$3;
function sum32_3$1(Ae, t, Me) {
  return Ae + t + Me >>> 0;
}
utils$n.sum32_3 = sum32_3$1;
function sum32_4$2(Ae, t, Me, Ie) {
  return Ae + t + Me + Ie >>> 0;
}
utils$n.sum32_4 = sum32_4$2;
function sum32_5$2(Ae, t, Me, Ie, Pe) {
  return Ae + t + Me + Ie + Pe >>> 0;
}
utils$n.sum32_5 = sum32_5$2;
function sum64$1(Ae, t, Me, Ie) {
  var Pe = Ae[t], Be = Ae[t + 1], Te = Ie + Be >>> 0, je = (Te < Ie ? 1 : 0) + Me + Pe;
  Ae[t] = je >>> 0, Ae[t + 1] = Te;
}
utils$n.sum64 = sum64$1;
function sum64_hi$1(Ae, t, Me, Ie) {
  var Pe = t + Ie >>> 0, Be = (Pe < t ? 1 : 0) + Ae + Me;
  return Be >>> 0;
}
utils$n.sum64_hi = sum64_hi$1;
function sum64_lo$1(Ae, t, Me, Ie) {
  var Pe = t + Ie;
  return Pe >>> 0;
}
utils$n.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(Ae, t, Me, Ie, Pe, Be, Te, je) {
  var Ve = 0, fi = t;
  fi = fi + Ie >>> 0, Ve += fi < t ? 1 : 0, fi = fi + Be >>> 0, Ve += fi < Be ? 1 : 0, fi = fi + je >>> 0, Ve += fi < je ? 1 : 0;
  var Ue = Ae + Me + Pe + Te + Ve;
  return Ue >>> 0;
}
utils$n.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(Ae, t, Me, Ie, Pe, Be, Te, je) {
  var Ve = t + Ie + Be + je;
  return Ve >>> 0;
}
utils$n.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(Ae, t, Me, Ie, Pe, Be, Te, je, Ve, fi) {
  var Ue = 0, bi = t;
  bi = bi + Ie >>> 0, Ue += bi < t ? 1 : 0, bi = bi + Be >>> 0, Ue += bi < Be ? 1 : 0, bi = bi + je >>> 0, Ue += bi < je ? 1 : 0, bi = bi + fi >>> 0, Ue += bi < fi ? 1 : 0;
  var vi = Ae + Me + Pe + Te + Ve + Ue;
  return vi >>> 0;
}
utils$n.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(Ae, t, Me, Ie, Pe, Be, Te, je, Ve, fi) {
  var Ue = t + Ie + Be + je + fi;
  return Ue >>> 0;
}
utils$n.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(Ae, t, Me) {
  var Ie = t << 32 - Me | Ae >>> Me;
  return Ie >>> 0;
}
utils$n.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(Ae, t, Me) {
  var Ie = Ae << 32 - Me | t >>> Me;
  return Ie >>> 0;
}
utils$n.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(Ae, t, Me) {
  return Ae >>> Me;
}
utils$n.shr64_hi = shr64_hi$1;
function shr64_lo$1(Ae, t, Me) {
  var Ie = Ae << 32 - Me | t >>> Me;
  return Ie >>> 0;
}
utils$n.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$m = utils$n, assert$i = minimalisticAssert$1;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function(t, Me) {
  if (t = utils$m.toArray(t, Me), this.pending ? this.pending = this.pending.concat(t) : this.pending = t, this.pendingTotal += t.length, this.pending.length >= this._delta8) {
    t = this.pending;
    var Ie = t.length % this._delta8;
    this.pending = t.slice(t.length - Ie, t.length), this.pending.length === 0 && (this.pending = null), t = utils$m.join32(t, 0, t.length - Ie, this.endian);
    for (var Pe = 0; Pe < t.length; Pe += this._delta32)
      this._update(t, Pe, Pe + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function(t) {
  return this.update(this._pad()), assert$i(this.pending === null), this._digest(t);
};
BlockHash$4.prototype._pad = function() {
  var t = this.pendingTotal, Me = this._delta8, Ie = Me - (t + this.padLength) % Me, Pe = new Array(Ie + this.padLength);
  Pe[0] = 128;
  for (var Be = 1; Be < Ie; Be++)
    Pe[Be] = 0;
  if (t <<= 3, this.endian === "big") {
    for (var Te = 8; Te < this.padLength; Te++)
      Pe[Be++] = 0;
    Pe[Be++] = 0, Pe[Be++] = 0, Pe[Be++] = 0, Pe[Be++] = 0, Pe[Be++] = t >>> 24 & 255, Pe[Be++] = t >>> 16 & 255, Pe[Be++] = t >>> 8 & 255, Pe[Be++] = t & 255;
  } else
    for (Pe[Be++] = t & 255, Pe[Be++] = t >>> 8 & 255, Pe[Be++] = t >>> 16 & 255, Pe[Be++] = t >>> 24 & 255, Pe[Be++] = 0, Pe[Be++] = 0, Pe[Be++] = 0, Pe[Be++] = 0, Te = 8; Te < this.padLength; Te++)
      Pe[Be++] = 0;
  return Pe;
};
var sha$1 = {}, common$4 = {}, utils$l = utils$n, rotr32 = utils$l.rotr32;
function ft_1$1(Ae, t, Me, Ie) {
  if (Ae === 0)
    return ch32$1(t, Me, Ie);
  if (Ae === 1 || Ae === 3)
    return p32(t, Me, Ie);
  if (Ae === 2)
    return maj32$1(t, Me, Ie);
}
common$4.ft_1 = ft_1$1;
function ch32$1(Ae, t, Me) {
  return Ae & t ^ ~Ae & Me;
}
common$4.ch32 = ch32$1;
function maj32$1(Ae, t, Me) {
  return Ae & t ^ Ae & Me ^ t & Me;
}
common$4.maj32 = maj32$1;
function p32(Ae, t, Me) {
  return Ae ^ t ^ Me;
}
common$4.p32 = p32;
function s0_256$1(Ae) {
  return rotr32(Ae, 2) ^ rotr32(Ae, 13) ^ rotr32(Ae, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(Ae) {
  return rotr32(Ae, 6) ^ rotr32(Ae, 11) ^ rotr32(Ae, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(Ae) {
  return rotr32(Ae, 7) ^ rotr32(Ae, 18) ^ Ae >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(Ae) {
  return rotr32(Ae, 17) ^ rotr32(Ae, 19) ^ Ae >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$k = utils$n, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$k.rotl32, sum32$2 = utils$k.sum32, sum32_5$1 = utils$k.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$k.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function(t, Me) {
  for (var Ie = this.W, Pe = 0; Pe < 16; Pe++)
    Ie[Pe] = t[Me + Pe];
  for (; Pe < Ie.length; Pe++)
    Ie[Pe] = rotl32$1(Ie[Pe - 3] ^ Ie[Pe - 8] ^ Ie[Pe - 14] ^ Ie[Pe - 16], 1);
  var Be = this.h[0], Te = this.h[1], je = this.h[2], Ve = this.h[3], fi = this.h[4];
  for (Pe = 0; Pe < Ie.length; Pe++) {
    var Ue = ~~(Pe / 20), bi = sum32_5$1(rotl32$1(Be, 5), ft_1(Ue, Te, je, Ve), fi, Ie[Pe], sha1_K[Ue]);
    fi = Ve, Ve = je, je = rotl32$1(Te, 30), Te = Be, Be = bi;
  }
  this.h[0] = sum32$2(this.h[0], Be), this.h[1] = sum32$2(this.h[1], Te), this.h[2] = sum32$2(this.h[2], je), this.h[3] = sum32$2(this.h[3], Ve), this.h[4] = sum32$2(this.h[4], fi);
};
SHA1.prototype._digest = function(t) {
  return t === "hex" ? utils$k.toHex32(this.h, "big") : utils$k.split32(this.h, "big");
};
var utils$j = utils$n, common$2 = common$5, shaCommon = common$4, assert$h = minimalisticAssert$1, sum32$1 = utils$j.sum32, sum32_4$1 = utils$j.sum32_4, sum32_5 = utils$j.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$j.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function(t, Me) {
  for (var Ie = this.W, Pe = 0; Pe < 16; Pe++)
    Ie[Pe] = t[Me + Pe];
  for (; Pe < Ie.length; Pe++)
    Ie[Pe] = sum32_4$1(g1_256(Ie[Pe - 2]), Ie[Pe - 7], g0_256(Ie[Pe - 15]), Ie[Pe - 16]);
  var Be = this.h[0], Te = this.h[1], je = this.h[2], Ve = this.h[3], fi = this.h[4], Ue = this.h[5], bi = this.h[6], vi = this.h[7];
  for (assert$h(this.k.length === Ie.length), Pe = 0; Pe < Ie.length; Pe++) {
    var mi = sum32_5(vi, s1_256(fi), ch32(fi, Ue, bi), this.k[Pe], Ie[Pe]), _i = sum32$1(s0_256(Be), maj32(Be, Te, je));
    vi = bi, bi = Ue, Ue = fi, fi = sum32$1(Ve, mi), Ve = je, je = Te, Te = Be, Be = sum32$1(mi, _i);
  }
  this.h[0] = sum32$1(this.h[0], Be), this.h[1] = sum32$1(this.h[1], Te), this.h[2] = sum32$1(this.h[2], je), this.h[3] = sum32$1(this.h[3], Ve), this.h[4] = sum32$1(this.h[4], fi), this.h[5] = sum32$1(this.h[5], Ue), this.h[6] = sum32$1(this.h[6], bi), this.h[7] = sum32$1(this.h[7], vi);
};
SHA256$1.prototype._digest = function(t) {
  return t === "hex" ? utils$j.toHex32(this.h, "big") : utils$j.split32(this.h, "big");
};
var utils$i = utils$n, SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$i.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function(t) {
  return t === "hex" ? utils$i.toHex32(this.h.slice(0, 7), "big") : utils$i.split32(this.h.slice(0, 7), "big");
};
var utils$h = utils$n, common$1 = common$5, assert$g = minimalisticAssert$1, rotr64_hi = utils$h.rotr64_hi, rotr64_lo = utils$h.rotr64_lo, shr64_hi = utils$h.shr64_hi, shr64_lo = utils$h.shr64_lo, sum64 = utils$h.sum64, sum64_hi = utils$h.sum64_hi, sum64_lo = utils$h.sum64_lo, sum64_4_hi = utils$h.sum64_4_hi, sum64_4_lo = utils$h.sum64_4_lo, sum64_5_hi = utils$h.sum64_5_hi, sum64_5_lo = utils$h.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$h.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function(t, Me) {
  for (var Ie = this.W, Pe = 0; Pe < 32; Pe++)
    Ie[Pe] = t[Me + Pe];
  for (; Pe < Ie.length; Pe += 2) {
    var Be = g1_512_hi(Ie[Pe - 4], Ie[Pe - 3]), Te = g1_512_lo(Ie[Pe - 4], Ie[Pe - 3]), je = Ie[Pe - 14], Ve = Ie[Pe - 13], fi = g0_512_hi(Ie[Pe - 30], Ie[Pe - 29]), Ue = g0_512_lo(Ie[Pe - 30], Ie[Pe - 29]), bi = Ie[Pe - 32], vi = Ie[Pe - 31];
    Ie[Pe] = sum64_4_hi(
      Be,
      Te,
      je,
      Ve,
      fi,
      Ue,
      bi,
      vi
    ), Ie[Pe + 1] = sum64_4_lo(
      Be,
      Te,
      je,
      Ve,
      fi,
      Ue,
      bi,
      vi
    );
  }
};
SHA512$1.prototype._update = function(t, Me) {
  this._prepareBlock(t, Me);
  var Ie = this.W, Pe = this.h[0], Be = this.h[1], Te = this.h[2], je = this.h[3], Ve = this.h[4], fi = this.h[5], Ue = this.h[6], bi = this.h[7], vi = this.h[8], mi = this.h[9], _i = this.h[10], $i = this.h[11], Ci = this.h[12], Ui = this.h[13], ki = this.h[14], Ji = this.h[15];
  assert$g(this.k.length === Ie.length);
  for (var Hi = 0; Hi < Ie.length; Hi += 2) {
    var Zi = ki, Qi = Ji, Bi = s1_512_hi(vi, mi), Xi = s1_512_lo(vi, mi), ns = ch64_hi(vi, mi, _i, $i, Ci), ls = ch64_lo(vi, mi, _i, $i, Ci, Ui), vn = this.k[Hi], Mi = this.k[Hi + 1], Ai = Ie[Hi], wi = Ie[Hi + 1], Ei = sum64_5_hi(
      Zi,
      Qi,
      Bi,
      Xi,
      ns,
      ls,
      vn,
      Mi,
      Ai,
      wi
    ), Ti = sum64_5_lo(
      Zi,
      Qi,
      Bi,
      Xi,
      ns,
      ls,
      vn,
      Mi,
      Ai,
      wi
    );
    Zi = s0_512_hi(Pe, Be), Qi = s0_512_lo(Pe, Be), Bi = maj64_hi(Pe, Be, Te, je, Ve), Xi = maj64_lo(Pe, Be, Te, je, Ve, fi);
    var Pi = sum64_hi(Zi, Qi, Bi, Xi), qi = sum64_lo(Zi, Qi, Bi, Xi);
    ki = Ci, Ji = Ui, Ci = _i, Ui = $i, _i = vi, $i = mi, vi = sum64_hi(Ue, bi, Ei, Ti), mi = sum64_lo(bi, bi, Ei, Ti), Ue = Ve, bi = fi, Ve = Te, fi = je, Te = Pe, je = Be, Pe = sum64_hi(Ei, Ti, Pi, qi), Be = sum64_lo(Ei, Ti, Pi, qi);
  }
  sum64(this.h, 0, Pe, Be), sum64(this.h, 2, Te, je), sum64(this.h, 4, Ve, fi), sum64(this.h, 6, Ue, bi), sum64(this.h, 8, vi, mi), sum64(this.h, 10, _i, $i), sum64(this.h, 12, Ci, Ui), sum64(this.h, 14, ki, Ji);
};
SHA512$1.prototype._digest = function(t) {
  return t === "hex" ? utils$h.toHex32(this.h, "big") : utils$h.split32(this.h, "big");
};
function ch64_hi(Ae, t, Me, Ie, Pe) {
  var Be = Ae & Me ^ ~Ae & Pe;
  return Be < 0 && (Be += 4294967296), Be;
}
function ch64_lo(Ae, t, Me, Ie, Pe, Be) {
  var Te = t & Ie ^ ~t & Be;
  return Te < 0 && (Te += 4294967296), Te;
}
function maj64_hi(Ae, t, Me, Ie, Pe) {
  var Be = Ae & Me ^ Ae & Pe ^ Me & Pe;
  return Be < 0 && (Be += 4294967296), Be;
}
function maj64_lo(Ae, t, Me, Ie, Pe, Be) {
  var Te = t & Ie ^ t & Be ^ Ie & Be;
  return Te < 0 && (Te += 4294967296), Te;
}
function s0_512_hi(Ae, t) {
  var Me = rotr64_hi(Ae, t, 28), Ie = rotr64_hi(t, Ae, 2), Pe = rotr64_hi(t, Ae, 7), Be = Me ^ Ie ^ Pe;
  return Be < 0 && (Be += 4294967296), Be;
}
function s0_512_lo(Ae, t) {
  var Me = rotr64_lo(Ae, t, 28), Ie = rotr64_lo(t, Ae, 2), Pe = rotr64_lo(t, Ae, 7), Be = Me ^ Ie ^ Pe;
  return Be < 0 && (Be += 4294967296), Be;
}
function s1_512_hi(Ae, t) {
  var Me = rotr64_hi(Ae, t, 14), Ie = rotr64_hi(Ae, t, 18), Pe = rotr64_hi(t, Ae, 9), Be = Me ^ Ie ^ Pe;
  return Be < 0 && (Be += 4294967296), Be;
}
function s1_512_lo(Ae, t) {
  var Me = rotr64_lo(Ae, t, 14), Ie = rotr64_lo(Ae, t, 18), Pe = rotr64_lo(t, Ae, 9), Be = Me ^ Ie ^ Pe;
  return Be < 0 && (Be += 4294967296), Be;
}
function g0_512_hi(Ae, t) {
  var Me = rotr64_hi(Ae, t, 1), Ie = rotr64_hi(Ae, t, 8), Pe = shr64_hi(Ae, t, 7), Be = Me ^ Ie ^ Pe;
  return Be < 0 && (Be += 4294967296), Be;
}
function g0_512_lo(Ae, t) {
  var Me = rotr64_lo(Ae, t, 1), Ie = rotr64_lo(Ae, t, 8), Pe = shr64_lo(Ae, t, 7), Be = Me ^ Ie ^ Pe;
  return Be < 0 && (Be += 4294967296), Be;
}
function g1_512_hi(Ae, t) {
  var Me = rotr64_hi(Ae, t, 19), Ie = rotr64_hi(t, Ae, 29), Pe = shr64_hi(Ae, t, 6), Be = Me ^ Ie ^ Pe;
  return Be < 0 && (Be += 4294967296), Be;
}
function g1_512_lo(Ae, t) {
  var Me = rotr64_lo(Ae, t, 19), Ie = rotr64_lo(t, Ae, 29), Pe = shr64_lo(Ae, t, 6), Be = Me ^ Ie ^ Pe;
  return Be < 0 && (Be += 4294967296), Be;
}
var utils$g = utils$n, SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$g.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function(t) {
  return t === "hex" ? utils$g.toHex32(this.h.slice(0, 12), "big") : utils$g.split32(this.h.slice(0, 12), "big");
};
sha$1.sha1 = _1;
sha$1.sha224 = _224;
sha$1.sha256 = _256;
sha$1.sha384 = _384;
sha$1.sha512 = _512;
var ripemd = {}, utils$f = utils$n, common = common$5, rotl32 = utils$f.rotl32, sum32 = utils$f.sum32, sum32_3 = utils$f.sum32_3, sum32_4 = utils$f.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$f.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function(t, Me) {
  for (var Ie = this.h[0], Pe = this.h[1], Be = this.h[2], Te = this.h[3], je = this.h[4], Ve = Ie, fi = Pe, Ue = Be, bi = Te, vi = je, mi = 0; mi < 80; mi++) {
    var _i = sum32(
      rotl32(
        sum32_4(Ie, f$4(mi, Pe, Be, Te), t[r$2[mi] + Me], K$4(mi)),
        s$1[mi]
      ),
      je
    );
    Ie = je, je = Te, Te = rotl32(Be, 10), Be = Pe, Pe = _i, _i = sum32(
      rotl32(
        sum32_4(Ve, f$4(79 - mi, fi, Ue, bi), t[rh[mi] + Me], Kh(mi)),
        sh[mi]
      ),
      vi
    ), Ve = vi, vi = bi, bi = rotl32(Ue, 10), Ue = fi, fi = _i;
  }
  _i = sum32_3(this.h[1], Be, bi), this.h[1] = sum32_3(this.h[2], Te, vi), this.h[2] = sum32_3(this.h[3], je, Ve), this.h[3] = sum32_3(this.h[4], Ie, fi), this.h[4] = sum32_3(this.h[0], Pe, Ue), this.h[0] = _i;
};
RIPEMD160.prototype._digest = function(t) {
  return t === "hex" ? utils$f.toHex32(this.h, "little") : utils$f.split32(this.h, "little");
};
function f$4(Ae, t, Me, Ie) {
  return Ae <= 15 ? t ^ Me ^ Ie : Ae <= 31 ? t & Me | ~t & Ie : Ae <= 47 ? (t | ~Me) ^ Ie : Ae <= 63 ? t & Ie | Me & ~Ie : t ^ (Me | ~Ie);
}
function K$4(Ae) {
  return Ae <= 15 ? 0 : Ae <= 31 ? 1518500249 : Ae <= 47 ? 1859775393 : Ae <= 63 ? 2400959708 : 2840853838;
}
function Kh(Ae) {
  return Ae <= 15 ? 1352829926 : Ae <= 31 ? 1548603684 : Ae <= 47 ? 1836072691 : Ae <= 63 ? 2053994217 : 0;
}
var r$2 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s$1 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils$e = utils$n, assert$f = minimalisticAssert$1;
function Hmac(Ae, t, Me) {
  if (!(this instanceof Hmac))
    return new Hmac(Ae, t, Me);
  this.Hash = Ae, this.blockSize = Ae.blockSize / 8, this.outSize = Ae.outSize / 8, this.inner = null, this.outer = null, this._init(utils$e.toArray(t, Me));
}
var hmac$2 = Hmac;
Hmac.prototype._init = function(t) {
  t.length > this.blockSize && (t = new this.Hash().update(t).digest()), assert$f(t.length <= this.blockSize);
  for (var Me = t.length; Me < this.blockSize; Me++)
    t.push(0);
  for (Me = 0; Me < t.length; Me++)
    t[Me] ^= 54;
  for (this.inner = new this.Hash().update(t), Me = 0; Me < t.length; Me++)
    t[Me] ^= 106;
  this.outer = new this.Hash().update(t);
};
Hmac.prototype.update = function(t, Me) {
  return this.inner.update(t, Me), this;
};
Hmac.prototype.digest = function(t) {
  return this.outer.update(this.inner.digest()), this.outer.digest(t);
};
(function(Ae) {
  var t = Ae;
  t.utils = utils$n, t.common = common$5, t.sha = sha$1, t.ripemd = ripemd, t.hmac = hmac$2, t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
})(hash$5);
const hash$4 = /* @__PURE__ */ getDefaultExportFromCjs(hash$5);
var util$1 = {}, types$1 = {}, shams$1 = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var t = {}, Me = Symbol("test"), Ie = Object(Me);
  if (typeof Me == "string" || Object.prototype.toString.call(Me) !== "[object Symbol]" || Object.prototype.toString.call(Ie) !== "[object Symbol]")
    return !1;
  var Pe = 42;
  t[Me] = Pe;
  for (Me in t)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
    return !1;
  var Be = Object.getOwnPropertySymbols(t);
  if (Be.length !== 1 || Be[0] !== Me || !Object.prototype.propertyIsEnumerable.call(t, Me))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var Te = Object.getOwnPropertyDescriptor(t, Me);
    if (Te.value !== Pe || Te.enumerable !== !0)
      return !1;
  }
  return !0;
}, hasSymbols$2 = shams$1, shams = function() {
  return hasSymbols$2() && !!Symbol.toStringTag;
}, esErrors = Error, _eval = EvalError, range = RangeError, ref = ReferenceError, syntax = SyntaxError, type = TypeError, uri = URIError, origSymbol = typeof Symbol < "u" && Symbol, hasSymbolSham = shams$1, hasSymbols$1 = function() {
  return typeof origSymbol != "function" || typeof Symbol != "function" || typeof origSymbol("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : hasSymbolSham();
}, test = {
  __proto__: null,
  foo: {}
}, $Object = Object, hasProto$1 = function() {
  return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
}, ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$3 = Object.prototype.toString, max = Math.max, funcType = "[object Function]", concatty = function(t, Me) {
  for (var Ie = [], Pe = 0; Pe < t.length; Pe += 1)
    Ie[Pe] = t[Pe];
  for (var Be = 0; Be < Me.length; Be += 1)
    Ie[Be + t.length] = Me[Be];
  return Ie;
}, slicy = function(t, Me) {
  for (var Ie = [], Pe = Me, Be = 0; Pe < t.length; Pe += 1, Be += 1)
    Ie[Be] = t[Pe];
  return Ie;
}, joiny = function(Ae, t) {
  for (var Me = "", Ie = 0; Ie < Ae.length; Ie += 1)
    Me += Ae[Ie], Ie + 1 < Ae.length && (Me += t);
  return Me;
}, implementation$1 = function(t) {
  var Me = this;
  if (typeof Me != "function" || toStr$3.apply(Me) !== funcType)
    throw new TypeError(ERROR_MESSAGE + Me);
  for (var Ie = slicy(arguments, 1), Pe, Be = function() {
    if (this instanceof Pe) {
      var Ue = Me.apply(
        this,
        concatty(Ie, arguments)
      );
      return Object(Ue) === Ue ? Ue : this;
    }
    return Me.apply(
      t,
      concatty(Ie, arguments)
    );
  }, Te = max(0, Me.length - Ie.length), je = [], Ve = 0; Ve < Te; Ve++)
    je[Ve] = "$" + Ve;
  if (Pe = Function("binder", "return function (" + joiny(je, ",") + "){ return binder.apply(this,arguments); }")(Be), Me.prototype) {
    var fi = function() {
    };
    fi.prototype = Me.prototype, Pe.prototype = new fi(), fi.prototype = null;
  }
  return Pe;
}, implementation = implementation$1, functionBind = Function.prototype.bind || implementation, call = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$2 = functionBind, hasown = bind$2.call(call, $hasOwn), undefined$1, $Error = esErrors, $EvalError = _eval, $RangeError = range, $ReferenceError = ref, $SyntaxError$1 = syntax, $TypeError$2 = type, $URIError = uri, $Function = Function, getEvalledConstructor = function(Ae) {
  try {
    return $Function('"use strict"; return (' + Ae + ").constructor;")();
  } catch {
  }
}, $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1)
  try {
    $gOPD$1({}, "");
  } catch {
    $gOPD$1 = null;
  }
var throwTypeError = function() {
  throw new $TypeError$2();
}, ThrowTypeError = $gOPD$1 ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols = hasSymbols$1(), hasProto = hasProto$1(), getProto$1 = Object.getPrototypeOf || (hasProto ? function(Ae) {
  return Ae.__proto__;
} : null), needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array), INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$2,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet
};
if (getProto$1)
  try {
    null.error;
  } catch (Ae) {
    var errorProto = getProto$1(getProto$1(Ae));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function Ae(t) {
  var Me;
  if (t === "%AsyncFunction%")
    Me = getEvalledConstructor("async function () {}");
  else if (t === "%GeneratorFunction%")
    Me = getEvalledConstructor("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    Me = getEvalledConstructor("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var Ie = Ae("%AsyncGeneratorFunction%");
    Ie && (Me = Ie.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var Pe = Ae("%AsyncGenerator%");
    Pe && getProto$1 && (Me = getProto$1(Pe.prototype));
  }
  return INTRINSICS[t] = Me, Me;
}, LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind$1 = functionBind, hasOwn = hasown, $concat = bind$1.call(Function.call, Array.prototype.concat), $spliceApply = bind$1.call(Function.apply, Array.prototype.splice), $replace = bind$1.call(Function.call, String.prototype.replace), $strSlice = bind$1.call(Function.call, String.prototype.slice), $exec = bind$1.call(Function.call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function(t) {
  var Me = $strSlice(t, 0, 1), Ie = $strSlice(t, -1);
  if (Me === "%" && Ie !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (Ie === "%" && Me !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var Pe = [];
  return $replace(t, rePropName, function(Be, Te, je, Ve) {
    Pe[Pe.length] = je ? $replace(Ve, reEscapeChar, "$1") : Te || Be;
  }), Pe;
}, getBaseIntrinsic = function(t, Me) {
  var Ie = t, Pe;
  if (hasOwn(LEGACY_ALIASES, Ie) && (Pe = LEGACY_ALIASES[Ie], Ie = "%" + Pe[0] + "%"), hasOwn(INTRINSICS, Ie)) {
    var Be = INTRINSICS[Ie];
    if (Be === needsEval && (Be = doEval(Ie)), typeof Be > "u" && !Me)
      throw new $TypeError$2("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: Pe,
      name: Ie,
      value: Be
    };
  }
  throw new $SyntaxError$1("intrinsic " + t + " does not exist!");
}, getIntrinsic = function(t, Me) {
  if (typeof t != "string" || t.length === 0)
    throw new $TypeError$2("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof Me != "boolean")
    throw new $TypeError$2('"allowMissing" argument must be a boolean');
  if ($exec(/^%?[^%]*%?$/, t) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var Ie = stringToPath(t), Pe = Ie.length > 0 ? Ie[0] : "", Be = getBaseIntrinsic("%" + Pe + "%", Me), Te = Be.name, je = Be.value, Ve = !1, fi = Be.alias;
  fi && (Pe = fi[0], $spliceApply(Ie, $concat([0, 1], fi)));
  for (var Ue = 1, bi = !0; Ue < Ie.length; Ue += 1) {
    var vi = Ie[Ue], mi = $strSlice(vi, 0, 1), _i = $strSlice(vi, -1);
    if ((mi === '"' || mi === "'" || mi === "`" || _i === '"' || _i === "'" || _i === "`") && mi !== _i)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((vi === "constructor" || !bi) && (Ve = !0), Pe += "." + vi, Te = "%" + Pe + "%", hasOwn(INTRINSICS, Te))
      je = INTRINSICS[Te];
    else if (je != null) {
      if (!(vi in je)) {
        if (!Me)
          throw new $TypeError$2("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if ($gOPD$1 && Ue + 1 >= Ie.length) {
        var $i = $gOPD$1(je, vi);
        bi = !!$i, bi && "get" in $i && !("originalValue" in $i.get) ? je = $i.get : je = je[vi];
      } else
        bi = hasOwn(je, vi), je = je[vi];
      bi && !Ve && (INTRINSICS[Te] = je);
    }
  }
  return je;
}, callBind$2 = { exports: {} }, esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var Ae = getIntrinsic, t = Ae("%Object.defineProperty%", !0) || !1;
  if (t)
    try {
      t({}, "a", { value: 1 });
    } catch {
      t = !1;
    }
  return esDefineProperty = t, esDefineProperty;
}
var GetIntrinsic$2 = getIntrinsic, $gOPD = GetIntrinsic$2("%Object.getOwnPropertyDescriptor%", !0);
if ($gOPD)
  try {
    $gOPD([], "length");
  } catch {
    $gOPD = null;
  }
var gopd$1 = $gOPD, $defineProperty$1 = requireEsDefineProperty(), $SyntaxError = syntax, $TypeError$1 = type, gopd = gopd$1, defineDataProperty = function(t, Me, Ie) {
  if (!t || typeof t != "object" && typeof t != "function")
    throw new $TypeError$1("`obj` must be an object or a function`");
  if (typeof Me != "string" && typeof Me != "symbol")
    throw new $TypeError$1("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$1("`loose`, if provided, must be a boolean");
  var Pe = arguments.length > 3 ? arguments[3] : null, Be = arguments.length > 4 ? arguments[4] : null, Te = arguments.length > 5 ? arguments[5] : null, je = arguments.length > 6 ? arguments[6] : !1, Ve = !!gopd && gopd(t, Me);
  if ($defineProperty$1)
    $defineProperty$1(t, Me, {
      configurable: Te === null && Ve ? Ve.configurable : !Te,
      enumerable: Pe === null && Ve ? Ve.enumerable : !Pe,
      value: Ie,
      writable: Be === null && Ve ? Ve.writable : !Be
    });
  else if (je || !Pe && !Be && !Te)
    t[Me] = Ie;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $defineProperty = requireEsDefineProperty(), hasPropertyDescriptors = function() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function() {
  if (!$defineProperty)
    return null;
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors, GetIntrinsic$1 = getIntrinsic, define = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD$1 = gopd$1, $TypeError = type, $floor = GetIntrinsic$1("%Math.floor%"), setFunctionLength = function(t, Me) {
  if (typeof t != "function")
    throw new $TypeError("`fn` is not a function");
  if (typeof Me != "number" || Me < 0 || Me > 4294967295 || $floor(Me) !== Me)
    throw new $TypeError("`length` must be a positive 32-bit integer");
  var Ie = arguments.length > 2 && !!arguments[2], Pe = !0, Be = !0;
  if ("length" in t && gOPD$1) {
    var Te = gOPD$1(t, "length");
    Te && !Te.configurable && (Pe = !1), Te && !Te.writable && (Be = !1);
  }
  return (Pe || Be || !Ie) && (hasDescriptors ? define(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    Me,
    !0,
    !0
  ) : define(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    Me
  )), t;
};
(function(Ae) {
  var t = functionBind, Me = getIntrinsic, Ie = setFunctionLength, Pe = type, Be = Me("%Function.prototype.apply%"), Te = Me("%Function.prototype.call%"), je = Me("%Reflect.apply%", !0) || t.call(Te, Be), Ve = requireEsDefineProperty(), fi = Me("%Math.max%");
  Ae.exports = function(vi) {
    if (typeof vi != "function")
      throw new Pe("a function is required");
    var mi = je(t, Te, arguments);
    return Ie(
      mi,
      1 + fi(0, vi.length - (arguments.length - 1)),
      !0
    );
  };
  var Ue = function() {
    return je(t, Be, arguments);
  };
  Ve ? Ve(Ae.exports, "apply", { value: Ue }) : Ae.exports.apply = Ue;
})(callBind$2);
var callBindExports = callBind$2.exports, GetIntrinsic = getIntrinsic, callBind$1 = callBindExports, $indexOf$1 = callBind$1(GetIntrinsic("String.prototype.indexOf")), callBound$2 = function(t, Me) {
  var Ie = GetIntrinsic(t, !!Me);
  return typeof Ie == "function" && $indexOf$1(t, ".prototype.") > -1 ? callBind$1(Ie) : Ie;
}, hasToStringTag$3 = shams(), callBound$1 = callBound$2, $toString$1 = callBound$1("Object.prototype.toString"), isStandardArguments = function(t) {
  return hasToStringTag$3 && t && typeof t == "object" && Symbol.toStringTag in t ? !1 : $toString$1(t) === "[object Arguments]";
}, isLegacyArguments = function(t) {
  return isStandardArguments(t) ? !0 : t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && $toString$1(t) !== "[object Array]" && $toString$1(t.callee) === "[object Function]";
}, supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments, toStr$2 = Object.prototype.toString, fnToStr$1 = Function.prototype.toString, isFnRegex = /^\s*(?:function)?\*/, hasToStringTag$2 = shams(), getProto = Object.getPrototypeOf, getGeneratorFunc = function() {
  if (!hasToStringTag$2)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, GeneratorFunction, isGeneratorFunction = function(t) {
  if (typeof t != "function")
    return !1;
  if (isFnRegex.test(fnToStr$1.call(t)))
    return !0;
  if (!hasToStringTag$2) {
    var Me = toStr$2.call(t);
    return Me === "[object GeneratorFunction]";
  }
  if (!getProto)
    return !1;
  if (typeof GeneratorFunction > "u") {
    var Ie = getGeneratorFunc();
    GeneratorFunction = Ie ? getProto(Ie) : !1;
  }
  return getProto(t) === GeneratorFunction;
}, fnToStr = Function.prototype.toString, reflectApply = typeof Reflect == "object" && Reflect !== null && Reflect.apply, badArrayLike, isCallableMarker;
if (typeof reflectApply == "function" && typeof Object.defineProperty == "function")
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    }), isCallableMarker = {}, reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (Ae) {
    Ae !== isCallableMarker && (reflectApply = null);
  }
else
  reflectApply = null;
var constructorRegex = /^\s*class\b/, isES6ClassFn = function(t) {
  try {
    var Me = fnToStr.call(t);
    return constructorRegex.test(Me);
  } catch {
    return !1;
  }
}, tryFunctionObject = function(t) {
  try {
    return isES6ClassFn(t) ? !1 : (fnToStr.call(t), !0);
  } catch {
    return !1;
  }
}, toStr$1 = Object.prototype.toString, objectClass = "[object Object]", fnClass = "[object Function]", genClass = "[object GeneratorFunction]", ddaClass = "[object HTMLAllCollection]", ddaClass2 = "[object HTML document.all class]", ddaClass3 = "[object HTMLCollection]", hasToStringTag$1 = typeof Symbol == "function" && !!Symbol.toStringTag, isIE68 = !(0 in [,]), isDDA = function() {
  return !1;
};
if (typeof document == "object") {
  var all = document.all;
  toStr$1.call(all) === toStr$1.call(document.all) && (isDDA = function(t) {
    if ((isIE68 || !t) && (typeof t > "u" || typeof t == "object"))
      try {
        var Me = toStr$1.call(t);
        return (Me === ddaClass || Me === ddaClass2 || Me === ddaClass3 || Me === objectClass) && t("") == null;
      } catch {
      }
    return !1;
  });
}
var isCallable$1 = reflectApply ? function(t) {
  if (isDDA(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  try {
    reflectApply(t, null, badArrayLike);
  } catch (Me) {
    if (Me !== isCallableMarker)
      return !1;
  }
  return !isES6ClassFn(t) && tryFunctionObject(t);
} : function(t) {
  if (isDDA(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  if (hasToStringTag$1)
    return tryFunctionObject(t);
  if (isES6ClassFn(t))
    return !1;
  var Me = toStr$1.call(t);
  return Me !== fnClass && Me !== genClass && !/^\[object HTML/.test(Me) ? !1 : tryFunctionObject(t);
}, isCallable = isCallable$1, toStr = Object.prototype.toString, hasOwnProperty = Object.prototype.hasOwnProperty, forEachArray = function(t, Me, Ie) {
  for (var Pe = 0, Be = t.length; Pe < Be; Pe++)
    hasOwnProperty.call(t, Pe) && (Ie == null ? Me(t[Pe], Pe, t) : Me.call(Ie, t[Pe], Pe, t));
}, forEachString = function(t, Me, Ie) {
  for (var Pe = 0, Be = t.length; Pe < Be; Pe++)
    Ie == null ? Me(t.charAt(Pe), Pe, t) : Me.call(Ie, t.charAt(Pe), Pe, t);
}, forEachObject = function(t, Me, Ie) {
  for (var Pe in t)
    hasOwnProperty.call(t, Pe) && (Ie == null ? Me(t[Pe], Pe, t) : Me.call(Ie, t[Pe], Pe, t));
}, forEach$1 = function(t, Me, Ie) {
  if (!isCallable(Me))
    throw new TypeError("iterator must be a function");
  var Pe;
  arguments.length >= 3 && (Pe = Ie), toStr.call(t) === "[object Array]" ? forEachArray(t, Me, Pe) : typeof t == "string" ? forEachString(t, Me, Pe) : forEachObject(t, Me, Pe);
}, forEach_1 = forEach$1, possibleTypedArrayNames = [
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], possibleNames = possibleTypedArrayNames, g$5 = typeof globalThis > "u" ? commonjsGlobal : globalThis, availableTypedArrays$1 = function() {
  for (var t = [], Me = 0; Me < possibleNames.length; Me++)
    typeof g$5[possibleNames[Me]] == "function" && (t[t.length] = possibleNames[Me]);
  return t;
}, forEach = forEach_1, availableTypedArrays = availableTypedArrays$1, callBind = callBindExports, callBound = callBound$2, gOPD = gopd$1, $toString = callBound("Object.prototype.toString"), hasToStringTag = shams(), g$4 = typeof globalThis > "u" ? commonjsGlobal : globalThis, typedArrays = availableTypedArrays(), $slice = callBound("String.prototype.slice"), getPrototypeOf = Object.getPrototypeOf, $indexOf = callBound("Array.prototype.indexOf", !0) || function(t, Me) {
  for (var Ie = 0; Ie < t.length; Ie += 1)
    if (t[Ie] === Me)
      return Ie;
  return -1;
}, cache = { __proto__: null };
hasToStringTag && gOPD && getPrototypeOf ? forEach(typedArrays, function(Ae) {
  var t = new g$4[Ae]();
  if (Symbol.toStringTag in t) {
    var Me = getPrototypeOf(t), Ie = gOPD(Me, Symbol.toStringTag);
    if (!Ie) {
      var Pe = getPrototypeOf(Me);
      Ie = gOPD(Pe, Symbol.toStringTag);
    }
    cache["$" + Ae] = callBind(Ie.get);
  }
}) : forEach(typedArrays, function(Ae) {
  var t = new g$4[Ae](), Me = t.slice || t.set;
  Me && (cache["$" + Ae] = callBind(Me));
});
var tryTypedArrays = function(t) {
  var Me = !1;
  return forEach(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    cache,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(Ie, Pe) {
      if (!Me)
        try {
          "$" + Ie(t) === Pe && (Me = $slice(Pe, 1));
        } catch {
        }
    }
  ), Me;
}, trySlices = function(t) {
  var Me = !1;
  return forEach(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    cache,
    /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
    function(Ie, Pe) {
      if (!Me)
        try {
          Ie(t), Me = $slice(Pe, 1);
        } catch {
        }
    }
  ), Me;
}, whichTypedArray$1 = function(t) {
  if (!t || typeof t != "object")
    return !1;
  if (!hasToStringTag) {
    var Me = $slice($toString(t), 8, -1);
    return $indexOf(typedArrays, Me) > -1 ? Me : Me !== "Object" ? !1 : trySlices(t);
  }
  return gOPD ? tryTypedArrays(t) : null;
}, whichTypedArray = whichTypedArray$1, isTypedArray = function(t) {
  return !!whichTypedArray(t);
};
(function(Ae) {
  var t = isArguments, Me = isGeneratorFunction, Ie = whichTypedArray$1, Pe = isTypedArray;
  function Be(hs) {
    return hs.call.bind(hs);
  }
  var Te = typeof BigInt < "u", je = typeof Symbol < "u", Ve = Be(Object.prototype.toString), fi = Be(Number.prototype.valueOf), Ue = Be(String.prototype.valueOf), bi = Be(Boolean.prototype.valueOf);
  if (Te)
    var vi = Be(BigInt.prototype.valueOf);
  if (je)
    var mi = Be(Symbol.prototype.valueOf);
  function _i(hs, fa) {
    if (typeof hs != "object")
      return !1;
    try {
      return fa(hs), !0;
    } catch {
      return !1;
    }
  }
  Ae.isArgumentsObject = t, Ae.isGeneratorFunction = Me, Ae.isTypedArray = Pe;
  function $i(hs) {
    return typeof Promise < "u" && hs instanceof Promise || hs !== null && typeof hs == "object" && typeof hs.then == "function" && typeof hs.catch == "function";
  }
  Ae.isPromise = $i;
  function Ci(hs) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(hs) : Pe(hs) || Wi(hs);
  }
  Ae.isArrayBufferView = Ci;
  function Ui(hs) {
    return Ie(hs) === "Uint8Array";
  }
  Ae.isUint8Array = Ui;
  function ki(hs) {
    return Ie(hs) === "Uint8ClampedArray";
  }
  Ae.isUint8ClampedArray = ki;
  function Ji(hs) {
    return Ie(hs) === "Uint16Array";
  }
  Ae.isUint16Array = Ji;
  function Hi(hs) {
    return Ie(hs) === "Uint32Array";
  }
  Ae.isUint32Array = Hi;
  function Zi(hs) {
    return Ie(hs) === "Int8Array";
  }
  Ae.isInt8Array = Zi;
  function Qi(hs) {
    return Ie(hs) === "Int16Array";
  }
  Ae.isInt16Array = Qi;
  function Bi(hs) {
    return Ie(hs) === "Int32Array";
  }
  Ae.isInt32Array = Bi;
  function Xi(hs) {
    return Ie(hs) === "Float32Array";
  }
  Ae.isFloat32Array = Xi;
  function ns(hs) {
    return Ie(hs) === "Float64Array";
  }
  Ae.isFloat64Array = ns;
  function ls(hs) {
    return Ie(hs) === "BigInt64Array";
  }
  Ae.isBigInt64Array = ls;
  function vn(hs) {
    return Ie(hs) === "BigUint64Array";
  }
  Ae.isBigUint64Array = vn;
  function Mi(hs) {
    return Ve(hs) === "[object Map]";
  }
  Mi.working = typeof Map < "u" && Mi(/* @__PURE__ */ new Map());
  function Ai(hs) {
    return typeof Map > "u" ? !1 : Mi.working ? Mi(hs) : hs instanceof Map;
  }
  Ae.isMap = Ai;
  function wi(hs) {
    return Ve(hs) === "[object Set]";
  }
  wi.working = typeof Set < "u" && wi(/* @__PURE__ */ new Set());
  function Ei(hs) {
    return typeof Set > "u" ? !1 : wi.working ? wi(hs) : hs instanceof Set;
  }
  Ae.isSet = Ei;
  function Ti(hs) {
    return Ve(hs) === "[object WeakMap]";
  }
  Ti.working = typeof WeakMap < "u" && Ti(/* @__PURE__ */ new WeakMap());
  function Pi(hs) {
    return typeof WeakMap > "u" ? !1 : Ti.working ? Ti(hs) : hs instanceof WeakMap;
  }
  Ae.isWeakMap = Pi;
  function qi(hs) {
    return Ve(hs) === "[object WeakSet]";
  }
  qi.working = typeof WeakSet < "u" && qi(/* @__PURE__ */ new WeakSet());
  function Oi(hs) {
    return qi(hs);
  }
  Ae.isWeakSet = Oi;
  function Si(hs) {
    return Ve(hs) === "[object ArrayBuffer]";
  }
  Si.working = typeof ArrayBuffer < "u" && Si(new ArrayBuffer());
  function Ni(hs) {
    return typeof ArrayBuffer > "u" ? !1 : Si.working ? Si(hs) : hs instanceof ArrayBuffer;
  }
  Ae.isArrayBuffer = Ni;
  function xi(hs) {
    return Ve(hs) === "[object DataView]";
  }
  xi.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && xi(new DataView(new ArrayBuffer(1), 0, 1));
  function Wi(hs) {
    return typeof DataView > "u" ? !1 : xi.working ? xi(hs) : hs instanceof DataView;
  }
  Ae.isDataView = Wi;
  var ts = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function Ki(hs) {
    return Ve(hs) === "[object SharedArrayBuffer]";
  }
  function fn(hs) {
    return typeof ts > "u" ? !1 : (typeof Ki.working > "u" && (Ki.working = Ki(new ts())), Ki.working ? Ki(hs) : hs instanceof ts);
  }
  Ae.isSharedArrayBuffer = fn;
  function Ii(hs) {
    return Ve(hs) === "[object AsyncFunction]";
  }
  Ae.isAsyncFunction = Ii;
  function Fi(hs) {
    return Ve(hs) === "[object Map Iterator]";
  }
  Ae.isMapIterator = Fi;
  function Gi(hs) {
    return Ve(hs) === "[object Set Iterator]";
  }
  Ae.isSetIterator = Gi;
  function Ri(hs) {
    return Ve(hs) === "[object Generator]";
  }
  Ae.isGeneratorObject = Ri;
  function ji(hs) {
    return Ve(hs) === "[object WebAssembly.Module]";
  }
  Ae.isWebAssemblyCompiledModule = ji;
  function Vi(hs) {
    return _i(hs, fi);
  }
  Ae.isNumberObject = Vi;
  function is(hs) {
    return _i(hs, Ue);
  }
  Ae.isStringObject = is;
  function os(hs) {
    return _i(hs, bi);
  }
  Ae.isBooleanObject = os;
  function ds(hs) {
    return Te && _i(hs, vi);
  }
  Ae.isBigIntObject = ds;
  function ps(hs) {
    return je && _i(hs, mi);
  }
  Ae.isSymbolObject = ps;
  function ea(hs) {
    return Vi(hs) || is(hs) || os(hs) || ds(hs) || ps(hs);
  }
  Ae.isBoxedPrimitive = ea;
  function ia(hs) {
    return typeof Uint8Array < "u" && (Ni(hs) || fn(hs));
  }
  Ae.isAnyArrayBuffer = ia, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(hs) {
    Object.defineProperty(Ae, hs, {
      enumerable: !1,
      value: function() {
        throw new Error(hs + " is not supported in userland");
      }
    });
  });
})(types$1);
var isBufferBrowser = function(t) {
  return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
};
(function(Ae) {
  var t = Object.getOwnPropertyDescriptors || function(Wi) {
    for (var ts = Object.keys(Wi), Ki = {}, fn = 0; fn < ts.length; fn++)
      Ki[ts[fn]] = Object.getOwnPropertyDescriptor(Wi, ts[fn]);
    return Ki;
  }, Me = /%[sdj%]/g;
  Ae.format = function(xi) {
    if (!Zi(xi)) {
      for (var Wi = [], ts = 0; ts < arguments.length; ts++)
        Wi.push(Te(arguments[ts]));
      return Wi.join(" ");
    }
    for (var ts = 1, Ki = arguments, fn = Ki.length, Ii = String(xi).replace(Me, function(Gi) {
      if (Gi === "%%") return "%";
      if (ts >= fn) return Gi;
      switch (Gi) {
        case "%s":
          return String(Ki[ts++]);
        case "%d":
          return Number(Ki[ts++]);
        case "%j":
          try {
            return JSON.stringify(Ki[ts++]);
          } catch {
            return "[Circular]";
          }
        default:
          return Gi;
      }
    }), Fi = Ki[ts]; ts < fn; Fi = Ki[++ts])
      ki(Fi) || !ns(Fi) ? Ii += " " + Fi : Ii += " " + Te(Fi);
    return Ii;
  }, Ae.deprecate = function(xi, Wi) {
    if (typeof process$1 < "u" && process$1.noDeprecation === !0)
      return xi;
    if (typeof process$1 > "u")
      return function() {
        return Ae.deprecate(xi, Wi).apply(this, arguments);
      };
    var ts = !1;
    function Ki() {
      if (!ts) {
        if (process$1.throwDeprecation)
          throw new Error(Wi);
        process$1.traceDeprecation ? console.trace(Wi) : console.error(Wi), ts = !0;
      }
      return xi.apply(this, arguments);
    }
    return Ki;
  };
  var Ie = {}, Pe = /^$/;
  if (process$1.env.NODE_DEBUG) {
    var Be = process$1.env.NODE_DEBUG;
    Be = Be.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), Pe = new RegExp("^" + Be + "$", "i");
  }
  Ae.debuglog = function(xi) {
    if (xi = xi.toUpperCase(), !Ie[xi])
      if (Pe.test(xi)) {
        var Wi = process$1.pid;
        Ie[xi] = function() {
          var ts = Ae.format.apply(Ae, arguments);
          console.error("%s %d: %s", xi, Wi, ts);
        };
      } else
        Ie[xi] = function() {
        };
    return Ie[xi];
  };
  function Te(xi, Wi) {
    var ts = {
      seen: [],
      stylize: Ve
    };
    return arguments.length >= 3 && (ts.depth = arguments[2]), arguments.length >= 4 && (ts.colors = arguments[3]), Ui(Wi) ? ts.showHidden = Wi : Wi && Ae._extend(ts, Wi), Bi(ts.showHidden) && (ts.showHidden = !1), Bi(ts.depth) && (ts.depth = 2), Bi(ts.colors) && (ts.colors = !1), Bi(ts.customInspect) && (ts.customInspect = !0), ts.colors && (ts.stylize = je), Ue(ts, xi, ts.depth);
  }
  Ae.inspect = Te, Te.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, Te.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function je(xi, Wi) {
    var ts = Te.styles[Wi];
    return ts ? "\x1B[" + Te.colors[ts][0] + "m" + xi + "\x1B[" + Te.colors[ts][1] + "m" : xi;
  }
  function Ve(xi, Wi) {
    return xi;
  }
  function fi(xi) {
    var Wi = {};
    return xi.forEach(function(ts, Ki) {
      Wi[ts] = !0;
    }), Wi;
  }
  function Ue(xi, Wi, ts) {
    if (xi.customInspect && Wi && Mi(Wi.inspect) && // Filter out the util module, it's inspect function is special
    Wi.inspect !== Ae.inspect && // Also filter out any prototype objects using the circular check.
    !(Wi.constructor && Wi.constructor.prototype === Wi)) {
      var Ki = Wi.inspect(ts, xi);
      return Zi(Ki) || (Ki = Ue(xi, Ki, ts)), Ki;
    }
    var fn = bi(xi, Wi);
    if (fn)
      return fn;
    var Ii = Object.keys(Wi), Fi = fi(Ii);
    if (xi.showHidden && (Ii = Object.getOwnPropertyNames(Wi)), vn(Wi) && (Ii.indexOf("message") >= 0 || Ii.indexOf("description") >= 0))
      return vi(Wi);
    if (Ii.length === 0) {
      if (Mi(Wi)) {
        var Gi = Wi.name ? ": " + Wi.name : "";
        return xi.stylize("[Function" + Gi + "]", "special");
      }
      if (Xi(Wi))
        return xi.stylize(RegExp.prototype.toString.call(Wi), "regexp");
      if (ls(Wi))
        return xi.stylize(Date.prototype.toString.call(Wi), "date");
      if (vn(Wi))
        return vi(Wi);
    }
    var Ri = "", ji = !1, Vi = ["{", "}"];
    if (Ci(Wi) && (ji = !0, Vi = ["[", "]"]), Mi(Wi)) {
      var is = Wi.name ? ": " + Wi.name : "";
      Ri = " [Function" + is + "]";
    }
    if (Xi(Wi) && (Ri = " " + RegExp.prototype.toString.call(Wi)), ls(Wi) && (Ri = " " + Date.prototype.toUTCString.call(Wi)), vn(Wi) && (Ri = " " + vi(Wi)), Ii.length === 0 && (!ji || Wi.length == 0))
      return Vi[0] + Ri + Vi[1];
    if (ts < 0)
      return Xi(Wi) ? xi.stylize(RegExp.prototype.toString.call(Wi), "regexp") : xi.stylize("[Object]", "special");
    xi.seen.push(Wi);
    var os;
    return ji ? os = mi(xi, Wi, ts, Fi, Ii) : os = Ii.map(function(ds) {
      return _i(xi, Wi, ts, Fi, ds, ji);
    }), xi.seen.pop(), $i(os, Ri, Vi);
  }
  function bi(xi, Wi) {
    if (Bi(Wi))
      return xi.stylize("undefined", "undefined");
    if (Zi(Wi)) {
      var ts = "'" + JSON.stringify(Wi).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return xi.stylize(ts, "string");
    }
    if (Hi(Wi))
      return xi.stylize("" + Wi, "number");
    if (Ui(Wi))
      return xi.stylize("" + Wi, "boolean");
    if (ki(Wi))
      return xi.stylize("null", "null");
  }
  function vi(xi) {
    return "[" + Error.prototype.toString.call(xi) + "]";
  }
  function mi(xi, Wi, ts, Ki, fn) {
    for (var Ii = [], Fi = 0, Gi = Wi.length; Fi < Gi; ++Fi)
      qi(Wi, String(Fi)) ? Ii.push(_i(
        xi,
        Wi,
        ts,
        Ki,
        String(Fi),
        !0
      )) : Ii.push("");
    return fn.forEach(function(Ri) {
      Ri.match(/^\d+$/) || Ii.push(_i(
        xi,
        Wi,
        ts,
        Ki,
        Ri,
        !0
      ));
    }), Ii;
  }
  function _i(xi, Wi, ts, Ki, fn, Ii) {
    var Fi, Gi, Ri;
    if (Ri = Object.getOwnPropertyDescriptor(Wi, fn) || { value: Wi[fn] }, Ri.get ? Ri.set ? Gi = xi.stylize("[Getter/Setter]", "special") : Gi = xi.stylize("[Getter]", "special") : Ri.set && (Gi = xi.stylize("[Setter]", "special")), qi(Ki, fn) || (Fi = "[" + fn + "]"), Gi || (xi.seen.indexOf(Ri.value) < 0 ? (ki(ts) ? Gi = Ue(xi, Ri.value, null) : Gi = Ue(xi, Ri.value, ts - 1), Gi.indexOf(`
`) > -1 && (Ii ? Gi = Gi.split(`
`).map(function(ji) {
      return "  " + ji;
    }).join(`
`).slice(2) : Gi = `
` + Gi.split(`
`).map(function(ji) {
      return "   " + ji;
    }).join(`
`))) : Gi = xi.stylize("[Circular]", "special")), Bi(Fi)) {
      if (Ii && fn.match(/^\d+$/))
        return Gi;
      Fi = JSON.stringify("" + fn), Fi.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Fi = Fi.slice(1, -1), Fi = xi.stylize(Fi, "name")) : (Fi = Fi.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Fi = xi.stylize(Fi, "string"));
    }
    return Fi + ": " + Gi;
  }
  function $i(xi, Wi, ts) {
    var Ki = xi.reduce(function(fn, Ii) {
      return Ii.indexOf(`
`) >= 0, fn + Ii.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return Ki > 60 ? ts[0] + (Wi === "" ? "" : Wi + `
 `) + " " + xi.join(`,
  `) + " " + ts[1] : ts[0] + Wi + " " + xi.join(", ") + " " + ts[1];
  }
  Ae.types = types$1;
  function Ci(xi) {
    return Array.isArray(xi);
  }
  Ae.isArray = Ci;
  function Ui(xi) {
    return typeof xi == "boolean";
  }
  Ae.isBoolean = Ui;
  function ki(xi) {
    return xi === null;
  }
  Ae.isNull = ki;
  function Ji(xi) {
    return xi == null;
  }
  Ae.isNullOrUndefined = Ji;
  function Hi(xi) {
    return typeof xi == "number";
  }
  Ae.isNumber = Hi;
  function Zi(xi) {
    return typeof xi == "string";
  }
  Ae.isString = Zi;
  function Qi(xi) {
    return typeof xi == "symbol";
  }
  Ae.isSymbol = Qi;
  function Bi(xi) {
    return xi === void 0;
  }
  Ae.isUndefined = Bi;
  function Xi(xi) {
    return ns(xi) && wi(xi) === "[object RegExp]";
  }
  Ae.isRegExp = Xi, Ae.types.isRegExp = Xi;
  function ns(xi) {
    return typeof xi == "object" && xi !== null;
  }
  Ae.isObject = ns;
  function ls(xi) {
    return ns(xi) && wi(xi) === "[object Date]";
  }
  Ae.isDate = ls, Ae.types.isDate = ls;
  function vn(xi) {
    return ns(xi) && (wi(xi) === "[object Error]" || xi instanceof Error);
  }
  Ae.isError = vn, Ae.types.isNativeError = vn;
  function Mi(xi) {
    return typeof xi == "function";
  }
  Ae.isFunction = Mi;
  function Ai(xi) {
    return xi === null || typeof xi == "boolean" || typeof xi == "number" || typeof xi == "string" || typeof xi == "symbol" || // ES6 symbol
    typeof xi > "u";
  }
  Ae.isPrimitive = Ai, Ae.isBuffer = isBufferBrowser;
  function wi(xi) {
    return Object.prototype.toString.call(xi);
  }
  function Ei(xi) {
    return xi < 10 ? "0" + xi.toString(10) : xi.toString(10);
  }
  var Ti = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function Pi() {
    var xi = /* @__PURE__ */ new Date(), Wi = [
      Ei(xi.getHours()),
      Ei(xi.getMinutes()),
      Ei(xi.getSeconds())
    ].join(":");
    return [xi.getDate(), Ti[xi.getMonth()], Wi].join(" ");
  }
  Ae.log = function() {
    console.log("%s - %s", Pi(), Ae.format.apply(Ae, arguments));
  }, Ae.inherits = inherits_browserExports, Ae._extend = function(xi, Wi) {
    if (!Wi || !ns(Wi)) return xi;
    for (var ts = Object.keys(Wi), Ki = ts.length; Ki--; )
      xi[ts[Ki]] = Wi[ts[Ki]];
    return xi;
  };
  function qi(xi, Wi) {
    return Object.prototype.hasOwnProperty.call(xi, Wi);
  }
  var Oi = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  Ae.promisify = function(Wi) {
    if (typeof Wi != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (Oi && Wi[Oi]) {
      var ts = Wi[Oi];
      if (typeof ts != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(ts, Oi, {
        value: ts,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), ts;
    }
    function ts() {
      for (var Ki, fn, Ii = new Promise(function(Ri, ji) {
        Ki = Ri, fn = ji;
      }), Fi = [], Gi = 0; Gi < arguments.length; Gi++)
        Fi.push(arguments[Gi]);
      Fi.push(function(Ri, ji) {
        Ri ? fn(Ri) : Ki(ji);
      });
      try {
        Wi.apply(this, Fi);
      } catch (Ri) {
        fn(Ri);
      }
      return Ii;
    }
    return Object.setPrototypeOf(ts, Object.getPrototypeOf(Wi)), Oi && Object.defineProperty(ts, Oi, {
      value: ts,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      ts,
      t(Wi)
    );
  }, Ae.promisify.custom = Oi;
  function Si(xi, Wi) {
    if (!xi) {
      var ts = new Error("Promise was rejected with a falsy value");
      ts.reason = xi, xi = ts;
    }
    return Wi(xi);
  }
  function Ni(xi) {
    if (typeof xi != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function Wi() {
      for (var ts = [], Ki = 0; Ki < arguments.length; Ki++)
        ts.push(arguments[Ki]);
      var fn = ts.pop();
      if (typeof fn != "function")
        throw new TypeError("The last argument must be of type Function");
      var Ii = this, Fi = function() {
        return fn.apply(Ii, arguments);
      };
      xi.apply(this, ts).then(
        function(Gi) {
          process$1.nextTick(Fi.bind(null, null, Gi));
        },
        function(Gi) {
          process$1.nextTick(Si.bind(null, Gi, Fi));
        }
      );
    }
    return Object.setPrototypeOf(Wi, Object.getPrototypeOf(xi)), Object.defineProperties(
      Wi,
      t(xi)
    ), Wi;
  }
  Ae.callbackify = Ni;
})(util$1);
var elliptic = {};
const name = "elliptic", version$5 = "6.5.7", description = "EC cryptography", main = "lib/elliptic.js", files = [
  "lib"
], scripts = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author = "Fedor Indutny <fedor@indutny.com>", license = "MIT", bugs = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage = "https://github.com/indutny/elliptic", devDependencies = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0$2 = {
  name,
  version: version$5,
  description,
  main,
  files,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  dependencies
};
var utils$d = {}, bn$2 = { exports: {} };
bn$2.exports;
(function(Ae) {
  (function(t, Me) {
    function Ie(vn, Mi) {
      if (!vn) throw new Error(Mi || "Assertion failed");
    }
    function Pe(vn, Mi) {
      vn.super_ = Mi;
      var Ai = function() {
      };
      Ai.prototype = Mi.prototype, vn.prototype = new Ai(), vn.prototype.constructor = vn;
    }
    function Be(vn, Mi, Ai) {
      if (Be.isBN(vn))
        return vn;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, vn !== null && ((Mi === "le" || Mi === "be") && (Ai = Mi, Mi = 10), this._init(vn || 0, Mi || 10, Ai || "be"));
    }
    typeof t == "object" ? t.exports = Be : Me.BN = Be, Be.BN = Be, Be.wordSize = 26;
    var Te;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Te = window.Buffer : Te = require$$0$3.Buffer;
    } catch {
    }
    Be.isBN = function(Mi) {
      return Mi instanceof Be ? !0 : Mi !== null && typeof Mi == "object" && Mi.constructor.wordSize === Be.wordSize && Array.isArray(Mi.words);
    }, Be.max = function(Mi, Ai) {
      return Mi.cmp(Ai) > 0 ? Mi : Ai;
    }, Be.min = function(Mi, Ai) {
      return Mi.cmp(Ai) < 0 ? Mi : Ai;
    }, Be.prototype._init = function(Mi, Ai, wi) {
      if (typeof Mi == "number")
        return this._initNumber(Mi, Ai, wi);
      if (typeof Mi == "object")
        return this._initArray(Mi, Ai, wi);
      Ai === "hex" && (Ai = 16), Ie(Ai === (Ai | 0) && Ai >= 2 && Ai <= 36), Mi = Mi.toString().replace(/\s+/g, "");
      var Ei = 0;
      Mi[0] === "-" && (Ei++, this.negative = 1), Ei < Mi.length && (Ai === 16 ? this._parseHex(Mi, Ei, wi) : (this._parseBase(Mi, Ai, Ei), wi === "le" && this._initArray(this.toArray(), Ai, wi)));
    }, Be.prototype._initNumber = function(Mi, Ai, wi) {
      Mi < 0 && (this.negative = 1, Mi = -Mi), Mi < 67108864 ? (this.words = [Mi & 67108863], this.length = 1) : Mi < 4503599627370496 ? (this.words = [
        Mi & 67108863,
        Mi / 67108864 & 67108863
      ], this.length = 2) : (Ie(Mi < 9007199254740992), this.words = [
        Mi & 67108863,
        Mi / 67108864 & 67108863,
        1
      ], this.length = 3), wi === "le" && this._initArray(this.toArray(), Ai, wi);
    }, Be.prototype._initArray = function(Mi, Ai, wi) {
      if (Ie(typeof Mi.length == "number"), Mi.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(Mi.length / 3), this.words = new Array(this.length);
      for (var Ei = 0; Ei < this.length; Ei++)
        this.words[Ei] = 0;
      var Ti, Pi, qi = 0;
      if (wi === "be")
        for (Ei = Mi.length - 1, Ti = 0; Ei >= 0; Ei -= 3)
          Pi = Mi[Ei] | Mi[Ei - 1] << 8 | Mi[Ei - 2] << 16, this.words[Ti] |= Pi << qi & 67108863, this.words[Ti + 1] = Pi >>> 26 - qi & 67108863, qi += 24, qi >= 26 && (qi -= 26, Ti++);
      else if (wi === "le")
        for (Ei = 0, Ti = 0; Ei < Mi.length; Ei += 3)
          Pi = Mi[Ei] | Mi[Ei + 1] << 8 | Mi[Ei + 2] << 16, this.words[Ti] |= Pi << qi & 67108863, this.words[Ti + 1] = Pi >>> 26 - qi & 67108863, qi += 24, qi >= 26 && (qi -= 26, Ti++);
      return this.strip();
    };
    function je(vn, Mi) {
      var Ai = vn.charCodeAt(Mi);
      return Ai >= 65 && Ai <= 70 ? Ai - 55 : Ai >= 97 && Ai <= 102 ? Ai - 87 : Ai - 48 & 15;
    }
    function Ve(vn, Mi, Ai) {
      var wi = je(vn, Ai);
      return Ai - 1 >= Mi && (wi |= je(vn, Ai - 1) << 4), wi;
    }
    Be.prototype._parseHex = function(Mi, Ai, wi) {
      this.length = Math.ceil((Mi.length - Ai) / 6), this.words = new Array(this.length);
      for (var Ei = 0; Ei < this.length; Ei++)
        this.words[Ei] = 0;
      var Ti = 0, Pi = 0, qi;
      if (wi === "be")
        for (Ei = Mi.length - 1; Ei >= Ai; Ei -= 2)
          qi = Ve(Mi, Ai, Ei) << Ti, this.words[Pi] |= qi & 67108863, Ti >= 18 ? (Ti -= 18, Pi += 1, this.words[Pi] |= qi >>> 26) : Ti += 8;
      else {
        var Oi = Mi.length - Ai;
        for (Ei = Oi % 2 === 0 ? Ai + 1 : Ai; Ei < Mi.length; Ei += 2)
          qi = Ve(Mi, Ai, Ei) << Ti, this.words[Pi] |= qi & 67108863, Ti >= 18 ? (Ti -= 18, Pi += 1, this.words[Pi] |= qi >>> 26) : Ti += 8;
      }
      this.strip();
    };
    function fi(vn, Mi, Ai, wi) {
      for (var Ei = 0, Ti = Math.min(vn.length, Ai), Pi = Mi; Pi < Ti; Pi++) {
        var qi = vn.charCodeAt(Pi) - 48;
        Ei *= wi, qi >= 49 ? Ei += qi - 49 + 10 : qi >= 17 ? Ei += qi - 17 + 10 : Ei += qi;
      }
      return Ei;
    }
    Be.prototype._parseBase = function(Mi, Ai, wi) {
      this.words = [0], this.length = 1;
      for (var Ei = 0, Ti = 1; Ti <= 67108863; Ti *= Ai)
        Ei++;
      Ei--, Ti = Ti / Ai | 0;
      for (var Pi = Mi.length - wi, qi = Pi % Ei, Oi = Math.min(Pi, Pi - qi) + wi, Si = 0, Ni = wi; Ni < Oi; Ni += Ei)
        Si = fi(Mi, Ni, Ni + Ei, Ai), this.imuln(Ti), this.words[0] + Si < 67108864 ? this.words[0] += Si : this._iaddn(Si);
      if (qi !== 0) {
        var xi = 1;
        for (Si = fi(Mi, Ni, Mi.length, Ai), Ni = 0; Ni < qi; Ni++)
          xi *= Ai;
        this.imuln(xi), this.words[0] + Si < 67108864 ? this.words[0] += Si : this._iaddn(Si);
      }
      this.strip();
    }, Be.prototype.copy = function(Mi) {
      Mi.words = new Array(this.length);
      for (var Ai = 0; Ai < this.length; Ai++)
        Mi.words[Ai] = this.words[Ai];
      Mi.length = this.length, Mi.negative = this.negative, Mi.red = this.red;
    }, Be.prototype.clone = function() {
      var Mi = new Be(null);
      return this.copy(Mi), Mi;
    }, Be.prototype._expand = function(Mi) {
      for (; this.length < Mi; )
        this.words[this.length++] = 0;
      return this;
    }, Be.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, Be.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, Be.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var Ue = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], bi = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], vi = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    Be.prototype.toString = function(Mi, Ai) {
      Mi = Mi || 10, Ai = Ai | 0 || 1;
      var wi;
      if (Mi === 16 || Mi === "hex") {
        wi = "";
        for (var Ei = 0, Ti = 0, Pi = 0; Pi < this.length; Pi++) {
          var qi = this.words[Pi], Oi = ((qi << Ei | Ti) & 16777215).toString(16);
          Ti = qi >>> 24 - Ei & 16777215, Ti !== 0 || Pi !== this.length - 1 ? wi = Ue[6 - Oi.length] + Oi + wi : wi = Oi + wi, Ei += 2, Ei >= 26 && (Ei -= 26, Pi--);
        }
        for (Ti !== 0 && (wi = Ti.toString(16) + wi); wi.length % Ai !== 0; )
          wi = "0" + wi;
        return this.negative !== 0 && (wi = "-" + wi), wi;
      }
      if (Mi === (Mi | 0) && Mi >= 2 && Mi <= 36) {
        var Si = bi[Mi], Ni = vi[Mi];
        wi = "";
        var xi = this.clone();
        for (xi.negative = 0; !xi.isZero(); ) {
          var Wi = xi.modn(Ni).toString(Mi);
          xi = xi.idivn(Ni), xi.isZero() ? wi = Wi + wi : wi = Ue[Si - Wi.length] + Wi + wi;
        }
        for (this.isZero() && (wi = "0" + wi); wi.length % Ai !== 0; )
          wi = "0" + wi;
        return this.negative !== 0 && (wi = "-" + wi), wi;
      }
      Ie(!1, "Base should be between 2 and 36");
    }, Be.prototype.toNumber = function() {
      var Mi = this.words[0];
      return this.length === 2 ? Mi += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? Mi += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && Ie(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -Mi : Mi;
    }, Be.prototype.toJSON = function() {
      return this.toString(16);
    }, Be.prototype.toBuffer = function(Mi, Ai) {
      return Ie(typeof Te < "u"), this.toArrayLike(Te, Mi, Ai);
    }, Be.prototype.toArray = function(Mi, Ai) {
      return this.toArrayLike(Array, Mi, Ai);
    }, Be.prototype.toArrayLike = function(Mi, Ai, wi) {
      var Ei = this.byteLength(), Ti = wi || Math.max(1, Ei);
      Ie(Ei <= Ti, "byte array longer than desired length"), Ie(Ti > 0, "Requested array length <= 0"), this.strip();
      var Pi = Ai === "le", qi = new Mi(Ti), Oi, Si, Ni = this.clone();
      if (Pi) {
        for (Si = 0; !Ni.isZero(); Si++)
          Oi = Ni.andln(255), Ni.iushrn(8), qi[Si] = Oi;
        for (; Si < Ti; Si++)
          qi[Si] = 0;
      } else {
        for (Si = 0; Si < Ti - Ei; Si++)
          qi[Si] = 0;
        for (Si = 0; !Ni.isZero(); Si++)
          Oi = Ni.andln(255), Ni.iushrn(8), qi[Ti - Si - 1] = Oi;
      }
      return qi;
    }, Math.clz32 ? Be.prototype._countBits = function(Mi) {
      return 32 - Math.clz32(Mi);
    } : Be.prototype._countBits = function(Mi) {
      var Ai = Mi, wi = 0;
      return Ai >= 4096 && (wi += 13, Ai >>>= 13), Ai >= 64 && (wi += 7, Ai >>>= 7), Ai >= 8 && (wi += 4, Ai >>>= 4), Ai >= 2 && (wi += 2, Ai >>>= 2), wi + Ai;
    }, Be.prototype._zeroBits = function(Mi) {
      if (Mi === 0) return 26;
      var Ai = Mi, wi = 0;
      return Ai & 8191 || (wi += 13, Ai >>>= 13), Ai & 127 || (wi += 7, Ai >>>= 7), Ai & 15 || (wi += 4, Ai >>>= 4), Ai & 3 || (wi += 2, Ai >>>= 2), Ai & 1 || wi++, wi;
    }, Be.prototype.bitLength = function() {
      var Mi = this.words[this.length - 1], Ai = this._countBits(Mi);
      return (this.length - 1) * 26 + Ai;
    };
    function mi(vn) {
      for (var Mi = new Array(vn.bitLength()), Ai = 0; Ai < Mi.length; Ai++) {
        var wi = Ai / 26 | 0, Ei = Ai % 26;
        Mi[Ai] = (vn.words[wi] & 1 << Ei) >>> Ei;
      }
      return Mi;
    }
    Be.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var Mi = 0, Ai = 0; Ai < this.length; Ai++) {
        var wi = this._zeroBits(this.words[Ai]);
        if (Mi += wi, wi !== 26) break;
      }
      return Mi;
    }, Be.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Be.prototype.toTwos = function(Mi) {
      return this.negative !== 0 ? this.abs().inotn(Mi).iaddn(1) : this.clone();
    }, Be.prototype.fromTwos = function(Mi) {
      return this.testn(Mi - 1) ? this.notn(Mi).iaddn(1).ineg() : this.clone();
    }, Be.prototype.isNeg = function() {
      return this.negative !== 0;
    }, Be.prototype.neg = function() {
      return this.clone().ineg();
    }, Be.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, Be.prototype.iuor = function(Mi) {
      for (; this.length < Mi.length; )
        this.words[this.length++] = 0;
      for (var Ai = 0; Ai < Mi.length; Ai++)
        this.words[Ai] = this.words[Ai] | Mi.words[Ai];
      return this.strip();
    }, Be.prototype.ior = function(Mi) {
      return Ie((this.negative | Mi.negative) === 0), this.iuor(Mi);
    }, Be.prototype.or = function(Mi) {
      return this.length > Mi.length ? this.clone().ior(Mi) : Mi.clone().ior(this);
    }, Be.prototype.uor = function(Mi) {
      return this.length > Mi.length ? this.clone().iuor(Mi) : Mi.clone().iuor(this);
    }, Be.prototype.iuand = function(Mi) {
      var Ai;
      this.length > Mi.length ? Ai = Mi : Ai = this;
      for (var wi = 0; wi < Ai.length; wi++)
        this.words[wi] = this.words[wi] & Mi.words[wi];
      return this.length = Ai.length, this.strip();
    }, Be.prototype.iand = function(Mi) {
      return Ie((this.negative | Mi.negative) === 0), this.iuand(Mi);
    }, Be.prototype.and = function(Mi) {
      return this.length > Mi.length ? this.clone().iand(Mi) : Mi.clone().iand(this);
    }, Be.prototype.uand = function(Mi) {
      return this.length > Mi.length ? this.clone().iuand(Mi) : Mi.clone().iuand(this);
    }, Be.prototype.iuxor = function(Mi) {
      var Ai, wi;
      this.length > Mi.length ? (Ai = this, wi = Mi) : (Ai = Mi, wi = this);
      for (var Ei = 0; Ei < wi.length; Ei++)
        this.words[Ei] = Ai.words[Ei] ^ wi.words[Ei];
      if (this !== Ai)
        for (; Ei < Ai.length; Ei++)
          this.words[Ei] = Ai.words[Ei];
      return this.length = Ai.length, this.strip();
    }, Be.prototype.ixor = function(Mi) {
      return Ie((this.negative | Mi.negative) === 0), this.iuxor(Mi);
    }, Be.prototype.xor = function(Mi) {
      return this.length > Mi.length ? this.clone().ixor(Mi) : Mi.clone().ixor(this);
    }, Be.prototype.uxor = function(Mi) {
      return this.length > Mi.length ? this.clone().iuxor(Mi) : Mi.clone().iuxor(this);
    }, Be.prototype.inotn = function(Mi) {
      Ie(typeof Mi == "number" && Mi >= 0);
      var Ai = Math.ceil(Mi / 26) | 0, wi = Mi % 26;
      this._expand(Ai), wi > 0 && Ai--;
      for (var Ei = 0; Ei < Ai; Ei++)
        this.words[Ei] = ~this.words[Ei] & 67108863;
      return wi > 0 && (this.words[Ei] = ~this.words[Ei] & 67108863 >> 26 - wi), this.strip();
    }, Be.prototype.notn = function(Mi) {
      return this.clone().inotn(Mi);
    }, Be.prototype.setn = function(Mi, Ai) {
      Ie(typeof Mi == "number" && Mi >= 0);
      var wi = Mi / 26 | 0, Ei = Mi % 26;
      return this._expand(wi + 1), Ai ? this.words[wi] = this.words[wi] | 1 << Ei : this.words[wi] = this.words[wi] & ~(1 << Ei), this.strip();
    }, Be.prototype.iadd = function(Mi) {
      var Ai;
      if (this.negative !== 0 && Mi.negative === 0)
        return this.negative = 0, Ai = this.isub(Mi), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && Mi.negative !== 0)
        return Mi.negative = 0, Ai = this.isub(Mi), Mi.negative = 1, Ai._normSign();
      var wi, Ei;
      this.length > Mi.length ? (wi = this, Ei = Mi) : (wi = Mi, Ei = this);
      for (var Ti = 0, Pi = 0; Pi < Ei.length; Pi++)
        Ai = (wi.words[Pi] | 0) + (Ei.words[Pi] | 0) + Ti, this.words[Pi] = Ai & 67108863, Ti = Ai >>> 26;
      for (; Ti !== 0 && Pi < wi.length; Pi++)
        Ai = (wi.words[Pi] | 0) + Ti, this.words[Pi] = Ai & 67108863, Ti = Ai >>> 26;
      if (this.length = wi.length, Ti !== 0)
        this.words[this.length] = Ti, this.length++;
      else if (wi !== this)
        for (; Pi < wi.length; Pi++)
          this.words[Pi] = wi.words[Pi];
      return this;
    }, Be.prototype.add = function(Mi) {
      var Ai;
      return Mi.negative !== 0 && this.negative === 0 ? (Mi.negative = 0, Ai = this.sub(Mi), Mi.negative ^= 1, Ai) : Mi.negative === 0 && this.negative !== 0 ? (this.negative = 0, Ai = Mi.sub(this), this.negative = 1, Ai) : this.length > Mi.length ? this.clone().iadd(Mi) : Mi.clone().iadd(this);
    }, Be.prototype.isub = function(Mi) {
      if (Mi.negative !== 0) {
        Mi.negative = 0;
        var Ai = this.iadd(Mi);
        return Mi.negative = 1, Ai._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(Mi), this.negative = 1, this._normSign();
      var wi = this.cmp(Mi);
      if (wi === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var Ei, Ti;
      wi > 0 ? (Ei = this, Ti = Mi) : (Ei = Mi, Ti = this);
      for (var Pi = 0, qi = 0; qi < Ti.length; qi++)
        Ai = (Ei.words[qi] | 0) - (Ti.words[qi] | 0) + Pi, Pi = Ai >> 26, this.words[qi] = Ai & 67108863;
      for (; Pi !== 0 && qi < Ei.length; qi++)
        Ai = (Ei.words[qi] | 0) + Pi, Pi = Ai >> 26, this.words[qi] = Ai & 67108863;
      if (Pi === 0 && qi < Ei.length && Ei !== this)
        for (; qi < Ei.length; qi++)
          this.words[qi] = Ei.words[qi];
      return this.length = Math.max(this.length, qi), Ei !== this && (this.negative = 1), this.strip();
    }, Be.prototype.sub = function(Mi) {
      return this.clone().isub(Mi);
    };
    function _i(vn, Mi, Ai) {
      Ai.negative = Mi.negative ^ vn.negative;
      var wi = vn.length + Mi.length | 0;
      Ai.length = wi, wi = wi - 1 | 0;
      var Ei = vn.words[0] | 0, Ti = Mi.words[0] | 0, Pi = Ei * Ti, qi = Pi & 67108863, Oi = Pi / 67108864 | 0;
      Ai.words[0] = qi;
      for (var Si = 1; Si < wi; Si++) {
        for (var Ni = Oi >>> 26, xi = Oi & 67108863, Wi = Math.min(Si, Mi.length - 1), ts = Math.max(0, Si - vn.length + 1); ts <= Wi; ts++) {
          var Ki = Si - ts | 0;
          Ei = vn.words[Ki] | 0, Ti = Mi.words[ts] | 0, Pi = Ei * Ti + xi, Ni += Pi / 67108864 | 0, xi = Pi & 67108863;
        }
        Ai.words[Si] = xi | 0, Oi = Ni | 0;
      }
      return Oi !== 0 ? Ai.words[Si] = Oi | 0 : Ai.length--, Ai.strip();
    }
    var $i = function(Mi, Ai, wi) {
      var Ei = Mi.words, Ti = Ai.words, Pi = wi.words, qi = 0, Oi, Si, Ni, xi = Ei[0] | 0, Wi = xi & 8191, ts = xi >>> 13, Ki = Ei[1] | 0, fn = Ki & 8191, Ii = Ki >>> 13, Fi = Ei[2] | 0, Gi = Fi & 8191, Ri = Fi >>> 13, ji = Ei[3] | 0, Vi = ji & 8191, is = ji >>> 13, os = Ei[4] | 0, ds = os & 8191, ps = os >>> 13, ea = Ei[5] | 0, ia = ea & 8191, hs = ea >>> 13, fa = Ei[6] | 0, gs = fa & 8191, sa = fa >>> 13, aa = Ei[7] | 0, Ds = aa & 8191, ra = aa >>> 13, ca = Ei[8] | 0, ta = ca & 8191, oa = ca >>> 13, da = Ei[9] | 0, Yi = da & 8191, Li = da >>> 13, zi = Ti[0] | 0, En = zi & 8191, ss = zi >>> 13, as = Ti[1] | 0, us = as & 8191, ua = as >>> 13, ma = Ti[2] | 0, na = ma & 8191, wa = ma >>> 13, ya = Ti[3] | 0, $a = ya & 8191, Sa = ya >>> 13, Ea = Ti[4] | 0, la = Ea & 8191, xa = Ea >>> 13, Aa = Ti[5] | 0, ha = Aa & 8191, Ia = Aa >>> 13, Da = Ti[6] | 0, va = Da & 8191, Pa = Da >>> 13, Ba = Ti[7] | 0, pa = Ba & 8191, Ra = Ba >>> 13, _a = Ti[8] | 0, ga = _a & 8191, Ca = _a >>> 13, Na = Ti[9] | 0, Ma = Na & 8191, Fa = Na >>> 13;
      wi.negative = Mi.negative ^ Ai.negative, wi.length = 19, Oi = Math.imul(Wi, En), Si = Math.imul(Wi, ss), Si = Si + Math.imul(ts, En) | 0, Ni = Math.imul(ts, ss);
      var qa = (qi + Oi | 0) + ((Si & 8191) << 13) | 0;
      qi = (Ni + (Si >>> 13) | 0) + (qa >>> 26) | 0, qa &= 67108863, Oi = Math.imul(fn, En), Si = Math.imul(fn, ss), Si = Si + Math.imul(Ii, En) | 0, Ni = Math.imul(Ii, ss), Oi = Oi + Math.imul(Wi, us) | 0, Si = Si + Math.imul(Wi, ua) | 0, Si = Si + Math.imul(ts, us) | 0, Ni = Ni + Math.imul(ts, ua) | 0;
      var Ta = (qi + Oi | 0) + ((Si & 8191) << 13) | 0;
      qi = (Ni + (Si >>> 13) | 0) + (Ta >>> 26) | 0, Ta &= 67108863, Oi = Math.imul(Gi, En), Si = Math.imul(Gi, ss), Si = Si + Math.imul(Ri, En) | 0, Ni = Math.imul(Ri, ss), Oi = Oi + Math.imul(fn, us) | 0, Si = Si + Math.imul(fn, ua) | 0, Si = Si + Math.imul(Ii, us) | 0, Ni = Ni + Math.imul(Ii, ua) | 0, Oi = Oi + Math.imul(Wi, na) | 0, Si = Si + Math.imul(Wi, wa) | 0, Si = Si + Math.imul(ts, na) | 0, Ni = Ni + Math.imul(ts, wa) | 0;
      var Va = (qi + Oi | 0) + ((Si & 8191) << 13) | 0;
      qi = (Ni + (Si >>> 13) | 0) + (Va >>> 26) | 0, Va &= 67108863, Oi = Math.imul(Vi, En), Si = Math.imul(Vi, ss), Si = Si + Math.imul(is, En) | 0, Ni = Math.imul(is, ss), Oi = Oi + Math.imul(Gi, us) | 0, Si = Si + Math.imul(Gi, ua) | 0, Si = Si + Math.imul(Ri, us) | 0, Ni = Ni + Math.imul(Ri, ua) | 0, Oi = Oi + Math.imul(fn, na) | 0, Si = Si + Math.imul(fn, wa) | 0, Si = Si + Math.imul(Ii, na) | 0, Ni = Ni + Math.imul(Ii, wa) | 0, Oi = Oi + Math.imul(Wi, $a) | 0, Si = Si + Math.imul(Wi, Sa) | 0, Si = Si + Math.imul(ts, $a) | 0, Ni = Ni + Math.imul(ts, Sa) | 0;
      var Ga = (qi + Oi | 0) + ((Si & 8191) << 13) | 0;
      qi = (Ni + (Si >>> 13) | 0) + (Ga >>> 26) | 0, Ga &= 67108863, Oi = Math.imul(ds, En), Si = Math.imul(ds, ss), Si = Si + Math.imul(ps, En) | 0, Ni = Math.imul(ps, ss), Oi = Oi + Math.imul(Vi, us) | 0, Si = Si + Math.imul(Vi, ua) | 0, Si = Si + Math.imul(is, us) | 0, Ni = Ni + Math.imul(is, ua) | 0, Oi = Oi + Math.imul(Gi, na) | 0, Si = Si + Math.imul(Gi, wa) | 0, Si = Si + Math.imul(Ri, na) | 0, Ni = Ni + Math.imul(Ri, wa) | 0, Oi = Oi + Math.imul(fn, $a) | 0, Si = Si + Math.imul(fn, Sa) | 0, Si = Si + Math.imul(Ii, $a) | 0, Ni = Ni + Math.imul(Ii, Sa) | 0, Oi = Oi + Math.imul(Wi, la) | 0, Si = Si + Math.imul(Wi, xa) | 0, Si = Si + Math.imul(ts, la) | 0, Ni = Ni + Math.imul(ts, xa) | 0;
      var Ja = (qi + Oi | 0) + ((Si & 8191) << 13) | 0;
      qi = (Ni + (Si >>> 13) | 0) + (Ja >>> 26) | 0, Ja &= 67108863, Oi = Math.imul(ia, En), Si = Math.imul(ia, ss), Si = Si + Math.imul(hs, En) | 0, Ni = Math.imul(hs, ss), Oi = Oi + Math.imul(ds, us) | 0, Si = Si + Math.imul(ds, ua) | 0, Si = Si + Math.imul(ps, us) | 0, Ni = Ni + Math.imul(ps, ua) | 0, Oi = Oi + Math.imul(Vi, na) | 0, Si = Si + Math.imul(Vi, wa) | 0, Si = Si + Math.imul(is, na) | 0, Ni = Ni + Math.imul(is, wa) | 0, Oi = Oi + Math.imul(Gi, $a) | 0, Si = Si + Math.imul(Gi, Sa) | 0, Si = Si + Math.imul(Ri, $a) | 0, Ni = Ni + Math.imul(Ri, Sa) | 0, Oi = Oi + Math.imul(fn, la) | 0, Si = Si + Math.imul(fn, xa) | 0, Si = Si + Math.imul(Ii, la) | 0, Ni = Ni + Math.imul(Ii, xa) | 0, Oi = Oi + Math.imul(Wi, ha) | 0, Si = Si + Math.imul(Wi, Ia) | 0, Si = Si + Math.imul(ts, ha) | 0, Ni = Ni + Math.imul(ts, Ia) | 0;
      var Xa = (qi + Oi | 0) + ((Si & 8191) << 13) | 0;
      qi = (Ni + (Si >>> 13) | 0) + (Xa >>> 26) | 0, Xa &= 67108863, Oi = Math.imul(gs, En), Si = Math.imul(gs, ss), Si = Si + Math.imul(sa, En) | 0, Ni = Math.imul(sa, ss), Oi = Oi + Math.imul(ia, us) | 0, Si = Si + Math.imul(ia, ua) | 0, Si = Si + Math.imul(hs, us) | 0, Ni = Ni + Math.imul(hs, ua) | 0, Oi = Oi + Math.imul(ds, na) | 0, Si = Si + Math.imul(ds, wa) | 0, Si = Si + Math.imul(ps, na) | 0, Ni = Ni + Math.imul(ps, wa) | 0, Oi = Oi + Math.imul(Vi, $a) | 0, Si = Si + Math.imul(Vi, Sa) | 0, Si = Si + Math.imul(is, $a) | 0, Ni = Ni + Math.imul(is, Sa) | 0, Oi = Oi + Math.imul(Gi, la) | 0, Si = Si + Math.imul(Gi, xa) | 0, Si = Si + Math.imul(Ri, la) | 0, Ni = Ni + Math.imul(Ri, xa) | 0, Oi = Oi + Math.imul(fn, ha) | 0, Si = Si + Math.imul(fn, Ia) | 0, Si = Si + Math.imul(Ii, ha) | 0, Ni = Ni + Math.imul(Ii, Ia) | 0, Oi = Oi + Math.imul(Wi, va) | 0, Si = Si + Math.imul(Wi, Pa) | 0, Si = Si + Math.imul(ts, va) | 0, Ni = Ni + Math.imul(ts, Pa) | 0;
      var ja = (qi + Oi | 0) + ((Si & 8191) << 13) | 0;
      qi = (Ni + (Si >>> 13) | 0) + (ja >>> 26) | 0, ja &= 67108863, Oi = Math.imul(Ds, En), Si = Math.imul(Ds, ss), Si = Si + Math.imul(ra, En) | 0, Ni = Math.imul(ra, ss), Oi = Oi + Math.imul(gs, us) | 0, Si = Si + Math.imul(gs, ua) | 0, Si = Si + Math.imul(sa, us) | 0, Ni = Ni + Math.imul(sa, ua) | 0, Oi = Oi + Math.imul(ia, na) | 0, Si = Si + Math.imul(ia, wa) | 0, Si = Si + Math.imul(hs, na) | 0, Ni = Ni + Math.imul(hs, wa) | 0, Oi = Oi + Math.imul(ds, $a) | 0, Si = Si + Math.imul(ds, Sa) | 0, Si = Si + Math.imul(ps, $a) | 0, Ni = Ni + Math.imul(ps, Sa) | 0, Oi = Oi + Math.imul(Vi, la) | 0, Si = Si + Math.imul(Vi, xa) | 0, Si = Si + Math.imul(is, la) | 0, Ni = Ni + Math.imul(is, xa) | 0, Oi = Oi + Math.imul(Gi, ha) | 0, Si = Si + Math.imul(Gi, Ia) | 0, Si = Si + Math.imul(Ri, ha) | 0, Ni = Ni + Math.imul(Ri, Ia) | 0, Oi = Oi + Math.imul(fn, va) | 0, Si = Si + Math.imul(fn, Pa) | 0, Si = Si + Math.imul(Ii, va) | 0, Ni = Ni + Math.imul(Ii, Pa) | 0, Oi = Oi + Math.imul(Wi, pa) | 0, Si = Si + Math.imul(Wi, Ra) | 0, Si = Si + Math.imul(ts, pa) | 0, Ni = Ni + Math.imul(ts, Ra) | 0;
      var go = (qi + Oi | 0) + ((Si & 8191) << 13) | 0;
      qi = (Ni + (Si >>> 13) | 0) + (go >>> 26) | 0, go &= 67108863, Oi = Math.imul(ta, En), Si = Math.imul(ta, ss), Si = Si + Math.imul(oa, En) | 0, Ni = Math.imul(oa, ss), Oi = Oi + Math.imul(Ds, us) | 0, Si = Si + Math.imul(Ds, ua) | 0, Si = Si + Math.imul(ra, us) | 0, Ni = Ni + Math.imul(ra, ua) | 0, Oi = Oi + Math.imul(gs, na) | 0, Si = Si + Math.imul(gs, wa) | 0, Si = Si + Math.imul(sa, na) | 0, Ni = Ni + Math.imul(sa, wa) | 0, Oi = Oi + Math.imul(ia, $a) | 0, Si = Si + Math.imul(ia, Sa) | 0, Si = Si + Math.imul(hs, $a) | 0, Ni = Ni + Math.imul(hs, Sa) | 0, Oi = Oi + Math.imul(ds, la) | 0, Si = Si + Math.imul(ds, xa) | 0, Si = Si + Math.imul(ps, la) | 0, Ni = Ni + Math.imul(ps, xa) | 0, Oi = Oi + Math.imul(Vi, ha) | 0, Si = Si + Math.imul(Vi, Ia) | 0, Si = Si + Math.imul(is, ha) | 0, Ni = Ni + Math.imul(is, Ia) | 0, Oi = Oi + Math.imul(Gi, va) | 0, Si = Si + Math.imul(Gi, Pa) | 0, Si = Si + Math.imul(Ri, va) | 0, Ni = Ni + Math.imul(Ri, Pa) | 0, Oi = Oi + Math.imul(fn, pa) | 0, Si = Si + Math.imul(fn, Ra) | 0, Si = Si + Math.imul(Ii, pa) | 0, Ni = Ni + Math.imul(Ii, Ra) | 0, Oi = Oi + Math.imul(Wi, ga) | 0, Si = Si + Math.imul(Wi, Ca) | 0, Si = Si + Math.imul(ts, ga) | 0, Ni = Ni + Math.imul(ts, Ca) | 0;
      var wo = (qi + Oi | 0) + ((Si & 8191) << 13) | 0;
      qi = (Ni + (Si >>> 13) | 0) + (wo >>> 26) | 0, wo &= 67108863, Oi = Math.imul(Yi, En), Si = Math.imul(Yi, ss), Si = Si + Math.imul(Li, En) | 0, Ni = Math.imul(Li, ss), Oi = Oi + Math.imul(ta, us) | 0, Si = Si + Math.imul(ta, ua) | 0, Si = Si + Math.imul(oa, us) | 0, Ni = Ni + Math.imul(oa, ua) | 0, Oi = Oi + Math.imul(Ds, na) | 0, Si = Si + Math.imul(Ds, wa) | 0, Si = Si + Math.imul(ra, na) | 0, Ni = Ni + Math.imul(ra, wa) | 0, Oi = Oi + Math.imul(gs, $a) | 0, Si = Si + Math.imul(gs, Sa) | 0, Si = Si + Math.imul(sa, $a) | 0, Ni = Ni + Math.imul(sa, Sa) | 0, Oi = Oi + Math.imul(ia, la) | 0, Si = Si + Math.imul(ia, xa) | 0, Si = Si + Math.imul(hs, la) | 0, Ni = Ni + Math.imul(hs, xa) | 0, Oi = Oi + Math.imul(ds, ha) | 0, Si = Si + Math.imul(ds, Ia) | 0, Si = Si + Math.imul(ps, ha) | 0, Ni = Ni + Math.imul(ps, Ia) | 0, Oi = Oi + Math.imul(Vi, va) | 0, Si = Si + Math.imul(Vi, Pa) | 0, Si = Si + Math.imul(is, va) | 0, Ni = Ni + Math.imul(is, Pa) | 0, Oi = Oi + Math.imul(Gi, pa) | 0, Si = Si + Math.imul(Gi, Ra) | 0, Si = Si + Math.imul(Ri, pa) | 0, Ni = Ni + Math.imul(Ri, Ra) | 0, Oi = Oi + Math.imul(fn, ga) | 0, Si = Si + Math.imul(fn, Ca) | 0, Si = Si + Math.imul(Ii, ga) | 0, Ni = Ni + Math.imul(Ii, Ca) | 0, Oi = Oi + Math.imul(Wi, Ma) | 0, Si = Si + Math.imul(Wi, Fa) | 0, Si = Si + Math.imul(ts, Ma) | 0, Ni = Ni + Math.imul(ts, Fa) | 0;
      var _o = (qi + Oi | 0) + ((Si & 8191) << 13) | 0;
      qi = (Ni + (Si >>> 13) | 0) + (_o >>> 26) | 0, _o &= 67108863, Oi = Math.imul(Yi, us), Si = Math.imul(Yi, ua), Si = Si + Math.imul(Li, us) | 0, Ni = Math.imul(Li, ua), Oi = Oi + Math.imul(ta, na) | 0, Si = Si + Math.imul(ta, wa) | 0, Si = Si + Math.imul(oa, na) | 0, Ni = Ni + Math.imul(oa, wa) | 0, Oi = Oi + Math.imul(Ds, $a) | 0, Si = Si + Math.imul(Ds, Sa) | 0, Si = Si + Math.imul(ra, $a) | 0, Ni = Ni + Math.imul(ra, Sa) | 0, Oi = Oi + Math.imul(gs, la) | 0, Si = Si + Math.imul(gs, xa) | 0, Si = Si + Math.imul(sa, la) | 0, Ni = Ni + Math.imul(sa, xa) | 0, Oi = Oi + Math.imul(ia, ha) | 0, Si = Si + Math.imul(ia, Ia) | 0, Si = Si + Math.imul(hs, ha) | 0, Ni = Ni + Math.imul(hs, Ia) | 0, Oi = Oi + Math.imul(ds, va) | 0, Si = Si + Math.imul(ds, Pa) | 0, Si = Si + Math.imul(ps, va) | 0, Ni = Ni + Math.imul(ps, Pa) | 0, Oi = Oi + Math.imul(Vi, pa) | 0, Si = Si + Math.imul(Vi, Ra) | 0, Si = Si + Math.imul(is, pa) | 0, Ni = Ni + Math.imul(is, Ra) | 0, Oi = Oi + Math.imul(Gi, ga) | 0, Si = Si + Math.imul(Gi, Ca) | 0, Si = Si + Math.imul(Ri, ga) | 0, Ni = Ni + Math.imul(Ri, Ca) | 0, Oi = Oi + Math.imul(fn, Ma) | 0, Si = Si + Math.imul(fn, Fa) | 0, Si = Si + Math.imul(Ii, Ma) | 0, Ni = Ni + Math.imul(Ii, Fa) | 0;
      var $o = (qi + Oi | 0) + ((Si & 8191) << 13) | 0;
      qi = (Ni + (Si >>> 13) | 0) + ($o >>> 26) | 0, $o &= 67108863, Oi = Math.imul(Yi, na), Si = Math.imul(Yi, wa), Si = Si + Math.imul(Li, na) | 0, Ni = Math.imul(Li, wa), Oi = Oi + Math.imul(ta, $a) | 0, Si = Si + Math.imul(ta, Sa) | 0, Si = Si + Math.imul(oa, $a) | 0, Ni = Ni + Math.imul(oa, Sa) | 0, Oi = Oi + Math.imul(Ds, la) | 0, Si = Si + Math.imul(Ds, xa) | 0, Si = Si + Math.imul(ra, la) | 0, Ni = Ni + Math.imul(ra, xa) | 0, Oi = Oi + Math.imul(gs, ha) | 0, Si = Si + Math.imul(gs, Ia) | 0, Si = Si + Math.imul(sa, ha) | 0, Ni = Ni + Math.imul(sa, Ia) | 0, Oi = Oi + Math.imul(ia, va) | 0, Si = Si + Math.imul(ia, Pa) | 0, Si = Si + Math.imul(hs, va) | 0, Ni = Ni + Math.imul(hs, Pa) | 0, Oi = Oi + Math.imul(ds, pa) | 0, Si = Si + Math.imul(ds, Ra) | 0, Si = Si + Math.imul(ps, pa) | 0, Ni = Ni + Math.imul(ps, Ra) | 0, Oi = Oi + Math.imul(Vi, ga) | 0, Si = Si + Math.imul(Vi, Ca) | 0, Si = Si + Math.imul(is, ga) | 0, Ni = Ni + Math.imul(is, Ca) | 0, Oi = Oi + Math.imul(Gi, Ma) | 0, Si = Si + Math.imul(Gi, Fa) | 0, Si = Si + Math.imul(Ri, Ma) | 0, Ni = Ni + Math.imul(Ri, Fa) | 0;
      var Eo = (qi + Oi | 0) + ((Si & 8191) << 13) | 0;
      qi = (Ni + (Si >>> 13) | 0) + (Eo >>> 26) | 0, Eo &= 67108863, Oi = Math.imul(Yi, $a), Si = Math.imul(Yi, Sa), Si = Si + Math.imul(Li, $a) | 0, Ni = Math.imul(Li, Sa), Oi = Oi + Math.imul(ta, la) | 0, Si = Si + Math.imul(ta, xa) | 0, Si = Si + Math.imul(oa, la) | 0, Ni = Ni + Math.imul(oa, xa) | 0, Oi = Oi + Math.imul(Ds, ha) | 0, Si = Si + Math.imul(Ds, Ia) | 0, Si = Si + Math.imul(ra, ha) | 0, Ni = Ni + Math.imul(ra, Ia) | 0, Oi = Oi + Math.imul(gs, va) | 0, Si = Si + Math.imul(gs, Pa) | 0, Si = Si + Math.imul(sa, va) | 0, Ni = Ni + Math.imul(sa, Pa) | 0, Oi = Oi + Math.imul(ia, pa) | 0, Si = Si + Math.imul(ia, Ra) | 0, Si = Si + Math.imul(hs, pa) | 0, Ni = Ni + Math.imul(hs, Ra) | 0, Oi = Oi + Math.imul(ds, ga) | 0, Si = Si + Math.imul(ds, Ca) | 0, Si = Si + Math.imul(ps, ga) | 0, Ni = Ni + Math.imul(ps, Ca) | 0, Oi = Oi + Math.imul(Vi, Ma) | 0, Si = Si + Math.imul(Vi, Fa) | 0, Si = Si + Math.imul(is, Ma) | 0, Ni = Ni + Math.imul(is, Fa) | 0;
      var Za = (qi + Oi | 0) + ((Si & 8191) << 13) | 0;
      qi = (Ni + (Si >>> 13) | 0) + (Za >>> 26) | 0, Za &= 67108863, Oi = Math.imul(Yi, la), Si = Math.imul(Yi, xa), Si = Si + Math.imul(Li, la) | 0, Ni = Math.imul(Li, xa), Oi = Oi + Math.imul(ta, ha) | 0, Si = Si + Math.imul(ta, Ia) | 0, Si = Si + Math.imul(oa, ha) | 0, Ni = Ni + Math.imul(oa, Ia) | 0, Oi = Oi + Math.imul(Ds, va) | 0, Si = Si + Math.imul(Ds, Pa) | 0, Si = Si + Math.imul(ra, va) | 0, Ni = Ni + Math.imul(ra, Pa) | 0, Oi = Oi + Math.imul(gs, pa) | 0, Si = Si + Math.imul(gs, Ra) | 0, Si = Si + Math.imul(sa, pa) | 0, Ni = Ni + Math.imul(sa, Ra) | 0, Oi = Oi + Math.imul(ia, ga) | 0, Si = Si + Math.imul(ia, Ca) | 0, Si = Si + Math.imul(hs, ga) | 0, Ni = Ni + Math.imul(hs, Ca) | 0, Oi = Oi + Math.imul(ds, Ma) | 0, Si = Si + Math.imul(ds, Fa) | 0, Si = Si + Math.imul(ps, Ma) | 0, Ni = Ni + Math.imul(ps, Fa) | 0;
      var So = (qi + Oi | 0) + ((Si & 8191) << 13) | 0;
      qi = (Ni + (Si >>> 13) | 0) + (So >>> 26) | 0, So &= 67108863, Oi = Math.imul(Yi, ha), Si = Math.imul(Yi, Ia), Si = Si + Math.imul(Li, ha) | 0, Ni = Math.imul(Li, Ia), Oi = Oi + Math.imul(ta, va) | 0, Si = Si + Math.imul(ta, Pa) | 0, Si = Si + Math.imul(oa, va) | 0, Ni = Ni + Math.imul(oa, Pa) | 0, Oi = Oi + Math.imul(Ds, pa) | 0, Si = Si + Math.imul(Ds, Ra) | 0, Si = Si + Math.imul(ra, pa) | 0, Ni = Ni + Math.imul(ra, Ra) | 0, Oi = Oi + Math.imul(gs, ga) | 0, Si = Si + Math.imul(gs, Ca) | 0, Si = Si + Math.imul(sa, ga) | 0, Ni = Ni + Math.imul(sa, Ca) | 0, Oi = Oi + Math.imul(ia, Ma) | 0, Si = Si + Math.imul(ia, Fa) | 0, Si = Si + Math.imul(hs, Ma) | 0, Ni = Ni + Math.imul(hs, Fa) | 0;
      var xo = (qi + Oi | 0) + ((Si & 8191) << 13) | 0;
      qi = (Ni + (Si >>> 13) | 0) + (xo >>> 26) | 0, xo &= 67108863, Oi = Math.imul(Yi, va), Si = Math.imul(Yi, Pa), Si = Si + Math.imul(Li, va) | 0, Ni = Math.imul(Li, Pa), Oi = Oi + Math.imul(ta, pa) | 0, Si = Si + Math.imul(ta, Ra) | 0, Si = Si + Math.imul(oa, pa) | 0, Ni = Ni + Math.imul(oa, Ra) | 0, Oi = Oi + Math.imul(Ds, ga) | 0, Si = Si + Math.imul(Ds, Ca) | 0, Si = Si + Math.imul(ra, ga) | 0, Ni = Ni + Math.imul(ra, Ca) | 0, Oi = Oi + Math.imul(gs, Ma) | 0, Si = Si + Math.imul(gs, Fa) | 0, Si = Si + Math.imul(sa, Ma) | 0, Ni = Ni + Math.imul(sa, Fa) | 0;
      var Ha = (qi + Oi | 0) + ((Si & 8191) << 13) | 0;
      qi = (Ni + (Si >>> 13) | 0) + (Ha >>> 26) | 0, Ha &= 67108863, Oi = Math.imul(Yi, pa), Si = Math.imul(Yi, Ra), Si = Si + Math.imul(Li, pa) | 0, Ni = Math.imul(Li, Ra), Oi = Oi + Math.imul(ta, ga) | 0, Si = Si + Math.imul(ta, Ca) | 0, Si = Si + Math.imul(oa, ga) | 0, Ni = Ni + Math.imul(oa, Ca) | 0, Oi = Oi + Math.imul(Ds, Ma) | 0, Si = Si + Math.imul(Ds, Fa) | 0, Si = Si + Math.imul(ra, Ma) | 0, Ni = Ni + Math.imul(ra, Fa) | 0;
      var Ao = (qi + Oi | 0) + ((Si & 8191) << 13) | 0;
      qi = (Ni + (Si >>> 13) | 0) + (Ao >>> 26) | 0, Ao &= 67108863, Oi = Math.imul(Yi, ga), Si = Math.imul(Yi, Ca), Si = Si + Math.imul(Li, ga) | 0, Ni = Math.imul(Li, Ca), Oi = Oi + Math.imul(ta, Ma) | 0, Si = Si + Math.imul(ta, Fa) | 0, Si = Si + Math.imul(oa, Ma) | 0, Ni = Ni + Math.imul(oa, Fa) | 0;
      var Ro = (qi + Oi | 0) + ((Si & 8191) << 13) | 0;
      qi = (Ni + (Si >>> 13) | 0) + (Ro >>> 26) | 0, Ro &= 67108863, Oi = Math.imul(Yi, Ma), Si = Math.imul(Yi, Fa), Si = Si + Math.imul(Li, Ma) | 0, Ni = Math.imul(Li, Fa);
      var Mo = (qi + Oi | 0) + ((Si & 8191) << 13) | 0;
      return qi = (Ni + (Si >>> 13) | 0) + (Mo >>> 26) | 0, Mo &= 67108863, Pi[0] = qa, Pi[1] = Ta, Pi[2] = Va, Pi[3] = Ga, Pi[4] = Ja, Pi[5] = Xa, Pi[6] = ja, Pi[7] = go, Pi[8] = wo, Pi[9] = _o, Pi[10] = $o, Pi[11] = Eo, Pi[12] = Za, Pi[13] = So, Pi[14] = xo, Pi[15] = Ha, Pi[16] = Ao, Pi[17] = Ro, Pi[18] = Mo, qi !== 0 && (Pi[19] = qi, wi.length++), wi;
    };
    Math.imul || ($i = _i);
    function Ci(vn, Mi, Ai) {
      Ai.negative = Mi.negative ^ vn.negative, Ai.length = vn.length + Mi.length;
      for (var wi = 0, Ei = 0, Ti = 0; Ti < Ai.length - 1; Ti++) {
        var Pi = Ei;
        Ei = 0;
        for (var qi = wi & 67108863, Oi = Math.min(Ti, Mi.length - 1), Si = Math.max(0, Ti - vn.length + 1); Si <= Oi; Si++) {
          var Ni = Ti - Si, xi = vn.words[Ni] | 0, Wi = Mi.words[Si] | 0, ts = xi * Wi, Ki = ts & 67108863;
          Pi = Pi + (ts / 67108864 | 0) | 0, Ki = Ki + qi | 0, qi = Ki & 67108863, Pi = Pi + (Ki >>> 26) | 0, Ei += Pi >>> 26, Pi &= 67108863;
        }
        Ai.words[Ti] = qi, wi = Pi, Pi = Ei;
      }
      return wi !== 0 ? Ai.words[Ti] = wi : Ai.length--, Ai.strip();
    }
    function Ui(vn, Mi, Ai) {
      var wi = new ki();
      return wi.mulp(vn, Mi, Ai);
    }
    Be.prototype.mulTo = function(Mi, Ai) {
      var wi, Ei = this.length + Mi.length;
      return this.length === 10 && Mi.length === 10 ? wi = $i(this, Mi, Ai) : Ei < 63 ? wi = _i(this, Mi, Ai) : Ei < 1024 ? wi = Ci(this, Mi, Ai) : wi = Ui(this, Mi, Ai), wi;
    };
    function ki(vn, Mi) {
      this.x = vn, this.y = Mi;
    }
    ki.prototype.makeRBT = function(Mi) {
      for (var Ai = new Array(Mi), wi = Be.prototype._countBits(Mi) - 1, Ei = 0; Ei < Mi; Ei++)
        Ai[Ei] = this.revBin(Ei, wi, Mi);
      return Ai;
    }, ki.prototype.revBin = function(Mi, Ai, wi) {
      if (Mi === 0 || Mi === wi - 1) return Mi;
      for (var Ei = 0, Ti = 0; Ti < Ai; Ti++)
        Ei |= (Mi & 1) << Ai - Ti - 1, Mi >>= 1;
      return Ei;
    }, ki.prototype.permute = function(Mi, Ai, wi, Ei, Ti, Pi) {
      for (var qi = 0; qi < Pi; qi++)
        Ei[qi] = Ai[Mi[qi]], Ti[qi] = wi[Mi[qi]];
    }, ki.prototype.transform = function(Mi, Ai, wi, Ei, Ti, Pi) {
      this.permute(Pi, Mi, Ai, wi, Ei, Ti);
      for (var qi = 1; qi < Ti; qi <<= 1)
        for (var Oi = qi << 1, Si = Math.cos(2 * Math.PI / Oi), Ni = Math.sin(2 * Math.PI / Oi), xi = 0; xi < Ti; xi += Oi)
          for (var Wi = Si, ts = Ni, Ki = 0; Ki < qi; Ki++) {
            var fn = wi[xi + Ki], Ii = Ei[xi + Ki], Fi = wi[xi + Ki + qi], Gi = Ei[xi + Ki + qi], Ri = Wi * Fi - ts * Gi;
            Gi = Wi * Gi + ts * Fi, Fi = Ri, wi[xi + Ki] = fn + Fi, Ei[xi + Ki] = Ii + Gi, wi[xi + Ki + qi] = fn - Fi, Ei[xi + Ki + qi] = Ii - Gi, Ki !== Oi && (Ri = Si * Wi - Ni * ts, ts = Si * ts + Ni * Wi, Wi = Ri);
          }
    }, ki.prototype.guessLen13b = function(Mi, Ai) {
      var wi = Math.max(Ai, Mi) | 1, Ei = wi & 1, Ti = 0;
      for (wi = wi / 2 | 0; wi; wi = wi >>> 1)
        Ti++;
      return 1 << Ti + 1 + Ei;
    }, ki.prototype.conjugate = function(Mi, Ai, wi) {
      if (!(wi <= 1))
        for (var Ei = 0; Ei < wi / 2; Ei++) {
          var Ti = Mi[Ei];
          Mi[Ei] = Mi[wi - Ei - 1], Mi[wi - Ei - 1] = Ti, Ti = Ai[Ei], Ai[Ei] = -Ai[wi - Ei - 1], Ai[wi - Ei - 1] = -Ti;
        }
    }, ki.prototype.normalize13b = function(Mi, Ai) {
      for (var wi = 0, Ei = 0; Ei < Ai / 2; Ei++) {
        var Ti = Math.round(Mi[2 * Ei + 1] / Ai) * 8192 + Math.round(Mi[2 * Ei] / Ai) + wi;
        Mi[Ei] = Ti & 67108863, Ti < 67108864 ? wi = 0 : wi = Ti / 67108864 | 0;
      }
      return Mi;
    }, ki.prototype.convert13b = function(Mi, Ai, wi, Ei) {
      for (var Ti = 0, Pi = 0; Pi < Ai; Pi++)
        Ti = Ti + (Mi[Pi] | 0), wi[2 * Pi] = Ti & 8191, Ti = Ti >>> 13, wi[2 * Pi + 1] = Ti & 8191, Ti = Ti >>> 13;
      for (Pi = 2 * Ai; Pi < Ei; ++Pi)
        wi[Pi] = 0;
      Ie(Ti === 0), Ie((Ti & -8192) === 0);
    }, ki.prototype.stub = function(Mi) {
      for (var Ai = new Array(Mi), wi = 0; wi < Mi; wi++)
        Ai[wi] = 0;
      return Ai;
    }, ki.prototype.mulp = function(Mi, Ai, wi) {
      var Ei = 2 * this.guessLen13b(Mi.length, Ai.length), Ti = this.makeRBT(Ei), Pi = this.stub(Ei), qi = new Array(Ei), Oi = new Array(Ei), Si = new Array(Ei), Ni = new Array(Ei), xi = new Array(Ei), Wi = new Array(Ei), ts = wi.words;
      ts.length = Ei, this.convert13b(Mi.words, Mi.length, qi, Ei), this.convert13b(Ai.words, Ai.length, Ni, Ei), this.transform(qi, Pi, Oi, Si, Ei, Ti), this.transform(Ni, Pi, xi, Wi, Ei, Ti);
      for (var Ki = 0; Ki < Ei; Ki++) {
        var fn = Oi[Ki] * xi[Ki] - Si[Ki] * Wi[Ki];
        Si[Ki] = Oi[Ki] * Wi[Ki] + Si[Ki] * xi[Ki], Oi[Ki] = fn;
      }
      return this.conjugate(Oi, Si, Ei), this.transform(Oi, Si, ts, Pi, Ei, Ti), this.conjugate(ts, Pi, Ei), this.normalize13b(ts, Ei), wi.negative = Mi.negative ^ Ai.negative, wi.length = Mi.length + Ai.length, wi.strip();
    }, Be.prototype.mul = function(Mi) {
      var Ai = new Be(null);
      return Ai.words = new Array(this.length + Mi.length), this.mulTo(Mi, Ai);
    }, Be.prototype.mulf = function(Mi) {
      var Ai = new Be(null);
      return Ai.words = new Array(this.length + Mi.length), Ui(this, Mi, Ai);
    }, Be.prototype.imul = function(Mi) {
      return this.clone().mulTo(Mi, this);
    }, Be.prototype.imuln = function(Mi) {
      Ie(typeof Mi == "number"), Ie(Mi < 67108864);
      for (var Ai = 0, wi = 0; wi < this.length; wi++) {
        var Ei = (this.words[wi] | 0) * Mi, Ti = (Ei & 67108863) + (Ai & 67108863);
        Ai >>= 26, Ai += Ei / 67108864 | 0, Ai += Ti >>> 26, this.words[wi] = Ti & 67108863;
      }
      return Ai !== 0 && (this.words[wi] = Ai, this.length++), this;
    }, Be.prototype.muln = function(Mi) {
      return this.clone().imuln(Mi);
    }, Be.prototype.sqr = function() {
      return this.mul(this);
    }, Be.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Be.prototype.pow = function(Mi) {
      var Ai = mi(Mi);
      if (Ai.length === 0) return new Be(1);
      for (var wi = this, Ei = 0; Ei < Ai.length && Ai[Ei] === 0; Ei++, wi = wi.sqr())
        ;
      if (++Ei < Ai.length)
        for (var Ti = wi.sqr(); Ei < Ai.length; Ei++, Ti = Ti.sqr())
          Ai[Ei] !== 0 && (wi = wi.mul(Ti));
      return wi;
    }, Be.prototype.iushln = function(Mi) {
      Ie(typeof Mi == "number" && Mi >= 0);
      var Ai = Mi % 26, wi = (Mi - Ai) / 26, Ei = 67108863 >>> 26 - Ai << 26 - Ai, Ti;
      if (Ai !== 0) {
        var Pi = 0;
        for (Ti = 0; Ti < this.length; Ti++) {
          var qi = this.words[Ti] & Ei, Oi = (this.words[Ti] | 0) - qi << Ai;
          this.words[Ti] = Oi | Pi, Pi = qi >>> 26 - Ai;
        }
        Pi && (this.words[Ti] = Pi, this.length++);
      }
      if (wi !== 0) {
        for (Ti = this.length - 1; Ti >= 0; Ti--)
          this.words[Ti + wi] = this.words[Ti];
        for (Ti = 0; Ti < wi; Ti++)
          this.words[Ti] = 0;
        this.length += wi;
      }
      return this.strip();
    }, Be.prototype.ishln = function(Mi) {
      return Ie(this.negative === 0), this.iushln(Mi);
    }, Be.prototype.iushrn = function(Mi, Ai, wi) {
      Ie(typeof Mi == "number" && Mi >= 0);
      var Ei;
      Ai ? Ei = (Ai - Ai % 26) / 26 : Ei = 0;
      var Ti = Mi % 26, Pi = Math.min((Mi - Ti) / 26, this.length), qi = 67108863 ^ 67108863 >>> Ti << Ti, Oi = wi;
      if (Ei -= Pi, Ei = Math.max(0, Ei), Oi) {
        for (var Si = 0; Si < Pi; Si++)
          Oi.words[Si] = this.words[Si];
        Oi.length = Pi;
      }
      if (Pi !== 0) if (this.length > Pi)
        for (this.length -= Pi, Si = 0; Si < this.length; Si++)
          this.words[Si] = this.words[Si + Pi];
      else
        this.words[0] = 0, this.length = 1;
      var Ni = 0;
      for (Si = this.length - 1; Si >= 0 && (Ni !== 0 || Si >= Ei); Si--) {
        var xi = this.words[Si] | 0;
        this.words[Si] = Ni << 26 - Ti | xi >>> Ti, Ni = xi & qi;
      }
      return Oi && Ni !== 0 && (Oi.words[Oi.length++] = Ni), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, Be.prototype.ishrn = function(Mi, Ai, wi) {
      return Ie(this.negative === 0), this.iushrn(Mi, Ai, wi);
    }, Be.prototype.shln = function(Mi) {
      return this.clone().ishln(Mi);
    }, Be.prototype.ushln = function(Mi) {
      return this.clone().iushln(Mi);
    }, Be.prototype.shrn = function(Mi) {
      return this.clone().ishrn(Mi);
    }, Be.prototype.ushrn = function(Mi) {
      return this.clone().iushrn(Mi);
    }, Be.prototype.testn = function(Mi) {
      Ie(typeof Mi == "number" && Mi >= 0);
      var Ai = Mi % 26, wi = (Mi - Ai) / 26, Ei = 1 << Ai;
      if (this.length <= wi) return !1;
      var Ti = this.words[wi];
      return !!(Ti & Ei);
    }, Be.prototype.imaskn = function(Mi) {
      Ie(typeof Mi == "number" && Mi >= 0);
      var Ai = Mi % 26, wi = (Mi - Ai) / 26;
      if (Ie(this.negative === 0, "imaskn works only with positive numbers"), this.length <= wi)
        return this;
      if (Ai !== 0 && wi++, this.length = Math.min(wi, this.length), Ai !== 0) {
        var Ei = 67108863 ^ 67108863 >>> Ai << Ai;
        this.words[this.length - 1] &= Ei;
      }
      return this.strip();
    }, Be.prototype.maskn = function(Mi) {
      return this.clone().imaskn(Mi);
    }, Be.prototype.iaddn = function(Mi) {
      return Ie(typeof Mi == "number"), Ie(Mi < 67108864), Mi < 0 ? this.isubn(-Mi) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < Mi ? (this.words[0] = Mi - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(Mi), this.negative = 1, this) : this._iaddn(Mi);
    }, Be.prototype._iaddn = function(Mi) {
      this.words[0] += Mi;
      for (var Ai = 0; Ai < this.length && this.words[Ai] >= 67108864; Ai++)
        this.words[Ai] -= 67108864, Ai === this.length - 1 ? this.words[Ai + 1] = 1 : this.words[Ai + 1]++;
      return this.length = Math.max(this.length, Ai + 1), this;
    }, Be.prototype.isubn = function(Mi) {
      if (Ie(typeof Mi == "number"), Ie(Mi < 67108864), Mi < 0) return this.iaddn(-Mi);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(Mi), this.negative = 1, this;
      if (this.words[0] -= Mi, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var Ai = 0; Ai < this.length && this.words[Ai] < 0; Ai++)
          this.words[Ai] += 67108864, this.words[Ai + 1] -= 1;
      return this.strip();
    }, Be.prototype.addn = function(Mi) {
      return this.clone().iaddn(Mi);
    }, Be.prototype.subn = function(Mi) {
      return this.clone().isubn(Mi);
    }, Be.prototype.iabs = function() {
      return this.negative = 0, this;
    }, Be.prototype.abs = function() {
      return this.clone().iabs();
    }, Be.prototype._ishlnsubmul = function(Mi, Ai, wi) {
      var Ei = Mi.length + wi, Ti;
      this._expand(Ei);
      var Pi, qi = 0;
      for (Ti = 0; Ti < Mi.length; Ti++) {
        Pi = (this.words[Ti + wi] | 0) + qi;
        var Oi = (Mi.words[Ti] | 0) * Ai;
        Pi -= Oi & 67108863, qi = (Pi >> 26) - (Oi / 67108864 | 0), this.words[Ti + wi] = Pi & 67108863;
      }
      for (; Ti < this.length - wi; Ti++)
        Pi = (this.words[Ti + wi] | 0) + qi, qi = Pi >> 26, this.words[Ti + wi] = Pi & 67108863;
      if (qi === 0) return this.strip();
      for (Ie(qi === -1), qi = 0, Ti = 0; Ti < this.length; Ti++)
        Pi = -(this.words[Ti] | 0) + qi, qi = Pi >> 26, this.words[Ti] = Pi & 67108863;
      return this.negative = 1, this.strip();
    }, Be.prototype._wordDiv = function(Mi, Ai) {
      var wi = this.length - Mi.length, Ei = this.clone(), Ti = Mi, Pi = Ti.words[Ti.length - 1] | 0, qi = this._countBits(Pi);
      wi = 26 - qi, wi !== 0 && (Ti = Ti.ushln(wi), Ei.iushln(wi), Pi = Ti.words[Ti.length - 1] | 0);
      var Oi = Ei.length - Ti.length, Si;
      if (Ai !== "mod") {
        Si = new Be(null), Si.length = Oi + 1, Si.words = new Array(Si.length);
        for (var Ni = 0; Ni < Si.length; Ni++)
          Si.words[Ni] = 0;
      }
      var xi = Ei.clone()._ishlnsubmul(Ti, 1, Oi);
      xi.negative === 0 && (Ei = xi, Si && (Si.words[Oi] = 1));
      for (var Wi = Oi - 1; Wi >= 0; Wi--) {
        var ts = (Ei.words[Ti.length + Wi] | 0) * 67108864 + (Ei.words[Ti.length + Wi - 1] | 0);
        for (ts = Math.min(ts / Pi | 0, 67108863), Ei._ishlnsubmul(Ti, ts, Wi); Ei.negative !== 0; )
          ts--, Ei.negative = 0, Ei._ishlnsubmul(Ti, 1, Wi), Ei.isZero() || (Ei.negative ^= 1);
        Si && (Si.words[Wi] = ts);
      }
      return Si && Si.strip(), Ei.strip(), Ai !== "div" && wi !== 0 && Ei.iushrn(wi), {
        div: Si || null,
        mod: Ei
      };
    }, Be.prototype.divmod = function(Mi, Ai, wi) {
      if (Ie(!Mi.isZero()), this.isZero())
        return {
          div: new Be(0),
          mod: new Be(0)
        };
      var Ei, Ti, Pi;
      return this.negative !== 0 && Mi.negative === 0 ? (Pi = this.neg().divmod(Mi, Ai), Ai !== "mod" && (Ei = Pi.div.neg()), Ai !== "div" && (Ti = Pi.mod.neg(), wi && Ti.negative !== 0 && Ti.iadd(Mi)), {
        div: Ei,
        mod: Ti
      }) : this.negative === 0 && Mi.negative !== 0 ? (Pi = this.divmod(Mi.neg(), Ai), Ai !== "mod" && (Ei = Pi.div.neg()), {
        div: Ei,
        mod: Pi.mod
      }) : this.negative & Mi.negative ? (Pi = this.neg().divmod(Mi.neg(), Ai), Ai !== "div" && (Ti = Pi.mod.neg(), wi && Ti.negative !== 0 && Ti.isub(Mi)), {
        div: Pi.div,
        mod: Ti
      }) : Mi.length > this.length || this.cmp(Mi) < 0 ? {
        div: new Be(0),
        mod: this
      } : Mi.length === 1 ? Ai === "div" ? {
        div: this.divn(Mi.words[0]),
        mod: null
      } : Ai === "mod" ? {
        div: null,
        mod: new Be(this.modn(Mi.words[0]))
      } : {
        div: this.divn(Mi.words[0]),
        mod: new Be(this.modn(Mi.words[0]))
      } : this._wordDiv(Mi, Ai);
    }, Be.prototype.div = function(Mi) {
      return this.divmod(Mi, "div", !1).div;
    }, Be.prototype.mod = function(Mi) {
      return this.divmod(Mi, "mod", !1).mod;
    }, Be.prototype.umod = function(Mi) {
      return this.divmod(Mi, "mod", !0).mod;
    }, Be.prototype.divRound = function(Mi) {
      var Ai = this.divmod(Mi);
      if (Ai.mod.isZero()) return Ai.div;
      var wi = Ai.div.negative !== 0 ? Ai.mod.isub(Mi) : Ai.mod, Ei = Mi.ushrn(1), Ti = Mi.andln(1), Pi = wi.cmp(Ei);
      return Pi < 0 || Ti === 1 && Pi === 0 ? Ai.div : Ai.div.negative !== 0 ? Ai.div.isubn(1) : Ai.div.iaddn(1);
    }, Be.prototype.modn = function(Mi) {
      Ie(Mi <= 67108863);
      for (var Ai = (1 << 26) % Mi, wi = 0, Ei = this.length - 1; Ei >= 0; Ei--)
        wi = (Ai * wi + (this.words[Ei] | 0)) % Mi;
      return wi;
    }, Be.prototype.idivn = function(Mi) {
      Ie(Mi <= 67108863);
      for (var Ai = 0, wi = this.length - 1; wi >= 0; wi--) {
        var Ei = (this.words[wi] | 0) + Ai * 67108864;
        this.words[wi] = Ei / Mi | 0, Ai = Ei % Mi;
      }
      return this.strip();
    }, Be.prototype.divn = function(Mi) {
      return this.clone().idivn(Mi);
    }, Be.prototype.egcd = function(Mi) {
      Ie(Mi.negative === 0), Ie(!Mi.isZero());
      var Ai = this, wi = Mi.clone();
      Ai.negative !== 0 ? Ai = Ai.umod(Mi) : Ai = Ai.clone();
      for (var Ei = new Be(1), Ti = new Be(0), Pi = new Be(0), qi = new Be(1), Oi = 0; Ai.isEven() && wi.isEven(); )
        Ai.iushrn(1), wi.iushrn(1), ++Oi;
      for (var Si = wi.clone(), Ni = Ai.clone(); !Ai.isZero(); ) {
        for (var xi = 0, Wi = 1; !(Ai.words[0] & Wi) && xi < 26; ++xi, Wi <<= 1) ;
        if (xi > 0)
          for (Ai.iushrn(xi); xi-- > 0; )
            (Ei.isOdd() || Ti.isOdd()) && (Ei.iadd(Si), Ti.isub(Ni)), Ei.iushrn(1), Ti.iushrn(1);
        for (var ts = 0, Ki = 1; !(wi.words[0] & Ki) && ts < 26; ++ts, Ki <<= 1) ;
        if (ts > 0)
          for (wi.iushrn(ts); ts-- > 0; )
            (Pi.isOdd() || qi.isOdd()) && (Pi.iadd(Si), qi.isub(Ni)), Pi.iushrn(1), qi.iushrn(1);
        Ai.cmp(wi) >= 0 ? (Ai.isub(wi), Ei.isub(Pi), Ti.isub(qi)) : (wi.isub(Ai), Pi.isub(Ei), qi.isub(Ti));
      }
      return {
        a: Pi,
        b: qi,
        gcd: wi.iushln(Oi)
      };
    }, Be.prototype._invmp = function(Mi) {
      Ie(Mi.negative === 0), Ie(!Mi.isZero());
      var Ai = this, wi = Mi.clone();
      Ai.negative !== 0 ? Ai = Ai.umod(Mi) : Ai = Ai.clone();
      for (var Ei = new Be(1), Ti = new Be(0), Pi = wi.clone(); Ai.cmpn(1) > 0 && wi.cmpn(1) > 0; ) {
        for (var qi = 0, Oi = 1; !(Ai.words[0] & Oi) && qi < 26; ++qi, Oi <<= 1) ;
        if (qi > 0)
          for (Ai.iushrn(qi); qi-- > 0; )
            Ei.isOdd() && Ei.iadd(Pi), Ei.iushrn(1);
        for (var Si = 0, Ni = 1; !(wi.words[0] & Ni) && Si < 26; ++Si, Ni <<= 1) ;
        if (Si > 0)
          for (wi.iushrn(Si); Si-- > 0; )
            Ti.isOdd() && Ti.iadd(Pi), Ti.iushrn(1);
        Ai.cmp(wi) >= 0 ? (Ai.isub(wi), Ei.isub(Ti)) : (wi.isub(Ai), Ti.isub(Ei));
      }
      var xi;
      return Ai.cmpn(1) === 0 ? xi = Ei : xi = Ti, xi.cmpn(0) < 0 && xi.iadd(Mi), xi;
    }, Be.prototype.gcd = function(Mi) {
      if (this.isZero()) return Mi.abs();
      if (Mi.isZero()) return this.abs();
      var Ai = this.clone(), wi = Mi.clone();
      Ai.negative = 0, wi.negative = 0;
      for (var Ei = 0; Ai.isEven() && wi.isEven(); Ei++)
        Ai.iushrn(1), wi.iushrn(1);
      do {
        for (; Ai.isEven(); )
          Ai.iushrn(1);
        for (; wi.isEven(); )
          wi.iushrn(1);
        var Ti = Ai.cmp(wi);
        if (Ti < 0) {
          var Pi = Ai;
          Ai = wi, wi = Pi;
        } else if (Ti === 0 || wi.cmpn(1) === 0)
          break;
        Ai.isub(wi);
      } while (!0);
      return wi.iushln(Ei);
    }, Be.prototype.invm = function(Mi) {
      return this.egcd(Mi).a.umod(Mi);
    }, Be.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, Be.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, Be.prototype.andln = function(Mi) {
      return this.words[0] & Mi;
    }, Be.prototype.bincn = function(Mi) {
      Ie(typeof Mi == "number");
      var Ai = Mi % 26, wi = (Mi - Ai) / 26, Ei = 1 << Ai;
      if (this.length <= wi)
        return this._expand(wi + 1), this.words[wi] |= Ei, this;
      for (var Ti = Ei, Pi = wi; Ti !== 0 && Pi < this.length; Pi++) {
        var qi = this.words[Pi] | 0;
        qi += Ti, Ti = qi >>> 26, qi &= 67108863, this.words[Pi] = qi;
      }
      return Ti !== 0 && (this.words[Pi] = Ti, this.length++), this;
    }, Be.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, Be.prototype.cmpn = function(Mi) {
      var Ai = Mi < 0;
      if (this.negative !== 0 && !Ai) return -1;
      if (this.negative === 0 && Ai) return 1;
      this.strip();
      var wi;
      if (this.length > 1)
        wi = 1;
      else {
        Ai && (Mi = -Mi), Ie(Mi <= 67108863, "Number is too big");
        var Ei = this.words[0] | 0;
        wi = Ei === Mi ? 0 : Ei < Mi ? -1 : 1;
      }
      return this.negative !== 0 ? -wi | 0 : wi;
    }, Be.prototype.cmp = function(Mi) {
      if (this.negative !== 0 && Mi.negative === 0) return -1;
      if (this.negative === 0 && Mi.negative !== 0) return 1;
      var Ai = this.ucmp(Mi);
      return this.negative !== 0 ? -Ai | 0 : Ai;
    }, Be.prototype.ucmp = function(Mi) {
      if (this.length > Mi.length) return 1;
      if (this.length < Mi.length) return -1;
      for (var Ai = 0, wi = this.length - 1; wi >= 0; wi--) {
        var Ei = this.words[wi] | 0, Ti = Mi.words[wi] | 0;
        if (Ei !== Ti) {
          Ei < Ti ? Ai = -1 : Ei > Ti && (Ai = 1);
          break;
        }
      }
      return Ai;
    }, Be.prototype.gtn = function(Mi) {
      return this.cmpn(Mi) === 1;
    }, Be.prototype.gt = function(Mi) {
      return this.cmp(Mi) === 1;
    }, Be.prototype.gten = function(Mi) {
      return this.cmpn(Mi) >= 0;
    }, Be.prototype.gte = function(Mi) {
      return this.cmp(Mi) >= 0;
    }, Be.prototype.ltn = function(Mi) {
      return this.cmpn(Mi) === -1;
    }, Be.prototype.lt = function(Mi) {
      return this.cmp(Mi) === -1;
    }, Be.prototype.lten = function(Mi) {
      return this.cmpn(Mi) <= 0;
    }, Be.prototype.lte = function(Mi) {
      return this.cmp(Mi) <= 0;
    }, Be.prototype.eqn = function(Mi) {
      return this.cmpn(Mi) === 0;
    }, Be.prototype.eq = function(Mi) {
      return this.cmp(Mi) === 0;
    }, Be.red = function(Mi) {
      return new ns(Mi);
    }, Be.prototype.toRed = function(Mi) {
      return Ie(!this.red, "Already a number in reduction context"), Ie(this.negative === 0, "red works only with positives"), Mi.convertTo(this)._forceRed(Mi);
    }, Be.prototype.fromRed = function() {
      return Ie(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, Be.prototype._forceRed = function(Mi) {
      return this.red = Mi, this;
    }, Be.prototype.forceRed = function(Mi) {
      return Ie(!this.red, "Already a number in reduction context"), this._forceRed(Mi);
    }, Be.prototype.redAdd = function(Mi) {
      return Ie(this.red, "redAdd works only with red numbers"), this.red.add(this, Mi);
    }, Be.prototype.redIAdd = function(Mi) {
      return Ie(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, Mi);
    }, Be.prototype.redSub = function(Mi) {
      return Ie(this.red, "redSub works only with red numbers"), this.red.sub(this, Mi);
    }, Be.prototype.redISub = function(Mi) {
      return Ie(this.red, "redISub works only with red numbers"), this.red.isub(this, Mi);
    }, Be.prototype.redShl = function(Mi) {
      return Ie(this.red, "redShl works only with red numbers"), this.red.shl(this, Mi);
    }, Be.prototype.redMul = function(Mi) {
      return Ie(this.red, "redMul works only with red numbers"), this.red._verify2(this, Mi), this.red.mul(this, Mi);
    }, Be.prototype.redIMul = function(Mi) {
      return Ie(this.red, "redMul works only with red numbers"), this.red._verify2(this, Mi), this.red.imul(this, Mi);
    }, Be.prototype.redSqr = function() {
      return Ie(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, Be.prototype.redISqr = function() {
      return Ie(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, Be.prototype.redSqrt = function() {
      return Ie(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, Be.prototype.redInvm = function() {
      return Ie(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, Be.prototype.redNeg = function() {
      return Ie(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, Be.prototype.redPow = function(Mi) {
      return Ie(this.red && !Mi.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, Mi);
    };
    var Ji = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Hi(vn, Mi) {
      this.name = vn, this.p = new Be(Mi, 16), this.n = this.p.bitLength(), this.k = new Be(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Hi.prototype._tmp = function() {
      var Mi = new Be(null);
      return Mi.words = new Array(Math.ceil(this.n / 13)), Mi;
    }, Hi.prototype.ireduce = function(Mi) {
      var Ai = Mi, wi;
      do
        this.split(Ai, this.tmp), Ai = this.imulK(Ai), Ai = Ai.iadd(this.tmp), wi = Ai.bitLength();
      while (wi > this.n);
      var Ei = wi < this.n ? -1 : Ai.ucmp(this.p);
      return Ei === 0 ? (Ai.words[0] = 0, Ai.length = 1) : Ei > 0 ? Ai.isub(this.p) : Ai.strip !== void 0 ? Ai.strip() : Ai._strip(), Ai;
    }, Hi.prototype.split = function(Mi, Ai) {
      Mi.iushrn(this.n, 0, Ai);
    }, Hi.prototype.imulK = function(Mi) {
      return Mi.imul(this.k);
    };
    function Zi() {
      Hi.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    Pe(Zi, Hi), Zi.prototype.split = function(Mi, Ai) {
      for (var wi = 4194303, Ei = Math.min(Mi.length, 9), Ti = 0; Ti < Ei; Ti++)
        Ai.words[Ti] = Mi.words[Ti];
      if (Ai.length = Ei, Mi.length <= 9) {
        Mi.words[0] = 0, Mi.length = 1;
        return;
      }
      var Pi = Mi.words[9];
      for (Ai.words[Ai.length++] = Pi & wi, Ti = 10; Ti < Mi.length; Ti++) {
        var qi = Mi.words[Ti] | 0;
        Mi.words[Ti - 10] = (qi & wi) << 4 | Pi >>> 22, Pi = qi;
      }
      Pi >>>= 22, Mi.words[Ti - 10] = Pi, Pi === 0 && Mi.length > 10 ? Mi.length -= 10 : Mi.length -= 9;
    }, Zi.prototype.imulK = function(Mi) {
      Mi.words[Mi.length] = 0, Mi.words[Mi.length + 1] = 0, Mi.length += 2;
      for (var Ai = 0, wi = 0; wi < Mi.length; wi++) {
        var Ei = Mi.words[wi] | 0;
        Ai += Ei * 977, Mi.words[wi] = Ai & 67108863, Ai = Ei * 64 + (Ai / 67108864 | 0);
      }
      return Mi.words[Mi.length - 1] === 0 && (Mi.length--, Mi.words[Mi.length - 1] === 0 && Mi.length--), Mi;
    };
    function Qi() {
      Hi.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    Pe(Qi, Hi);
    function Bi() {
      Hi.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    Pe(Bi, Hi);
    function Xi() {
      Hi.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    Pe(Xi, Hi), Xi.prototype.imulK = function(Mi) {
      for (var Ai = 0, wi = 0; wi < Mi.length; wi++) {
        var Ei = (Mi.words[wi] | 0) * 19 + Ai, Ti = Ei & 67108863;
        Ei >>>= 26, Mi.words[wi] = Ti, Ai = Ei;
      }
      return Ai !== 0 && (Mi.words[Mi.length++] = Ai), Mi;
    }, Be._prime = function(Mi) {
      if (Ji[Mi]) return Ji[Mi];
      var Ai;
      if (Mi === "k256")
        Ai = new Zi();
      else if (Mi === "p224")
        Ai = new Qi();
      else if (Mi === "p192")
        Ai = new Bi();
      else if (Mi === "p25519")
        Ai = new Xi();
      else
        throw new Error("Unknown prime " + Mi);
      return Ji[Mi] = Ai, Ai;
    };
    function ns(vn) {
      if (typeof vn == "string") {
        var Mi = Be._prime(vn);
        this.m = Mi.p, this.prime = Mi;
      } else
        Ie(vn.gtn(1), "modulus must be greater than 1"), this.m = vn, this.prime = null;
    }
    ns.prototype._verify1 = function(Mi) {
      Ie(Mi.negative === 0, "red works only with positives"), Ie(Mi.red, "red works only with red numbers");
    }, ns.prototype._verify2 = function(Mi, Ai) {
      Ie((Mi.negative | Ai.negative) === 0, "red works only with positives"), Ie(
        Mi.red && Mi.red === Ai.red,
        "red works only with red numbers"
      );
    }, ns.prototype.imod = function(Mi) {
      return this.prime ? this.prime.ireduce(Mi)._forceRed(this) : Mi.umod(this.m)._forceRed(this);
    }, ns.prototype.neg = function(Mi) {
      return Mi.isZero() ? Mi.clone() : this.m.sub(Mi)._forceRed(this);
    }, ns.prototype.add = function(Mi, Ai) {
      this._verify2(Mi, Ai);
      var wi = Mi.add(Ai);
      return wi.cmp(this.m) >= 0 && wi.isub(this.m), wi._forceRed(this);
    }, ns.prototype.iadd = function(Mi, Ai) {
      this._verify2(Mi, Ai);
      var wi = Mi.iadd(Ai);
      return wi.cmp(this.m) >= 0 && wi.isub(this.m), wi;
    }, ns.prototype.sub = function(Mi, Ai) {
      this._verify2(Mi, Ai);
      var wi = Mi.sub(Ai);
      return wi.cmpn(0) < 0 && wi.iadd(this.m), wi._forceRed(this);
    }, ns.prototype.isub = function(Mi, Ai) {
      this._verify2(Mi, Ai);
      var wi = Mi.isub(Ai);
      return wi.cmpn(0) < 0 && wi.iadd(this.m), wi;
    }, ns.prototype.shl = function(Mi, Ai) {
      return this._verify1(Mi), this.imod(Mi.ushln(Ai));
    }, ns.prototype.imul = function(Mi, Ai) {
      return this._verify2(Mi, Ai), this.imod(Mi.imul(Ai));
    }, ns.prototype.mul = function(Mi, Ai) {
      return this._verify2(Mi, Ai), this.imod(Mi.mul(Ai));
    }, ns.prototype.isqr = function(Mi) {
      return this.imul(Mi, Mi.clone());
    }, ns.prototype.sqr = function(Mi) {
      return this.mul(Mi, Mi);
    }, ns.prototype.sqrt = function(Mi) {
      if (Mi.isZero()) return Mi.clone();
      var Ai = this.m.andln(3);
      if (Ie(Ai % 2 === 1), Ai === 3) {
        var wi = this.m.add(new Be(1)).iushrn(2);
        return this.pow(Mi, wi);
      }
      for (var Ei = this.m.subn(1), Ti = 0; !Ei.isZero() && Ei.andln(1) === 0; )
        Ti++, Ei.iushrn(1);
      Ie(!Ei.isZero());
      var Pi = new Be(1).toRed(this), qi = Pi.redNeg(), Oi = this.m.subn(1).iushrn(1), Si = this.m.bitLength();
      for (Si = new Be(2 * Si * Si).toRed(this); this.pow(Si, Oi).cmp(qi) !== 0; )
        Si.redIAdd(qi);
      for (var Ni = this.pow(Si, Ei), xi = this.pow(Mi, Ei.addn(1).iushrn(1)), Wi = this.pow(Mi, Ei), ts = Ti; Wi.cmp(Pi) !== 0; ) {
        for (var Ki = Wi, fn = 0; Ki.cmp(Pi) !== 0; fn++)
          Ki = Ki.redSqr();
        Ie(fn < ts);
        var Ii = this.pow(Ni, new Be(1).iushln(ts - fn - 1));
        xi = xi.redMul(Ii), Ni = Ii.redSqr(), Wi = Wi.redMul(Ni), ts = fn;
      }
      return xi;
    }, ns.prototype.invm = function(Mi) {
      var Ai = Mi._invmp(this.m);
      return Ai.negative !== 0 ? (Ai.negative = 0, this.imod(Ai).redNeg()) : this.imod(Ai);
    }, ns.prototype.pow = function(Mi, Ai) {
      if (Ai.isZero()) return new Be(1).toRed(this);
      if (Ai.cmpn(1) === 0) return Mi.clone();
      var wi = 4, Ei = new Array(1 << wi);
      Ei[0] = new Be(1).toRed(this), Ei[1] = Mi;
      for (var Ti = 2; Ti < Ei.length; Ti++)
        Ei[Ti] = this.mul(Ei[Ti - 1], Mi);
      var Pi = Ei[0], qi = 0, Oi = 0, Si = Ai.bitLength() % 26;
      for (Si === 0 && (Si = 26), Ti = Ai.length - 1; Ti >= 0; Ti--) {
        for (var Ni = Ai.words[Ti], xi = Si - 1; xi >= 0; xi--) {
          var Wi = Ni >> xi & 1;
          if (Pi !== Ei[0] && (Pi = this.sqr(Pi)), Wi === 0 && qi === 0) {
            Oi = 0;
            continue;
          }
          qi <<= 1, qi |= Wi, Oi++, !(Oi !== wi && (Ti !== 0 || xi !== 0)) && (Pi = this.mul(Pi, Ei[qi]), Oi = 0, qi = 0);
        }
        Si = 26;
      }
      return Pi;
    }, ns.prototype.convertTo = function(Mi) {
      var Ai = Mi.umod(this.m);
      return Ai === Mi ? Ai.clone() : Ai;
    }, ns.prototype.convertFrom = function(Mi) {
      var Ai = Mi.clone();
      return Ai.red = null, Ai;
    }, Be.mont = function(Mi) {
      return new ls(Mi);
    };
    function ls(vn) {
      ns.call(this, vn), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new Be(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    Pe(ls, ns), ls.prototype.convertTo = function(Mi) {
      return this.imod(Mi.ushln(this.shift));
    }, ls.prototype.convertFrom = function(Mi) {
      var Ai = this.imod(Mi.mul(this.rinv));
      return Ai.red = null, Ai;
    }, ls.prototype.imul = function(Mi, Ai) {
      if (Mi.isZero() || Ai.isZero())
        return Mi.words[0] = 0, Mi.length = 1, Mi;
      var wi = Mi.imul(Ai), Ei = wi.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Ti = wi.isub(Ei).iushrn(this.shift), Pi = Ti;
      return Ti.cmp(this.m) >= 0 ? Pi = Ti.isub(this.m) : Ti.cmpn(0) < 0 && (Pi = Ti.iadd(this.m)), Pi._forceRed(this);
    }, ls.prototype.mul = function(Mi, Ai) {
      if (Mi.isZero() || Ai.isZero()) return new Be(0)._forceRed(this);
      var wi = Mi.mul(Ai), Ei = wi.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Ti = wi.isub(Ei).iushrn(this.shift), Pi = Ti;
      return Ti.cmp(this.m) >= 0 ? Pi = Ti.isub(this.m) : Ti.cmpn(0) < 0 && (Pi = Ti.iadd(this.m)), Pi._forceRed(this);
    }, ls.prototype.invm = function(Mi) {
      var Ai = this.imod(Mi._invmp(this.m).mul(this.r2));
      return Ai._forceRed(this);
    };
  })(Ae, commonjsGlobal);
})(bn$2);
var bnExports = bn$2.exports, utils$c = {};
(function(Ae) {
  var t = Ae;
  function Me(Be, Te) {
    if (Array.isArray(Be))
      return Be.slice();
    if (!Be)
      return [];
    var je = [];
    if (typeof Be != "string") {
      for (var Ve = 0; Ve < Be.length; Ve++)
        je[Ve] = Be[Ve] | 0;
      return je;
    }
    if (Te === "hex") {
      Be = Be.replace(/[^a-z0-9]+/ig, ""), Be.length % 2 !== 0 && (Be = "0" + Be);
      for (var Ve = 0; Ve < Be.length; Ve += 2)
        je.push(parseInt(Be[Ve] + Be[Ve + 1], 16));
    } else
      for (var Ve = 0; Ve < Be.length; Ve++) {
        var fi = Be.charCodeAt(Ve), Ue = fi >> 8, bi = fi & 255;
        Ue ? je.push(Ue, bi) : je.push(bi);
      }
    return je;
  }
  t.toArray = Me;
  function Ie(Be) {
    return Be.length === 1 ? "0" + Be : Be;
  }
  t.zero2 = Ie;
  function Pe(Be) {
    for (var Te = "", je = 0; je < Be.length; je++)
      Te += Ie(Be[je].toString(16));
    return Te;
  }
  t.toHex = Pe, t.encode = function(Te, je) {
    return je === "hex" ? Pe(Te) : Te;
  };
})(utils$c);
(function(Ae) {
  var t = Ae, Me = bnExports, Ie = minimalisticAssert$1, Pe = utils$c;
  t.assert = Ie, t.toArray = Pe.toArray, t.zero2 = Pe.zero2, t.toHex = Pe.toHex, t.encode = Pe.encode;
  function Be(Ue, bi, vi) {
    var mi = new Array(Math.max(Ue.bitLength(), vi) + 1), _i;
    for (_i = 0; _i < mi.length; _i += 1)
      mi[_i] = 0;
    var $i = 1 << bi + 1, Ci = Ue.clone();
    for (_i = 0; _i < mi.length; _i++) {
      var Ui, ki = Ci.andln($i - 1);
      Ci.isOdd() ? (ki > ($i >> 1) - 1 ? Ui = ($i >> 1) - ki : Ui = ki, Ci.isubn(Ui)) : Ui = 0, mi[_i] = Ui, Ci.iushrn(1);
    }
    return mi;
  }
  t.getNAF = Be;
  function Te(Ue, bi) {
    var vi = [
      [],
      []
    ];
    Ue = Ue.clone(), bi = bi.clone();
    for (var mi = 0, _i = 0, $i; Ue.cmpn(-mi) > 0 || bi.cmpn(-_i) > 0; ) {
      var Ci = Ue.andln(3) + mi & 3, Ui = bi.andln(3) + _i & 3;
      Ci === 3 && (Ci = -1), Ui === 3 && (Ui = -1);
      var ki;
      Ci & 1 ? ($i = Ue.andln(7) + mi & 7, ($i === 3 || $i === 5) && Ui === 2 ? ki = -Ci : ki = Ci) : ki = 0, vi[0].push(ki);
      var Ji;
      Ui & 1 ? ($i = bi.andln(7) + _i & 7, ($i === 3 || $i === 5) && Ci === 2 ? Ji = -Ui : Ji = Ui) : Ji = 0, vi[1].push(Ji), 2 * mi === ki + 1 && (mi = 1 - mi), 2 * _i === Ji + 1 && (_i = 1 - _i), Ue.iushrn(1), bi.iushrn(1);
    }
    return vi;
  }
  t.getJSF = Te;
  function je(Ue, bi, vi) {
    var mi = "_" + bi;
    Ue.prototype[bi] = function() {
      return this[mi] !== void 0 ? this[mi] : this[mi] = vi.call(this);
    };
  }
  t.cachedProperty = je;
  function Ve(Ue) {
    return typeof Ue == "string" ? t.toArray(Ue, "hex") : Ue;
  }
  t.parseBytes = Ve;
  function fi(Ue) {
    return new Me(Ue, "hex", "le");
  }
  t.intFromLE = fi;
})(utils$d);
var brorand = { exports: {} }, cryptoBrowserify = {}, browser$e = { exports: {} }, safeBuffer$1 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer$1;
function requireSafeBuffer$1() {
  return hasRequiredSafeBuffer$1 || (hasRequiredSafeBuffer$1 = 1, function(Ae, t) {
    var Me = require$$0$3, Ie = Me.Buffer;
    function Pe(Te, je) {
      for (var Ve in Te)
        je[Ve] = Te[Ve];
    }
    Ie.from && Ie.alloc && Ie.allocUnsafe && Ie.allocUnsafeSlow ? Ae.exports = Me : (Pe(Me, t), t.Buffer = Be);
    function Be(Te, je, Ve) {
      return Ie(Te, je, Ve);
    }
    Be.prototype = Object.create(Ie.prototype), Pe(Ie, Be), Be.from = function(Te, je, Ve) {
      if (typeof Te == "number")
        throw new TypeError("Argument must not be a number");
      return Ie(Te, je, Ve);
    }, Be.alloc = function(Te, je, Ve) {
      if (typeof Te != "number")
        throw new TypeError("Argument must be a number");
      var fi = Ie(Te);
      return je !== void 0 ? typeof Ve == "string" ? fi.fill(je, Ve) : fi.fill(je) : fi.fill(0), fi;
    }, Be.allocUnsafe = function(Te) {
      if (typeof Te != "number")
        throw new TypeError("Argument must be a number");
      return Ie(Te);
    }, Be.allocUnsafeSlow = function(Te) {
      if (typeof Te != "number")
        throw new TypeError("Argument must be a number");
      return Me.SlowBuffer(Te);
    };
  }(safeBuffer$1, safeBuffer$1.exports)), safeBuffer$1.exports;
}
var hasRequiredBrowser$b;
function requireBrowser$b() {
  if (hasRequiredBrowser$b) return browser$e.exports;
  hasRequiredBrowser$b = 1;
  var Ae = 65536, t = 4294967295;
  function Me() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var Ie = requireSafeBuffer$1().Buffer, Pe = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  Pe && Pe.getRandomValues ? browser$e.exports = Be : browser$e.exports = Me;
  function Be(Te, je) {
    if (Te > t) throw new RangeError("requested too many random bytes");
    var Ve = Ie.allocUnsafe(Te);
    if (Te > 0)
      if (Te > Ae)
        for (var fi = 0; fi < Te; fi += Ae)
          Pe.getRandomValues(Ve.slice(fi, fi + Ae));
      else
        Pe.getRandomValues(Ve);
    return typeof je == "function" ? process$1.nextTick(function() {
      je(null, Ve);
    }) : Ve;
  }
  return browser$e.exports;
}
var events = { exports: {} }, R$3 = typeof Reflect == "object" ? Reflect : null, ReflectApply = R$3 && typeof R$3.apply == "function" ? R$3.apply : function(t, Me, Ie) {
  return Function.prototype.apply.call(t, Me, Ie);
}, ReflectOwnKeys;
R$3 && typeof R$3.ownKeys == "function" ? ReflectOwnKeys = R$3.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : ReflectOwnKeys = function(t) {
  return Object.getOwnPropertyNames(t);
};
function ProcessEmitWarning(Ae) {
  console && console.warn && console.warn(Ae);
}
var NumberIsNaN = Number.isNaN || function(t) {
  return t !== t;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(Ae) {
  if (typeof Ae != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof Ae);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(Ae) {
    if (typeof Ae != "number" || Ae < 0 || NumberIsNaN(Ae))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + Ae + ".");
    defaultMaxListeners = Ae;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || NumberIsNaN(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function _getMaxListeners(Ae) {
  return Ae._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : Ae._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function(t) {
  for (var Me = [], Ie = 1; Ie < arguments.length; Ie++) Me.push(arguments[Ie]);
  var Pe = t === "error", Be = this._events;
  if (Be !== void 0)
    Pe = Pe && Be.error === void 0;
  else if (!Pe)
    return !1;
  if (Pe) {
    var Te;
    if (Me.length > 0 && (Te = Me[0]), Te instanceof Error)
      throw Te;
    var je = new Error("Unhandled error." + (Te ? " (" + Te.message + ")" : ""));
    throw je.context = Te, je;
  }
  var Ve = Be[t];
  if (Ve === void 0)
    return !1;
  if (typeof Ve == "function")
    ReflectApply(Ve, this, Me);
  else
    for (var fi = Ve.length, Ue = arrayClone(Ve, fi), Ie = 0; Ie < fi; ++Ie)
      ReflectApply(Ue[Ie], this, Me);
  return !0;
};
function _addListener(Ae, t, Me, Ie) {
  var Pe, Be, Te;
  if (checkListener(Me), Be = Ae._events, Be === void 0 ? (Be = Ae._events = /* @__PURE__ */ Object.create(null), Ae._eventsCount = 0) : (Be.newListener !== void 0 && (Ae.emit(
    "newListener",
    t,
    Me.listener ? Me.listener : Me
  ), Be = Ae._events), Te = Be[t]), Te === void 0)
    Te = Be[t] = Me, ++Ae._eventsCount;
  else if (typeof Te == "function" ? Te = Be[t] = Ie ? [Me, Te] : [Te, Me] : Ie ? Te.unshift(Me) : Te.push(Me), Pe = _getMaxListeners(Ae), Pe > 0 && Te.length > Pe && !Te.warned) {
    Te.warned = !0;
    var je = new Error("Possible EventEmitter memory leak detected. " + Te.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    je.name = "MaxListenersExceededWarning", je.emitter = Ae, je.type = t, je.count = Te.length, ProcessEmitWarning(je);
  }
  return Ae;
}
EventEmitter.prototype.addListener = function(t, Me) {
  return _addListener(this, t, Me, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function(t, Me) {
  return _addListener(this, t, Me, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(Ae, t, Me) {
  var Ie = { fired: !1, wrapFn: void 0, target: Ae, type: t, listener: Me }, Pe = onceWrapper.bind(Ie);
  return Pe.listener = Me, Ie.wrapFn = Pe, Pe;
}
EventEmitter.prototype.once = function(t, Me) {
  return checkListener(Me), this.on(t, _onceWrap(this, t, Me)), this;
};
EventEmitter.prototype.prependOnceListener = function(t, Me) {
  return checkListener(Me), this.prependListener(t, _onceWrap(this, t, Me)), this;
};
EventEmitter.prototype.removeListener = function(t, Me) {
  var Ie, Pe, Be, Te, je;
  if (checkListener(Me), Pe = this._events, Pe === void 0)
    return this;
  if (Ie = Pe[t], Ie === void 0)
    return this;
  if (Ie === Me || Ie.listener === Me)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete Pe[t], Pe.removeListener && this.emit("removeListener", t, Ie.listener || Me));
  else if (typeof Ie != "function") {
    for (Be = -1, Te = Ie.length - 1; Te >= 0; Te--)
      if (Ie[Te] === Me || Ie[Te].listener === Me) {
        je = Ie[Te].listener, Be = Te;
        break;
      }
    if (Be < 0)
      return this;
    Be === 0 ? Ie.shift() : spliceOne(Ie, Be), Ie.length === 1 && (Pe[t] = Ie[0]), Pe.removeListener !== void 0 && this.emit("removeListener", t, je || Me);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function(t) {
  var Me, Ie, Pe;
  if (Ie = this._events, Ie === void 0)
    return this;
  if (Ie.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Ie[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Ie[t]), this;
  if (arguments.length === 0) {
    var Be = Object.keys(Ie), Te;
    for (Pe = 0; Pe < Be.length; ++Pe)
      Te = Be[Pe], Te !== "removeListener" && this.removeAllListeners(Te);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (Me = Ie[t], typeof Me == "function")
    this.removeListener(t, Me);
  else if (Me !== void 0)
    for (Pe = Me.length - 1; Pe >= 0; Pe--)
      this.removeListener(t, Me[Pe]);
  return this;
};
function _listeners(Ae, t, Me) {
  var Ie = Ae._events;
  if (Ie === void 0)
    return [];
  var Pe = Ie[t];
  return Pe === void 0 ? [] : typeof Pe == "function" ? Me ? [Pe.listener || Pe] : [Pe] : Me ? unwrapListeners(Pe) : arrayClone(Pe, Pe.length);
}
EventEmitter.prototype.listeners = function(t) {
  return _listeners(this, t, !0);
};
EventEmitter.prototype.rawListeners = function(t) {
  return _listeners(this, t, !1);
};
EventEmitter.listenerCount = function(Ae, t) {
  return typeof Ae.listenerCount == "function" ? Ae.listenerCount(t) : listenerCount.call(Ae, t);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(Ae) {
  var t = this._events;
  if (t !== void 0) {
    var Me = t[Ae];
    if (typeof Me == "function")
      return 1;
    if (Me !== void 0)
      return Me.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(Ae, t) {
  for (var Me = new Array(t), Ie = 0; Ie < t; ++Ie)
    Me[Ie] = Ae[Ie];
  return Me;
}
function spliceOne(Ae, t) {
  for (; t + 1 < Ae.length; t++)
    Ae[t] = Ae[t + 1];
  Ae.pop();
}
function unwrapListeners(Ae) {
  for (var t = new Array(Ae.length), Me = 0; Me < t.length; ++Me)
    t[Me] = Ae[Me].listener || Ae[Me];
  return t;
}
function once(Ae, t) {
  return new Promise(function(Me, Ie) {
    function Pe(Te) {
      Ae.removeListener(t, Be), Ie(Te);
    }
    function Be() {
      typeof Ae.removeListener == "function" && Ae.removeListener("error", Pe), Me([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(Ae, t, Be, { once: !0 }), t !== "error" && addErrorHandlerIfEventEmitter(Ae, Pe, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(Ae, t, Me) {
  typeof Ae.on == "function" && eventTargetAgnosticAddListener(Ae, "error", t, Me);
}
function eventTargetAgnosticAddListener(Ae, t, Me, Ie) {
  if (typeof Ae.on == "function")
    Ie.once ? Ae.once(t, Me) : Ae.on(t, Me);
  else if (typeof Ae.addEventListener == "function")
    Ae.addEventListener(t, function Pe(Be) {
      Ie.once && Ae.removeEventListener(t, Pe), Me(Be);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof Ae);
}
var eventsExports = events.exports;
const es = /* @__PURE__ */ getDefaultExportFromCjs(eventsExports);
var streamBrowser$1, hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
  return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1, streamBrowser$1 = eventsExports.EventEmitter), streamBrowser$1;
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function Ae(_i, $i) {
    var Ci = Object.keys(_i);
    if (Object.getOwnPropertySymbols) {
      var Ui = Object.getOwnPropertySymbols(_i);
      $i && (Ui = Ui.filter(function(ki) {
        return Object.getOwnPropertyDescriptor(_i, ki).enumerable;
      })), Ci.push.apply(Ci, Ui);
    }
    return Ci;
  }
  function t(_i) {
    for (var $i = 1; $i < arguments.length; $i++) {
      var Ci = arguments[$i] != null ? arguments[$i] : {};
      $i % 2 ? Ae(Object(Ci), !0).forEach(function(Ui) {
        Me(_i, Ui, Ci[Ui]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_i, Object.getOwnPropertyDescriptors(Ci)) : Ae(Object(Ci)).forEach(function(Ui) {
        Object.defineProperty(_i, Ui, Object.getOwnPropertyDescriptor(Ci, Ui));
      });
    }
    return _i;
  }
  function Me(_i, $i, Ci) {
    return $i = Te($i), $i in _i ? Object.defineProperty(_i, $i, { value: Ci, enumerable: !0, configurable: !0, writable: !0 }) : _i[$i] = Ci, _i;
  }
  function Ie(_i, $i) {
    if (!(_i instanceof $i))
      throw new TypeError("Cannot call a class as a function");
  }
  function Pe(_i, $i) {
    for (var Ci = 0; Ci < $i.length; Ci++) {
      var Ui = $i[Ci];
      Ui.enumerable = Ui.enumerable || !1, Ui.configurable = !0, "value" in Ui && (Ui.writable = !0), Object.defineProperty(_i, Te(Ui.key), Ui);
    }
  }
  function Be(_i, $i, Ci) {
    return $i && Pe(_i.prototype, $i), Object.defineProperty(_i, "prototype", { writable: !1 }), _i;
  }
  function Te(_i) {
    var $i = je(_i, "string");
    return typeof $i == "symbol" ? $i : String($i);
  }
  function je(_i, $i) {
    if (typeof _i != "object" || _i === null) return _i;
    var Ci = _i[Symbol.toPrimitive];
    if (Ci !== void 0) {
      var Ui = Ci.call(_i, $i || "default");
      if (typeof Ui != "object") return Ui;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ($i === "string" ? String : Number)(_i);
  }
  var Ve = require$$0$3, fi = Ve.Buffer, Ue = util$1, bi = Ue.inspect, vi = bi && bi.custom || "inspect";
  function mi(_i, $i, Ci) {
    fi.prototype.copy.call(_i, $i, Ci);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function _i() {
      Ie(this, _i), this.head = null, this.tail = null, this.length = 0;
    }
    return Be(_i, [{
      key: "push",
      value: function(Ci) {
        var Ui = {
          data: Ci,
          next: null
        };
        this.length > 0 ? this.tail.next = Ui : this.head = Ui, this.tail = Ui, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(Ci) {
        var Ui = {
          data: Ci,
          next: this.head
        };
        this.length === 0 && (this.tail = Ui), this.head = Ui, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var Ci = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Ci;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(Ci) {
        if (this.length === 0) return "";
        for (var Ui = this.head, ki = "" + Ui.data; Ui = Ui.next; ) ki += Ci + Ui.data;
        return ki;
      }
    }, {
      key: "concat",
      value: function(Ci) {
        if (this.length === 0) return fi.alloc(0);
        for (var Ui = fi.allocUnsafe(Ci >>> 0), ki = this.head, Ji = 0; ki; )
          mi(ki.data, Ui, Ji), Ji += ki.data.length, ki = ki.next;
        return Ui;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(Ci, Ui) {
        var ki;
        return Ci < this.head.data.length ? (ki = this.head.data.slice(0, Ci), this.head.data = this.head.data.slice(Ci)) : Ci === this.head.data.length ? ki = this.shift() : ki = Ui ? this._getString(Ci) : this._getBuffer(Ci), ki;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(Ci) {
        var Ui = this.head, ki = 1, Ji = Ui.data;
        for (Ci -= Ji.length; Ui = Ui.next; ) {
          var Hi = Ui.data, Zi = Ci > Hi.length ? Hi.length : Ci;
          if (Zi === Hi.length ? Ji += Hi : Ji += Hi.slice(0, Ci), Ci -= Zi, Ci === 0) {
            Zi === Hi.length ? (++ki, Ui.next ? this.head = Ui.next : this.head = this.tail = null) : (this.head = Ui, Ui.data = Hi.slice(Zi));
            break;
          }
          ++ki;
        }
        return this.length -= ki, Ji;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(Ci) {
        var Ui = fi.allocUnsafe(Ci), ki = this.head, Ji = 1;
        for (ki.data.copy(Ui), Ci -= ki.data.length; ki = ki.next; ) {
          var Hi = ki.data, Zi = Ci > Hi.length ? Hi.length : Ci;
          if (Hi.copy(Ui, Ui.length - Ci, 0, Zi), Ci -= Zi, Ci === 0) {
            Zi === Hi.length ? (++Ji, ki.next ? this.head = ki.next : this.head = this.tail = null) : (this.head = ki, ki.data = Hi.slice(Zi));
            break;
          }
          ++Ji;
        }
        return this.length -= Ji, Ui;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: vi,
      value: function(Ci, Ui) {
        return bi(this, t(t({}, Ui), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), _i;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1) return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  function Ae(Te, je) {
    var Ve = this, fi = this._readableState && this._readableState.destroyed, Ue = this._writableState && this._writableState.destroyed;
    return fi || Ue ? (je ? je(Te) : Te && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(Pe, this, Te)) : process$1.nextTick(Pe, this, Te)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(Te || null, function(bi) {
      !je && bi ? Ve._writableState ? Ve._writableState.errorEmitted ? process$1.nextTick(Me, Ve) : (Ve._writableState.errorEmitted = !0, process$1.nextTick(t, Ve, bi)) : process$1.nextTick(t, Ve, bi) : je ? (process$1.nextTick(Me, Ve), je(bi)) : process$1.nextTick(Me, Ve);
    }), this);
  }
  function t(Te, je) {
    Pe(Te, je), Me(Te);
  }
  function Me(Te) {
    Te._writableState && !Te._writableState.emitClose || Te._readableState && !Te._readableState.emitClose || Te.emit("close");
  }
  function Ie() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function Pe(Te, je) {
    Te.emit("error", je);
  }
  function Be(Te, je) {
    var Ve = Te._readableState, fi = Te._writableState;
    Ve && Ve.autoDestroy || fi && fi.autoDestroy ? Te.destroy(je) : Te.emit("error", je);
  }
  return destroy_1$1 = {
    destroy: Ae,
    undestroy: Ie,
    errorOrDestroy: Be
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function Ae(je, Ve) {
    je.prototype = Object.create(Ve.prototype), je.prototype.constructor = je, je.__proto__ = Ve;
  }
  var t = {};
  function Me(je, Ve, fi) {
    fi || (fi = Error);
    function Ue(vi, mi, _i) {
      return typeof Ve == "string" ? Ve : Ve(vi, mi, _i);
    }
    var bi = /* @__PURE__ */ function(vi) {
      Ae(mi, vi);
      function mi(_i, $i, Ci) {
        return vi.call(this, Ue(_i, $i, Ci)) || this;
      }
      return mi;
    }(fi);
    bi.prototype.name = fi.name, bi.prototype.code = je, t[je] = bi;
  }
  function Ie(je, Ve) {
    if (Array.isArray(je)) {
      var fi = je.length;
      return je = je.map(function(Ue) {
        return String(Ue);
      }), fi > 2 ? "one of ".concat(Ve, " ").concat(je.slice(0, fi - 1).join(", "), ", or ") + je[fi - 1] : fi === 2 ? "one of ".concat(Ve, " ").concat(je[0], " or ").concat(je[1]) : "of ".concat(Ve, " ").concat(je[0]);
    } else
      return "of ".concat(Ve, " ").concat(String(je));
  }
  function Pe(je, Ve, fi) {
    return je.substr(0, Ve.length) === Ve;
  }
  function Be(je, Ve, fi) {
    return (fi === void 0 || fi > je.length) && (fi = je.length), je.substring(fi - Ve.length, fi) === Ve;
  }
  function Te(je, Ve, fi) {
    return typeof fi != "number" && (fi = 0), fi + Ve.length > je.length ? !1 : je.indexOf(Ve, fi) !== -1;
  }
  return Me("ERR_INVALID_OPT_VALUE", function(je, Ve) {
    return 'The value "' + Ve + '" is invalid for option "' + je + '"';
  }, TypeError), Me("ERR_INVALID_ARG_TYPE", function(je, Ve, fi) {
    var Ue;
    typeof Ve == "string" && Pe(Ve, "not ") ? (Ue = "must not be", Ve = Ve.replace(/^not /, "")) : Ue = "must be";
    var bi;
    if (Be(je, " argument"))
      bi = "The ".concat(je, " ").concat(Ue, " ").concat(Ie(Ve, "type"));
    else {
      var vi = Te(je, ".") ? "property" : "argument";
      bi = 'The "'.concat(je, '" ').concat(vi, " ").concat(Ue, " ").concat(Ie(Ve, "type"));
    }
    return bi += ". Received type ".concat(typeof fi), bi;
  }, TypeError), Me("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), Me("ERR_METHOD_NOT_IMPLEMENTED", function(je) {
    return "The " + je + " method is not implemented";
  }), Me("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), Me("ERR_STREAM_DESTROYED", function(je) {
    return "Cannot call " + je + " after a stream was destroyed";
  }), Me("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), Me("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), Me("ERR_STREAM_WRITE_AFTER_END", "write after end"), Me("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), Me("ERR_UNKNOWN_ENCODING", function(je) {
    return "Unknown encoding: " + je;
  }, TypeError), Me("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = t, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var Ae = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function t(Ie, Pe, Be) {
    return Ie.highWaterMark != null ? Ie.highWaterMark : Pe ? Ie[Be] : null;
  }
  function Me(Ie, Pe, Be, Te) {
    var je = t(Pe, Te, Be);
    if (je != null) {
      if (!(isFinite(je) && Math.floor(je) === je) || je < 0) {
        var Ve = Te ? Be : "highWaterMark";
        throw new Ae(Ve, je);
      }
      return Math.floor(je);
    }
    return Ie.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: Me
  }, state;
}
var browser$d, hasRequiredBrowser$a;
function requireBrowser$a() {
  if (hasRequiredBrowser$a) return browser$d;
  hasRequiredBrowser$a = 1, browser$d = Ae;
  function Ae(Me, Ie) {
    if (t("noDeprecation"))
      return Me;
    var Pe = !1;
    function Be() {
      if (!Pe) {
        if (t("throwDeprecation"))
          throw new Error(Ie);
        t("traceDeprecation") ? console.trace(Ie) : console.warn(Ie), Pe = !0;
      }
      return Me.apply(this, arguments);
    }
    return Be;
  }
  function t(Me) {
    try {
      if (!commonjsGlobal.localStorage) return !1;
    } catch {
      return !1;
    }
    var Ie = commonjsGlobal.localStorage[Me];
    return Ie == null ? !1 : String(Ie).toLowerCase() === "true";
  }
  return browser$d;
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = Xi;
  function Ae(fn) {
    var Ii = this;
    this.next = null, this.entry = null, this.finish = function() {
      Ki(Ii, fn);
    };
  }
  var t;
  Xi.WritableState = Qi;
  var Me = {
    deprecate: requireBrowser$a()
  }, Ie = requireStreamBrowser$1(), Pe = require$$0$3.Buffer, Be = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function Te(fn) {
    return Pe.from(fn);
  }
  function je(fn) {
    return Pe.isBuffer(fn) || fn instanceof Be;
  }
  var Ve = requireDestroy$1(), fi = requireState(), Ue = fi.getHighWaterMark, bi = requireErrorsBrowser().codes, vi = bi.ERR_INVALID_ARG_TYPE, mi = bi.ERR_METHOD_NOT_IMPLEMENTED, _i = bi.ERR_MULTIPLE_CALLBACK, $i = bi.ERR_STREAM_CANNOT_PIPE, Ci = bi.ERR_STREAM_DESTROYED, Ui = bi.ERR_STREAM_NULL_VALUES, ki = bi.ERR_STREAM_WRITE_AFTER_END, Ji = bi.ERR_UNKNOWN_ENCODING, Hi = Ve.errorOrDestroy;
  inherits_browserExports(Xi, Ie);
  function Zi() {
  }
  function Qi(fn, Ii, Fi) {
    t = t || require_stream_duplex$1(), fn = fn || {}, typeof Fi != "boolean" && (Fi = Ii instanceof t), this.objectMode = !!fn.objectMode, Fi && (this.objectMode = this.objectMode || !!fn.writableObjectMode), this.highWaterMark = Ue(this, fn, "writableHighWaterMark", Fi), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Gi = fn.decodeStrings === !1;
    this.decodeStrings = !Gi, this.defaultEncoding = fn.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Ri) {
      Ti(Ii, Ri);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = fn.emitClose !== !1, this.autoDestroy = !!fn.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Ae(this);
  }
  Qi.prototype.getBuffer = function() {
    for (var Ii = this.bufferedRequest, Fi = []; Ii; )
      Fi.push(Ii), Ii = Ii.next;
    return Fi;
  }, function() {
    try {
      Object.defineProperty(Qi.prototype, "buffer", {
        get: Me.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Bi;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Bi = Function.prototype[Symbol.hasInstance], Object.defineProperty(Xi, Symbol.hasInstance, {
    value: function(Ii) {
      return Bi.call(this, Ii) ? !0 : this !== Xi ? !1 : Ii && Ii._writableState instanceof Qi;
    }
  })) : Bi = function(Ii) {
    return Ii instanceof this;
  };
  function Xi(fn) {
    t = t || require_stream_duplex$1();
    var Ii = this instanceof t;
    if (!Ii && !Bi.call(Xi, this)) return new Xi(fn);
    this._writableState = new Qi(fn, this, Ii), this.writable = !0, fn && (typeof fn.write == "function" && (this._write = fn.write), typeof fn.writev == "function" && (this._writev = fn.writev), typeof fn.destroy == "function" && (this._destroy = fn.destroy), typeof fn.final == "function" && (this._final = fn.final)), Ie.call(this);
  }
  Xi.prototype.pipe = function() {
    Hi(this, new $i());
  };
  function ns(fn, Ii) {
    var Fi = new ki();
    Hi(fn, Fi), process$1.nextTick(Ii, Fi);
  }
  function ls(fn, Ii, Fi, Gi) {
    var Ri;
    return Fi === null ? Ri = new Ui() : typeof Fi != "string" && !Ii.objectMode && (Ri = new vi("chunk", ["string", "Buffer"], Fi)), Ri ? (Hi(fn, Ri), process$1.nextTick(Gi, Ri), !1) : !0;
  }
  Xi.prototype.write = function(fn, Ii, Fi) {
    var Gi = this._writableState, Ri = !1, ji = !Gi.objectMode && je(fn);
    return ji && !Pe.isBuffer(fn) && (fn = Te(fn)), typeof Ii == "function" && (Fi = Ii, Ii = null), ji ? Ii = "buffer" : Ii || (Ii = Gi.defaultEncoding), typeof Fi != "function" && (Fi = Zi), Gi.ending ? ns(this, Fi) : (ji || ls(this, Gi, fn, Fi)) && (Gi.pendingcb++, Ri = Mi(this, Gi, ji, fn, Ii, Fi)), Ri;
  }, Xi.prototype.cork = function() {
    this._writableState.corked++;
  }, Xi.prototype.uncork = function() {
    var fn = this._writableState;
    fn.corked && (fn.corked--, !fn.writing && !fn.corked && !fn.bufferProcessing && fn.bufferedRequest && Oi(this, fn));
  }, Xi.prototype.setDefaultEncoding = function(Ii) {
    if (typeof Ii == "string" && (Ii = Ii.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Ii + "").toLowerCase()) > -1)) throw new Ji(Ii);
    return this._writableState.defaultEncoding = Ii, this;
  }, Object.defineProperty(Xi.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function vn(fn, Ii, Fi) {
    return !fn.objectMode && fn.decodeStrings !== !1 && typeof Ii == "string" && (Ii = Pe.from(Ii, Fi)), Ii;
  }
  Object.defineProperty(Xi.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Mi(fn, Ii, Fi, Gi, Ri, ji) {
    if (!Fi) {
      var Vi = vn(Ii, Gi, Ri);
      Gi !== Vi && (Fi = !0, Ri = "buffer", Gi = Vi);
    }
    var is = Ii.objectMode ? 1 : Gi.length;
    Ii.length += is;
    var os = Ii.length < Ii.highWaterMark;
    if (os || (Ii.needDrain = !0), Ii.writing || Ii.corked) {
      var ds = Ii.lastBufferedRequest;
      Ii.lastBufferedRequest = {
        chunk: Gi,
        encoding: Ri,
        isBuf: Fi,
        callback: ji,
        next: null
      }, ds ? ds.next = Ii.lastBufferedRequest : Ii.bufferedRequest = Ii.lastBufferedRequest, Ii.bufferedRequestCount += 1;
    } else
      Ai(fn, Ii, !1, is, Gi, Ri, ji);
    return os;
  }
  function Ai(fn, Ii, Fi, Gi, Ri, ji, Vi) {
    Ii.writelen = Gi, Ii.writecb = Vi, Ii.writing = !0, Ii.sync = !0, Ii.destroyed ? Ii.onwrite(new Ci("write")) : Fi ? fn._writev(Ri, Ii.onwrite) : fn._write(Ri, ji, Ii.onwrite), Ii.sync = !1;
  }
  function wi(fn, Ii, Fi, Gi, Ri) {
    --Ii.pendingcb, Fi ? (process$1.nextTick(Ri, Gi), process$1.nextTick(Wi, fn, Ii), fn._writableState.errorEmitted = !0, Hi(fn, Gi)) : (Ri(Gi), fn._writableState.errorEmitted = !0, Hi(fn, Gi), Wi(fn, Ii));
  }
  function Ei(fn) {
    fn.writing = !1, fn.writecb = null, fn.length -= fn.writelen, fn.writelen = 0;
  }
  function Ti(fn, Ii) {
    var Fi = fn._writableState, Gi = Fi.sync, Ri = Fi.writecb;
    if (typeof Ri != "function") throw new _i();
    if (Ei(Fi), Ii) wi(fn, Fi, Gi, Ii, Ri);
    else {
      var ji = Si(Fi) || fn.destroyed;
      !ji && !Fi.corked && !Fi.bufferProcessing && Fi.bufferedRequest && Oi(fn, Fi), Gi ? process$1.nextTick(Pi, fn, Fi, ji, Ri) : Pi(fn, Fi, ji, Ri);
    }
  }
  function Pi(fn, Ii, Fi, Gi) {
    Fi || qi(fn, Ii), Ii.pendingcb--, Gi(), Wi(fn, Ii);
  }
  function qi(fn, Ii) {
    Ii.length === 0 && Ii.needDrain && (Ii.needDrain = !1, fn.emit("drain"));
  }
  function Oi(fn, Ii) {
    Ii.bufferProcessing = !0;
    var Fi = Ii.bufferedRequest;
    if (fn._writev && Fi && Fi.next) {
      var Gi = Ii.bufferedRequestCount, Ri = new Array(Gi), ji = Ii.corkedRequestsFree;
      ji.entry = Fi;
      for (var Vi = 0, is = !0; Fi; )
        Ri[Vi] = Fi, Fi.isBuf || (is = !1), Fi = Fi.next, Vi += 1;
      Ri.allBuffers = is, Ai(fn, Ii, !0, Ii.length, Ri, "", ji.finish), Ii.pendingcb++, Ii.lastBufferedRequest = null, ji.next ? (Ii.corkedRequestsFree = ji.next, ji.next = null) : Ii.corkedRequestsFree = new Ae(Ii), Ii.bufferedRequestCount = 0;
    } else {
      for (; Fi; ) {
        var os = Fi.chunk, ds = Fi.encoding, ps = Fi.callback, ea = Ii.objectMode ? 1 : os.length;
        if (Ai(fn, Ii, !1, ea, os, ds, ps), Fi = Fi.next, Ii.bufferedRequestCount--, Ii.writing)
          break;
      }
      Fi === null && (Ii.lastBufferedRequest = null);
    }
    Ii.bufferedRequest = Fi, Ii.bufferProcessing = !1;
  }
  Xi.prototype._write = function(fn, Ii, Fi) {
    Fi(new mi("_write()"));
  }, Xi.prototype._writev = null, Xi.prototype.end = function(fn, Ii, Fi) {
    var Gi = this._writableState;
    return typeof fn == "function" ? (Fi = fn, fn = null, Ii = null) : typeof Ii == "function" && (Fi = Ii, Ii = null), fn != null && this.write(fn, Ii), Gi.corked && (Gi.corked = 1, this.uncork()), Gi.ending || ts(this, Gi, Fi), this;
  }, Object.defineProperty(Xi.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function Si(fn) {
    return fn.ending && fn.length === 0 && fn.bufferedRequest === null && !fn.finished && !fn.writing;
  }
  function Ni(fn, Ii) {
    fn._final(function(Fi) {
      Ii.pendingcb--, Fi && Hi(fn, Fi), Ii.prefinished = !0, fn.emit("prefinish"), Wi(fn, Ii);
    });
  }
  function xi(fn, Ii) {
    !Ii.prefinished && !Ii.finalCalled && (typeof fn._final == "function" && !Ii.destroyed ? (Ii.pendingcb++, Ii.finalCalled = !0, process$1.nextTick(Ni, fn, Ii)) : (Ii.prefinished = !0, fn.emit("prefinish")));
  }
  function Wi(fn, Ii) {
    var Fi = Si(Ii);
    if (Fi && (xi(fn, Ii), Ii.pendingcb === 0 && (Ii.finished = !0, fn.emit("finish"), Ii.autoDestroy))) {
      var Gi = fn._readableState;
      (!Gi || Gi.autoDestroy && Gi.endEmitted) && fn.destroy();
    }
    return Fi;
  }
  function ts(fn, Ii, Fi) {
    Ii.ending = !0, Wi(fn, Ii), Fi && (Ii.finished ? process$1.nextTick(Fi) : fn.once("finish", Fi)), Ii.ended = !0, fn.writable = !1;
  }
  function Ki(fn, Ii, Fi) {
    var Gi = fn.entry;
    for (fn.entry = null; Gi; ) {
      var Ri = Gi.callback;
      Ii.pendingcb--, Ri(Fi), Gi = Gi.next;
    }
    Ii.corkedRequestsFree.next = fn;
  }
  return Object.defineProperty(Xi.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Ii) {
      this._writableState && (this._writableState.destroyed = Ii);
    }
  }), Xi.prototype.destroy = Ve.destroy, Xi.prototype._undestroy = Ve.undestroy, Xi.prototype._destroy = function(fn, Ii) {
    Ii(fn);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var Ae = Object.keys || function(fi) {
    var Ue = [];
    for (var bi in fi) Ue.push(bi);
    return Ue;
  };
  _stream_duplex$1 = Te;
  var t = require_stream_readable$1(), Me = require_stream_writable$1();
  inherits_browserExports(Te, t);
  for (var Ie = Ae(Me.prototype), Pe = 0; Pe < Ie.length; Pe++) {
    var Be = Ie[Pe];
    Te.prototype[Be] || (Te.prototype[Be] = Me.prototype[Be]);
  }
  function Te(fi) {
    if (!(this instanceof Te)) return new Te(fi);
    t.call(this, fi), Me.call(this, fi), this.allowHalfOpen = !0, fi && (fi.readable === !1 && (this.readable = !1), fi.writable === !1 && (this.writable = !1), fi.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", je)));
  }
  Object.defineProperty(Te.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(Te.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(Te.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function je() {
    this._writableState.ended || process$1.nextTick(Ve, this);
  }
  function Ve(fi) {
    fi.end();
  }
  return Object.defineProperty(Te.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(Ue) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = Ue, this._writableState.destroyed = Ue);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, Buffer = requireSafeBuffer$1().Buffer, isEncoding = Buffer.isEncoding || function(Ae) {
  switch (Ae = "" + Ae, Ae && Ae.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function _normalizeEncoding(Ae) {
  if (!Ae) return "utf8";
  for (var t; ; )
    switch (Ae) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return Ae;
      default:
        if (t) return;
        Ae = ("" + Ae).toLowerCase(), t = !0;
    }
}
function normalizeEncoding(Ae) {
  var t = _normalizeEncoding(Ae);
  if (typeof t != "string" && (Buffer.isEncoding === isEncoding || !isEncoding(Ae))) throw new Error("Unknown encoding: " + Ae);
  return t || Ae;
}
string_decoder.StringDecoder = StringDecoder;
function StringDecoder(Ae) {
  this.encoding = normalizeEncoding(Ae);
  var t;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text, this.end = utf16End, t = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast, t = 4;
      break;
    case "base64":
      this.text = base64Text, this.end = base64End, t = 3;
      break;
    default:
      this.write = simpleWrite, this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer.allocUnsafe(t);
}
StringDecoder.prototype.write = function(Ae) {
  if (Ae.length === 0) return "";
  var t, Me;
  if (this.lastNeed) {
    if (t = this.fillLast(Ae), t === void 0) return "";
    Me = this.lastNeed, this.lastNeed = 0;
  } else
    Me = 0;
  return Me < Ae.length ? t ? t + this.text(Ae, Me) : this.text(Ae, Me) : t || "";
};
StringDecoder.prototype.end = utf8End;
StringDecoder.prototype.text = utf8Text;
StringDecoder.prototype.fillLast = function(Ae) {
  if (this.lastNeed <= Ae.length)
    return Ae.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  Ae.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, Ae.length), this.lastNeed -= Ae.length;
};
function utf8CheckByte(Ae) {
  return Ae <= 127 ? 0 : Ae >> 5 === 6 ? 2 : Ae >> 4 === 14 ? 3 : Ae >> 3 === 30 ? 4 : Ae >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(Ae, t, Me) {
  var Ie = t.length - 1;
  if (Ie < Me) return 0;
  var Pe = utf8CheckByte(t[Ie]);
  return Pe >= 0 ? (Pe > 0 && (Ae.lastNeed = Pe - 1), Pe) : --Ie < Me || Pe === -2 ? 0 : (Pe = utf8CheckByte(t[Ie]), Pe >= 0 ? (Pe > 0 && (Ae.lastNeed = Pe - 2), Pe) : --Ie < Me || Pe === -2 ? 0 : (Pe = utf8CheckByte(t[Ie]), Pe >= 0 ? (Pe > 0 && (Pe === 2 ? Pe = 0 : Ae.lastNeed = Pe - 3), Pe) : 0));
}
function utf8CheckExtraBytes(Ae, t, Me) {
  if ((t[0] & 192) !== 128)
    return Ae.lastNeed = 0, "";
  if (Ae.lastNeed > 1 && t.length > 1) {
    if ((t[1] & 192) !== 128)
      return Ae.lastNeed = 1, "";
    if (Ae.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
      return Ae.lastNeed = 2, "";
  }
}
function utf8FillLast(Ae) {
  var t = this.lastTotal - this.lastNeed, Me = utf8CheckExtraBytes(this, Ae);
  if (Me !== void 0) return Me;
  if (this.lastNeed <= Ae.length)
    return Ae.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  Ae.copy(this.lastChar, t, 0, Ae.length), this.lastNeed -= Ae.length;
}
function utf8Text(Ae, t) {
  var Me = utf8CheckIncomplete(this, Ae, t);
  if (!this.lastNeed) return Ae.toString("utf8", t);
  this.lastTotal = Me;
  var Ie = Ae.length - (Me - this.lastNeed);
  return Ae.copy(this.lastChar, 0, Ie), Ae.toString("utf8", t, Ie);
}
function utf8End(Ae) {
  var t = Ae && Ae.length ? this.write(Ae) : "";
  return this.lastNeed ? t + "" : t;
}
function utf16Text(Ae, t) {
  if ((Ae.length - t) % 2 === 0) {
    var Me = Ae.toString("utf16le", t);
    if (Me) {
      var Ie = Me.charCodeAt(Me.length - 1);
      if (Ie >= 55296 && Ie <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = Ae[Ae.length - 2], this.lastChar[1] = Ae[Ae.length - 1], Me.slice(0, -1);
    }
    return Me;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = Ae[Ae.length - 1], Ae.toString("utf16le", t, Ae.length - 1);
}
function utf16End(Ae) {
  var t = Ae && Ae.length ? this.write(Ae) : "";
  if (this.lastNeed) {
    var Me = this.lastTotal - this.lastNeed;
    return t + this.lastChar.toString("utf16le", 0, Me);
  }
  return t;
}
function base64Text(Ae, t) {
  var Me = (Ae.length - t) % 3;
  return Me === 0 ? Ae.toString("base64", t) : (this.lastNeed = 3 - Me, this.lastTotal = 3, Me === 1 ? this.lastChar[0] = Ae[Ae.length - 1] : (this.lastChar[0] = Ae[Ae.length - 2], this.lastChar[1] = Ae[Ae.length - 1]), Ae.toString("base64", t, Ae.length - Me));
}
function base64End(Ae) {
  var t = Ae && Ae.length ? this.write(Ae) : "";
  return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
}
function simpleWrite(Ae) {
  return Ae.toString(this.encoding);
}
function simpleEnd(Ae) {
  return Ae && Ae.length ? this.write(Ae) : "";
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var Ae = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function t(Be) {
    var Te = !1;
    return function() {
      if (!Te) {
        Te = !0;
        for (var je = arguments.length, Ve = new Array(je), fi = 0; fi < je; fi++)
          Ve[fi] = arguments[fi];
        Be.apply(this, Ve);
      }
    };
  }
  function Me() {
  }
  function Ie(Be) {
    return Be.setHeader && typeof Be.abort == "function";
  }
  function Pe(Be, Te, je) {
    if (typeof Te == "function") return Pe(Be, null, Te);
    Te || (Te = {}), je = t(je || Me);
    var Ve = Te.readable || Te.readable !== !1 && Be.readable, fi = Te.writable || Te.writable !== !1 && Be.writable, Ue = function() {
      Be.writable || vi();
    }, bi = Be._writableState && Be._writableState.finished, vi = function() {
      fi = !1, bi = !0, Ve || je.call(Be);
    }, mi = Be._readableState && Be._readableState.endEmitted, _i = function() {
      Ve = !1, mi = !0, fi || je.call(Be);
    }, $i = function(Ji) {
      je.call(Be, Ji);
    }, Ci = function() {
      var Ji;
      if (Ve && !mi)
        return (!Be._readableState || !Be._readableState.ended) && (Ji = new Ae()), je.call(Be, Ji);
      if (fi && !bi)
        return (!Be._writableState || !Be._writableState.ended) && (Ji = new Ae()), je.call(Be, Ji);
    }, Ui = function() {
      Be.req.on("finish", vi);
    };
    return Ie(Be) ? (Be.on("complete", vi), Be.on("abort", Ci), Be.req ? Ui() : Be.on("request", Ui)) : fi && !Be._writableState && (Be.on("end", Ue), Be.on("close", Ue)), Be.on("end", _i), Be.on("finish", vi), Te.error !== !1 && Be.on("error", $i), Be.on("close", Ci), function() {
      Be.removeListener("complete", vi), Be.removeListener("abort", Ci), Be.removeListener("request", Ui), Be.req && Be.req.removeListener("finish", vi), Be.removeListener("end", Ue), Be.removeListener("close", Ue), Be.removeListener("finish", vi), Be.removeListener("end", _i), Be.removeListener("error", $i), Be.removeListener("close", Ci);
    };
  }
  return endOfStream = Pe, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var Ae;
  function t(Ji, Hi, Zi) {
    return Hi = Me(Hi), Hi in Ji ? Object.defineProperty(Ji, Hi, { value: Zi, enumerable: !0, configurable: !0, writable: !0 }) : Ji[Hi] = Zi, Ji;
  }
  function Me(Ji) {
    var Hi = Ie(Ji, "string");
    return typeof Hi == "symbol" ? Hi : String(Hi);
  }
  function Ie(Ji, Hi) {
    if (typeof Ji != "object" || Ji === null) return Ji;
    var Zi = Ji[Symbol.toPrimitive];
    if (Zi !== void 0) {
      var Qi = Zi.call(Ji, Hi || "default");
      if (typeof Qi != "object") return Qi;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (Hi === "string" ? String : Number)(Ji);
  }
  var Pe = requireEndOfStream(), Be = Symbol("lastResolve"), Te = Symbol("lastReject"), je = Symbol("error"), Ve = Symbol("ended"), fi = Symbol("lastPromise"), Ue = Symbol("handlePromise"), bi = Symbol("stream");
  function vi(Ji, Hi) {
    return {
      value: Ji,
      done: Hi
    };
  }
  function mi(Ji) {
    var Hi = Ji[Be];
    if (Hi !== null) {
      var Zi = Ji[bi].read();
      Zi !== null && (Ji[fi] = null, Ji[Be] = null, Ji[Te] = null, Hi(vi(Zi, !1)));
    }
  }
  function _i(Ji) {
    process$1.nextTick(mi, Ji);
  }
  function $i(Ji, Hi) {
    return function(Zi, Qi) {
      Ji.then(function() {
        if (Hi[Ve]) {
          Zi(vi(void 0, !0));
          return;
        }
        Hi[Ue](Zi, Qi);
      }, Qi);
    };
  }
  var Ci = Object.getPrototypeOf(function() {
  }), Ui = Object.setPrototypeOf((Ae = {
    get stream() {
      return this[bi];
    },
    next: function() {
      var Hi = this, Zi = this[je];
      if (Zi !== null)
        return Promise.reject(Zi);
      if (this[Ve])
        return Promise.resolve(vi(void 0, !0));
      if (this[bi].destroyed)
        return new Promise(function(ns, ls) {
          process$1.nextTick(function() {
            Hi[je] ? ls(Hi[je]) : ns(vi(void 0, !0));
          });
        });
      var Qi = this[fi], Bi;
      if (Qi)
        Bi = new Promise($i(Qi, this));
      else {
        var Xi = this[bi].read();
        if (Xi !== null)
          return Promise.resolve(vi(Xi, !1));
        Bi = new Promise(this[Ue]);
      }
      return this[fi] = Bi, Bi;
    }
  }, t(Ae, Symbol.asyncIterator, function() {
    return this;
  }), t(Ae, "return", function() {
    var Hi = this;
    return new Promise(function(Zi, Qi) {
      Hi[bi].destroy(null, function(Bi) {
        if (Bi) {
          Qi(Bi);
          return;
        }
        Zi(vi(void 0, !0));
      });
    });
  }), Ae), Ci), ki = function(Hi) {
    var Zi, Qi = Object.create(Ui, (Zi = {}, t(Zi, bi, {
      value: Hi,
      writable: !0
    }), t(Zi, Be, {
      value: null,
      writable: !0
    }), t(Zi, Te, {
      value: null,
      writable: !0
    }), t(Zi, je, {
      value: null,
      writable: !0
    }), t(Zi, Ve, {
      value: Hi._readableState.endEmitted,
      writable: !0
    }), t(Zi, Ue, {
      value: function(Xi, ns) {
        var ls = Qi[bi].read();
        ls ? (Qi[fi] = null, Qi[Be] = null, Qi[Te] = null, Xi(vi(ls, !1))) : (Qi[Be] = Xi, Qi[Te] = ns);
      },
      writable: !0
    }), Zi));
    return Qi[fi] = null, Pe(Hi, function(Bi) {
      if (Bi && Bi.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Xi = Qi[Te];
        Xi !== null && (Qi[fi] = null, Qi[Be] = null, Qi[Te] = null, Xi(Bi)), Qi[je] = Bi;
        return;
      }
      var ns = Qi[Be];
      ns !== null && (Qi[fi] = null, Qi[Be] = null, Qi[Te] = null, ns(vi(void 0, !0))), Qi[Ve] = !0;
    }), Hi.on("readable", _i.bind(null, Qi)), Qi;
  };
  return async_iterator = ki, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = ns;
  var Ae;
  ns.ReadableState = Xi, eventsExports.EventEmitter;
  var t = function(Vi, is) {
    return Vi.listeners(is).length;
  }, Me = requireStreamBrowser$1(), Ie = require$$0$3.Buffer, Pe = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function Be(ji) {
    return Ie.from(ji);
  }
  function Te(ji) {
    return Ie.isBuffer(ji) || ji instanceof Pe;
  }
  var je = util$1, Ve;
  je && je.debuglog ? Ve = je.debuglog("stream") : Ve = function() {
  };
  var fi = requireBuffer_list(), Ue = requireDestroy$1(), bi = requireState(), vi = bi.getHighWaterMark, mi = requireErrorsBrowser().codes, _i = mi.ERR_INVALID_ARG_TYPE, $i = mi.ERR_STREAM_PUSH_AFTER_EOF, Ci = mi.ERR_METHOD_NOT_IMPLEMENTED, Ui = mi.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, ki, Ji, Hi;
  inherits_browserExports(ns, Me);
  var Zi = Ue.errorOrDestroy, Qi = ["error", "close", "destroy", "pause", "resume"];
  function Bi(ji, Vi, is) {
    if (typeof ji.prependListener == "function") return ji.prependListener(Vi, is);
    !ji._events || !ji._events[Vi] ? ji.on(Vi, is) : Array.isArray(ji._events[Vi]) ? ji._events[Vi].unshift(is) : ji._events[Vi] = [is, ji._events[Vi]];
  }
  function Xi(ji, Vi, is) {
    Ae = Ae || require_stream_duplex$1(), ji = ji || {}, typeof is != "boolean" && (is = Vi instanceof Ae), this.objectMode = !!ji.objectMode, is && (this.objectMode = this.objectMode || !!ji.readableObjectMode), this.highWaterMark = vi(this, ji, "readableHighWaterMark", is), this.buffer = new fi(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = ji.emitClose !== !1, this.autoDestroy = !!ji.autoDestroy, this.destroyed = !1, this.defaultEncoding = ji.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, ji.encoding && (ki || (ki = string_decoder.StringDecoder), this.decoder = new ki(ji.encoding), this.encoding = ji.encoding);
  }
  function ns(ji) {
    if (Ae = Ae || require_stream_duplex$1(), !(this instanceof ns)) return new ns(ji);
    var Vi = this instanceof Ae;
    this._readableState = new Xi(ji, this, Vi), this.readable = !0, ji && (typeof ji.read == "function" && (this._read = ji.read), typeof ji.destroy == "function" && (this._destroy = ji.destroy)), Me.call(this);
  }
  Object.defineProperty(ns.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Vi) {
      this._readableState && (this._readableState.destroyed = Vi);
    }
  }), ns.prototype.destroy = Ue.destroy, ns.prototype._undestroy = Ue.undestroy, ns.prototype._destroy = function(ji, Vi) {
    Vi(ji);
  }, ns.prototype.push = function(ji, Vi) {
    var is = this._readableState, os;
    return is.objectMode ? os = !0 : typeof ji == "string" && (Vi = Vi || is.defaultEncoding, Vi !== is.encoding && (ji = Ie.from(ji, Vi), Vi = ""), os = !0), ls(this, ji, Vi, !1, os);
  }, ns.prototype.unshift = function(ji) {
    return ls(this, ji, null, !0, !1);
  };
  function ls(ji, Vi, is, os, ds) {
    Ve("readableAddChunk", Vi);
    var ps = ji._readableState;
    if (Vi === null)
      ps.reading = !1, Ti(ji, ps);
    else {
      var ea;
      if (ds || (ea = Mi(ps, Vi)), ea)
        Zi(ji, ea);
      else if (ps.objectMode || Vi && Vi.length > 0)
        if (typeof Vi != "string" && !ps.objectMode && Object.getPrototypeOf(Vi) !== Ie.prototype && (Vi = Be(Vi)), os)
          ps.endEmitted ? Zi(ji, new Ui()) : vn(ji, ps, Vi, !0);
        else if (ps.ended)
          Zi(ji, new $i());
        else {
          if (ps.destroyed)
            return !1;
          ps.reading = !1, ps.decoder && !is ? (Vi = ps.decoder.write(Vi), ps.objectMode || Vi.length !== 0 ? vn(ji, ps, Vi, !1) : Oi(ji, ps)) : vn(ji, ps, Vi, !1);
        }
      else os || (ps.reading = !1, Oi(ji, ps));
    }
    return !ps.ended && (ps.length < ps.highWaterMark || ps.length === 0);
  }
  function vn(ji, Vi, is, os) {
    Vi.flowing && Vi.length === 0 && !Vi.sync ? (Vi.awaitDrain = 0, ji.emit("data", is)) : (Vi.length += Vi.objectMode ? 1 : is.length, os ? Vi.buffer.unshift(is) : Vi.buffer.push(is), Vi.needReadable && Pi(ji)), Oi(ji, Vi);
  }
  function Mi(ji, Vi) {
    var is;
    return !Te(Vi) && typeof Vi != "string" && Vi !== void 0 && !ji.objectMode && (is = new _i("chunk", ["string", "Buffer", "Uint8Array"], Vi)), is;
  }
  ns.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, ns.prototype.setEncoding = function(ji) {
    ki || (ki = string_decoder.StringDecoder);
    var Vi = new ki(ji);
    this._readableState.decoder = Vi, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var is = this._readableState.buffer.head, os = ""; is !== null; )
      os += Vi.write(is.data), is = is.next;
    return this._readableState.buffer.clear(), os !== "" && this._readableState.buffer.push(os), this._readableState.length = os.length, this;
  };
  var Ai = 1073741824;
  function wi(ji) {
    return ji >= Ai ? ji = Ai : (ji--, ji |= ji >>> 1, ji |= ji >>> 2, ji |= ji >>> 4, ji |= ji >>> 8, ji |= ji >>> 16, ji++), ji;
  }
  function Ei(ji, Vi) {
    return ji <= 0 || Vi.length === 0 && Vi.ended ? 0 : Vi.objectMode ? 1 : ji !== ji ? Vi.flowing && Vi.length ? Vi.buffer.head.data.length : Vi.length : (ji > Vi.highWaterMark && (Vi.highWaterMark = wi(ji)), ji <= Vi.length ? ji : Vi.ended ? Vi.length : (Vi.needReadable = !0, 0));
  }
  ns.prototype.read = function(ji) {
    Ve("read", ji), ji = parseInt(ji, 10);
    var Vi = this._readableState, is = ji;
    if (ji !== 0 && (Vi.emittedReadable = !1), ji === 0 && Vi.needReadable && ((Vi.highWaterMark !== 0 ? Vi.length >= Vi.highWaterMark : Vi.length > 0) || Vi.ended))
      return Ve("read: emitReadable", Vi.length, Vi.ended), Vi.length === 0 && Vi.ended ? Fi(this) : Pi(this), null;
    if (ji = Ei(ji, Vi), ji === 0 && Vi.ended)
      return Vi.length === 0 && Fi(this), null;
    var os = Vi.needReadable;
    Ve("need readable", os), (Vi.length === 0 || Vi.length - ji < Vi.highWaterMark) && (os = !0, Ve("length less than watermark", os)), Vi.ended || Vi.reading ? (os = !1, Ve("reading or ended", os)) : os && (Ve("do read"), Vi.reading = !0, Vi.sync = !0, Vi.length === 0 && (Vi.needReadable = !0), this._read(Vi.highWaterMark), Vi.sync = !1, Vi.reading || (ji = Ei(is, Vi)));
    var ds;
    return ji > 0 ? ds = Ii(ji, Vi) : ds = null, ds === null ? (Vi.needReadable = Vi.length <= Vi.highWaterMark, ji = 0) : (Vi.length -= ji, Vi.awaitDrain = 0), Vi.length === 0 && (Vi.ended || (Vi.needReadable = !0), is !== ji && Vi.ended && Fi(this)), ds !== null && this.emit("data", ds), ds;
  };
  function Ti(ji, Vi) {
    if (Ve("onEofChunk"), !Vi.ended) {
      if (Vi.decoder) {
        var is = Vi.decoder.end();
        is && is.length && (Vi.buffer.push(is), Vi.length += Vi.objectMode ? 1 : is.length);
      }
      Vi.ended = !0, Vi.sync ? Pi(ji) : (Vi.needReadable = !1, Vi.emittedReadable || (Vi.emittedReadable = !0, qi(ji)));
    }
  }
  function Pi(ji) {
    var Vi = ji._readableState;
    Ve("emitReadable", Vi.needReadable, Vi.emittedReadable), Vi.needReadable = !1, Vi.emittedReadable || (Ve("emitReadable", Vi.flowing), Vi.emittedReadable = !0, process$1.nextTick(qi, ji));
  }
  function qi(ji) {
    var Vi = ji._readableState;
    Ve("emitReadable_", Vi.destroyed, Vi.length, Vi.ended), !Vi.destroyed && (Vi.length || Vi.ended) && (ji.emit("readable"), Vi.emittedReadable = !1), Vi.needReadable = !Vi.flowing && !Vi.ended && Vi.length <= Vi.highWaterMark, fn(ji);
  }
  function Oi(ji, Vi) {
    Vi.readingMore || (Vi.readingMore = !0, process$1.nextTick(Si, ji, Vi));
  }
  function Si(ji, Vi) {
    for (; !Vi.reading && !Vi.ended && (Vi.length < Vi.highWaterMark || Vi.flowing && Vi.length === 0); ) {
      var is = Vi.length;
      if (Ve("maybeReadMore read 0"), ji.read(0), is === Vi.length)
        break;
    }
    Vi.readingMore = !1;
  }
  ns.prototype._read = function(ji) {
    Zi(this, new Ci("_read()"));
  }, ns.prototype.pipe = function(ji, Vi) {
    var is = this, os = this._readableState;
    switch (os.pipesCount) {
      case 0:
        os.pipes = ji;
        break;
      case 1:
        os.pipes = [os.pipes, ji];
        break;
      default:
        os.pipes.push(ji);
        break;
    }
    os.pipesCount += 1, Ve("pipe count=%d opts=%j", os.pipesCount, Vi);
    var ds = (!Vi || Vi.end !== !1) && ji !== process$1.stdout && ji !== process$1.stderr, ps = ds ? ia : ca;
    os.endEmitted ? process$1.nextTick(ps) : is.once("end", ps), ji.on("unpipe", ea);
    function ea(ta, oa) {
      Ve("onunpipe"), ta === is && oa && oa.hasUnpiped === !1 && (oa.hasUnpiped = !0, gs());
    }
    function ia() {
      Ve("onend"), ji.end();
    }
    var hs = Ni(is);
    ji.on("drain", hs);
    var fa = !1;
    function gs() {
      Ve("cleanup"), ji.removeListener("close", Ds), ji.removeListener("finish", ra), ji.removeListener("drain", hs), ji.removeListener("error", aa), ji.removeListener("unpipe", ea), is.removeListener("end", ia), is.removeListener("end", ca), is.removeListener("data", sa), fa = !0, os.awaitDrain && (!ji._writableState || ji._writableState.needDrain) && hs();
    }
    is.on("data", sa);
    function sa(ta) {
      Ve("ondata");
      var oa = ji.write(ta);
      Ve("dest.write", oa), oa === !1 && ((os.pipesCount === 1 && os.pipes === ji || os.pipesCount > 1 && Ri(os.pipes, ji) !== -1) && !fa && (Ve("false write response, pause", os.awaitDrain), os.awaitDrain++), is.pause());
    }
    function aa(ta) {
      Ve("onerror", ta), ca(), ji.removeListener("error", aa), t(ji, "error") === 0 && Zi(ji, ta);
    }
    Bi(ji, "error", aa);
    function Ds() {
      ji.removeListener("finish", ra), ca();
    }
    ji.once("close", Ds);
    function ra() {
      Ve("onfinish"), ji.removeListener("close", Ds), ca();
    }
    ji.once("finish", ra);
    function ca() {
      Ve("unpipe"), is.unpipe(ji);
    }
    return ji.emit("pipe", is), os.flowing || (Ve("pipe resume"), is.resume()), ji;
  };
  function Ni(ji) {
    return function() {
      var is = ji._readableState;
      Ve("pipeOnDrain", is.awaitDrain), is.awaitDrain && is.awaitDrain--, is.awaitDrain === 0 && t(ji, "data") && (is.flowing = !0, fn(ji));
    };
  }
  ns.prototype.unpipe = function(ji) {
    var Vi = this._readableState, is = {
      hasUnpiped: !1
    };
    if (Vi.pipesCount === 0) return this;
    if (Vi.pipesCount === 1)
      return ji && ji !== Vi.pipes ? this : (ji || (ji = Vi.pipes), Vi.pipes = null, Vi.pipesCount = 0, Vi.flowing = !1, ji && ji.emit("unpipe", this, is), this);
    if (!ji) {
      var os = Vi.pipes, ds = Vi.pipesCount;
      Vi.pipes = null, Vi.pipesCount = 0, Vi.flowing = !1;
      for (var ps = 0; ps < ds; ps++) os[ps].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var ea = Ri(Vi.pipes, ji);
    return ea === -1 ? this : (Vi.pipes.splice(ea, 1), Vi.pipesCount -= 1, Vi.pipesCount === 1 && (Vi.pipes = Vi.pipes[0]), ji.emit("unpipe", this, is), this);
  }, ns.prototype.on = function(ji, Vi) {
    var is = Me.prototype.on.call(this, ji, Vi), os = this._readableState;
    return ji === "data" ? (os.readableListening = this.listenerCount("readable") > 0, os.flowing !== !1 && this.resume()) : ji === "readable" && !os.endEmitted && !os.readableListening && (os.readableListening = os.needReadable = !0, os.flowing = !1, os.emittedReadable = !1, Ve("on readable", os.length, os.reading), os.length ? Pi(this) : os.reading || process$1.nextTick(Wi, this)), is;
  }, ns.prototype.addListener = ns.prototype.on, ns.prototype.removeListener = function(ji, Vi) {
    var is = Me.prototype.removeListener.call(this, ji, Vi);
    return ji === "readable" && process$1.nextTick(xi, this), is;
  }, ns.prototype.removeAllListeners = function(ji) {
    var Vi = Me.prototype.removeAllListeners.apply(this, arguments);
    return (ji === "readable" || ji === void 0) && process$1.nextTick(xi, this), Vi;
  };
  function xi(ji) {
    var Vi = ji._readableState;
    Vi.readableListening = ji.listenerCount("readable") > 0, Vi.resumeScheduled && !Vi.paused ? Vi.flowing = !0 : ji.listenerCount("data") > 0 && ji.resume();
  }
  function Wi(ji) {
    Ve("readable nexttick read 0"), ji.read(0);
  }
  ns.prototype.resume = function() {
    var ji = this._readableState;
    return ji.flowing || (Ve("resume"), ji.flowing = !ji.readableListening, ts(this, ji)), ji.paused = !1, this;
  };
  function ts(ji, Vi) {
    Vi.resumeScheduled || (Vi.resumeScheduled = !0, process$1.nextTick(Ki, ji, Vi));
  }
  function Ki(ji, Vi) {
    Ve("resume", Vi.reading), Vi.reading || ji.read(0), Vi.resumeScheduled = !1, ji.emit("resume"), fn(ji), Vi.flowing && !Vi.reading && ji.read(0);
  }
  ns.prototype.pause = function() {
    return Ve("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (Ve("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function fn(ji) {
    var Vi = ji._readableState;
    for (Ve("flow", Vi.flowing); Vi.flowing && ji.read() !== null; ) ;
  }
  ns.prototype.wrap = function(ji) {
    var Vi = this, is = this._readableState, os = !1;
    ji.on("end", function() {
      if (Ve("wrapped end"), is.decoder && !is.ended) {
        var ea = is.decoder.end();
        ea && ea.length && Vi.push(ea);
      }
      Vi.push(null);
    }), ji.on("data", function(ea) {
      if (Ve("wrapped data"), is.decoder && (ea = is.decoder.write(ea)), !(is.objectMode && ea == null) && !(!is.objectMode && (!ea || !ea.length))) {
        var ia = Vi.push(ea);
        ia || (os = !0, ji.pause());
      }
    });
    for (var ds in ji)
      this[ds] === void 0 && typeof ji[ds] == "function" && (this[ds] = /* @__PURE__ */ function(ia) {
        return function() {
          return ji[ia].apply(ji, arguments);
        };
      }(ds));
    for (var ps = 0; ps < Qi.length; ps++)
      ji.on(Qi[ps], this.emit.bind(this, Qi[ps]));
    return this._read = function(ea) {
      Ve("wrapped _read", ea), os && (os = !1, ji.resume());
    }, this;
  }, typeof Symbol == "function" && (ns.prototype[Symbol.asyncIterator] = function() {
    return Ji === void 0 && (Ji = requireAsync_iterator()), Ji(this);
  }), Object.defineProperty(ns.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(ns.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(ns.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(Vi) {
      this._readableState && (this._readableState.flowing = Vi);
    }
  }), ns._fromList = Ii, Object.defineProperty(ns.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Ii(ji, Vi) {
    if (Vi.length === 0) return null;
    var is;
    return Vi.objectMode ? is = Vi.buffer.shift() : !ji || ji >= Vi.length ? (Vi.decoder ? is = Vi.buffer.join("") : Vi.buffer.length === 1 ? is = Vi.buffer.first() : is = Vi.buffer.concat(Vi.length), Vi.buffer.clear()) : is = Vi.buffer.consume(ji, Vi.decoder), is;
  }
  function Fi(ji) {
    var Vi = ji._readableState;
    Ve("endReadable", Vi.endEmitted), Vi.endEmitted || (Vi.ended = !0, process$1.nextTick(Gi, Vi, ji));
  }
  function Gi(ji, Vi) {
    if (Ve("endReadableNT", ji.endEmitted, ji.length), !ji.endEmitted && ji.length === 0 && (ji.endEmitted = !0, Vi.readable = !1, Vi.emit("end"), ji.autoDestroy)) {
      var is = Vi._writableState;
      (!is || is.autoDestroy && is.finished) && Vi.destroy();
    }
  }
  typeof Symbol == "function" && (ns.from = function(ji, Vi) {
    return Hi === void 0 && (Hi = requireFromBrowser()), Hi(ns, ji, Vi);
  });
  function Ri(ji, Vi) {
    for (var is = 0, os = ji.length; is < os; is++)
      if (ji[is] === Vi) return is;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1) return _stream_transform$1;
  hasRequired_stream_transform$1 = 1, _stream_transform$1 = je;
  var Ae = requireErrorsBrowser().codes, t = Ae.ERR_METHOD_NOT_IMPLEMENTED, Me = Ae.ERR_MULTIPLE_CALLBACK, Ie = Ae.ERR_TRANSFORM_ALREADY_TRANSFORMING, Pe = Ae.ERR_TRANSFORM_WITH_LENGTH_0, Be = require_stream_duplex$1();
  inherits_browserExports(je, Be);
  function Te(Ue, bi) {
    var vi = this._transformState;
    vi.transforming = !1;
    var mi = vi.writecb;
    if (mi === null)
      return this.emit("error", new Me());
    vi.writechunk = null, vi.writecb = null, bi != null && this.push(bi), mi(Ue);
    var _i = this._readableState;
    _i.reading = !1, (_i.needReadable || _i.length < _i.highWaterMark) && this._read(_i.highWaterMark);
  }
  function je(Ue) {
    if (!(this instanceof je)) return new je(Ue);
    Be.call(this, Ue), this._transformState = {
      afterTransform: Te.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, Ue && (typeof Ue.transform == "function" && (this._transform = Ue.transform), typeof Ue.flush == "function" && (this._flush = Ue.flush)), this.on("prefinish", Ve);
  }
  function Ve() {
    var Ue = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(bi, vi) {
      fi(Ue, bi, vi);
    }) : fi(this, null, null);
  }
  je.prototype.push = function(Ue, bi) {
    return this._transformState.needTransform = !1, Be.prototype.push.call(this, Ue, bi);
  }, je.prototype._transform = function(Ue, bi, vi) {
    vi(new t("_transform()"));
  }, je.prototype._write = function(Ue, bi, vi) {
    var mi = this._transformState;
    if (mi.writecb = vi, mi.writechunk = Ue, mi.writeencoding = bi, !mi.transforming) {
      var _i = this._readableState;
      (mi.needTransform || _i.needReadable || _i.length < _i.highWaterMark) && this._read(_i.highWaterMark);
    }
  }, je.prototype._read = function(Ue) {
    var bi = this._transformState;
    bi.writechunk !== null && !bi.transforming ? (bi.transforming = !0, this._transform(bi.writechunk, bi.writeencoding, bi.afterTransform)) : bi.needTransform = !0;
  }, je.prototype._destroy = function(Ue, bi) {
    Be.prototype._destroy.call(this, Ue, function(vi) {
      bi(vi);
    });
  };
  function fi(Ue, bi, vi) {
    if (bi) return Ue.emit("error", bi);
    if (vi != null && Ue.push(vi), Ue._writableState.length) throw new Pe();
    if (Ue._transformState.transforming) throw new Ie();
    return Ue.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1, _stream_passthrough$1 = t;
  var Ae = require_stream_transform$1();
  inherits_browserExports(t, Ae);
  function t(Me) {
    if (!(this instanceof t)) return new t(Me);
    Ae.call(this, Me);
  }
  return t.prototype._transform = function(Me, Ie, Pe) {
    Pe(null, Me);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var Ae;
  function t(vi) {
    var mi = !1;
    return function() {
      mi || (mi = !0, vi.apply(void 0, arguments));
    };
  }
  var Me = requireErrorsBrowser().codes, Ie = Me.ERR_MISSING_ARGS, Pe = Me.ERR_STREAM_DESTROYED;
  function Be(vi) {
    if (vi) throw vi;
  }
  function Te(vi) {
    return vi.setHeader && typeof vi.abort == "function";
  }
  function je(vi, mi, _i, $i) {
    $i = t($i);
    var Ci = !1;
    vi.on("close", function() {
      Ci = !0;
    }), Ae === void 0 && (Ae = requireEndOfStream()), Ae(vi, {
      readable: mi,
      writable: _i
    }, function(ki) {
      if (ki) return $i(ki);
      Ci = !0, $i();
    });
    var Ui = !1;
    return function(ki) {
      if (!Ci && !Ui) {
        if (Ui = !0, Te(vi)) return vi.abort();
        if (typeof vi.destroy == "function") return vi.destroy();
        $i(ki || new Pe("pipe"));
      }
    };
  }
  function Ve(vi) {
    vi();
  }
  function fi(vi, mi) {
    return vi.pipe(mi);
  }
  function Ue(vi) {
    return !vi.length || typeof vi[vi.length - 1] != "function" ? Be : vi.pop();
  }
  function bi() {
    for (var vi = arguments.length, mi = new Array(vi), _i = 0; _i < vi; _i++)
      mi[_i] = arguments[_i];
    var $i = Ue(mi);
    if (Array.isArray(mi[0]) && (mi = mi[0]), mi.length < 2)
      throw new Ie("streams");
    var Ci, Ui = mi.map(function(ki, Ji) {
      var Hi = Ji < mi.length - 1, Zi = Ji > 0;
      return je(ki, Hi, Zi, function(Qi) {
        Ci || (Ci = Qi), Qi && Ui.forEach(Ve), !Hi && (Ui.forEach(Ve), $i(Ci));
      });
    });
    return mi.reduce(fi);
  }
  return pipeline_1 = bi, pipeline_1;
}
var streamBrowserify, hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1, streamBrowserify = Me;
  var Ae = eventsExports.EventEmitter, t = inherits_browserExports;
  t(Me, Ae), Me.Readable = require_stream_readable$1(), Me.Writable = require_stream_writable$1(), Me.Duplex = require_stream_duplex$1(), Me.Transform = require_stream_transform$1(), Me.PassThrough = require_stream_passthrough$1(), Me.finished = requireEndOfStream(), Me.pipeline = requirePipeline(), Me.Stream = Me;
  function Me() {
    Ae.call(this);
  }
  return Me.prototype.pipe = function(Ie, Pe) {
    var Be = this;
    function Te(mi) {
      Ie.writable && Ie.write(mi) === !1 && Be.pause && Be.pause();
    }
    Be.on("data", Te);
    function je() {
      Be.readable && Be.resume && Be.resume();
    }
    Ie.on("drain", je), !Ie._isStdio && (!Pe || Pe.end !== !1) && (Be.on("end", fi), Be.on("close", Ue));
    var Ve = !1;
    function fi() {
      Ve || (Ve = !0, Ie.end());
    }
    function Ue() {
      Ve || (Ve = !0, typeof Ie.destroy == "function" && Ie.destroy());
    }
    function bi(mi) {
      if (vi(), Ae.listenerCount(this, "error") === 0)
        throw mi;
    }
    Be.on("error", bi), Ie.on("error", bi);
    function vi() {
      Be.removeListener("data", Te), Ie.removeListener("drain", je), Be.removeListener("end", fi), Be.removeListener("close", Ue), Be.removeListener("error", bi), Ie.removeListener("error", bi), Be.removeListener("end", vi), Be.removeListener("close", vi), Ie.removeListener("close", vi);
    }
    return Be.on("end", vi), Be.on("close", vi), Ie.on("close", vi), Ie.emit("pipe", Be), Ie;
  }, streamBrowserify;
}
var hashBase, hasRequiredHashBase;
function requireHashBase() {
  if (hasRequiredHashBase) return hashBase;
  hasRequiredHashBase = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requireStreamBrowserify().Transform, Me = inherits_browserExports;
  function Ie(Be, Te) {
    if (!Ae.isBuffer(Be) && typeof Be != "string")
      throw new TypeError(Te + " must be a string or a buffer");
  }
  function Pe(Be) {
    t.call(this), this._block = Ae.allocUnsafe(Be), this._blockSize = Be, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return Me(Pe, t), Pe.prototype._transform = function(Be, Te, je) {
    var Ve = null;
    try {
      this.update(Be, Te);
    } catch (fi) {
      Ve = fi;
    }
    je(Ve);
  }, Pe.prototype._flush = function(Be) {
    var Te = null;
    try {
      this.push(this.digest());
    } catch (je) {
      Te = je;
    }
    Be(Te);
  }, Pe.prototype.update = function(Be, Te) {
    if (Ie(Be, "Data"), this._finalized) throw new Error("Digest already called");
    Ae.isBuffer(Be) || (Be = Ae.from(Be, Te));
    for (var je = this._block, Ve = 0; this._blockOffset + Be.length - Ve >= this._blockSize; ) {
      for (var fi = this._blockOffset; fi < this._blockSize; ) je[fi++] = Be[Ve++];
      this._update(), this._blockOffset = 0;
    }
    for (; Ve < Be.length; ) je[this._blockOffset++] = Be[Ve++];
    for (var Ue = 0, bi = Be.length * 8; bi > 0; ++Ue)
      this._length[Ue] += bi, bi = this._length[Ue] / 4294967296 | 0, bi > 0 && (this._length[Ue] -= 4294967296 * bi);
    return this;
  }, Pe.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, Pe.prototype.digest = function(Be) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = !0;
    var Te = this._digest();
    Be !== void 0 && (Te = Te.toString(Be)), this._block.fill(0), this._blockOffset = 0;
    for (var je = 0; je < 4; ++je) this._length[je] = 0;
    return Te;
  }, Pe.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase = Pe, hashBase;
}
var md5_js, hasRequiredMd5_js;
function requireMd5_js() {
  if (hasRequiredMd5_js) return md5_js;
  hasRequiredMd5_js = 1;
  var Ae = inherits_browserExports, t = requireHashBase(), Me = requireSafeBuffer$1().Buffer, Ie = new Array(16);
  function Pe() {
    t.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  Ae(Pe, t), Pe.prototype._update = function() {
    for (var Ue = Ie, bi = 0; bi < 16; ++bi) Ue[bi] = this._block.readInt32LE(bi * 4);
    var vi = this._a, mi = this._b, _i = this._c, $i = this._d;
    vi = Te(vi, mi, _i, $i, Ue[0], 3614090360, 7), $i = Te($i, vi, mi, _i, Ue[1], 3905402710, 12), _i = Te(_i, $i, vi, mi, Ue[2], 606105819, 17), mi = Te(mi, _i, $i, vi, Ue[3], 3250441966, 22), vi = Te(vi, mi, _i, $i, Ue[4], 4118548399, 7), $i = Te($i, vi, mi, _i, Ue[5], 1200080426, 12), _i = Te(_i, $i, vi, mi, Ue[6], 2821735955, 17), mi = Te(mi, _i, $i, vi, Ue[7], 4249261313, 22), vi = Te(vi, mi, _i, $i, Ue[8], 1770035416, 7), $i = Te($i, vi, mi, _i, Ue[9], 2336552879, 12), _i = Te(_i, $i, vi, mi, Ue[10], 4294925233, 17), mi = Te(mi, _i, $i, vi, Ue[11], 2304563134, 22), vi = Te(vi, mi, _i, $i, Ue[12], 1804603682, 7), $i = Te($i, vi, mi, _i, Ue[13], 4254626195, 12), _i = Te(_i, $i, vi, mi, Ue[14], 2792965006, 17), mi = Te(mi, _i, $i, vi, Ue[15], 1236535329, 22), vi = je(vi, mi, _i, $i, Ue[1], 4129170786, 5), $i = je($i, vi, mi, _i, Ue[6], 3225465664, 9), _i = je(_i, $i, vi, mi, Ue[11], 643717713, 14), mi = je(mi, _i, $i, vi, Ue[0], 3921069994, 20), vi = je(vi, mi, _i, $i, Ue[5], 3593408605, 5), $i = je($i, vi, mi, _i, Ue[10], 38016083, 9), _i = je(_i, $i, vi, mi, Ue[15], 3634488961, 14), mi = je(mi, _i, $i, vi, Ue[4], 3889429448, 20), vi = je(vi, mi, _i, $i, Ue[9], 568446438, 5), $i = je($i, vi, mi, _i, Ue[14], 3275163606, 9), _i = je(_i, $i, vi, mi, Ue[3], 4107603335, 14), mi = je(mi, _i, $i, vi, Ue[8], 1163531501, 20), vi = je(vi, mi, _i, $i, Ue[13], 2850285829, 5), $i = je($i, vi, mi, _i, Ue[2], 4243563512, 9), _i = je(_i, $i, vi, mi, Ue[7], 1735328473, 14), mi = je(mi, _i, $i, vi, Ue[12], 2368359562, 20), vi = Ve(vi, mi, _i, $i, Ue[5], 4294588738, 4), $i = Ve($i, vi, mi, _i, Ue[8], 2272392833, 11), _i = Ve(_i, $i, vi, mi, Ue[11], 1839030562, 16), mi = Ve(mi, _i, $i, vi, Ue[14], 4259657740, 23), vi = Ve(vi, mi, _i, $i, Ue[1], 2763975236, 4), $i = Ve($i, vi, mi, _i, Ue[4], 1272893353, 11), _i = Ve(_i, $i, vi, mi, Ue[7], 4139469664, 16), mi = Ve(mi, _i, $i, vi, Ue[10], 3200236656, 23), vi = Ve(vi, mi, _i, $i, Ue[13], 681279174, 4), $i = Ve($i, vi, mi, _i, Ue[0], 3936430074, 11), _i = Ve(_i, $i, vi, mi, Ue[3], 3572445317, 16), mi = Ve(mi, _i, $i, vi, Ue[6], 76029189, 23), vi = Ve(vi, mi, _i, $i, Ue[9], 3654602809, 4), $i = Ve($i, vi, mi, _i, Ue[12], 3873151461, 11), _i = Ve(_i, $i, vi, mi, Ue[15], 530742520, 16), mi = Ve(mi, _i, $i, vi, Ue[2], 3299628645, 23), vi = fi(vi, mi, _i, $i, Ue[0], 4096336452, 6), $i = fi($i, vi, mi, _i, Ue[7], 1126891415, 10), _i = fi(_i, $i, vi, mi, Ue[14], 2878612391, 15), mi = fi(mi, _i, $i, vi, Ue[5], 4237533241, 21), vi = fi(vi, mi, _i, $i, Ue[12], 1700485571, 6), $i = fi($i, vi, mi, _i, Ue[3], 2399980690, 10), _i = fi(_i, $i, vi, mi, Ue[10], 4293915773, 15), mi = fi(mi, _i, $i, vi, Ue[1], 2240044497, 21), vi = fi(vi, mi, _i, $i, Ue[8], 1873313359, 6), $i = fi($i, vi, mi, _i, Ue[15], 4264355552, 10), _i = fi(_i, $i, vi, mi, Ue[6], 2734768916, 15), mi = fi(mi, _i, $i, vi, Ue[13], 1309151649, 21), vi = fi(vi, mi, _i, $i, Ue[4], 4149444226, 6), $i = fi($i, vi, mi, _i, Ue[11], 3174756917, 10), _i = fi(_i, $i, vi, mi, Ue[2], 718787259, 15), mi = fi(mi, _i, $i, vi, Ue[9], 3951481745, 21), this._a = this._a + vi | 0, this._b = this._b + mi | 0, this._c = this._c + _i | 0, this._d = this._d + $i | 0;
  }, Pe.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var Ue = Me.allocUnsafe(16);
    return Ue.writeInt32LE(this._a, 0), Ue.writeInt32LE(this._b, 4), Ue.writeInt32LE(this._c, 8), Ue.writeInt32LE(this._d, 12), Ue;
  };
  function Be(Ue, bi) {
    return Ue << bi | Ue >>> 32 - bi;
  }
  function Te(Ue, bi, vi, mi, _i, $i, Ci) {
    return Be(Ue + (bi & vi | ~bi & mi) + _i + $i | 0, Ci) + bi | 0;
  }
  function je(Ue, bi, vi, mi, _i, $i, Ci) {
    return Be(Ue + (bi & mi | vi & ~mi) + _i + $i | 0, Ci) + bi | 0;
  }
  function Ve(Ue, bi, vi, mi, _i, $i, Ci) {
    return Be(Ue + (bi ^ vi ^ mi) + _i + $i | 0, Ci) + bi | 0;
  }
  function fi(Ue, bi, vi, mi, _i, $i, Ci) {
    return Be(Ue + (vi ^ (bi | ~mi)) + _i + $i | 0, Ci) + bi | 0;
  }
  return md5_js = Pe, md5_js;
}
var ripemd160, hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160;
  hasRequiredRipemd160 = 1;
  var Ae = require$$0$3.Buffer, t = inherits_browserExports, Me = requireHashBase(), Ie = new Array(16), Pe = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], Be = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], Te = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], je = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], Ve = [0, 1518500249, 1859775393, 2400959708, 2840853838], fi = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function Ue() {
    Me.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  t(Ue, Me), Ue.prototype._update = function() {
    for (var Ui = Ie, ki = 0; ki < 16; ++ki) Ui[ki] = this._block.readInt32LE(ki * 4);
    for (var Ji = this._a | 0, Hi = this._b | 0, Zi = this._c | 0, Qi = this._d | 0, Bi = this._e | 0, Xi = this._a | 0, ns = this._b | 0, ls = this._c | 0, vn = this._d | 0, Mi = this._e | 0, Ai = 0; Ai < 80; Ai += 1) {
      var wi, Ei;
      Ai < 16 ? (wi = vi(Ji, Hi, Zi, Qi, Bi, Ui[Pe[Ai]], Ve[0], Te[Ai]), Ei = Ci(Xi, ns, ls, vn, Mi, Ui[Be[Ai]], fi[0], je[Ai])) : Ai < 32 ? (wi = mi(Ji, Hi, Zi, Qi, Bi, Ui[Pe[Ai]], Ve[1], Te[Ai]), Ei = $i(Xi, ns, ls, vn, Mi, Ui[Be[Ai]], fi[1], je[Ai])) : Ai < 48 ? (wi = _i(Ji, Hi, Zi, Qi, Bi, Ui[Pe[Ai]], Ve[2], Te[Ai]), Ei = _i(Xi, ns, ls, vn, Mi, Ui[Be[Ai]], fi[2], je[Ai])) : Ai < 64 ? (wi = $i(Ji, Hi, Zi, Qi, Bi, Ui[Pe[Ai]], Ve[3], Te[Ai]), Ei = mi(Xi, ns, ls, vn, Mi, Ui[Be[Ai]], fi[3], je[Ai])) : (wi = Ci(Ji, Hi, Zi, Qi, Bi, Ui[Pe[Ai]], Ve[4], Te[Ai]), Ei = vi(Xi, ns, ls, vn, Mi, Ui[Be[Ai]], fi[4], je[Ai])), Ji = Bi, Bi = Qi, Qi = bi(Zi, 10), Zi = Hi, Hi = wi, Xi = Mi, Mi = vn, vn = bi(ls, 10), ls = ns, ns = Ei;
    }
    var Ti = this._b + Zi + vn | 0;
    this._b = this._c + Qi + Mi | 0, this._c = this._d + Bi + Xi | 0, this._d = this._e + Ji + ns | 0, this._e = this._a + Hi + ls | 0, this._a = Ti;
  }, Ue.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var Ui = Ae.alloc ? Ae.alloc(20) : new Ae(20);
    return Ui.writeInt32LE(this._a, 0), Ui.writeInt32LE(this._b, 4), Ui.writeInt32LE(this._c, 8), Ui.writeInt32LE(this._d, 12), Ui.writeInt32LE(this._e, 16), Ui;
  };
  function bi(Ui, ki) {
    return Ui << ki | Ui >>> 32 - ki;
  }
  function vi(Ui, ki, Ji, Hi, Zi, Qi, Bi, Xi) {
    return bi(Ui + (ki ^ Ji ^ Hi) + Qi + Bi | 0, Xi) + Zi | 0;
  }
  function mi(Ui, ki, Ji, Hi, Zi, Qi, Bi, Xi) {
    return bi(Ui + (ki & Ji | ~ki & Hi) + Qi + Bi | 0, Xi) + Zi | 0;
  }
  function _i(Ui, ki, Ji, Hi, Zi, Qi, Bi, Xi) {
    return bi(Ui + ((ki | ~Ji) ^ Hi) + Qi + Bi | 0, Xi) + Zi | 0;
  }
  function $i(Ui, ki, Ji, Hi, Zi, Qi, Bi, Xi) {
    return bi(Ui + (ki & Hi | Ji & ~Hi) + Qi + Bi | 0, Xi) + Zi | 0;
  }
  function Ci(Ui, ki, Ji, Hi, Zi, Qi, Bi, Xi) {
    return bi(Ui + (ki ^ (Ji | ~Hi)) + Qi + Bi | 0, Xi) + Zi | 0;
  }
  return ripemd160 = Ue, ripemd160;
}
var sha_js = { exports: {} }, hash$3, hasRequiredHash;
function requireHash() {
  if (hasRequiredHash) return hash$3;
  hasRequiredHash = 1;
  var Ae = requireSafeBuffer$1().Buffer;
  function t(Me, Ie) {
    this._block = Ae.alloc(Me), this._finalSize = Ie, this._blockSize = Me, this._len = 0;
  }
  return t.prototype.update = function(Me, Ie) {
    typeof Me == "string" && (Ie = Ie || "utf8", Me = Ae.from(Me, Ie));
    for (var Pe = this._block, Be = this._blockSize, Te = Me.length, je = this._len, Ve = 0; Ve < Te; ) {
      for (var fi = je % Be, Ue = Math.min(Te - Ve, Be - fi), bi = 0; bi < Ue; bi++)
        Pe[fi + bi] = Me[Ve + bi];
      je += Ue, Ve += Ue, je % Be === 0 && this._update(Pe);
    }
    return this._len += Te, this;
  }, t.prototype.digest = function(Me) {
    var Ie = this._len % this._blockSize;
    this._block[Ie] = 128, this._block.fill(0, Ie + 1), Ie >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var Pe = this._len * 8;
    if (Pe <= 4294967295)
      this._block.writeUInt32BE(Pe, this._blockSize - 4);
    else {
      var Be = (Pe & 4294967295) >>> 0, Te = (Pe - Be) / 4294967296;
      this._block.writeUInt32BE(Te, this._blockSize - 8), this._block.writeUInt32BE(Be, this._blockSize - 4);
    }
    this._update(this._block);
    var je = this._hash();
    return Me ? je.toString(Me) : je;
  }, t.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, hash$3 = t, hash$3;
}
var sha, hasRequiredSha;
function requireSha() {
  if (hasRequiredSha) return sha;
  hasRequiredSha = 1;
  var Ae = inherits_browserExports, t = requireHash(), Me = requireSafeBuffer$1().Buffer, Ie = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], Pe = new Array(80);
  function Be() {
    this.init(), this._w = Pe, t.call(this, 64, 56);
  }
  Ae(Be, t), Be.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function Te(fi) {
    return fi << 5 | fi >>> 27;
  }
  function je(fi) {
    return fi << 30 | fi >>> 2;
  }
  function Ve(fi, Ue, bi, vi) {
    return fi === 0 ? Ue & bi | ~Ue & vi : fi === 2 ? Ue & bi | Ue & vi | bi & vi : Ue ^ bi ^ vi;
  }
  return Be.prototype._update = function(fi) {
    for (var Ue = this._w, bi = this._a | 0, vi = this._b | 0, mi = this._c | 0, _i = this._d | 0, $i = this._e | 0, Ci = 0; Ci < 16; ++Ci) Ue[Ci] = fi.readInt32BE(Ci * 4);
    for (; Ci < 80; ++Ci) Ue[Ci] = Ue[Ci - 3] ^ Ue[Ci - 8] ^ Ue[Ci - 14] ^ Ue[Ci - 16];
    for (var Ui = 0; Ui < 80; ++Ui) {
      var ki = ~~(Ui / 20), Ji = Te(bi) + Ve(ki, vi, mi, _i) + $i + Ue[Ui] + Ie[ki] | 0;
      $i = _i, _i = mi, mi = je(vi), vi = bi, bi = Ji;
    }
    this._a = bi + this._a | 0, this._b = vi + this._b | 0, this._c = mi + this._c | 0, this._d = _i + this._d | 0, this._e = $i + this._e | 0;
  }, Be.prototype._hash = function() {
    var fi = Me.allocUnsafe(20);
    return fi.writeInt32BE(this._a | 0, 0), fi.writeInt32BE(this._b | 0, 4), fi.writeInt32BE(this._c | 0, 8), fi.writeInt32BE(this._d | 0, 12), fi.writeInt32BE(this._e | 0, 16), fi;
  }, sha = Be, sha;
}
var sha1, hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1;
  hasRequiredSha1 = 1;
  var Ae = inherits_browserExports, t = requireHash(), Me = requireSafeBuffer$1().Buffer, Ie = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], Pe = new Array(80);
  function Be() {
    this.init(), this._w = Pe, t.call(this, 64, 56);
  }
  Ae(Be, t), Be.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function Te(Ue) {
    return Ue << 1 | Ue >>> 31;
  }
  function je(Ue) {
    return Ue << 5 | Ue >>> 27;
  }
  function Ve(Ue) {
    return Ue << 30 | Ue >>> 2;
  }
  function fi(Ue, bi, vi, mi) {
    return Ue === 0 ? bi & vi | ~bi & mi : Ue === 2 ? bi & vi | bi & mi | vi & mi : bi ^ vi ^ mi;
  }
  return Be.prototype._update = function(Ue) {
    for (var bi = this._w, vi = this._a | 0, mi = this._b | 0, _i = this._c | 0, $i = this._d | 0, Ci = this._e | 0, Ui = 0; Ui < 16; ++Ui) bi[Ui] = Ue.readInt32BE(Ui * 4);
    for (; Ui < 80; ++Ui) bi[Ui] = Te(bi[Ui - 3] ^ bi[Ui - 8] ^ bi[Ui - 14] ^ bi[Ui - 16]);
    for (var ki = 0; ki < 80; ++ki) {
      var Ji = ~~(ki / 20), Hi = je(vi) + fi(Ji, mi, _i, $i) + Ci + bi[ki] + Ie[Ji] | 0;
      Ci = $i, $i = _i, _i = Ve(mi), mi = vi, vi = Hi;
    }
    this._a = vi + this._a | 0, this._b = mi + this._b | 0, this._c = _i + this._c | 0, this._d = $i + this._d | 0, this._e = Ci + this._e | 0;
  }, Be.prototype._hash = function() {
    var Ue = Me.allocUnsafe(20);
    return Ue.writeInt32BE(this._a | 0, 0), Ue.writeInt32BE(this._b | 0, 4), Ue.writeInt32BE(this._c | 0, 8), Ue.writeInt32BE(this._d | 0, 12), Ue.writeInt32BE(this._e | 0, 16), Ue;
  }, sha1 = Be, sha1;
}
var sha256$2, hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$2;
  hasRequiredSha256 = 1;
  var Ae = inherits_browserExports, t = requireHash(), Me = requireSafeBuffer$1().Buffer, Ie = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], Pe = new Array(64);
  function Be() {
    this.init(), this._w = Pe, t.call(this, 64, 56);
  }
  Ae(Be, t), Be.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function Te(vi, mi, _i) {
    return _i ^ vi & (mi ^ _i);
  }
  function je(vi, mi, _i) {
    return vi & mi | _i & (vi | mi);
  }
  function Ve(vi) {
    return (vi >>> 2 | vi << 30) ^ (vi >>> 13 | vi << 19) ^ (vi >>> 22 | vi << 10);
  }
  function fi(vi) {
    return (vi >>> 6 | vi << 26) ^ (vi >>> 11 | vi << 21) ^ (vi >>> 25 | vi << 7);
  }
  function Ue(vi) {
    return (vi >>> 7 | vi << 25) ^ (vi >>> 18 | vi << 14) ^ vi >>> 3;
  }
  function bi(vi) {
    return (vi >>> 17 | vi << 15) ^ (vi >>> 19 | vi << 13) ^ vi >>> 10;
  }
  return Be.prototype._update = function(vi) {
    for (var mi = this._w, _i = this._a | 0, $i = this._b | 0, Ci = this._c | 0, Ui = this._d | 0, ki = this._e | 0, Ji = this._f | 0, Hi = this._g | 0, Zi = this._h | 0, Qi = 0; Qi < 16; ++Qi) mi[Qi] = vi.readInt32BE(Qi * 4);
    for (; Qi < 64; ++Qi) mi[Qi] = bi(mi[Qi - 2]) + mi[Qi - 7] + Ue(mi[Qi - 15]) + mi[Qi - 16] | 0;
    for (var Bi = 0; Bi < 64; ++Bi) {
      var Xi = Zi + fi(ki) + Te(ki, Ji, Hi) + Ie[Bi] + mi[Bi] | 0, ns = Ve(_i) + je(_i, $i, Ci) | 0;
      Zi = Hi, Hi = Ji, Ji = ki, ki = Ui + Xi | 0, Ui = Ci, Ci = $i, $i = _i, _i = Xi + ns | 0;
    }
    this._a = _i + this._a | 0, this._b = $i + this._b | 0, this._c = Ci + this._c | 0, this._d = Ui + this._d | 0, this._e = ki + this._e | 0, this._f = Ji + this._f | 0, this._g = Hi + this._g | 0, this._h = Zi + this._h | 0;
  }, Be.prototype._hash = function() {
    var vi = Me.allocUnsafe(32);
    return vi.writeInt32BE(this._a, 0), vi.writeInt32BE(this._b, 4), vi.writeInt32BE(this._c, 8), vi.writeInt32BE(this._d, 12), vi.writeInt32BE(this._e, 16), vi.writeInt32BE(this._f, 20), vi.writeInt32BE(this._g, 24), vi.writeInt32BE(this._h, 28), vi;
  }, sha256$2 = Be, sha256$2;
}
var sha224$1, hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha224$1;
  hasRequiredSha224 = 1;
  var Ae = inherits_browserExports, t = requireSha256(), Me = requireHash(), Ie = requireSafeBuffer$1().Buffer, Pe = new Array(64);
  function Be() {
    this.init(), this._w = Pe, Me.call(this, 64, 56);
  }
  return Ae(Be, t), Be.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, Be.prototype._hash = function() {
    var Te = Ie.allocUnsafe(28);
    return Te.writeInt32BE(this._a, 0), Te.writeInt32BE(this._b, 4), Te.writeInt32BE(this._c, 8), Te.writeInt32BE(this._d, 12), Te.writeInt32BE(this._e, 16), Te.writeInt32BE(this._f, 20), Te.writeInt32BE(this._g, 24), Te;
  }, sha224$1 = Be, sha224$1;
}
var sha512$2, hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$2;
  hasRequiredSha512 = 1;
  var Ae = inherits_browserExports, t = requireHash(), Me = requireSafeBuffer$1().Buffer, Ie = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], Pe = new Array(160);
  function Be() {
    this.init(), this._w = Pe, t.call(this, 128, 112);
  }
  Ae(Be, t), Be.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function Te($i, Ci, Ui) {
    return Ui ^ $i & (Ci ^ Ui);
  }
  function je($i, Ci, Ui) {
    return $i & Ci | Ui & ($i | Ci);
  }
  function Ve($i, Ci) {
    return ($i >>> 28 | Ci << 4) ^ (Ci >>> 2 | $i << 30) ^ (Ci >>> 7 | $i << 25);
  }
  function fi($i, Ci) {
    return ($i >>> 14 | Ci << 18) ^ ($i >>> 18 | Ci << 14) ^ (Ci >>> 9 | $i << 23);
  }
  function Ue($i, Ci) {
    return ($i >>> 1 | Ci << 31) ^ ($i >>> 8 | Ci << 24) ^ $i >>> 7;
  }
  function bi($i, Ci) {
    return ($i >>> 1 | Ci << 31) ^ ($i >>> 8 | Ci << 24) ^ ($i >>> 7 | Ci << 25);
  }
  function vi($i, Ci) {
    return ($i >>> 19 | Ci << 13) ^ (Ci >>> 29 | $i << 3) ^ $i >>> 6;
  }
  function mi($i, Ci) {
    return ($i >>> 19 | Ci << 13) ^ (Ci >>> 29 | $i << 3) ^ ($i >>> 6 | Ci << 26);
  }
  function _i($i, Ci) {
    return $i >>> 0 < Ci >>> 0 ? 1 : 0;
  }
  return Be.prototype._update = function($i) {
    for (var Ci = this._w, Ui = this._ah | 0, ki = this._bh | 0, Ji = this._ch | 0, Hi = this._dh | 0, Zi = this._eh | 0, Qi = this._fh | 0, Bi = this._gh | 0, Xi = this._hh | 0, ns = this._al | 0, ls = this._bl | 0, vn = this._cl | 0, Mi = this._dl | 0, Ai = this._el | 0, wi = this._fl | 0, Ei = this._gl | 0, Ti = this._hl | 0, Pi = 0; Pi < 32; Pi += 2)
      Ci[Pi] = $i.readInt32BE(Pi * 4), Ci[Pi + 1] = $i.readInt32BE(Pi * 4 + 4);
    for (; Pi < 160; Pi += 2) {
      var qi = Ci[Pi - 30], Oi = Ci[Pi - 15 * 2 + 1], Si = Ue(qi, Oi), Ni = bi(Oi, qi);
      qi = Ci[Pi - 2 * 2], Oi = Ci[Pi - 2 * 2 + 1];
      var xi = vi(qi, Oi), Wi = mi(Oi, qi), ts = Ci[Pi - 7 * 2], Ki = Ci[Pi - 7 * 2 + 1], fn = Ci[Pi - 16 * 2], Ii = Ci[Pi - 16 * 2 + 1], Fi = Ni + Ki | 0, Gi = Si + ts + _i(Fi, Ni) | 0;
      Fi = Fi + Wi | 0, Gi = Gi + xi + _i(Fi, Wi) | 0, Fi = Fi + Ii | 0, Gi = Gi + fn + _i(Fi, Ii) | 0, Ci[Pi] = Gi, Ci[Pi + 1] = Fi;
    }
    for (var Ri = 0; Ri < 160; Ri += 2) {
      Gi = Ci[Ri], Fi = Ci[Ri + 1];
      var ji = je(Ui, ki, Ji), Vi = je(ns, ls, vn), is = Ve(Ui, ns), os = Ve(ns, Ui), ds = fi(Zi, Ai), ps = fi(Ai, Zi), ea = Ie[Ri], ia = Ie[Ri + 1], hs = Te(Zi, Qi, Bi), fa = Te(Ai, wi, Ei), gs = Ti + ps | 0, sa = Xi + ds + _i(gs, Ti) | 0;
      gs = gs + fa | 0, sa = sa + hs + _i(gs, fa) | 0, gs = gs + ia | 0, sa = sa + ea + _i(gs, ia) | 0, gs = gs + Fi | 0, sa = sa + Gi + _i(gs, Fi) | 0;
      var aa = os + Vi | 0, Ds = is + ji + _i(aa, os) | 0;
      Xi = Bi, Ti = Ei, Bi = Qi, Ei = wi, Qi = Zi, wi = Ai, Ai = Mi + gs | 0, Zi = Hi + sa + _i(Ai, Mi) | 0, Hi = Ji, Mi = vn, Ji = ki, vn = ls, ki = Ui, ls = ns, ns = gs + aa | 0, Ui = sa + Ds + _i(ns, gs) | 0;
    }
    this._al = this._al + ns | 0, this._bl = this._bl + ls | 0, this._cl = this._cl + vn | 0, this._dl = this._dl + Mi | 0, this._el = this._el + Ai | 0, this._fl = this._fl + wi | 0, this._gl = this._gl + Ei | 0, this._hl = this._hl + Ti | 0, this._ah = this._ah + Ui + _i(this._al, ns) | 0, this._bh = this._bh + ki + _i(this._bl, ls) | 0, this._ch = this._ch + Ji + _i(this._cl, vn) | 0, this._dh = this._dh + Hi + _i(this._dl, Mi) | 0, this._eh = this._eh + Zi + _i(this._el, Ai) | 0, this._fh = this._fh + Qi + _i(this._fl, wi) | 0, this._gh = this._gh + Bi + _i(this._gl, Ei) | 0, this._hh = this._hh + Xi + _i(this._hl, Ti) | 0;
  }, Be.prototype._hash = function() {
    var $i = Me.allocUnsafe(64);
    function Ci(Ui, ki, Ji) {
      $i.writeInt32BE(Ui, Ji), $i.writeInt32BE(ki, Ji + 4);
    }
    return Ci(this._ah, this._al, 0), Ci(this._bh, this._bl, 8), Ci(this._ch, this._cl, 16), Ci(this._dh, this._dl, 24), Ci(this._eh, this._el, 32), Ci(this._fh, this._fl, 40), Ci(this._gh, this._gl, 48), Ci(this._hh, this._hl, 56), $i;
  }, sha512$2 = Be, sha512$2;
}
var sha384$1, hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha384$1;
  hasRequiredSha384 = 1;
  var Ae = inherits_browserExports, t = requireSha512(), Me = requireHash(), Ie = requireSafeBuffer$1().Buffer, Pe = new Array(160);
  function Be() {
    this.init(), this._w = Pe, Me.call(this, 128, 112);
  }
  return Ae(Be, t), Be.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, Be.prototype._hash = function() {
    var Te = Ie.allocUnsafe(48);
    function je(Ve, fi, Ue) {
      Te.writeInt32BE(Ve, Ue), Te.writeInt32BE(fi, Ue + 4);
    }
    return je(this._ah, this._al, 0), je(this._bh, this._bl, 8), je(this._ch, this._cl, 16), je(this._dh, this._dl, 24), je(this._eh, this._el, 32), je(this._fh, this._fl, 40), Te;
  }, sha384$1 = Be, sha384$1;
}
var hasRequiredSha_js;
function requireSha_js() {
  if (hasRequiredSha_js) return sha_js.exports;
  hasRequiredSha_js = 1;
  var Ae = sha_js.exports = function(Me) {
    Me = Me.toLowerCase();
    var Ie = Ae[Me];
    if (!Ie) throw new Error(Me + " is not supported (we accept pull requests)");
    return new Ie();
  };
  return Ae.sha = requireSha(), Ae.sha1 = requireSha1(), Ae.sha224 = requireSha224(), Ae.sha256 = requireSha256(), Ae.sha384 = requireSha384(), Ae.sha512 = requireSha512(), sha_js.exports;
}
var cipherBase, hasRequiredCipherBase;
function requireCipherBase() {
  if (hasRequiredCipherBase) return cipherBase;
  hasRequiredCipherBase = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requireStreamBrowserify().Transform, Me = string_decoder.StringDecoder, Ie = inherits_browserExports;
  function Pe(Be) {
    t.call(this), this.hashMode = typeof Be == "string", this.hashMode ? this[Be] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  return Ie(Pe, t), Pe.prototype.update = function(Be, Te, je) {
    typeof Be == "string" && (Be = Ae.from(Be, Te));
    var Ve = this._update(Be);
    return this.hashMode ? this : (je && (Ve = this._toString(Ve, je)), Ve);
  }, Pe.prototype.setAutoPadding = function() {
  }, Pe.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, Pe.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, Pe.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, Pe.prototype._transform = function(Be, Te, je) {
    var Ve;
    try {
      this.hashMode ? this._update(Be) : this.push(this._update(Be));
    } catch (fi) {
      Ve = fi;
    } finally {
      je(Ve);
    }
  }, Pe.prototype._flush = function(Be) {
    var Te;
    try {
      this.push(this.__final());
    } catch (je) {
      Te = je;
    }
    Be(Te);
  }, Pe.prototype._finalOrDigest = function(Be) {
    var Te = this.__final() || Ae.alloc(0);
    return Be && (Te = this._toString(Te, Be, !0)), Te;
  }, Pe.prototype._toString = function(Be, Te, je) {
    if (this._decoder || (this._decoder = new Me(Te), this._encoding = Te), this._encoding !== Te) throw new Error("can't switch encodings");
    var Ve = this._decoder.write(Be);
    return je && (Ve += this._decoder.end()), Ve;
  }, cipherBase = Pe, cipherBase;
}
var browser$c, hasRequiredBrowser$9;
function requireBrowser$9() {
  if (hasRequiredBrowser$9) return browser$c;
  hasRequiredBrowser$9 = 1;
  var Ae = inherits_browserExports, t = requireMd5_js(), Me = requireRipemd160(), Ie = requireSha_js(), Pe = requireCipherBase();
  function Be(Te) {
    Pe.call(this, "digest"), this._hash = Te;
  }
  return Ae(Be, Pe), Be.prototype._update = function(Te) {
    this._hash.update(Te);
  }, Be.prototype._final = function() {
    return this._hash.digest();
  }, browser$c = function(je) {
    return je = je.toLowerCase(), je === "md5" ? new t() : je === "rmd160" || je === "ripemd160" ? new Me() : new Be(Ie(je));
  }, browser$c;
}
var legacy, hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  var Ae = inherits_browserExports, t = requireSafeBuffer$1().Buffer, Me = requireCipherBase(), Ie = t.alloc(128), Pe = 64;
  function Be(Te, je) {
    Me.call(this, "digest"), typeof je == "string" && (je = t.from(je)), this._alg = Te, this._key = je, je.length > Pe ? je = Te(je) : je.length < Pe && (je = t.concat([je, Ie], Pe));
    for (var Ve = this._ipad = t.allocUnsafe(Pe), fi = this._opad = t.allocUnsafe(Pe), Ue = 0; Ue < Pe; Ue++)
      Ve[Ue] = je[Ue] ^ 54, fi[Ue] = je[Ue] ^ 92;
    this._hash = [Ve];
  }
  return Ae(Be, Me), Be.prototype._update = function(Te) {
    this._hash.push(Te);
  }, Be.prototype._final = function() {
    var Te = this._alg(t.concat(this._hash));
    return this._alg(t.concat([this._opad, Te]));
  }, legacy = Be, legacy;
}
var md5, hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  var Ae = requireMd5_js();
  return md5 = function(t) {
    return new Ae().update(t).digest();
  }, md5;
}
var browser$b, hasRequiredBrowser$8;
function requireBrowser$8() {
  if (hasRequiredBrowser$8) return browser$b;
  hasRequiredBrowser$8 = 1;
  var Ae = inherits_browserExports, t = requireLegacy(), Me = requireCipherBase(), Ie = requireSafeBuffer$1().Buffer, Pe = requireMd5(), Be = requireRipemd160(), Te = requireSha_js(), je = Ie.alloc(128);
  function Ve(fi, Ue) {
    Me.call(this, "digest"), typeof Ue == "string" && (Ue = Ie.from(Ue));
    var bi = fi === "sha512" || fi === "sha384" ? 128 : 64;
    if (this._alg = fi, this._key = Ue, Ue.length > bi) {
      var vi = fi === "rmd160" ? new Be() : Te(fi);
      Ue = vi.update(Ue).digest();
    } else Ue.length < bi && (Ue = Ie.concat([Ue, je], bi));
    for (var mi = this._ipad = Ie.allocUnsafe(bi), _i = this._opad = Ie.allocUnsafe(bi), $i = 0; $i < bi; $i++)
      mi[$i] = Ue[$i] ^ 54, _i[$i] = Ue[$i] ^ 92;
    this._hash = fi === "rmd160" ? new Be() : Te(fi), this._hash.update(mi);
  }
  return Ae(Ve, Me), Ve.prototype._update = function(fi) {
    this._hash.update(fi);
  }, Ve.prototype._final = function() {
    var fi = this._hash.digest(), Ue = this._alg === "rmd160" ? new Be() : Te(this._alg);
    return Ue.update(this._opad).update(fi).digest();
  }, browser$b = function(Ue, bi) {
    return Ue = Ue.toLowerCase(), Ue === "rmd160" || Ue === "ripemd160" ? new Ve("rmd160", bi) : Ue === "md5" ? new t(Pe, bi) : new Ve(Ue, bi);
  }, browser$b;
}
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$1 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512$1 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$1,
  sha224,
  sha384,
  sha512: sha512$1,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
  return hasRequiredAlgos || (hasRequiredAlgos = 1, algos = require$$6), algos;
}
var browser$a = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
  if (hasRequiredPrecondition) return precondition;
  hasRequiredPrecondition = 1;
  var Ae = Math.pow(2, 30) - 1;
  return precondition = function(t, Me) {
    if (typeof t != "number")
      throw new TypeError("Iterations not a number");
    if (t < 0)
      throw new TypeError("Bad iterations");
    if (typeof Me != "number")
      throw new TypeError("Key length not a number");
    if (Me < 0 || Me > Ae || Me !== Me)
      throw new TypeError("Bad key length");
  }, precondition;
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
  if (hasRequiredDefaultEncoding) return defaultEncoding_1;
  hasRequiredDefaultEncoding = 1;
  var Ae;
  if (commonjsGlobal.process && commonjsGlobal.process.browser)
    Ae = "utf-8";
  else if (commonjsGlobal.process && commonjsGlobal.process.version) {
    var t = parseInt(process$1.version.split(".")[0].slice(1), 10);
    Ae = t >= 6 ? "utf-8" : "binary";
  } else
    Ae = "utf-8";
  return defaultEncoding_1 = Ae, defaultEncoding_1;
}
var toBuffer, hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer) return toBuffer;
  hasRequiredToBuffer = 1;
  var Ae = requireSafeBuffer$1().Buffer;
  return toBuffer = function(t, Me, Ie) {
    if (Ae.isBuffer(t))
      return t;
    if (typeof t == "string")
      return Ae.from(t, Me);
    if (ArrayBuffer.isView(t))
      return Ae.from(t.buffer);
    throw new TypeError(Ie + " must be a string, a Buffer, a typed array or a DataView");
  }, toBuffer;
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser) return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var Ae = requireMd5(), t = requireRipemd160(), Me = requireSha_js(), Ie = requireSafeBuffer$1().Buffer, Pe = requirePrecondition(), Be = requireDefaultEncoding(), Te = requireToBuffer(), je = Ie.alloc(128), Ve = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function fi(vi, mi, _i) {
    var $i = Ue(vi), Ci = vi === "sha512" || vi === "sha384" ? 128 : 64;
    mi.length > Ci ? mi = $i(mi) : mi.length < Ci && (mi = Ie.concat([mi, je], Ci));
    for (var Ui = Ie.allocUnsafe(Ci + Ve[vi]), ki = Ie.allocUnsafe(Ci + Ve[vi]), Ji = 0; Ji < Ci; Ji++)
      Ui[Ji] = mi[Ji] ^ 54, ki[Ji] = mi[Ji] ^ 92;
    var Hi = Ie.allocUnsafe(Ci + _i + 4);
    Ui.copy(Hi, 0, 0, Ci), this.ipad1 = Hi, this.ipad2 = Ui, this.opad = ki, this.alg = vi, this.blocksize = Ci, this.hash = $i, this.size = Ve[vi];
  }
  fi.prototype.run = function(vi, mi) {
    vi.copy(mi, this.blocksize);
    var _i = this.hash(mi);
    return _i.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function Ue(vi) {
    function mi($i) {
      return Me(vi).update($i).digest();
    }
    function _i($i) {
      return new t().update($i).digest();
    }
    return vi === "rmd160" || vi === "ripemd160" ? _i : vi === "md5" ? Ae : mi;
  }
  function bi(vi, mi, _i, $i, Ci) {
    Pe(_i, $i), vi = Te(vi, Be, "Password"), mi = Te(mi, Be, "Salt"), Ci = Ci || "sha1";
    var Ui = new fi(Ci, vi, mi.length), ki = Ie.allocUnsafe($i), Ji = Ie.allocUnsafe(mi.length + 4);
    mi.copy(Ji, 0, 0, mi.length);
    for (var Hi = 0, Zi = Ve[Ci], Qi = Math.ceil($i / Zi), Bi = 1; Bi <= Qi; Bi++) {
      Ji.writeUInt32BE(Bi, mi.length);
      for (var Xi = Ui.run(Ji, Ui.ipad1), ns = Xi, ls = 1; ls < _i; ls++) {
        ns = Ui.run(ns, Ui.ipad2);
        for (var vn = 0; vn < Zi; vn++) Xi[vn] ^= ns[vn];
      }
      Xi.copy(ki, Hi), Hi += Zi;
    }
    return ki;
  }
  return syncBrowser = bi, syncBrowser;
}
var async, hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requirePrecondition(), Me = requireDefaultEncoding(), Ie = requireSyncBrowser(), Pe = requireToBuffer(), Be, Te = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, je = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, Ve = [];
  function fi(_i) {
    if (commonjsGlobal.process && !commonjsGlobal.process.browser || !Te || !Te.importKey || !Te.deriveBits)
      return Promise.resolve(!1);
    if (Ve[_i] !== void 0)
      return Ve[_i];
    Be = Be || Ae.alloc(8);
    var $i = vi(Be, Be, 10, 128, _i).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return Ve[_i] = $i, $i;
  }
  var Ue;
  function bi() {
    return Ue || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? Ue = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? Ue = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? Ue = commonjsGlobal.setImmediate : Ue = commonjsGlobal.setTimeout, Ue);
  }
  function vi(_i, $i, Ci, Ui, ki) {
    return Te.importKey(
      "raw",
      _i,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(Ji) {
      return Te.deriveBits({
        name: "PBKDF2",
        salt: $i,
        iterations: Ci,
        hash: {
          name: ki
        }
      }, Ji, Ui << 3);
    }).then(function(Ji) {
      return Ae.from(Ji);
    });
  }
  function mi(_i, $i) {
    _i.then(function(Ci) {
      bi()(function() {
        $i(null, Ci);
      });
    }, function(Ci) {
      bi()(function() {
        $i(Ci);
      });
    });
  }
  return async = function(_i, $i, Ci, Ui, ki, Ji) {
    typeof ki == "function" && (Ji = ki, ki = void 0), ki = ki || "sha1";
    var Hi = je[ki.toLowerCase()];
    if (!Hi || typeof commonjsGlobal.Promise != "function") {
      bi()(function() {
        var Zi;
        try {
          Zi = Ie(_i, $i, Ci, Ui, ki);
        } catch (Qi) {
          return Ji(Qi);
        }
        Ji(null, Zi);
      });
      return;
    }
    if (t(Ci, Ui), _i = Pe(_i, Me, "Password"), $i = Pe($i, Me, "Salt"), typeof Ji != "function") throw new Error("No callback provided to pbkdf2");
    mi(fi(Hi).then(function(Zi) {
      return Zi ? vi(_i, $i, Ci, Ui, Hi) : Ie(_i, $i, Ci, Ui, ki);
    }), Ji);
  }, async;
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
  return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1, browser$a.pbkdf2 = requireAsync(), browser$a.pbkdf2Sync = requireSyncBrowser()), browser$a;
}
var browser$9 = {}, des$1 = {}, utils$b = {}, hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$b;
  hasRequiredUtils$1 = 1, utils$b.readUInt32BE = function(Pe, Be) {
    var Te = Pe[0 + Be] << 24 | Pe[1 + Be] << 16 | Pe[2 + Be] << 8 | Pe[3 + Be];
    return Te >>> 0;
  }, utils$b.writeUInt32BE = function(Pe, Be, Te) {
    Pe[0 + Te] = Be >>> 24, Pe[1 + Te] = Be >>> 16 & 255, Pe[2 + Te] = Be >>> 8 & 255, Pe[3 + Te] = Be & 255;
  }, utils$b.ip = function(Pe, Be, Te, je) {
    for (var Ve = 0, fi = 0, Ue = 6; Ue >= 0; Ue -= 2) {
      for (var bi = 0; bi <= 24; bi += 8)
        Ve <<= 1, Ve |= Be >>> bi + Ue & 1;
      for (var bi = 0; bi <= 24; bi += 8)
        Ve <<= 1, Ve |= Pe >>> bi + Ue & 1;
    }
    for (var Ue = 6; Ue >= 0; Ue -= 2) {
      for (var bi = 1; bi <= 25; bi += 8)
        fi <<= 1, fi |= Be >>> bi + Ue & 1;
      for (var bi = 1; bi <= 25; bi += 8)
        fi <<= 1, fi |= Pe >>> bi + Ue & 1;
    }
    Te[je + 0] = Ve >>> 0, Te[je + 1] = fi >>> 0;
  }, utils$b.rip = function(Pe, Be, Te, je) {
    for (var Ve = 0, fi = 0, Ue = 0; Ue < 4; Ue++)
      for (var bi = 24; bi >= 0; bi -= 8)
        Ve <<= 1, Ve |= Be >>> bi + Ue & 1, Ve <<= 1, Ve |= Pe >>> bi + Ue & 1;
    for (var Ue = 4; Ue < 8; Ue++)
      for (var bi = 24; bi >= 0; bi -= 8)
        fi <<= 1, fi |= Be >>> bi + Ue & 1, fi <<= 1, fi |= Pe >>> bi + Ue & 1;
    Te[je + 0] = Ve >>> 0, Te[je + 1] = fi >>> 0;
  }, utils$b.pc1 = function(Pe, Be, Te, je) {
    for (var Ve = 0, fi = 0, Ue = 7; Ue >= 5; Ue--) {
      for (var bi = 0; bi <= 24; bi += 8)
        Ve <<= 1, Ve |= Be >> bi + Ue & 1;
      for (var bi = 0; bi <= 24; bi += 8)
        Ve <<= 1, Ve |= Pe >> bi + Ue & 1;
    }
    for (var bi = 0; bi <= 24; bi += 8)
      Ve <<= 1, Ve |= Be >> bi + Ue & 1;
    for (var Ue = 1; Ue <= 3; Ue++) {
      for (var bi = 0; bi <= 24; bi += 8)
        fi <<= 1, fi |= Be >> bi + Ue & 1;
      for (var bi = 0; bi <= 24; bi += 8)
        fi <<= 1, fi |= Pe >> bi + Ue & 1;
    }
    for (var bi = 0; bi <= 24; bi += 8)
      fi <<= 1, fi |= Pe >> bi + Ue & 1;
    Te[je + 0] = Ve >>> 0, Te[je + 1] = fi >>> 0;
  }, utils$b.r28shl = function(Pe, Be) {
    return Pe << Be & 268435455 | Pe >>> 28 - Be;
  };
  var Ae = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$b.pc2 = function(Pe, Be, Te, je) {
    for (var Ve = 0, fi = 0, Ue = Ae.length >>> 1, bi = 0; bi < Ue; bi++)
      Ve <<= 1, Ve |= Pe >>> Ae[bi] & 1;
    for (var bi = Ue; bi < Ae.length; bi++)
      fi <<= 1, fi |= Be >>> Ae[bi] & 1;
    Te[je + 0] = Ve >>> 0, Te[je + 1] = fi >>> 0;
  }, utils$b.expand = function(Pe, Be, Te) {
    var je = 0, Ve = 0;
    je = (Pe & 1) << 5 | Pe >>> 27;
    for (var fi = 23; fi >= 15; fi -= 4)
      je <<= 6, je |= Pe >>> fi & 63;
    for (var fi = 11; fi >= 3; fi -= 4)
      Ve |= Pe >>> fi & 63, Ve <<= 6;
    Ve |= (Pe & 31) << 1 | Pe >>> 31, Be[Te + 0] = je >>> 0, Be[Te + 1] = Ve >>> 0;
  };
  var t = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$b.substitute = function(Pe, Be) {
    for (var Te = 0, je = 0; je < 4; je++) {
      var Ve = Pe >>> 18 - je * 6 & 63, fi = t[je * 64 + Ve];
      Te <<= 4, Te |= fi;
    }
    for (var je = 0; je < 4; je++) {
      var Ve = Be >>> 18 - je * 6 & 63, fi = t[4 * 64 + je * 64 + Ve];
      Te <<= 4, Te |= fi;
    }
    return Te >>> 0;
  };
  var Me = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return utils$b.permute = function(Pe) {
    for (var Be = 0, Te = 0; Te < Me.length; Te++)
      Be <<= 1, Be |= Pe >>> Me[Te] & 1;
    return Be >>> 0;
  }, utils$b.padSplit = function(Pe, Be, Te) {
    for (var je = Pe.toString(2); je.length < Be; )
      je = "0" + je;
    for (var Ve = [], fi = 0; fi < Be; fi += Te)
      Ve.push(je.slice(fi, fi + Te));
    return Ve.join(" ");
  }, utils$b;
}
var cipher, hasRequiredCipher;
function requireCipher() {
  if (hasRequiredCipher) return cipher;
  hasRequiredCipher = 1;
  var Ae = minimalisticAssert$1;
  function t(Me) {
    this.options = Me, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = Me.padding !== !1;
  }
  return cipher = t, t.prototype._init = function() {
  }, t.prototype.update = function(Ie) {
    return Ie.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(Ie) : this._updateEncrypt(Ie);
  }, t.prototype._buffer = function(Ie, Pe) {
    for (var Be = Math.min(this.buffer.length - this.bufferOff, Ie.length - Pe), Te = 0; Te < Be; Te++)
      this.buffer[this.bufferOff + Te] = Ie[Pe + Te];
    return this.bufferOff += Be, Be;
  }, t.prototype._flushBuffer = function(Ie, Pe) {
    return this._update(this.buffer, 0, Ie, Pe), this.bufferOff = 0, this.blockSize;
  }, t.prototype._updateEncrypt = function(Ie) {
    var Pe = 0, Be = 0, Te = (this.bufferOff + Ie.length) / this.blockSize | 0, je = new Array(Te * this.blockSize);
    this.bufferOff !== 0 && (Pe += this._buffer(Ie, Pe), this.bufferOff === this.buffer.length && (Be += this._flushBuffer(je, Be)));
    for (var Ve = Ie.length - (Ie.length - Pe) % this.blockSize; Pe < Ve; Pe += this.blockSize)
      this._update(Ie, Pe, je, Be), Be += this.blockSize;
    for (; Pe < Ie.length; Pe++, this.bufferOff++)
      this.buffer[this.bufferOff] = Ie[Pe];
    return je;
  }, t.prototype._updateDecrypt = function(Ie) {
    for (var Pe = 0, Be = 0, Te = Math.ceil((this.bufferOff + Ie.length) / this.blockSize) - 1, je = new Array(Te * this.blockSize); Te > 0; Te--)
      Pe += this._buffer(Ie, Pe), Be += this._flushBuffer(je, Be);
    return Pe += this._buffer(Ie, Pe), je;
  }, t.prototype.final = function(Ie) {
    var Pe;
    Ie && (Pe = this.update(Ie));
    var Be;
    return this.type === "encrypt" ? Be = this._finalEncrypt() : Be = this._finalDecrypt(), Pe ? Pe.concat(Be) : Be;
  }, t.prototype._pad = function(Ie, Pe) {
    if (Pe === 0)
      return !1;
    for (; Pe < Ie.length; )
      Ie[Pe++] = 0;
    return !0;
  }, t.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var Ie = new Array(this.blockSize);
    return this._update(this.buffer, 0, Ie, 0), Ie;
  }, t.prototype._unpad = function(Ie) {
    return Ie;
  }, t.prototype._finalDecrypt = function() {
    Ae.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var Ie = new Array(this.blockSize);
    return this._flushBuffer(Ie, 0), this._unpad(Ie);
  }, cipher;
}
var des, hasRequiredDes$1;
function requireDes$1() {
  if (hasRequiredDes$1) return des;
  hasRequiredDes$1 = 1;
  var Ae = minimalisticAssert$1, t = inherits_browserExports, Me = requireUtils$1(), Ie = requireCipher();
  function Pe() {
    this.tmp = new Array(2), this.keys = null;
  }
  function Be(je) {
    Ie.call(this, je);
    var Ve = new Pe();
    this._desState = Ve, this.deriveKeys(Ve, je.key);
  }
  t(Be, Ie), des = Be, Be.create = function(Ve) {
    return new Be(Ve);
  };
  var Te = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return Be.prototype.deriveKeys = function(Ve, fi) {
    Ve.keys = new Array(16 * 2), Ae.equal(fi.length, this.blockSize, "Invalid key length");
    var Ue = Me.readUInt32BE(fi, 0), bi = Me.readUInt32BE(fi, 4);
    Me.pc1(Ue, bi, Ve.tmp, 0), Ue = Ve.tmp[0], bi = Ve.tmp[1];
    for (var vi = 0; vi < Ve.keys.length; vi += 2) {
      var mi = Te[vi >>> 1];
      Ue = Me.r28shl(Ue, mi), bi = Me.r28shl(bi, mi), Me.pc2(Ue, bi, Ve.keys, vi);
    }
  }, Be.prototype._update = function(Ve, fi, Ue, bi) {
    var vi = this._desState, mi = Me.readUInt32BE(Ve, fi), _i = Me.readUInt32BE(Ve, fi + 4);
    Me.ip(mi, _i, vi.tmp, 0), mi = vi.tmp[0], _i = vi.tmp[1], this.type === "encrypt" ? this._encrypt(vi, mi, _i, vi.tmp, 0) : this._decrypt(vi, mi, _i, vi.tmp, 0), mi = vi.tmp[0], _i = vi.tmp[1], Me.writeUInt32BE(Ue, mi, bi), Me.writeUInt32BE(Ue, _i, bi + 4);
  }, Be.prototype._pad = function(Ve, fi) {
    if (this.padding === !1)
      return !1;
    for (var Ue = Ve.length - fi, bi = fi; bi < Ve.length; bi++)
      Ve[bi] = Ue;
    return !0;
  }, Be.prototype._unpad = function(Ve) {
    if (this.padding === !1)
      return Ve;
    for (var fi = Ve[Ve.length - 1], Ue = Ve.length - fi; Ue < Ve.length; Ue++)
      Ae.equal(Ve[Ue], fi);
    return Ve.slice(0, Ve.length - fi);
  }, Be.prototype._encrypt = function(Ve, fi, Ue, bi, vi) {
    for (var mi = fi, _i = Ue, $i = 0; $i < Ve.keys.length; $i += 2) {
      var Ci = Ve.keys[$i], Ui = Ve.keys[$i + 1];
      Me.expand(_i, Ve.tmp, 0), Ci ^= Ve.tmp[0], Ui ^= Ve.tmp[1];
      var ki = Me.substitute(Ci, Ui), Ji = Me.permute(ki), Hi = _i;
      _i = (mi ^ Ji) >>> 0, mi = Hi;
    }
    Me.rip(_i, mi, bi, vi);
  }, Be.prototype._decrypt = function(Ve, fi, Ue, bi, vi) {
    for (var mi = Ue, _i = fi, $i = Ve.keys.length - 2; $i >= 0; $i -= 2) {
      var Ci = Ve.keys[$i], Ui = Ve.keys[$i + 1];
      Me.expand(mi, Ve.tmp, 0), Ci ^= Ve.tmp[0], Ui ^= Ve.tmp[1];
      var ki = Me.substitute(Ci, Ui), Ji = Me.permute(ki), Hi = mi;
      mi = (_i ^ Ji) >>> 0, _i = Hi;
    }
    Me.rip(mi, _i, bi, vi);
  }, des;
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
  if (hasRequiredCbc$1) return cbc$1;
  hasRequiredCbc$1 = 1;
  var Ae = minimalisticAssert$1, t = inherits_browserExports, Me = {};
  function Ie(Be) {
    Ae.equal(Be.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var Te = 0; Te < this.iv.length; Te++)
      this.iv[Te] = Be[Te];
  }
  function Pe(Be) {
    function Te(Ue) {
      Be.call(this, Ue), this._cbcInit();
    }
    t(Te, Be);
    for (var je = Object.keys(Me), Ve = 0; Ve < je.length; Ve++) {
      var fi = je[Ve];
      Te.prototype[fi] = Me[fi];
    }
    return Te.create = function(bi) {
      return new Te(bi);
    }, Te;
  }
  return cbc$1.instantiate = Pe, Me._cbcInit = function() {
    var Te = new Ie(this.options.iv);
    this._cbcState = Te;
  }, Me._update = function(Te, je, Ve, fi) {
    var Ue = this._cbcState, bi = this.constructor.super_.prototype, vi = Ue.iv;
    if (this.type === "encrypt") {
      for (var mi = 0; mi < this.blockSize; mi++)
        vi[mi] ^= Te[je + mi];
      bi._update.call(this, vi, 0, Ve, fi);
      for (var mi = 0; mi < this.blockSize; mi++)
        vi[mi] = Ve[fi + mi];
    } else {
      bi._update.call(this, Te, je, Ve, fi);
      for (var mi = 0; mi < this.blockSize; mi++)
        Ve[fi + mi] ^= vi[mi];
      for (var mi = 0; mi < this.blockSize; mi++)
        vi[mi] = Te[je + mi];
    }
  }, cbc$1;
}
var ede, hasRequiredEde;
function requireEde() {
  if (hasRequiredEde) return ede;
  hasRequiredEde = 1;
  var Ae = minimalisticAssert$1, t = inherits_browserExports, Me = requireCipher(), Ie = requireDes$1();
  function Pe(Te, je) {
    Ae.equal(je.length, 24, "Invalid key length");
    var Ve = je.slice(0, 8), fi = je.slice(8, 16), Ue = je.slice(16, 24);
    Te === "encrypt" ? this.ciphers = [
      Ie.create({ type: "encrypt", key: Ve }),
      Ie.create({ type: "decrypt", key: fi }),
      Ie.create({ type: "encrypt", key: Ue })
    ] : this.ciphers = [
      Ie.create({ type: "decrypt", key: Ue }),
      Ie.create({ type: "encrypt", key: fi }),
      Ie.create({ type: "decrypt", key: Ve })
    ];
  }
  function Be(Te) {
    Me.call(this, Te);
    var je = new Pe(this.type, this.options.key);
    this._edeState = je;
  }
  return t(Be, Me), ede = Be, Be.create = function(je) {
    return new Be(je);
  }, Be.prototype._update = function(je, Ve, fi, Ue) {
    var bi = this._edeState;
    bi.ciphers[0]._update(je, Ve, fi, Ue), bi.ciphers[1]._update(fi, Ue, fi, Ue), bi.ciphers[2]._update(fi, Ue, fi, Ue);
  }, Be.prototype._pad = Ie.prototype._pad, Be.prototype._unpad = Ie.prototype._unpad, ede;
}
var hasRequiredDes;
function requireDes() {
  return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils$1(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1;
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes) return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var Ae = requireCipherBase(), t = requireDes(), Me = inherits_browserExports, Ie = requireSafeBuffer$1().Buffer, Pe = {
    "des-ede3-cbc": t.CBC.instantiate(t.EDE),
    "des-ede3": t.EDE,
    "des-ede-cbc": t.CBC.instantiate(t.EDE),
    "des-ede": t.EDE,
    "des-cbc": t.CBC.instantiate(t.DES),
    "des-ecb": t.DES
  };
  Pe.des = Pe["des-cbc"], Pe.des3 = Pe["des-ede3-cbc"], browserifyDes = Be, Me(Be, Ae);
  function Be(Te) {
    Ae.call(this);
    var je = Te.mode.toLowerCase(), Ve = Pe[je], fi;
    Te.decrypt ? fi = "decrypt" : fi = "encrypt";
    var Ue = Te.key;
    Ie.isBuffer(Ue) || (Ue = Ie.from(Ue)), (je === "des-ede" || je === "des-ede-cbc") && (Ue = Ie.concat([Ue, Ue.slice(0, 8)]));
    var bi = Te.iv;
    Ie.isBuffer(bi) || (bi = Ie.from(bi)), this._des = Ve.create({
      key: Ue,
      iv: bi,
      type: fi
    });
  }
  return Be.prototype._update = function(Te) {
    return Ie.from(this._des.update(Te));
  }, Be.prototype._final = function() {
    return Ie.from(this._des.final());
  }, browserifyDes;
}
var browser$8 = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
  return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function(Ae, t) {
    return Ae._cipher.encryptBlock(t);
  }, ecb.decrypt = function(Ae, t) {
    return Ae._cipher.decryptBlock(t);
  }), ecb;
}
var cbc = {}, bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
  return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function(t, Me) {
    for (var Ie = Math.min(t.length, Me.length), Pe = new Buffer$1(Ie), Be = 0; Be < Ie; ++Be)
      Pe[Be] = t[Be] ^ Me[Be];
    return Pe;
  }), bufferXor;
}
var hasRequiredCbc;
function requireCbc() {
  if (hasRequiredCbc) return cbc;
  hasRequiredCbc = 1;
  var Ae = requireBufferXor();
  return cbc.encrypt = function(t, Me) {
    var Ie = Ae(Me, t._prev);
    return t._prev = t._cipher.encryptBlock(Ie), t._prev;
  }, cbc.decrypt = function(t, Me) {
    var Ie = t._prev;
    t._prev = Me;
    var Pe = t._cipher.decryptBlock(Me);
    return Ae(Pe, Ie);
  }, cbc;
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb) return cfb;
  hasRequiredCfb = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requireBufferXor();
  function Me(Ie, Pe, Be) {
    var Te = Pe.length, je = t(Pe, Ie._cache);
    return Ie._cache = Ie._cache.slice(Te), Ie._prev = Ae.concat([Ie._prev, Be ? Pe : je]), je;
  }
  return cfb.encrypt = function(Ie, Pe, Be) {
    for (var Te = Ae.allocUnsafe(0), je; Pe.length; )
      if (Ie._cache.length === 0 && (Ie._cache = Ie._cipher.encryptBlock(Ie._prev), Ie._prev = Ae.allocUnsafe(0)), Ie._cache.length <= Pe.length)
        je = Ie._cache.length, Te = Ae.concat([Te, Me(Ie, Pe.slice(0, je), Be)]), Pe = Pe.slice(je);
      else {
        Te = Ae.concat([Te, Me(Ie, Pe, Be)]);
        break;
      }
    return Te;
  }, cfb;
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8) return cfb8;
  hasRequiredCfb8 = 1;
  var Ae = requireSafeBuffer$1().Buffer;
  function t(Me, Ie, Pe) {
    var Be = Me._cipher.encryptBlock(Me._prev), Te = Be[0] ^ Ie;
    return Me._prev = Ae.concat([
      Me._prev.slice(1),
      Ae.from([Pe ? Ie : Te])
    ]), Te;
  }
  return cfb8.encrypt = function(Me, Ie, Pe) {
    for (var Be = Ie.length, Te = Ae.allocUnsafe(Be), je = -1; ++je < Be; )
      Te[je] = t(Me, Ie[je], Pe);
    return Te;
  }, cfb8;
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1) return cfb1;
  hasRequiredCfb1 = 1;
  var Ae = requireSafeBuffer$1().Buffer;
  function t(Ie, Pe, Be) {
    for (var Te, je = -1, Ve = 8, fi = 0, Ue, bi; ++je < Ve; )
      Te = Ie._cipher.encryptBlock(Ie._prev), Ue = Pe & 1 << 7 - je ? 128 : 0, bi = Te[0] ^ Ue, fi += (bi & 128) >> je % 8, Ie._prev = Me(Ie._prev, Be ? Ue : bi);
    return fi;
  }
  function Me(Ie, Pe) {
    var Be = Ie.length, Te = -1, je = Ae.allocUnsafe(Ie.length);
    for (Ie = Ae.concat([Ie, Ae.from([Pe])]); ++Te < Be; )
      je[Te] = Ie[Te] << 1 | Ie[Te + 1] >> 7;
    return je;
  }
  return cfb1.encrypt = function(Ie, Pe, Be) {
    for (var Te = Pe.length, je = Ae.allocUnsafe(Te), Ve = -1; ++Ve < Te; )
      je[Ve] = t(Ie, Pe[Ve], Be);
    return je;
  }, cfb1;
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb) return ofb;
  hasRequiredOfb = 1;
  var Ae = requireBufferXor();
  function t(Me) {
    return Me._prev = Me._cipher.encryptBlock(Me._prev), Me._prev;
  }
  return ofb.encrypt = function(Me, Ie) {
    for (; Me._cache.length < Ie.length; )
      Me._cache = Buffer$1.concat([Me._cache, t(Me)]);
    var Pe = Me._cache.slice(0, Ie.length);
    return Me._cache = Me._cache.slice(Ie.length), Ae(Ie, Pe);
  }, ofb;
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
  if (hasRequiredIncr32) return incr32_1;
  hasRequiredIncr32 = 1;
  function Ae(t) {
    for (var Me = t.length, Ie; Me--; )
      if (Ie = t.readUInt8(Me), Ie === 255)
        t.writeUInt8(0, Me);
      else {
        Ie++, t.writeUInt8(Ie, Me);
        break;
      }
  }
  return incr32_1 = Ae, incr32_1;
}
var hasRequiredCtr;
function requireCtr() {
  if (hasRequiredCtr) return ctr;
  hasRequiredCtr = 1;
  var Ae = requireBufferXor(), t = requireSafeBuffer$1().Buffer, Me = requireIncr32();
  function Ie(Be) {
    var Te = Be._cipher.encryptBlockRaw(Be._prev);
    return Me(Be._prev), Te;
  }
  var Pe = 16;
  return ctr.encrypt = function(Be, Te) {
    var je = Math.ceil(Te.length / Pe), Ve = Be._cache.length;
    Be._cache = t.concat([
      Be._cache,
      t.allocUnsafe(je * Pe)
    ]);
    for (var fi = 0; fi < je; fi++) {
      var Ue = Ie(Be), bi = Ve + fi * Pe;
      Be._cache.writeUInt32BE(Ue[0], bi + 0), Be._cache.writeUInt32BE(Ue[1], bi + 4), Be._cache.writeUInt32BE(Ue[2], bi + 8), Be._cache.writeUInt32BE(Ue[3], bi + 12);
    }
    var vi = Be._cache.slice(0, Te.length);
    return Be._cache = Be._cache.slice(Te.length), Ae(Te, vi);
  }, ctr;
}
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1) return modes_1;
  hasRequiredModes$1 = 1;
  var Ae = {
    ECB: requireEcb(),
    CBC: requireCbc(),
    CFB: requireCfb(),
    CFB8: requireCfb8(),
    CFB1: requireCfb1(),
    OFB: requireOfb(),
    CTR: requireCtr(),
    GCM: requireCtr()
  }, t = require$$2;
  for (var Me in t)
    t[Me].module = Ae[t[Me].mode];
  return modes_1 = t, modes_1;
}
var aes = {}, hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes;
  hasRequiredAes = 1;
  var Ae = requireSafeBuffer$1().Buffer;
  function t(je) {
    Ae.isBuffer(je) || (je = Ae.from(je));
    for (var Ve = je.length / 4 | 0, fi = new Array(Ve), Ue = 0; Ue < Ve; Ue++)
      fi[Ue] = je.readUInt32BE(Ue * 4);
    return fi;
  }
  function Me(je) {
    for (var Ve = 0; Ve < je.length; je++)
      je[Ve] = 0;
  }
  function Ie(je, Ve, fi, Ue, bi) {
    for (var vi = fi[0], mi = fi[1], _i = fi[2], $i = fi[3], Ci = je[0] ^ Ve[0], Ui = je[1] ^ Ve[1], ki = je[2] ^ Ve[2], Ji = je[3] ^ Ve[3], Hi, Zi, Qi, Bi, Xi = 4, ns = 1; ns < bi; ns++)
      Hi = vi[Ci >>> 24] ^ mi[Ui >>> 16 & 255] ^ _i[ki >>> 8 & 255] ^ $i[Ji & 255] ^ Ve[Xi++], Zi = vi[Ui >>> 24] ^ mi[ki >>> 16 & 255] ^ _i[Ji >>> 8 & 255] ^ $i[Ci & 255] ^ Ve[Xi++], Qi = vi[ki >>> 24] ^ mi[Ji >>> 16 & 255] ^ _i[Ci >>> 8 & 255] ^ $i[Ui & 255] ^ Ve[Xi++], Bi = vi[Ji >>> 24] ^ mi[Ci >>> 16 & 255] ^ _i[Ui >>> 8 & 255] ^ $i[ki & 255] ^ Ve[Xi++], Ci = Hi, Ui = Zi, ki = Qi, Ji = Bi;
    return Hi = (Ue[Ci >>> 24] << 24 | Ue[Ui >>> 16 & 255] << 16 | Ue[ki >>> 8 & 255] << 8 | Ue[Ji & 255]) ^ Ve[Xi++], Zi = (Ue[Ui >>> 24] << 24 | Ue[ki >>> 16 & 255] << 16 | Ue[Ji >>> 8 & 255] << 8 | Ue[Ci & 255]) ^ Ve[Xi++], Qi = (Ue[ki >>> 24] << 24 | Ue[Ji >>> 16 & 255] << 16 | Ue[Ci >>> 8 & 255] << 8 | Ue[Ui & 255]) ^ Ve[Xi++], Bi = (Ue[Ji >>> 24] << 24 | Ue[Ci >>> 16 & 255] << 16 | Ue[Ui >>> 8 & 255] << 8 | Ue[ki & 255]) ^ Ve[Xi++], Hi = Hi >>> 0, Zi = Zi >>> 0, Qi = Qi >>> 0, Bi = Bi >>> 0, [Hi, Zi, Qi, Bi];
  }
  var Pe = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], Be = function() {
    for (var je = new Array(256), Ve = 0; Ve < 256; Ve++)
      Ve < 128 ? je[Ve] = Ve << 1 : je[Ve] = Ve << 1 ^ 283;
    for (var fi = [], Ue = [], bi = [[], [], [], []], vi = [[], [], [], []], mi = 0, _i = 0, $i = 0; $i < 256; ++$i) {
      var Ci = _i ^ _i << 1 ^ _i << 2 ^ _i << 3 ^ _i << 4;
      Ci = Ci >>> 8 ^ Ci & 255 ^ 99, fi[mi] = Ci, Ue[Ci] = mi;
      var Ui = je[mi], ki = je[Ui], Ji = je[ki], Hi = je[Ci] * 257 ^ Ci * 16843008;
      bi[0][mi] = Hi << 24 | Hi >>> 8, bi[1][mi] = Hi << 16 | Hi >>> 16, bi[2][mi] = Hi << 8 | Hi >>> 24, bi[3][mi] = Hi, Hi = Ji * 16843009 ^ ki * 65537 ^ Ui * 257 ^ mi * 16843008, vi[0][Ci] = Hi << 24 | Hi >>> 8, vi[1][Ci] = Hi << 16 | Hi >>> 16, vi[2][Ci] = Hi << 8 | Hi >>> 24, vi[3][Ci] = Hi, mi === 0 ? mi = _i = 1 : (mi = Ui ^ je[je[je[Ji ^ Ui]]], _i ^= je[je[_i]]);
    }
    return {
      SBOX: fi,
      INV_SBOX: Ue,
      SUB_MIX: bi,
      INV_SUB_MIX: vi
    };
  }();
  function Te(je) {
    this._key = t(je), this._reset();
  }
  return Te.blockSize = 4 * 4, Te.keySize = 256 / 8, Te.prototype.blockSize = Te.blockSize, Te.prototype.keySize = Te.keySize, Te.prototype._reset = function() {
    for (var je = this._key, Ve = je.length, fi = Ve + 6, Ue = (fi + 1) * 4, bi = [], vi = 0; vi < Ve; vi++)
      bi[vi] = je[vi];
    for (vi = Ve; vi < Ue; vi++) {
      var mi = bi[vi - 1];
      vi % Ve === 0 ? (mi = mi << 8 | mi >>> 24, mi = Be.SBOX[mi >>> 24] << 24 | Be.SBOX[mi >>> 16 & 255] << 16 | Be.SBOX[mi >>> 8 & 255] << 8 | Be.SBOX[mi & 255], mi ^= Pe[vi / Ve | 0] << 24) : Ve > 6 && vi % Ve === 4 && (mi = Be.SBOX[mi >>> 24] << 24 | Be.SBOX[mi >>> 16 & 255] << 16 | Be.SBOX[mi >>> 8 & 255] << 8 | Be.SBOX[mi & 255]), bi[vi] = bi[vi - Ve] ^ mi;
    }
    for (var _i = [], $i = 0; $i < Ue; $i++) {
      var Ci = Ue - $i, Ui = bi[Ci - ($i % 4 ? 0 : 4)];
      $i < 4 || Ci <= 4 ? _i[$i] = Ui : _i[$i] = Be.INV_SUB_MIX[0][Be.SBOX[Ui >>> 24]] ^ Be.INV_SUB_MIX[1][Be.SBOX[Ui >>> 16 & 255]] ^ Be.INV_SUB_MIX[2][Be.SBOX[Ui >>> 8 & 255]] ^ Be.INV_SUB_MIX[3][Be.SBOX[Ui & 255]];
    }
    this._nRounds = fi, this._keySchedule = bi, this._invKeySchedule = _i;
  }, Te.prototype.encryptBlockRaw = function(je) {
    return je = t(je), Ie(je, this._keySchedule, Be.SUB_MIX, Be.SBOX, this._nRounds);
  }, Te.prototype.encryptBlock = function(je) {
    var Ve = this.encryptBlockRaw(je), fi = Ae.allocUnsafe(16);
    return fi.writeUInt32BE(Ve[0], 0), fi.writeUInt32BE(Ve[1], 4), fi.writeUInt32BE(Ve[2], 8), fi.writeUInt32BE(Ve[3], 12), fi;
  }, Te.prototype.decryptBlock = function(je) {
    je = t(je);
    var Ve = je[1];
    je[1] = je[3], je[3] = Ve;
    var fi = Ie(je, this._invKeySchedule, Be.INV_SUB_MIX, Be.INV_SBOX, this._nRounds), Ue = Ae.allocUnsafe(16);
    return Ue.writeUInt32BE(fi[0], 0), Ue.writeUInt32BE(fi[3], 4), Ue.writeUInt32BE(fi[2], 8), Ue.writeUInt32BE(fi[1], 12), Ue;
  }, Te.prototype.scrub = function() {
    Me(this._keySchedule), Me(this._invKeySchedule), Me(this._key);
  }, aes.AES = Te, aes;
}
var ghash, hasRequiredGhash;
function requireGhash() {
  if (hasRequiredGhash) return ghash;
  hasRequiredGhash = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = Ae.alloc(16, 0);
  function Me(Be) {
    return [
      Be.readUInt32BE(0),
      Be.readUInt32BE(4),
      Be.readUInt32BE(8),
      Be.readUInt32BE(12)
    ];
  }
  function Ie(Be) {
    var Te = Ae.allocUnsafe(16);
    return Te.writeUInt32BE(Be[0] >>> 0, 0), Te.writeUInt32BE(Be[1] >>> 0, 4), Te.writeUInt32BE(Be[2] >>> 0, 8), Te.writeUInt32BE(Be[3] >>> 0, 12), Te;
  }
  function Pe(Be) {
    this.h = Be, this.state = Ae.alloc(16, 0), this.cache = Ae.allocUnsafe(0);
  }
  return Pe.prototype.ghash = function(Be) {
    for (var Te = -1; ++Te < Be.length; )
      this.state[Te] ^= Be[Te];
    this._multiply();
  }, Pe.prototype._multiply = function() {
    for (var Be = Me(this.h), Te = [0, 0, 0, 0], je, Ve, fi, Ue = -1; ++Ue < 128; ) {
      for (Ve = (this.state[~~(Ue / 8)] & 1 << 7 - Ue % 8) !== 0, Ve && (Te[0] ^= Be[0], Te[1] ^= Be[1], Te[2] ^= Be[2], Te[3] ^= Be[3]), fi = (Be[3] & 1) !== 0, je = 3; je > 0; je--)
        Be[je] = Be[je] >>> 1 | (Be[je - 1] & 1) << 31;
      Be[0] = Be[0] >>> 1, fi && (Be[0] = Be[0] ^ 225 << 24);
    }
    this.state = Ie(Te);
  }, Pe.prototype.update = function(Be) {
    this.cache = Ae.concat([this.cache, Be]);
    for (var Te; this.cache.length >= 16; )
      Te = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(Te);
  }, Pe.prototype.final = function(Be, Te) {
    return this.cache.length && this.ghash(Ae.concat([this.cache, t], 16)), this.ghash(Ie([0, Be, 0, Te])), this.state;
  }, ghash = Pe, ghash;
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
  if (hasRequiredAuthCipher) return authCipher;
  hasRequiredAuthCipher = 1;
  var Ae = requireAes(), t = requireSafeBuffer$1().Buffer, Me = requireCipherBase(), Ie = inherits_browserExports, Pe = requireGhash(), Be = requireBufferXor(), Te = requireIncr32();
  function je(Ue, bi) {
    var vi = 0;
    Ue.length !== bi.length && vi++;
    for (var mi = Math.min(Ue.length, bi.length), _i = 0; _i < mi; ++_i)
      vi += Ue[_i] ^ bi[_i];
    return vi;
  }
  function Ve(Ue, bi, vi) {
    if (bi.length === 12)
      return Ue._finID = t.concat([bi, t.from([0, 0, 0, 1])]), t.concat([bi, t.from([0, 0, 0, 2])]);
    var mi = new Pe(vi), _i = bi.length, $i = _i % 16;
    mi.update(bi), $i && ($i = 16 - $i, mi.update(t.alloc($i, 0))), mi.update(t.alloc(8, 0));
    var Ci = _i * 8, Ui = t.alloc(8);
    Ui.writeUIntBE(Ci, 0, 8), mi.update(Ui), Ue._finID = mi.state;
    var ki = t.from(Ue._finID);
    return Te(ki), ki;
  }
  function fi(Ue, bi, vi, mi) {
    Me.call(this);
    var _i = t.alloc(4, 0);
    this._cipher = new Ae.AES(bi);
    var $i = this._cipher.encryptBlock(_i);
    this._ghash = new Pe($i), vi = Ve(this, vi, $i), this._prev = t.from(vi), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = mi, this._alen = 0, this._len = 0, this._mode = Ue, this._authTag = null, this._called = !1;
  }
  return Ie(fi, Me), fi.prototype._update = function(Ue) {
    if (!this._called && this._alen) {
      var bi = 16 - this._alen % 16;
      bi < 16 && (bi = t.alloc(bi, 0), this._ghash.update(bi));
    }
    this._called = !0;
    var vi = this._mode.encrypt(this, Ue);
    return this._decrypt ? this._ghash.update(Ue) : this._ghash.update(vi), this._len += Ue.length, vi;
  }, fi.prototype._final = function() {
    if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var Ue = Be(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && je(Ue, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = Ue, this._cipher.scrub();
  }, fi.prototype.getAuthTag = function() {
    if (this._decrypt || !t.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, fi.prototype.setAuthTag = function(bi) {
    if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = bi;
  }, fi.prototype.setAAD = function(bi) {
    if (this._called) throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(bi), this._alen += bi.length;
  }, authCipher = fi, authCipher;
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
  if (hasRequiredStreamCipher) return streamCipher;
  hasRequiredStreamCipher = 1;
  var Ae = requireAes(), t = requireSafeBuffer$1().Buffer, Me = requireCipherBase(), Ie = inherits_browserExports;
  function Pe(Be, Te, je, Ve) {
    Me.call(this), this._cipher = new Ae.AES(Te), this._prev = t.from(je), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = Ve, this._mode = Be;
  }
  return Ie(Pe, Me), Pe.prototype._update = function(Be) {
    return this._mode.encrypt(this, Be, this._decrypt);
  }, Pe.prototype._final = function() {
    this._cipher.scrub();
  }, streamCipher = Pe, streamCipher;
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey) return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requireMd5_js();
  function Me(Ie, Pe, Be, Te) {
    if (Ae.isBuffer(Ie) || (Ie = Ae.from(Ie, "binary")), Pe && (Ae.isBuffer(Pe) || (Pe = Ae.from(Pe, "binary")), Pe.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var je = Be / 8, Ve = Ae.alloc(je), fi = Ae.alloc(Te || 0), Ue = Ae.alloc(0); je > 0 || Te > 0; ) {
      var bi = new t();
      bi.update(Ue), bi.update(Ie), Pe && bi.update(Pe), Ue = bi.digest();
      var vi = 0;
      if (je > 0) {
        var mi = Ve.length - je;
        vi = Math.min(je, Ue.length), Ue.copy(Ve, mi, 0, vi), je -= vi;
      }
      if (vi < Ue.length && Te > 0) {
        var _i = fi.length - Te, $i = Math.min(Te, Ue.length - vi);
        Ue.copy(fi, _i, vi, vi + $i), Te -= $i;
      }
    }
    return Ue.fill(0), { key: Ve, iv: fi };
  }
  return evp_bytestokey = Me, evp_bytestokey;
}
var hasRequiredEncrypter;
function requireEncrypter() {
  if (hasRequiredEncrypter) return encrypter;
  hasRequiredEncrypter = 1;
  var Ae = requireModes$1(), t = requireAuthCipher(), Me = requireSafeBuffer$1().Buffer, Ie = requireStreamCipher(), Pe = requireCipherBase(), Be = requireAes(), Te = requireEvp_bytestokey(), je = inherits_browserExports;
  function Ve(mi, _i, $i) {
    Pe.call(this), this._cache = new Ue(), this._cipher = new Be.AES(_i), this._prev = Me.from($i), this._mode = mi, this._autopadding = !0;
  }
  je(Ve, Pe), Ve.prototype._update = function(mi) {
    this._cache.add(mi);
    for (var _i, $i, Ci = []; _i = this._cache.get(); )
      $i = this._mode.encrypt(this, _i), Ci.push($i);
    return Me.concat(Ci);
  };
  var fi = Me.alloc(16, 16);
  Ve.prototype._final = function() {
    var mi = this._cache.flush();
    if (this._autopadding)
      return mi = this._mode.encrypt(this, mi), this._cipher.scrub(), mi;
    if (!mi.equals(fi))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, Ve.prototype.setAutoPadding = function(mi) {
    return this._autopadding = !!mi, this;
  };
  function Ue() {
    this.cache = Me.allocUnsafe(0);
  }
  Ue.prototype.add = function(mi) {
    this.cache = Me.concat([this.cache, mi]);
  }, Ue.prototype.get = function() {
    if (this.cache.length > 15) {
      var mi = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), mi;
    }
    return null;
  }, Ue.prototype.flush = function() {
    for (var mi = 16 - this.cache.length, _i = Me.allocUnsafe(mi), $i = -1; ++$i < mi; )
      _i.writeUInt8(mi, $i);
    return Me.concat([this.cache, _i]);
  };
  function bi(mi, _i, $i) {
    var Ci = Ae[mi.toLowerCase()];
    if (!Ci) throw new TypeError("invalid suite type");
    if (typeof _i == "string" && (_i = Me.from(_i)), _i.length !== Ci.key / 8) throw new TypeError("invalid key length " + _i.length);
    if (typeof $i == "string" && ($i = Me.from($i)), Ci.mode !== "GCM" && $i.length !== Ci.iv) throw new TypeError("invalid iv length " + $i.length);
    return Ci.type === "stream" ? new Ie(Ci.module, _i, $i) : Ci.type === "auth" ? new t(Ci.module, _i, $i) : new Ve(Ci.module, _i, $i);
  }
  function vi(mi, _i) {
    var $i = Ae[mi.toLowerCase()];
    if (!$i) throw new TypeError("invalid suite type");
    var Ci = Te(_i, !1, $i.key, $i.iv);
    return bi(mi, Ci.key, Ci.iv);
  }
  return encrypter.createCipheriv = bi, encrypter.createCipher = vi, encrypter;
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
  if (hasRequiredDecrypter) return decrypter;
  hasRequiredDecrypter = 1;
  var Ae = requireAuthCipher(), t = requireSafeBuffer$1().Buffer, Me = requireModes$1(), Ie = requireStreamCipher(), Pe = requireCipherBase(), Be = requireAes(), Te = requireEvp_bytestokey(), je = inherits_browserExports;
  function Ve(mi, _i, $i) {
    Pe.call(this), this._cache = new fi(), this._last = void 0, this._cipher = new Be.AES(_i), this._prev = t.from($i), this._mode = mi, this._autopadding = !0;
  }
  je(Ve, Pe), Ve.prototype._update = function(mi) {
    this._cache.add(mi);
    for (var _i, $i, Ci = []; _i = this._cache.get(this._autopadding); )
      $i = this._mode.decrypt(this, _i), Ci.push($i);
    return t.concat(Ci);
  }, Ve.prototype._final = function() {
    var mi = this._cache.flush();
    if (this._autopadding)
      return Ue(this._mode.decrypt(this, mi));
    if (mi)
      throw new Error("data not multiple of block length");
  }, Ve.prototype.setAutoPadding = function(mi) {
    return this._autopadding = !!mi, this;
  };
  function fi() {
    this.cache = t.allocUnsafe(0);
  }
  fi.prototype.add = function(mi) {
    this.cache = t.concat([this.cache, mi]);
  }, fi.prototype.get = function(mi) {
    var _i;
    if (mi) {
      if (this.cache.length > 16)
        return _i = this.cache.slice(0, 16), this.cache = this.cache.slice(16), _i;
    } else if (this.cache.length >= 16)
      return _i = this.cache.slice(0, 16), this.cache = this.cache.slice(16), _i;
    return null;
  }, fi.prototype.flush = function() {
    if (this.cache.length) return this.cache;
  };
  function Ue(mi) {
    var _i = mi[15];
    if (_i < 1 || _i > 16)
      throw new Error("unable to decrypt data");
    for (var $i = -1; ++$i < _i; )
      if (mi[$i + (16 - _i)] !== _i)
        throw new Error("unable to decrypt data");
    if (_i !== 16)
      return mi.slice(0, 16 - _i);
  }
  function bi(mi, _i, $i) {
    var Ci = Me[mi.toLowerCase()];
    if (!Ci) throw new TypeError("invalid suite type");
    if (typeof $i == "string" && ($i = t.from($i)), Ci.mode !== "GCM" && $i.length !== Ci.iv) throw new TypeError("invalid iv length " + $i.length);
    if (typeof _i == "string" && (_i = t.from(_i)), _i.length !== Ci.key / 8) throw new TypeError("invalid key length " + _i.length);
    return Ci.type === "stream" ? new Ie(Ci.module, _i, $i, !0) : Ci.type === "auth" ? new Ae(Ci.module, _i, $i, !0) : new Ve(Ci.module, _i, $i);
  }
  function vi(mi, _i) {
    var $i = Me[mi.toLowerCase()];
    if (!$i) throw new TypeError("invalid suite type");
    var Ci = Te(_i, !1, $i.key, $i.iv);
    return bi(mi, Ci.key, Ci.iv);
  }
  return decrypter.createDecipher = vi, decrypter.createDecipheriv = bi, decrypter;
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
  if (hasRequiredBrowser$6) return browser$8;
  hasRequiredBrowser$6 = 1;
  var Ae = requireEncrypter(), t = requireDecrypter(), Me = require$$2;
  function Ie() {
    return Object.keys(Me);
  }
  return browser$8.createCipher = browser$8.Cipher = Ae.createCipher, browser$8.createCipheriv = browser$8.Cipheriv = Ae.createCipheriv, browser$8.createDecipher = browser$8.Decipher = t.createDecipher, browser$8.createDecipheriv = browser$8.Decipheriv = t.createDecipheriv, browser$8.listCiphers = browser$8.getCiphers = Ie, browser$8;
}
var modes = {}, hasRequiredModes;
function requireModes() {
  return hasRequiredModes || (hasRequiredModes = 1, function(Ae) {
    Ae["des-ecb"] = {
      key: 8,
      iv: 0
    }, Ae["des-cbc"] = Ae.des = {
      key: 8,
      iv: 8
    }, Ae["des-ede3-cbc"] = Ae.des3 = {
      key: 24,
      iv: 8
    }, Ae["des-ede3"] = {
      key: 24,
      iv: 0
    }, Ae["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, Ae["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(modes)), modes;
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
  if (hasRequiredBrowser$5) return browser$9;
  hasRequiredBrowser$5 = 1;
  var Ae = requireBrowserifyDes(), t = requireBrowser$6(), Me = requireModes$1(), Ie = requireModes(), Pe = requireEvp_bytestokey();
  function Be(Ue, bi) {
    Ue = Ue.toLowerCase();
    var vi, mi;
    if (Me[Ue])
      vi = Me[Ue].key, mi = Me[Ue].iv;
    else if (Ie[Ue])
      vi = Ie[Ue].key * 8, mi = Ie[Ue].iv;
    else
      throw new TypeError("invalid suite type");
    var _i = Pe(bi, !1, vi, mi);
    return je(Ue, _i.key, _i.iv);
  }
  function Te(Ue, bi) {
    Ue = Ue.toLowerCase();
    var vi, mi;
    if (Me[Ue])
      vi = Me[Ue].key, mi = Me[Ue].iv;
    else if (Ie[Ue])
      vi = Ie[Ue].key * 8, mi = Ie[Ue].iv;
    else
      throw new TypeError("invalid suite type");
    var _i = Pe(bi, !1, vi, mi);
    return Ve(Ue, _i.key, _i.iv);
  }
  function je(Ue, bi, vi) {
    if (Ue = Ue.toLowerCase(), Me[Ue]) return t.createCipheriv(Ue, bi, vi);
    if (Ie[Ue]) return new Ae({ key: bi, iv: vi, mode: Ue });
    throw new TypeError("invalid suite type");
  }
  function Ve(Ue, bi, vi) {
    if (Ue = Ue.toLowerCase(), Me[Ue]) return t.createDecipheriv(Ue, bi, vi);
    if (Ie[Ue]) return new Ae({ key: bi, iv: vi, mode: Ue, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function fi() {
    return Object.keys(Ie).concat(t.getCiphers());
  }
  return browser$9.createCipher = browser$9.Cipher = Be, browser$9.createCipheriv = browser$9.Cipheriv = je, browser$9.createDecipher = browser$9.Decipher = Te, browser$9.createDecipheriv = browser$9.Decipheriv = Ve, browser$9.listCiphers = browser$9.getCiphers = fi, browser$9;
}
var browser$7 = {}, mr$3, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr$3;
  hasRequiredMr = 1;
  var Ae = bnExports, t = requireBrorand();
  function Me(Ie) {
    this.rand = Ie || new t.Rand();
  }
  return mr$3 = Me, Me.create = function(Pe) {
    return new Me(Pe);
  }, Me.prototype._randbelow = function(Pe) {
    var Be = Pe.bitLength(), Te = Math.ceil(Be / 8);
    do
      var je = new Ae(this.rand.generate(Te));
    while (je.cmp(Pe) >= 0);
    return je;
  }, Me.prototype._randrange = function(Pe, Be) {
    var Te = Be.sub(Pe);
    return Pe.add(this._randbelow(Te));
  }, Me.prototype.test = function(Pe, Be, Te) {
    var je = Pe.bitLength(), Ve = Ae.mont(Pe), fi = new Ae(1).toRed(Ve);
    Be || (Be = Math.max(1, je / 48 | 0));
    for (var Ue = Pe.subn(1), bi = 0; !Ue.testn(bi); bi++)
      ;
    for (var vi = Pe.shrn(bi), mi = Ue.toRed(Ve), _i = !0; Be > 0; Be--) {
      var $i = this._randrange(new Ae(2), Ue);
      Te && Te($i);
      var Ci = $i.toRed(Ve).redPow(vi);
      if (!(Ci.cmp(fi) === 0 || Ci.cmp(mi) === 0)) {
        for (var Ui = 1; Ui < bi; Ui++) {
          if (Ci = Ci.redSqr(), Ci.cmp(fi) === 0)
            return !1;
          if (Ci.cmp(mi) === 0)
            break;
        }
        if (Ui === bi)
          return !1;
      }
    }
    return _i;
  }, Me.prototype.getDivisor = function(Pe, Be) {
    var Te = Pe.bitLength(), je = Ae.mont(Pe), Ve = new Ae(1).toRed(je);
    Be || (Be = Math.max(1, Te / 48 | 0));
    for (var fi = Pe.subn(1), Ue = 0; !fi.testn(Ue); Ue++)
      ;
    for (var bi = Pe.shrn(Ue), vi = fi.toRed(je); Be > 0; Be--) {
      var mi = this._randrange(new Ae(2), fi), _i = Pe.gcd(mi);
      if (_i.cmpn(1) !== 0)
        return _i;
      var $i = mi.toRed(je).redPow(bi);
      if (!($i.cmp(Ve) === 0 || $i.cmp(vi) === 0)) {
        for (var Ci = 1; Ci < Ue; Ci++) {
          if ($i = $i.redSqr(), $i.cmp(Ve) === 0)
            return $i.fromRed().subn(1).gcd(Pe);
          if ($i.cmp(vi) === 0)
            break;
        }
        if (Ci === Ue)
          return $i = $i.redSqr(), $i.fromRed().subn(1).gcd(Pe);
      }
    }
    return !1;
  }, mr$3;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var Ae = requireBrowser$b();
  generatePrime = Ci, Ci.simpleSieve = _i, Ci.fermatTest = $i;
  var t = bnExports, Me = new t(24), Ie = requireMr(), Pe = new Ie(), Be = new t(1), Te = new t(2), je = new t(5);
  new t(16), new t(8);
  var Ve = new t(10), fi = new t(3);
  new t(7);
  var Ue = new t(11), bi = new t(4);
  new t(12);
  var vi = null;
  function mi() {
    if (vi !== null)
      return vi;
    var Ui = 1048576, ki = [];
    ki[0] = 2;
    for (var Ji = 1, Hi = 3; Hi < Ui; Hi += 2) {
      for (var Zi = Math.ceil(Math.sqrt(Hi)), Qi = 0; Qi < Ji && ki[Qi] <= Zi && Hi % ki[Qi] !== 0; Qi++)
        ;
      Ji !== Qi && ki[Qi] <= Zi || (ki[Ji++] = Hi);
    }
    return vi = ki, ki;
  }
  function _i(Ui) {
    for (var ki = mi(), Ji = 0; Ji < ki.length; Ji++)
      if (Ui.modn(ki[Ji]) === 0)
        return Ui.cmpn(ki[Ji]) === 0;
    return !0;
  }
  function $i(Ui) {
    var ki = t.mont(Ui);
    return Te.toRed(ki).redPow(Ui.subn(1)).fromRed().cmpn(1) === 0;
  }
  function Ci(Ui, ki) {
    if (Ui < 16)
      return ki === 2 || ki === 5 ? new t([140, 123]) : new t([140, 39]);
    ki = new t(ki);
    for (var Ji, Hi; ; ) {
      for (Ji = new t(Ae(Math.ceil(Ui / 8))); Ji.bitLength() > Ui; )
        Ji.ishrn(1);
      if (Ji.isEven() && Ji.iadd(Be), Ji.testn(1) || Ji.iadd(Te), ki.cmp(Te)) {
        if (!ki.cmp(je))
          for (; Ji.mod(Ve).cmp(fi); )
            Ji.iadd(bi);
      } else for (; Ji.mod(Me).cmp(Ue); )
        Ji.iadd(bi);
      if (Hi = Ji.shrn(1), _i(Hi) && _i(Ji) && $i(Hi) && $i(Ji) && Pe.test(Hi) && Pe.test(Ji))
        return Ji;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var Ae = bnExports, t = requireMr(), Me = new t(), Ie = new Ae(24), Pe = new Ae(11), Be = new Ae(10), Te = new Ae(3), je = new Ae(7), Ve = requireGeneratePrime(), fi = requireBrowser$b();
  dh = _i;
  function Ue(Ci, Ui) {
    return Ui = Ui || "utf8", Buffer$1.isBuffer(Ci) || (Ci = new Buffer$1(Ci, Ui)), this._pub = new Ae(Ci), this;
  }
  function bi(Ci, Ui) {
    return Ui = Ui || "utf8", Buffer$1.isBuffer(Ci) || (Ci = new Buffer$1(Ci, Ui)), this._priv = new Ae(Ci), this;
  }
  var vi = {};
  function mi(Ci, Ui) {
    var ki = Ui.toString("hex"), Ji = [ki, Ci.toString(16)].join("_");
    if (Ji in vi)
      return vi[Ji];
    var Hi = 0;
    if (Ci.isEven() || !Ve.simpleSieve || !Ve.fermatTest(Ci) || !Me.test(Ci))
      return Hi += 1, ki === "02" || ki === "05" ? Hi += 8 : Hi += 4, vi[Ji] = Hi, Hi;
    Me.test(Ci.shrn(1)) || (Hi += 2);
    var Zi;
    switch (ki) {
      case "02":
        Ci.mod(Ie).cmp(Pe) && (Hi += 8);
        break;
      case "05":
        Zi = Ci.mod(Be), Zi.cmp(Te) && Zi.cmp(je) && (Hi += 8);
        break;
      default:
        Hi += 4;
    }
    return vi[Ji] = Hi, Hi;
  }
  function _i(Ci, Ui, ki) {
    this.setGenerator(Ui), this.__prime = new Ae(Ci), this._prime = Ae.mont(this.__prime), this._primeLen = Ci.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, ki ? (this.setPublicKey = Ue, this.setPrivateKey = bi) : this._primeCode = 8;
  }
  Object.defineProperty(_i.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = mi(this.__prime, this.__gen)), this._primeCode;
    }
  }), _i.prototype.generateKeys = function() {
    return this._priv || (this._priv = new Ae(fi(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, _i.prototype.computeSecret = function(Ci) {
    Ci = new Ae(Ci), Ci = Ci.toRed(this._prime);
    var Ui = Ci.redPow(this._priv).fromRed(), ki = new Buffer$1(Ui.toArray()), Ji = this.getPrime();
    if (ki.length < Ji.length) {
      var Hi = new Buffer$1(Ji.length - ki.length);
      Hi.fill(0), ki = Buffer$1.concat([Hi, ki]);
    }
    return ki;
  }, _i.prototype.getPublicKey = function(Ui) {
    return $i(this._pub, Ui);
  }, _i.prototype.getPrivateKey = function(Ui) {
    return $i(this._priv, Ui);
  }, _i.prototype.getPrime = function(Ci) {
    return $i(this.__prime, Ci);
  }, _i.prototype.getGenerator = function(Ci) {
    return $i(this._gen, Ci);
  }, _i.prototype.setGenerator = function(Ci, Ui) {
    return Ui = Ui || "utf8", Buffer$1.isBuffer(Ci) || (Ci = new Buffer$1(Ci, Ui)), this.__gen = Ci, this._gen = new Ae(Ci), this;
  };
  function $i(Ci, Ui) {
    var ki = new Buffer$1(Ci.toArray());
    return Ui ? ki.toString(Ui) : ki;
  }
  return dh;
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4) return browser$7;
  hasRequiredBrowser$4 = 1;
  var Ae = requireGeneratePrime(), t = require$$1$1, Me = requireDh();
  function Ie(Te) {
    var je = new Buffer$1(t[Te].prime, "hex"), Ve = new Buffer$1(t[Te].gen, "hex");
    return new Me(je, Ve);
  }
  var Pe = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function Be(Te, je, Ve, fi) {
    return Buffer$1.isBuffer(je) || Pe[je] === void 0 ? Be(Te, "binary", je, Ve) : (je = je || "binary", fi = fi || "binary", Ve = Ve || new Buffer$1([2]), Buffer$1.isBuffer(Ve) || (Ve = new Buffer$1(Ve, fi)), typeof Te == "number" ? new Me(Ae(Te, Ve), Ve, !0) : (Buffer$1.isBuffer(Te) || (Te = new Buffer$1(Te, je)), new Me(Te, Ve, !0)));
  }
  return browser$7.DiffieHellmanGroup = browser$7.createDiffieHellmanGroup = browser$7.getDiffieHellman = Ie, browser$7.createDiffieHellman = browser$7.DiffieHellman = Be, browser$7;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} }, hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1, typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick: Ae } : processNextickArgs.exports = process$1;
  function Ae(t, Me, Ie, Pe) {
    if (typeof t != "function")
      throw new TypeError('"callback" argument must be a function');
    var Be = arguments.length, Te, je;
    switch (Be) {
      case 0:
      case 1:
        return process$1.nextTick(t);
      case 2:
        return process$1.nextTick(function() {
          t.call(null, Me);
        });
      case 3:
        return process$1.nextTick(function() {
          t.call(null, Me, Ie);
        });
      case 4:
        return process$1.nextTick(function() {
          t.call(null, Me, Ie, Pe);
        });
      default:
        for (Te = new Array(Be - 1), je = 0; je < Te.length; )
          Te[je++] = arguments[je];
        return process$1.nextTick(function() {
          t.apply(null, Te);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray, hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var Ae = {}.toString;
  return isarray = Array.isArray || function(t) {
    return Ae.call(t) == "[object Array]";
  }, isarray;
}
var streamBrowser, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser = eventsExports.EventEmitter), streamBrowser;
}
var safeBuffer = { exports: {} }, hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(Ae, t) {
    var Me = require$$0$3, Ie = Me.Buffer;
    function Pe(Te, je) {
      for (var Ve in Te)
        je[Ve] = Te[Ve];
    }
    Ie.from && Ie.alloc && Ie.allocUnsafe && Ie.allocUnsafeSlow ? Ae.exports = Me : (Pe(Me, t), t.Buffer = Be);
    function Be(Te, je, Ve) {
      return Ie(Te, je, Ve);
    }
    Pe(Ie, Be), Be.from = function(Te, je, Ve) {
      if (typeof Te == "number")
        throw new TypeError("Argument must not be a number");
      return Ie(Te, je, Ve);
    }, Be.alloc = function(Te, je, Ve) {
      if (typeof Te != "number")
        throw new TypeError("Argument must be a number");
      var fi = Ie(Te);
      return je !== void 0 ? typeof Ve == "string" ? fi.fill(je, Ve) : fi.fill(je) : fi.fill(0), fi;
    }, Be.allocUnsafe = function(Te) {
      if (typeof Te != "number")
        throw new TypeError("Argument must be a number");
      return Ie(Te);
    }, Be.allocUnsafeSlow = function(Te) {
      if (typeof Te != "number")
        throw new TypeError("Argument must be a number");
      return Me.SlowBuffer(Te);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var util = {}, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  function Ae($i) {
    return Array.isArray ? Array.isArray($i) : _i($i) === "[object Array]";
  }
  util.isArray = Ae;
  function t($i) {
    return typeof $i == "boolean";
  }
  util.isBoolean = t;
  function Me($i) {
    return $i === null;
  }
  util.isNull = Me;
  function Ie($i) {
    return $i == null;
  }
  util.isNullOrUndefined = Ie;
  function Pe($i) {
    return typeof $i == "number";
  }
  util.isNumber = Pe;
  function Be($i) {
    return typeof $i == "string";
  }
  util.isString = Be;
  function Te($i) {
    return typeof $i == "symbol";
  }
  util.isSymbol = Te;
  function je($i) {
    return $i === void 0;
  }
  util.isUndefined = je;
  function Ve($i) {
    return _i($i) === "[object RegExp]";
  }
  util.isRegExp = Ve;
  function fi($i) {
    return typeof $i == "object" && $i !== null;
  }
  util.isObject = fi;
  function Ue($i) {
    return _i($i) === "[object Date]";
  }
  util.isDate = Ue;
  function bi($i) {
    return _i($i) === "[object Error]" || $i instanceof Error;
  }
  util.isError = bi;
  function vi($i) {
    return typeof $i == "function";
  }
  util.isFunction = vi;
  function mi($i) {
    return $i === null || typeof $i == "boolean" || typeof $i == "number" || typeof $i == "string" || typeof $i == "symbol" || // ES6 symbol
    typeof $i > "u";
  }
  util.isPrimitive = mi, util.isBuffer = require$$0$3.Buffer.isBuffer;
  function _i($i) {
    return Object.prototype.toString.call($i);
  }
  return util;
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(Ae) {
    function t(Be, Te) {
      if (!(Be instanceof Te))
        throw new TypeError("Cannot call a class as a function");
    }
    var Me = requireSafeBuffer().Buffer, Ie = util$1;
    function Pe(Be, Te, je) {
      Be.copy(Te, je);
    }
    Ae.exports = function() {
      function Be() {
        t(this, Be), this.head = null, this.tail = null, this.length = 0;
      }
      return Be.prototype.push = function(je) {
        var Ve = { data: je, next: null };
        this.length > 0 ? this.tail.next = Ve : this.head = Ve, this.tail = Ve, ++this.length;
      }, Be.prototype.unshift = function(je) {
        var Ve = { data: je, next: this.head };
        this.length === 0 && (this.tail = Ve), this.head = Ve, ++this.length;
      }, Be.prototype.shift = function() {
        if (this.length !== 0) {
          var je = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, je;
        }
      }, Be.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, Be.prototype.join = function(je) {
        if (this.length === 0) return "";
        for (var Ve = this.head, fi = "" + Ve.data; Ve = Ve.next; )
          fi += je + Ve.data;
        return fi;
      }, Be.prototype.concat = function(je) {
        if (this.length === 0) return Me.alloc(0);
        for (var Ve = Me.allocUnsafe(je >>> 0), fi = this.head, Ue = 0; fi; )
          Pe(fi.data, Ve, Ue), Ue += fi.data.length, fi = fi.next;
        return Ve;
      }, Be;
    }(), Ie && Ie.inspect && Ie.inspect.custom && (Ae.exports.prototype[Ie.inspect.custom] = function() {
      var Be = Ie.inspect({ length: this.length });
      return this.constructor.name + " " + Be;
    });
  }(BufferList)), BufferList.exports;
}
var destroy_1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  var Ae = requireProcessNextickArgs();
  function t(Pe, Be) {
    var Te = this, je = this._readableState && this._readableState.destroyed, Ve = this._writableState && this._writableState.destroyed;
    return je || Ve ? (Be ? Be(Pe) : Pe && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, Ae.nextTick(Ie, this, Pe)) : Ae.nextTick(Ie, this, Pe)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(Pe || null, function(fi) {
      !Be && fi ? Te._writableState ? Te._writableState.errorEmitted || (Te._writableState.errorEmitted = !0, Ae.nextTick(Ie, Te, fi)) : Ae.nextTick(Ie, Te, fi) : Be && Be(fi);
    }), this);
  }
  function Me() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function Ie(Pe, Be) {
    Pe.emit("error", Be);
  }
  return destroy_1 = {
    destroy: t,
    undestroy: Me
  }, destroy_1;
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var Ae = requireProcessNextickArgs();
  _stream_writable = $i;
  function t(Pi) {
    var qi = this;
    this.next = null, this.entry = null, this.finish = function() {
      Ti(qi, Pi);
    };
  }
  var Me = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : Ae.nextTick, Ie;
  $i.WritableState = mi;
  var Pe = Object.create(requireUtil());
  Pe.inherits = inherits_browserExports;
  var Be = {
    deprecate: requireBrowser$a()
  }, Te = requireStreamBrowser(), je = requireSafeBuffer().Buffer, Ve = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function fi(Pi) {
    return je.from(Pi);
  }
  function Ue(Pi) {
    return je.isBuffer(Pi) || Pi instanceof Ve;
  }
  var bi = requireDestroy();
  Pe.inherits($i, Te);
  function vi() {
  }
  function mi(Pi, qi) {
    Ie = Ie || require_stream_duplex(), Pi = Pi || {};
    var Oi = qi instanceof Ie;
    this.objectMode = !!Pi.objectMode, Oi && (this.objectMode = this.objectMode || !!Pi.writableObjectMode);
    var Si = Pi.highWaterMark, Ni = Pi.writableHighWaterMark, xi = this.objectMode ? 16 : 16 * 1024;
    Si || Si === 0 ? this.highWaterMark = Si : Oi && (Ni || Ni === 0) ? this.highWaterMark = Ni : this.highWaterMark = xi, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Wi = Pi.decodeStrings === !1;
    this.decodeStrings = !Wi, this.defaultEncoding = Pi.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ts) {
      Bi(qi, ts);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  mi.prototype.getBuffer = function() {
    for (var qi = this.bufferedRequest, Oi = []; qi; )
      Oi.push(qi), qi = qi.next;
    return Oi;
  }, function() {
    try {
      Object.defineProperty(mi.prototype, "buffer", {
        get: Be.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var _i;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (_i = Function.prototype[Symbol.hasInstance], Object.defineProperty($i, Symbol.hasInstance, {
    value: function(Pi) {
      return _i.call(this, Pi) ? !0 : this !== $i ? !1 : Pi && Pi._writableState instanceof mi;
    }
  })) : _i = function(Pi) {
    return Pi instanceof this;
  };
  function $i(Pi) {
    if (Ie = Ie || require_stream_duplex(), !_i.call($i, this) && !(this instanceof Ie))
      return new $i(Pi);
    this._writableState = new mi(Pi, this), this.writable = !0, Pi && (typeof Pi.write == "function" && (this._write = Pi.write), typeof Pi.writev == "function" && (this._writev = Pi.writev), typeof Pi.destroy == "function" && (this._destroy = Pi.destroy), typeof Pi.final == "function" && (this._final = Pi.final)), Te.call(this);
  }
  $i.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function Ci(Pi, qi) {
    var Oi = new Error("write after end");
    Pi.emit("error", Oi), Ae.nextTick(qi, Oi);
  }
  function Ui(Pi, qi, Oi, Si) {
    var Ni = !0, xi = !1;
    return Oi === null ? xi = new TypeError("May not write null values to stream") : typeof Oi != "string" && Oi !== void 0 && !qi.objectMode && (xi = new TypeError("Invalid non-string/buffer chunk")), xi && (Pi.emit("error", xi), Ae.nextTick(Si, xi), Ni = !1), Ni;
  }
  $i.prototype.write = function(Pi, qi, Oi) {
    var Si = this._writableState, Ni = !1, xi = !Si.objectMode && Ue(Pi);
    return xi && !je.isBuffer(Pi) && (Pi = fi(Pi)), typeof qi == "function" && (Oi = qi, qi = null), xi ? qi = "buffer" : qi || (qi = Si.defaultEncoding), typeof Oi != "function" && (Oi = vi), Si.ended ? Ci(this, Oi) : (xi || Ui(this, Si, Pi, Oi)) && (Si.pendingcb++, Ni = Ji(this, Si, xi, Pi, qi, Oi)), Ni;
  }, $i.prototype.cork = function() {
    var Pi = this._writableState;
    Pi.corked++;
  }, $i.prototype.uncork = function() {
    var Pi = this._writableState;
    Pi.corked && (Pi.corked--, !Pi.writing && !Pi.corked && !Pi.bufferProcessing && Pi.bufferedRequest && ls(this, Pi));
  }, $i.prototype.setDefaultEncoding = function(qi) {
    if (typeof qi == "string" && (qi = qi.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((qi + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + qi);
    return this._writableState.defaultEncoding = qi, this;
  };
  function ki(Pi, qi, Oi) {
    return !Pi.objectMode && Pi.decodeStrings !== !1 && typeof qi == "string" && (qi = je.from(qi, Oi)), qi;
  }
  Object.defineProperty($i.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Ji(Pi, qi, Oi, Si, Ni, xi) {
    if (!Oi) {
      var Wi = ki(qi, Si, Ni);
      Si !== Wi && (Oi = !0, Ni = "buffer", Si = Wi);
    }
    var ts = qi.objectMode ? 1 : Si.length;
    qi.length += ts;
    var Ki = qi.length < qi.highWaterMark;
    if (Ki || (qi.needDrain = !0), qi.writing || qi.corked) {
      var fn = qi.lastBufferedRequest;
      qi.lastBufferedRequest = {
        chunk: Si,
        encoding: Ni,
        isBuf: Oi,
        callback: xi,
        next: null
      }, fn ? fn.next = qi.lastBufferedRequest : qi.bufferedRequest = qi.lastBufferedRequest, qi.bufferedRequestCount += 1;
    } else
      Hi(Pi, qi, !1, ts, Si, Ni, xi);
    return Ki;
  }
  function Hi(Pi, qi, Oi, Si, Ni, xi, Wi) {
    qi.writelen = Si, qi.writecb = Wi, qi.writing = !0, qi.sync = !0, Oi ? Pi._writev(Ni, qi.onwrite) : Pi._write(Ni, xi, qi.onwrite), qi.sync = !1;
  }
  function Zi(Pi, qi, Oi, Si, Ni) {
    --qi.pendingcb, Oi ? (Ae.nextTick(Ni, Si), Ae.nextTick(wi, Pi, qi), Pi._writableState.errorEmitted = !0, Pi.emit("error", Si)) : (Ni(Si), Pi._writableState.errorEmitted = !0, Pi.emit("error", Si), wi(Pi, qi));
  }
  function Qi(Pi) {
    Pi.writing = !1, Pi.writecb = null, Pi.length -= Pi.writelen, Pi.writelen = 0;
  }
  function Bi(Pi, qi) {
    var Oi = Pi._writableState, Si = Oi.sync, Ni = Oi.writecb;
    if (Qi(Oi), qi) Zi(Pi, Oi, Si, qi, Ni);
    else {
      var xi = vn(Oi);
      !xi && !Oi.corked && !Oi.bufferProcessing && Oi.bufferedRequest && ls(Pi, Oi), Si ? Me(Xi, Pi, Oi, xi, Ni) : Xi(Pi, Oi, xi, Ni);
    }
  }
  function Xi(Pi, qi, Oi, Si) {
    Oi || ns(Pi, qi), qi.pendingcb--, Si(), wi(Pi, qi);
  }
  function ns(Pi, qi) {
    qi.length === 0 && qi.needDrain && (qi.needDrain = !1, Pi.emit("drain"));
  }
  function ls(Pi, qi) {
    qi.bufferProcessing = !0;
    var Oi = qi.bufferedRequest;
    if (Pi._writev && Oi && Oi.next) {
      var Si = qi.bufferedRequestCount, Ni = new Array(Si), xi = qi.corkedRequestsFree;
      xi.entry = Oi;
      for (var Wi = 0, ts = !0; Oi; )
        Ni[Wi] = Oi, Oi.isBuf || (ts = !1), Oi = Oi.next, Wi += 1;
      Ni.allBuffers = ts, Hi(Pi, qi, !0, qi.length, Ni, "", xi.finish), qi.pendingcb++, qi.lastBufferedRequest = null, xi.next ? (qi.corkedRequestsFree = xi.next, xi.next = null) : qi.corkedRequestsFree = new t(qi), qi.bufferedRequestCount = 0;
    } else {
      for (; Oi; ) {
        var Ki = Oi.chunk, fn = Oi.encoding, Ii = Oi.callback, Fi = qi.objectMode ? 1 : Ki.length;
        if (Hi(Pi, qi, !1, Fi, Ki, fn, Ii), Oi = Oi.next, qi.bufferedRequestCount--, qi.writing)
          break;
      }
      Oi === null && (qi.lastBufferedRequest = null);
    }
    qi.bufferedRequest = Oi, qi.bufferProcessing = !1;
  }
  $i.prototype._write = function(Pi, qi, Oi) {
    Oi(new Error("_write() is not implemented"));
  }, $i.prototype._writev = null, $i.prototype.end = function(Pi, qi, Oi) {
    var Si = this._writableState;
    typeof Pi == "function" ? (Oi = Pi, Pi = null, qi = null) : typeof qi == "function" && (Oi = qi, qi = null), Pi != null && this.write(Pi, qi), Si.corked && (Si.corked = 1, this.uncork()), Si.ending || Ei(this, Si, Oi);
  };
  function vn(Pi) {
    return Pi.ending && Pi.length === 0 && Pi.bufferedRequest === null && !Pi.finished && !Pi.writing;
  }
  function Mi(Pi, qi) {
    Pi._final(function(Oi) {
      qi.pendingcb--, Oi && Pi.emit("error", Oi), qi.prefinished = !0, Pi.emit("prefinish"), wi(Pi, qi);
    });
  }
  function Ai(Pi, qi) {
    !qi.prefinished && !qi.finalCalled && (typeof Pi._final == "function" ? (qi.pendingcb++, qi.finalCalled = !0, Ae.nextTick(Mi, Pi, qi)) : (qi.prefinished = !0, Pi.emit("prefinish")));
  }
  function wi(Pi, qi) {
    var Oi = vn(qi);
    return Oi && (Ai(Pi, qi), qi.pendingcb === 0 && (qi.finished = !0, Pi.emit("finish"))), Oi;
  }
  function Ei(Pi, qi, Oi) {
    qi.ending = !0, wi(Pi, qi), Oi && (qi.finished ? Ae.nextTick(Oi) : Pi.once("finish", Oi)), qi.ended = !0, Pi.writable = !1;
  }
  function Ti(Pi, qi, Oi) {
    var Si = Pi.entry;
    for (Pi.entry = null; Si; ) {
      var Ni = Si.callback;
      qi.pendingcb--, Ni(Oi), Si = Si.next;
    }
    qi.corkedRequestsFree.next = Pi;
  }
  return Object.defineProperty($i.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Pi) {
      this._writableState && (this._writableState.destroyed = Pi);
    }
  }), $i.prototype.destroy = bi.destroy, $i.prototype._undestroy = bi.undestroy, $i.prototype._destroy = function(Pi, qi) {
    this.end(), qi(Pi);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var Ae = requireProcessNextickArgs(), t = Object.keys || function(bi) {
    var vi = [];
    for (var mi in bi)
      vi.push(mi);
    return vi;
  };
  _stream_duplex = Ve;
  var Me = Object.create(requireUtil());
  Me.inherits = inherits_browserExports;
  var Ie = require_stream_readable(), Pe = require_stream_writable();
  Me.inherits(Ve, Ie);
  for (var Be = t(Pe.prototype), Te = 0; Te < Be.length; Te++) {
    var je = Be[Te];
    Ve.prototype[je] || (Ve.prototype[je] = Pe.prototype[je]);
  }
  function Ve(bi) {
    if (!(this instanceof Ve)) return new Ve(bi);
    Ie.call(this, bi), Pe.call(this, bi), bi && bi.readable === !1 && (this.readable = !1), bi && bi.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, bi && bi.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", fi);
  }
  Object.defineProperty(Ve.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function fi() {
    this.allowHalfOpen || this._writableState.ended || Ae.nextTick(Ue, this);
  }
  function Ue(bi) {
    bi.end();
  }
  return Object.defineProperty(Ve.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(bi) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = bi, this._writableState.destroyed = bi);
    }
  }), Ve.prototype._destroy = function(bi, vi) {
    this.push(null), this.end(), Ae.nextTick(vi, bi);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var Ae = requireProcessNextickArgs();
  _stream_readable = ki;
  var t = requireIsarray(), Me;
  ki.ReadableState = Ui, eventsExports.EventEmitter;
  var Ie = function(Ii, Fi) {
    return Ii.listeners(Fi).length;
  }, Pe = requireStreamBrowser(), Be = requireSafeBuffer().Buffer, Te = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function je(Ii) {
    return Be.from(Ii);
  }
  function Ve(Ii) {
    return Be.isBuffer(Ii) || Ii instanceof Te;
  }
  var fi = Object.create(requireUtil());
  fi.inherits = inherits_browserExports;
  var Ue = util$1, bi = void 0;
  Ue && Ue.debuglog ? bi = Ue.debuglog("stream") : bi = function() {
  };
  var vi = requireBufferList(), mi = requireDestroy(), _i;
  fi.inherits(ki, Pe);
  var $i = ["error", "close", "destroy", "pause", "resume"];
  function Ci(Ii, Fi, Gi) {
    if (typeof Ii.prependListener == "function") return Ii.prependListener(Fi, Gi);
    !Ii._events || !Ii._events[Fi] ? Ii.on(Fi, Gi) : t(Ii._events[Fi]) ? Ii._events[Fi].unshift(Gi) : Ii._events[Fi] = [Gi, Ii._events[Fi]];
  }
  function Ui(Ii, Fi) {
    Me = Me || require_stream_duplex(), Ii = Ii || {};
    var Gi = Fi instanceof Me;
    this.objectMode = !!Ii.objectMode, Gi && (this.objectMode = this.objectMode || !!Ii.readableObjectMode);
    var Ri = Ii.highWaterMark, ji = Ii.readableHighWaterMark, Vi = this.objectMode ? 16 : 16 * 1024;
    Ri || Ri === 0 ? this.highWaterMark = Ri : Gi && (ji || ji === 0) ? this.highWaterMark = ji : this.highWaterMark = Vi, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new vi(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Ii.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Ii.encoding && (_i || (_i = string_decoder.StringDecoder), this.decoder = new _i(Ii.encoding), this.encoding = Ii.encoding);
  }
  function ki(Ii) {
    if (Me = Me || require_stream_duplex(), !(this instanceof ki)) return new ki(Ii);
    this._readableState = new Ui(Ii, this), this.readable = !0, Ii && (typeof Ii.read == "function" && (this._read = Ii.read), typeof Ii.destroy == "function" && (this._destroy = Ii.destroy)), Pe.call(this);
  }
  Object.defineProperty(ki.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Ii) {
      this._readableState && (this._readableState.destroyed = Ii);
    }
  }), ki.prototype.destroy = mi.destroy, ki.prototype._undestroy = mi.undestroy, ki.prototype._destroy = function(Ii, Fi) {
    this.push(null), Fi(Ii);
  }, ki.prototype.push = function(Ii, Fi) {
    var Gi = this._readableState, Ri;
    return Gi.objectMode ? Ri = !0 : typeof Ii == "string" && (Fi = Fi || Gi.defaultEncoding, Fi !== Gi.encoding && (Ii = Be.from(Ii, Fi), Fi = ""), Ri = !0), Ji(this, Ii, Fi, !1, Ri);
  }, ki.prototype.unshift = function(Ii) {
    return Ji(this, Ii, null, !0, !1);
  };
  function Ji(Ii, Fi, Gi, Ri, ji) {
    var Vi = Ii._readableState;
    if (Fi === null)
      Vi.reading = !1, ls(Ii, Vi);
    else {
      var is;
      ji || (is = Zi(Vi, Fi)), is ? Ii.emit("error", is) : Vi.objectMode || Fi && Fi.length > 0 ? (typeof Fi != "string" && !Vi.objectMode && Object.getPrototypeOf(Fi) !== Be.prototype && (Fi = je(Fi)), Ri ? Vi.endEmitted ? Ii.emit("error", new Error("stream.unshift() after end event")) : Hi(Ii, Vi, Fi, !0) : Vi.ended ? Ii.emit("error", new Error("stream.push() after EOF")) : (Vi.reading = !1, Vi.decoder && !Gi ? (Fi = Vi.decoder.write(Fi), Vi.objectMode || Fi.length !== 0 ? Hi(Ii, Vi, Fi, !1) : Ai(Ii, Vi)) : Hi(Ii, Vi, Fi, !1))) : Ri || (Vi.reading = !1);
    }
    return Qi(Vi);
  }
  function Hi(Ii, Fi, Gi, Ri) {
    Fi.flowing && Fi.length === 0 && !Fi.sync ? (Ii.emit("data", Gi), Ii.read(0)) : (Fi.length += Fi.objectMode ? 1 : Gi.length, Ri ? Fi.buffer.unshift(Gi) : Fi.buffer.push(Gi), Fi.needReadable && vn(Ii)), Ai(Ii, Fi);
  }
  function Zi(Ii, Fi) {
    var Gi;
    return !Ve(Fi) && typeof Fi != "string" && Fi !== void 0 && !Ii.objectMode && (Gi = new TypeError("Invalid non-string/buffer chunk")), Gi;
  }
  function Qi(Ii) {
    return !Ii.ended && (Ii.needReadable || Ii.length < Ii.highWaterMark || Ii.length === 0);
  }
  ki.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, ki.prototype.setEncoding = function(Ii) {
    return _i || (_i = string_decoder.StringDecoder), this._readableState.decoder = new _i(Ii), this._readableState.encoding = Ii, this;
  };
  var Bi = 8388608;
  function Xi(Ii) {
    return Ii >= Bi ? Ii = Bi : (Ii--, Ii |= Ii >>> 1, Ii |= Ii >>> 2, Ii |= Ii >>> 4, Ii |= Ii >>> 8, Ii |= Ii >>> 16, Ii++), Ii;
  }
  function ns(Ii, Fi) {
    return Ii <= 0 || Fi.length === 0 && Fi.ended ? 0 : Fi.objectMode ? 1 : Ii !== Ii ? Fi.flowing && Fi.length ? Fi.buffer.head.data.length : Fi.length : (Ii > Fi.highWaterMark && (Fi.highWaterMark = Xi(Ii)), Ii <= Fi.length ? Ii : Fi.ended ? Fi.length : (Fi.needReadable = !0, 0));
  }
  ki.prototype.read = function(Ii) {
    bi("read", Ii), Ii = parseInt(Ii, 10);
    var Fi = this._readableState, Gi = Ii;
    if (Ii !== 0 && (Fi.emittedReadable = !1), Ii === 0 && Fi.needReadable && (Fi.length >= Fi.highWaterMark || Fi.ended))
      return bi("read: emitReadable", Fi.length, Fi.ended), Fi.length === 0 && Fi.ended ? ts(this) : vn(this), null;
    if (Ii = ns(Ii, Fi), Ii === 0 && Fi.ended)
      return Fi.length === 0 && ts(this), null;
    var Ri = Fi.needReadable;
    bi("need readable", Ri), (Fi.length === 0 || Fi.length - Ii < Fi.highWaterMark) && (Ri = !0, bi("length less than watermark", Ri)), Fi.ended || Fi.reading ? (Ri = !1, bi("reading or ended", Ri)) : Ri && (bi("do read"), Fi.reading = !0, Fi.sync = !0, Fi.length === 0 && (Fi.needReadable = !0), this._read(Fi.highWaterMark), Fi.sync = !1, Fi.reading || (Ii = ns(Gi, Fi)));
    var ji;
    return Ii > 0 ? ji = Si(Ii, Fi) : ji = null, ji === null ? (Fi.needReadable = !0, Ii = 0) : Fi.length -= Ii, Fi.length === 0 && (Fi.ended || (Fi.needReadable = !0), Gi !== Ii && Fi.ended && ts(this)), ji !== null && this.emit("data", ji), ji;
  };
  function ls(Ii, Fi) {
    if (!Fi.ended) {
      if (Fi.decoder) {
        var Gi = Fi.decoder.end();
        Gi && Gi.length && (Fi.buffer.push(Gi), Fi.length += Fi.objectMode ? 1 : Gi.length);
      }
      Fi.ended = !0, vn(Ii);
    }
  }
  function vn(Ii) {
    var Fi = Ii._readableState;
    Fi.needReadable = !1, Fi.emittedReadable || (bi("emitReadable", Fi.flowing), Fi.emittedReadable = !0, Fi.sync ? Ae.nextTick(Mi, Ii) : Mi(Ii));
  }
  function Mi(Ii) {
    bi("emit readable"), Ii.emit("readable"), Oi(Ii);
  }
  function Ai(Ii, Fi) {
    Fi.readingMore || (Fi.readingMore = !0, Ae.nextTick(wi, Ii, Fi));
  }
  function wi(Ii, Fi) {
    for (var Gi = Fi.length; !Fi.reading && !Fi.flowing && !Fi.ended && Fi.length < Fi.highWaterMark && (bi("maybeReadMore read 0"), Ii.read(0), Gi !== Fi.length); )
      Gi = Fi.length;
    Fi.readingMore = !1;
  }
  ki.prototype._read = function(Ii) {
    this.emit("error", new Error("_read() is not implemented"));
  }, ki.prototype.pipe = function(Ii, Fi) {
    var Gi = this, Ri = this._readableState;
    switch (Ri.pipesCount) {
      case 0:
        Ri.pipes = Ii;
        break;
      case 1:
        Ri.pipes = [Ri.pipes, Ii];
        break;
      default:
        Ri.pipes.push(Ii);
        break;
    }
    Ri.pipesCount += 1, bi("pipe count=%d opts=%j", Ri.pipesCount, Fi);
    var ji = (!Fi || Fi.end !== !1) && Ii !== process$1.stdout && Ii !== process$1.stderr, Vi = ji ? os : aa;
    Ri.endEmitted ? Ae.nextTick(Vi) : Gi.once("end", Vi), Ii.on("unpipe", is);
    function is(Ds, ra) {
      bi("onunpipe"), Ds === Gi && ra && ra.hasUnpiped === !1 && (ra.hasUnpiped = !0, ea());
    }
    function os() {
      bi("onend"), Ii.end();
    }
    var ds = Ei(Gi);
    Ii.on("drain", ds);
    var ps = !1;
    function ea() {
      bi("cleanup"), Ii.removeListener("close", gs), Ii.removeListener("finish", sa), Ii.removeListener("drain", ds), Ii.removeListener("error", fa), Ii.removeListener("unpipe", is), Gi.removeListener("end", os), Gi.removeListener("end", aa), Gi.removeListener("data", hs), ps = !0, Ri.awaitDrain && (!Ii._writableState || Ii._writableState.needDrain) && ds();
    }
    var ia = !1;
    Gi.on("data", hs);
    function hs(Ds) {
      bi("ondata"), ia = !1;
      var ra = Ii.write(Ds);
      ra === !1 && !ia && ((Ri.pipesCount === 1 && Ri.pipes === Ii || Ri.pipesCount > 1 && fn(Ri.pipes, Ii) !== -1) && !ps && (bi("false write response, pause", Ri.awaitDrain), Ri.awaitDrain++, ia = !0), Gi.pause());
    }
    function fa(Ds) {
      bi("onerror", Ds), aa(), Ii.removeListener("error", fa), Ie(Ii, "error") === 0 && Ii.emit("error", Ds);
    }
    Ci(Ii, "error", fa);
    function gs() {
      Ii.removeListener("finish", sa), aa();
    }
    Ii.once("close", gs);
    function sa() {
      bi("onfinish"), Ii.removeListener("close", gs), aa();
    }
    Ii.once("finish", sa);
    function aa() {
      bi("unpipe"), Gi.unpipe(Ii);
    }
    return Ii.emit("pipe", Gi), Ri.flowing || (bi("pipe resume"), Gi.resume()), Ii;
  };
  function Ei(Ii) {
    return function() {
      var Fi = Ii._readableState;
      bi("pipeOnDrain", Fi.awaitDrain), Fi.awaitDrain && Fi.awaitDrain--, Fi.awaitDrain === 0 && Ie(Ii, "data") && (Fi.flowing = !0, Oi(Ii));
    };
  }
  ki.prototype.unpipe = function(Ii) {
    var Fi = this._readableState, Gi = { hasUnpiped: !1 };
    if (Fi.pipesCount === 0) return this;
    if (Fi.pipesCount === 1)
      return Ii && Ii !== Fi.pipes ? this : (Ii || (Ii = Fi.pipes), Fi.pipes = null, Fi.pipesCount = 0, Fi.flowing = !1, Ii && Ii.emit("unpipe", this, Gi), this);
    if (!Ii) {
      var Ri = Fi.pipes, ji = Fi.pipesCount;
      Fi.pipes = null, Fi.pipesCount = 0, Fi.flowing = !1;
      for (var Vi = 0; Vi < ji; Vi++)
        Ri[Vi].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var is = fn(Fi.pipes, Ii);
    return is === -1 ? this : (Fi.pipes.splice(is, 1), Fi.pipesCount -= 1, Fi.pipesCount === 1 && (Fi.pipes = Fi.pipes[0]), Ii.emit("unpipe", this, Gi), this);
  }, ki.prototype.on = function(Ii, Fi) {
    var Gi = Pe.prototype.on.call(this, Ii, Fi);
    if (Ii === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (Ii === "readable") {
      var Ri = this._readableState;
      !Ri.endEmitted && !Ri.readableListening && (Ri.readableListening = Ri.needReadable = !0, Ri.emittedReadable = !1, Ri.reading ? Ri.length && vn(this) : Ae.nextTick(Ti, this));
    }
    return Gi;
  }, ki.prototype.addListener = ki.prototype.on;
  function Ti(Ii) {
    bi("readable nexttick read 0"), Ii.read(0);
  }
  ki.prototype.resume = function() {
    var Ii = this._readableState;
    return Ii.flowing || (bi("resume"), Ii.flowing = !0, Pi(this, Ii)), this;
  };
  function Pi(Ii, Fi) {
    Fi.resumeScheduled || (Fi.resumeScheduled = !0, Ae.nextTick(qi, Ii, Fi));
  }
  function qi(Ii, Fi) {
    Fi.reading || (bi("resume read 0"), Ii.read(0)), Fi.resumeScheduled = !1, Fi.awaitDrain = 0, Ii.emit("resume"), Oi(Ii), Fi.flowing && !Fi.reading && Ii.read(0);
  }
  ki.prototype.pause = function() {
    return bi("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (bi("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function Oi(Ii) {
    var Fi = Ii._readableState;
    for (bi("flow", Fi.flowing); Fi.flowing && Ii.read() !== null; )
      ;
  }
  ki.prototype.wrap = function(Ii) {
    var Fi = this, Gi = this._readableState, Ri = !1;
    Ii.on("end", function() {
      if (bi("wrapped end"), Gi.decoder && !Gi.ended) {
        var is = Gi.decoder.end();
        is && is.length && Fi.push(is);
      }
      Fi.push(null);
    }), Ii.on("data", function(is) {
      if (bi("wrapped data"), Gi.decoder && (is = Gi.decoder.write(is)), !(Gi.objectMode && is == null) && !(!Gi.objectMode && (!is || !is.length))) {
        var os = Fi.push(is);
        os || (Ri = !0, Ii.pause());
      }
    });
    for (var ji in Ii)
      this[ji] === void 0 && typeof Ii[ji] == "function" && (this[ji] = /* @__PURE__ */ function(is) {
        return function() {
          return Ii[is].apply(Ii, arguments);
        };
      }(ji));
    for (var Vi = 0; Vi < $i.length; Vi++)
      Ii.on($i[Vi], this.emit.bind(this, $i[Vi]));
    return this._read = function(is) {
      bi("wrapped _read", is), Ri && (Ri = !1, Ii.resume());
    }, this;
  }, Object.defineProperty(ki.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), ki._fromList = Si;
  function Si(Ii, Fi) {
    if (Fi.length === 0) return null;
    var Gi;
    return Fi.objectMode ? Gi = Fi.buffer.shift() : !Ii || Ii >= Fi.length ? (Fi.decoder ? Gi = Fi.buffer.join("") : Fi.buffer.length === 1 ? Gi = Fi.buffer.head.data : Gi = Fi.buffer.concat(Fi.length), Fi.buffer.clear()) : Gi = Ni(Ii, Fi.buffer, Fi.decoder), Gi;
  }
  function Ni(Ii, Fi, Gi) {
    var Ri;
    return Ii < Fi.head.data.length ? (Ri = Fi.head.data.slice(0, Ii), Fi.head.data = Fi.head.data.slice(Ii)) : Ii === Fi.head.data.length ? Ri = Fi.shift() : Ri = Gi ? xi(Ii, Fi) : Wi(Ii, Fi), Ri;
  }
  function xi(Ii, Fi) {
    var Gi = Fi.head, Ri = 1, ji = Gi.data;
    for (Ii -= ji.length; Gi = Gi.next; ) {
      var Vi = Gi.data, is = Ii > Vi.length ? Vi.length : Ii;
      if (is === Vi.length ? ji += Vi : ji += Vi.slice(0, Ii), Ii -= is, Ii === 0) {
        is === Vi.length ? (++Ri, Gi.next ? Fi.head = Gi.next : Fi.head = Fi.tail = null) : (Fi.head = Gi, Gi.data = Vi.slice(is));
        break;
      }
      ++Ri;
    }
    return Fi.length -= Ri, ji;
  }
  function Wi(Ii, Fi) {
    var Gi = Be.allocUnsafe(Ii), Ri = Fi.head, ji = 1;
    for (Ri.data.copy(Gi), Ii -= Ri.data.length; Ri = Ri.next; ) {
      var Vi = Ri.data, is = Ii > Vi.length ? Vi.length : Ii;
      if (Vi.copy(Gi, Gi.length - Ii, 0, is), Ii -= is, Ii === 0) {
        is === Vi.length ? (++ji, Ri.next ? Fi.head = Ri.next : Fi.head = Fi.tail = null) : (Fi.head = Ri, Ri.data = Vi.slice(is));
        break;
      }
      ++ji;
    }
    return Fi.length -= ji, Gi;
  }
  function ts(Ii) {
    var Fi = Ii._readableState;
    if (Fi.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    Fi.endEmitted || (Fi.ended = !0, Ae.nextTick(Ki, Fi, Ii));
  }
  function Ki(Ii, Fi) {
    !Ii.endEmitted && Ii.length === 0 && (Ii.endEmitted = !0, Fi.readable = !1, Fi.emit("end"));
  }
  function fn(Ii, Fi) {
    for (var Gi = 0, Ri = Ii.length; Gi < Ri; Gi++)
      if (Ii[Gi] === Fi) return Gi;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1, _stream_transform = Ie;
  var Ae = require_stream_duplex(), t = Object.create(requireUtil());
  t.inherits = inherits_browserExports, t.inherits(Ie, Ae);
  function Me(Te, je) {
    var Ve = this._transformState;
    Ve.transforming = !1;
    var fi = Ve.writecb;
    if (!fi)
      return this.emit("error", new Error("write callback called multiple times"));
    Ve.writechunk = null, Ve.writecb = null, je != null && this.push(je), fi(Te);
    var Ue = this._readableState;
    Ue.reading = !1, (Ue.needReadable || Ue.length < Ue.highWaterMark) && this._read(Ue.highWaterMark);
  }
  function Ie(Te) {
    if (!(this instanceof Ie)) return new Ie(Te);
    Ae.call(this, Te), this._transformState = {
      afterTransform: Me.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, Te && (typeof Te.transform == "function" && (this._transform = Te.transform), typeof Te.flush == "function" && (this._flush = Te.flush)), this.on("prefinish", Pe);
  }
  function Pe() {
    var Te = this;
    typeof this._flush == "function" ? this._flush(function(je, Ve) {
      Be(Te, je, Ve);
    }) : Be(this, null, null);
  }
  Ie.prototype.push = function(Te, je) {
    return this._transformState.needTransform = !1, Ae.prototype.push.call(this, Te, je);
  }, Ie.prototype._transform = function(Te, je, Ve) {
    throw new Error("_transform() is not implemented");
  }, Ie.prototype._write = function(Te, je, Ve) {
    var fi = this._transformState;
    if (fi.writecb = Ve, fi.writechunk = Te, fi.writeencoding = je, !fi.transforming) {
      var Ue = this._readableState;
      (fi.needTransform || Ue.needReadable || Ue.length < Ue.highWaterMark) && this._read(Ue.highWaterMark);
    }
  }, Ie.prototype._read = function(Te) {
    var je = this._transformState;
    je.writechunk !== null && je.writecb && !je.transforming ? (je.transforming = !0, this._transform(je.writechunk, je.writeencoding, je.afterTransform)) : je.needTransform = !0;
  }, Ie.prototype._destroy = function(Te, je) {
    var Ve = this;
    Ae.prototype._destroy.call(this, Te, function(fi) {
      je(fi), Ve.emit("close");
    });
  };
  function Be(Te, je, Ve) {
    if (je) return Te.emit("error", je);
    if (Ve != null && Te.push(Ve), Te._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (Te._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return Te.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1, _stream_passthrough = Me;
  var Ae = require_stream_transform(), t = Object.create(requireUtil());
  t.inherits = inherits_browserExports, t.inherits(Me, Ae);
  function Me(Ie) {
    if (!(this instanceof Me)) return new Me(Ie);
    Ae.call(this, Ie);
  }
  return Me.prototype._transform = function(Ie, Pe, Be) {
    Be(null, Ie);
  }, _stream_passthrough;
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
  return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1, function(Ae, t) {
    t = Ae.exports = require_stream_readable(), t.Stream = t, t.Readable = t, t.Writable = require_stream_writable(), t.Duplex = require_stream_duplex(), t.Transform = require_stream_transform(), t.PassThrough = require_stream_passthrough();
  }(readableBrowser, readableBrowser.exports)), readableBrowser.exports;
}
var sign = { exports: {} }, browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa) return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var Ae = bnExports$1, t = requireBrowser$b(), Me = requireSafeBuffer$1().Buffer;
  function Ie(Te) {
    var je = Te.modulus.byteLength(), Ve;
    do
      Ve = new Ae(t(je));
    while (Ve.cmp(Te.modulus) >= 0 || !Ve.umod(Te.prime1) || !Ve.umod(Te.prime2));
    return Ve;
  }
  function Pe(Te) {
    var je = Ie(Te), Ve = je.toRed(Ae.mont(Te.modulus)).redPow(new Ae(Te.publicExponent)).fromRed();
    return { blinder: Ve, unblinder: je.invm(Te.modulus) };
  }
  function Be(Te, je) {
    var Ve = Pe(je), fi = je.modulus.byteLength(), Ue = new Ae(Te).mul(Ve.blinder).umod(je.modulus), bi = Ue.toRed(Ae.mont(je.prime1)), vi = Ue.toRed(Ae.mont(je.prime2)), mi = je.coefficient, _i = je.prime1, $i = je.prime2, Ci = bi.redPow(je.exponent1).fromRed(), Ui = vi.redPow(je.exponent2).fromRed(), ki = Ci.isub(Ui).imul(mi).umod(_i).imul($i);
    return Ui.iadd(ki).imul(Ve.unblinder).umod(je.modulus).toArrayLike(Me, "be", fi);
  }
  return Be.getr = Ie, browserifyRsa = Be, browserifyRsa;
}
var asn1$1 = {}, asn1 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(Ae, t) {
      if (Ae.indexOf) return Ae.indexOf(t);
      for (var Me = 0; Me < Ae.length; Me++)
        if (Ae[Me] === t) return Me;
      return -1;
    }, Object_keys = function(Ae) {
      if (Object.keys) return Object.keys(Ae);
      var t = [];
      for (var Me in Ae) t.push(Me);
      return t;
    }, forEach = function(Ae, t) {
      if (Ae.forEach) return Ae.forEach(t);
      for (var Me = 0; Me < Ae.length; Me++)
        t(Ae[Me], Me, Ae);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(Ae, t, Me) {
          Object.defineProperty(Ae, t, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: Me
          });
        };
      } catch {
        return function(t, Me, Ie) {
          t[Me] = Ie;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(t) {
      if (!(this instanceof Script)) return new Script(t);
      this.code = t;
    };
    Script.prototype.runInContext = function(Ae) {
      if (!(Ae instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var t = document.createElement("iframe");
      t.style || (t.style = {}), t.style.display = "none", document.body.appendChild(t);
      var Me = t.contentWindow, Ie = Me.eval, Pe = Me.execScript;
      !Ie && Pe && (Pe.call(Me, "null"), Ie = Me.eval), forEach(Object_keys(Ae), function(je) {
        Me[je] = Ae[je];
      }), forEach(globals, function(je) {
        Ae[je] && (Me[je] = Ae[je]);
      });
      var Be = Object_keys(Me), Te = Ie.call(Me, this.code);
      return forEach(Object_keys(Me), function(je) {
        (je in Ae || indexOf(Be, je) === -1) && (Ae[je] = Me[je]);
      }), forEach(globals, function(je) {
        je in Ae || defineProp(Ae, je, Me[je]);
      }), document.body.removeChild(t), Te;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(Ae) {
      var t = Script.createContext(Ae), Me = this.runInContext(t);
      return Ae && forEach(Object_keys(t), function(Ie) {
        Ae[Ie] = t[Ie];
      }), Me;
    }, forEach(Object_keys(Script.prototype), function(Ae) {
      exports[Ae] = Script[Ae] = function(t) {
        var Me = Script(t);
        return Me[Ae].apply(Me, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(Ae) {
      return Ae instanceof Context;
    }, exports.createScript = function(Ae) {
      return exports.Script(Ae);
    }, exports.createContext = Script.createContext = function(Ae) {
      var t = new Context();
      return typeof Ae == "object" && forEach(Object_keys(Ae), function(Me) {
        t[Me] = Ae[Me];
      }), t;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(Ae) {
    var t = requireAsn1$1(), Me = inherits_browserExports, Ie = Ae;
    Ie.define = function(Te, je) {
      return new Pe(Te, je);
    };
    function Pe(Be, Te) {
      this.name = Be, this.body = Te, this.decoders = {}, this.encoders = {};
    }
    Pe.prototype._createNamed = function(Te) {
      var je;
      try {
        je = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        je = function(fi) {
          this._initNamed(fi);
        };
      }
      return Me(je, Te), je.prototype._initNamed = function(fi) {
        Te.call(this, fi);
      }, new je(this);
    }, Pe.prototype._getDecoder = function(Te) {
      return Te = Te || "der", this.decoders.hasOwnProperty(Te) || (this.decoders[Te] = this._createNamed(t.decoders[Te])), this.decoders[Te];
    }, Pe.prototype.decode = function(Te, je, Ve) {
      return this._getDecoder(je).decode(Te, Ve);
    }, Pe.prototype._getEncoder = function(Te) {
      return Te = Te || "der", this.encoders.hasOwnProperty(Te) || (this.encoders[Te] = this._createNamed(t.encoders[Te])), this.encoders[Te];
    }, Pe.prototype.encode = function(Te, je, Ve) {
      return this._getEncoder(je).encode(Te, Ve);
    };
  }(api)), api;
}
var base$3 = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter) return reporter;
  hasRequiredReporter = 1;
  var Ae = inherits_browserExports;
  function t(Ie) {
    this._reporterState = {
      obj: null,
      path: [],
      options: Ie || {},
      errors: []
    };
  }
  reporter.Reporter = t, t.prototype.isError = function(Pe) {
    return Pe instanceof Me;
  }, t.prototype.save = function() {
    var Pe = this._reporterState;
    return { obj: Pe.obj, pathLen: Pe.path.length };
  }, t.prototype.restore = function(Pe) {
    var Be = this._reporterState;
    Be.obj = Pe.obj, Be.path = Be.path.slice(0, Pe.pathLen);
  }, t.prototype.enterKey = function(Pe) {
    return this._reporterState.path.push(Pe);
  }, t.prototype.exitKey = function(Pe) {
    var Be = this._reporterState;
    Be.path = Be.path.slice(0, Pe - 1);
  }, t.prototype.leaveKey = function(Pe, Be, Te) {
    var je = this._reporterState;
    this.exitKey(Pe), je.obj !== null && (je.obj[Be] = Te);
  }, t.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, t.prototype.enterObject = function() {
    var Pe = this._reporterState, Be = Pe.obj;
    return Pe.obj = {}, Be;
  }, t.prototype.leaveObject = function(Pe) {
    var Be = this._reporterState, Te = Be.obj;
    return Be.obj = Pe, Te;
  }, t.prototype.error = function(Pe) {
    var Be, Te = this._reporterState, je = Pe instanceof Me;
    if (je ? Be = Pe : Be = new Me(Te.path.map(function(Ve) {
      return "[" + JSON.stringify(Ve) + "]";
    }).join(""), Pe.message || Pe, Pe.stack), !Te.options.partial)
      throw Be;
    return je || Te.errors.push(Be), Be;
  }, t.prototype.wrapResult = function(Pe) {
    var Be = this._reporterState;
    return Be.options.partial ? {
      result: this.isError(Pe) ? null : Pe,
      errors: Be.errors
    } : Pe;
  };
  function Me(Ie, Pe) {
    this.path = Ie, this.rethrow(Pe);
  }
  return Ae(Me, Error), Me.prototype.rethrow = function(Pe) {
    if (this.message = Pe + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, Me), !this.stack)
      try {
        throw new Error(this.message);
      } catch (Be) {
        this.stack = Be.stack;
      }
    return this;
  }, reporter;
}
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var Ae = inherits_browserExports, t = requireBase().Reporter, Me = require$$0$3.Buffer;
  function Ie(Be, Te) {
    if (t.call(this, Te), !Me.isBuffer(Be)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = Be, this.offset = 0, this.length = Be.length;
  }
  Ae(Ie, t), buffer.DecoderBuffer = Ie, Ie.prototype.save = function() {
    return { offset: this.offset, reporter: t.prototype.save.call(this) };
  }, Ie.prototype.restore = function(Te) {
    var je = new Ie(this.base);
    return je.offset = Te.offset, je.length = this.offset, this.offset = Te.offset, t.prototype.restore.call(this, Te.reporter), je;
  }, Ie.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, Ie.prototype.readUInt8 = function(Te) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(Te || "DecoderBuffer overrun");
  }, Ie.prototype.skip = function(Te, je) {
    if (!(this.offset + Te <= this.length))
      return this.error(je || "DecoderBuffer overrun");
    var Ve = new Ie(this.base);
    return Ve._reporterState = this._reporterState, Ve.offset = this.offset, Ve.length = this.offset + Te, this.offset += Te, Ve;
  }, Ie.prototype.raw = function(Te) {
    return this.base.slice(Te ? Te.offset : this.offset, this.length);
  };
  function Pe(Be, Te) {
    if (Array.isArray(Be))
      this.length = 0, this.value = Be.map(function(je) {
        return je instanceof Pe || (je = new Pe(je, Te)), this.length += je.length, je;
      }, this);
    else if (typeof Be == "number") {
      if (!(0 <= Be && Be <= 255))
        return Te.error("non-byte EncoderBuffer value");
      this.value = Be, this.length = 1;
    } else if (typeof Be == "string")
      this.value = Be, this.length = Me.byteLength(Be);
    else if (Me.isBuffer(Be))
      this.value = Be, this.length = Be.length;
    else
      return Te.error("Unsupported type: " + typeof Be);
  }
  return buffer.EncoderBuffer = Pe, Pe.prototype.join = function(Te, je) {
    return Te || (Te = new Me(this.length)), je || (je = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(Ve) {
      Ve.join(Te, je), je += Ve.length;
    }) : (typeof this.value == "number" ? Te[je] = this.value : typeof this.value == "string" ? Te.write(this.value, je) : Me.isBuffer(this.value) && this.value.copy(Te, je), je += this.length)), Te;
  }, buffer;
}
var node$1, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node$1;
  hasRequiredNode = 1;
  var Ae = requireBase().Reporter, t = requireBase().EncoderBuffer, Me = requireBase().DecoderBuffer, Ie = minimalisticAssert$1, Pe = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], Be = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(Pe), Te = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function je(fi, Ue) {
    var bi = {};
    this._baseState = bi, bi.enc = fi, bi.parent = Ue || null, bi.children = null, bi.tag = null, bi.args = null, bi.reverseArgs = null, bi.choice = null, bi.optional = !1, bi.any = !1, bi.obj = !1, bi.use = null, bi.useDecoder = null, bi.key = null, bi.default = null, bi.explicit = null, bi.implicit = null, bi.contains = null, bi.parent || (bi.children = [], this._wrap());
  }
  node$1 = je;
  var Ve = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return je.prototype.clone = function() {
    var Ue = this._baseState, bi = {};
    Ve.forEach(function(mi) {
      bi[mi] = Ue[mi];
    });
    var vi = new this.constructor(bi.parent);
    return vi._baseState = bi, vi;
  }, je.prototype._wrap = function() {
    var Ue = this._baseState;
    Be.forEach(function(bi) {
      this[bi] = function() {
        var mi = new this.constructor(this);
        return Ue.children.push(mi), mi[bi].apply(mi, arguments);
      };
    }, this);
  }, je.prototype._init = function(Ue) {
    var bi = this._baseState;
    Ie(bi.parent === null), Ue.call(this), bi.children = bi.children.filter(function(vi) {
      return vi._baseState.parent === this;
    }, this), Ie.equal(bi.children.length, 1, "Root node can have only one child");
  }, je.prototype._useArgs = function(Ue) {
    var bi = this._baseState, vi = Ue.filter(function(mi) {
      return mi instanceof this.constructor;
    }, this);
    Ue = Ue.filter(function(mi) {
      return !(mi instanceof this.constructor);
    }, this), vi.length !== 0 && (Ie(bi.children === null), bi.children = vi, vi.forEach(function(mi) {
      mi._baseState.parent = this;
    }, this)), Ue.length !== 0 && (Ie(bi.args === null), bi.args = Ue, bi.reverseArgs = Ue.map(function(mi) {
      if (typeof mi != "object" || mi.constructor !== Object)
        return mi;
      var _i = {};
      return Object.keys(mi).forEach(function($i) {
        $i == ($i | 0) && ($i |= 0);
        var Ci = mi[$i];
        _i[Ci] = $i;
      }), _i;
    }));
  }, Te.forEach(function(fi) {
    je.prototype[fi] = function() {
      var bi = this._baseState;
      throw new Error(fi + " not implemented for encoding: " + bi.enc);
    };
  }), Pe.forEach(function(fi) {
    je.prototype[fi] = function() {
      var bi = this._baseState, vi = Array.prototype.slice.call(arguments);
      return Ie(bi.tag === null), bi.tag = fi, this._useArgs(vi), this;
    };
  }), je.prototype.use = function(Ue) {
    Ie(Ue);
    var bi = this._baseState;
    return Ie(bi.use === null), bi.use = Ue, this;
  }, je.prototype.optional = function() {
    var Ue = this._baseState;
    return Ue.optional = !0, this;
  }, je.prototype.def = function(Ue) {
    var bi = this._baseState;
    return Ie(bi.default === null), bi.default = Ue, bi.optional = !0, this;
  }, je.prototype.explicit = function(Ue) {
    var bi = this._baseState;
    return Ie(bi.explicit === null && bi.implicit === null), bi.explicit = Ue, this;
  }, je.prototype.implicit = function(Ue) {
    var bi = this._baseState;
    return Ie(bi.explicit === null && bi.implicit === null), bi.implicit = Ue, this;
  }, je.prototype.obj = function() {
    var Ue = this._baseState, bi = Array.prototype.slice.call(arguments);
    return Ue.obj = !0, bi.length !== 0 && this._useArgs(bi), this;
  }, je.prototype.key = function(Ue) {
    var bi = this._baseState;
    return Ie(bi.key === null), bi.key = Ue, this;
  }, je.prototype.any = function() {
    var Ue = this._baseState;
    return Ue.any = !0, this;
  }, je.prototype.choice = function(Ue) {
    var bi = this._baseState;
    return Ie(bi.choice === null), bi.choice = Ue, this._useArgs(Object.keys(Ue).map(function(vi) {
      return Ue[vi];
    })), this;
  }, je.prototype.contains = function(Ue) {
    var bi = this._baseState;
    return Ie(bi.use === null), bi.contains = Ue, this;
  }, je.prototype._decode = function(Ue, bi) {
    var vi = this._baseState;
    if (vi.parent === null)
      return Ue.wrapResult(vi.children[0]._decode(Ue, bi));
    var mi = vi.default, _i = !0, $i = null;
    if (vi.key !== null && ($i = Ue.enterKey(vi.key)), vi.optional) {
      var Ci = null;
      if (vi.explicit !== null ? Ci = vi.explicit : vi.implicit !== null ? Ci = vi.implicit : vi.tag !== null && (Ci = vi.tag), Ci === null && !vi.any) {
        var Ui = Ue.save();
        try {
          vi.choice === null ? this._decodeGeneric(vi.tag, Ue, bi) : this._decodeChoice(Ue, bi), _i = !0;
        } catch {
          _i = !1;
        }
        Ue.restore(Ui);
      } else if (_i = this._peekTag(Ue, Ci, vi.any), Ue.isError(_i))
        return _i;
    }
    var ki;
    if (vi.obj && _i && (ki = Ue.enterObject()), _i) {
      if (vi.explicit !== null) {
        var Ji = this._decodeTag(Ue, vi.explicit);
        if (Ue.isError(Ji))
          return Ji;
        Ue = Ji;
      }
      var Hi = Ue.offset;
      if (vi.use === null && vi.choice === null) {
        if (vi.any)
          var Ui = Ue.save();
        var Zi = this._decodeTag(
          Ue,
          vi.implicit !== null ? vi.implicit : vi.tag,
          vi.any
        );
        if (Ue.isError(Zi))
          return Zi;
        vi.any ? mi = Ue.raw(Ui) : Ue = Zi;
      }
      if (bi && bi.track && vi.tag !== null && bi.track(Ue.path(), Hi, Ue.length, "tagged"), bi && bi.track && vi.tag !== null && bi.track(Ue.path(), Ue.offset, Ue.length, "content"), vi.any ? mi = mi : vi.choice === null ? mi = this._decodeGeneric(vi.tag, Ue, bi) : mi = this._decodeChoice(Ue, bi), Ue.isError(mi))
        return mi;
      if (!vi.any && vi.choice === null && vi.children !== null && vi.children.forEach(function(Xi) {
        Xi._decode(Ue, bi);
      }), vi.contains && (vi.tag === "octstr" || vi.tag === "bitstr")) {
        var Qi = new Me(mi);
        mi = this._getUse(vi.contains, Ue._reporterState.obj)._decode(Qi, bi);
      }
    }
    return vi.obj && _i && (mi = Ue.leaveObject(ki)), vi.key !== null && (mi !== null || _i === !0) ? Ue.leaveKey($i, vi.key, mi) : $i !== null && Ue.exitKey($i), mi;
  }, je.prototype._decodeGeneric = function(Ue, bi, vi) {
    var mi = this._baseState;
    return Ue === "seq" || Ue === "set" ? null : Ue === "seqof" || Ue === "setof" ? this._decodeList(bi, Ue, mi.args[0], vi) : /str$/.test(Ue) ? this._decodeStr(bi, Ue, vi) : Ue === "objid" && mi.args ? this._decodeObjid(bi, mi.args[0], mi.args[1], vi) : Ue === "objid" ? this._decodeObjid(bi, null, null, vi) : Ue === "gentime" || Ue === "utctime" ? this._decodeTime(bi, Ue, vi) : Ue === "null_" ? this._decodeNull(bi, vi) : Ue === "bool" ? this._decodeBool(bi, vi) : Ue === "objDesc" ? this._decodeStr(bi, Ue, vi) : Ue === "int" || Ue === "enum" ? this._decodeInt(bi, mi.args && mi.args[0], vi) : mi.use !== null ? this._getUse(mi.use, bi._reporterState.obj)._decode(bi, vi) : bi.error("unknown tag: " + Ue);
  }, je.prototype._getUse = function(Ue, bi) {
    var vi = this._baseState;
    return vi.useDecoder = this._use(Ue, bi), Ie(vi.useDecoder._baseState.parent === null), vi.useDecoder = vi.useDecoder._baseState.children[0], vi.implicit !== vi.useDecoder._baseState.implicit && (vi.useDecoder = vi.useDecoder.clone(), vi.useDecoder._baseState.implicit = vi.implicit), vi.useDecoder;
  }, je.prototype._decodeChoice = function(Ue, bi) {
    var vi = this._baseState, mi = null, _i = !1;
    return Object.keys(vi.choice).some(function($i) {
      var Ci = Ue.save(), Ui = vi.choice[$i];
      try {
        var ki = Ui._decode(Ue, bi);
        if (Ue.isError(ki))
          return !1;
        mi = { type: $i, value: ki }, _i = !0;
      } catch {
        return Ue.restore(Ci), !1;
      }
      return !0;
    }, this), _i ? mi : Ue.error("Choice not matched");
  }, je.prototype._createEncoderBuffer = function(Ue) {
    return new t(Ue, this.reporter);
  }, je.prototype._encode = function(Ue, bi, vi) {
    var mi = this._baseState;
    if (!(mi.default !== null && mi.default === Ue)) {
      var _i = this._encodeValue(Ue, bi, vi);
      if (_i !== void 0 && !this._skipDefault(_i, bi, vi))
        return _i;
    }
  }, je.prototype._encodeValue = function(Ue, bi, vi) {
    var mi = this._baseState;
    if (mi.parent === null)
      return mi.children[0]._encode(Ue, bi || new Ae());
    var Ui = null;
    if (this.reporter = bi, mi.optional && Ue === void 0)
      if (mi.default !== null)
        Ue = mi.default;
      else
        return;
    var _i = null, $i = !1;
    if (mi.any)
      Ui = this._createEncoderBuffer(Ue);
    else if (mi.choice)
      Ui = this._encodeChoice(Ue, bi);
    else if (mi.contains)
      _i = this._getUse(mi.contains, vi)._encode(Ue, bi), $i = !0;
    else if (mi.children)
      _i = mi.children.map(function(Hi) {
        if (Hi._baseState.tag === "null_")
          return Hi._encode(null, bi, Ue);
        if (Hi._baseState.key === null)
          return bi.error("Child should have a key");
        var Zi = bi.enterKey(Hi._baseState.key);
        if (typeof Ue != "object")
          return bi.error("Child expected, but input is not object");
        var Qi = Hi._encode(Ue[Hi._baseState.key], bi, Ue);
        return bi.leaveKey(Zi), Qi;
      }, this).filter(function(Hi) {
        return Hi;
      }), _i = this._createEncoderBuffer(_i);
    else if (mi.tag === "seqof" || mi.tag === "setof") {
      if (!(mi.args && mi.args.length === 1))
        return bi.error("Too many args for : " + mi.tag);
      if (!Array.isArray(Ue))
        return bi.error("seqof/setof, but data is not Array");
      var Ci = this.clone();
      Ci._baseState.implicit = null, _i = this._createEncoderBuffer(Ue.map(function(Hi) {
        var Zi = this._baseState;
        return this._getUse(Zi.args[0], Ue)._encode(Hi, bi);
      }, Ci));
    } else mi.use !== null ? Ui = this._getUse(mi.use, vi)._encode(Ue, bi) : (_i = this._encodePrimitive(mi.tag, Ue), $i = !0);
    var Ui;
    if (!mi.any && mi.choice === null) {
      var ki = mi.implicit !== null ? mi.implicit : mi.tag, Ji = mi.implicit === null ? "universal" : "context";
      ki === null ? mi.use === null && bi.error("Tag could be omitted only for .use()") : mi.use === null && (Ui = this._encodeComposite(ki, $i, Ji, _i));
    }
    return mi.explicit !== null && (Ui = this._encodeComposite(mi.explicit, !1, "context", Ui)), Ui;
  }, je.prototype._encodeChoice = function(Ue, bi) {
    var vi = this._baseState, mi = vi.choice[Ue.type];
    return mi || Ie(
      !1,
      Ue.type + " not found in " + JSON.stringify(Object.keys(vi.choice))
    ), mi._encode(Ue.value, bi);
  }, je.prototype._encodePrimitive = function(Ue, bi) {
    var vi = this._baseState;
    if (/str$/.test(Ue))
      return this._encodeStr(bi, Ue);
    if (Ue === "objid" && vi.args)
      return this._encodeObjid(bi, vi.reverseArgs[0], vi.args[1]);
    if (Ue === "objid")
      return this._encodeObjid(bi, null, null);
    if (Ue === "gentime" || Ue === "utctime")
      return this._encodeTime(bi, Ue);
    if (Ue === "null_")
      return this._encodeNull();
    if (Ue === "int" || Ue === "enum")
      return this._encodeInt(bi, vi.args && vi.reverseArgs[0]);
    if (Ue === "bool")
      return this._encodeBool(bi);
    if (Ue === "objDesc")
      return this._encodeStr(bi, Ue);
    throw new Error("Unsupported tag: " + Ue);
  }, je.prototype._isNumstr = function(Ue) {
    return /^[0-9 ]*$/.test(Ue);
  }, je.prototype._isPrintstr = function(Ue) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(Ue);
  }, node$1;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(Ae) {
    var t = Ae;
    t.Reporter = requireReporter().Reporter, t.DecoderBuffer = requireBuffer().DecoderBuffer, t.EncoderBuffer = requireBuffer().EncoderBuffer, t.Node = requireNode();
  }(base$3)), base$3;
}
var constants$1 = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(Ae) {
    var t = requireConstants$1();
    Ae.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, Ae.tagClassByName = t._reverse(Ae.tagClass), Ae.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, Ae.tagByName = t._reverse(Ae.tag);
  }(der)), der;
}
var hasRequiredConstants$1;
function requireConstants$1() {
  return hasRequiredConstants$1 || (hasRequiredConstants$1 = 1, function(Ae) {
    var t = Ae;
    t._reverse = function(Ie) {
      var Pe = {};
      return Object.keys(Ie).forEach(function(Be) {
        (Be | 0) == Be && (Be = Be | 0);
        var Te = Ie[Be];
        Pe[Te] = Be;
      }), Pe;
    }, t.der = requireDer$2();
  }(constants$1)), constants$1;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var Ae = inherits_browserExports, t = requireAsn1$1(), Me = t.base, Ie = t.bignum, Pe = t.constants.der;
  function Be(fi) {
    this.enc = "der", this.name = fi.name, this.entity = fi, this.tree = new Te(), this.tree._init(fi.body);
  }
  der_1$1 = Be, Be.prototype.decode = function(Ue, bi) {
    return Ue instanceof Me.DecoderBuffer || (Ue = new Me.DecoderBuffer(Ue, bi)), this.tree._decode(Ue, bi);
  };
  function Te(fi) {
    Me.Node.call(this, "der", fi);
  }
  Ae(Te, Me.Node), Te.prototype._peekTag = function(Ue, bi, vi) {
    if (Ue.isEmpty())
      return !1;
    var mi = Ue.save(), _i = je(Ue, 'Failed to peek tag: "' + bi + '"');
    return Ue.isError(_i) ? _i : (Ue.restore(mi), _i.tag === bi || _i.tagStr === bi || _i.tagStr + "of" === bi || vi);
  }, Te.prototype._decodeTag = function(Ue, bi, vi) {
    var mi = je(
      Ue,
      'Failed to decode tag of "' + bi + '"'
    );
    if (Ue.isError(mi))
      return mi;
    var _i = Ve(
      Ue,
      mi.primitive,
      'Failed to get length of "' + bi + '"'
    );
    if (Ue.isError(_i))
      return _i;
    if (!vi && mi.tag !== bi && mi.tagStr !== bi && mi.tagStr + "of" !== bi)
      return Ue.error('Failed to match tag: "' + bi + '"');
    if (mi.primitive || _i !== null)
      return Ue.skip(_i, 'Failed to match body of: "' + bi + '"');
    var $i = Ue.save(), Ci = this._skipUntilEnd(
      Ue,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return Ue.isError(Ci) ? Ci : (_i = Ue.offset - $i.offset, Ue.restore($i), Ue.skip(_i, 'Failed to match body of: "' + bi + '"'));
  }, Te.prototype._skipUntilEnd = function(Ue, bi) {
    for (; ; ) {
      var vi = je(Ue, bi);
      if (Ue.isError(vi))
        return vi;
      var mi = Ve(Ue, vi.primitive, bi);
      if (Ue.isError(mi))
        return mi;
      var _i;
      if (vi.primitive || mi !== null ? _i = Ue.skip(mi) : _i = this._skipUntilEnd(Ue, bi), Ue.isError(_i))
        return _i;
      if (vi.tagStr === "end")
        break;
    }
  }, Te.prototype._decodeList = function(Ue, bi, vi, mi) {
    for (var _i = []; !Ue.isEmpty(); ) {
      var $i = this._peekTag(Ue, "end");
      if (Ue.isError($i))
        return $i;
      var Ci = vi.decode(Ue, "der", mi);
      if (Ue.isError(Ci) && $i)
        break;
      _i.push(Ci);
    }
    return _i;
  }, Te.prototype._decodeStr = function(Ue, bi) {
    if (bi === "bitstr") {
      var vi = Ue.readUInt8();
      return Ue.isError(vi) ? vi : { unused: vi, data: Ue.raw() };
    } else if (bi === "bmpstr") {
      var mi = Ue.raw();
      if (mi.length % 2 === 1)
        return Ue.error("Decoding of string type: bmpstr length mismatch");
      for (var _i = "", $i = 0; $i < mi.length / 2; $i++)
        _i += String.fromCharCode(mi.readUInt16BE($i * 2));
      return _i;
    } else if (bi === "numstr") {
      var Ci = Ue.raw().toString("ascii");
      return this._isNumstr(Ci) ? Ci : Ue.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (bi === "octstr")
        return Ue.raw();
      if (bi === "objDesc")
        return Ue.raw();
      if (bi === "printstr") {
        var Ui = Ue.raw().toString("ascii");
        return this._isPrintstr(Ui) ? Ui : Ue.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(bi) ? Ue.raw().toString() : Ue.error("Decoding of string type: " + bi + " unsupported");
    }
  }, Te.prototype._decodeObjid = function(Ue, bi, vi) {
    for (var mi, _i = [], $i = 0; !Ue.isEmpty(); ) {
      var Ci = Ue.readUInt8();
      $i <<= 7, $i |= Ci & 127, Ci & 128 || (_i.push($i), $i = 0);
    }
    Ci & 128 && _i.push($i);
    var Ui = _i[0] / 40 | 0, ki = _i[0] % 40;
    if (vi ? mi = _i : mi = [Ui, ki].concat(_i.slice(1)), bi) {
      var Ji = bi[mi.join(" ")];
      Ji === void 0 && (Ji = bi[mi.join(".")]), Ji !== void 0 && (mi = Ji);
    }
    return mi;
  }, Te.prototype._decodeTime = function(Ue, bi) {
    var vi = Ue.raw().toString();
    if (bi === "gentime")
      var mi = vi.slice(0, 4) | 0, _i = vi.slice(4, 6) | 0, $i = vi.slice(6, 8) | 0, Ci = vi.slice(8, 10) | 0, Ui = vi.slice(10, 12) | 0, ki = vi.slice(12, 14) | 0;
    else if (bi === "utctime") {
      var mi = vi.slice(0, 2) | 0, _i = vi.slice(2, 4) | 0, $i = vi.slice(4, 6) | 0, Ci = vi.slice(6, 8) | 0, Ui = vi.slice(8, 10) | 0, ki = vi.slice(10, 12) | 0;
      mi < 70 ? mi = 2e3 + mi : mi = 1900 + mi;
    } else
      return Ue.error("Decoding " + bi + " time is not supported yet");
    return Date.UTC(mi, _i - 1, $i, Ci, Ui, ki, 0);
  }, Te.prototype._decodeNull = function(Ue) {
    return null;
  }, Te.prototype._decodeBool = function(Ue) {
    var bi = Ue.readUInt8();
    return Ue.isError(bi) ? bi : bi !== 0;
  }, Te.prototype._decodeInt = function(Ue, bi) {
    var vi = Ue.raw(), mi = new Ie(vi);
    return bi && (mi = bi[mi.toString(10)] || mi), mi;
  }, Te.prototype._use = function(Ue, bi) {
    return typeof Ue == "function" && (Ue = Ue(bi)), Ue._getDecoder("der").tree;
  };
  function je(fi, Ue) {
    var bi = fi.readUInt8(Ue);
    if (fi.isError(bi))
      return bi;
    var vi = Pe.tagClass[bi >> 6], mi = (bi & 32) === 0;
    if ((bi & 31) === 31) {
      var _i = bi;
      for (bi = 0; (_i & 128) === 128; ) {
        if (_i = fi.readUInt8(Ue), fi.isError(_i))
          return _i;
        bi <<= 7, bi |= _i & 127;
      }
    } else
      bi &= 31;
    var $i = Pe.tag[bi];
    return {
      cls: vi,
      primitive: mi,
      tag: bi,
      tagStr: $i
    };
  }
  function Ve(fi, Ue, bi) {
    var vi = fi.readUInt8(bi);
    if (fi.isError(vi))
      return vi;
    if (!Ue && vi === 128)
      return null;
    if (!(vi & 128))
      return vi;
    var mi = vi & 127;
    if (mi > 4)
      return fi.error("length octect is too long");
    vi = 0;
    for (var _i = 0; _i < mi; _i++) {
      vi <<= 8;
      var $i = fi.readUInt8(bi);
      if (fi.isError($i))
        return $i;
      vi |= $i;
    }
    return vi;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var Ae = inherits_browserExports, t = require$$0$3.Buffer, Me = requireDer$1();
  function Ie(Pe) {
    Me.call(this, Pe), this.enc = "pem";
  }
  return Ae(Ie, Me), pem$1 = Ie, Ie.prototype.decode = function(Be, Te) {
    for (var je = Be.toString().split(/[\r\n]+/g), Ve = Te.label.toUpperCase(), fi = /^-----(BEGIN|END) ([^-]+)-----$/, Ue = -1, bi = -1, vi = 0; vi < je.length; vi++) {
      var mi = je[vi].match(fi);
      if (mi !== null && mi[2] === Ve)
        if (Ue === -1) {
          if (mi[1] !== "BEGIN")
            break;
          Ue = vi;
        } else {
          if (mi[1] !== "END")
            break;
          bi = vi;
          break;
        }
    }
    if (Ue === -1 || bi === -1)
      throw new Error("PEM section not found for: " + Ve);
    var _i = je.slice(Ue + 1, bi).join("");
    _i.replace(/[^a-z0-9\+\/=]+/gi, "");
    var $i = new t(_i, "base64");
    return Me.prototype.decode.call(this, $i, Te);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(Ae) {
    var t = Ae;
    t.der = requireDer$1(), t.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var Ae = inherits_browserExports, t = require$$0$3.Buffer, Me = requireAsn1$1(), Ie = Me.base, Pe = Me.constants.der;
  function Be(fi) {
    this.enc = "der", this.name = fi.name, this.entity = fi, this.tree = new Te(), this.tree._init(fi.body);
  }
  der_1 = Be, Be.prototype.encode = function(Ue, bi) {
    return this.tree._encode(Ue, bi).join();
  };
  function Te(fi) {
    Ie.Node.call(this, "der", fi);
  }
  Ae(Te, Ie.Node), Te.prototype._encodeComposite = function(Ue, bi, vi, mi) {
    var _i = Ve(Ue, bi, vi, this.reporter);
    if (mi.length < 128) {
      var Ui = new t(2);
      return Ui[0] = _i, Ui[1] = mi.length, this._createEncoderBuffer([Ui, mi]);
    }
    for (var $i = 1, Ci = mi.length; Ci >= 256; Ci >>= 8)
      $i++;
    var Ui = new t(2 + $i);
    Ui[0] = _i, Ui[1] = 128 | $i;
    for (var Ci = 1 + $i, ki = mi.length; ki > 0; Ci--, ki >>= 8)
      Ui[Ci] = ki & 255;
    return this._createEncoderBuffer([Ui, mi]);
  }, Te.prototype._encodeStr = function(Ue, bi) {
    if (bi === "bitstr")
      return this._createEncoderBuffer([Ue.unused | 0, Ue.data]);
    if (bi === "bmpstr") {
      for (var vi = new t(Ue.length * 2), mi = 0; mi < Ue.length; mi++)
        vi.writeUInt16BE(Ue.charCodeAt(mi), mi * 2);
      return this._createEncoderBuffer(vi);
    } else return bi === "numstr" ? this._isNumstr(Ue) ? this._createEncoderBuffer(Ue) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : bi === "printstr" ? this._isPrintstr(Ue) ? this._createEncoderBuffer(Ue) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(bi) ? this._createEncoderBuffer(Ue) : bi === "objDesc" ? this._createEncoderBuffer(Ue) : this.reporter.error("Encoding of string type: " + bi + " unsupported");
  }, Te.prototype._encodeObjid = function(Ue, bi, vi) {
    if (typeof Ue == "string") {
      if (!bi)
        return this.reporter.error("string objid given, but no values map found");
      if (!bi.hasOwnProperty(Ue))
        return this.reporter.error("objid not found in values map");
      Ue = bi[Ue].split(/[\s\.]+/g);
      for (var mi = 0; mi < Ue.length; mi++)
        Ue[mi] |= 0;
    } else if (Array.isArray(Ue)) {
      Ue = Ue.slice();
      for (var mi = 0; mi < Ue.length; mi++)
        Ue[mi] |= 0;
    }
    if (!Array.isArray(Ue))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(Ue));
    if (!vi) {
      if (Ue[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      Ue.splice(0, 2, Ue[0] * 40 + Ue[1]);
    }
    for (var _i = 0, mi = 0; mi < Ue.length; mi++) {
      var $i = Ue[mi];
      for (_i++; $i >= 128; $i >>= 7)
        _i++;
    }
    for (var Ci = new t(_i), Ui = Ci.length - 1, mi = Ue.length - 1; mi >= 0; mi--) {
      var $i = Ue[mi];
      for (Ci[Ui--] = $i & 127; ($i >>= 7) > 0; )
        Ci[Ui--] = 128 | $i & 127;
    }
    return this._createEncoderBuffer(Ci);
  };
  function je(fi) {
    return fi < 10 ? "0" + fi : fi;
  }
  Te.prototype._encodeTime = function(Ue, bi) {
    var vi, mi = new Date(Ue);
    return bi === "gentime" ? vi = [
      je(mi.getFullYear()),
      je(mi.getUTCMonth() + 1),
      je(mi.getUTCDate()),
      je(mi.getUTCHours()),
      je(mi.getUTCMinutes()),
      je(mi.getUTCSeconds()),
      "Z"
    ].join("") : bi === "utctime" ? vi = [
      je(mi.getFullYear() % 100),
      je(mi.getUTCMonth() + 1),
      je(mi.getUTCDate()),
      je(mi.getUTCHours()),
      je(mi.getUTCMinutes()),
      je(mi.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + bi + " time is not supported yet"), this._encodeStr(vi, "octstr");
  }, Te.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, Te.prototype._encodeInt = function(Ue, bi) {
    if (typeof Ue == "string") {
      if (!bi)
        return this.reporter.error("String int or enum given, but no values map");
      if (!bi.hasOwnProperty(Ue))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(Ue));
      Ue = bi[Ue];
    }
    if (typeof Ue != "number" && !t.isBuffer(Ue)) {
      var vi = Ue.toArray();
      !Ue.sign && vi[0] & 128 && vi.unshift(0), Ue = new t(vi);
    }
    if (t.isBuffer(Ue)) {
      var mi = Ue.length;
      Ue.length === 0 && mi++;
      var $i = new t(mi);
      return Ue.copy($i), Ue.length === 0 && ($i[0] = 0), this._createEncoderBuffer($i);
    }
    if (Ue < 128)
      return this._createEncoderBuffer(Ue);
    if (Ue < 256)
      return this._createEncoderBuffer([0, Ue]);
    for (var mi = 1, _i = Ue; _i >= 256; _i >>= 8)
      mi++;
    for (var $i = new Array(mi), _i = $i.length - 1; _i >= 0; _i--)
      $i[_i] = Ue & 255, Ue >>= 8;
    return $i[0] & 128 && $i.unshift(0), this._createEncoderBuffer(new t($i));
  }, Te.prototype._encodeBool = function(Ue) {
    return this._createEncoderBuffer(Ue ? 255 : 0);
  }, Te.prototype._use = function(Ue, bi) {
    return typeof Ue == "function" && (Ue = Ue(bi)), Ue._getEncoder("der").tree;
  }, Te.prototype._skipDefault = function(Ue, bi, vi) {
    var mi = this._baseState, _i;
    if (mi.default === null)
      return !1;
    var $i = Ue.join();
    if (mi.defaultBuffer === void 0 && (mi.defaultBuffer = this._encodeValue(mi.default, bi, vi).join()), $i.length !== mi.defaultBuffer.length)
      return !1;
    for (_i = 0; _i < $i.length; _i++)
      if ($i[_i] !== mi.defaultBuffer[_i])
        return !1;
    return !0;
  };
  function Ve(fi, Ue, bi, vi) {
    var mi;
    if (fi === "seqof" ? fi = "seq" : fi === "setof" && (fi = "set"), Pe.tagByName.hasOwnProperty(fi))
      mi = Pe.tagByName[fi];
    else if (typeof fi == "number" && (fi | 0) === fi)
      mi = fi;
    else
      return vi.error("Unknown tag: " + fi);
    return mi >= 31 ? vi.error("Multi-octet tag encoding unsupported") : (Ue || (mi |= 32), mi |= Pe.tagClassByName[bi || "universal"] << 6, mi);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var Ae = inherits_browserExports, t = requireDer();
  function Me(Ie) {
    t.call(this, Ie), this.enc = "pem";
  }
  return Ae(Me, t), pem = Me, Me.prototype.encode = function(Pe, Be) {
    for (var Te = t.prototype.encode.call(this, Pe), je = Te.toString("base64"), Ve = ["-----BEGIN " + Be.label + "-----"], fi = 0; fi < je.length; fi += 64)
      Ve.push(je.slice(fi, fi + 64));
    return Ve.push("-----END " + Be.label + "-----"), Ve.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(Ae) {
    var t = Ae;
    t.der = requireDer(), t.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
  return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, function(Ae) {
    var t = Ae;
    t.bignum = bnExports, t.define = requireApi().define, t.base = requireBase(), t.constants = requireConstants$1(), t.decoders = requireDecoders(), t.encoders = requireEncoders();
  }(asn1)), asn1;
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate) return certificate;
  hasRequiredCertificate = 1;
  var Ae = requireAsn1$1(), t = Ae.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), Me = Ae.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), Ie = Ae.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), Pe = Ae.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(Ie),
      this.key("subjectPublicKey").bitstr()
    );
  }), Be = Ae.define("RelativeDistinguishedName", function() {
    this.setof(Me);
  }), Te = Ae.define("RDNSequence", function() {
    this.seqof(Be);
  }), je = Ae.define("Name", function() {
    this.choice({
      rdnSequence: this.use(Te)
    });
  }), Ve = Ae.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(t),
      this.key("notAfter").use(t)
    );
  }), fi = Ae.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), Ue = Ae.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(Ie),
      this.key("issuer").use(je),
      this.key("validity").use(Ve),
      this.key("subject").use(je),
      this.key("subjectPublicKeyInfo").use(Pe),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(fi).optional()
    );
  }), bi = Ae.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(Ue),
      this.key("signatureAlgorithm").use(Ie),
      this.key("signatureValue").bitstr()
    );
  });
  return certificate = bi, certificate;
}
var hasRequiredAsn1;
function requireAsn1() {
  if (hasRequiredAsn1) return asn1$1;
  hasRequiredAsn1 = 1;
  var Ae = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var t = Ae.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  asn1$1.RSAPrivateKey = t;
  var Me = Ae.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  asn1$1.RSAPublicKey = Me;
  var Ie = Ae.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), Pe = Ae.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(Ie),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1.PublicKey = Pe;
  var Be = Ae.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(Ie),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.PrivateKey = Be;
  var Te = Ae.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.EncryptedPrivateKey = Te;
  var je = Ae.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  asn1$1.DSAPrivateKey = je, asn1$1.DSAparam = Ae.define("DSAparam", function() {
    this.int();
  });
  var Ve = Ae.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  }), fi = Ae.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(Ve),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  return asn1$1.ECPrivateKey = fi, asn1$1.signature = Ae.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), asn1$1;
}
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
  if (hasRequiredFixProc) return fixProc;
  hasRequiredFixProc = 1;
  var Ae = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, t = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, Me = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, Ie = requireEvp_bytestokey(), Pe = requireBrowser$6(), Be = requireSafeBuffer$1().Buffer;
  return fixProc = function(Te, je) {
    var Ve = Te.toString(), fi = Ve.match(Ae), Ue;
    if (fi) {
      var vi = "aes" + fi[1], mi = Be.from(fi[2], "hex"), _i = Be.from(fi[3].replace(/[\r\n]/g, ""), "base64"), $i = Ie(je, mi.slice(0, 8), parseInt(fi[1], 10)).key, Ci = [], Ui = Pe.createDecipheriv(vi, $i, mi);
      Ci.push(Ui.update(_i)), Ci.push(Ui.final()), Ue = Be.concat(Ci);
    } else {
      var bi = Ve.match(Me);
      Ue = Be.from(bi[2].replace(/[\r\n]/g, ""), "base64");
    }
    var ki = Ve.match(t)[1];
    return {
      tag: ki,
      data: Ue
    };
  }, fixProc;
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
  if (hasRequiredParseAsn1) return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var Ae = requireAsn1(), t = require$$1, Me = requireFixProc(), Ie = requireBrowser$6(), Pe = requireBrowser$7(), Be = requireSafeBuffer$1().Buffer;
  function Te(Ve, fi) {
    var Ue = Ve.algorithm.decrypt.kde.kdeparams.salt, bi = parseInt(Ve.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), vi = t[Ve.algorithm.decrypt.cipher.algo.join(".")], mi = Ve.algorithm.decrypt.cipher.iv, _i = Ve.subjectPrivateKey, $i = parseInt(vi.split("-")[1], 10) / 8, Ci = Pe.pbkdf2Sync(fi, Ue, bi, $i, "sha1"), Ui = Ie.createDecipheriv(vi, Ci, mi), ki = [];
    return ki.push(Ui.update(_i)), ki.push(Ui.final()), Be.concat(ki);
  }
  function je(Ve) {
    var fi;
    typeof Ve == "object" && !Be.isBuffer(Ve) && (fi = Ve.passphrase, Ve = Ve.key), typeof Ve == "string" && (Ve = Be.from(Ve));
    var Ue = Me(Ve, fi), bi = Ue.tag, vi = Ue.data, mi, _i;
    switch (bi) {
      case "CERTIFICATE":
        _i = Ae.certificate.decode(vi, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (_i || (_i = Ae.PublicKey.decode(vi, "der")), mi = _i.algorithm.algorithm.join("."), mi) {
          case "1.2.840.113549.1.1.1":
            return Ae.RSAPublicKey.decode(_i.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return _i.subjectPrivateKey = _i.subjectPublicKey, {
              type: "ec",
              data: _i
            };
          case "1.2.840.10040.4.1":
            return _i.algorithm.params.pub_key = Ae.DSAparam.decode(_i.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: _i.algorithm.params
            };
          default:
            throw new Error("unknown key id " + mi);
        }
      case "ENCRYPTED PRIVATE KEY":
        vi = Ae.EncryptedPrivateKey.decode(vi, "der"), vi = Te(vi, fi);
      case "PRIVATE KEY":
        switch (_i = Ae.PrivateKey.decode(vi, "der"), mi = _i.algorithm.algorithm.join("."), mi) {
          case "1.2.840.113549.1.1.1":
            return Ae.RSAPrivateKey.decode(_i.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: _i.algorithm.curve,
              privateKey: Ae.ECPrivateKey.decode(_i.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return _i.algorithm.params.priv_key = Ae.DSAparam.decode(_i.subjectPrivateKey, "der"), {
              type: "dsa",
              params: _i.algorithm.params
            };
          default:
            throw new Error("unknown key id " + mi);
        }
      case "RSA PUBLIC KEY":
        return Ae.RSAPublicKey.decode(vi, "der");
      case "RSA PRIVATE KEY":
        return Ae.RSAPrivateKey.decode(vi, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: Ae.DSAPrivateKey.decode(vi, "der")
        };
      case "EC PRIVATE KEY":
        return vi = Ae.ECPrivateKey.decode(vi, "der"), {
          curve: vi.parameters.value,
          privateKey: vi.privateKey
        };
      default:
        throw new Error("unknown key type " + bi);
    }
  }
  return je.signature = Ae.signature, parseAsn1 = je, parseAsn1;
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requireBrowser$8(), Me = requireBrowserifyRsa(), Ie = requireElliptic().ec, Pe = bnExports$1, Be = requireParseAsn1(), Te = require$$4, je = 1;
  function Ve(Ui, ki, Ji, Hi, Zi) {
    var Qi = Be(ki);
    if (Qi.curve) {
      if (Hi !== "ecdsa" && Hi !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return fi(Ui, Qi);
    } else if (Qi.type === "dsa") {
      if (Hi !== "dsa")
        throw new Error("wrong private key type");
      return Ue(Ui, Qi, Ji);
    }
    if (Hi !== "rsa" && Hi !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (ki.padding !== void 0 && ki.padding !== je)
      throw new Error("illegal or unsupported padding mode");
    Ui = Ae.concat([Zi, Ui]);
    for (var Bi = Qi.modulus.byteLength(), Xi = [0, 1]; Ui.length + Xi.length + 1 < Bi; )
      Xi.push(255);
    Xi.push(0);
    for (var ns = -1; ++ns < Ui.length; )
      Xi.push(Ui[ns]);
    var ls = Me(Xi, Qi);
    return ls;
  }
  function fi(Ui, ki) {
    var Ji = Te[ki.curve.join(".")];
    if (!Ji)
      throw new Error("unknown curve " + ki.curve.join("."));
    var Hi = new Ie(Ji), Zi = Hi.keyFromPrivate(ki.privateKey), Qi = Zi.sign(Ui);
    return Ae.from(Qi.toDER());
  }
  function Ue(Ui, ki, Ji) {
    for (var Hi = ki.params.priv_key, Zi = ki.params.p, Qi = ki.params.q, Bi = ki.params.g, Xi = new Pe(0), ns, ls = mi(Ui, Qi).mod(Qi), vn = !1, Mi = vi(Hi, Qi, Ui, Ji); vn === !1; )
      ns = $i(Qi, Mi, Ji), Xi = Ci(Bi, ns, Zi, Qi), vn = ns.invm(Qi).imul(ls.add(Hi.mul(Xi))).mod(Qi), vn.cmpn(0) === 0 && (vn = !1, Xi = new Pe(0));
    return bi(Xi, vn);
  }
  function bi(Ui, ki) {
    Ui = Ui.toArray(), ki = ki.toArray(), Ui[0] & 128 && (Ui = [0].concat(Ui)), ki[0] & 128 && (ki = [0].concat(ki));
    var Ji = Ui.length + ki.length + 4, Hi = [
      48,
      Ji,
      2,
      Ui.length
    ];
    return Hi = Hi.concat(Ui, [2, ki.length], ki), Ae.from(Hi);
  }
  function vi(Ui, ki, Ji, Hi) {
    if (Ui = Ae.from(Ui.toArray()), Ui.length < ki.byteLength()) {
      var Zi = Ae.alloc(ki.byteLength() - Ui.length);
      Ui = Ae.concat([Zi, Ui]);
    }
    var Qi = Ji.length, Bi = _i(Ji, ki), Xi = Ae.alloc(Qi);
    Xi.fill(1);
    var ns = Ae.alloc(Qi);
    return ns = t(Hi, ns).update(Xi).update(Ae.from([0])).update(Ui).update(Bi).digest(), Xi = t(Hi, ns).update(Xi).digest(), ns = t(Hi, ns).update(Xi).update(Ae.from([1])).update(Ui).update(Bi).digest(), Xi = t(Hi, ns).update(Xi).digest(), { k: ns, v: Xi };
  }
  function mi(Ui, ki) {
    var Ji = new Pe(Ui), Hi = (Ui.length << 3) - ki.bitLength();
    return Hi > 0 && Ji.ishrn(Hi), Ji;
  }
  function _i(Ui, ki) {
    Ui = mi(Ui, ki), Ui = Ui.mod(ki);
    var Ji = Ae.from(Ui.toArray());
    if (Ji.length < ki.byteLength()) {
      var Hi = Ae.alloc(ki.byteLength() - Ji.length);
      Ji = Ae.concat([Hi, Ji]);
    }
    return Ji;
  }
  function $i(Ui, ki, Ji) {
    var Hi, Zi;
    do {
      for (Hi = Ae.alloc(0); Hi.length * 8 < Ui.bitLength(); )
        ki.v = t(Ji, ki.k).update(ki.v).digest(), Hi = Ae.concat([Hi, ki.v]);
      Zi = mi(Hi, Ui), ki.k = t(Ji, ki.k).update(ki.v).update(Ae.from([0])).digest(), ki.v = t(Ji, ki.k).update(ki.v).digest();
    } while (Zi.cmp(Ui) !== -1);
    return Zi;
  }
  function Ci(Ui, ki, Ji, Hi) {
    return Ui.toRed(Pe.mont(Ji)).redPow(ki).fromRed().mod(Hi);
  }
  return sign.exports = Ve, sign.exports.getKey = vi, sign.exports.makeKey = $i, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = bnExports$1, Me = requireElliptic().ec, Ie = requireParseAsn1(), Pe = require$$4;
  function Be(fi, Ue, bi, vi, mi) {
    var _i = Ie(bi);
    if (_i.type === "ec") {
      if (vi !== "ecdsa" && vi !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return Te(fi, Ue, _i);
    } else if (_i.type === "dsa") {
      if (vi !== "dsa")
        throw new Error("wrong public key type");
      return je(fi, Ue, _i);
    }
    if (vi !== "rsa" && vi !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    Ue = Ae.concat([mi, Ue]);
    for (var $i = _i.modulus.byteLength(), Ci = [1], Ui = 0; Ue.length + Ci.length + 2 < $i; )
      Ci.push(255), Ui += 1;
    Ci.push(0);
    for (var ki = -1; ++ki < Ue.length; )
      Ci.push(Ue[ki]);
    Ci = Ae.from(Ci);
    var Ji = t.mont(_i.modulus);
    fi = new t(fi).toRed(Ji), fi = fi.redPow(new t(_i.publicExponent)), fi = Ae.from(fi.fromRed().toArray());
    var Hi = Ui < 8 ? 1 : 0;
    for ($i = Math.min(fi.length, Ci.length), fi.length !== Ci.length && (Hi = 1), ki = -1; ++ki < $i; )
      Hi |= fi[ki] ^ Ci[ki];
    return Hi === 0;
  }
  function Te(fi, Ue, bi) {
    var vi = Pe[bi.data.algorithm.curve.join(".")];
    if (!vi)
      throw new Error("unknown curve " + bi.data.algorithm.curve.join("."));
    var mi = new Me(vi), _i = bi.data.subjectPrivateKey.data;
    return mi.verify(Ue, fi, _i);
  }
  function je(fi, Ue, bi) {
    var vi = bi.data.p, mi = bi.data.q, _i = bi.data.g, $i = bi.data.pub_key, Ci = Ie.signature.decode(fi, "der"), Ui = Ci.s, ki = Ci.r;
    Ve(Ui, mi), Ve(ki, mi);
    var Ji = t.mont(vi), Hi = Ui.invm(mi), Zi = _i.toRed(Ji).redPow(new t(Ue).mul(Hi).mod(mi)).fromRed().mul($i.toRed(Ji).redPow(ki.mul(Hi).mod(mi)).fromRed()).mod(vi).mod(mi);
    return Zi.cmp(ki) === 0;
  }
  function Ve(fi, Ue) {
    if (fi.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (fi.cmp(Ue) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = Be, verify_1;
}
var browser$6, hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3) return browser$6;
  hasRequiredBrowser$3 = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requireBrowser$9(), Me = requireReadableBrowser(), Ie = inherits_browserExports, Pe = requireSign(), Be = requireVerify(), Te = require$$6;
  Object.keys(Te).forEach(function(bi) {
    Te[bi].id = Ae.from(Te[bi].id, "hex"), Te[bi.toLowerCase()] = Te[bi];
  });
  function je(bi) {
    Me.Writable.call(this);
    var vi = Te[bi];
    if (!vi)
      throw new Error("Unknown message digest");
    this._hashType = vi.hash, this._hash = t(vi.hash), this._tag = vi.id, this._signType = vi.sign;
  }
  Ie(je, Me.Writable), je.prototype._write = function(vi, mi, _i) {
    this._hash.update(vi), _i();
  }, je.prototype.update = function(vi, mi) {
    return this._hash.update(typeof vi == "string" ? Ae.from(vi, mi) : vi), this;
  }, je.prototype.sign = function(vi, mi) {
    this.end();
    var _i = this._hash.digest(), $i = Pe(_i, vi, this._hashType, this._signType, this._tag);
    return mi ? $i.toString(mi) : $i;
  };
  function Ve(bi) {
    Me.Writable.call(this);
    var vi = Te[bi];
    if (!vi)
      throw new Error("Unknown message digest");
    this._hash = t(vi.hash), this._tag = vi.id, this._signType = vi.sign;
  }
  Ie(Ve, Me.Writable), Ve.prototype._write = function(vi, mi, _i) {
    this._hash.update(vi), _i();
  }, Ve.prototype.update = function(vi, mi) {
    return this._hash.update(typeof vi == "string" ? Ae.from(vi, mi) : vi), this;
  }, Ve.prototype.verify = function(vi, mi, _i) {
    var $i = typeof mi == "string" ? Ae.from(mi, _i) : mi;
    this.end();
    var Ci = this._hash.digest();
    return Be($i, Ci, vi, this._signType, this._tag);
  };
  function fi(bi) {
    return new je(bi);
  }
  function Ue(bi) {
    return new Ve(bi);
  }
  return browser$6 = {
    Sign: fi,
    Verify: Ue,
    createSign: fi,
    createVerify: Ue
  }, browser$6;
}
var browser$5, hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$5;
  hasRequiredBrowser$2 = 1;
  var Ae = requireElliptic(), t = bnExports;
  browser$5 = function(Te) {
    return new Ie(Te);
  };
  var Me = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  Me.p224 = Me.secp224r1, Me.p256 = Me.secp256r1 = Me.prime256v1, Me.p192 = Me.secp192r1 = Me.prime192v1, Me.p384 = Me.secp384r1, Me.p521 = Me.secp521r1;
  function Ie(Be) {
    this.curveType = Me[Be], this.curveType || (this.curveType = {
      name: Be
    }), this.curve = new Ae.ec(this.curveType.name), this.keys = void 0;
  }
  Ie.prototype.generateKeys = function(Be, Te) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(Be, Te);
  }, Ie.prototype.computeSecret = function(Be, Te, je) {
    Te = Te || "utf8", Buffer$1.isBuffer(Be) || (Be = new Buffer$1(Be, Te));
    var Ve = this.curve.keyFromPublic(Be).getPublic(), fi = Ve.mul(this.keys.getPrivate()).getX();
    return Pe(fi, je, this.curveType.byteLength);
  }, Ie.prototype.getPublicKey = function(Be, Te) {
    var je = this.keys.getPublic(Te === "compressed", !0);
    return Te === "hybrid" && (je[je.length - 1] % 2 ? je[0] = 7 : je[0] = 6), Pe(je, Be);
  }, Ie.prototype.getPrivateKey = function(Be) {
    return Pe(this.keys.getPrivate(), Be);
  }, Ie.prototype.setPublicKey = function(Be, Te) {
    return Te = Te || "utf8", Buffer$1.isBuffer(Be) || (Be = new Buffer$1(Be, Te)), this.keys._importPublic(Be), this;
  }, Ie.prototype.setPrivateKey = function(Be, Te) {
    Te = Te || "utf8", Buffer$1.isBuffer(Be) || (Be = new Buffer$1(Be, Te));
    var je = new t(Be);
    return je = je.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(je), this;
  };
  function Pe(Be, Te, je) {
    Array.isArray(Be) || (Be = Be.toArray());
    var Ve = new Buffer$1(Be);
    if (je && Ve.length < je) {
      var fi = new Buffer$1(je - Ve.length);
      fi.fill(0), Ve = Buffer$1.concat([fi, Ve]);
    }
    return Te ? Ve.toString(Te) : Ve;
  }
  return browser$5;
}
var browser$4 = {}, mgf, hasRequiredMgf;
function requireMgf() {
  if (hasRequiredMgf) return mgf;
  hasRequiredMgf = 1;
  var Ae = requireBrowser$9(), t = requireSafeBuffer$1().Buffer;
  mgf = function(Ie, Pe) {
    for (var Be = t.alloc(0), Te = 0, je; Be.length < Pe; )
      je = Me(Te++), Be = t.concat([Be, Ae("sha1").update(Ie).update(je).digest()]);
    return Be.slice(0, Pe);
  };
  function Me(Ie) {
    var Pe = t.allocUnsafe(4);
    return Pe.writeUInt32BE(Ie, 0), Pe;
  }
  return mgf;
}
var xor, hasRequiredXor;
function requireXor() {
  return hasRequiredXor || (hasRequiredXor = 1, xor = function(t, Me) {
    for (var Ie = t.length, Pe = -1; ++Pe < Ie; )
      t[Pe] ^= Me[Pe];
    return t;
  }), xor;
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
  if (hasRequiredWithPublic) return withPublic_1;
  hasRequiredWithPublic = 1;
  var Ae = bnExports, t = requireSafeBuffer$1().Buffer;
  function Me(Ie, Pe) {
    return t.from(Ie.toRed(Ae.mont(Pe.modulus)).redPow(new Ae(Pe.publicExponent)).fromRed().toArray());
  }
  return withPublic_1 = Me, withPublic_1;
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt) return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var Ae = requireParseAsn1(), t = requireBrowser$b(), Me = requireBrowser$9(), Ie = requireMgf(), Pe = requireXor(), Be = bnExports, Te = requireWithPublic(), je = requireBrowserifyRsa(), Ve = requireSafeBuffer$1().Buffer;
  publicEncrypt = function(mi, _i, $i) {
    var Ci;
    mi.padding ? Ci = mi.padding : $i ? Ci = 1 : Ci = 4;
    var Ui = Ae(mi), ki;
    if (Ci === 4)
      ki = fi(Ui, _i);
    else if (Ci === 1)
      ki = Ue(Ui, _i, $i);
    else if (Ci === 3) {
      if (ki = new Be(_i), ki.cmp(Ui.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return $i ? je(ki, Ui) : Te(ki, Ui);
  };
  function fi(vi, mi) {
    var _i = vi.modulus.byteLength(), $i = mi.length, Ci = Me("sha1").update(Ve.alloc(0)).digest(), Ui = Ci.length, ki = 2 * Ui;
    if ($i > _i - ki - 2)
      throw new Error("message too long");
    var Ji = Ve.alloc(_i - $i - ki - 2), Hi = _i - Ui - 1, Zi = t(Ui), Qi = Pe(Ve.concat([Ci, Ji, Ve.alloc(1, 1), mi], Hi), Ie(Zi, Hi)), Bi = Pe(Zi, Ie(Qi, Ui));
    return new Be(Ve.concat([Ve.alloc(1), Bi, Qi], _i));
  }
  function Ue(vi, mi, _i) {
    var $i = mi.length, Ci = vi.modulus.byteLength();
    if ($i > Ci - 11)
      throw new Error("message too long");
    var Ui;
    return _i ? Ui = Ve.alloc(Ci - $i - 3, 255) : Ui = bi(Ci - $i - 3), new Be(Ve.concat([Ve.from([0, _i ? 1 : 2]), Ui, Ve.alloc(1), mi], Ci));
  }
  function bi(vi) {
    for (var mi = Ve.allocUnsafe(vi), _i = 0, $i = t(vi * 2), Ci = 0, Ui; _i < vi; )
      Ci === $i.length && ($i = t(vi * 2), Ci = 0), Ui = $i[Ci++], Ui && (mi[_i++] = Ui);
    return mi;
  }
  return publicEncrypt;
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt) return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var Ae = requireParseAsn1(), t = requireMgf(), Me = requireXor(), Ie = bnExports, Pe = requireBrowserifyRsa(), Be = requireBrowser$9(), Te = requireWithPublic(), je = requireSafeBuffer$1().Buffer;
  privateDecrypt = function(vi, mi, _i) {
    var $i;
    vi.padding ? $i = vi.padding : _i ? $i = 1 : $i = 4;
    var Ci = Ae(vi), Ui = Ci.modulus.byteLength();
    if (mi.length > Ui || new Ie(mi).cmp(Ci.modulus) >= 0)
      throw new Error("decryption error");
    var ki;
    _i ? ki = Te(new Ie(mi), Ci) : ki = Pe(mi, Ci);
    var Ji = je.alloc(Ui - ki.length);
    if (ki = je.concat([Ji, ki], Ui), $i === 4)
      return Ve(Ci, ki);
    if ($i === 1)
      return fi(Ci, ki, _i);
    if ($i === 3)
      return ki;
    throw new Error("unknown padding");
  };
  function Ve(bi, vi) {
    var mi = bi.modulus.byteLength(), _i = Be("sha1").update(je.alloc(0)).digest(), $i = _i.length;
    if (vi[0] !== 0)
      throw new Error("decryption error");
    var Ci = vi.slice(1, $i + 1), Ui = vi.slice($i + 1), ki = Me(Ci, t(Ui, $i)), Ji = Me(Ui, t(ki, mi - $i - 1));
    if (Ue(_i, Ji.slice(0, $i)))
      throw new Error("decryption error");
    for (var Hi = $i; Ji[Hi] === 0; )
      Hi++;
    if (Ji[Hi++] !== 1)
      throw new Error("decryption error");
    return Ji.slice(Hi);
  }
  function fi(bi, vi, mi) {
    for (var _i = vi.slice(0, 2), $i = 2, Ci = 0; vi[$i++] !== 0; )
      if ($i >= vi.length) {
        Ci++;
        break;
      }
    var Ui = vi.slice(2, $i - 1);
    if ((_i.toString("hex") !== "0002" && !mi || _i.toString("hex") !== "0001" && mi) && Ci++, Ui.length < 8 && Ci++, Ci)
      throw new Error("decryption error");
    return vi.slice($i);
  }
  function Ue(bi, vi) {
    bi = je.from(bi), vi = je.from(vi);
    var mi = 0, _i = bi.length;
    bi.length !== vi.length && (mi++, _i = Math.min(bi.length, vi.length));
    for (var $i = -1; ++$i < _i; )
      mi += bi[$i] ^ vi[$i];
    return mi;
  }
  return privateDecrypt;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function(Ae) {
    Ae.publicEncrypt = requirePublicEncrypt(), Ae.privateDecrypt = requirePrivateDecrypt(), Ae.privateEncrypt = function(Me, Ie) {
      return Ae.publicEncrypt(Me, Ie, !0);
    }, Ae.publicDecrypt = function(Me, Ie) {
      return Ae.privateDecrypt(Me, Ie, !0);
    };
  }(browser$4)), browser$4;
}
var browser$3 = {}, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser$3;
  hasRequiredBrowser = 1;
  function Ae() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var t = requireSafeBuffer$1(), Me = requireBrowser$b(), Ie = t.Buffer, Pe = t.kMaxLength, Be = commonjsGlobal.crypto || commonjsGlobal.msCrypto, Te = Math.pow(2, 32) - 1;
  function je(vi, mi) {
    if (typeof vi != "number" || vi !== vi)
      throw new TypeError("offset must be a number");
    if (vi > Te || vi < 0)
      throw new TypeError("offset must be a uint32");
    if (vi > Pe || vi > mi)
      throw new RangeError("offset out of range");
  }
  function Ve(vi, mi, _i) {
    if (typeof vi != "number" || vi !== vi)
      throw new TypeError("size must be a number");
    if (vi > Te || vi < 0)
      throw new TypeError("size must be a uint32");
    if (vi + mi > _i || vi > Pe)
      throw new RangeError("buffer too small");
  }
  Be && Be.getRandomValues || !process$1.browser ? (browser$3.randomFill = fi, browser$3.randomFillSync = bi) : (browser$3.randomFill = Ae, browser$3.randomFillSync = Ae);
  function fi(vi, mi, _i, $i) {
    if (!Ie.isBuffer(vi) && !(vi instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof mi == "function")
      $i = mi, mi = 0, _i = vi.length;
    else if (typeof _i == "function")
      $i = _i, _i = vi.length - mi;
    else if (typeof $i != "function")
      throw new TypeError('"cb" argument must be a function');
    return je(mi, vi.length), Ve(_i, mi, vi.length), Ue(vi, mi, _i, $i);
  }
  function Ue(vi, mi, _i, $i) {
    if (process$1.browser) {
      var Ci = vi.buffer, Ui = new Uint8Array(Ci, mi, _i);
      if (Be.getRandomValues(Ui), $i) {
        process$1.nextTick(function() {
          $i(null, vi);
        });
        return;
      }
      return vi;
    }
    if ($i) {
      Me(_i, function(Ji, Hi) {
        if (Ji)
          return $i(Ji);
        Hi.copy(vi, mi), $i(null, vi);
      });
      return;
    }
    var ki = Me(_i);
    return ki.copy(vi, mi), vi;
  }
  function bi(vi, mi, _i) {
    if (typeof mi > "u" && (mi = 0), !Ie.isBuffer(vi) && !(vi instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return je(mi, vi.length), _i === void 0 && (_i = vi.length - mi), Ve(_i, mi, vi.length), Ue(vi, mi, _i);
  }
  return browser$3;
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$b(), cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
  var Ae = requireAlgos(), t = Object.keys(Ae), Me = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(t);
  cryptoBrowserify.getHashes = function() {
    return Me;
  };
  var Ie = requireBrowser$7();
  cryptoBrowserify.pbkdf2 = Ie.pbkdf2, cryptoBrowserify.pbkdf2Sync = Ie.pbkdf2Sync;
  var Pe = requireBrowser$5();
  cryptoBrowserify.Cipher = Pe.Cipher, cryptoBrowserify.createCipher = Pe.createCipher, cryptoBrowserify.Cipheriv = Pe.Cipheriv, cryptoBrowserify.createCipheriv = Pe.createCipheriv, cryptoBrowserify.Decipher = Pe.Decipher, cryptoBrowserify.createDecipher = Pe.createDecipher, cryptoBrowserify.Decipheriv = Pe.Decipheriv, cryptoBrowserify.createDecipheriv = Pe.createDecipheriv, cryptoBrowserify.getCiphers = Pe.getCiphers, cryptoBrowserify.listCiphers = Pe.listCiphers;
  var Be = requireBrowser$4();
  cryptoBrowserify.DiffieHellmanGroup = Be.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = Be.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = Be.getDiffieHellman, cryptoBrowserify.createDiffieHellman = Be.createDiffieHellman, cryptoBrowserify.DiffieHellman = Be.DiffieHellman;
  var Te = requireBrowser$3();
  cryptoBrowserify.createSign = Te.createSign, cryptoBrowserify.Sign = Te.Sign, cryptoBrowserify.createVerify = Te.createVerify, cryptoBrowserify.Verify = Te.Verify, cryptoBrowserify.createECDH = requireBrowser$2();
  var je = requireBrowser$1();
  cryptoBrowserify.publicEncrypt = je.publicEncrypt, cryptoBrowserify.privateEncrypt = je.privateEncrypt, cryptoBrowserify.publicDecrypt = je.publicDecrypt, cryptoBrowserify.privateDecrypt = je.privateDecrypt;
  var Ve = requireBrowser();
  return cryptoBrowserify.randomFill = Ve.randomFill, cryptoBrowserify.randomFillSync = Ve.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
var hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var Ae;
  brorand.exports = function(Pe) {
    return Ae || (Ae = new t(null)), Ae.generate(Pe);
  };
  function t(Ie) {
    this.rand = Ie;
  }
  if (brorand.exports.Rand = t, t.prototype.generate = function(Pe) {
    return this._rand(Pe);
  }, t.prototype._rand = function(Pe) {
    if (this.rand.getBytes)
      return this.rand.getBytes(Pe);
    for (var Be = new Uint8Array(Pe), Te = 0; Te < Be.length; Te++)
      Be[Te] = this.rand.getByte();
    return Be;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? t.prototype._rand = function(Pe) {
      var Be = new Uint8Array(Pe);
      return self.crypto.getRandomValues(Be), Be;
    } : self.msCrypto && self.msCrypto.getRandomValues ? t.prototype._rand = function(Pe) {
      var Be = new Uint8Array(Pe);
      return self.msCrypto.getRandomValues(Be), Be;
    } : typeof window == "object" && (t.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var Me = requireCryptoBrowserify();
      if (typeof Me.randomBytes != "function")
        throw new Error("Not supported");
      t.prototype._rand = function(Pe) {
        return Me.randomBytes(Pe);
      };
    } catch {
    }
  return brorand.exports;
}
var curve = {}, BN$7 = bnExports, utils$a = utils$d, getNAF$1 = utils$a.getNAF, getJSF$1 = utils$a.getJSF, assert$e = utils$a.assert;
function BaseCurve$1(Ae, t) {
  this.type = Ae, this.p = new BN$7(t.p, 16), this.red = t.prime ? BN$7.red(t.prime) : BN$7.mont(this.p), this.zero = new BN$7(0).toRed(this.red), this.one = new BN$7(1).toRed(this.red), this.two = new BN$7(2).toRed(this.red), this.n = t.n && new BN$7(t.n, 16), this.g = t.g && this.pointFromJSON(t.g, t.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var Me = this.n && this.p.div(this.n);
  !Me || Me.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$2 = BaseCurve$1;
BaseCurve$1.prototype.point = function Ae() {
  throw new Error("Not implemented");
};
BaseCurve$1.prototype.validate = function Ae() {
  throw new Error("Not implemented");
};
BaseCurve$1.prototype._fixedNafMul = function Ae(t, Me) {
  assert$e(t.precomputed);
  var Ie = t._getDoubles(), Pe = getNAF$1(Me, 1, this._bitLength), Be = (1 << Ie.step + 1) - (Ie.step % 2 === 0 ? 2 : 1);
  Be /= 3;
  var Te = [], je, Ve;
  for (je = 0; je < Pe.length; je += Ie.step) {
    Ve = 0;
    for (var fi = je + Ie.step - 1; fi >= je; fi--)
      Ve = (Ve << 1) + Pe[fi];
    Te.push(Ve);
  }
  for (var Ue = this.jpoint(null, null, null), bi = this.jpoint(null, null, null), vi = Be; vi > 0; vi--) {
    for (je = 0; je < Te.length; je++)
      Ve = Te[je], Ve === vi ? bi = bi.mixedAdd(Ie.points[je]) : Ve === -vi && (bi = bi.mixedAdd(Ie.points[je].neg()));
    Ue = Ue.add(bi);
  }
  return Ue.toP();
};
BaseCurve$1.prototype._wnafMul = function Ae(t, Me) {
  var Ie = 4, Pe = t._getNAFPoints(Ie);
  Ie = Pe.wnd;
  for (var Be = Pe.points, Te = getNAF$1(Me, Ie, this._bitLength), je = this.jpoint(null, null, null), Ve = Te.length - 1; Ve >= 0; Ve--) {
    for (var fi = 0; Ve >= 0 && Te[Ve] === 0; Ve--)
      fi++;
    if (Ve >= 0 && fi++, je = je.dblp(fi), Ve < 0)
      break;
    var Ue = Te[Ve];
    assert$e(Ue !== 0), t.type === "affine" ? Ue > 0 ? je = je.mixedAdd(Be[Ue - 1 >> 1]) : je = je.mixedAdd(Be[-Ue - 1 >> 1].neg()) : Ue > 0 ? je = je.add(Be[Ue - 1 >> 1]) : je = je.add(Be[-Ue - 1 >> 1].neg());
  }
  return t.type === "affine" ? je.toP() : je;
};
BaseCurve$1.prototype._wnafMulAdd = function Ae(t, Me, Ie, Pe, Be) {
  var Te = this._wnafT1, je = this._wnafT2, Ve = this._wnafT3, fi = 0, Ue, bi, vi;
  for (Ue = 0; Ue < Pe; Ue++) {
    vi = Me[Ue];
    var mi = vi._getNAFPoints(t);
    Te[Ue] = mi.wnd, je[Ue] = mi.points;
  }
  for (Ue = Pe - 1; Ue >= 1; Ue -= 2) {
    var _i = Ue - 1, $i = Ue;
    if (Te[_i] !== 1 || Te[$i] !== 1) {
      Ve[_i] = getNAF$1(Ie[_i], Te[_i], this._bitLength), Ve[$i] = getNAF$1(Ie[$i], Te[$i], this._bitLength), fi = Math.max(Ve[_i].length, fi), fi = Math.max(Ve[$i].length, fi);
      continue;
    }
    var Ci = [
      Me[_i],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      Me[$i]
      /* 7 */
    ];
    Me[_i].y.cmp(Me[$i].y) === 0 ? (Ci[1] = Me[_i].add(Me[$i]), Ci[2] = Me[_i].toJ().mixedAdd(Me[$i].neg())) : Me[_i].y.cmp(Me[$i].y.redNeg()) === 0 ? (Ci[1] = Me[_i].toJ().mixedAdd(Me[$i]), Ci[2] = Me[_i].add(Me[$i].neg())) : (Ci[1] = Me[_i].toJ().mixedAdd(Me[$i]), Ci[2] = Me[_i].toJ().mixedAdd(Me[$i].neg()));
    var Ui = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], ki = getJSF$1(Ie[_i], Ie[$i]);
    for (fi = Math.max(ki[0].length, fi), Ve[_i] = new Array(fi), Ve[$i] = new Array(fi), bi = 0; bi < fi; bi++) {
      var Ji = ki[0][bi] | 0, Hi = ki[1][bi] | 0;
      Ve[_i][bi] = Ui[(Ji + 1) * 3 + (Hi + 1)], Ve[$i][bi] = 0, je[_i] = Ci;
    }
  }
  var Zi = this.jpoint(null, null, null), Qi = this._wnafT4;
  for (Ue = fi; Ue >= 0; Ue--) {
    for (var Bi = 0; Ue >= 0; ) {
      var Xi = !0;
      for (bi = 0; bi < Pe; bi++)
        Qi[bi] = Ve[bi][Ue] | 0, Qi[bi] !== 0 && (Xi = !1);
      if (!Xi)
        break;
      Bi++, Ue--;
    }
    if (Ue >= 0 && Bi++, Zi = Zi.dblp(Bi), Ue < 0)
      break;
    for (bi = 0; bi < Pe; bi++) {
      var ns = Qi[bi];
      ns !== 0 && (ns > 0 ? vi = je[bi][ns - 1 >> 1] : ns < 0 && (vi = je[bi][-ns - 1 >> 1].neg()), vi.type === "affine" ? Zi = Zi.mixedAdd(vi) : Zi = Zi.add(vi));
    }
  }
  for (Ue = 0; Ue < Pe; Ue++)
    je[Ue] = null;
  return Be ? Zi : Zi.toP();
};
function BasePoint$1(Ae, t) {
  this.curve = Ae, this.type = t, this.precomputed = null;
}
BaseCurve$1.BasePoint = BasePoint$1;
BasePoint$1.prototype.eq = function Ae() {
  throw new Error("Not implemented");
};
BasePoint$1.prototype.validate = function Ae() {
  return this.curve.validate(this);
};
BaseCurve$1.prototype.decodePoint = function Ae(t, Me) {
  t = utils$a.toArray(t, Me);
  var Ie = this.p.byteLength();
  if ((t[0] === 4 || t[0] === 6 || t[0] === 7) && t.length - 1 === 2 * Ie) {
    t[0] === 6 ? assert$e(t[t.length - 1] % 2 === 0) : t[0] === 7 && assert$e(t[t.length - 1] % 2 === 1);
    var Pe = this.point(
      t.slice(1, 1 + Ie),
      t.slice(1 + Ie, 1 + 2 * Ie)
    );
    return Pe;
  } else if ((t[0] === 2 || t[0] === 3) && t.length - 1 === Ie)
    return this.pointFromX(t.slice(1, 1 + Ie), t[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint$1.prototype.encodeCompressed = function Ae(t) {
  return this.encode(t, !0);
};
BasePoint$1.prototype._encode = function Ae(t) {
  var Me = this.curve.p.byteLength(), Ie = this.getX().toArray("be", Me);
  return t ? [this.getY().isEven() ? 2 : 3].concat(Ie) : [4].concat(Ie, this.getY().toArray("be", Me));
};
BasePoint$1.prototype.encode = function Ae(t, Me) {
  return utils$a.encode(this._encode(Me), t);
};
BasePoint$1.prototype.precompute = function Ae(t) {
  if (this.precomputed)
    return this;
  var Me = {
    doubles: null,
    naf: null,
    beta: null
  };
  return Me.naf = this._getNAFPoints(8), Me.doubles = this._getDoubles(4, t), Me.beta = this._getBeta(), this.precomputed = Me, this;
};
BasePoint$1.prototype._hasDoubles = function Ae(t) {
  if (!this.precomputed)
    return !1;
  var Me = this.precomputed.doubles;
  return Me ? Me.points.length >= Math.ceil((t.bitLength() + 1) / Me.step) : !1;
};
BasePoint$1.prototype._getDoubles = function Ae(t, Me) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var Ie = [this], Pe = this, Be = 0; Be < Me; Be += t) {
    for (var Te = 0; Te < t; Te++)
      Pe = Pe.dbl();
    Ie.push(Pe);
  }
  return {
    step: t,
    points: Ie
  };
};
BasePoint$1.prototype._getNAFPoints = function Ae(t) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var Me = [this], Ie = (1 << t) - 1, Pe = Ie === 1 ? null : this.dbl(), Be = 1; Be < Ie; Be++)
    Me[Be] = Me[Be - 1].add(Pe);
  return {
    wnd: t,
    points: Me
  };
};
BasePoint$1.prototype._getBeta = function Ae() {
  return null;
};
BasePoint$1.prototype.dblp = function Ae(t) {
  for (var Me = this, Ie = 0; Ie < t; Ie++)
    Me = Me.dbl();
  return Me;
};
var utils$9 = utils$d, BN$6 = bnExports, inherits$2 = inherits_browserExports, Base$2 = base$2, assert$d = utils$9.assert;
function ShortCurve$1(Ae) {
  Base$2.call(this, "short", Ae), this.a = new BN$6(Ae.a, 16).toRed(this.red), this.b = new BN$6(Ae.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(Ae), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits$2(ShortCurve$1, Base$2);
var short = ShortCurve$1;
ShortCurve$1.prototype._getEndomorphism = function Ae(t) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var Me, Ie;
    if (t.beta)
      Me = new BN$6(t.beta, 16).toRed(this.red);
    else {
      var Pe = this._getEndoRoots(this.p);
      Me = Pe[0].cmp(Pe[1]) < 0 ? Pe[0] : Pe[1], Me = Me.toRed(this.red);
    }
    if (t.lambda)
      Ie = new BN$6(t.lambda, 16);
    else {
      var Be = this._getEndoRoots(this.n);
      this.g.mul(Be[0]).x.cmp(this.g.x.redMul(Me)) === 0 ? Ie = Be[0] : (Ie = Be[1], assert$d(this.g.mul(Ie).x.cmp(this.g.x.redMul(Me)) === 0));
    }
    var Te;
    return t.basis ? Te = t.basis.map(function(je) {
      return {
        a: new BN$6(je.a, 16),
        b: new BN$6(je.b, 16)
      };
    }) : Te = this._getEndoBasis(Ie), {
      beta: Me,
      lambda: Ie,
      basis: Te
    };
  }
};
ShortCurve$1.prototype._getEndoRoots = function Ae(t) {
  var Me = t === this.p ? this.red : BN$6.mont(t), Ie = new BN$6(2).toRed(Me).redInvm(), Pe = Ie.redNeg(), Be = new BN$6(3).toRed(Me).redNeg().redSqrt().redMul(Ie), Te = Pe.redAdd(Be).fromRed(), je = Pe.redSub(Be).fromRed();
  return [Te, je];
};
ShortCurve$1.prototype._getEndoBasis = function Ae(t) {
  for (var Me = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), Ie = t, Pe = this.n.clone(), Be = new BN$6(1), Te = new BN$6(0), je = new BN$6(0), Ve = new BN$6(1), fi, Ue, bi, vi, mi, _i, $i, Ci = 0, Ui, ki; Ie.cmpn(0) !== 0; ) {
    var Ji = Pe.div(Ie);
    Ui = Pe.sub(Ji.mul(Ie)), ki = je.sub(Ji.mul(Be));
    var Hi = Ve.sub(Ji.mul(Te));
    if (!bi && Ui.cmp(Me) < 0)
      fi = $i.neg(), Ue = Be, bi = Ui.neg(), vi = ki;
    else if (bi && ++Ci === 2)
      break;
    $i = Ui, Pe = Ie, Ie = Ui, je = Be, Be = ki, Ve = Te, Te = Hi;
  }
  mi = Ui.neg(), _i = ki;
  var Zi = bi.sqr().add(vi.sqr()), Qi = mi.sqr().add(_i.sqr());
  return Qi.cmp(Zi) >= 0 && (mi = fi, _i = Ue), bi.negative && (bi = bi.neg(), vi = vi.neg()), mi.negative && (mi = mi.neg(), _i = _i.neg()), [
    { a: bi, b: vi },
    { a: mi, b: _i }
  ];
};
ShortCurve$1.prototype._endoSplit = function Ae(t) {
  var Me = this.endo.basis, Ie = Me[0], Pe = Me[1], Be = Pe.b.mul(t).divRound(this.n), Te = Ie.b.neg().mul(t).divRound(this.n), je = Be.mul(Ie.a), Ve = Te.mul(Pe.a), fi = Be.mul(Ie.b), Ue = Te.mul(Pe.b), bi = t.sub(je).sub(Ve), vi = fi.add(Ue).neg();
  return { k1: bi, k2: vi };
};
ShortCurve$1.prototype.pointFromX = function Ae(t, Me) {
  t = new BN$6(t, 16), t.red || (t = t.toRed(this.red));
  var Ie = t.redSqr().redMul(t).redIAdd(t.redMul(this.a)).redIAdd(this.b), Pe = Ie.redSqrt();
  if (Pe.redSqr().redSub(Ie).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var Be = Pe.fromRed().isOdd();
  return (Me && !Be || !Me && Be) && (Pe = Pe.redNeg()), this.point(t, Pe);
};
ShortCurve$1.prototype.validate = function Ae(t) {
  if (t.inf)
    return !0;
  var Me = t.x, Ie = t.y, Pe = this.a.redMul(Me), Be = Me.redSqr().redMul(Me).redIAdd(Pe).redIAdd(this.b);
  return Ie.redSqr().redISub(Be).cmpn(0) === 0;
};
ShortCurve$1.prototype._endoWnafMulAdd = function Ae(t, Me, Ie) {
  for (var Pe = this._endoWnafT1, Be = this._endoWnafT2, Te = 0; Te < t.length; Te++) {
    var je = this._endoSplit(Me[Te]), Ve = t[Te], fi = Ve._getBeta();
    je.k1.negative && (je.k1.ineg(), Ve = Ve.neg(!0)), je.k2.negative && (je.k2.ineg(), fi = fi.neg(!0)), Pe[Te * 2] = Ve, Pe[Te * 2 + 1] = fi, Be[Te * 2] = je.k1, Be[Te * 2 + 1] = je.k2;
  }
  for (var Ue = this._wnafMulAdd(1, Pe, Be, Te * 2, Ie), bi = 0; bi < Te * 2; bi++)
    Pe[bi] = null, Be[bi] = null;
  return Ue;
};
function Point$3(Ae, t, Me, Ie) {
  Base$2.BasePoint.call(this, Ae, "affine"), t === null && Me === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$6(t, 16), this.y = new BN$6(Me, 16), Ie && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits$2(Point$3, Base$2.BasePoint);
ShortCurve$1.prototype.point = function Ae(t, Me, Ie) {
  return new Point$3(this, t, Me, Ie);
};
ShortCurve$1.prototype.pointFromJSON = function Ae(t, Me) {
  return Point$3.fromJSON(this, t, Me);
};
Point$3.prototype._getBeta = function Ae() {
  if (this.curve.endo) {
    var t = this.precomputed;
    if (t && t.beta)
      return t.beta;
    var Me = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (t) {
      var Ie = this.curve, Pe = function(Be) {
        return Ie.point(Be.x.redMul(Ie.endo.beta), Be.y);
      };
      t.beta = Me, Me.precomputed = {
        beta: null,
        naf: t.naf && {
          wnd: t.naf.wnd,
          points: t.naf.points.map(Pe)
        },
        doubles: t.doubles && {
          step: t.doubles.step,
          points: t.doubles.points.map(Pe)
        }
      };
    }
    return Me;
  }
};
Point$3.prototype.toJSON = function Ae() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point$3.fromJSON = function Ae(t, Me, Ie) {
  typeof Me == "string" && (Me = JSON.parse(Me));
  var Pe = t.point(Me[0], Me[1], Ie);
  if (!Me[2])
    return Pe;
  function Be(je) {
    return t.point(je[0], je[1], Ie);
  }
  var Te = Me[2];
  return Pe.precomputed = {
    beta: null,
    doubles: Te.doubles && {
      step: Te.doubles.step,
      points: [Pe].concat(Te.doubles.points.map(Be))
    },
    naf: Te.naf && {
      wnd: Te.naf.wnd,
      points: [Pe].concat(Te.naf.points.map(Be))
    }
  }, Pe;
};
Point$3.prototype.inspect = function Ae() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$3.prototype.isInfinity = function Ae() {
  return this.inf;
};
Point$3.prototype.add = function Ae(t) {
  if (this.inf)
    return t;
  if (t.inf)
    return this;
  if (this.eq(t))
    return this.dbl();
  if (this.neg().eq(t))
    return this.curve.point(null, null);
  if (this.x.cmp(t.x) === 0)
    return this.curve.point(null, null);
  var Me = this.y.redSub(t.y);
  Me.cmpn(0) !== 0 && (Me = Me.redMul(this.x.redSub(t.x).redInvm()));
  var Ie = Me.redSqr().redISub(this.x).redISub(t.x), Pe = Me.redMul(this.x.redSub(Ie)).redISub(this.y);
  return this.curve.point(Ie, Pe);
};
Point$3.prototype.dbl = function Ae() {
  if (this.inf)
    return this;
  var t = this.y.redAdd(this.y);
  if (t.cmpn(0) === 0)
    return this.curve.point(null, null);
  var Me = this.curve.a, Ie = this.x.redSqr(), Pe = t.redInvm(), Be = Ie.redAdd(Ie).redIAdd(Ie).redIAdd(Me).redMul(Pe), Te = Be.redSqr().redISub(this.x.redAdd(this.x)), je = Be.redMul(this.x.redSub(Te)).redISub(this.y);
  return this.curve.point(Te, je);
};
Point$3.prototype.getX = function Ae() {
  return this.x.fromRed();
};
Point$3.prototype.getY = function Ae() {
  return this.y.fromRed();
};
Point$3.prototype.mul = function Ae(t) {
  return t = new BN$6(t, 16), this.isInfinity() ? this : this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [t]) : this.curve._wnafMul(this, t);
};
Point$3.prototype.mulAdd = function Ae(t, Me, Ie) {
  var Pe = [this, Me], Be = [t, Ie];
  return this.curve.endo ? this.curve._endoWnafMulAdd(Pe, Be) : this.curve._wnafMulAdd(1, Pe, Be, 2);
};
Point$3.prototype.jmulAdd = function Ae(t, Me, Ie) {
  var Pe = [this, Me], Be = [t, Ie];
  return this.curve.endo ? this.curve._endoWnafMulAdd(Pe, Be, !0) : this.curve._wnafMulAdd(1, Pe, Be, 2, !0);
};
Point$3.prototype.eq = function Ae(t) {
  return this === t || this.inf === t.inf && (this.inf || this.x.cmp(t.x) === 0 && this.y.cmp(t.y) === 0);
};
Point$3.prototype.neg = function Ae(t) {
  if (this.inf)
    return this;
  var Me = this.curve.point(this.x, this.y.redNeg());
  if (t && this.precomputed) {
    var Ie = this.precomputed, Pe = function(Be) {
      return Be.neg();
    };
    Me.precomputed = {
      naf: Ie.naf && {
        wnd: Ie.naf.wnd,
        points: Ie.naf.points.map(Pe)
      },
      doubles: Ie.doubles && {
        step: Ie.doubles.step,
        points: Ie.doubles.points.map(Pe)
      }
    };
  }
  return Me;
};
Point$3.prototype.toJ = function Ae() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var t = this.curve.jpoint(this.x, this.y, this.curve.one);
  return t;
};
function JPoint$1(Ae, t, Me, Ie) {
  Base$2.BasePoint.call(this, Ae, "jacobian"), t === null && Me === null && Ie === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$6(0)) : (this.x = new BN$6(t, 16), this.y = new BN$6(Me, 16), this.z = new BN$6(Ie, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits$2(JPoint$1, Base$2.BasePoint);
ShortCurve$1.prototype.jpoint = function Ae(t, Me, Ie) {
  return new JPoint$1(this, t, Me, Ie);
};
JPoint$1.prototype.toP = function Ae() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var t = this.z.redInvm(), Me = t.redSqr(), Ie = this.x.redMul(Me), Pe = this.y.redMul(Me).redMul(t);
  return this.curve.point(Ie, Pe);
};
JPoint$1.prototype.neg = function Ae() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint$1.prototype.add = function Ae(t) {
  if (this.isInfinity())
    return t;
  if (t.isInfinity())
    return this;
  var Me = t.z.redSqr(), Ie = this.z.redSqr(), Pe = this.x.redMul(Me), Be = t.x.redMul(Ie), Te = this.y.redMul(Me.redMul(t.z)), je = t.y.redMul(Ie.redMul(this.z)), Ve = Pe.redSub(Be), fi = Te.redSub(je);
  if (Ve.cmpn(0) === 0)
    return fi.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var Ue = Ve.redSqr(), bi = Ue.redMul(Ve), vi = Pe.redMul(Ue), mi = fi.redSqr().redIAdd(bi).redISub(vi).redISub(vi), _i = fi.redMul(vi.redISub(mi)).redISub(Te.redMul(bi)), $i = this.z.redMul(t.z).redMul(Ve);
  return this.curve.jpoint(mi, _i, $i);
};
JPoint$1.prototype.mixedAdd = function Ae(t) {
  if (this.isInfinity())
    return t.toJ();
  if (t.isInfinity())
    return this;
  var Me = this.z.redSqr(), Ie = this.x, Pe = t.x.redMul(Me), Be = this.y, Te = t.y.redMul(Me).redMul(this.z), je = Ie.redSub(Pe), Ve = Be.redSub(Te);
  if (je.cmpn(0) === 0)
    return Ve.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var fi = je.redSqr(), Ue = fi.redMul(je), bi = Ie.redMul(fi), vi = Ve.redSqr().redIAdd(Ue).redISub(bi).redISub(bi), mi = Ve.redMul(bi.redISub(vi)).redISub(Be.redMul(Ue)), _i = this.z.redMul(je);
  return this.curve.jpoint(vi, mi, _i);
};
JPoint$1.prototype.dblp = function Ae(t) {
  if (t === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!t)
    return this.dbl();
  var Me;
  if (this.curve.zeroA || this.curve.threeA) {
    var Ie = this;
    for (Me = 0; Me < t; Me++)
      Ie = Ie.dbl();
    return Ie;
  }
  var Pe = this.curve.a, Be = this.curve.tinv, Te = this.x, je = this.y, Ve = this.z, fi = Ve.redSqr().redSqr(), Ue = je.redAdd(je);
  for (Me = 0; Me < t; Me++) {
    var bi = Te.redSqr(), vi = Ue.redSqr(), mi = vi.redSqr(), _i = bi.redAdd(bi).redIAdd(bi).redIAdd(Pe.redMul(fi)), $i = Te.redMul(vi), Ci = _i.redSqr().redISub($i.redAdd($i)), Ui = $i.redISub(Ci), ki = _i.redMul(Ui);
    ki = ki.redIAdd(ki).redISub(mi);
    var Ji = Ue.redMul(Ve);
    Me + 1 < t && (fi = fi.redMul(mi)), Te = Ci, Ve = Ji, Ue = ki;
  }
  return this.curve.jpoint(Te, Ue.redMul(Be), Ve);
};
JPoint$1.prototype.dbl = function Ae() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint$1.prototype._zeroDbl = function Ae() {
  var t, Me, Ie;
  if (this.zOne) {
    var Pe = this.x.redSqr(), Be = this.y.redSqr(), Te = Be.redSqr(), je = this.x.redAdd(Be).redSqr().redISub(Pe).redISub(Te);
    je = je.redIAdd(je);
    var Ve = Pe.redAdd(Pe).redIAdd(Pe), fi = Ve.redSqr().redISub(je).redISub(je), Ue = Te.redIAdd(Te);
    Ue = Ue.redIAdd(Ue), Ue = Ue.redIAdd(Ue), t = fi, Me = Ve.redMul(je.redISub(fi)).redISub(Ue), Ie = this.y.redAdd(this.y);
  } else {
    var bi = this.x.redSqr(), vi = this.y.redSqr(), mi = vi.redSqr(), _i = this.x.redAdd(vi).redSqr().redISub(bi).redISub(mi);
    _i = _i.redIAdd(_i);
    var $i = bi.redAdd(bi).redIAdd(bi), Ci = $i.redSqr(), Ui = mi.redIAdd(mi);
    Ui = Ui.redIAdd(Ui), Ui = Ui.redIAdd(Ui), t = Ci.redISub(_i).redISub(_i), Me = $i.redMul(_i.redISub(t)).redISub(Ui), Ie = this.y.redMul(this.z), Ie = Ie.redIAdd(Ie);
  }
  return this.curve.jpoint(t, Me, Ie);
};
JPoint$1.prototype._threeDbl = function Ae() {
  var t, Me, Ie;
  if (this.zOne) {
    var Pe = this.x.redSqr(), Be = this.y.redSqr(), Te = Be.redSqr(), je = this.x.redAdd(Be).redSqr().redISub(Pe).redISub(Te);
    je = je.redIAdd(je);
    var Ve = Pe.redAdd(Pe).redIAdd(Pe).redIAdd(this.curve.a), fi = Ve.redSqr().redISub(je).redISub(je);
    t = fi;
    var Ue = Te.redIAdd(Te);
    Ue = Ue.redIAdd(Ue), Ue = Ue.redIAdd(Ue), Me = Ve.redMul(je.redISub(fi)).redISub(Ue), Ie = this.y.redAdd(this.y);
  } else {
    var bi = this.z.redSqr(), vi = this.y.redSqr(), mi = this.x.redMul(vi), _i = this.x.redSub(bi).redMul(this.x.redAdd(bi));
    _i = _i.redAdd(_i).redIAdd(_i);
    var $i = mi.redIAdd(mi);
    $i = $i.redIAdd($i);
    var Ci = $i.redAdd($i);
    t = _i.redSqr().redISub(Ci), Ie = this.y.redAdd(this.z).redSqr().redISub(vi).redISub(bi);
    var Ui = vi.redSqr();
    Ui = Ui.redIAdd(Ui), Ui = Ui.redIAdd(Ui), Ui = Ui.redIAdd(Ui), Me = _i.redMul($i.redISub(t)).redISub(Ui);
  }
  return this.curve.jpoint(t, Me, Ie);
};
JPoint$1.prototype._dbl = function Ae() {
  var t = this.curve.a, Me = this.x, Ie = this.y, Pe = this.z, Be = Pe.redSqr().redSqr(), Te = Me.redSqr(), je = Ie.redSqr(), Ve = Te.redAdd(Te).redIAdd(Te).redIAdd(t.redMul(Be)), fi = Me.redAdd(Me);
  fi = fi.redIAdd(fi);
  var Ue = fi.redMul(je), bi = Ve.redSqr().redISub(Ue.redAdd(Ue)), vi = Ue.redISub(bi), mi = je.redSqr();
  mi = mi.redIAdd(mi), mi = mi.redIAdd(mi), mi = mi.redIAdd(mi);
  var _i = Ve.redMul(vi).redISub(mi), $i = Ie.redAdd(Ie).redMul(Pe);
  return this.curve.jpoint(bi, _i, $i);
};
JPoint$1.prototype.trpl = function Ae() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var t = this.x.redSqr(), Me = this.y.redSqr(), Ie = this.z.redSqr(), Pe = Me.redSqr(), Be = t.redAdd(t).redIAdd(t), Te = Be.redSqr(), je = this.x.redAdd(Me).redSqr().redISub(t).redISub(Pe);
  je = je.redIAdd(je), je = je.redAdd(je).redIAdd(je), je = je.redISub(Te);
  var Ve = je.redSqr(), fi = Pe.redIAdd(Pe);
  fi = fi.redIAdd(fi), fi = fi.redIAdd(fi), fi = fi.redIAdd(fi);
  var Ue = Be.redIAdd(je).redSqr().redISub(Te).redISub(Ve).redISub(fi), bi = Me.redMul(Ue);
  bi = bi.redIAdd(bi), bi = bi.redIAdd(bi);
  var vi = this.x.redMul(Ve).redISub(bi);
  vi = vi.redIAdd(vi), vi = vi.redIAdd(vi);
  var mi = this.y.redMul(Ue.redMul(fi.redISub(Ue)).redISub(je.redMul(Ve)));
  mi = mi.redIAdd(mi), mi = mi.redIAdd(mi), mi = mi.redIAdd(mi);
  var _i = this.z.redAdd(je).redSqr().redISub(Ie).redISub(Ve);
  return this.curve.jpoint(vi, mi, _i);
};
JPoint$1.prototype.mul = function Ae(t, Me) {
  return t = new BN$6(t, Me), this.curve._wnafMul(this, t);
};
JPoint$1.prototype.eq = function Ae(t) {
  if (t.type === "affine")
    return this.eq(t.toJ());
  if (this === t)
    return !0;
  var Me = this.z.redSqr(), Ie = t.z.redSqr();
  if (this.x.redMul(Ie).redISub(t.x.redMul(Me)).cmpn(0) !== 0)
    return !1;
  var Pe = Me.redMul(this.z), Be = Ie.redMul(t.z);
  return this.y.redMul(Be).redISub(t.y.redMul(Pe)).cmpn(0) === 0;
};
JPoint$1.prototype.eqXToP = function Ae(t) {
  var Me = this.z.redSqr(), Ie = t.toRed(this.curve.red).redMul(Me);
  if (this.x.cmp(Ie) === 0)
    return !0;
  for (var Pe = t.clone(), Be = this.curve.redN.redMul(Me); ; ) {
    if (Pe.iadd(this.curve.n), Pe.cmp(this.curve.p) >= 0)
      return !1;
    if (Ie.redIAdd(Be), this.x.cmp(Ie) === 0)
      return !0;
  }
};
JPoint$1.prototype.inspect = function Ae() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint$1.prototype.isInfinity = function Ae() {
  return this.z.cmpn(0) === 0;
};
var BN$5 = bnExports, inherits$1 = inherits_browserExports, Base$1 = base$2, utils$8 = utils$d;
function MontCurve(Ae) {
  Base$1.call(this, "mont", Ae), this.a = new BN$5(Ae.a, 16).toRed(this.red), this.b = new BN$5(Ae.b, 16).toRed(this.red), this.i4 = new BN$5(4).toRed(this.red).redInvm(), this.two = new BN$5(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$1(MontCurve, Base$1);
var mont = MontCurve;
MontCurve.prototype.validate = function Ae(t) {
  var Me = t.normalize().x, Ie = Me.redSqr(), Pe = Ie.redMul(Me).redAdd(Ie.redMul(this.a)).redAdd(Me), Be = Pe.redSqrt();
  return Be.redSqr().cmp(Pe) === 0;
};
function Point$2(Ae, t, Me) {
  Base$1.BasePoint.call(this, Ae, "projective"), t === null && Me === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN$5(t, 16), this.z = new BN$5(Me, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
inherits$1(Point$2, Base$1.BasePoint);
MontCurve.prototype.decodePoint = function Ae(t, Me) {
  return this.point(utils$8.toArray(t, Me), 1);
};
MontCurve.prototype.point = function Ae(t, Me) {
  return new Point$2(this, t, Me);
};
MontCurve.prototype.pointFromJSON = function Ae(t) {
  return Point$2.fromJSON(this, t);
};
Point$2.prototype.precompute = function Ae() {
};
Point$2.prototype._encode = function Ae() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$2.fromJSON = function Ae(t, Me) {
  return new Point$2(t, Me[0], Me[1] || t.one);
};
Point$2.prototype.inspect = function Ae() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function Ae() {
  return this.z.cmpn(0) === 0;
};
Point$2.prototype.dbl = function Ae() {
  var t = this.x.redAdd(this.z), Me = t.redSqr(), Ie = this.x.redSub(this.z), Pe = Ie.redSqr(), Be = Me.redSub(Pe), Te = Me.redMul(Pe), je = Be.redMul(Pe.redAdd(this.curve.a24.redMul(Be)));
  return this.curve.point(Te, je);
};
Point$2.prototype.add = function Ae() {
  throw new Error("Not supported on Montgomery curve");
};
Point$2.prototype.diffAdd = function Ae(t, Me) {
  var Ie = this.x.redAdd(this.z), Pe = this.x.redSub(this.z), Be = t.x.redAdd(t.z), Te = t.x.redSub(t.z), je = Te.redMul(Ie), Ve = Be.redMul(Pe), fi = Me.z.redMul(je.redAdd(Ve).redSqr()), Ue = Me.x.redMul(je.redISub(Ve).redSqr());
  return this.curve.point(fi, Ue);
};
Point$2.prototype.mul = function Ae(t) {
  for (var Me = t.clone(), Ie = this, Pe = this.curve.point(null, null), Be = this, Te = []; Me.cmpn(0) !== 0; Me.iushrn(1))
    Te.push(Me.andln(1));
  for (var je = Te.length - 1; je >= 0; je--)
    Te[je] === 0 ? (Ie = Ie.diffAdd(Pe, Be), Pe = Pe.dbl()) : (Pe = Ie.diffAdd(Pe, Be), Ie = Ie.dbl());
  return Pe;
};
Point$2.prototype.mulAdd = function Ae() {
  throw new Error("Not supported on Montgomery curve");
};
Point$2.prototype.jumlAdd = function Ae() {
  throw new Error("Not supported on Montgomery curve");
};
Point$2.prototype.eq = function Ae(t) {
  return this.getX().cmp(t.getX()) === 0;
};
Point$2.prototype.normalize = function Ae() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Point$2.prototype.getX = function Ae() {
  return this.normalize(), this.x.fromRed();
};
var utils$7 = utils$d, BN$4 = bnExports, inherits = inherits_browserExports, Base = base$2, assert$c = utils$7.assert;
function EdwardsCurve(Ae) {
  this.twisted = (Ae.a | 0) !== 1, this.mOneA = this.twisted && (Ae.a | 0) === -1, this.extended = this.mOneA, Base.call(this, "edwards", Ae), this.a = new BN$4(Ae.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN$4(Ae.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN$4(Ae.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert$c(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (Ae.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function Ae(t) {
  return this.mOneA ? t.redNeg() : this.a.redMul(t);
};
EdwardsCurve.prototype._mulC = function Ae(t) {
  return this.oneC ? t : this.c.redMul(t);
};
EdwardsCurve.prototype.jpoint = function Ae(t, Me, Ie, Pe) {
  return this.point(t, Me, Ie, Pe);
};
EdwardsCurve.prototype.pointFromX = function Ae(t, Me) {
  t = new BN$4(t, 16), t.red || (t = t.toRed(this.red));
  var Ie = t.redSqr(), Pe = this.c2.redSub(this.a.redMul(Ie)), Be = this.one.redSub(this.c2.redMul(this.d).redMul(Ie)), Te = Pe.redMul(Be.redInvm()), je = Te.redSqrt();
  if (je.redSqr().redSub(Te).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var Ve = je.fromRed().isOdd();
  return (Me && !Ve || !Me && Ve) && (je = je.redNeg()), this.point(t, je);
};
EdwardsCurve.prototype.pointFromY = function Ae(t, Me) {
  t = new BN$4(t, 16), t.red || (t = t.toRed(this.red));
  var Ie = t.redSqr(), Pe = Ie.redSub(this.c2), Be = Ie.redMul(this.d).redMul(this.c2).redSub(this.a), Te = Pe.redMul(Be.redInvm());
  if (Te.cmp(this.zero) === 0) {
    if (Me)
      throw new Error("invalid point");
    return this.point(this.zero, t);
  }
  var je = Te.redSqrt();
  if (je.redSqr().redSub(Te).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return je.fromRed().isOdd() !== Me && (je = je.redNeg()), this.point(je, t);
};
EdwardsCurve.prototype.validate = function Ae(t) {
  if (t.isInfinity())
    return !0;
  t.normalize();
  var Me = t.x.redSqr(), Ie = t.y.redSqr(), Pe = Me.redMul(this.a).redAdd(Ie), Be = this.c2.redMul(this.one.redAdd(this.d.redMul(Me).redMul(Ie)));
  return Pe.cmp(Be) === 0;
};
function Point$1(Ae, t, Me, Ie, Pe) {
  Base.BasePoint.call(this, Ae, "projective"), t === null && Me === null && Ie === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN$4(t, 16), this.y = new BN$4(Me, 16), this.z = Ie ? new BN$4(Ie, 16) : this.curve.one, this.t = Pe && new BN$4(Pe, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
inherits(Point$1, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function Ae(t) {
  return Point$1.fromJSON(this, t);
};
EdwardsCurve.prototype.point = function Ae(t, Me, Ie, Pe) {
  return new Point$1(this, t, Me, Ie, Pe);
};
Point$1.fromJSON = function Ae(t, Me) {
  return new Point$1(t, Me[0], Me[1], Me[2]);
};
Point$1.prototype.inspect = function Ae() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function Ae() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point$1.prototype._extDbl = function Ae() {
  var t = this.x.redSqr(), Me = this.y.redSqr(), Ie = this.z.redSqr();
  Ie = Ie.redIAdd(Ie);
  var Pe = this.curve._mulA(t), Be = this.x.redAdd(this.y).redSqr().redISub(t).redISub(Me), Te = Pe.redAdd(Me), je = Te.redSub(Ie), Ve = Pe.redSub(Me), fi = Be.redMul(je), Ue = Te.redMul(Ve), bi = Be.redMul(Ve), vi = je.redMul(Te);
  return this.curve.point(fi, Ue, vi, bi);
};
Point$1.prototype._projDbl = function Ae() {
  var t = this.x.redAdd(this.y).redSqr(), Me = this.x.redSqr(), Ie = this.y.redSqr(), Pe, Be, Te, je, Ve, fi;
  if (this.curve.twisted) {
    je = this.curve._mulA(Me);
    var Ue = je.redAdd(Ie);
    this.zOne ? (Pe = t.redSub(Me).redSub(Ie).redMul(Ue.redSub(this.curve.two)), Be = Ue.redMul(je.redSub(Ie)), Te = Ue.redSqr().redSub(Ue).redSub(Ue)) : (Ve = this.z.redSqr(), fi = Ue.redSub(Ve).redISub(Ve), Pe = t.redSub(Me).redISub(Ie).redMul(fi), Be = Ue.redMul(je.redSub(Ie)), Te = Ue.redMul(fi));
  } else
    je = Me.redAdd(Ie), Ve = this.curve._mulC(this.z).redSqr(), fi = je.redSub(Ve).redSub(Ve), Pe = this.curve._mulC(t.redISub(je)).redMul(fi), Be = this.curve._mulC(je).redMul(Me.redISub(Ie)), Te = je.redMul(fi);
  return this.curve.point(Pe, Be, Te);
};
Point$1.prototype.dbl = function Ae() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Point$1.prototype._extAdd = function Ae(t) {
  var Me = this.y.redSub(this.x).redMul(t.y.redSub(t.x)), Ie = this.y.redAdd(this.x).redMul(t.y.redAdd(t.x)), Pe = this.t.redMul(this.curve.dd).redMul(t.t), Be = this.z.redMul(t.z.redAdd(t.z)), Te = Ie.redSub(Me), je = Be.redSub(Pe), Ve = Be.redAdd(Pe), fi = Ie.redAdd(Me), Ue = Te.redMul(je), bi = Ve.redMul(fi), vi = Te.redMul(fi), mi = je.redMul(Ve);
  return this.curve.point(Ue, bi, mi, vi);
};
Point$1.prototype._projAdd = function Ae(t) {
  var Me = this.z.redMul(t.z), Ie = Me.redSqr(), Pe = this.x.redMul(t.x), Be = this.y.redMul(t.y), Te = this.curve.d.redMul(Pe).redMul(Be), je = Ie.redSub(Te), Ve = Ie.redAdd(Te), fi = this.x.redAdd(this.y).redMul(t.x.redAdd(t.y)).redISub(Pe).redISub(Be), Ue = Me.redMul(je).redMul(fi), bi, vi;
  return this.curve.twisted ? (bi = Me.redMul(Ve).redMul(Be.redSub(this.curve._mulA(Pe))), vi = je.redMul(Ve)) : (bi = Me.redMul(Ve).redMul(Be.redSub(Pe)), vi = this.curve._mulC(je).redMul(Ve)), this.curve.point(Ue, bi, vi);
};
Point$1.prototype.add = function Ae(t) {
  return this.isInfinity() ? t : t.isInfinity() ? this : this.curve.extended ? this._extAdd(t) : this._projAdd(t);
};
Point$1.prototype.mul = function Ae(t) {
  return this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve._wnafMul(this, t);
};
Point$1.prototype.mulAdd = function Ae(t, Me, Ie) {
  return this.curve._wnafMulAdd(1, [this, Me], [t, Ie], 2, !1);
};
Point$1.prototype.jmulAdd = function Ae(t, Me, Ie) {
  return this.curve._wnafMulAdd(1, [this, Me], [t, Ie], 2, !0);
};
Point$1.prototype.normalize = function Ae() {
  if (this.zOne)
    return this;
  var t = this.z.redInvm();
  return this.x = this.x.redMul(t), this.y = this.y.redMul(t), this.t && (this.t = this.t.redMul(t)), this.z = this.curve.one, this.zOne = !0, this;
};
Point$1.prototype.neg = function Ae() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point$1.prototype.getX = function Ae() {
  return this.normalize(), this.x.fromRed();
};
Point$1.prototype.getY = function Ae() {
  return this.normalize(), this.y.fromRed();
};
Point$1.prototype.eq = function Ae(t) {
  return this === t || this.getX().cmp(t.getX()) === 0 && this.getY().cmp(t.getY()) === 0;
};
Point$1.prototype.eqXToP = function Ae(t) {
  var Me = t.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(Me) === 0)
    return !0;
  for (var Ie = t.clone(), Pe = this.curve.redN.redMul(this.z); ; ) {
    if (Ie.iadd(this.curve.n), Ie.cmp(this.curve.p) >= 0)
      return !1;
    if (Me.redIAdd(Pe), this.x.cmp(Me) === 0)
      return !0;
  }
};
Point$1.prototype.toP = Point$1.prototype.normalize;
Point$1.prototype.mixedAdd = Point$1.prototype.add;
(function(Ae) {
  var t = Ae;
  t.base = base$2, t.short = short, t.mont = mont, t.edwards = edwards;
})(curve);
var curves$1 = {}, secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
(function(Ae) {
  var t = Ae, Me = hash$5, Ie = curve, Pe = utils$d, Be = Pe.assert;
  function Te(fi) {
    fi.type === "short" ? this.curve = new Ie.short(fi) : fi.type === "edwards" ? this.curve = new Ie.edwards(fi) : this.curve = new Ie.mont(fi), this.g = this.curve.g, this.n = this.curve.n, this.hash = fi.hash, Be(this.g.validate(), "Invalid curve"), Be(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  t.PresetCurve = Te;
  function je(fi, Ue) {
    Object.defineProperty(t, fi, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var bi = new Te(Ue);
        return Object.defineProperty(t, fi, {
          configurable: !0,
          enumerable: !0,
          value: bi
        }), bi;
      }
    });
  }
  je("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: Me.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), je("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: Me.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), je("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: Me.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), je("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: Me.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), je("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: Me.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), je("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Me.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), je("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Me.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var Ve;
  try {
    Ve = requireSecp256k1();
  } catch {
    Ve = void 0;
  }
  je("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: Me.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      Ve
    ]
  });
})(curves$1);
var hash$2 = hash$5, utils$6 = utils$c, assert$b = minimalisticAssert$1;
function HmacDRBG$1(Ae) {
  if (!(this instanceof HmacDRBG$1))
    return new HmacDRBG$1(Ae);
  this.hash = Ae.hash, this.predResist = !!Ae.predResist, this.outLen = this.hash.outSize, this.minEntropy = Ae.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var t = utils$6.toArray(Ae.entropy, Ae.entropyEnc || "hex"), Me = utils$6.toArray(Ae.nonce, Ae.nonceEnc || "hex"), Ie = utils$6.toArray(Ae.pers, Ae.persEnc || "hex");
  assert$b(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(t, Me, Ie);
}
var hmacDrbg$1 = HmacDRBG$1;
HmacDRBG$1.prototype._init = function Ae(t, Me, Ie) {
  var Pe = t.concat(Me).concat(Ie);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var Be = 0; Be < this.V.length; Be++)
    this.K[Be] = 0, this.V[Be] = 1;
  this._update(Pe), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG$1.prototype._hmac = function Ae() {
  return new hash$2.hmac(this.hash, this.K);
};
HmacDRBG$1.prototype._update = function Ae(t) {
  var Me = this._hmac().update(this.V).update([0]);
  t && (Me = Me.update(t)), this.K = Me.digest(), this.V = this._hmac().update(this.V).digest(), t && (this.K = this._hmac().update(this.V).update([1]).update(t).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG$1.prototype.reseed = function Ae(t, Me, Ie, Pe) {
  typeof Me != "string" && (Pe = Ie, Ie = Me, Me = null), t = utils$6.toArray(t, Me), Ie = utils$6.toArray(Ie, Pe), assert$b(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(t.concat(Ie || [])), this._reseed = 1;
};
HmacDRBG$1.prototype.generate = function Ae(t, Me, Ie, Pe) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof Me != "string" && (Pe = Ie, Ie = Me, Me = null), Ie && (Ie = utils$6.toArray(Ie, Pe || "hex"), this._update(Ie));
  for (var Be = []; Be.length < t; )
    this.V = this._hmac().update(this.V).digest(), Be = Be.concat(this.V);
  var Te = Be.slice(0, t);
  return this._update(Ie), this._reseed++, utils$6.encode(Te, Me);
};
var BN$3 = bnExports, utils$5 = utils$d, assert$a = utils$5.assert;
function KeyPair$3(Ae, t) {
  this.ec = Ae, this.priv = null, this.pub = null, t.priv && this._importPrivate(t.priv, t.privEnc), t.pub && this._importPublic(t.pub, t.pubEnc);
}
var key$2 = KeyPair$3;
KeyPair$3.fromPublic = function Ae(t, Me, Ie) {
  return Me instanceof KeyPair$3 ? Me : new KeyPair$3(t, {
    pub: Me,
    pubEnc: Ie
  });
};
KeyPair$3.fromPrivate = function Ae(t, Me, Ie) {
  return Me instanceof KeyPair$3 ? Me : new KeyPair$3(t, {
    priv: Me,
    privEnc: Ie
  });
};
KeyPair$3.prototype.validate = function Ae() {
  var t = this.getPublic();
  return t.isInfinity() ? { result: !1, reason: "Invalid public key" } : t.validate() ? t.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair$3.prototype.getPublic = function Ae(t, Me) {
  return typeof t == "string" && (Me = t, t = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), Me ? this.pub.encode(Me, t) : this.pub;
};
KeyPair$3.prototype.getPrivate = function Ae(t) {
  return t === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair$3.prototype._importPrivate = function Ae(t, Me) {
  this.priv = new BN$3(t, Me || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$3.prototype._importPublic = function Ae(t, Me) {
  if (t.x || t.y) {
    this.ec.curve.type === "mont" ? assert$a(t.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$a(t.x && t.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(t.x, t.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(t, Me);
};
KeyPair$3.prototype.derive = function Ae(t) {
  return t.validate() || assert$a(t.validate(), "public point not validated"), t.mul(this.priv).getX();
};
KeyPair$3.prototype.sign = function Ae(t, Me, Ie) {
  return this.ec.sign(t, this, Me, Ie);
};
KeyPair$3.prototype.verify = function Ae(t, Me) {
  return this.ec.verify(t, Me, this);
};
KeyPair$3.prototype.inspect = function Ae() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$2 = bnExports, utils$4 = utils$d, assert$9 = utils$4.assert;
function Signature$3(Ae, t) {
  if (Ae instanceof Signature$3)
    return Ae;
  this._importDER(Ae, t) || (assert$9(Ae.r && Ae.s, "Signature without r or s"), this.r = new BN$2(Ae.r, 16), this.s = new BN$2(Ae.s, 16), Ae.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = Ae.recoveryParam);
}
var signature$2 = Signature$3;
function Position$1() {
  this.place = 0;
}
function getLength$1(Ae, t) {
  var Me = Ae[t.place++];
  if (!(Me & 128))
    return Me;
  var Ie = Me & 15;
  if (Ie === 0 || Ie > 4 || Ae[t.place] === 0)
    return !1;
  for (var Pe = 0, Be = 0, Te = t.place; Be < Ie; Be++, Te++)
    Pe <<= 8, Pe |= Ae[Te], Pe >>>= 0;
  return Pe <= 127 ? !1 : (t.place = Te, Pe);
}
function rmPadding$1(Ae) {
  for (var t = 0, Me = Ae.length - 1; !Ae[t] && !(Ae[t + 1] & 128) && t < Me; )
    t++;
  return t === 0 ? Ae : Ae.slice(t);
}
Signature$3.prototype._importDER = function Ae(t, Me) {
  t = utils$4.toArray(t, Me);
  var Ie = new Position$1();
  if (t[Ie.place++] !== 48)
    return !1;
  var Pe = getLength$1(t, Ie);
  if (Pe === !1 || Pe + Ie.place !== t.length || t[Ie.place++] !== 2)
    return !1;
  var Be = getLength$1(t, Ie);
  if (Be === !1 || t[Ie.place] & 128)
    return !1;
  var Te = t.slice(Ie.place, Be + Ie.place);
  if (Ie.place += Be, t[Ie.place++] !== 2)
    return !1;
  var je = getLength$1(t, Ie);
  if (je === !1 || t.length !== je + Ie.place || t[Ie.place] & 128)
    return !1;
  var Ve = t.slice(Ie.place, je + Ie.place);
  if (Te[0] === 0)
    if (Te[1] & 128)
      Te = Te.slice(1);
    else
      return !1;
  if (Ve[0] === 0)
    if (Ve[1] & 128)
      Ve = Ve.slice(1);
    else
      return !1;
  return this.r = new BN$2(Te), this.s = new BN$2(Ve), this.recoveryParam = null, !0;
};
function constructLength$1(Ae, t) {
  if (t < 128) {
    Ae.push(t);
    return;
  }
  var Me = 1 + (Math.log(t) / Math.LN2 >>> 3);
  for (Ae.push(Me | 128); --Me; )
    Ae.push(t >>> (Me << 3) & 255);
  Ae.push(t);
}
Signature$3.prototype.toDER = function Ae(t) {
  var Me = this.r.toArray(), Ie = this.s.toArray();
  for (Me[0] & 128 && (Me = [0].concat(Me)), Ie[0] & 128 && (Ie = [0].concat(Ie)), Me = rmPadding$1(Me), Ie = rmPadding$1(Ie); !Ie[0] && !(Ie[1] & 128); )
    Ie = Ie.slice(1);
  var Pe = [2];
  constructLength$1(Pe, Me.length), Pe = Pe.concat(Me), Pe.push(2), constructLength$1(Pe, Ie.length);
  var Be = Pe.concat(Ie), Te = [48];
  return constructLength$1(Te, Be.length), Te = Te.concat(Be), utils$4.encode(Te, t);
};
var ec$1, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec$1;
  hasRequiredEc = 1;
  var Ae = bnExports, t = hmacDrbg$1, Me = utils$d, Ie = curves$1, Pe = requireBrorand(), Be = Me.assert, Te = key$2, je = signature$2;
  function Ve(fi) {
    if (!(this instanceof Ve))
      return new Ve(fi);
    typeof fi == "string" && (Be(
      Object.prototype.hasOwnProperty.call(Ie, fi),
      "Unknown curve " + fi
    ), fi = Ie[fi]), fi instanceof Ie.PresetCurve && (fi = { curve: fi }), this.curve = fi.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = fi.curve.g, this.g.precompute(fi.curve.n.bitLength() + 1), this.hash = fi.hash || fi.curve.hash;
  }
  return ec$1 = Ve, Ve.prototype.keyPair = function(Ue) {
    return new Te(this, Ue);
  }, Ve.prototype.keyFromPrivate = function(Ue, bi) {
    return Te.fromPrivate(this, Ue, bi);
  }, Ve.prototype.keyFromPublic = function(Ue, bi) {
    return Te.fromPublic(this, Ue, bi);
  }, Ve.prototype.genKeyPair = function(Ue) {
    Ue || (Ue = {});
    for (var bi = new t({
      hash: this.hash,
      pers: Ue.pers,
      persEnc: Ue.persEnc || "utf8",
      entropy: Ue.entropy || Pe(this.hash.hmacStrength),
      entropyEnc: Ue.entropy && Ue.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), vi = this.n.byteLength(), mi = this.n.sub(new Ae(2)); ; ) {
      var _i = new Ae(bi.generate(vi));
      if (!(_i.cmp(mi) > 0))
        return _i.iaddn(1), this.keyFromPrivate(_i);
    }
  }, Ve.prototype._truncateToN = function(Ue, bi) {
    var vi = Ue.byteLength() * 8 - this.n.bitLength();
    return vi > 0 && (Ue = Ue.ushrn(vi)), !bi && Ue.cmp(this.n) >= 0 ? Ue.sub(this.n) : Ue;
  }, Ve.prototype.sign = function(Ue, bi, vi, mi) {
    typeof vi == "object" && (mi = vi, vi = null), mi || (mi = {}), bi = this.keyFromPrivate(bi, vi), Ue = this._truncateToN(new Ae(Ue, 16));
    for (var _i = this.n.byteLength(), $i = bi.getPrivate().toArray("be", _i), Ci = Ue.toArray("be", _i), Ui = new t({
      hash: this.hash,
      entropy: $i,
      nonce: Ci,
      pers: mi.pers,
      persEnc: mi.persEnc || "utf8"
    }), ki = this.n.sub(new Ae(1)), Ji = 0; ; Ji++) {
      var Hi = mi.k ? mi.k(Ji) : new Ae(Ui.generate(this.n.byteLength()));
      if (Hi = this._truncateToN(Hi, !0), !(Hi.cmpn(1) <= 0 || Hi.cmp(ki) >= 0)) {
        var Zi = this.g.mul(Hi);
        if (!Zi.isInfinity()) {
          var Qi = Zi.getX(), Bi = Qi.umod(this.n);
          if (Bi.cmpn(0) !== 0) {
            var Xi = Hi.invm(this.n).mul(Bi.mul(bi.getPrivate()).iadd(Ue));
            if (Xi = Xi.umod(this.n), Xi.cmpn(0) !== 0) {
              var ns = (Zi.getY().isOdd() ? 1 : 0) | (Qi.cmp(Bi) !== 0 ? 2 : 0);
              return mi.canonical && Xi.cmp(this.nh) > 0 && (Xi = this.n.sub(Xi), ns ^= 1), new je({ r: Bi, s: Xi, recoveryParam: ns });
            }
          }
        }
      }
    }
  }, Ve.prototype.verify = function(Ue, bi, vi, mi) {
    Ue = this._truncateToN(new Ae(Ue, 16)), vi = this.keyFromPublic(vi, mi), bi = new je(bi, "hex");
    var _i = bi.r, $i = bi.s;
    if (_i.cmpn(1) < 0 || _i.cmp(this.n) >= 0 || $i.cmpn(1) < 0 || $i.cmp(this.n) >= 0)
      return !1;
    var Ci = $i.invm(this.n), Ui = Ci.mul(Ue).umod(this.n), ki = Ci.mul(_i).umod(this.n), Ji;
    return this.curve._maxwellTrick ? (Ji = this.g.jmulAdd(Ui, vi.getPublic(), ki), Ji.isInfinity() ? !1 : Ji.eqXToP(_i)) : (Ji = this.g.mulAdd(Ui, vi.getPublic(), ki), Ji.isInfinity() ? !1 : Ji.getX().umod(this.n).cmp(_i) === 0);
  }, Ve.prototype.recoverPubKey = function(fi, Ue, bi, vi) {
    Be((3 & bi) === bi, "The recovery param is more than two bits"), Ue = new je(Ue, vi);
    var mi = this.n, _i = new Ae(fi), $i = Ue.r, Ci = Ue.s, Ui = bi & 1, ki = bi >> 1;
    if ($i.cmp(this.curve.p.umod(this.curve.n)) >= 0 && ki)
      throw new Error("Unable to find sencond key candinate");
    ki ? $i = this.curve.pointFromX($i.add(this.curve.n), Ui) : $i = this.curve.pointFromX($i, Ui);
    var Ji = Ue.r.invm(mi), Hi = mi.sub(_i).mul(Ji).umod(mi), Zi = Ci.mul(Ji).umod(mi);
    return this.g.mulAdd(Hi, $i, Zi);
  }, Ve.prototype.getKeyRecoveryParam = function(fi, Ue, bi, vi) {
    if (Ue = new je(Ue, vi), Ue.recoveryParam !== null)
      return Ue.recoveryParam;
    for (var mi = 0; mi < 4; mi++) {
      var _i;
      try {
        _i = this.recoverPubKey(fi, Ue, mi);
      } catch {
        continue;
      }
      if (_i.eq(bi))
        return mi;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec$1;
}
var utils$3 = utils$d, assert$8 = utils$3.assert, parseBytes$2 = utils$3.parseBytes, cachedProperty$1 = utils$3.cachedProperty;
function KeyPair$2(Ae, t) {
  this.eddsa = Ae, this._secret = parseBytes$2(t.secret), Ae.isPoint(t.pub) ? this._pub = t.pub : this._pubBytes = parseBytes$2(t.pub);
}
KeyPair$2.fromPublic = function Ae(t, Me) {
  return Me instanceof KeyPair$2 ? Me : new KeyPair$2(t, { pub: Me });
};
KeyPair$2.fromSecret = function Ae(t, Me) {
  return Me instanceof KeyPair$2 ? Me : new KeyPair$2(t, { secret: Me });
};
KeyPair$2.prototype.secret = function Ae() {
  return this._secret;
};
cachedProperty$1(KeyPair$2, "pubBytes", function Ae() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$2, "pub", function Ae() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$2, "privBytes", function Ae() {
  var t = this.eddsa, Me = this.hash(), Ie = t.encodingLength - 1, Pe = Me.slice(0, t.encodingLength);
  return Pe[0] &= 248, Pe[Ie] &= 127, Pe[Ie] |= 64, Pe;
});
cachedProperty$1(KeyPair$2, "priv", function Ae() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$2, "hash", function Ae() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$2, "messagePrefix", function Ae() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$2.prototype.sign = function Ae(t) {
  return assert$8(this._secret, "KeyPair can only verify"), this.eddsa.sign(t, this);
};
KeyPair$2.prototype.verify = function Ae(t, Me) {
  return this.eddsa.verify(t, Me, this);
};
KeyPair$2.prototype.getSecret = function Ae(t) {
  return assert$8(this._secret, "KeyPair is public only"), utils$3.encode(this.secret(), t);
};
KeyPair$2.prototype.getPublic = function Ae(t) {
  return utils$3.encode(this.pubBytes(), t);
};
var key$1 = KeyPair$2, BN$1 = bnExports, utils$2 = utils$d, assert$7 = utils$2.assert, cachedProperty = utils$2.cachedProperty, parseBytes$1 = utils$2.parseBytes;
function Signature$2(Ae, t) {
  this.eddsa = Ae, typeof t != "object" && (t = parseBytes$1(t)), Array.isArray(t) && (assert$7(t.length === Ae.encodingLength * 2, "Signature has invalid size"), t = {
    R: t.slice(0, Ae.encodingLength),
    S: t.slice(Ae.encodingLength)
  }), assert$7(t.R && t.S, "Signature without R or S"), Ae.isPoint(t.R) && (this._R = t.R), t.S instanceof BN$1 && (this._S = t.S), this._Rencoded = Array.isArray(t.R) ? t.R : t.Rencoded, this._Sencoded = Array.isArray(t.S) ? t.S : t.Sencoded;
}
cachedProperty(Signature$2, "S", function Ae() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$2, "R", function Ae() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$2, "Rencoded", function Ae() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$2, "Sencoded", function Ae() {
  return this.eddsa.encodeInt(this.S());
});
Signature$2.prototype.toBytes = function Ae() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$2.prototype.toHex = function Ae() {
  return utils$2.encode(this.toBytes(), "hex").toUpperCase();
};
var signature$1 = Signature$2, hash$1 = hash$5, curves = curves$1, utils$1 = utils$d, assert$6 = utils$1.assert, parseBytes = utils$1.parseBytes, KeyPair$1 = key$1, Signature$1 = signature$1;
function EDDSA(Ae) {
  if (assert$6(Ae === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
    return new EDDSA(Ae);
  Ae = curves[Ae].curve, this.curve = Ae, this.g = Ae.g, this.g.precompute(Ae.n.bitLength() + 1), this.pointClass = Ae.point().constructor, this.encodingLength = Math.ceil(Ae.n.bitLength() / 8), this.hash = hash$1.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function Ae(t, Me) {
  t = parseBytes(t);
  var Ie = this.keyFromSecret(Me), Pe = this.hashInt(Ie.messagePrefix(), t), Be = this.g.mul(Pe), Te = this.encodePoint(Be), je = this.hashInt(Te, Ie.pubBytes(), t).mul(Ie.priv()), Ve = Pe.add(je).umod(this.curve.n);
  return this.makeSignature({ R: Be, S: Ve, Rencoded: Te });
};
EDDSA.prototype.verify = function Ae(t, Me, Ie) {
  if (t = parseBytes(t), Me = this.makeSignature(Me), Me.S().gte(Me.eddsa.curve.n) || Me.S().isNeg())
    return !1;
  var Pe = this.keyFromPublic(Ie), Be = this.hashInt(Me.Rencoded(), Pe.pubBytes(), t), Te = this.g.mul(Me.S()), je = Me.R().add(Pe.pub().mul(Be));
  return je.eq(Te);
};
EDDSA.prototype.hashInt = function Ae() {
  for (var t = this.hash(), Me = 0; Me < arguments.length; Me++)
    t.update(arguments[Me]);
  return utils$1.intFromLE(t.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function Ae(t) {
  return KeyPair$1.fromPublic(this, t);
};
EDDSA.prototype.keyFromSecret = function Ae(t) {
  return KeyPair$1.fromSecret(this, t);
};
EDDSA.prototype.makeSignature = function Ae(t) {
  return t instanceof Signature$1 ? t : new Signature$1(this, t);
};
EDDSA.prototype.encodePoint = function Ae(t) {
  var Me = t.getY().toArray("le", this.encodingLength);
  return Me[this.encodingLength - 1] |= t.getX().isOdd() ? 128 : 0, Me;
};
EDDSA.prototype.decodePoint = function Ae(t) {
  t = utils$1.parseBytes(t);
  var Me = t.length - 1, Ie = t.slice(0, Me).concat(t[Me] & -129), Pe = (t[Me] & 128) !== 0, Be = utils$1.intFromLE(Ie);
  return this.curve.pointFromY(Be, Pe);
};
EDDSA.prototype.encodeInt = function Ae(t) {
  return t.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function Ae(t) {
  return utils$1.intFromLE(t);
};
EDDSA.prototype.isPoint = function Ae(t) {
  return t instanceof this.pointClass;
};
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(Ae) {
    var t = Ae;
    t.version = require$$0$2.version, t.utils = utils$d, t.rand = requireBrorand(), t.curve = curve, t.curves = curves$1, t.ec = requireEc(), t.eddsa = eddsa;
  }(elliptic)), elliptic;
}
var ellipticExports = requireElliptic();
const EC$2 = /* @__PURE__ */ getDefaultExportFromCjs(ellipticExports);
function commonjsRequire$1(Ae) {
  throw new Error('Could not dynamically require "' + Ae + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
const global = globalThis || void 0 || self;
var cjs$3 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(Ae, t) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Me, Ie) {
    Me.__proto__ = Ie;
  } || function(Me, Ie) {
    for (var Pe in Ie) Ie.hasOwnProperty(Pe) && (Me[Pe] = Ie[Pe]);
  }, extendStatics(Ae, t);
};
function __extends(Ae, t) {
  extendStatics(Ae, t);
  function Me() {
    this.constructor = Ae;
  }
  Ae.prototype = t === null ? Object.create(t) : (Me.prototype = t.prototype, new Me());
}
var __assign = function() {
  return __assign = Object.assign || function(t) {
    for (var Me, Ie = 1, Pe = arguments.length; Ie < Pe; Ie++) {
      Me = arguments[Ie];
      for (var Be in Me) Object.prototype.hasOwnProperty.call(Me, Be) && (t[Be] = Me[Be]);
    }
    return t;
  }, __assign.apply(this, arguments);
};
function __rest(Ae, t) {
  var Me = {};
  for (var Ie in Ae) Object.prototype.hasOwnProperty.call(Ae, Ie) && t.indexOf(Ie) < 0 && (Me[Ie] = Ae[Ie]);
  if (Ae != null && typeof Object.getOwnPropertySymbols == "function")
    for (var Pe = 0, Ie = Object.getOwnPropertySymbols(Ae); Pe < Ie.length; Pe++)
      t.indexOf(Ie[Pe]) < 0 && Object.prototype.propertyIsEnumerable.call(Ae, Ie[Pe]) && (Me[Ie[Pe]] = Ae[Ie[Pe]]);
  return Me;
}
function __decorate(Ae, t, Me, Ie) {
  var Pe = arguments.length, Be = Pe < 3 ? t : Ie === null ? Ie = Object.getOwnPropertyDescriptor(t, Me) : Ie, Te;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") Be = Reflect.decorate(Ae, t, Me, Ie);
  else for (var je = Ae.length - 1; je >= 0; je--) (Te = Ae[je]) && (Be = (Pe < 3 ? Te(Be) : Pe > 3 ? Te(t, Me, Be) : Te(t, Me)) || Be);
  return Pe > 3 && Be && Object.defineProperty(t, Me, Be), Be;
}
function __param(Ae, t) {
  return function(Me, Ie) {
    t(Me, Ie, Ae);
  };
}
function __metadata(Ae, t) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(Ae, t);
}
function __awaiter(Ae, t, Me, Ie) {
  function Pe(Be) {
    return Be instanceof Me ? Be : new Me(function(Te) {
      Te(Be);
    });
  }
  return new (Me || (Me = Promise))(function(Be, Te) {
    function je(Ue) {
      try {
        fi(Ie.next(Ue));
      } catch (bi) {
        Te(bi);
      }
    }
    function Ve(Ue) {
      try {
        fi(Ie.throw(Ue));
      } catch (bi) {
        Te(bi);
      }
    }
    function fi(Ue) {
      Ue.done ? Be(Ue.value) : Pe(Ue.value).then(je, Ve);
    }
    fi((Ie = Ie.apply(Ae, t || [])).next());
  });
}
function __generator(Ae, t) {
  var Me = { label: 0, sent: function() {
    if (Be[0] & 1) throw Be[1];
    return Be[1];
  }, trys: [], ops: [] }, Ie, Pe, Be, Te;
  return Te = { next: je(0), throw: je(1), return: je(2) }, typeof Symbol == "function" && (Te[Symbol.iterator] = function() {
    return this;
  }), Te;
  function je(fi) {
    return function(Ue) {
      return Ve([fi, Ue]);
    };
  }
  function Ve(fi) {
    if (Ie) throw new TypeError("Generator is already executing.");
    for (; Me; ) try {
      if (Ie = 1, Pe && (Be = fi[0] & 2 ? Pe.return : fi[0] ? Pe.throw || ((Be = Pe.return) && Be.call(Pe), 0) : Pe.next) && !(Be = Be.call(Pe, fi[1])).done) return Be;
      switch (Pe = 0, Be && (fi = [fi[0] & 2, Be.value]), fi[0]) {
        case 0:
        case 1:
          Be = fi;
          break;
        case 4:
          return Me.label++, { value: fi[1], done: !1 };
        case 5:
          Me.label++, Pe = fi[1], fi = [0];
          continue;
        case 7:
          fi = Me.ops.pop(), Me.trys.pop();
          continue;
        default:
          if (Be = Me.trys, !(Be = Be.length > 0 && Be[Be.length - 1]) && (fi[0] === 6 || fi[0] === 2)) {
            Me = 0;
            continue;
          }
          if (fi[0] === 3 && (!Be || fi[1] > Be[0] && fi[1] < Be[3])) {
            Me.label = fi[1];
            break;
          }
          if (fi[0] === 6 && Me.label < Be[1]) {
            Me.label = Be[1], Be = fi;
            break;
          }
          if (Be && Me.label < Be[2]) {
            Me.label = Be[2], Me.ops.push(fi);
            break;
          }
          Be[2] && Me.ops.pop(), Me.trys.pop();
          continue;
      }
      fi = t.call(Ae, Me);
    } catch (Ue) {
      fi = [6, Ue], Pe = 0;
    } finally {
      Ie = Be = 0;
    }
    if (fi[0] & 5) throw fi[1];
    return { value: fi[0] ? fi[1] : void 0, done: !0 };
  }
}
function __createBinding(Ae, t, Me, Ie) {
  Ie === void 0 && (Ie = Me), Ae[Ie] = t[Me];
}
function __exportStar(Ae, t) {
  for (var Me in Ae) Me !== "default" && !t.hasOwnProperty(Me) && (t[Me] = Ae[Me]);
}
function __values(Ae) {
  var t = typeof Symbol == "function" && Symbol.iterator, Me = t && Ae[t], Ie = 0;
  if (Me) return Me.call(Ae);
  if (Ae && typeof Ae.length == "number") return {
    next: function() {
      return Ae && Ie >= Ae.length && (Ae = void 0), { value: Ae && Ae[Ie++], done: !Ae };
    }
  };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(Ae, t) {
  var Me = typeof Symbol == "function" && Ae[Symbol.iterator];
  if (!Me) return Ae;
  var Ie = Me.call(Ae), Pe, Be = [], Te;
  try {
    for (; (t === void 0 || t-- > 0) && !(Pe = Ie.next()).done; ) Be.push(Pe.value);
  } catch (je) {
    Te = { error: je };
  } finally {
    try {
      Pe && !Pe.done && (Me = Ie.return) && Me.call(Ie);
    } finally {
      if (Te) throw Te.error;
    }
  }
  return Be;
}
function __spread() {
  for (var Ae = [], t = 0; t < arguments.length; t++)
    Ae = Ae.concat(__read(arguments[t]));
  return Ae;
}
function __spreadArrays() {
  for (var Ae = 0, t = 0, Me = arguments.length; t < Me; t++) Ae += arguments[t].length;
  for (var Ie = Array(Ae), Pe = 0, t = 0; t < Me; t++)
    for (var Be = arguments[t], Te = 0, je = Be.length; Te < je; Te++, Pe++)
      Ie[Pe] = Be[Te];
  return Ie;
}
function __await(Ae) {
  return this instanceof __await ? (this.v = Ae, this) : new __await(Ae);
}
function __asyncGenerator(Ae, t, Me) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var Ie = Me.apply(Ae, t || []), Pe, Be = [];
  return Pe = {}, Te("next"), Te("throw"), Te("return"), Pe[Symbol.asyncIterator] = function() {
    return this;
  }, Pe;
  function Te(vi) {
    Ie[vi] && (Pe[vi] = function(mi) {
      return new Promise(function(_i, $i) {
        Be.push([vi, mi, _i, $i]) > 1 || je(vi, mi);
      });
    });
  }
  function je(vi, mi) {
    try {
      Ve(Ie[vi](mi));
    } catch (_i) {
      bi(Be[0][3], _i);
    }
  }
  function Ve(vi) {
    vi.value instanceof __await ? Promise.resolve(vi.value.v).then(fi, Ue) : bi(Be[0][2], vi);
  }
  function fi(vi) {
    je("next", vi);
  }
  function Ue(vi) {
    je("throw", vi);
  }
  function bi(vi, mi) {
    vi(mi), Be.shift(), Be.length && je(Be[0][0], Be[0][1]);
  }
}
function __asyncDelegator(Ae) {
  var t, Me;
  return t = {}, Ie("next"), Ie("throw", function(Pe) {
    throw Pe;
  }), Ie("return"), t[Symbol.iterator] = function() {
    return this;
  }, t;
  function Ie(Pe, Be) {
    t[Pe] = Ae[Pe] ? function(Te) {
      return (Me = !Me) ? { value: __await(Ae[Pe](Te)), done: Pe === "return" } : Be ? Be(Te) : Te;
    } : Be;
  }
}
function __asyncValues(Ae) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = Ae[Symbol.asyncIterator], Me;
  return t ? t.call(Ae) : (Ae = typeof __values == "function" ? __values(Ae) : Ae[Symbol.iterator](), Me = {}, Ie("next"), Ie("throw"), Ie("return"), Me[Symbol.asyncIterator] = function() {
    return this;
  }, Me);
  function Ie(Be) {
    Me[Be] = Ae[Be] && function(Te) {
      return new Promise(function(je, Ve) {
        Te = Ae[Be](Te), Pe(je, Ve, Te.done, Te.value);
      });
    };
  }
  function Pe(Be, Te, je, Ve) {
    Promise.resolve(Ve).then(function(fi) {
      Be({ value: fi, done: je });
    }, Te);
  }
}
function __makeTemplateObject(Ae, t) {
  return Object.defineProperty ? Object.defineProperty(Ae, "raw", { value: t }) : Ae.raw = t, Ae;
}
function __importStar(Ae) {
  if (Ae && Ae.__esModule) return Ae;
  var t = {};
  if (Ae != null) for (var Me in Ae) Object.hasOwnProperty.call(Ae, Me) && (t[Me] = Ae[Me]);
  return t.default = Ae, t;
}
function __importDefault(Ae) {
  return Ae && Ae.__esModule ? Ae : { default: Ae };
}
function __classPrivateFieldGet(Ae, t) {
  if (!t.has(Ae))
    throw new TypeError("attempted to get private field on non-instance");
  return t.get(Ae);
}
function __classPrivateFieldSet(Ae, t, Me) {
  if (!t.has(Ae))
    throw new TypeError("attempted to set private field on non-instance");
  return t.set(Ae, Me), Me;
}
const tslib_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __read,
  __rest,
  __spread,
  __spreadArrays,
  __values
}, Symbol.toStringTag, { value: "Module" })), require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6);
var utils = {}, delay = {}, hasRequiredDelay;
function requireDelay() {
  if (hasRequiredDelay) return delay;
  hasRequiredDelay = 1, Object.defineProperty(delay, "__esModule", { value: !0 }), delay.delay = void 0;
  function Ae(t) {
    return new Promise((Me) => {
      setTimeout(() => {
        Me(!0);
      }, t);
    });
  }
  return delay.delay = Ae, delay;
}
var convert = {}, constants = {}, misc = {}, hasRequiredMisc;
function requireMisc() {
  return hasRequiredMisc || (hasRequiredMisc = 1, Object.defineProperty(misc, "__esModule", { value: !0 }), misc.ONE_THOUSAND = misc.ONE_HUNDRED = void 0, misc.ONE_HUNDRED = 100, misc.ONE_THOUSAND = 1e3), misc;
}
var time = {}, hasRequiredTime;
function requireTime() {
  return hasRequiredTime || (hasRequiredTime = 1, function(Ae) {
    Object.defineProperty(Ae, "__esModule", { value: !0 }), Ae.ONE_YEAR = Ae.FOUR_WEEKS = Ae.THREE_WEEKS = Ae.TWO_WEEKS = Ae.ONE_WEEK = Ae.THIRTY_DAYS = Ae.SEVEN_DAYS = Ae.FIVE_DAYS = Ae.THREE_DAYS = Ae.ONE_DAY = Ae.TWENTY_FOUR_HOURS = Ae.TWELVE_HOURS = Ae.SIX_HOURS = Ae.THREE_HOURS = Ae.ONE_HOUR = Ae.SIXTY_MINUTES = Ae.THIRTY_MINUTES = Ae.TEN_MINUTES = Ae.FIVE_MINUTES = Ae.ONE_MINUTE = Ae.SIXTY_SECONDS = Ae.THIRTY_SECONDS = Ae.TEN_SECONDS = Ae.FIVE_SECONDS = Ae.ONE_SECOND = void 0, Ae.ONE_SECOND = 1, Ae.FIVE_SECONDS = 5, Ae.TEN_SECONDS = 10, Ae.THIRTY_SECONDS = 30, Ae.SIXTY_SECONDS = 60, Ae.ONE_MINUTE = Ae.SIXTY_SECONDS, Ae.FIVE_MINUTES = Ae.ONE_MINUTE * 5, Ae.TEN_MINUTES = Ae.ONE_MINUTE * 10, Ae.THIRTY_MINUTES = Ae.ONE_MINUTE * 30, Ae.SIXTY_MINUTES = Ae.ONE_MINUTE * 60, Ae.ONE_HOUR = Ae.SIXTY_MINUTES, Ae.THREE_HOURS = Ae.ONE_HOUR * 3, Ae.SIX_HOURS = Ae.ONE_HOUR * 6, Ae.TWELVE_HOURS = Ae.ONE_HOUR * 12, Ae.TWENTY_FOUR_HOURS = Ae.ONE_HOUR * 24, Ae.ONE_DAY = Ae.TWENTY_FOUR_HOURS, Ae.THREE_DAYS = Ae.ONE_DAY * 3, Ae.FIVE_DAYS = Ae.ONE_DAY * 5, Ae.SEVEN_DAYS = Ae.ONE_DAY * 7, Ae.THIRTY_DAYS = Ae.ONE_DAY * 30, Ae.ONE_WEEK = Ae.SEVEN_DAYS, Ae.TWO_WEEKS = Ae.ONE_WEEK * 2, Ae.THREE_WEEKS = Ae.ONE_WEEK * 3, Ae.FOUR_WEEKS = Ae.ONE_WEEK * 4, Ae.ONE_YEAR = Ae.ONE_DAY * 365;
  }(time)), time;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(Ae) {
    Object.defineProperty(Ae, "__esModule", { value: !0 });
    const t = require$$0$1;
    t.__exportStar(requireMisc(), Ae), t.__exportStar(requireTime(), Ae);
  }(constants)), constants;
}
var hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert) return convert;
  hasRequiredConvert = 1, Object.defineProperty(convert, "__esModule", { value: !0 }), convert.fromMiliseconds = convert.toMiliseconds = void 0;
  const Ae = requireConstants();
  function t(Ie) {
    return Ie * Ae.ONE_THOUSAND;
  }
  convert.toMiliseconds = t;
  function Me(Ie) {
    return Math.floor(Ie / Ae.ONE_THOUSAND);
  }
  return convert.fromMiliseconds = Me, convert;
}
var hasRequiredUtils;
function requireUtils() {
  return hasRequiredUtils || (hasRequiredUtils = 1, function(Ae) {
    Object.defineProperty(Ae, "__esModule", { value: !0 });
    const t = require$$0$1;
    t.__exportStar(requireDelay(), Ae), t.__exportStar(requireConvert(), Ae);
  }(utils)), utils;
}
var watch$2 = {}, hasRequiredWatch$1;
function requireWatch$1() {
  if (hasRequiredWatch$1) return watch$2;
  hasRequiredWatch$1 = 1, Object.defineProperty(watch$2, "__esModule", { value: !0 }), watch$2.Watch = void 0;
  class Ae {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(Me) {
      if (this.timestamps.has(Me))
        throw new Error(`Watch already started for label: ${Me}`);
      this.timestamps.set(Me, { started: Date.now() });
    }
    stop(Me) {
      const Ie = this.get(Me);
      if (typeof Ie.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${Me}`);
      const Pe = Date.now() - Ie.started;
      this.timestamps.set(Me, { started: Ie.started, elapsed: Pe });
    }
    get(Me) {
      const Ie = this.timestamps.get(Me);
      if (typeof Ie > "u")
        throw new Error(`No timestamp found for label: ${Me}`);
      return Ie;
    }
    elapsed(Me) {
      const Ie = this.get(Me);
      return Ie.elapsed || Date.now() - Ie.started;
    }
  }
  return watch$2.Watch = Ae, watch$2.default = Ae, watch$2;
}
var types = {}, watch$1 = {}, hasRequiredWatch;
function requireWatch() {
  if (hasRequiredWatch) return watch$1;
  hasRequiredWatch = 1, Object.defineProperty(watch$1, "__esModule", { value: !0 }), watch$1.IWatch = void 0;
  class Ae {
  }
  return watch$1.IWatch = Ae, watch$1;
}
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(Ae) {
    Object.defineProperty(Ae, "__esModule", { value: !0 }), require$$0$1.__exportStar(requireWatch(), Ae);
  }(types)), types;
}
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  const t = require$$0$1;
  t.__exportStar(requireUtils(), Ae), t.__exportStar(requireWatch$1(), Ae), t.__exportStar(requireTypes(), Ae), t.__exportStar(requireConstants(), Ae);
})(cjs$3);
class IEvents {
}
let n$3 = class extends IEvents {
  constructor(t) {
    super();
  }
};
const s = cjs$3.FIVE_SECONDS, r$1 = { pulse: "heartbeat_pulse" };
let i$1 = class tf extends n$3 {
  constructor(t) {
    super(t), this.events = new eventsExports.EventEmitter(), this.interval = s, this.interval = (t == null ? void 0 : t.interval) || s;
  }
  static async init(t) {
    const Me = new tf(t);
    return await Me.init(), Me;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(t, Me) {
    this.events.on(t, Me);
  }
  once(t, Me) {
    this.events.once(t, Me);
  }
  off(t, Me) {
    this.events.off(t, Me);
  }
  removeListener(t, Me) {
    this.events.removeListener(t, Me);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), cjs$3.toMiliseconds(this.interval));
  }
  pulse() {
    this.events.emit(r$1.pulse);
  }
};
const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(Ae, t) {
  if (Ae === "__proto__" || Ae === "constructor" && t && typeof t == "object" && "prototype" in t) {
    warnKeyDropped(Ae);
    return;
  }
  return t;
}
function warnKeyDropped(Ae) {
  console.warn(`[destr] Dropping "${Ae}" key to prevent prototype pollution.`);
}
function destr(Ae, t = {}) {
  if (typeof Ae != "string")
    return Ae;
  const Me = Ae.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    Ae[0] === '"' && Ae.endsWith('"') && !Ae.includes("\\")
  )
    return Me.slice(1, -1);
  if (Me.length <= 9) {
    const Ie = Me.toLowerCase();
    if (Ie === "true")
      return !0;
    if (Ie === "false")
      return !1;
    if (Ie === "undefined")
      return;
    if (Ie === "null")
      return null;
    if (Ie === "nan")
      return Number.NaN;
    if (Ie === "infinity")
      return Number.POSITIVE_INFINITY;
    if (Ie === "-infinity")
      return Number.NEGATIVE_INFINITY;
  }
  if (!JsonSigRx.test(Ae)) {
    if (t.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return Ae;
  }
  try {
    if (suspectProtoRx.test(Ae) || suspectConstructorRx.test(Ae)) {
      if (t.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(Ae, jsonParseTransform);
    }
    return JSON.parse(Ae);
  } catch (Ie) {
    if (t.strict)
      throw Ie;
    return Ae;
  }
}
function wrapToPromise(Ae) {
  return !Ae || typeof Ae.then != "function" ? Promise.resolve(Ae) : Ae;
}
function asyncCall(Ae, ...t) {
  try {
    return wrapToPromise(Ae(...t));
  } catch (Me) {
    return Promise.reject(Me);
  }
}
function isPrimitive(Ae) {
  const t = typeof Ae;
  return Ae === null || t !== "object" && t !== "function";
}
function isPureObject(Ae) {
  const t = Object.getPrototypeOf(Ae);
  return !t || t.isPrototypeOf(Object);
}
function stringify(Ae) {
  if (isPrimitive(Ae))
    return String(Ae);
  if (isPureObject(Ae) || Array.isArray(Ae))
    return JSON.stringify(Ae);
  if (typeof Ae.toJSON == "function")
    return stringify(Ae.toJSON());
  throw new Error("[unstorage] Cannot stringify value!");
}
function checkBufferSupport() {
  if (typeof Buffer$1 > "u")
    throw new TypeError("[unstorage] Buffer is not supported!");
}
const BASE64_PREFIX = "base64:";
function serializeRaw(Ae) {
  if (typeof Ae == "string")
    return Ae;
  checkBufferSupport();
  const t = Buffer$1.from(Ae).toString("base64");
  return BASE64_PREFIX + t;
}
function deserializeRaw(Ae) {
  return typeof Ae != "string" || !Ae.startsWith(BASE64_PREFIX) ? Ae : (checkBufferSupport(), Buffer$1.from(Ae.slice(BASE64_PREFIX.length), "base64"));
}
function normalizeKey(Ae) {
  return Ae ? Ae.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : "";
}
function joinKeys(...Ae) {
  return normalizeKey(Ae.join(":"));
}
function normalizeBaseKey(Ae) {
  return Ae = normalizeKey(Ae), Ae ? Ae + ":" : "";
}
function defineDriver(Ae) {
  return Ae;
}
const DRIVER_NAME = "memory", memory = () => {
  const Ae = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => Ae,
    hasItem(t) {
      return Ae.has(t);
    },
    getItem(t) {
      return Ae.get(t) ?? null;
    },
    getItemRaw(t) {
      return Ae.get(t) ?? null;
    },
    setItem(t, Me) {
      Ae.set(t, Me);
    },
    setItemRaw(t, Me) {
      Ae.set(t, Me);
    },
    removeItem(t) {
      Ae.delete(t);
    },
    getKeys() {
      return [...Ae.keys()];
    },
    clear() {
      Ae.clear();
    },
    dispose() {
      Ae.clear();
    }
  };
};
function createStorage(Ae = {}) {
  const t = {
    mounts: { "": Ae.driver || memory() },
    mountpoints: [""],
    watching: !1,
    watchListeners: [],
    unwatch: {}
  }, Me = (fi) => {
    for (const Ue of t.mountpoints)
      if (fi.startsWith(Ue))
        return {
          base: Ue,
          relativeKey: fi.slice(Ue.length),
          driver: t.mounts[Ue]
        };
    return {
      base: "",
      relativeKey: fi,
      driver: t.mounts[""]
    };
  }, Ie = (fi, Ue) => t.mountpoints.filter(
    (bi) => bi.startsWith(fi) || Ue && fi.startsWith(bi)
  ).map((bi) => ({
    relativeBase: fi.length > bi.length ? fi.slice(bi.length) : void 0,
    mountpoint: bi,
    driver: t.mounts[bi]
  })), Pe = (fi, Ue) => {
    if (t.watching) {
      Ue = normalizeKey(Ue);
      for (const bi of t.watchListeners)
        bi(fi, Ue);
    }
  }, Be = async () => {
    if (!t.watching) {
      t.watching = !0;
      for (const fi in t.mounts)
        t.unwatch[fi] = await watch(
          t.mounts[fi],
          Pe,
          fi
        );
    }
  }, Te = async () => {
    if (t.watching) {
      for (const fi in t.unwatch)
        await t.unwatch[fi]();
      t.unwatch = {}, t.watching = !1;
    }
  }, je = (fi, Ue, bi) => {
    const vi = /* @__PURE__ */ new Map(), mi = (_i) => {
      let $i = vi.get(_i.base);
      return $i || ($i = {
        driver: _i.driver,
        base: _i.base,
        items: []
      }, vi.set(_i.base, $i)), $i;
    };
    for (const _i of fi) {
      const $i = typeof _i == "string", Ci = normalizeKey($i ? _i : _i.key), Ui = $i ? void 0 : _i.value, ki = $i || !_i.options ? Ue : { ...Ue, ..._i.options }, Ji = Me(Ci);
      mi(Ji).items.push({
        key: Ci,
        value: Ui,
        relativeKey: Ji.relativeKey,
        options: ki
      });
    }
    return Promise.all([...vi.values()].map((_i) => bi(_i))).then(
      (_i) => _i.flat()
    );
  }, Ve = {
    // Item
    hasItem(fi, Ue = {}) {
      fi = normalizeKey(fi);
      const { relativeKey: bi, driver: vi } = Me(fi);
      return asyncCall(vi.hasItem, bi, Ue);
    },
    getItem(fi, Ue = {}) {
      fi = normalizeKey(fi);
      const { relativeKey: bi, driver: vi } = Me(fi);
      return asyncCall(vi.getItem, bi, Ue).then(
        (mi) => destr(mi)
      );
    },
    getItems(fi, Ue) {
      return je(fi, Ue, (bi) => bi.driver.getItems ? asyncCall(
        bi.driver.getItems,
        bi.items.map((vi) => ({
          key: vi.relativeKey,
          options: vi.options
        })),
        Ue
      ).then(
        (vi) => vi.map((mi) => ({
          key: joinKeys(bi.base, mi.key),
          value: destr(mi.value)
        }))
      ) : Promise.all(
        bi.items.map((vi) => asyncCall(
          bi.driver.getItem,
          vi.relativeKey,
          vi.options
        ).then((mi) => ({
          key: vi.key,
          value: destr(mi)
        })))
      ));
    },
    getItemRaw(fi, Ue = {}) {
      fi = normalizeKey(fi);
      const { relativeKey: bi, driver: vi } = Me(fi);
      return vi.getItemRaw ? asyncCall(vi.getItemRaw, bi, Ue) : asyncCall(vi.getItem, bi, Ue).then(
        (mi) => deserializeRaw(mi)
      );
    },
    async setItem(fi, Ue, bi = {}) {
      if (Ue === void 0)
        return Ve.removeItem(fi);
      fi = normalizeKey(fi);
      const { relativeKey: vi, driver: mi } = Me(fi);
      mi.setItem && (await asyncCall(mi.setItem, vi, stringify(Ue), bi), mi.watch || Pe("update", fi));
    },
    async setItems(fi, Ue) {
      await je(fi, Ue, async (bi) => {
        if (bi.driver.setItems)
          return asyncCall(
            bi.driver.setItems,
            bi.items.map((vi) => ({
              key: vi.relativeKey,
              value: stringify(vi.value),
              options: vi.options
            })),
            Ue
          );
        bi.driver.setItem && await Promise.all(
          bi.items.map((vi) => asyncCall(
            bi.driver.setItem,
            vi.relativeKey,
            stringify(vi.value),
            vi.options
          ))
        );
      });
    },
    async setItemRaw(fi, Ue, bi = {}) {
      if (Ue === void 0)
        return Ve.removeItem(fi, bi);
      fi = normalizeKey(fi);
      const { relativeKey: vi, driver: mi } = Me(fi);
      if (mi.setItemRaw)
        await asyncCall(mi.setItemRaw, vi, Ue, bi);
      else if (mi.setItem)
        await asyncCall(mi.setItem, vi, serializeRaw(Ue), bi);
      else
        return;
      mi.watch || Pe("update", fi);
    },
    async removeItem(fi, Ue = {}) {
      typeof Ue == "boolean" && (Ue = { removeMeta: Ue }), fi = normalizeKey(fi);
      const { relativeKey: bi, driver: vi } = Me(fi);
      vi.removeItem && (await asyncCall(vi.removeItem, bi, Ue), (Ue.removeMeta || Ue.removeMata) && await asyncCall(vi.removeItem, bi + "$", Ue), vi.watch || Pe("remove", fi));
    },
    // Meta
    async getMeta(fi, Ue = {}) {
      typeof Ue == "boolean" && (Ue = { nativeOnly: Ue }), fi = normalizeKey(fi);
      const { relativeKey: bi, driver: vi } = Me(fi), mi = /* @__PURE__ */ Object.create(null);
      if (vi.getMeta && Object.assign(mi, await asyncCall(vi.getMeta, bi, Ue)), !Ue.nativeOnly) {
        const _i = await asyncCall(
          vi.getItem,
          bi + "$",
          Ue
        ).then(($i) => destr($i));
        _i && typeof _i == "object" && (typeof _i.atime == "string" && (_i.atime = new Date(_i.atime)), typeof _i.mtime == "string" && (_i.mtime = new Date(_i.mtime)), Object.assign(mi, _i));
      }
      return mi;
    },
    setMeta(fi, Ue, bi = {}) {
      return this.setItem(fi + "$", Ue, bi);
    },
    removeMeta(fi, Ue = {}) {
      return this.removeItem(fi + "$", Ue);
    },
    // Keys
    async getKeys(fi, Ue = {}) {
      fi = normalizeBaseKey(fi);
      const bi = Ie(fi, !0);
      let vi = [];
      const mi = [];
      for (const _i of bi) {
        const $i = await asyncCall(
          _i.driver.getKeys,
          _i.relativeBase,
          Ue
        );
        for (const Ci of $i) {
          const Ui = _i.mountpoint + normalizeKey(Ci);
          vi.some((ki) => Ui.startsWith(ki)) || mi.push(Ui);
        }
        vi = [
          _i.mountpoint,
          ...vi.filter((Ci) => !Ci.startsWith(_i.mountpoint))
        ];
      }
      return fi ? mi.filter(
        (_i) => _i.startsWith(fi) && _i[_i.length - 1] !== "$"
      ) : mi.filter((_i) => _i[_i.length - 1] !== "$");
    },
    // Utils
    async clear(fi, Ue = {}) {
      fi = normalizeBaseKey(fi), await Promise.all(
        Ie(fi, !1).map(async (bi) => {
          if (bi.driver.clear)
            return asyncCall(bi.driver.clear, bi.relativeBase, Ue);
          if (bi.driver.removeItem) {
            const vi = await bi.driver.getKeys(bi.relativeBase || "", Ue);
            return Promise.all(
              vi.map((mi) => bi.driver.removeItem(mi, Ue))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(t.mounts).map((fi) => dispose(fi))
      );
    },
    async watch(fi) {
      return await Be(), t.watchListeners.push(fi), async () => {
        t.watchListeners = t.watchListeners.filter(
          (Ue) => Ue !== fi
        ), t.watchListeners.length === 0 && await Te();
      };
    },
    async unwatch() {
      t.watchListeners = [], await Te();
    },
    // Mount
    mount(fi, Ue) {
      if (fi = normalizeBaseKey(fi), fi && t.mounts[fi])
        throw new Error(`already mounted at ${fi}`);
      return fi && (t.mountpoints.push(fi), t.mountpoints.sort((bi, vi) => vi.length - bi.length)), t.mounts[fi] = Ue, t.watching && Promise.resolve(watch(Ue, Pe, fi)).then((bi) => {
        t.unwatch[fi] = bi;
      }).catch(console.error), Ve;
    },
    async unmount(fi, Ue = !0) {
      fi = normalizeBaseKey(fi), !(!fi || !t.mounts[fi]) && (t.watching && fi in t.unwatch && (t.unwatch[fi](), delete t.unwatch[fi]), Ue && await dispose(t.mounts[fi]), t.mountpoints = t.mountpoints.filter((bi) => bi !== fi), delete t.mounts[fi]);
    },
    getMount(fi = "") {
      fi = normalizeKey(fi) + ":";
      const Ue = Me(fi);
      return {
        driver: Ue.driver,
        base: Ue.base
      };
    },
    getMounts(fi = "", Ue = {}) {
      return fi = normalizeKey(fi), Ie(fi, Ue.parents).map((vi) => ({
        driver: vi.driver,
        base: vi.mountpoint
      }));
    },
    // Aliases
    keys: (fi, Ue = {}) => Ve.getKeys(fi, Ue),
    get: (fi, Ue = {}) => Ve.getItem(fi, Ue),
    set: (fi, Ue, bi = {}) => Ve.setItem(fi, Ue, bi),
    has: (fi, Ue = {}) => Ve.hasItem(fi, Ue),
    del: (fi, Ue = {}) => Ve.removeItem(fi, Ue),
    remove: (fi, Ue = {}) => Ve.removeItem(fi, Ue)
  };
  return Ve;
}
function watch(Ae, t, Me) {
  return Ae.watch ? Ae.watch((Ie, Pe) => t(Ie, Me + Pe)) : () => {
  };
}
async function dispose(Ae) {
  typeof Ae.dispose == "function" && await asyncCall(Ae.dispose);
}
function promisifyRequest(Ae) {
  return new Promise((t, Me) => {
    Ae.oncomplete = Ae.onsuccess = () => t(Ae.result), Ae.onabort = Ae.onerror = () => Me(Ae.error);
  });
}
function createStore(Ae, t) {
  const Me = indexedDB.open(Ae);
  Me.onupgradeneeded = () => Me.result.createObjectStore(t);
  const Ie = promisifyRequest(Me);
  return (Pe, Be) => Ie.then((Te) => Be(Te.transaction(t, Pe).objectStore(t)));
}
let defaultGetStoreFunc;
function defaultGetStore() {
  return defaultGetStoreFunc || (defaultGetStoreFunc = createStore("keyval-store", "keyval")), defaultGetStoreFunc;
}
function get(Ae, t = defaultGetStore()) {
  return t("readonly", (Me) => promisifyRequest(Me.get(Ae)));
}
function set$1(Ae, t, Me = defaultGetStore()) {
  return Me("readwrite", (Ie) => (Ie.put(t, Ae), promisifyRequest(Ie.transaction)));
}
function del(Ae, t = defaultGetStore()) {
  return t("readwrite", (Me) => (Me.delete(Ae), promisifyRequest(Me.transaction)));
}
function clear(Ae = defaultGetStore()) {
  return Ae("readwrite", (t) => (t.clear(), promisifyRequest(t.transaction)));
}
function eachCursor(Ae, t) {
  return Ae.openCursor().onsuccess = function() {
    this.result && (t(this.result), this.result.continue());
  }, promisifyRequest(Ae.transaction);
}
function keys(Ae = defaultGetStore()) {
  return Ae("readonly", (t) => {
    if (t.getAllKeys)
      return promisifyRequest(t.getAllKeys());
    const Me = [];
    return eachCursor(t, (Ie) => Me.push(Ie.key)).then(() => Me);
  });
}
const JSONStringify = (Ae) => JSON.stringify(Ae, (t, Me) => typeof Me == "bigint" ? Me.toString() + "n" : Me), JSONParse = (Ae) => {
  const t = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, Me = Ae.replace(t, '$1"$2n"$3');
  return JSON.parse(Me, (Ie, Pe) => typeof Pe == "string" && Pe.match(/^\d+n$/) ? BigInt(Pe.substring(0, Pe.length - 1)) : Pe);
};
function safeJsonParse(Ae) {
  if (typeof Ae != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof Ae}`);
  try {
    return JSONParse(Ae);
  } catch {
    return Ae;
  }
}
function safeJsonStringify(Ae) {
  return typeof Ae == "string" ? Ae : JSONStringify(Ae) || "";
}
const x$6 = "idb-keyval";
var z$6 = (Ae = {}) => {
  const t = Ae.base && Ae.base.length > 0 ? `${Ae.base}:` : "", Me = (Pe) => t + Pe;
  let Ie;
  return Ae.dbName && Ae.storeName && (Ie = createStore(Ae.dbName, Ae.storeName)), { name: x$6, options: Ae, async hasItem(Pe) {
    return !(typeof await get(Me(Pe), Ie) > "u");
  }, async getItem(Pe) {
    return await get(Me(Pe), Ie) ?? null;
  }, setItem(Pe, Be) {
    return set$1(Me(Pe), Be, Ie);
  }, removeItem(Pe) {
    return del(Me(Pe), Ie);
  }, getKeys() {
    return keys(Ie);
  }, clear() {
    return clear(Ie);
  } };
};
const D$3 = "WALLET_CONNECT_V2_INDEXED_DB", E$2 = "keyvaluestorage";
let _$3 = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z$6({ dbName: D$3, storeName: E$2 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const Me = await this.indexedDb.getItem(t);
    if (Me !== null) return Me;
  }
  async setItem(t, Me) {
    await this.indexedDb.setItem(t, safeJsonStringify(Me));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l$2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, c$2 = { exports: {} };
(function() {
  let Ae;
  function t() {
  }
  Ae = t, Ae.prototype.getItem = function(Me) {
    return this.hasOwnProperty(Me) ? String(this[Me]) : null;
  }, Ae.prototype.setItem = function(Me, Ie) {
    this[Me] = String(Ie);
  }, Ae.prototype.removeItem = function(Me) {
    delete this[Me];
  }, Ae.prototype.clear = function() {
    const Me = this;
    Object.keys(Me).forEach(function(Ie) {
      Me[Ie] = void 0, delete Me[Ie];
    });
  }, Ae.prototype.key = function(Me) {
    return Me = Me || 0, Object.keys(this)[Me];
  }, Ae.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l$2 < "u" && l$2.localStorage ? c$2.exports = l$2.localStorage : typeof window < "u" && window.localStorage ? c$2.exports = window.localStorage : c$2.exports = new t();
})();
function k$3(Ae) {
  var t;
  return [Ae[0], safeJsonParse((t = Ae[1]) != null ? t : "")];
}
let K$3 = class {
  constructor() {
    this.localStorage = c$2.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k$3);
  }
  async getItem(t) {
    const Me = this.localStorage.getItem(t);
    if (Me !== null) return safeJsonParse(Me);
  }
  async setItem(t, Me) {
    this.localStorage.setItem(t, safeJsonStringify(Me));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
const N$1 = "wc_storage_version", y$4 = 1, O$5 = async (Ae, t, Me) => {
  const Ie = N$1, Pe = await t.getItem(Ie);
  if (Pe && Pe >= y$4) {
    Me(t);
    return;
  }
  const Be = await Ae.getKeys();
  if (!Be.length) {
    Me(t);
    return;
  }
  const Te = [];
  for (; Be.length; ) {
    const je = Be.shift();
    if (!je) continue;
    const Ve = je.toLowerCase();
    if (Ve.includes("wc@") || Ve.includes("walletconnect") || Ve.includes("wc_") || Ve.includes("wallet_connect")) {
      const fi = await Ae.getItem(je);
      await t.setItem(je, fi), Te.push(je);
    }
  }
  await t.setItem(Ie, y$4), Me(t), j$2(Ae, Te);
}, j$2 = async (Ae, t) => {
  t.length && t.forEach(async (Me) => {
    await Ae.removeItem(Me);
  });
};
let h$2 = class {
  constructor() {
    this.initialized = !1, this.setInitialized = (Me) => {
      this.storage = Me, this.initialized = !0;
    };
    const t = new K$3();
    this.storage = t;
    try {
      const Me = new _$3();
      O$5(t, Me, this.setInitialized);
    } catch {
      this.initialized = !0;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, Me) {
    return await this.initialize(), this.storage.setItem(t, Me);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const Me = setInterval(() => {
        this.initialized && (clearInterval(Me), t());
      }, 20);
    });
  }
};
function tryStringify(Ae) {
  try {
    return JSON.stringify(Ae);
  } catch {
    return '"[Circular]"';
  }
}
var quickFormatUnescaped = format$1;
function format$1(Ae, t, Me) {
  var Ie = Me && Me.stringify || tryStringify, Pe = 1;
  if (typeof Ae == "object" && Ae !== null) {
    var Be = t.length + Pe;
    if (Be === 1) return Ae;
    var Te = new Array(Be);
    Te[0] = Ie(Ae);
    for (var je = 1; je < Be; je++)
      Te[je] = Ie(t[je]);
    return Te.join(" ");
  }
  if (typeof Ae != "string")
    return Ae;
  var Ve = t.length;
  if (Ve === 0) return Ae;
  for (var fi = "", Ue = 1 - Pe, bi = -1, vi = Ae && Ae.length || 0, mi = 0; mi < vi; ) {
    if (Ae.charCodeAt(mi) === 37 && mi + 1 < vi) {
      switch (bi = bi > -1 ? bi : 0, Ae.charCodeAt(mi + 1)) {
        case 100:
        case 102:
          if (Ue >= Ve || t[Ue] == null) break;
          bi < mi && (fi += Ae.slice(bi, mi)), fi += Number(t[Ue]), bi = mi + 2, mi++;
          break;
        case 105:
          if (Ue >= Ve || t[Ue] == null) break;
          bi < mi && (fi += Ae.slice(bi, mi)), fi += Math.floor(Number(t[Ue])), bi = mi + 2, mi++;
          break;
        case 79:
        case 111:
        case 106:
          if (Ue >= Ve || t[Ue] === void 0) break;
          bi < mi && (fi += Ae.slice(bi, mi));
          var _i = typeof t[Ue];
          if (_i === "string") {
            fi += "'" + t[Ue] + "'", bi = mi + 2, mi++;
            break;
          }
          if (_i === "function") {
            fi += t[Ue].name || "<anonymous>", bi = mi + 2, mi++;
            break;
          }
          fi += Ie(t[Ue]), bi = mi + 2, mi++;
          break;
        case 115:
          if (Ue >= Ve)
            break;
          bi < mi && (fi += Ae.slice(bi, mi)), fi += String(t[Ue]), bi = mi + 2, mi++;
          break;
        case 37:
          bi < mi && (fi += Ae.slice(bi, mi)), fi += "%", bi = mi + 2, mi++, Ue--;
          break;
      }
      ++Ue;
    }
    ++mi;
  }
  return bi === -1 ? Ae : (bi < vi && (fi += Ae.slice(bi)), fi);
}
const format = quickFormatUnescaped;
var browser$2 = pino;
const _console = pfGlobalThisOrFallback().console || {}, stdSerializers = {
  mapHttpRequest: mock,
  mapHttpResponse: mock,
  wrapRequestSerializer: passthrough,
  wrapResponseSerializer: passthrough,
  wrapErrorSerializer: passthrough,
  req: mock,
  res: mock,
  err: asErrValue
};
function shouldSerialize(Ae, t) {
  return Array.isArray(Ae) ? Ae.filter(function(Ie) {
    return Ie !== "!stdSerializers.err";
  }) : Ae === !0 ? Object.keys(t) : !1;
}
function pino(Ae) {
  Ae = Ae || {}, Ae.browser = Ae.browser || {};
  const t = Ae.browser.transmit;
  if (t && typeof t.send != "function")
    throw Error("pino: transmit option must have a send function");
  const Me = Ae.browser.write || _console;
  Ae.browser.write && (Ae.browser.asObject = !0);
  const Ie = Ae.serializers || {}, Pe = shouldSerialize(Ae.browser.serialize, Ie);
  let Be = Ae.browser.serialize;
  Array.isArray(Ae.browser.serialize) && Ae.browser.serialize.indexOf("!stdSerializers.err") > -1 && (Be = !1);
  const Te = ["error", "fatal", "warn", "info", "debug", "trace"];
  typeof Me == "function" && (Me.error = Me.fatal = Me.warn = Me.info = Me.debug = Me.trace = Me), Ae.enabled === !1 && (Ae.level = "silent");
  const je = Ae.level || "info", Ve = Object.create(Me);
  Ve.log || (Ve.log = noop), Object.defineProperty(Ve, "levelVal", {
    get: Ue
  }), Object.defineProperty(Ve, "level", {
    get: bi,
    set: vi
  });
  const fi = {
    transmit: t,
    serialize: Pe,
    asObject: Ae.browser.asObject,
    levels: Te,
    timestamp: getTimeFunction(Ae)
  };
  Ve.levels = pino.levels, Ve.level = je, Ve.setMaxListeners = Ve.getMaxListeners = Ve.emit = Ve.addListener = Ve.on = Ve.prependListener = Ve.once = Ve.prependOnceListener = Ve.removeListener = Ve.removeAllListeners = Ve.listeners = Ve.listenerCount = Ve.eventNames = Ve.write = Ve.flush = noop, Ve.serializers = Ie, Ve._serialize = Pe, Ve._stdErrSerialize = Be, Ve.child = mi, t && (Ve._logEvent = createLogEventShape());
  function Ue() {
    return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
  }
  function bi() {
    return this._level;
  }
  function vi(_i) {
    if (_i !== "silent" && !this.levels.values[_i])
      throw Error("unknown level " + _i);
    this._level = _i, set(fi, Ve, "error", "log"), set(fi, Ve, "fatal", "error"), set(fi, Ve, "warn", "error"), set(fi, Ve, "info", "log"), set(fi, Ve, "debug", "log"), set(fi, Ve, "trace", "log");
  }
  function mi(_i, $i) {
    if (!_i)
      throw new Error("missing bindings for child Pino");
    $i = $i || {}, Pe && _i.serializers && ($i.serializers = _i.serializers);
    const Ci = $i.serializers;
    if (Pe && Ci) {
      var Ui = Object.assign({}, Ie, Ci), ki = Ae.browser.serialize === !0 ? Object.keys(Ui) : Pe;
      delete _i.serializers, applySerializers([_i], ki, Ui, this._stdErrSerialize);
    }
    function Ji(Hi) {
      this._childLevel = (Hi._childLevel | 0) + 1, this.error = bind(Hi, _i, "error"), this.fatal = bind(Hi, _i, "fatal"), this.warn = bind(Hi, _i, "warn"), this.info = bind(Hi, _i, "info"), this.debug = bind(Hi, _i, "debug"), this.trace = bind(Hi, _i, "trace"), Ui && (this.serializers = Ui, this._serialize = ki), t && (this._logEvent = createLogEventShape(
        [].concat(Hi._logEvent.bindings, _i)
      ));
    }
    return Ji.prototype = this, new Ji(this);
  }
  return Ve;
}
pino.levels = {
  values: {
    fatal: 60,
    error: 50,
    warn: 40,
    info: 30,
    debug: 20,
    trace: 10
  },
  labels: {
    10: "trace",
    20: "debug",
    30: "info",
    40: "warn",
    50: "error",
    60: "fatal"
  }
};
pino.stdSerializers = stdSerializers;
pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
function set(Ae, t, Me, Ie) {
  const Pe = Object.getPrototypeOf(t);
  t[Me] = t.levelVal > t.levels.values[Me] ? noop : Pe[Me] ? Pe[Me] : _console[Me] || _console[Ie] || noop, wrap(Ae, t, Me);
}
function wrap(Ae, t, Me) {
  !Ae.transmit && t[Me] === noop || (t[Me] = /* @__PURE__ */ function(Ie) {
    return function() {
      const Be = Ae.timestamp(), Te = new Array(arguments.length), je = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
      for (var Ve = 0; Ve < Te.length; Ve++) Te[Ve] = arguments[Ve];
      if (Ae.serialize && !Ae.asObject && applySerializers(Te, this._serialize, this.serializers, this._stdErrSerialize), Ae.asObject ? Ie.call(je, asObject(this, Me, Te, Be)) : Ie.apply(je, Te), Ae.transmit) {
        const fi = Ae.transmit.level || t.level, Ue = pino.levels.values[fi], bi = pino.levels.values[Me];
        if (bi < Ue) return;
        transmit(this, {
          ts: Be,
          methodLevel: Me,
          methodValue: bi,
          transmitLevel: fi,
          transmitValue: pino.levels.values[Ae.transmit.level || t.level],
          send: Ae.transmit.send,
          val: t.levelVal
        }, Te);
      }
    };
  }(t[Me]));
}
function asObject(Ae, t, Me, Ie) {
  Ae._serialize && applySerializers(Me, Ae._serialize, Ae.serializers, Ae._stdErrSerialize);
  const Pe = Me.slice();
  let Be = Pe[0];
  const Te = {};
  Ie && (Te.time = Ie), Te.level = pino.levels.values[t];
  let je = (Ae._childLevel | 0) + 1;
  if (je < 1 && (je = 1), Be !== null && typeof Be == "object") {
    for (; je-- && typeof Pe[0] == "object"; )
      Object.assign(Te, Pe.shift());
    Be = Pe.length ? format(Pe.shift(), Pe) : void 0;
  } else typeof Be == "string" && (Be = format(Pe.shift(), Pe));
  return Be !== void 0 && (Te.msg = Be), Te;
}
function applySerializers(Ae, t, Me, Ie) {
  for (const Pe in Ae)
    if (Ie && Ae[Pe] instanceof Error)
      Ae[Pe] = pino.stdSerializers.err(Ae[Pe]);
    else if (typeof Ae[Pe] == "object" && !Array.isArray(Ae[Pe]))
      for (const Be in Ae[Pe])
        t && t.indexOf(Be) > -1 && Be in Me && (Ae[Pe][Be] = Me[Be](Ae[Pe][Be]));
}
function bind(Ae, t, Me) {
  return function() {
    const Ie = new Array(1 + arguments.length);
    Ie[0] = t;
    for (var Pe = 1; Pe < Ie.length; Pe++)
      Ie[Pe] = arguments[Pe - 1];
    return Ae[Me].apply(this, Ie);
  };
}
function transmit(Ae, t, Me) {
  const Ie = t.send, Pe = t.ts, Be = t.methodLevel, Te = t.methodValue, je = t.val, Ve = Ae._logEvent.bindings;
  applySerializers(
    Me,
    Ae._serialize || Object.keys(Ae.serializers),
    Ae.serializers,
    Ae._stdErrSerialize === void 0 ? !0 : Ae._stdErrSerialize
  ), Ae._logEvent.ts = Pe, Ae._logEvent.messages = Me.filter(function(fi) {
    return Ve.indexOf(fi) === -1;
  }), Ae._logEvent.level.label = Be, Ae._logEvent.level.value = Te, Ie(Be, Ae._logEvent, je), Ae._logEvent = createLogEventShape(Ve);
}
function createLogEventShape(Ae) {
  return {
    ts: 0,
    messages: [],
    bindings: Ae || [],
    level: { label: "", value: 0 }
  };
}
function asErrValue(Ae) {
  const t = {
    type: Ae.constructor.name,
    msg: Ae.message,
    stack: Ae.stack
  };
  for (const Me in Ae)
    t[Me] === void 0 && (t[Me] = Ae[Me]);
  return t;
}
function getTimeFunction(Ae) {
  return typeof Ae.timestamp == "function" ? Ae.timestamp : Ae.timestamp === !1 ? nullTime : epochTime;
}
function mock() {
  return {};
}
function passthrough(Ae) {
  return Ae;
}
function noop() {
}
function nullTime() {
  return !1;
}
function epochTime() {
  return Date.now();
}
function unixTime() {
  return Math.round(Date.now() / 1e3);
}
function isoTime() {
  return new Date(Date.now()).toISOString();
}
function pfGlobalThisOrFallback() {
  function Ae(t) {
    return typeof t < "u" && t;
  }
  try {
    return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
      get: function() {
        return delete Object.prototype.globalThis, this.globalThis = this;
      },
      configurable: !0
    }), globalThis;
  } catch {
    return Ae(self) || Ae(window) || Ae(this) || {};
  }
}
const qt$3 = /* @__PURE__ */ getDefaultExportFromCjs(browser$2), c$1 = { level: "info" }, n$2 = "custom_context", l$1 = 1e3 * 1024;
let O$4 = class {
  constructor(t) {
    this.nodeValue = t, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
}, d$2 = class {
  constructor(t) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = t, this.sizeInBytes = 0;
  }
  append(t) {
    const Me = new O$4(t);
    if (Me.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${t} with size ${Me.size}`);
    for (; this.size + Me.size > this.maxSizeInBytes; ) this.shift();
    this.head ? (this.tail && (this.tail.next = Me), this.tail = Me) : (this.head = Me, this.tail = Me), this.lengthInNodes++, this.sizeInBytes += Me.size;
  }
  shift() {
    if (!this.head) return;
    const t = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= t.size;
  }
  toArray() {
    const t = [];
    let Me = this.head;
    for (; Me !== null; ) t.push(Me.value), Me = Me.next;
    return t;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let t = this.head;
    return { next: () => {
      if (!t) return { done: !0, value: null };
      const Me = t.value;
      return t = t.next, { done: !1, value: Me };
    } };
  }
}, L$3 = class {
  constructor(t, Me = l$1) {
    this.level = t ?? "error", this.levelValue = browser$2.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = Me, this.logs = new d$2(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(t, Me) {
    Me === browser$2.levels.values.error ? console.error(t) : Me === browser$2.levels.values.warn ? console.warn(t) : Me === browser$2.levels.values.debug ? console.debug(t) : Me === browser$2.levels.values.trace ? console.trace(t) : console.log(t);
  }
  appendToLogs(t) {
    this.logs.append(safeJsonStringify({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: t }));
    const Me = typeof t == "string" ? JSON.parse(t).level : t.level;
    Me >= this.levelValue && this.forwardToConsole(t, Me);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new d$2(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(t) {
    const Me = this.getLogArray();
    return Me.push(safeJsonStringify({ extraMetadata: t })), new Blob(Me, { type: "application/json" });
  }
};
class m {
  constructor(t, Me = l$1) {
    this.baseChunkLogger = new L$3(t, Me);
  }
  write(t) {
    this.baseChunkLogger.appendToLogs(t);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(t) {
    return this.baseChunkLogger.logsToBlob(t);
  }
  downloadLogsBlobInBrowser(t) {
    const Me = URL.createObjectURL(this.logsToBlob(t)), Ie = document.createElement("a");
    Ie.href = Me, Ie.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(Ie), Ie.click(), document.body.removeChild(Ie), URL.revokeObjectURL(Me);
  }
}
let B$3 = class {
  constructor(t, Me = l$1) {
    this.baseChunkLogger = new L$3(t, Me);
  }
  write(t) {
    this.baseChunkLogger.appendToLogs(t);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(t) {
    return this.baseChunkLogger.logsToBlob(t);
  }
};
var x$5 = Object.defineProperty, S$6 = Object.defineProperties, _$2 = Object.getOwnPropertyDescriptors, p$2 = Object.getOwnPropertySymbols, T$2 = Object.prototype.hasOwnProperty, z$5 = Object.prototype.propertyIsEnumerable, f$3 = (Ae, t, Me) => t in Ae ? x$5(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Me }) : Ae[t] = Me, i = (Ae, t) => {
  for (var Me in t || (t = {})) T$2.call(t, Me) && f$3(Ae, Me, t[Me]);
  if (p$2) for (var Me of p$2(t)) z$5.call(t, Me) && f$3(Ae, Me, t[Me]);
  return Ae;
}, g$3 = (Ae, t) => S$6(Ae, _$2(t));
function k$2(Ae) {
  return g$3(i({}, Ae), { level: (Ae == null ? void 0 : Ae.level) || c$1.level });
}
function v$4(Ae, t = n$2) {
  return Ae[t] || "";
}
function b$3(Ae, t, Me = n$2) {
  return Ae[Me] = t, Ae;
}
function y$3(Ae, t = n$2) {
  let Me = "";
  return typeof Ae.bindings > "u" ? Me = v$4(Ae, t) : Me = Ae.bindings().context || "", Me;
}
function w$2(Ae, t, Me = n$2) {
  const Ie = y$3(Ae, Me);
  return Ie.trim() ? `${Ie}/${t}` : t;
}
function E$1(Ae, t, Me = n$2) {
  const Ie = w$2(Ae, t, Me), Pe = Ae.child({ context: Ie });
  return b$3(Pe, Ie, Me);
}
function C$4(Ae) {
  var t, Me;
  const Ie = new m((t = Ae.opts) == null ? void 0 : t.level, Ae.maxSizeInBytes);
  return { logger: qt$3(g$3(i({}, Ae.opts), { level: "trace", browser: g$3(i({}, (Me = Ae.opts) == null ? void 0 : Me.browser), { write: (Pe) => Ie.write(Pe) }) })), chunkLoggerController: Ie };
}
function I$4(Ae) {
  var t;
  const Me = new B$3((t = Ae.opts) == null ? void 0 : t.level, Ae.maxSizeInBytes);
  return { logger: qt$3(g$3(i({}, Ae.opts), { level: "trace" }), Me), chunkLoggerController: Me };
}
function A$1(Ae) {
  return typeof Ae.loggerOverride < "u" && typeof Ae.loggerOverride != "string" ? { logger: Ae.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? C$4(Ae) : I$4(Ae);
}
let n$1 = class extends IEvents {
  constructor(t) {
    super(), this.opts = t, this.protocol = "wc", this.version = 2;
  }
}, h$1 = class extends IEvents {
  constructor(t, Me) {
    super(), this.core = t, this.logger = Me, this.records = /* @__PURE__ */ new Map();
  }
}, a$1 = class {
  constructor(t, Me) {
    this.logger = t, this.core = Me;
  }
}, g$2 = class extends IEvents {
  constructor(t, Me) {
    super(), this.relayer = t, this.logger = Me;
  }
};
class u extends IEvents {
  constructor(t) {
    super();
  }
}
let p$1 = class {
  constructor(t, Me, Ie, Pe) {
    this.core = t, this.logger = Me, this.name = Ie;
  }
}, d$1 = class extends IEvents {
  constructor(t, Me) {
    super(), this.relayer = t, this.logger = Me;
  }
}, x$4 = class extends IEvents {
  constructor(t, Me) {
    super(), this.core = t, this.logger = Me;
  }
}, y$2 = class {
  constructor(t, Me, Ie) {
    this.core = t, this.logger = Me, this.store = Ie;
  }
}, v$3 = class {
  constructor(t, Me) {
    this.projectId = t, this.logger = Me;
  }
}, C$3 = class {
  constructor(t, Me, Ie) {
    this.core = t, this.logger = Me, this.telemetryEnabled = Ie;
  }
}, S$5 = class {
  constructor(t) {
    this.opts = t, this.protocol = "wc", this.version = 2;
  }
}, M$3 = class {
  constructor(t) {
    this.client = t;
  }
};
var ed25519 = {}, random = {}, system = {}, browser$1 = {};
Object.defineProperty(browser$1, "__esModule", { value: !0 });
browser$1.BrowserRandomSource = void 0;
const QUOTA = 65536;
class BrowserRandomSource {
  constructor() {
    this.isAvailable = !1, this.isInstantiated = !1;
    const t = typeof self < "u" ? self.crypto || self.msCrypto : null;
    t && t.getRandomValues !== void 0 && (this._crypto = t, this.isAvailable = !0, this.isInstantiated = !0);
  }
  randomBytes(t) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Browser random byte generator is not available.");
    const Me = new Uint8Array(t);
    for (let Ie = 0; Ie < Me.length; Ie += QUOTA)
      this._crypto.getRandomValues(Me.subarray(Ie, Ie + Math.min(Me.length - Ie, QUOTA)));
    return Me;
  }
}
browser$1.BrowserRandomSource = BrowserRandomSource;
var node = {}, wipe$1 = {};
Object.defineProperty(wipe$1, "__esModule", { value: !0 });
function wipe(Ae) {
  for (var t = 0; t < Ae.length; t++)
    Ae[t] = 0;
  return Ae;
}
wipe$1.wipe = wipe;
Object.defineProperty(node, "__esModule", { value: !0 });
node.NodeRandomSource = void 0;
const wipe_1$3 = wipe$1;
class NodeRandomSource {
  constructor() {
    if (this.isAvailable = !1, this.isInstantiated = !1, typeof commonjsRequire$1 < "u") {
      const t = requireCryptoBrowserify();
      t && t.randomBytes && (this._crypto = t, this.isAvailable = !0, this.isInstantiated = !0);
    }
  }
  randomBytes(t) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Node.js random byte generator is not available.");
    let Me = this._crypto.randomBytes(t);
    if (Me.length !== t)
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    const Ie = new Uint8Array(t);
    for (let Pe = 0; Pe < Ie.length; Pe++)
      Ie[Pe] = Me[Pe];
    return (0, wipe_1$3.wipe)(Me), Ie;
  }
}
node.NodeRandomSource = NodeRandomSource;
Object.defineProperty(system, "__esModule", { value: !0 });
system.SystemRandomSource = void 0;
const browser_1 = browser$1, node_1 = node;
class SystemRandomSource {
  constructor() {
    if (this.isAvailable = !1, this.name = "", this._source = new browser_1.BrowserRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Browser";
      return;
    }
    if (this._source = new node_1.NodeRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Node";
      return;
    }
  }
  randomBytes(t) {
    if (!this.isAvailable)
      throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(t);
  }
}
system.SystemRandomSource = SystemRandomSource;
var binary = {}, int = {};
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  function t(je, Ve) {
    var fi = je >>> 16 & 65535, Ue = je & 65535, bi = Ve >>> 16 & 65535, vi = Ve & 65535;
    return Ue * vi + (fi * vi + Ue * bi << 16 >>> 0) | 0;
  }
  Ae.mul = Math.imul || t;
  function Me(je, Ve) {
    return je + Ve | 0;
  }
  Ae.add = Me;
  function Ie(je, Ve) {
    return je - Ve | 0;
  }
  Ae.sub = Ie;
  function Pe(je, Ve) {
    return je << Ve | je >>> 32 - Ve;
  }
  Ae.rotl = Pe;
  function Be(je, Ve) {
    return je << 32 - Ve | je >>> Ve;
  }
  Ae.rotr = Be;
  function Te(je) {
    return typeof je == "number" && isFinite(je) && Math.floor(je) === je;
  }
  Ae.isInteger = Number.isInteger || Te, Ae.MAX_SAFE_INTEGER = 9007199254740991, Ae.isSafeInteger = function(je) {
    return Ae.isInteger(je) && je >= -Ae.MAX_SAFE_INTEGER && je <= Ae.MAX_SAFE_INTEGER;
  };
})(int);
Object.defineProperty(binary, "__esModule", { value: !0 });
var int_1 = int;
function readInt16BE(Ae, t) {
  return t === void 0 && (t = 0), (Ae[t + 0] << 8 | Ae[t + 1]) << 16 >> 16;
}
binary.readInt16BE = readInt16BE;
function readUint16BE(Ae, t) {
  return t === void 0 && (t = 0), (Ae[t + 0] << 8 | Ae[t + 1]) >>> 0;
}
binary.readUint16BE = readUint16BE;
function readInt16LE(Ae, t) {
  return t === void 0 && (t = 0), (Ae[t + 1] << 8 | Ae[t]) << 16 >> 16;
}
binary.readInt16LE = readInt16LE;
function readUint16LE(Ae, t) {
  return t === void 0 && (t = 0), (Ae[t + 1] << 8 | Ae[t]) >>> 0;
}
binary.readUint16LE = readUint16LE;
function writeUint16BE(Ae, t, Me) {
  return t === void 0 && (t = new Uint8Array(2)), Me === void 0 && (Me = 0), t[Me + 0] = Ae >>> 8, t[Me + 1] = Ae >>> 0, t;
}
binary.writeUint16BE = writeUint16BE;
binary.writeInt16BE = writeUint16BE;
function writeUint16LE(Ae, t, Me) {
  return t === void 0 && (t = new Uint8Array(2)), Me === void 0 && (Me = 0), t[Me + 0] = Ae >>> 0, t[Me + 1] = Ae >>> 8, t;
}
binary.writeUint16LE = writeUint16LE;
binary.writeInt16LE = writeUint16LE;
function readInt32BE(Ae, t) {
  return t === void 0 && (t = 0), Ae[t] << 24 | Ae[t + 1] << 16 | Ae[t + 2] << 8 | Ae[t + 3];
}
binary.readInt32BE = readInt32BE;
function readUint32BE(Ae, t) {
  return t === void 0 && (t = 0), (Ae[t] << 24 | Ae[t + 1] << 16 | Ae[t + 2] << 8 | Ae[t + 3]) >>> 0;
}
binary.readUint32BE = readUint32BE;
function readInt32LE(Ae, t) {
  return t === void 0 && (t = 0), Ae[t + 3] << 24 | Ae[t + 2] << 16 | Ae[t + 1] << 8 | Ae[t];
}
binary.readInt32LE = readInt32LE;
function readUint32LE(Ae, t) {
  return t === void 0 && (t = 0), (Ae[t + 3] << 24 | Ae[t + 2] << 16 | Ae[t + 1] << 8 | Ae[t]) >>> 0;
}
binary.readUint32LE = readUint32LE;
function writeUint32BE(Ae, t, Me) {
  return t === void 0 && (t = new Uint8Array(4)), Me === void 0 && (Me = 0), t[Me + 0] = Ae >>> 24, t[Me + 1] = Ae >>> 16, t[Me + 2] = Ae >>> 8, t[Me + 3] = Ae >>> 0, t;
}
binary.writeUint32BE = writeUint32BE;
binary.writeInt32BE = writeUint32BE;
function writeUint32LE(Ae, t, Me) {
  return t === void 0 && (t = new Uint8Array(4)), Me === void 0 && (Me = 0), t[Me + 0] = Ae >>> 0, t[Me + 1] = Ae >>> 8, t[Me + 2] = Ae >>> 16, t[Me + 3] = Ae >>> 24, t;
}
binary.writeUint32LE = writeUint32LE;
binary.writeInt32LE = writeUint32LE;
function readInt64BE(Ae, t) {
  t === void 0 && (t = 0);
  var Me = readInt32BE(Ae, t), Ie = readInt32BE(Ae, t + 4);
  return Me * 4294967296 + Ie - (Ie >> 31) * 4294967296;
}
binary.readInt64BE = readInt64BE;
function readUint64BE(Ae, t) {
  t === void 0 && (t = 0);
  var Me = readUint32BE(Ae, t), Ie = readUint32BE(Ae, t + 4);
  return Me * 4294967296 + Ie;
}
binary.readUint64BE = readUint64BE;
function readInt64LE(Ae, t) {
  t === void 0 && (t = 0);
  var Me = readInt32LE(Ae, t), Ie = readInt32LE(Ae, t + 4);
  return Ie * 4294967296 + Me - (Me >> 31) * 4294967296;
}
binary.readInt64LE = readInt64LE;
function readUint64LE(Ae, t) {
  t === void 0 && (t = 0);
  var Me = readUint32LE(Ae, t), Ie = readUint32LE(Ae, t + 4);
  return Ie * 4294967296 + Me;
}
binary.readUint64LE = readUint64LE;
function writeUint64BE(Ae, t, Me) {
  return t === void 0 && (t = new Uint8Array(8)), Me === void 0 && (Me = 0), writeUint32BE(Ae / 4294967296 >>> 0, t, Me), writeUint32BE(Ae >>> 0, t, Me + 4), t;
}
binary.writeUint64BE = writeUint64BE;
binary.writeInt64BE = writeUint64BE;
function writeUint64LE(Ae, t, Me) {
  return t === void 0 && (t = new Uint8Array(8)), Me === void 0 && (Me = 0), writeUint32LE(Ae >>> 0, t, Me), writeUint32LE(Ae / 4294967296 >>> 0, t, Me + 4), t;
}
binary.writeUint64LE = writeUint64LE;
binary.writeInt64LE = writeUint64LE;
function readUintBE(Ae, t, Me) {
  if (Me === void 0 && (Me = 0), Ae % 8 !== 0)
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (Ae / 8 > t.length - Me)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var Ie = 0, Pe = 1, Be = Ae / 8 + Me - 1; Be >= Me; Be--)
    Ie += t[Be] * Pe, Pe *= 256;
  return Ie;
}
binary.readUintBE = readUintBE;
function readUintLE(Ae, t, Me) {
  if (Me === void 0 && (Me = 0), Ae % 8 !== 0)
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (Ae / 8 > t.length - Me)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var Ie = 0, Pe = 1, Be = Me; Be < Me + Ae / 8; Be++)
    Ie += t[Be] * Pe, Pe *= 256;
  return Ie;
}
binary.readUintLE = readUintLE;
function writeUintBE(Ae, t, Me, Ie) {
  if (Me === void 0 && (Me = new Uint8Array(Ae / 8)), Ie === void 0 && (Ie = 0), Ae % 8 !== 0)
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!int_1.isSafeInteger(t))
    throw new Error("writeUintBE value must be an integer");
  for (var Pe = 1, Be = Ae / 8 + Ie - 1; Be >= Ie; Be--)
    Me[Be] = t / Pe & 255, Pe *= 256;
  return Me;
}
binary.writeUintBE = writeUintBE;
function writeUintLE(Ae, t, Me, Ie) {
  if (Me === void 0 && (Me = new Uint8Array(Ae / 8)), Ie === void 0 && (Ie = 0), Ae % 8 !== 0)
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!int_1.isSafeInteger(t))
    throw new Error("writeUintLE value must be an integer");
  for (var Pe = 1, Be = Ie; Be < Ie + Ae / 8; Be++)
    Me[Be] = t / Pe & 255, Pe *= 256;
  return Me;
}
binary.writeUintLE = writeUintLE;
function readFloat32BE(Ae, t) {
  t === void 0 && (t = 0);
  var Me = new DataView(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  return Me.getFloat32(t);
}
binary.readFloat32BE = readFloat32BE;
function readFloat32LE(Ae, t) {
  t === void 0 && (t = 0);
  var Me = new DataView(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  return Me.getFloat32(t, !0);
}
binary.readFloat32LE = readFloat32LE;
function readFloat64BE(Ae, t) {
  t === void 0 && (t = 0);
  var Me = new DataView(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  return Me.getFloat64(t);
}
binary.readFloat64BE = readFloat64BE;
function readFloat64LE(Ae, t) {
  t === void 0 && (t = 0);
  var Me = new DataView(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  return Me.getFloat64(t, !0);
}
binary.readFloat64LE = readFloat64LE;
function writeFloat32BE(Ae, t, Me) {
  t === void 0 && (t = new Uint8Array(4)), Me === void 0 && (Me = 0);
  var Ie = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return Ie.setFloat32(Me, Ae), t;
}
binary.writeFloat32BE = writeFloat32BE;
function writeFloat32LE(Ae, t, Me) {
  t === void 0 && (t = new Uint8Array(4)), Me === void 0 && (Me = 0);
  var Ie = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return Ie.setFloat32(Me, Ae, !0), t;
}
binary.writeFloat32LE = writeFloat32LE;
function writeFloat64BE(Ae, t, Me) {
  t === void 0 && (t = new Uint8Array(8)), Me === void 0 && (Me = 0);
  var Ie = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return Ie.setFloat64(Me, Ae), t;
}
binary.writeFloat64BE = writeFloat64BE;
function writeFloat64LE(Ae, t, Me) {
  t === void 0 && (t = new Uint8Array(8)), Me === void 0 && (Me = 0);
  var Ie = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return Ie.setFloat64(Me, Ae, !0), t;
}
binary.writeFloat64LE = writeFloat64LE;
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 }), Ae.randomStringForEntropy = Ae.randomString = Ae.randomUint32 = Ae.randomBytes = Ae.defaultRandomSource = void 0;
  const t = system, Me = binary, Ie = wipe$1;
  Ae.defaultRandomSource = new t.SystemRandomSource();
  function Pe(fi, Ue = Ae.defaultRandomSource) {
    return Ue.randomBytes(fi);
  }
  Ae.randomBytes = Pe;
  function Be(fi = Ae.defaultRandomSource) {
    const Ue = Pe(4, fi), bi = (0, Me.readUint32LE)(Ue);
    return (0, Ie.wipe)(Ue), bi;
  }
  Ae.randomUint32 = Be;
  const Te = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function je(fi, Ue = Te, bi = Ae.defaultRandomSource) {
    if (Ue.length < 2)
      throw new Error("randomString charset is too short");
    if (Ue.length > 256)
      throw new Error("randomString charset is too long");
    let vi = "";
    const mi = Ue.length, _i = 256 - 256 % mi;
    for (; fi > 0; ) {
      const $i = Pe(Math.ceil(fi * 256 / _i), bi);
      for (let Ci = 0; Ci < $i.length && fi > 0; Ci++) {
        const Ui = $i[Ci];
        Ui < _i && (vi += Ue.charAt(Ui % mi), fi--);
      }
      (0, Ie.wipe)($i);
    }
    return vi;
  }
  Ae.randomString = je;
  function Ve(fi, Ue = Te, bi = Ae.defaultRandomSource) {
    const vi = Math.ceil(fi / (Math.log(Ue.length) / Math.LN2));
    return je(vi, Ue, bi);
  }
  Ae.randomStringForEntropy = Ve;
})(random);
var sha512 = {};
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  var t = binary, Me = wipe$1;
  Ae.DIGEST_LENGTH = 64, Ae.BLOCK_SIZE = 128;
  var Ie = (
    /** @class */
    function() {
      function je() {
        this.digestLength = Ae.DIGEST_LENGTH, this.blockSize = Ae.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return je.prototype._initState = function() {
        this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209;
      }, je.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, je.prototype.clean = function() {
        Me.wipe(this._buffer), Me.wipe(this._tempHi), Me.wipe(this._tempLo), this.reset();
      }, je.prototype.update = function(Ve, fi) {
        if (fi === void 0 && (fi = Ve.length), this._finished)
          throw new Error("SHA512: can't update because hash was finished.");
        var Ue = 0;
        if (this._bytesHashed += fi, this._bufferLength > 0) {
          for (; this._bufferLength < Ae.BLOCK_SIZE && fi > 0; )
            this._buffer[this._bufferLength++] = Ve[Ue++], fi--;
          this._bufferLength === this.blockSize && (Be(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (fi >= this.blockSize && (Ue = Be(this._tempHi, this._tempLo, this._stateHi, this._stateLo, Ve, Ue, fi), fi %= this.blockSize); fi > 0; )
          this._buffer[this._bufferLength++] = Ve[Ue++], fi--;
        return this;
      }, je.prototype.finish = function(Ve) {
        if (!this._finished) {
          var fi = this._bytesHashed, Ue = this._bufferLength, bi = fi / 536870912 | 0, vi = fi << 3, mi = fi % 128 < 112 ? 128 : 256;
          this._buffer[Ue] = 128;
          for (var _i = Ue + 1; _i < mi - 8; _i++)
            this._buffer[_i] = 0;
          t.writeUint32BE(bi, this._buffer, mi - 8), t.writeUint32BE(vi, this._buffer, mi - 4), Be(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, mi), this._finished = !0;
        }
        for (var _i = 0; _i < this.digestLength / 8; _i++)
          t.writeUint32BE(this._stateHi[_i], Ve, _i * 8), t.writeUint32BE(this._stateLo[_i], Ve, _i * 8 + 4);
        return this;
      }, je.prototype.digest = function() {
        var Ve = new Uint8Array(this.digestLength);
        return this.finish(Ve), Ve;
      }, je.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, je.prototype.restoreState = function(Ve) {
        return this._stateHi.set(Ve.stateHi), this._stateLo.set(Ve.stateLo), this._bufferLength = Ve.bufferLength, Ve.buffer && this._buffer.set(Ve.buffer), this._bytesHashed = Ve.bytesHashed, this._finished = !1, this;
      }, je.prototype.cleanSavedState = function(Ve) {
        Me.wipe(Ve.stateHi), Me.wipe(Ve.stateLo), Ve.buffer && Me.wipe(Ve.buffer), Ve.bufferLength = 0, Ve.bytesHashed = 0;
      }, je;
    }()
  );
  Ae.SHA512 = Ie;
  var Pe = new Int32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  function Be(je, Ve, fi, Ue, bi, vi, mi) {
    for (var _i = fi[0], $i = fi[1], Ci = fi[2], Ui = fi[3], ki = fi[4], Ji = fi[5], Hi = fi[6], Zi = fi[7], Qi = Ue[0], Bi = Ue[1], Xi = Ue[2], ns = Ue[3], ls = Ue[4], vn = Ue[5], Mi = Ue[6], Ai = Ue[7], wi, Ei, Ti, Pi, qi, Oi, Si, Ni; mi >= 128; ) {
      for (var xi = 0; xi < 16; xi++) {
        var Wi = 8 * xi + vi;
        je[xi] = t.readUint32BE(bi, Wi), Ve[xi] = t.readUint32BE(bi, Wi + 4);
      }
      for (var xi = 0; xi < 80; xi++) {
        var ts = _i, Ki = $i, fn = Ci, Ii = Ui, Fi = ki, Gi = Ji, Ri = Hi, ji = Zi, Vi = Qi, is = Bi, os = Xi, ds = ns, ps = ls, ea = vn, ia = Mi, hs = Ai;
        if (wi = Zi, Ei = Ai, qi = Ei & 65535, Oi = Ei >>> 16, Si = wi & 65535, Ni = wi >>> 16, wi = (ki >>> 14 | ls << 18) ^ (ki >>> 18 | ls << 14) ^ (ls >>> 9 | ki << 23), Ei = (ls >>> 14 | ki << 18) ^ (ls >>> 18 | ki << 14) ^ (ki >>> 9 | ls << 23), qi += Ei & 65535, Oi += Ei >>> 16, Si += wi & 65535, Ni += wi >>> 16, wi = ki & Ji ^ ~ki & Hi, Ei = ls & vn ^ ~ls & Mi, qi += Ei & 65535, Oi += Ei >>> 16, Si += wi & 65535, Ni += wi >>> 16, wi = Pe[xi * 2], Ei = Pe[xi * 2 + 1], qi += Ei & 65535, Oi += Ei >>> 16, Si += wi & 65535, Ni += wi >>> 16, wi = je[xi % 16], Ei = Ve[xi % 16], qi += Ei & 65535, Oi += Ei >>> 16, Si += wi & 65535, Ni += wi >>> 16, Oi += qi >>> 16, Si += Oi >>> 16, Ni += Si >>> 16, Ti = Si & 65535 | Ni << 16, Pi = qi & 65535 | Oi << 16, wi = Ti, Ei = Pi, qi = Ei & 65535, Oi = Ei >>> 16, Si = wi & 65535, Ni = wi >>> 16, wi = (_i >>> 28 | Qi << 4) ^ (Qi >>> 2 | _i << 30) ^ (Qi >>> 7 | _i << 25), Ei = (Qi >>> 28 | _i << 4) ^ (_i >>> 2 | Qi << 30) ^ (_i >>> 7 | Qi << 25), qi += Ei & 65535, Oi += Ei >>> 16, Si += wi & 65535, Ni += wi >>> 16, wi = _i & $i ^ _i & Ci ^ $i & Ci, Ei = Qi & Bi ^ Qi & Xi ^ Bi & Xi, qi += Ei & 65535, Oi += Ei >>> 16, Si += wi & 65535, Ni += wi >>> 16, Oi += qi >>> 16, Si += Oi >>> 16, Ni += Si >>> 16, ji = Si & 65535 | Ni << 16, hs = qi & 65535 | Oi << 16, wi = Ii, Ei = ds, qi = Ei & 65535, Oi = Ei >>> 16, Si = wi & 65535, Ni = wi >>> 16, wi = Ti, Ei = Pi, qi += Ei & 65535, Oi += Ei >>> 16, Si += wi & 65535, Ni += wi >>> 16, Oi += qi >>> 16, Si += Oi >>> 16, Ni += Si >>> 16, Ii = Si & 65535 | Ni << 16, ds = qi & 65535 | Oi << 16, $i = ts, Ci = Ki, Ui = fn, ki = Ii, Ji = Fi, Hi = Gi, Zi = Ri, _i = ji, Bi = Vi, Xi = is, ns = os, ls = ds, vn = ps, Mi = ea, Ai = ia, Qi = hs, xi % 16 === 15)
          for (var Wi = 0; Wi < 16; Wi++)
            wi = je[Wi], Ei = Ve[Wi], qi = Ei & 65535, Oi = Ei >>> 16, Si = wi & 65535, Ni = wi >>> 16, wi = je[(Wi + 9) % 16], Ei = Ve[(Wi + 9) % 16], qi += Ei & 65535, Oi += Ei >>> 16, Si += wi & 65535, Ni += wi >>> 16, Ti = je[(Wi + 1) % 16], Pi = Ve[(Wi + 1) % 16], wi = (Ti >>> 1 | Pi << 31) ^ (Ti >>> 8 | Pi << 24) ^ Ti >>> 7, Ei = (Pi >>> 1 | Ti << 31) ^ (Pi >>> 8 | Ti << 24) ^ (Pi >>> 7 | Ti << 25), qi += Ei & 65535, Oi += Ei >>> 16, Si += wi & 65535, Ni += wi >>> 16, Ti = je[(Wi + 14) % 16], Pi = Ve[(Wi + 14) % 16], wi = (Ti >>> 19 | Pi << 13) ^ (Pi >>> 29 | Ti << 3) ^ Ti >>> 6, Ei = (Pi >>> 19 | Ti << 13) ^ (Ti >>> 29 | Pi << 3) ^ (Pi >>> 6 | Ti << 26), qi += Ei & 65535, Oi += Ei >>> 16, Si += wi & 65535, Ni += wi >>> 16, Oi += qi >>> 16, Si += Oi >>> 16, Ni += Si >>> 16, je[Wi] = Si & 65535 | Ni << 16, Ve[Wi] = qi & 65535 | Oi << 16;
      }
      wi = _i, Ei = Qi, qi = Ei & 65535, Oi = Ei >>> 16, Si = wi & 65535, Ni = wi >>> 16, wi = fi[0], Ei = Ue[0], qi += Ei & 65535, Oi += Ei >>> 16, Si += wi & 65535, Ni += wi >>> 16, Oi += qi >>> 16, Si += Oi >>> 16, Ni += Si >>> 16, fi[0] = _i = Si & 65535 | Ni << 16, Ue[0] = Qi = qi & 65535 | Oi << 16, wi = $i, Ei = Bi, qi = Ei & 65535, Oi = Ei >>> 16, Si = wi & 65535, Ni = wi >>> 16, wi = fi[1], Ei = Ue[1], qi += Ei & 65535, Oi += Ei >>> 16, Si += wi & 65535, Ni += wi >>> 16, Oi += qi >>> 16, Si += Oi >>> 16, Ni += Si >>> 16, fi[1] = $i = Si & 65535 | Ni << 16, Ue[1] = Bi = qi & 65535 | Oi << 16, wi = Ci, Ei = Xi, qi = Ei & 65535, Oi = Ei >>> 16, Si = wi & 65535, Ni = wi >>> 16, wi = fi[2], Ei = Ue[2], qi += Ei & 65535, Oi += Ei >>> 16, Si += wi & 65535, Ni += wi >>> 16, Oi += qi >>> 16, Si += Oi >>> 16, Ni += Si >>> 16, fi[2] = Ci = Si & 65535 | Ni << 16, Ue[2] = Xi = qi & 65535 | Oi << 16, wi = Ui, Ei = ns, qi = Ei & 65535, Oi = Ei >>> 16, Si = wi & 65535, Ni = wi >>> 16, wi = fi[3], Ei = Ue[3], qi += Ei & 65535, Oi += Ei >>> 16, Si += wi & 65535, Ni += wi >>> 16, Oi += qi >>> 16, Si += Oi >>> 16, Ni += Si >>> 16, fi[3] = Ui = Si & 65535 | Ni << 16, Ue[3] = ns = qi & 65535 | Oi << 16, wi = ki, Ei = ls, qi = Ei & 65535, Oi = Ei >>> 16, Si = wi & 65535, Ni = wi >>> 16, wi = fi[4], Ei = Ue[4], qi += Ei & 65535, Oi += Ei >>> 16, Si += wi & 65535, Ni += wi >>> 16, Oi += qi >>> 16, Si += Oi >>> 16, Ni += Si >>> 16, fi[4] = ki = Si & 65535 | Ni << 16, Ue[4] = ls = qi & 65535 | Oi << 16, wi = Ji, Ei = vn, qi = Ei & 65535, Oi = Ei >>> 16, Si = wi & 65535, Ni = wi >>> 16, wi = fi[5], Ei = Ue[5], qi += Ei & 65535, Oi += Ei >>> 16, Si += wi & 65535, Ni += wi >>> 16, Oi += qi >>> 16, Si += Oi >>> 16, Ni += Si >>> 16, fi[5] = Ji = Si & 65535 | Ni << 16, Ue[5] = vn = qi & 65535 | Oi << 16, wi = Hi, Ei = Mi, qi = Ei & 65535, Oi = Ei >>> 16, Si = wi & 65535, Ni = wi >>> 16, wi = fi[6], Ei = Ue[6], qi += Ei & 65535, Oi += Ei >>> 16, Si += wi & 65535, Ni += wi >>> 16, Oi += qi >>> 16, Si += Oi >>> 16, Ni += Si >>> 16, fi[6] = Hi = Si & 65535 | Ni << 16, Ue[6] = Mi = qi & 65535 | Oi << 16, wi = Zi, Ei = Ai, qi = Ei & 65535, Oi = Ei >>> 16, Si = wi & 65535, Ni = wi >>> 16, wi = fi[7], Ei = Ue[7], qi += Ei & 65535, Oi += Ei >>> 16, Si += wi & 65535, Ni += wi >>> 16, Oi += qi >>> 16, Si += Oi >>> 16, Ni += Si >>> 16, fi[7] = Zi = Si & 65535 | Ni << 16, Ue[7] = Ai = qi & 65535 | Oi << 16, vi += 128, mi -= 128;
    }
    return vi;
  }
  function Te(je) {
    var Ve = new Ie();
    Ve.update(je);
    var fi = Ve.digest();
    return Ve.clean(), fi;
  }
  Ae.hash = Te;
})(sha512);
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 }), Ae.convertSecretKeyToX25519 = Ae.convertPublicKeyToX25519 = Ae.verify = Ae.sign = Ae.extractPublicKeyFromSecretKey = Ae.generateKeyPair = Ae.generateKeyPairFromSeed = Ae.SEED_LENGTH = Ae.SECRET_KEY_LENGTH = Ae.PUBLIC_KEY_LENGTH = Ae.SIGNATURE_LENGTH = void 0;
  const t = random, Me = sha512, Ie = wipe$1;
  Ae.SIGNATURE_LENGTH = 64, Ae.PUBLIC_KEY_LENGTH = 32, Ae.SECRET_KEY_LENGTH = 64, Ae.SEED_LENGTH = 32;
  function Pe(Ii) {
    const Fi = new Float64Array(16);
    if (Ii)
      for (let Gi = 0; Gi < Ii.length; Gi++)
        Fi[Gi] = Ii[Gi];
    return Fi;
  }
  const Be = new Uint8Array(32);
  Be[0] = 9;
  const Te = Pe(), je = Pe([1]), Ve = Pe([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]), fi = Pe([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]), Ue = Pe([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]), bi = Pe([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]), vi = Pe([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function mi(Ii, Fi) {
    for (let Gi = 0; Gi < 16; Gi++)
      Ii[Gi] = Fi[Gi] | 0;
  }
  function _i(Ii) {
    let Fi = 1;
    for (let Gi = 0; Gi < 16; Gi++) {
      let Ri = Ii[Gi] + Fi + 65535;
      Fi = Math.floor(Ri / 65536), Ii[Gi] = Ri - Fi * 65536;
    }
    Ii[0] += Fi - 1 + 37 * (Fi - 1);
  }
  function $i(Ii, Fi, Gi) {
    const Ri = ~(Gi - 1);
    for (let ji = 0; ji < 16; ji++) {
      const Vi = Ri & (Ii[ji] ^ Fi[ji]);
      Ii[ji] ^= Vi, Fi[ji] ^= Vi;
    }
  }
  function Ci(Ii, Fi) {
    const Gi = Pe(), Ri = Pe();
    for (let ji = 0; ji < 16; ji++)
      Ri[ji] = Fi[ji];
    _i(Ri), _i(Ri), _i(Ri);
    for (let ji = 0; ji < 2; ji++) {
      Gi[0] = Ri[0] - 65517;
      for (let is = 1; is < 15; is++)
        Gi[is] = Ri[is] - 65535 - (Gi[is - 1] >> 16 & 1), Gi[is - 1] &= 65535;
      Gi[15] = Ri[15] - 32767 - (Gi[14] >> 16 & 1);
      const Vi = Gi[15] >> 16 & 1;
      Gi[14] &= 65535, $i(Ri, Gi, 1 - Vi);
    }
    for (let ji = 0; ji < 16; ji++)
      Ii[2 * ji] = Ri[ji] & 255, Ii[2 * ji + 1] = Ri[ji] >> 8;
  }
  function Ui(Ii, Fi) {
    let Gi = 0;
    for (let Ri = 0; Ri < 32; Ri++)
      Gi |= Ii[Ri] ^ Fi[Ri];
    return (1 & Gi - 1 >>> 8) - 1;
  }
  function ki(Ii, Fi) {
    const Gi = new Uint8Array(32), Ri = new Uint8Array(32);
    return Ci(Gi, Ii), Ci(Ri, Fi), Ui(Gi, Ri);
  }
  function Ji(Ii) {
    const Fi = new Uint8Array(32);
    return Ci(Fi, Ii), Fi[0] & 1;
  }
  function Hi(Ii, Fi) {
    for (let Gi = 0; Gi < 16; Gi++)
      Ii[Gi] = Fi[2 * Gi] + (Fi[2 * Gi + 1] << 8);
    Ii[15] &= 32767;
  }
  function Zi(Ii, Fi, Gi) {
    for (let Ri = 0; Ri < 16; Ri++)
      Ii[Ri] = Fi[Ri] + Gi[Ri];
  }
  function Qi(Ii, Fi, Gi) {
    for (let Ri = 0; Ri < 16; Ri++)
      Ii[Ri] = Fi[Ri] - Gi[Ri];
  }
  function Bi(Ii, Fi, Gi) {
    let Ri, ji, Vi = 0, is = 0, os = 0, ds = 0, ps = 0, ea = 0, ia = 0, hs = 0, fa = 0, gs = 0, sa = 0, aa = 0, Ds = 0, ra = 0, ca = 0, ta = 0, oa = 0, da = 0, Yi = 0, Li = 0, zi = 0, En = 0, ss = 0, as = 0, us = 0, ua = 0, ma = 0, na = 0, wa = 0, ya = 0, $a = 0, Sa = Gi[0], Ea = Gi[1], la = Gi[2], xa = Gi[3], Aa = Gi[4], ha = Gi[5], Ia = Gi[6], Da = Gi[7], va = Gi[8], Pa = Gi[9], Ba = Gi[10], pa = Gi[11], Ra = Gi[12], _a = Gi[13], ga = Gi[14], Ca = Gi[15];
    Ri = Fi[0], Vi += Ri * Sa, is += Ri * Ea, os += Ri * la, ds += Ri * xa, ps += Ri * Aa, ea += Ri * ha, ia += Ri * Ia, hs += Ri * Da, fa += Ri * va, gs += Ri * Pa, sa += Ri * Ba, aa += Ri * pa, Ds += Ri * Ra, ra += Ri * _a, ca += Ri * ga, ta += Ri * Ca, Ri = Fi[1], is += Ri * Sa, os += Ri * Ea, ds += Ri * la, ps += Ri * xa, ea += Ri * Aa, ia += Ri * ha, hs += Ri * Ia, fa += Ri * Da, gs += Ri * va, sa += Ri * Pa, aa += Ri * Ba, Ds += Ri * pa, ra += Ri * Ra, ca += Ri * _a, ta += Ri * ga, oa += Ri * Ca, Ri = Fi[2], os += Ri * Sa, ds += Ri * Ea, ps += Ri * la, ea += Ri * xa, ia += Ri * Aa, hs += Ri * ha, fa += Ri * Ia, gs += Ri * Da, sa += Ri * va, aa += Ri * Pa, Ds += Ri * Ba, ra += Ri * pa, ca += Ri * Ra, ta += Ri * _a, oa += Ri * ga, da += Ri * Ca, Ri = Fi[3], ds += Ri * Sa, ps += Ri * Ea, ea += Ri * la, ia += Ri * xa, hs += Ri * Aa, fa += Ri * ha, gs += Ri * Ia, sa += Ri * Da, aa += Ri * va, Ds += Ri * Pa, ra += Ri * Ba, ca += Ri * pa, ta += Ri * Ra, oa += Ri * _a, da += Ri * ga, Yi += Ri * Ca, Ri = Fi[4], ps += Ri * Sa, ea += Ri * Ea, ia += Ri * la, hs += Ri * xa, fa += Ri * Aa, gs += Ri * ha, sa += Ri * Ia, aa += Ri * Da, Ds += Ri * va, ra += Ri * Pa, ca += Ri * Ba, ta += Ri * pa, oa += Ri * Ra, da += Ri * _a, Yi += Ri * ga, Li += Ri * Ca, Ri = Fi[5], ea += Ri * Sa, ia += Ri * Ea, hs += Ri * la, fa += Ri * xa, gs += Ri * Aa, sa += Ri * ha, aa += Ri * Ia, Ds += Ri * Da, ra += Ri * va, ca += Ri * Pa, ta += Ri * Ba, oa += Ri * pa, da += Ri * Ra, Yi += Ri * _a, Li += Ri * ga, zi += Ri * Ca, Ri = Fi[6], ia += Ri * Sa, hs += Ri * Ea, fa += Ri * la, gs += Ri * xa, sa += Ri * Aa, aa += Ri * ha, Ds += Ri * Ia, ra += Ri * Da, ca += Ri * va, ta += Ri * Pa, oa += Ri * Ba, da += Ri * pa, Yi += Ri * Ra, Li += Ri * _a, zi += Ri * ga, En += Ri * Ca, Ri = Fi[7], hs += Ri * Sa, fa += Ri * Ea, gs += Ri * la, sa += Ri * xa, aa += Ri * Aa, Ds += Ri * ha, ra += Ri * Ia, ca += Ri * Da, ta += Ri * va, oa += Ri * Pa, da += Ri * Ba, Yi += Ri * pa, Li += Ri * Ra, zi += Ri * _a, En += Ri * ga, ss += Ri * Ca, Ri = Fi[8], fa += Ri * Sa, gs += Ri * Ea, sa += Ri * la, aa += Ri * xa, Ds += Ri * Aa, ra += Ri * ha, ca += Ri * Ia, ta += Ri * Da, oa += Ri * va, da += Ri * Pa, Yi += Ri * Ba, Li += Ri * pa, zi += Ri * Ra, En += Ri * _a, ss += Ri * ga, as += Ri * Ca, Ri = Fi[9], gs += Ri * Sa, sa += Ri * Ea, aa += Ri * la, Ds += Ri * xa, ra += Ri * Aa, ca += Ri * ha, ta += Ri * Ia, oa += Ri * Da, da += Ri * va, Yi += Ri * Pa, Li += Ri * Ba, zi += Ri * pa, En += Ri * Ra, ss += Ri * _a, as += Ri * ga, us += Ri * Ca, Ri = Fi[10], sa += Ri * Sa, aa += Ri * Ea, Ds += Ri * la, ra += Ri * xa, ca += Ri * Aa, ta += Ri * ha, oa += Ri * Ia, da += Ri * Da, Yi += Ri * va, Li += Ri * Pa, zi += Ri * Ba, En += Ri * pa, ss += Ri * Ra, as += Ri * _a, us += Ri * ga, ua += Ri * Ca, Ri = Fi[11], aa += Ri * Sa, Ds += Ri * Ea, ra += Ri * la, ca += Ri * xa, ta += Ri * Aa, oa += Ri * ha, da += Ri * Ia, Yi += Ri * Da, Li += Ri * va, zi += Ri * Pa, En += Ri * Ba, ss += Ri * pa, as += Ri * Ra, us += Ri * _a, ua += Ri * ga, ma += Ri * Ca, Ri = Fi[12], Ds += Ri * Sa, ra += Ri * Ea, ca += Ri * la, ta += Ri * xa, oa += Ri * Aa, da += Ri * ha, Yi += Ri * Ia, Li += Ri * Da, zi += Ri * va, En += Ri * Pa, ss += Ri * Ba, as += Ri * pa, us += Ri * Ra, ua += Ri * _a, ma += Ri * ga, na += Ri * Ca, Ri = Fi[13], ra += Ri * Sa, ca += Ri * Ea, ta += Ri * la, oa += Ri * xa, da += Ri * Aa, Yi += Ri * ha, Li += Ri * Ia, zi += Ri * Da, En += Ri * va, ss += Ri * Pa, as += Ri * Ba, us += Ri * pa, ua += Ri * Ra, ma += Ri * _a, na += Ri * ga, wa += Ri * Ca, Ri = Fi[14], ca += Ri * Sa, ta += Ri * Ea, oa += Ri * la, da += Ri * xa, Yi += Ri * Aa, Li += Ri * ha, zi += Ri * Ia, En += Ri * Da, ss += Ri * va, as += Ri * Pa, us += Ri * Ba, ua += Ri * pa, ma += Ri * Ra, na += Ri * _a, wa += Ri * ga, ya += Ri * Ca, Ri = Fi[15], ta += Ri * Sa, oa += Ri * Ea, da += Ri * la, Yi += Ri * xa, Li += Ri * Aa, zi += Ri * ha, En += Ri * Ia, ss += Ri * Da, as += Ri * va, us += Ri * Pa, ua += Ri * Ba, ma += Ri * pa, na += Ri * Ra, wa += Ri * _a, ya += Ri * ga, $a += Ri * Ca, Vi += 38 * oa, is += 38 * da, os += 38 * Yi, ds += 38 * Li, ps += 38 * zi, ea += 38 * En, ia += 38 * ss, hs += 38 * as, fa += 38 * us, gs += 38 * ua, sa += 38 * ma, aa += 38 * na, Ds += 38 * wa, ra += 38 * ya, ca += 38 * $a, ji = 1, Ri = Vi + ji + 65535, ji = Math.floor(Ri / 65536), Vi = Ri - ji * 65536, Ri = is + ji + 65535, ji = Math.floor(Ri / 65536), is = Ri - ji * 65536, Ri = os + ji + 65535, ji = Math.floor(Ri / 65536), os = Ri - ji * 65536, Ri = ds + ji + 65535, ji = Math.floor(Ri / 65536), ds = Ri - ji * 65536, Ri = ps + ji + 65535, ji = Math.floor(Ri / 65536), ps = Ri - ji * 65536, Ri = ea + ji + 65535, ji = Math.floor(Ri / 65536), ea = Ri - ji * 65536, Ri = ia + ji + 65535, ji = Math.floor(Ri / 65536), ia = Ri - ji * 65536, Ri = hs + ji + 65535, ji = Math.floor(Ri / 65536), hs = Ri - ji * 65536, Ri = fa + ji + 65535, ji = Math.floor(Ri / 65536), fa = Ri - ji * 65536, Ri = gs + ji + 65535, ji = Math.floor(Ri / 65536), gs = Ri - ji * 65536, Ri = sa + ji + 65535, ji = Math.floor(Ri / 65536), sa = Ri - ji * 65536, Ri = aa + ji + 65535, ji = Math.floor(Ri / 65536), aa = Ri - ji * 65536, Ri = Ds + ji + 65535, ji = Math.floor(Ri / 65536), Ds = Ri - ji * 65536, Ri = ra + ji + 65535, ji = Math.floor(Ri / 65536), ra = Ri - ji * 65536, Ri = ca + ji + 65535, ji = Math.floor(Ri / 65536), ca = Ri - ji * 65536, Ri = ta + ji + 65535, ji = Math.floor(Ri / 65536), ta = Ri - ji * 65536, Vi += ji - 1 + 37 * (ji - 1), ji = 1, Ri = Vi + ji + 65535, ji = Math.floor(Ri / 65536), Vi = Ri - ji * 65536, Ri = is + ji + 65535, ji = Math.floor(Ri / 65536), is = Ri - ji * 65536, Ri = os + ji + 65535, ji = Math.floor(Ri / 65536), os = Ri - ji * 65536, Ri = ds + ji + 65535, ji = Math.floor(Ri / 65536), ds = Ri - ji * 65536, Ri = ps + ji + 65535, ji = Math.floor(Ri / 65536), ps = Ri - ji * 65536, Ri = ea + ji + 65535, ji = Math.floor(Ri / 65536), ea = Ri - ji * 65536, Ri = ia + ji + 65535, ji = Math.floor(Ri / 65536), ia = Ri - ji * 65536, Ri = hs + ji + 65535, ji = Math.floor(Ri / 65536), hs = Ri - ji * 65536, Ri = fa + ji + 65535, ji = Math.floor(Ri / 65536), fa = Ri - ji * 65536, Ri = gs + ji + 65535, ji = Math.floor(Ri / 65536), gs = Ri - ji * 65536, Ri = sa + ji + 65535, ji = Math.floor(Ri / 65536), sa = Ri - ji * 65536, Ri = aa + ji + 65535, ji = Math.floor(Ri / 65536), aa = Ri - ji * 65536, Ri = Ds + ji + 65535, ji = Math.floor(Ri / 65536), Ds = Ri - ji * 65536, Ri = ra + ji + 65535, ji = Math.floor(Ri / 65536), ra = Ri - ji * 65536, Ri = ca + ji + 65535, ji = Math.floor(Ri / 65536), ca = Ri - ji * 65536, Ri = ta + ji + 65535, ji = Math.floor(Ri / 65536), ta = Ri - ji * 65536, Vi += ji - 1 + 37 * (ji - 1), Ii[0] = Vi, Ii[1] = is, Ii[2] = os, Ii[3] = ds, Ii[4] = ps, Ii[5] = ea, Ii[6] = ia, Ii[7] = hs, Ii[8] = fa, Ii[9] = gs, Ii[10] = sa, Ii[11] = aa, Ii[12] = Ds, Ii[13] = ra, Ii[14] = ca, Ii[15] = ta;
  }
  function Xi(Ii, Fi) {
    Bi(Ii, Fi, Fi);
  }
  function ns(Ii, Fi) {
    const Gi = Pe();
    let Ri;
    for (Ri = 0; Ri < 16; Ri++)
      Gi[Ri] = Fi[Ri];
    for (Ri = 253; Ri >= 0; Ri--)
      Xi(Gi, Gi), Ri !== 2 && Ri !== 4 && Bi(Gi, Gi, Fi);
    for (Ri = 0; Ri < 16; Ri++)
      Ii[Ri] = Gi[Ri];
  }
  function ls(Ii, Fi) {
    const Gi = Pe();
    let Ri;
    for (Ri = 0; Ri < 16; Ri++)
      Gi[Ri] = Fi[Ri];
    for (Ri = 250; Ri >= 0; Ri--)
      Xi(Gi, Gi), Ri !== 1 && Bi(Gi, Gi, Fi);
    for (Ri = 0; Ri < 16; Ri++)
      Ii[Ri] = Gi[Ri];
  }
  function vn(Ii, Fi) {
    const Gi = Pe(), Ri = Pe(), ji = Pe(), Vi = Pe(), is = Pe(), os = Pe(), ds = Pe(), ps = Pe(), ea = Pe();
    Qi(Gi, Ii[1], Ii[0]), Qi(ea, Fi[1], Fi[0]), Bi(Gi, Gi, ea), Zi(Ri, Ii[0], Ii[1]), Zi(ea, Fi[0], Fi[1]), Bi(Ri, Ri, ea), Bi(ji, Ii[3], Fi[3]), Bi(ji, ji, fi), Bi(Vi, Ii[2], Fi[2]), Zi(Vi, Vi, Vi), Qi(is, Ri, Gi), Qi(os, Vi, ji), Zi(ds, Vi, ji), Zi(ps, Ri, Gi), Bi(Ii[0], is, os), Bi(Ii[1], ps, ds), Bi(Ii[2], ds, os), Bi(Ii[3], is, ps);
  }
  function Mi(Ii, Fi, Gi) {
    for (let Ri = 0; Ri < 4; Ri++)
      $i(Ii[Ri], Fi[Ri], Gi);
  }
  function Ai(Ii, Fi) {
    const Gi = Pe(), Ri = Pe(), ji = Pe();
    ns(ji, Fi[2]), Bi(Gi, Fi[0], ji), Bi(Ri, Fi[1], ji), Ci(Ii, Ri), Ii[31] ^= Ji(Gi) << 7;
  }
  function wi(Ii, Fi, Gi) {
    mi(Ii[0], Te), mi(Ii[1], je), mi(Ii[2], je), mi(Ii[3], Te);
    for (let Ri = 255; Ri >= 0; --Ri) {
      const ji = Gi[Ri / 8 | 0] >> (Ri & 7) & 1;
      Mi(Ii, Fi, ji), vn(Fi, Ii), vn(Ii, Ii), Mi(Ii, Fi, ji);
    }
  }
  function Ei(Ii, Fi) {
    const Gi = [Pe(), Pe(), Pe(), Pe()];
    mi(Gi[0], Ue), mi(Gi[1], bi), mi(Gi[2], je), Bi(Gi[3], Ue, bi), wi(Ii, Gi, Fi);
  }
  function Ti(Ii) {
    if (Ii.length !== Ae.SEED_LENGTH)
      throw new Error(`ed25519: seed must be ${Ae.SEED_LENGTH} bytes`);
    const Fi = (0, Me.hash)(Ii);
    Fi[0] &= 248, Fi[31] &= 127, Fi[31] |= 64;
    const Gi = new Uint8Array(32), Ri = [Pe(), Pe(), Pe(), Pe()];
    Ei(Ri, Fi), Ai(Gi, Ri);
    const ji = new Uint8Array(64);
    return ji.set(Ii), ji.set(Gi, 32), {
      publicKey: Gi,
      secretKey: ji
    };
  }
  Ae.generateKeyPairFromSeed = Ti;
  function Pi(Ii) {
    const Fi = (0, t.randomBytes)(32, Ii), Gi = Ti(Fi);
    return (0, Ie.wipe)(Fi), Gi;
  }
  Ae.generateKeyPair = Pi;
  function qi(Ii) {
    if (Ii.length !== Ae.SECRET_KEY_LENGTH)
      throw new Error(`ed25519: secret key must be ${Ae.SECRET_KEY_LENGTH} bytes`);
    return new Uint8Array(Ii.subarray(32));
  }
  Ae.extractPublicKeyFromSecretKey = qi;
  const Oi = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function Si(Ii, Fi) {
    let Gi, Ri, ji, Vi;
    for (Ri = 63; Ri >= 32; --Ri) {
      for (Gi = 0, ji = Ri - 32, Vi = Ri - 12; ji < Vi; ++ji)
        Fi[ji] += Gi - 16 * Fi[Ri] * Oi[ji - (Ri - 32)], Gi = Math.floor((Fi[ji] + 128) / 256), Fi[ji] -= Gi * 256;
      Fi[ji] += Gi, Fi[Ri] = 0;
    }
    for (Gi = 0, ji = 0; ji < 32; ji++)
      Fi[ji] += Gi - (Fi[31] >> 4) * Oi[ji], Gi = Fi[ji] >> 8, Fi[ji] &= 255;
    for (ji = 0; ji < 32; ji++)
      Fi[ji] -= Gi * Oi[ji];
    for (Ri = 0; Ri < 32; Ri++)
      Fi[Ri + 1] += Fi[Ri] >> 8, Ii[Ri] = Fi[Ri] & 255;
  }
  function Ni(Ii) {
    const Fi = new Float64Array(64);
    for (let Gi = 0; Gi < 64; Gi++)
      Fi[Gi] = Ii[Gi];
    for (let Gi = 0; Gi < 64; Gi++)
      Ii[Gi] = 0;
    Si(Ii, Fi);
  }
  function xi(Ii, Fi) {
    const Gi = new Float64Array(64), Ri = [Pe(), Pe(), Pe(), Pe()], ji = (0, Me.hash)(Ii.subarray(0, 32));
    ji[0] &= 248, ji[31] &= 127, ji[31] |= 64;
    const Vi = new Uint8Array(64);
    Vi.set(ji.subarray(32), 32);
    const is = new Me.SHA512();
    is.update(Vi.subarray(32)), is.update(Fi);
    const os = is.digest();
    is.clean(), Ni(os), Ei(Ri, os), Ai(Vi, Ri), is.reset(), is.update(Vi.subarray(0, 32)), is.update(Ii.subarray(32)), is.update(Fi);
    const ds = is.digest();
    Ni(ds);
    for (let ps = 0; ps < 32; ps++)
      Gi[ps] = os[ps];
    for (let ps = 0; ps < 32; ps++)
      for (let ea = 0; ea < 32; ea++)
        Gi[ps + ea] += ds[ps] * ji[ea];
    return Si(Vi.subarray(32), Gi), Vi;
  }
  Ae.sign = xi;
  function Wi(Ii, Fi) {
    const Gi = Pe(), Ri = Pe(), ji = Pe(), Vi = Pe(), is = Pe(), os = Pe(), ds = Pe();
    return mi(Ii[2], je), Hi(Ii[1], Fi), Xi(ji, Ii[1]), Bi(Vi, ji, Ve), Qi(ji, ji, Ii[2]), Zi(Vi, Ii[2], Vi), Xi(is, Vi), Xi(os, is), Bi(ds, os, is), Bi(Gi, ds, ji), Bi(Gi, Gi, Vi), ls(Gi, Gi), Bi(Gi, Gi, ji), Bi(Gi, Gi, Vi), Bi(Gi, Gi, Vi), Bi(Ii[0], Gi, Vi), Xi(Ri, Ii[0]), Bi(Ri, Ri, Vi), ki(Ri, ji) && Bi(Ii[0], Ii[0], vi), Xi(Ri, Ii[0]), Bi(Ri, Ri, Vi), ki(Ri, ji) ? -1 : (Ji(Ii[0]) === Fi[31] >> 7 && Qi(Ii[0], Te, Ii[0]), Bi(Ii[3], Ii[0], Ii[1]), 0);
  }
  function ts(Ii, Fi, Gi) {
    const Ri = new Uint8Array(32), ji = [Pe(), Pe(), Pe(), Pe()], Vi = [Pe(), Pe(), Pe(), Pe()];
    if (Gi.length !== Ae.SIGNATURE_LENGTH)
      throw new Error(`ed25519: signature must be ${Ae.SIGNATURE_LENGTH} bytes`);
    if (Wi(Vi, Ii))
      return !1;
    const is = new Me.SHA512();
    is.update(Gi.subarray(0, 32)), is.update(Ii), is.update(Fi);
    const os = is.digest();
    return Ni(os), wi(ji, Vi, os), Ei(Vi, Gi.subarray(32)), vn(ji, Vi), Ai(Ri, ji), !Ui(Gi, Ri);
  }
  Ae.verify = ts;
  function Ki(Ii) {
    let Fi = [Pe(), Pe(), Pe(), Pe()];
    if (Wi(Fi, Ii))
      throw new Error("Ed25519: invalid public key");
    let Gi = Pe(), Ri = Pe(), ji = Fi[1];
    Zi(Gi, je, ji), Qi(Ri, je, ji), ns(Ri, Ri), Bi(Gi, Gi, Ri);
    let Vi = new Uint8Array(32);
    return Ci(Vi, Gi), Vi;
  }
  Ae.convertPublicKeyToX25519 = Ki;
  function fn(Ii) {
    const Fi = (0, Me.hash)(Ii.subarray(0, 32));
    Fi[0] &= 248, Fi[31] &= 127, Fi[31] |= 64;
    const Gi = new Uint8Array(Fi.subarray(0, 32));
    return (0, Ie.wipe)(Fi), Gi;
  }
  Ae.convertSecretKeyToX25519 = fn;
})(ed25519);
const JWT_IRIDIUM_ALG = "EdDSA", JWT_IRIDIUM_TYP = "JWT", JWT_DELIMITER = ".", JWT_ENCODING = "base64url", JSON_ENCODING = "utf8", DATA_ENCODING = "utf8", DID_DELIMITER = ":", DID_PREFIX = "did", DID_METHOD = "key", MULTICODEC_ED25519_ENCODING = "base58btc", MULTICODEC_ED25519_BASE = "z", MULTICODEC_ED25519_HEADER = "K36", KEY_PAIR_SEED_LENGTH = 32;
function allocUnsafe(Ae = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(Ae) : new Uint8Array(Ae);
}
function concat$1(Ae, t) {
  t || (t = Ae.reduce((Pe, Be) => Pe + Be.length, 0));
  const Me = allocUnsafe(t);
  let Ie = 0;
  for (const Pe of Ae)
    Me.set(Pe, Ie), Ie += Pe.length;
  return Me;
}
function base$1(Ae, t) {
  if (Ae.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var Me = new Uint8Array(256), Ie = 0; Ie < Me.length; Ie++)
    Me[Ie] = 255;
  for (var Pe = 0; Pe < Ae.length; Pe++) {
    var Be = Ae.charAt(Pe), Te = Be.charCodeAt(0);
    if (Me[Te] !== 255)
      throw new TypeError(Be + " is ambiguous");
    Me[Te] = Pe;
  }
  var je = Ae.length, Ve = Ae.charAt(0), fi = Math.log(je) / Math.log(256), Ue = Math.log(256) / Math.log(je);
  function bi(_i) {
    if (_i instanceof Uint8Array || (ArrayBuffer.isView(_i) ? _i = new Uint8Array(_i.buffer, _i.byteOffset, _i.byteLength) : Array.isArray(_i) && (_i = Uint8Array.from(_i))), !(_i instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (_i.length === 0)
      return "";
    for (var $i = 0, Ci = 0, Ui = 0, ki = _i.length; Ui !== ki && _i[Ui] === 0; )
      Ui++, $i++;
    for (var Ji = (ki - Ui) * Ue + 1 >>> 0, Hi = new Uint8Array(Ji); Ui !== ki; ) {
      for (var Zi = _i[Ui], Qi = 0, Bi = Ji - 1; (Zi !== 0 || Qi < Ci) && Bi !== -1; Bi--, Qi++)
        Zi += 256 * Hi[Bi] >>> 0, Hi[Bi] = Zi % je >>> 0, Zi = Zi / je >>> 0;
      if (Zi !== 0)
        throw new Error("Non-zero carry");
      Ci = Qi, Ui++;
    }
    for (var Xi = Ji - Ci; Xi !== Ji && Hi[Xi] === 0; )
      Xi++;
    for (var ns = Ve.repeat($i); Xi < Ji; ++Xi)
      ns += Ae.charAt(Hi[Xi]);
    return ns;
  }
  function vi(_i) {
    if (typeof _i != "string")
      throw new TypeError("Expected String");
    if (_i.length === 0)
      return new Uint8Array();
    var $i = 0;
    if (_i[$i] !== " ") {
      for (var Ci = 0, Ui = 0; _i[$i] === Ve; )
        Ci++, $i++;
      for (var ki = (_i.length - $i) * fi + 1 >>> 0, Ji = new Uint8Array(ki); _i[$i]; ) {
        var Hi = Me[_i.charCodeAt($i)];
        if (Hi === 255)
          return;
        for (var Zi = 0, Qi = ki - 1; (Hi !== 0 || Zi < Ui) && Qi !== -1; Qi--, Zi++)
          Hi += je * Ji[Qi] >>> 0, Ji[Qi] = Hi % 256 >>> 0, Hi = Hi / 256 >>> 0;
        if (Hi !== 0)
          throw new Error("Non-zero carry");
        Ui = Zi, $i++;
      }
      if (_i[$i] !== " ") {
        for (var Bi = ki - Ui; Bi !== ki && Ji[Bi] === 0; )
          Bi++;
        for (var Xi = new Uint8Array(Ci + (ki - Bi)), ns = Ci; Bi !== ki; )
          Xi[ns++] = Ji[Bi++];
        return Xi;
      }
    }
  }
  function mi(_i) {
    var $i = vi(_i);
    if ($i)
      return $i;
    throw new Error(`Non-${t} character`);
  }
  return {
    encode: bi,
    decodeUnsafe: vi,
    decode: mi
  };
}
var src = base$1, _brrp__multiformats_scope_baseX = src;
const coerce = (Ae) => {
  if (Ae instanceof Uint8Array && Ae.constructor.name === "Uint8Array")
    return Ae;
  if (Ae instanceof ArrayBuffer)
    return new Uint8Array(Ae);
  if (ArrayBuffer.isView(Ae))
    return new Uint8Array(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  throw new Error("Unknown type, must be binary type");
}, fromString$1 = (Ae) => new TextEncoder().encode(Ae), toString$1 = (Ae) => new TextDecoder().decode(Ae);
class Encoder {
  constructor(t, Me, Ie) {
    this.name = t, this.prefix = Me, this.baseEncode = Ie;
  }
  encode(t) {
    if (t instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Decoder {
  constructor(t, Me, Ie) {
    if (this.name = t, this.prefix = Me, Me.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = Me.codePointAt(0), this.baseDecode = Ie;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(t) {
    return or$2(this, t);
  }
}
class ComposedDecoder {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return or$2(this, t);
  }
  decode(t) {
    const Me = t[0], Ie = this.decoders[Me];
    if (Ie)
      return Ie.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const or$2 = (Ae, t) => new ComposedDecoder({
  ...Ae.decoders || { [Ae.prefix]: Ae },
  ...t.decoders || { [t.prefix]: t }
});
class Codec {
  constructor(t, Me, Ie, Pe) {
    this.name = t, this.prefix = Me, this.baseEncode = Ie, this.baseDecode = Pe, this.encoder = new Encoder(t, Me, Ie), this.decoder = new Decoder(t, Me, Pe);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
}
const from = ({ name: Ae, prefix: t, encode: Me, decode: Ie }) => new Codec(Ae, t, Me, Ie), baseX = ({ prefix: Ae, name: t, alphabet: Me }) => {
  const { encode: Ie, decode: Pe } = _brrp__multiformats_scope_baseX(Me, t);
  return from({
    prefix: Ae,
    name: t,
    encode: Ie,
    decode: (Be) => coerce(Pe(Be))
  });
}, decode$2 = (Ae, t, Me, Ie) => {
  const Pe = {};
  for (let Ue = 0; Ue < t.length; ++Ue)
    Pe[t[Ue]] = Ue;
  let Be = Ae.length;
  for (; Ae[Be - 1] === "="; )
    --Be;
  const Te = new Uint8Array(Be * Me / 8 | 0);
  let je = 0, Ve = 0, fi = 0;
  for (let Ue = 0; Ue < Be; ++Ue) {
    const bi = Pe[Ae[Ue]];
    if (bi === void 0)
      throw new SyntaxError(`Non-${Ie} character`);
    Ve = Ve << Me | bi, je += Me, je >= 8 && (je -= 8, Te[fi++] = 255 & Ve >> je);
  }
  if (je >= Me || 255 & Ve << 8 - je)
    throw new SyntaxError("Unexpected end of data");
  return Te;
}, encode$1 = (Ae, t, Me) => {
  const Ie = t[t.length - 1] === "=", Pe = (1 << Me) - 1;
  let Be = "", Te = 0, je = 0;
  for (let Ve = 0; Ve < Ae.length; ++Ve)
    for (je = je << 8 | Ae[Ve], Te += 8; Te > Me; )
      Te -= Me, Be += t[Pe & je >> Te];
  if (Te && (Be += t[Pe & je << Me - Te]), Ie)
    for (; Be.length * Me & 7; )
      Be += "=";
  return Be;
}, rfc4648 = ({ name: Ae, prefix: t, bitsPerChar: Me, alphabet: Ie }) => from({
  prefix: t,
  name: Ae,
  encode(Pe) {
    return encode$1(Pe, Ie, Me);
  },
  decode(Pe) {
    return decode$2(Pe, Ie, Me, Ae);
  }
}), identity = from({
  prefix: "\0",
  name: "identity",
  encode: (Ae) => toString$1(Ae),
  decode: (Ae) => fromString$1(Ae)
}), identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity
}, Symbol.toStringTag, { value: "Module" })), base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" })), base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" })), base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" })), base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" })), base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32,
  base32hex,
  base32hexpad,
  base32hexpadupper,
  base32hexupper,
  base32pad,
  base32padupper,
  base32upper,
  base32z
}, Symbol.toStringTag, { value: "Module" })), base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" })), base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc,
  base58flickr
}, Symbol.toStringTag, { value: "Module" })), base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), base64$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" })), alphabet = Array.from(""), alphabetBytesToChars = alphabet.reduce((Ae, t, Me) => (Ae[Me] = t, Ae), []), alphabetCharsToBytes = alphabet.reduce((Ae, t, Me) => (Ae[t.codePointAt(0)] = Me, Ae), []);
function encode(Ae) {
  return Ae.reduce((t, Me) => (t += alphabetBytesToChars[Me], t), "");
}
function decode$1(Ae) {
  const t = [];
  for (const Me of Ae) {
    const Ie = alphabetCharsToBytes[Me.codePointAt(0)];
    if (Ie === void 0)
      throw new Error(`Non-base256emoji character: ${Me}`);
    t.push(Ie);
  }
  return new Uint8Array(t);
}
const base256emoji = from({
  prefix: "",
  name: "base256emoji",
  encode,
  decode: decode$1
}), base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const bases = {
  ...identityBase,
  ...base2$1,
  ...base8$1,
  ...base10$1,
  ...base16$1,
  ...base32$1,
  ...base36$1,
  ...base58,
  ...base64$1,
  ...base256emoji$1
};
function createCodec(Ae, t, Me, Ie) {
  return {
    name: Ae,
    prefix: t,
    encoder: {
      name: Ae,
      prefix: t,
      encode: Me
    },
    decoder: { decode: Ie }
  };
}
const string = createCodec("utf8", "u", (Ae) => "u" + new TextDecoder("utf8").decode(Ae), (Ae) => new TextEncoder().encode(Ae.substring(1))), ascii = createCodec("ascii", "a", (Ae) => {
  let t = "a";
  for (let Me = 0; Me < Ae.length; Me++)
    t += String.fromCharCode(Ae[Me]);
  return t;
}, (Ae) => {
  Ae = Ae.substring(1);
  const t = allocUnsafe(Ae.length);
  for (let Me = 0; Me < Ae.length; Me++)
    t[Me] = Ae.charCodeAt(Me);
  return t;
}), BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function toString(Ae, t = "utf8") {
  const Me = BASES[t];
  if (!Me)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(Ae.buffer, Ae.byteOffset, Ae.byteLength).toString("utf8") : Me.encoder.encode(Ae).substring(1);
}
function fromString(Ae, t = "utf8") {
  const Me = BASES[t];
  if (!Me)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(Ae, "utf8") : Me.decoder.decode(`${Me.prefix}${Ae}`);
}
function decodeJSON(Ae) {
  return safeJsonParse(toString(fromString(Ae, JWT_ENCODING), JSON_ENCODING));
}
function encodeJSON(Ae) {
  return toString(fromString(safeJsonStringify(Ae), JSON_ENCODING), JWT_ENCODING);
}
function encodeIss(Ae) {
  const t = fromString(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING), Me = MULTICODEC_ED25519_BASE + toString(concat$1([t, Ae]), MULTICODEC_ED25519_ENCODING);
  return [DID_PREFIX, DID_METHOD, Me].join(DID_DELIMITER);
}
function encodeSig(Ae) {
  return toString(Ae, JWT_ENCODING);
}
function decodeSig(Ae) {
  return fromString(Ae, JWT_ENCODING);
}
function encodeData(Ae) {
  return fromString([encodeJSON(Ae.header), encodeJSON(Ae.payload)].join(JWT_DELIMITER), DATA_ENCODING);
}
function encodeJWT(Ae) {
  return [
    encodeJSON(Ae.header),
    encodeJSON(Ae.payload),
    encodeSig(Ae.signature)
  ].join(JWT_DELIMITER);
}
function decodeJWT(Ae) {
  const t = Ae.split(JWT_DELIMITER), Me = decodeJSON(t[0]), Ie = decodeJSON(t[1]), Pe = decodeSig(t[2]), Be = fromString(t.slice(0, 2).join(JWT_DELIMITER), DATA_ENCODING);
  return { header: Me, payload: Ie, signature: Pe, data: Be };
}
function generateKeyPair(Ae = random.randomBytes(KEY_PAIR_SEED_LENGTH)) {
  return ed25519.generateKeyPairFromSeed(Ae);
}
async function signJWT(Ae, t, Me, Ie, Pe = cjs$3.fromMiliseconds(Date.now())) {
  const Be = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP }, Te = encodeIss(Ie.publicKey), je = Pe + Me, Ve = { iss: Te, sub: Ae, aud: t, iat: Pe, exp: je }, fi = encodeData({ header: Be, payload: Ve }), Ue = ed25519.sign(Ie.secretKey, fi);
  return encodeJWT({ header: Be, payload: Ve, signature: Ue });
}
var __spreadArray = function(Ae, t, Me) {
  if (Me || arguments.length === 2) for (var Ie = 0, Pe = t.length, Be; Ie < Pe; Ie++)
    (Be || !(Ie in t)) && (Be || (Be = Array.prototype.slice.call(t, 0, Ie)), Be[Ie] = t[Ie]);
  return Ae.concat(Be || Array.prototype.slice.call(t));
}, BrowserInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function Ae(t, Me, Ie) {
      this.name = t, this.version = Me, this.os = Ie, this.type = "browser";
    }
    return Ae;
  }()
), NodeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function Ae(t) {
      this.version = t, this.type = "node", this.name = "node", this.os = process$1.platform;
    }
    return Ae;
  }()
), SearchBotDeviceInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function Ae(t, Me, Ie, Pe) {
      this.name = t, this.version = Me, this.os = Ie, this.bot = Pe, this.type = "bot-device";
    }
    return Ae;
  }()
), BotInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function Ae() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return Ae;
  }()
), ReactNativeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function Ae() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return Ae;
  }()
), SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, REQUIRED_VERSION_PARTS = 3, userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
], operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(Ae) {
  return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new ReactNativeInfo() : typeof navigator < "u" ? parseUserAgent(navigator.userAgent) : getNodeVersion();
}
function matchUserAgent(Ae) {
  return Ae !== "" && userAgentRules.reduce(function(t, Me) {
    var Ie = Me[0], Pe = Me[1];
    if (t)
      return t;
    var Be = Pe.exec(Ae);
    return !!Be && [Ie, Be];
  }, !1);
}
function parseUserAgent(Ae) {
  var t = matchUserAgent(Ae);
  if (!t)
    return null;
  var Me = t[0], Ie = t[1];
  if (Me === "searchbot")
    return new BotInfo();
  var Pe = Ie[1] && Ie[1].split(".").join("_").split("_").slice(0, 3);
  Pe ? Pe.length < REQUIRED_VERSION_PARTS && (Pe = __spreadArray(__spreadArray([], Pe, !0), createVersionParts(REQUIRED_VERSION_PARTS - Pe.length), !0)) : Pe = [];
  var Be = Pe.join("."), Te = detectOS(Ae), je = SEARCHBOT_OS_REGEX.exec(Ae);
  return je && je[1] ? new SearchBotDeviceInfo(Me, Be, Te, je[1]) : new BrowserInfo(Me, Be, Te);
}
function detectOS(Ae) {
  for (var t = 0, Me = operatingSystemRules.length; t < Me; t++) {
    var Ie = operatingSystemRules[t], Pe = Ie[0], Be = Ie[1], Te = Be.exec(Ae);
    if (Te)
      return Pe;
  }
  return null;
}
function getNodeVersion() {
  var Ae = typeof process$1 < "u" && process$1.version;
  return Ae ? new NodeInfo(process$1.version.slice(1)) : null;
}
function createVersionParts(Ae) {
  for (var t = [], Me = 0; Me < Ae; Me++)
    t.push("0");
  return t;
}
var cjs$2 = {};
Object.defineProperty(cjs$2, "__esModule", { value: !0 });
cjs$2.getLocalStorage = cjs$2.getLocalStorageOrThrow = cjs$2.getCrypto = cjs$2.getCryptoOrThrow = getLocation_1 = cjs$2.getLocation = cjs$2.getLocationOrThrow = getNavigator_1 = cjs$2.getNavigator = cjs$2.getNavigatorOrThrow = getDocument_1 = cjs$2.getDocument = cjs$2.getDocumentOrThrow = cjs$2.getFromWindowOrThrow = cjs$2.getFromWindow = void 0;
function getFromWindow(Ae) {
  let t;
  return typeof window < "u" && typeof window[Ae] < "u" && (t = window[Ae]), t;
}
cjs$2.getFromWindow = getFromWindow;
function getFromWindowOrThrow(Ae) {
  const t = getFromWindow(Ae);
  if (!t)
    throw new Error(`${Ae} is not defined in Window`);
  return t;
}
cjs$2.getFromWindowOrThrow = getFromWindowOrThrow;
function getDocumentOrThrow() {
  return getFromWindowOrThrow("document");
}
cjs$2.getDocumentOrThrow = getDocumentOrThrow;
function getDocument() {
  return getFromWindow("document");
}
var getDocument_1 = cjs$2.getDocument = getDocument;
function getNavigatorOrThrow() {
  return getFromWindowOrThrow("navigator");
}
cjs$2.getNavigatorOrThrow = getNavigatorOrThrow;
function getNavigator() {
  return getFromWindow("navigator");
}
var getNavigator_1 = cjs$2.getNavigator = getNavigator;
function getLocationOrThrow() {
  return getFromWindowOrThrow("location");
}
cjs$2.getLocationOrThrow = getLocationOrThrow;
function getLocation() {
  return getFromWindow("location");
}
var getLocation_1 = cjs$2.getLocation = getLocation;
function getCryptoOrThrow() {
  return getFromWindowOrThrow("crypto");
}
cjs$2.getCryptoOrThrow = getCryptoOrThrow;
function getCrypto() {
  return getFromWindow("crypto");
}
cjs$2.getCrypto = getCrypto;
function getLocalStorageOrThrow() {
  return getFromWindowOrThrow("localStorage");
}
cjs$2.getLocalStorageOrThrow = getLocalStorageOrThrow;
function getLocalStorage() {
  return getFromWindow("localStorage");
}
cjs$2.getLocalStorage = getLocalStorage;
var cjs$1 = {};
Object.defineProperty(cjs$1, "__esModule", { value: !0 });
var getWindowMetadata_1 = cjs$1.getWindowMetadata = void 0;
const window_getters_1 = cjs$2;
function getWindowMetadata() {
  let Ae, t;
  try {
    Ae = window_getters_1.getDocumentOrThrow(), t = window_getters_1.getLocationOrThrow();
  } catch {
    return null;
  }
  function Me() {
    const bi = Ae.getElementsByTagName("link"), vi = [];
    for (let mi = 0; mi < bi.length; mi++) {
      const _i = bi[mi], $i = _i.getAttribute("rel");
      if ($i && $i.toLowerCase().indexOf("icon") > -1) {
        const Ci = _i.getAttribute("href");
        if (Ci)
          if (Ci.toLowerCase().indexOf("https:") === -1 && Ci.toLowerCase().indexOf("http:") === -1 && Ci.indexOf("//") !== 0) {
            let Ui = t.protocol + "//" + t.host;
            if (Ci.indexOf("/") === 0)
              Ui += Ci;
            else {
              const ki = t.pathname.split("/");
              ki.pop();
              const Ji = ki.join("/");
              Ui += Ji + "/" + Ci;
            }
            vi.push(Ui);
          } else if (Ci.indexOf("//") === 0) {
            const Ui = t.protocol + Ci;
            vi.push(Ui);
          } else
            vi.push(Ci);
      }
    }
    return vi;
  }
  function Ie(...bi) {
    const vi = Ae.getElementsByTagName("meta");
    for (let mi = 0; mi < vi.length; mi++) {
      const _i = vi[mi], $i = ["itemprop", "property", "name"].map((Ci) => _i.getAttribute(Ci)).filter((Ci) => Ci ? bi.includes(Ci) : !1);
      if ($i.length && $i) {
        const Ci = _i.getAttribute("content");
        if (Ci)
          return Ci;
      }
    }
    return "";
  }
  function Pe() {
    let bi = Ie("name", "og:site_name", "og:title", "twitter:title");
    return bi || (bi = Ae.title), bi;
  }
  function Be() {
    return Ie("description", "og:description", "twitter:description", "keywords");
  }
  const Te = Pe(), je = Be(), Ve = t.origin, fi = Me();
  return {
    description: je,
    url: Ve,
    icons: fi,
    name: Te
  };
}
getWindowMetadata_1 = cjs$1.getWindowMetadata = getWindowMetadata;
var queryString = {}, strictUriEncode = (Ae) => encodeURIComponent(Ae).replace(/[!'()*]/g, (t) => `%${t.charCodeAt(0).toString(16).toUpperCase()}`), token = "%[a-f0-9]{2}", singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi"), multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(Ae, t) {
  try {
    return [decodeURIComponent(Ae.join(""))];
  } catch {
  }
  if (Ae.length === 1)
    return Ae;
  t = t || 1;
  var Me = Ae.slice(0, t), Ie = Ae.slice(t);
  return Array.prototype.concat.call([], decodeComponents(Me), decodeComponents(Ie));
}
function decode(Ae) {
  try {
    return decodeURIComponent(Ae);
  } catch {
    for (var t = Ae.match(singleMatcher) || [], Me = 1; Me < t.length; Me++)
      Ae = decodeComponents(t, Me).join(""), t = Ae.match(singleMatcher) || [];
    return Ae;
  }
}
function customDecodeURIComponent(Ae) {
  for (var t = {
    "%FE%FF": "",
    "%FF%FE": ""
  }, Me = multiMatcher.exec(Ae); Me; ) {
    try {
      t[Me[0]] = decodeURIComponent(Me[0]);
    } catch {
      var Ie = decode(Me[0]);
      Ie !== Me[0] && (t[Me[0]] = Ie);
    }
    Me = multiMatcher.exec(Ae);
  }
  t["%C2"] = "";
  for (var Pe = Object.keys(t), Be = 0; Be < Pe.length; Be++) {
    var Te = Pe[Be];
    Ae = Ae.replace(new RegExp(Te, "g"), t[Te]);
  }
  return Ae;
}
var decodeUriComponent = function(Ae) {
  if (typeof Ae != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof Ae + "`");
  try {
    return Ae = Ae.replace(/\+/g, " "), decodeURIComponent(Ae);
  } catch {
    return customDecodeURIComponent(Ae);
  }
}, splitOnFirst = (Ae, t) => {
  if (!(typeof Ae == "string" && typeof t == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (t === "")
    return [Ae];
  const Me = Ae.indexOf(t);
  return Me === -1 ? [Ae] : [
    Ae.slice(0, Me),
    Ae.slice(Me + t.length)
  ];
}, filterObj = function(Ae, t) {
  for (var Me = {}, Ie = Object.keys(Ae), Pe = Array.isArray(t), Be = 0; Be < Ie.length; Be++) {
    var Te = Ie[Be], je = Ae[Te];
    (Pe ? t.indexOf(Te) !== -1 : t(Te, je, Ae)) && (Me[Te] = je);
  }
  return Me;
};
(function(Ae) {
  const t = strictUriEncode, Me = decodeUriComponent, Ie = splitOnFirst, Pe = filterObj, Be = (ki) => ki == null, Te = Symbol("encodeFragmentIdentifier");
  function je(ki) {
    switch (ki.arrayFormat) {
      case "index":
        return (Ji) => (Hi, Zi) => {
          const Qi = Hi.length;
          return Zi === void 0 || ki.skipNull && Zi === null || ki.skipEmptyString && Zi === "" ? Hi : Zi === null ? [...Hi, [Ue(Ji, ki), "[", Qi, "]"].join("")] : [
            ...Hi,
            [Ue(Ji, ki), "[", Ue(Qi, ki), "]=", Ue(Zi, ki)].join("")
          ];
        };
      case "bracket":
        return (Ji) => (Hi, Zi) => Zi === void 0 || ki.skipNull && Zi === null || ki.skipEmptyString && Zi === "" ? Hi : Zi === null ? [...Hi, [Ue(Ji, ki), "[]"].join("")] : [...Hi, [Ue(Ji, ki), "[]=", Ue(Zi, ki)].join("")];
      case "colon-list-separator":
        return (Ji) => (Hi, Zi) => Zi === void 0 || ki.skipNull && Zi === null || ki.skipEmptyString && Zi === "" ? Hi : Zi === null ? [...Hi, [Ue(Ji, ki), ":list="].join("")] : [...Hi, [Ue(Ji, ki), ":list=", Ue(Zi, ki)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const Ji = ki.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (Hi) => (Zi, Qi) => Qi === void 0 || ki.skipNull && Qi === null || ki.skipEmptyString && Qi === "" ? Zi : (Qi = Qi === null ? "" : Qi, Zi.length === 0 ? [[Ue(Hi, ki), Ji, Ue(Qi, ki)].join("")] : [[Zi, Ue(Qi, ki)].join(ki.arrayFormatSeparator)]);
      }
      default:
        return (Ji) => (Hi, Zi) => Zi === void 0 || ki.skipNull && Zi === null || ki.skipEmptyString && Zi === "" ? Hi : Zi === null ? [...Hi, Ue(Ji, ki)] : [...Hi, [Ue(Ji, ki), "=", Ue(Zi, ki)].join("")];
    }
  }
  function Ve(ki) {
    let Ji;
    switch (ki.arrayFormat) {
      case "index":
        return (Hi, Zi, Qi) => {
          if (Ji = /\[(\d*)\]$/.exec(Hi), Hi = Hi.replace(/\[\d*\]$/, ""), !Ji) {
            Qi[Hi] = Zi;
            return;
          }
          Qi[Hi] === void 0 && (Qi[Hi] = {}), Qi[Hi][Ji[1]] = Zi;
        };
      case "bracket":
        return (Hi, Zi, Qi) => {
          if (Ji = /(\[\])$/.exec(Hi), Hi = Hi.replace(/\[\]$/, ""), !Ji) {
            Qi[Hi] = Zi;
            return;
          }
          if (Qi[Hi] === void 0) {
            Qi[Hi] = [Zi];
            return;
          }
          Qi[Hi] = [].concat(Qi[Hi], Zi);
        };
      case "colon-list-separator":
        return (Hi, Zi, Qi) => {
          if (Ji = /(:list)$/.exec(Hi), Hi = Hi.replace(/:list$/, ""), !Ji) {
            Qi[Hi] = Zi;
            return;
          }
          if (Qi[Hi] === void 0) {
            Qi[Hi] = [Zi];
            return;
          }
          Qi[Hi] = [].concat(Qi[Hi], Zi);
        };
      case "comma":
      case "separator":
        return (Hi, Zi, Qi) => {
          const Bi = typeof Zi == "string" && Zi.includes(ki.arrayFormatSeparator), Xi = typeof Zi == "string" && !Bi && bi(Zi, ki).includes(ki.arrayFormatSeparator);
          Zi = Xi ? bi(Zi, ki) : Zi;
          const ns = Bi || Xi ? Zi.split(ki.arrayFormatSeparator).map((ls) => bi(ls, ki)) : Zi === null ? Zi : bi(Zi, ki);
          Qi[Hi] = ns;
        };
      case "bracket-separator":
        return (Hi, Zi, Qi) => {
          const Bi = /(\[\])$/.test(Hi);
          if (Hi = Hi.replace(/\[\]$/, ""), !Bi) {
            Qi[Hi] = Zi && bi(Zi, ki);
            return;
          }
          const Xi = Zi === null ? [] : Zi.split(ki.arrayFormatSeparator).map((ns) => bi(ns, ki));
          if (Qi[Hi] === void 0) {
            Qi[Hi] = Xi;
            return;
          }
          Qi[Hi] = [].concat(Qi[Hi], Xi);
        };
      default:
        return (Hi, Zi, Qi) => {
          if (Qi[Hi] === void 0) {
            Qi[Hi] = Zi;
            return;
          }
          Qi[Hi] = [].concat(Qi[Hi], Zi);
        };
    }
  }
  function fi(ki) {
    if (typeof ki != "string" || ki.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function Ue(ki, Ji) {
    return Ji.encode ? Ji.strict ? t(ki) : encodeURIComponent(ki) : ki;
  }
  function bi(ki, Ji) {
    return Ji.decode ? Me(ki) : ki;
  }
  function vi(ki) {
    return Array.isArray(ki) ? ki.sort() : typeof ki == "object" ? vi(Object.keys(ki)).sort((Ji, Hi) => Number(Ji) - Number(Hi)).map((Ji) => ki[Ji]) : ki;
  }
  function mi(ki) {
    const Ji = ki.indexOf("#");
    return Ji !== -1 && (ki = ki.slice(0, Ji)), ki;
  }
  function _i(ki) {
    let Ji = "";
    const Hi = ki.indexOf("#");
    return Hi !== -1 && (Ji = ki.slice(Hi)), Ji;
  }
  function $i(ki) {
    ki = mi(ki);
    const Ji = ki.indexOf("?");
    return Ji === -1 ? "" : ki.slice(Ji + 1);
  }
  function Ci(ki, Ji) {
    return Ji.parseNumbers && !Number.isNaN(Number(ki)) && typeof ki == "string" && ki.trim() !== "" ? ki = Number(ki) : Ji.parseBooleans && ki !== null && (ki.toLowerCase() === "true" || ki.toLowerCase() === "false") && (ki = ki.toLowerCase() === "true"), ki;
  }
  function Ui(ki, Ji) {
    Ji = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, Ji), fi(Ji.arrayFormatSeparator);
    const Hi = Ve(Ji), Zi = /* @__PURE__ */ Object.create(null);
    if (typeof ki != "string" || (ki = ki.trim().replace(/^[?#&]/, ""), !ki))
      return Zi;
    for (const Qi of ki.split("&")) {
      if (Qi === "")
        continue;
      let [Bi, Xi] = Ie(Ji.decode ? Qi.replace(/\+/g, " ") : Qi, "=");
      Xi = Xi === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(Ji.arrayFormat) ? Xi : bi(Xi, Ji), Hi(bi(Bi, Ji), Xi, Zi);
    }
    for (const Qi of Object.keys(Zi)) {
      const Bi = Zi[Qi];
      if (typeof Bi == "object" && Bi !== null)
        for (const Xi of Object.keys(Bi))
          Bi[Xi] = Ci(Bi[Xi], Ji);
      else
        Zi[Qi] = Ci(Bi, Ji);
    }
    return Ji.sort === !1 ? Zi : (Ji.sort === !0 ? Object.keys(Zi).sort() : Object.keys(Zi).sort(Ji.sort)).reduce((Qi, Bi) => {
      const Xi = Zi[Bi];
      return Xi && typeof Xi == "object" && !Array.isArray(Xi) ? Qi[Bi] = vi(Xi) : Qi[Bi] = Xi, Qi;
    }, /* @__PURE__ */ Object.create(null));
  }
  Ae.extract = $i, Ae.parse = Ui, Ae.stringify = (ki, Ji) => {
    if (!ki)
      return "";
    Ji = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, Ji), fi(Ji.arrayFormatSeparator);
    const Hi = (Xi) => Ji.skipNull && Be(ki[Xi]) || Ji.skipEmptyString && ki[Xi] === "", Zi = je(Ji), Qi = {};
    for (const Xi of Object.keys(ki))
      Hi(Xi) || (Qi[Xi] = ki[Xi]);
    const Bi = Object.keys(Qi);
    return Ji.sort !== !1 && Bi.sort(Ji.sort), Bi.map((Xi) => {
      const ns = ki[Xi];
      return ns === void 0 ? "" : ns === null ? Ue(Xi, Ji) : Array.isArray(ns) ? ns.length === 0 && Ji.arrayFormat === "bracket-separator" ? Ue(Xi, Ji) + "[]" : ns.reduce(Zi(Xi), []).join("&") : Ue(Xi, Ji) + "=" + Ue(ns, Ji);
    }).filter((Xi) => Xi.length > 0).join("&");
  }, Ae.parseUrl = (ki, Ji) => {
    Ji = Object.assign({
      decode: !0
    }, Ji);
    const [Hi, Zi] = Ie(ki, "#");
    return Object.assign(
      {
        url: Hi.split("?")[0] || "",
        query: Ui($i(ki), Ji)
      },
      Ji && Ji.parseFragmentIdentifier && Zi ? { fragmentIdentifier: bi(Zi, Ji) } : {}
    );
  }, Ae.stringifyUrl = (ki, Ji) => {
    Ji = Object.assign({
      encode: !0,
      strict: !0,
      [Te]: !0
    }, Ji);
    const Hi = mi(ki.url).split("?")[0] || "", Zi = Ae.extract(ki.url), Qi = Ae.parse(Zi, { sort: !1 }), Bi = Object.assign(Qi, ki.query);
    let Xi = Ae.stringify(Bi, Ji);
    Xi && (Xi = `?${Xi}`);
    let ns = _i(ki.url);
    return ki.fragmentIdentifier && (ns = `#${Ji[Te] ? Ue(ki.fragmentIdentifier, Ji) : ki.fragmentIdentifier}`), `${Hi}${Xi}${ns}`;
  }, Ae.pick = (ki, Ji, Hi) => {
    Hi = Object.assign({
      parseFragmentIdentifier: !0,
      [Te]: !1
    }, Hi);
    const { url: Zi, query: Qi, fragmentIdentifier: Bi } = Ae.parseUrl(ki, Hi);
    return Ae.stringifyUrl({
      url: Zi,
      query: Pe(Qi, Ji),
      fragmentIdentifier: Bi
    }, Hi);
  }, Ae.exclude = (ki, Ji, Hi) => {
    const Zi = Array.isArray(Ji) ? (Qi) => !Ji.includes(Qi) : (Qi, Bi) => !Ji(Qi, Bi);
    return Ae.pick(ki, Zi, Hi);
  };
})(queryString);
var sha3$1 = { exports: {} };
(function(Ae) {
  (function() {
    var t = "input is invalid type", Me = "finalize already called", Ie = typeof window == "object", Pe = Ie ? window : {};
    Pe.JS_SHA3_NO_WINDOW && (Ie = !1);
    var Be = !Ie && typeof self == "object", Te = !Pe.JS_SHA3_NO_NODE_JS && typeof process$1 == "object" && process$1.versions && process$1.versions.node;
    Te ? Pe = commonjsGlobal : Be && (Pe = self);
    var je = !Pe.JS_SHA3_NO_COMMON_JS && !0 && Ae.exports, Ve = !Pe.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", fi = "0123456789abcdef".split(""), Ue = [31, 7936, 2031616, 520093696], bi = [4, 1024, 262144, 67108864], vi = [1, 256, 65536, 16777216], mi = [6, 1536, 393216, 100663296], _i = [0, 8, 16, 24], $i = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ], Ci = [224, 256, 384, 512], Ui = [128, 256], ki = ["hex", "buffer", "arrayBuffer", "array", "digest"], Ji = {
      128: 168,
      256: 136
    };
    (Pe.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(Ki) {
      return Object.prototype.toString.call(Ki) === "[object Array]";
    }), Ve && (Pe.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(Ki) {
      return typeof Ki == "object" && Ki.buffer && Ki.buffer.constructor === ArrayBuffer;
    });
    for (var Hi = function(Ki, fn, Ii) {
      return function(Fi) {
        return new xi(Ki, fn, Ki).update(Fi)[Ii]();
      };
    }, Zi = function(Ki, fn, Ii) {
      return function(Fi, Gi) {
        return new xi(Ki, fn, Gi).update(Fi)[Ii]();
      };
    }, Qi = function(Ki, fn, Ii) {
      return function(Fi, Gi, Ri, ji) {
        return wi["cshake" + Ki].update(Fi, Gi, Ri, ji)[Ii]();
      };
    }, Bi = function(Ki, fn, Ii) {
      return function(Fi, Gi, Ri, ji) {
        return wi["kmac" + Ki].update(Fi, Gi, Ri, ji)[Ii]();
      };
    }, Xi = function(Ki, fn, Ii, Fi) {
      for (var Gi = 0; Gi < ki.length; ++Gi) {
        var Ri = ki[Gi];
        Ki[Ri] = fn(Ii, Fi, Ri);
      }
      return Ki;
    }, ns = function(Ki, fn) {
      var Ii = Hi(Ki, fn, "hex");
      return Ii.create = function() {
        return new xi(Ki, fn, Ki);
      }, Ii.update = function(Fi) {
        return Ii.create().update(Fi);
      }, Xi(Ii, Hi, Ki, fn);
    }, ls = function(Ki, fn) {
      var Ii = Zi(Ki, fn, "hex");
      return Ii.create = function(Fi) {
        return new xi(Ki, fn, Fi);
      }, Ii.update = function(Fi, Gi) {
        return Ii.create(Gi).update(Fi);
      }, Xi(Ii, Zi, Ki, fn);
    }, vn = function(Ki, fn) {
      var Ii = Ji[Ki], Fi = Qi(Ki, fn, "hex");
      return Fi.create = function(Gi, Ri, ji) {
        return !Ri && !ji ? wi["shake" + Ki].create(Gi) : new xi(Ki, fn, Gi).bytepad([Ri, ji], Ii);
      }, Fi.update = function(Gi, Ri, ji, Vi) {
        return Fi.create(Ri, ji, Vi).update(Gi);
      }, Xi(Fi, Qi, Ki, fn);
    }, Mi = function(Ki, fn) {
      var Ii = Ji[Ki], Fi = Bi(Ki, fn, "hex");
      return Fi.create = function(Gi, Ri, ji) {
        return new Wi(Ki, fn, Ri).bytepad(["KMAC", ji], Ii).bytepad([Gi], Ii);
      }, Fi.update = function(Gi, Ri, ji, Vi) {
        return Fi.create(Gi, ji, Vi).update(Ri);
      }, Xi(Fi, Bi, Ki, fn);
    }, Ai = [
      { name: "keccak", padding: vi, bits: Ci, createMethod: ns },
      { name: "sha3", padding: mi, bits: Ci, createMethod: ns },
      { name: "shake", padding: Ue, bits: Ui, createMethod: ls },
      { name: "cshake", padding: bi, bits: Ui, createMethod: vn },
      { name: "kmac", padding: bi, bits: Ui, createMethod: Mi }
    ], wi = {}, Ei = [], Ti = 0; Ti < Ai.length; ++Ti)
      for (var Pi = Ai[Ti], qi = Pi.bits, Oi = 0; Oi < qi.length; ++Oi) {
        var Si = Pi.name + "_" + qi[Oi];
        if (Ei.push(Si), wi[Si] = Pi.createMethod(qi[Oi], Pi.padding), Pi.name !== "sha3") {
          var Ni = Pi.name + qi[Oi];
          Ei.push(Ni), wi[Ni] = wi[Si];
        }
      }
    function xi(Ki, fn, Ii) {
      this.blocks = [], this.s = [], this.padding = fn, this.outputBits = Ii, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (Ki << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = Ii >> 5, this.extraBytes = (Ii & 31) >> 3;
      for (var Fi = 0; Fi < 50; ++Fi)
        this.s[Fi] = 0;
    }
    xi.prototype.update = function(Ki) {
      if (this.finalized)
        throw new Error(Me);
      var fn, Ii = typeof Ki;
      if (Ii !== "string") {
        if (Ii === "object") {
          if (Ki === null)
            throw new Error(t);
          if (Ve && Ki.constructor === ArrayBuffer)
            Ki = new Uint8Array(Ki);
          else if (!Array.isArray(Ki) && (!Ve || !ArrayBuffer.isView(Ki)))
            throw new Error(t);
        } else
          throw new Error(t);
        fn = !0;
      }
      for (var Fi = this.blocks, Gi = this.byteCount, Ri = Ki.length, ji = this.blockCount, Vi = 0, is = this.s, os, ds; Vi < Ri; ) {
        if (this.reset)
          for (this.reset = !1, Fi[0] = this.block, os = 1; os < ji + 1; ++os)
            Fi[os] = 0;
        if (fn)
          for (os = this.start; Vi < Ri && os < Gi; ++Vi)
            Fi[os >> 2] |= Ki[Vi] << _i[os++ & 3];
        else
          for (os = this.start; Vi < Ri && os < Gi; ++Vi)
            ds = Ki.charCodeAt(Vi), ds < 128 ? Fi[os >> 2] |= ds << _i[os++ & 3] : ds < 2048 ? (Fi[os >> 2] |= (192 | ds >> 6) << _i[os++ & 3], Fi[os >> 2] |= (128 | ds & 63) << _i[os++ & 3]) : ds < 55296 || ds >= 57344 ? (Fi[os >> 2] |= (224 | ds >> 12) << _i[os++ & 3], Fi[os >> 2] |= (128 | ds >> 6 & 63) << _i[os++ & 3], Fi[os >> 2] |= (128 | ds & 63) << _i[os++ & 3]) : (ds = 65536 + ((ds & 1023) << 10 | Ki.charCodeAt(++Vi) & 1023), Fi[os >> 2] |= (240 | ds >> 18) << _i[os++ & 3], Fi[os >> 2] |= (128 | ds >> 12 & 63) << _i[os++ & 3], Fi[os >> 2] |= (128 | ds >> 6 & 63) << _i[os++ & 3], Fi[os >> 2] |= (128 | ds & 63) << _i[os++ & 3]);
        if (this.lastByteIndex = os, os >= Gi) {
          for (this.start = os - Gi, this.block = Fi[ji], os = 0; os < ji; ++os)
            is[os] ^= Fi[os];
          ts(is), this.reset = !0;
        } else
          this.start = os;
      }
      return this;
    }, xi.prototype.encode = function(Ki, fn) {
      var Ii = Ki & 255, Fi = 1, Gi = [Ii];
      for (Ki = Ki >> 8, Ii = Ki & 255; Ii > 0; )
        Gi.unshift(Ii), Ki = Ki >> 8, Ii = Ki & 255, ++Fi;
      return fn ? Gi.push(Fi) : Gi.unshift(Fi), this.update(Gi), Gi.length;
    }, xi.prototype.encodeString = function(Ki) {
      var fn, Ii = typeof Ki;
      if (Ii !== "string") {
        if (Ii === "object") {
          if (Ki === null)
            throw new Error(t);
          if (Ve && Ki.constructor === ArrayBuffer)
            Ki = new Uint8Array(Ki);
          else if (!Array.isArray(Ki) && (!Ve || !ArrayBuffer.isView(Ki)))
            throw new Error(t);
        } else
          throw new Error(t);
        fn = !0;
      }
      var Fi = 0, Gi = Ki.length;
      if (fn)
        Fi = Gi;
      else
        for (var Ri = 0; Ri < Ki.length; ++Ri) {
          var ji = Ki.charCodeAt(Ri);
          ji < 128 ? Fi += 1 : ji < 2048 ? Fi += 2 : ji < 55296 || ji >= 57344 ? Fi += 3 : (ji = 65536 + ((ji & 1023) << 10 | Ki.charCodeAt(++Ri) & 1023), Fi += 4);
        }
      return Fi += this.encode(Fi * 8), this.update(Ki), Fi;
    }, xi.prototype.bytepad = function(Ki, fn) {
      for (var Ii = this.encode(fn), Fi = 0; Fi < Ki.length; ++Fi)
        Ii += this.encodeString(Ki[Fi]);
      var Gi = fn - Ii % fn, Ri = [];
      return Ri.length = Gi, this.update(Ri), this;
    }, xi.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var Ki = this.blocks, fn = this.lastByteIndex, Ii = this.blockCount, Fi = this.s;
        if (Ki[fn >> 2] |= this.padding[fn & 3], this.lastByteIndex === this.byteCount)
          for (Ki[0] = Ki[Ii], fn = 1; fn < Ii + 1; ++fn)
            Ki[fn] = 0;
        for (Ki[Ii - 1] |= 2147483648, fn = 0; fn < Ii; ++fn)
          Fi[fn] ^= Ki[fn];
        ts(Fi);
      }
    }, xi.prototype.toString = xi.prototype.hex = function() {
      this.finalize();
      for (var Ki = this.blockCount, fn = this.s, Ii = this.outputBlocks, Fi = this.extraBytes, Gi = 0, Ri = 0, ji = "", Vi; Ri < Ii; ) {
        for (Gi = 0; Gi < Ki && Ri < Ii; ++Gi, ++Ri)
          Vi = fn[Gi], ji += fi[Vi >> 4 & 15] + fi[Vi & 15] + fi[Vi >> 12 & 15] + fi[Vi >> 8 & 15] + fi[Vi >> 20 & 15] + fi[Vi >> 16 & 15] + fi[Vi >> 28 & 15] + fi[Vi >> 24 & 15];
        Ri % Ki === 0 && (ts(fn), Gi = 0);
      }
      return Fi && (Vi = fn[Gi], ji += fi[Vi >> 4 & 15] + fi[Vi & 15], Fi > 1 && (ji += fi[Vi >> 12 & 15] + fi[Vi >> 8 & 15]), Fi > 2 && (ji += fi[Vi >> 20 & 15] + fi[Vi >> 16 & 15])), ji;
    }, xi.prototype.arrayBuffer = function() {
      this.finalize();
      var Ki = this.blockCount, fn = this.s, Ii = this.outputBlocks, Fi = this.extraBytes, Gi = 0, Ri = 0, ji = this.outputBits >> 3, Vi;
      Fi ? Vi = new ArrayBuffer(Ii + 1 << 2) : Vi = new ArrayBuffer(ji);
      for (var is = new Uint32Array(Vi); Ri < Ii; ) {
        for (Gi = 0; Gi < Ki && Ri < Ii; ++Gi, ++Ri)
          is[Ri] = fn[Gi];
        Ri % Ki === 0 && ts(fn);
      }
      return Fi && (is[Gi] = fn[Gi], Vi = Vi.slice(0, ji)), Vi;
    }, xi.prototype.buffer = xi.prototype.arrayBuffer, xi.prototype.digest = xi.prototype.array = function() {
      this.finalize();
      for (var Ki = this.blockCount, fn = this.s, Ii = this.outputBlocks, Fi = this.extraBytes, Gi = 0, Ri = 0, ji = [], Vi, is; Ri < Ii; ) {
        for (Gi = 0; Gi < Ki && Ri < Ii; ++Gi, ++Ri)
          Vi = Ri << 2, is = fn[Gi], ji[Vi] = is & 255, ji[Vi + 1] = is >> 8 & 255, ji[Vi + 2] = is >> 16 & 255, ji[Vi + 3] = is >> 24 & 255;
        Ri % Ki === 0 && ts(fn);
      }
      return Fi && (Vi = Ri << 2, is = fn[Gi], ji[Vi] = is & 255, Fi > 1 && (ji[Vi + 1] = is >> 8 & 255), Fi > 2 && (ji[Vi + 2] = is >> 16 & 255)), ji;
    };
    function Wi(Ki, fn, Ii) {
      xi.call(this, Ki, fn, Ii);
    }
    Wi.prototype = new xi(), Wi.prototype.finalize = function() {
      return this.encode(this.outputBits, !0), xi.prototype.finalize.call(this);
    };
    var ts = function(Ki) {
      var fn, Ii, Fi, Gi, Ri, ji, Vi, is, os, ds, ps, ea, ia, hs, fa, gs, sa, aa, Ds, ra, ca, ta, oa, da, Yi, Li, zi, En, ss, as, us, ua, ma, na, wa, ya, $a, Sa, Ea, la, xa, Aa, ha, Ia, Da, va, Pa, Ba, pa, Ra, _a, ga, Ca, Na, Ma, Fa, qa, Ta, Va, Ga, Ja, Xa, ja;
      for (Fi = 0; Fi < 48; Fi += 2)
        Gi = Ki[0] ^ Ki[10] ^ Ki[20] ^ Ki[30] ^ Ki[40], Ri = Ki[1] ^ Ki[11] ^ Ki[21] ^ Ki[31] ^ Ki[41], ji = Ki[2] ^ Ki[12] ^ Ki[22] ^ Ki[32] ^ Ki[42], Vi = Ki[3] ^ Ki[13] ^ Ki[23] ^ Ki[33] ^ Ki[43], is = Ki[4] ^ Ki[14] ^ Ki[24] ^ Ki[34] ^ Ki[44], os = Ki[5] ^ Ki[15] ^ Ki[25] ^ Ki[35] ^ Ki[45], ds = Ki[6] ^ Ki[16] ^ Ki[26] ^ Ki[36] ^ Ki[46], ps = Ki[7] ^ Ki[17] ^ Ki[27] ^ Ki[37] ^ Ki[47], ea = Ki[8] ^ Ki[18] ^ Ki[28] ^ Ki[38] ^ Ki[48], ia = Ki[9] ^ Ki[19] ^ Ki[29] ^ Ki[39] ^ Ki[49], fn = ea ^ (ji << 1 | Vi >>> 31), Ii = ia ^ (Vi << 1 | ji >>> 31), Ki[0] ^= fn, Ki[1] ^= Ii, Ki[10] ^= fn, Ki[11] ^= Ii, Ki[20] ^= fn, Ki[21] ^= Ii, Ki[30] ^= fn, Ki[31] ^= Ii, Ki[40] ^= fn, Ki[41] ^= Ii, fn = Gi ^ (is << 1 | os >>> 31), Ii = Ri ^ (os << 1 | is >>> 31), Ki[2] ^= fn, Ki[3] ^= Ii, Ki[12] ^= fn, Ki[13] ^= Ii, Ki[22] ^= fn, Ki[23] ^= Ii, Ki[32] ^= fn, Ki[33] ^= Ii, Ki[42] ^= fn, Ki[43] ^= Ii, fn = ji ^ (ds << 1 | ps >>> 31), Ii = Vi ^ (ps << 1 | ds >>> 31), Ki[4] ^= fn, Ki[5] ^= Ii, Ki[14] ^= fn, Ki[15] ^= Ii, Ki[24] ^= fn, Ki[25] ^= Ii, Ki[34] ^= fn, Ki[35] ^= Ii, Ki[44] ^= fn, Ki[45] ^= Ii, fn = is ^ (ea << 1 | ia >>> 31), Ii = os ^ (ia << 1 | ea >>> 31), Ki[6] ^= fn, Ki[7] ^= Ii, Ki[16] ^= fn, Ki[17] ^= Ii, Ki[26] ^= fn, Ki[27] ^= Ii, Ki[36] ^= fn, Ki[37] ^= Ii, Ki[46] ^= fn, Ki[47] ^= Ii, fn = ds ^ (Gi << 1 | Ri >>> 31), Ii = ps ^ (Ri << 1 | Gi >>> 31), Ki[8] ^= fn, Ki[9] ^= Ii, Ki[18] ^= fn, Ki[19] ^= Ii, Ki[28] ^= fn, Ki[29] ^= Ii, Ki[38] ^= fn, Ki[39] ^= Ii, Ki[48] ^= fn, Ki[49] ^= Ii, hs = Ki[0], fa = Ki[1], va = Ki[11] << 4 | Ki[10] >>> 28, Pa = Ki[10] << 4 | Ki[11] >>> 28, En = Ki[20] << 3 | Ki[21] >>> 29, ss = Ki[21] << 3 | Ki[20] >>> 29, Ga = Ki[31] << 9 | Ki[30] >>> 23, Ja = Ki[30] << 9 | Ki[31] >>> 23, Aa = Ki[40] << 18 | Ki[41] >>> 14, ha = Ki[41] << 18 | Ki[40] >>> 14, na = Ki[2] << 1 | Ki[3] >>> 31, wa = Ki[3] << 1 | Ki[2] >>> 31, gs = Ki[13] << 12 | Ki[12] >>> 20, sa = Ki[12] << 12 | Ki[13] >>> 20, Ba = Ki[22] << 10 | Ki[23] >>> 22, pa = Ki[23] << 10 | Ki[22] >>> 22, as = Ki[33] << 13 | Ki[32] >>> 19, us = Ki[32] << 13 | Ki[33] >>> 19, Xa = Ki[42] << 2 | Ki[43] >>> 30, ja = Ki[43] << 2 | Ki[42] >>> 30, Na = Ki[5] << 30 | Ki[4] >>> 2, Ma = Ki[4] << 30 | Ki[5] >>> 2, ya = Ki[14] << 6 | Ki[15] >>> 26, $a = Ki[15] << 6 | Ki[14] >>> 26, aa = Ki[25] << 11 | Ki[24] >>> 21, Ds = Ki[24] << 11 | Ki[25] >>> 21, Ra = Ki[34] << 15 | Ki[35] >>> 17, _a = Ki[35] << 15 | Ki[34] >>> 17, ua = Ki[45] << 29 | Ki[44] >>> 3, ma = Ki[44] << 29 | Ki[45] >>> 3, da = Ki[6] << 28 | Ki[7] >>> 4, Yi = Ki[7] << 28 | Ki[6] >>> 4, Fa = Ki[17] << 23 | Ki[16] >>> 9, qa = Ki[16] << 23 | Ki[17] >>> 9, Sa = Ki[26] << 25 | Ki[27] >>> 7, Ea = Ki[27] << 25 | Ki[26] >>> 7, ra = Ki[36] << 21 | Ki[37] >>> 11, ca = Ki[37] << 21 | Ki[36] >>> 11, ga = Ki[47] << 24 | Ki[46] >>> 8, Ca = Ki[46] << 24 | Ki[47] >>> 8, Ia = Ki[8] << 27 | Ki[9] >>> 5, Da = Ki[9] << 27 | Ki[8] >>> 5, Li = Ki[18] << 20 | Ki[19] >>> 12, zi = Ki[19] << 20 | Ki[18] >>> 12, Ta = Ki[29] << 7 | Ki[28] >>> 25, Va = Ki[28] << 7 | Ki[29] >>> 25, la = Ki[38] << 8 | Ki[39] >>> 24, xa = Ki[39] << 8 | Ki[38] >>> 24, ta = Ki[48] << 14 | Ki[49] >>> 18, oa = Ki[49] << 14 | Ki[48] >>> 18, Ki[0] = hs ^ ~gs & aa, Ki[1] = fa ^ ~sa & Ds, Ki[10] = da ^ ~Li & En, Ki[11] = Yi ^ ~zi & ss, Ki[20] = na ^ ~ya & Sa, Ki[21] = wa ^ ~$a & Ea, Ki[30] = Ia ^ ~va & Ba, Ki[31] = Da ^ ~Pa & pa, Ki[40] = Na ^ ~Fa & Ta, Ki[41] = Ma ^ ~qa & Va, Ki[2] = gs ^ ~aa & ra, Ki[3] = sa ^ ~Ds & ca, Ki[12] = Li ^ ~En & as, Ki[13] = zi ^ ~ss & us, Ki[22] = ya ^ ~Sa & la, Ki[23] = $a ^ ~Ea & xa, Ki[32] = va ^ ~Ba & Ra, Ki[33] = Pa ^ ~pa & _a, Ki[42] = Fa ^ ~Ta & Ga, Ki[43] = qa ^ ~Va & Ja, Ki[4] = aa ^ ~ra & ta, Ki[5] = Ds ^ ~ca & oa, Ki[14] = En ^ ~as & ua, Ki[15] = ss ^ ~us & ma, Ki[24] = Sa ^ ~la & Aa, Ki[25] = Ea ^ ~xa & ha, Ki[34] = Ba ^ ~Ra & ga, Ki[35] = pa ^ ~_a & Ca, Ki[44] = Ta ^ ~Ga & Xa, Ki[45] = Va ^ ~Ja & ja, Ki[6] = ra ^ ~ta & hs, Ki[7] = ca ^ ~oa & fa, Ki[16] = as ^ ~ua & da, Ki[17] = us ^ ~ma & Yi, Ki[26] = la ^ ~Aa & na, Ki[27] = xa ^ ~ha & wa, Ki[36] = Ra ^ ~ga & Ia, Ki[37] = _a ^ ~Ca & Da, Ki[46] = Ga ^ ~Xa & Na, Ki[47] = Ja ^ ~ja & Ma, Ki[8] = ta ^ ~hs & gs, Ki[9] = oa ^ ~fa & sa, Ki[18] = ua ^ ~da & Li, Ki[19] = ma ^ ~Yi & zi, Ki[28] = Aa ^ ~na & ya, Ki[29] = ha ^ ~wa & $a, Ki[38] = ga ^ ~Ia & va, Ki[39] = Ca ^ ~Da & Pa, Ki[48] = Xa ^ ~Na & Fa, Ki[49] = ja ^ ~Ma & qa, Ki[0] ^= $i[Fi], Ki[1] ^= $i[Fi + 1];
    };
    if (je)
      Ae.exports = wi;
    else
      for (Ti = 0; Ti < Ei.length; ++Ti)
        Pe[Ei[Ti]] = wi[Ei[Ti]];
  })();
})(sha3$1);
var sha3Exports = sha3$1.exports;
const sha3 = /* @__PURE__ */ getDefaultExportFromCjs(sha3Exports), version$4 = "logger/5.7.0";
let _permanentCensorErrors = !1, _censorErrors = !1;
const LogLevels = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels.default, _globalLogger = null;
function _checkNormalize() {
  try {
    const Ae = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((t) => {
      try {
        if ("test".normalize(t) !== "test")
          throw new Error("bad normalize");
      } catch {
        Ae.push(t);
      }
    }), Ae.length)
      throw new Error("missing " + Ae.join(", "));
    if ("".normalize("NFD") !== "e")
      throw new Error("broken implementation");
  } catch (Ae) {
    return Ae.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(Ae) {
  Ae.DEBUG = "DEBUG", Ae.INFO = "INFO", Ae.WARNING = "WARNING", Ae.ERROR = "ERROR", Ae.OFF = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(Ae) {
  Ae.UNKNOWN_ERROR = "UNKNOWN_ERROR", Ae.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", Ae.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", Ae.NETWORK_ERROR = "NETWORK_ERROR", Ae.SERVER_ERROR = "SERVER_ERROR", Ae.TIMEOUT = "TIMEOUT", Ae.BUFFER_OVERRUN = "BUFFER_OVERRUN", Ae.NUMERIC_FAULT = "NUMERIC_FAULT", Ae.MISSING_NEW = "MISSING_NEW", Ae.INVALID_ARGUMENT = "INVALID_ARGUMENT", Ae.MISSING_ARGUMENT = "MISSING_ARGUMENT", Ae.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", Ae.CALL_EXCEPTION = "CALL_EXCEPTION", Ae.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", Ae.NONCE_EXPIRED = "NONCE_EXPIRED", Ae.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", Ae.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", Ae.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", Ae.ACTION_REJECTED = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(t) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: t,
      writable: !1
    });
  }
  _log(t, Me) {
    const Ie = t.toLowerCase();
    LogLevels[Ie] == null && this.throwArgumentError("invalid log level name", "logLevel", t), !(_logLevel > LogLevels[Ie]) && console.log.apply(console, Me);
  }
  debug(...t) {
    this._log(Logger.levels.DEBUG, t);
  }
  info(...t) {
    this._log(Logger.levels.INFO, t);
  }
  warn(...t) {
    this._log(Logger.levels.WARNING, t);
  }
  makeError(t, Me, Ie) {
    if (_censorErrors)
      return this.makeError("censored error", Me, {});
    Me || (Me = Logger.errors.UNKNOWN_ERROR), Ie || (Ie = {});
    const Pe = [];
    Object.keys(Ie).forEach((Ve) => {
      const fi = Ie[Ve];
      try {
        if (fi instanceof Uint8Array) {
          let Ue = "";
          for (let bi = 0; bi < fi.length; bi++)
            Ue += HEX[fi[bi] >> 4], Ue += HEX[fi[bi] & 15];
          Pe.push(Ve + "=Uint8Array(0x" + Ue + ")");
        } else
          Pe.push(Ve + "=" + JSON.stringify(fi));
      } catch {
        Pe.push(Ve + "=" + JSON.stringify(Ie[Ve].toString()));
      }
    }), Pe.push(`code=${Me}`), Pe.push(`version=${this.version}`);
    const Be = t;
    let Te = "";
    switch (Me) {
      case ErrorCode.NUMERIC_FAULT: {
        Te = "NUMERIC_FAULT";
        const Ve = t;
        switch (Ve) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            Te += "-" + Ve;
            break;
          case "negative-power":
          case "negative-width":
            Te += "-unsupported";
            break;
          case "unbound-bitwise-result":
            Te += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        Te = Me;
        break;
    }
    Te && (t += " [ See: https://links.ethers.org/v5-errors-" + Te + " ]"), Pe.length && (t += " (" + Pe.join(", ") + ")");
    const je = new Error(t);
    return je.reason = Be, je.code = Me, Object.keys(Ie).forEach(function(Ve) {
      je[Ve] = Ie[Ve];
    }), je;
  }
  throwError(t, Me, Ie) {
    throw this.makeError(t, Me, Ie);
  }
  throwArgumentError(t, Me, Ie) {
    return this.throwError(t, Logger.errors.INVALID_ARGUMENT, {
      argument: Me,
      value: Ie
    });
  }
  assert(t, Me, Ie, Pe) {
    t || this.throwError(Me, Ie, Pe);
  }
  assertArgument(t, Me, Ie, Pe) {
    t || this.throwArgumentError(Me, Ie, Pe);
  }
  checkNormalize(t) {
    _normalizeError && this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: _normalizeError
    });
  }
  checkSafeUint53(t, Me) {
    typeof t == "number" && (Me == null && (Me = "value not safe"), (t < 0 || t >= 9007199254740991) && this.throwError(Me, Logger.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: t
    }), t % 1 && this.throwError(Me, Logger.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: t
    }));
  }
  checkArgumentCount(t, Me, Ie) {
    Ie ? Ie = ": " + Ie : Ie = "", t < Me && this.throwError("missing argument" + Ie, Logger.errors.MISSING_ARGUMENT, {
      count: t,
      expectedCount: Me
    }), t > Me && this.throwError("too many arguments" + Ie, Logger.errors.UNEXPECTED_ARGUMENT, {
      count: t,
      expectedCount: Me
    });
  }
  checkNew(t, Me) {
    (t === Object || t == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: Me.name });
  }
  checkAbstract(t, Me) {
    t === Me ? this.throwError("cannot instantiate abstract class " + JSON.stringify(Me.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: t.name, operation: "new" }) : (t === Object || t == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: Me.name });
  }
  static globalLogger() {
    return _globalLogger || (_globalLogger = new Logger(version$4)), _globalLogger;
  }
  static setCensorship(t, Me) {
    if (!t && Me && this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), _permanentCensorErrors) {
      if (!t)
        return;
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!t, _permanentCensorErrors = !!Me;
  }
  static setLogLevel(t) {
    const Me = LogLevels[t.toLowerCase()];
    if (Me == null) {
      Logger.globalLogger().warn("invalid log level - " + t);
      return;
    }
    _logLevel = Me;
  }
  static from(t) {
    return new Logger(t);
  }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
const version$3 = "bytes/5.7.0", logger$3 = new Logger(version$3);
function isHexable(Ae) {
  return !!Ae.toHexString;
}
function addSlice(Ae) {
  return Ae.slice || (Ae.slice = function() {
    const t = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(Ae, t)));
  }), Ae;
}
function isBytesLike(Ae) {
  return isHexString(Ae) && !(Ae.length % 2) || isBytes(Ae);
}
function isInteger(Ae) {
  return typeof Ae == "number" && Ae == Ae && Ae % 1 === 0;
}
function isBytes(Ae) {
  if (Ae == null)
    return !1;
  if (Ae.constructor === Uint8Array)
    return !0;
  if (typeof Ae == "string" || !isInteger(Ae.length) || Ae.length < 0)
    return !1;
  for (let t = 0; t < Ae.length; t++) {
    const Me = Ae[t];
    if (!isInteger(Me) || Me < 0 || Me >= 256)
      return !1;
  }
  return !0;
}
function arrayify(Ae, t) {
  if (t || (t = {}), typeof Ae == "number") {
    logger$3.checkSafeUint53(Ae, "invalid arrayify value");
    const Me = [];
    for (; Ae; )
      Me.unshift(Ae & 255), Ae = parseInt(String(Ae / 256));
    return Me.length === 0 && Me.push(0), addSlice(new Uint8Array(Me));
  }
  if (t.allowMissingPrefix && typeof Ae == "string" && Ae.substring(0, 2) !== "0x" && (Ae = "0x" + Ae), isHexable(Ae) && (Ae = Ae.toHexString()), isHexString(Ae)) {
    let Me = Ae.substring(2);
    Me.length % 2 && (t.hexPad === "left" ? Me = "0" + Me : t.hexPad === "right" ? Me += "0" : logger$3.throwArgumentError("hex data is odd-length", "value", Ae));
    const Ie = [];
    for (let Pe = 0; Pe < Me.length; Pe += 2)
      Ie.push(parseInt(Me.substring(Pe, Pe + 2), 16));
    return addSlice(new Uint8Array(Ie));
  }
  return isBytes(Ae) ? addSlice(new Uint8Array(Ae)) : logger$3.throwArgumentError("invalid arrayify value", "value", Ae);
}
function concat(Ae) {
  const t = Ae.map((Pe) => arrayify(Pe)), Me = t.reduce((Pe, Be) => Pe + Be.length, 0), Ie = new Uint8Array(Me);
  return t.reduce((Pe, Be) => (Ie.set(Be, Pe), Pe + Be.length), 0), addSlice(Ie);
}
function zeroPad(Ae, t) {
  Ae = arrayify(Ae), Ae.length > t && logger$3.throwArgumentError("value out of range", "value", arguments[0]);
  const Me = new Uint8Array(t);
  return Me.set(Ae, t - Ae.length), addSlice(Me);
}
function isHexString(Ae, t) {
  return !(typeof Ae != "string" || !Ae.match(/^0x[0-9A-Fa-f]*$/) || t && Ae.length !== 2 + 2 * t);
}
const HexCharacters = "0123456789abcdef";
function hexlify(Ae, t) {
  if (t || (t = {}), typeof Ae == "number") {
    logger$3.checkSafeUint53(Ae, "invalid hexlify value");
    let Me = "";
    for (; Ae; )
      Me = HexCharacters[Ae & 15] + Me, Ae = Math.floor(Ae / 16);
    return Me.length ? (Me.length % 2 && (Me = "0" + Me), "0x" + Me) : "0x00";
  }
  if (typeof Ae == "bigint")
    return Ae = Ae.toString(16), Ae.length % 2 ? "0x0" + Ae : "0x" + Ae;
  if (t.allowMissingPrefix && typeof Ae == "string" && Ae.substring(0, 2) !== "0x" && (Ae = "0x" + Ae), isHexable(Ae))
    return Ae.toHexString();
  if (isHexString(Ae))
    return Ae.length % 2 && (t.hexPad === "left" ? Ae = "0x0" + Ae.substring(2) : t.hexPad === "right" ? Ae += "0" : logger$3.throwArgumentError("hex data is odd-length", "value", Ae)), Ae.toLowerCase();
  if (isBytes(Ae)) {
    let Me = "0x";
    for (let Ie = 0; Ie < Ae.length; Ie++) {
      let Pe = Ae[Ie];
      Me += HexCharacters[(Pe & 240) >> 4] + HexCharacters[Pe & 15];
    }
    return Me;
  }
  return logger$3.throwArgumentError("invalid hexlify value", "value", Ae);
}
function hexDataLength(Ae) {
  if (typeof Ae != "string")
    Ae = hexlify(Ae);
  else if (!isHexString(Ae) || Ae.length % 2)
    return null;
  return (Ae.length - 2) / 2;
}
function hexDataSlice(Ae, t, Me) {
  return typeof Ae != "string" ? Ae = hexlify(Ae) : (!isHexString(Ae) || Ae.length % 2) && logger$3.throwArgumentError("invalid hexData", "value", Ae), t = 2 + 2 * t, "0x" + Ae.substring(t);
}
function hexZeroPad(Ae, t) {
  for (typeof Ae != "string" ? Ae = hexlify(Ae) : isHexString(Ae) || logger$3.throwArgumentError("invalid hex string", "value", Ae), Ae.length > 2 * t + 2 && logger$3.throwArgumentError("value out of range", "value", arguments[1]); Ae.length < 2 * t + 2; )
    Ae = "0x0" + Ae.substring(2);
  return Ae;
}
function splitSignature(Ae) {
  const t = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(Ae)) {
    let Me = arrayify(Ae);
    Me.length === 64 ? (t.v = 27 + (Me[32] >> 7), Me[32] &= 127, t.r = hexlify(Me.slice(0, 32)), t.s = hexlify(Me.slice(32, 64))) : Me.length === 65 ? (t.r = hexlify(Me.slice(0, 32)), t.s = hexlify(Me.slice(32, 64)), t.v = Me[64]) : logger$3.throwArgumentError("invalid signature string", "signature", Ae), t.v < 27 && (t.v === 0 || t.v === 1 ? t.v += 27 : logger$3.throwArgumentError("signature invalid v byte", "signature", Ae)), t.recoveryParam = 1 - t.v % 2, t.recoveryParam && (Me[32] |= 128), t._vs = hexlify(Me.slice(32, 64));
  } else {
    if (t.r = Ae.r, t.s = Ae.s, t.v = Ae.v, t.recoveryParam = Ae.recoveryParam, t._vs = Ae._vs, t._vs != null) {
      const Pe = zeroPad(arrayify(t._vs), 32);
      t._vs = hexlify(Pe);
      const Be = Pe[0] >= 128 ? 1 : 0;
      t.recoveryParam == null ? t.recoveryParam = Be : t.recoveryParam !== Be && logger$3.throwArgumentError("signature recoveryParam mismatch _vs", "signature", Ae), Pe[0] &= 127;
      const Te = hexlify(Pe);
      t.s == null ? t.s = Te : t.s !== Te && logger$3.throwArgumentError("signature v mismatch _vs", "signature", Ae);
    }
    if (t.recoveryParam == null)
      t.v == null ? logger$3.throwArgumentError("signature missing v and recoveryParam", "signature", Ae) : t.v === 0 || t.v === 1 ? t.recoveryParam = t.v : t.recoveryParam = 1 - t.v % 2;
    else if (t.v == null)
      t.v = 27 + t.recoveryParam;
    else {
      const Pe = t.v === 0 || t.v === 1 ? t.v : 1 - t.v % 2;
      t.recoveryParam !== Pe && logger$3.throwArgumentError("signature recoveryParam mismatch v", "signature", Ae);
    }
    t.r == null || !isHexString(t.r) ? logger$3.throwArgumentError("signature missing or invalid r", "signature", Ae) : t.r = hexZeroPad(t.r, 32), t.s == null || !isHexString(t.s) ? logger$3.throwArgumentError("signature missing or invalid s", "signature", Ae) : t.s = hexZeroPad(t.s, 32);
    const Me = arrayify(t.s);
    Me[0] >= 128 && logger$3.throwArgumentError("signature s out of range", "signature", Ae), t.recoveryParam && (Me[0] |= 128);
    const Ie = hexlify(Me);
    t._vs && (isHexString(t._vs) || logger$3.throwArgumentError("signature invalid _vs", "signature", Ae), t._vs = hexZeroPad(t._vs, 32)), t._vs == null ? t._vs = Ie : t._vs !== Ie && logger$3.throwArgumentError("signature _vs mismatch v and s", "signature", Ae);
  }
  return t.yParityAndS = t._vs, t.compact = t.r + t.yParityAndS.substring(2), t;
}
function keccak256(Ae) {
  return "0x" + sha3.keccak_256(arrayify(Ae));
}
var BN = BN$8.BN;
function _base36To16(Ae) {
  return new BN(Ae, 36).toString(16);
}
const version$2 = "strings/5.7.0", logger$2 = new Logger(version$2);
var UnicodeNormalizationForm;
(function(Ae) {
  Ae.current = "", Ae.NFC = "NFC", Ae.NFD = "NFD", Ae.NFKC = "NFKC", Ae.NFKD = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Ae) {
  Ae.UNEXPECTED_CONTINUE = "unexpected continuation byte", Ae.BAD_PREFIX = "bad codepoint prefix", Ae.OVERRUN = "string overrun", Ae.MISSING_CONTINUE = "missing continuation byte", Ae.OUT_OF_RANGE = "out of UTF-8 range", Ae.UTF16_SURROGATE = "UTF-16 surrogate", Ae.OVERLONG = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function toUtf8Bytes(Ae, t = UnicodeNormalizationForm.current) {
  t != UnicodeNormalizationForm.current && (logger$2.checkNormalize(), Ae = Ae.normalize(t));
  let Me = [];
  for (let Ie = 0; Ie < Ae.length; Ie++) {
    const Pe = Ae.charCodeAt(Ie);
    if (Pe < 128)
      Me.push(Pe);
    else if (Pe < 2048)
      Me.push(Pe >> 6 | 192), Me.push(Pe & 63 | 128);
    else if ((Pe & 64512) == 55296) {
      Ie++;
      const Be = Ae.charCodeAt(Ie);
      if (Ie >= Ae.length || (Be & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const Te = 65536 + ((Pe & 1023) << 10) + (Be & 1023);
      Me.push(Te >> 18 | 240), Me.push(Te >> 12 & 63 | 128), Me.push(Te >> 6 & 63 | 128), Me.push(Te & 63 | 128);
    } else
      Me.push(Pe >> 12 | 224), Me.push(Pe >> 6 & 63 | 128), Me.push(Pe & 63 | 128);
  }
  return arrayify(Me);
}
const messagePrefix = `Ethereum Signed Message:
`;
function hashMessage(Ae) {
  return typeof Ae == "string" && (Ae = toUtf8Bytes(Ae)), keccak256(concat([
    toUtf8Bytes(messagePrefix),
    toUtf8Bytes(String(Ae.length)),
    Ae
  ]));
}
const version$1 = "address/5.7.0", logger$1 = new Logger(version$1);
function getChecksumAddress(Ae) {
  isHexString(Ae, 20) || logger$1.throwArgumentError("invalid address", "address", Ae), Ae = Ae.toLowerCase();
  const t = Ae.substring(2).split(""), Me = new Uint8Array(40);
  for (let Pe = 0; Pe < 40; Pe++)
    Me[Pe] = t[Pe].charCodeAt(0);
  const Ie = arrayify(keccak256(Me));
  for (let Pe = 0; Pe < 40; Pe += 2)
    Ie[Pe >> 1] >> 4 >= 8 && (t[Pe] = t[Pe].toUpperCase()), (Ie[Pe >> 1] & 15) >= 8 && (t[Pe + 1] = t[Pe + 1].toUpperCase());
  return "0x" + t.join("");
}
const MAX_SAFE_INTEGER = 9007199254740991;
function log10(Ae) {
  return Math.log10 ? Math.log10(Ae) : Math.log(Ae) / Math.LN10;
}
const ibanLookup = {};
for (let Ae = 0; Ae < 10; Ae++)
  ibanLookup[String(Ae)] = String(Ae);
for (let Ae = 0; Ae < 26; Ae++)
  ibanLookup[String.fromCharCode(65 + Ae)] = String(10 + Ae);
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(Ae) {
  Ae = Ae.toUpperCase(), Ae = Ae.substring(4) + Ae.substring(0, 2) + "00";
  let t = Ae.split("").map((Ie) => ibanLookup[Ie]).join("");
  for (; t.length >= safeDigits; ) {
    let Ie = t.substring(0, safeDigits);
    t = parseInt(Ie, 10) % 97 + t.substring(Ie.length);
  }
  let Me = String(98 - parseInt(t, 10) % 97);
  for (; Me.length < 2; )
    Me = "0" + Me;
  return Me;
}
function getAddress(Ae) {
  let t = null;
  if (typeof Ae != "string" && logger$1.throwArgumentError("invalid address", "address", Ae), Ae.match(/^(0x)?[0-9a-fA-F]{40}$/))
    Ae.substring(0, 2) !== "0x" && (Ae = "0x" + Ae), t = getChecksumAddress(Ae), Ae.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && t !== Ae && logger$1.throwArgumentError("bad address checksum", "address", Ae);
  else if (Ae.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (Ae.substring(2, 4) !== ibanChecksum(Ae) && logger$1.throwArgumentError("bad icap checksum", "address", Ae), t = _base36To16(Ae.substring(4)); t.length < 40; )
      t = "0" + t;
    t = getChecksumAddress("0x" + t);
  } else
    logger$1.throwArgumentError("invalid address", "address", Ae);
  return t;
}
function defineReadOnly(Ae, t, Me) {
  Object.defineProperty(Ae, t, {
    enumerable: !0,
    value: Me,
    writable: !1
  });
}
function createCommonjsModule(Ae, t, Me) {
  return Me = {
    path: t,
    exports: {},
    require: function(Ie, Pe) {
      return commonjsRequire(Ie, Pe ?? Me.path);
    }
  }, Ae(Me, Me.exports), Me.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert;
function assert(Ae, t) {
  if (!Ae)
    throw new Error(t || "Assertion failed");
}
assert.equal = function Ae(t, Me, Ie) {
  if (t != Me)
    throw new Error(Ie || "Assertion failed: " + t + " != " + Me);
};
var utils_1 = createCommonjsModule(function(Ae, t) {
  var Me = t;
  function Ie(Te, je) {
    if (Array.isArray(Te))
      return Te.slice();
    if (!Te)
      return [];
    var Ve = [];
    if (typeof Te != "string") {
      for (var fi = 0; fi < Te.length; fi++)
        Ve[fi] = Te[fi] | 0;
      return Ve;
    }
    if (je === "hex") {
      Te = Te.replace(/[^a-z0-9]+/ig, ""), Te.length % 2 !== 0 && (Te = "0" + Te);
      for (var fi = 0; fi < Te.length; fi += 2)
        Ve.push(parseInt(Te[fi] + Te[fi + 1], 16));
    } else
      for (var fi = 0; fi < Te.length; fi++) {
        var Ue = Te.charCodeAt(fi), bi = Ue >> 8, vi = Ue & 255;
        bi ? Ve.push(bi, vi) : Ve.push(vi);
      }
    return Ve;
  }
  Me.toArray = Ie;
  function Pe(Te) {
    return Te.length === 1 ? "0" + Te : Te;
  }
  Me.zero2 = Pe;
  function Be(Te) {
    for (var je = "", Ve = 0; Ve < Te.length; Ve++)
      je += Pe(Te[Ve].toString(16));
    return je;
  }
  Me.toHex = Be, Me.encode = function(je, Ve) {
    return Ve === "hex" ? Be(je) : je;
  };
}), utils_1$1 = createCommonjsModule(function(Ae, t) {
  var Me = t;
  Me.assert = minimalisticAssert, Me.toArray = utils_1.toArray, Me.zero2 = utils_1.zero2, Me.toHex = utils_1.toHex, Me.encode = utils_1.encode;
  function Ie(Ve, fi, Ue) {
    var bi = new Array(Math.max(Ve.bitLength(), Ue) + 1);
    bi.fill(0);
    for (var vi = 1 << fi + 1, mi = Ve.clone(), _i = 0; _i < bi.length; _i++) {
      var $i, Ci = mi.andln(vi - 1);
      mi.isOdd() ? (Ci > (vi >> 1) - 1 ? $i = (vi >> 1) - Ci : $i = Ci, mi.isubn($i)) : $i = 0, bi[_i] = $i, mi.iushrn(1);
    }
    return bi;
  }
  Me.getNAF = Ie;
  function Pe(Ve, fi) {
    var Ue = [
      [],
      []
    ];
    Ve = Ve.clone(), fi = fi.clone();
    for (var bi = 0, vi = 0, mi; Ve.cmpn(-bi) > 0 || fi.cmpn(-vi) > 0; ) {
      var _i = Ve.andln(3) + bi & 3, $i = fi.andln(3) + vi & 3;
      _i === 3 && (_i = -1), $i === 3 && ($i = -1);
      var Ci;
      _i & 1 ? (mi = Ve.andln(7) + bi & 7, (mi === 3 || mi === 5) && $i === 2 ? Ci = -_i : Ci = _i) : Ci = 0, Ue[0].push(Ci);
      var Ui;
      $i & 1 ? (mi = fi.andln(7) + vi & 7, (mi === 3 || mi === 5) && _i === 2 ? Ui = -$i : Ui = $i) : Ui = 0, Ue[1].push(Ui), 2 * bi === Ci + 1 && (bi = 1 - bi), 2 * vi === Ui + 1 && (vi = 1 - vi), Ve.iushrn(1), fi.iushrn(1);
    }
    return Ue;
  }
  Me.getJSF = Pe;
  function Be(Ve, fi, Ue) {
    var bi = "_" + fi;
    Ve.prototype[fi] = function() {
      return this[bi] !== void 0 ? this[bi] : this[bi] = Ue.call(this);
    };
  }
  Me.cachedProperty = Be;
  function Te(Ve) {
    return typeof Ve == "string" ? Me.toArray(Ve, "hex") : Ve;
  }
  Me.parseBytes = Te;
  function je(Ve) {
    return new BN$8(Ve, "hex", "le");
  }
  Me.intFromLE = je;
}), getNAF = utils_1$1.getNAF, getJSF = utils_1$1.getJSF, assert$1 = utils_1$1.assert;
function BaseCurve(Ae, t) {
  this.type = Ae, this.p = new BN$8(t.p, 16), this.red = t.prime ? BN$8.red(t.prime) : BN$8.mont(this.p), this.zero = new BN$8(0).toRed(this.red), this.one = new BN$8(1).toRed(this.red), this.two = new BN$8(2).toRed(this.red), this.n = t.n && new BN$8(t.n, 16), this.g = t.g && this.pointFromJSON(t.g, t.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var Me = this.n && this.p.div(this.n);
  !Me || Me.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base = BaseCurve;
BaseCurve.prototype.point = function Ae() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function Ae() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function Ae(t, Me) {
  assert$1(t.precomputed);
  var Ie = t._getDoubles(), Pe = getNAF(Me, 1, this._bitLength), Be = (1 << Ie.step + 1) - (Ie.step % 2 === 0 ? 2 : 1);
  Be /= 3;
  var Te = [], je, Ve;
  for (je = 0; je < Pe.length; je += Ie.step) {
    Ve = 0;
    for (var fi = je + Ie.step - 1; fi >= je; fi--)
      Ve = (Ve << 1) + Pe[fi];
    Te.push(Ve);
  }
  for (var Ue = this.jpoint(null, null, null), bi = this.jpoint(null, null, null), vi = Be; vi > 0; vi--) {
    for (je = 0; je < Te.length; je++)
      Ve = Te[je], Ve === vi ? bi = bi.mixedAdd(Ie.points[je]) : Ve === -vi && (bi = bi.mixedAdd(Ie.points[je].neg()));
    Ue = Ue.add(bi);
  }
  return Ue.toP();
};
BaseCurve.prototype._wnafMul = function Ae(t, Me) {
  var Ie = 4, Pe = t._getNAFPoints(Ie);
  Ie = Pe.wnd;
  for (var Be = Pe.points, Te = getNAF(Me, Ie, this._bitLength), je = this.jpoint(null, null, null), Ve = Te.length - 1; Ve >= 0; Ve--) {
    for (var fi = 0; Ve >= 0 && Te[Ve] === 0; Ve--)
      fi++;
    if (Ve >= 0 && fi++, je = je.dblp(fi), Ve < 0)
      break;
    var Ue = Te[Ve];
    assert$1(Ue !== 0), t.type === "affine" ? Ue > 0 ? je = je.mixedAdd(Be[Ue - 1 >> 1]) : je = je.mixedAdd(Be[-Ue - 1 >> 1].neg()) : Ue > 0 ? je = je.add(Be[Ue - 1 >> 1]) : je = je.add(Be[-Ue - 1 >> 1].neg());
  }
  return t.type === "affine" ? je.toP() : je;
};
BaseCurve.prototype._wnafMulAdd = function Ae(t, Me, Ie, Pe, Be) {
  var Te = this._wnafT1, je = this._wnafT2, Ve = this._wnafT3, fi = 0, Ue, bi, vi;
  for (Ue = 0; Ue < Pe; Ue++) {
    vi = Me[Ue];
    var mi = vi._getNAFPoints(t);
    Te[Ue] = mi.wnd, je[Ue] = mi.points;
  }
  for (Ue = Pe - 1; Ue >= 1; Ue -= 2) {
    var _i = Ue - 1, $i = Ue;
    if (Te[_i] !== 1 || Te[$i] !== 1) {
      Ve[_i] = getNAF(Ie[_i], Te[_i], this._bitLength), Ve[$i] = getNAF(Ie[$i], Te[$i], this._bitLength), fi = Math.max(Ve[_i].length, fi), fi = Math.max(Ve[$i].length, fi);
      continue;
    }
    var Ci = [
      Me[_i],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      Me[$i]
      /* 7 */
    ];
    Me[_i].y.cmp(Me[$i].y) === 0 ? (Ci[1] = Me[_i].add(Me[$i]), Ci[2] = Me[_i].toJ().mixedAdd(Me[$i].neg())) : Me[_i].y.cmp(Me[$i].y.redNeg()) === 0 ? (Ci[1] = Me[_i].toJ().mixedAdd(Me[$i]), Ci[2] = Me[_i].add(Me[$i].neg())) : (Ci[1] = Me[_i].toJ().mixedAdd(Me[$i]), Ci[2] = Me[_i].toJ().mixedAdd(Me[$i].neg()));
    var Ui = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], ki = getJSF(Ie[_i], Ie[$i]);
    for (fi = Math.max(ki[0].length, fi), Ve[_i] = new Array(fi), Ve[$i] = new Array(fi), bi = 0; bi < fi; bi++) {
      var Ji = ki[0][bi] | 0, Hi = ki[1][bi] | 0;
      Ve[_i][bi] = Ui[(Ji + 1) * 3 + (Hi + 1)], Ve[$i][bi] = 0, je[_i] = Ci;
    }
  }
  var Zi = this.jpoint(null, null, null), Qi = this._wnafT4;
  for (Ue = fi; Ue >= 0; Ue--) {
    for (var Bi = 0; Ue >= 0; ) {
      var Xi = !0;
      for (bi = 0; bi < Pe; bi++)
        Qi[bi] = Ve[bi][Ue] | 0, Qi[bi] !== 0 && (Xi = !1);
      if (!Xi)
        break;
      Bi++, Ue--;
    }
    if (Ue >= 0 && Bi++, Zi = Zi.dblp(Bi), Ue < 0)
      break;
    for (bi = 0; bi < Pe; bi++) {
      var ns = Qi[bi];
      ns !== 0 && (ns > 0 ? vi = je[bi][ns - 1 >> 1] : ns < 0 && (vi = je[bi][-ns - 1 >> 1].neg()), vi.type === "affine" ? Zi = Zi.mixedAdd(vi) : Zi = Zi.add(vi));
    }
  }
  for (Ue = 0; Ue < Pe; Ue++)
    je[Ue] = null;
  return Be ? Zi : Zi.toP();
};
function BasePoint(Ae, t) {
  this.curve = Ae, this.type = t, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function Ae() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function Ae() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function Ae(t, Me) {
  t = utils_1$1.toArray(t, Me);
  var Ie = this.p.byteLength();
  if ((t[0] === 4 || t[0] === 6 || t[0] === 7) && t.length - 1 === 2 * Ie) {
    t[0] === 6 ? assert$1(t[t.length - 1] % 2 === 0) : t[0] === 7 && assert$1(t[t.length - 1] % 2 === 1);
    var Pe = this.point(
      t.slice(1, 1 + Ie),
      t.slice(1 + Ie, 1 + 2 * Ie)
    );
    return Pe;
  } else if ((t[0] === 2 || t[0] === 3) && t.length - 1 === Ie)
    return this.pointFromX(t.slice(1, 1 + Ie), t[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function Ae(t) {
  return this.encode(t, !0);
};
BasePoint.prototype._encode = function Ae(t) {
  var Me = this.curve.p.byteLength(), Ie = this.getX().toArray("be", Me);
  return t ? [this.getY().isEven() ? 2 : 3].concat(Ie) : [4].concat(Ie, this.getY().toArray("be", Me));
};
BasePoint.prototype.encode = function Ae(t, Me) {
  return utils_1$1.encode(this._encode(Me), t);
};
BasePoint.prototype.precompute = function Ae(t) {
  if (this.precomputed)
    return this;
  var Me = {
    doubles: null,
    naf: null,
    beta: null
  };
  return Me.naf = this._getNAFPoints(8), Me.doubles = this._getDoubles(4, t), Me.beta = this._getBeta(), this.precomputed = Me, this;
};
BasePoint.prototype._hasDoubles = function Ae(t) {
  if (!this.precomputed)
    return !1;
  var Me = this.precomputed.doubles;
  return Me ? Me.points.length >= Math.ceil((t.bitLength() + 1) / Me.step) : !1;
};
BasePoint.prototype._getDoubles = function Ae(t, Me) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var Ie = [this], Pe = this, Be = 0; Be < Me; Be += t) {
    for (var Te = 0; Te < t; Te++)
      Pe = Pe.dbl();
    Ie.push(Pe);
  }
  return {
    step: t,
    points: Ie
  };
};
BasePoint.prototype._getNAFPoints = function Ae(t) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var Me = [this], Ie = (1 << t) - 1, Pe = Ie === 1 ? null : this.dbl(), Be = 1; Be < Ie; Be++)
    Me[Be] = Me[Be - 1].add(Pe);
  return {
    wnd: t,
    points: Me
  };
};
BasePoint.prototype._getBeta = function Ae() {
  return null;
};
BasePoint.prototype.dblp = function Ae(t) {
  for (var Me = this, Ie = 0; Ie < t; Ie++)
    Me = Me.dbl();
  return Me;
};
var inherits_browser = createCommonjsModule(function(Ae) {
  typeof Object.create == "function" ? Ae.exports = function(Me, Ie) {
    Ie && (Me.super_ = Ie, Me.prototype = Object.create(Ie.prototype, {
      constructor: {
        value: Me,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : Ae.exports = function(Me, Ie) {
    if (Ie) {
      Me.super_ = Ie;
      var Pe = function() {
      };
      Pe.prototype = Ie.prototype, Me.prototype = new Pe(), Me.prototype.constructor = Me;
    }
  };
}), assert$2 = utils_1$1.assert;
function ShortCurve(Ae) {
  base.call(this, "short", Ae), this.a = new BN$8(Ae.a, 16).toRed(this.red), this.b = new BN$8(Ae.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(Ae), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function Ae(t) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var Me, Ie;
    if (t.beta)
      Me = new BN$8(t.beta, 16).toRed(this.red);
    else {
      var Pe = this._getEndoRoots(this.p);
      Me = Pe[0].cmp(Pe[1]) < 0 ? Pe[0] : Pe[1], Me = Me.toRed(this.red);
    }
    if (t.lambda)
      Ie = new BN$8(t.lambda, 16);
    else {
      var Be = this._getEndoRoots(this.n);
      this.g.mul(Be[0]).x.cmp(this.g.x.redMul(Me)) === 0 ? Ie = Be[0] : (Ie = Be[1], assert$2(this.g.mul(Ie).x.cmp(this.g.x.redMul(Me)) === 0));
    }
    var Te;
    return t.basis ? Te = t.basis.map(function(je) {
      return {
        a: new BN$8(je.a, 16),
        b: new BN$8(je.b, 16)
      };
    }) : Te = this._getEndoBasis(Ie), {
      beta: Me,
      lambda: Ie,
      basis: Te
    };
  }
};
ShortCurve.prototype._getEndoRoots = function Ae(t) {
  var Me = t === this.p ? this.red : BN$8.mont(t), Ie = new BN$8(2).toRed(Me).redInvm(), Pe = Ie.redNeg(), Be = new BN$8(3).toRed(Me).redNeg().redSqrt().redMul(Ie), Te = Pe.redAdd(Be).fromRed(), je = Pe.redSub(Be).fromRed();
  return [Te, je];
};
ShortCurve.prototype._getEndoBasis = function Ae(t) {
  for (var Me = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), Ie = t, Pe = this.n.clone(), Be = new BN$8(1), Te = new BN$8(0), je = new BN$8(0), Ve = new BN$8(1), fi, Ue, bi, vi, mi, _i, $i, Ci = 0, Ui, ki; Ie.cmpn(0) !== 0; ) {
    var Ji = Pe.div(Ie);
    Ui = Pe.sub(Ji.mul(Ie)), ki = je.sub(Ji.mul(Be));
    var Hi = Ve.sub(Ji.mul(Te));
    if (!bi && Ui.cmp(Me) < 0)
      fi = $i.neg(), Ue = Be, bi = Ui.neg(), vi = ki;
    else if (bi && ++Ci === 2)
      break;
    $i = Ui, Pe = Ie, Ie = Ui, je = Be, Be = ki, Ve = Te, Te = Hi;
  }
  mi = Ui.neg(), _i = ki;
  var Zi = bi.sqr().add(vi.sqr()), Qi = mi.sqr().add(_i.sqr());
  return Qi.cmp(Zi) >= 0 && (mi = fi, _i = Ue), bi.negative && (bi = bi.neg(), vi = vi.neg()), mi.negative && (mi = mi.neg(), _i = _i.neg()), [
    { a: bi, b: vi },
    { a: mi, b: _i }
  ];
};
ShortCurve.prototype._endoSplit = function Ae(t) {
  var Me = this.endo.basis, Ie = Me[0], Pe = Me[1], Be = Pe.b.mul(t).divRound(this.n), Te = Ie.b.neg().mul(t).divRound(this.n), je = Be.mul(Ie.a), Ve = Te.mul(Pe.a), fi = Be.mul(Ie.b), Ue = Te.mul(Pe.b), bi = t.sub(je).sub(Ve), vi = fi.add(Ue).neg();
  return { k1: bi, k2: vi };
};
ShortCurve.prototype.pointFromX = function Ae(t, Me) {
  t = new BN$8(t, 16), t.red || (t = t.toRed(this.red));
  var Ie = t.redSqr().redMul(t).redIAdd(t.redMul(this.a)).redIAdd(this.b), Pe = Ie.redSqrt();
  if (Pe.redSqr().redSub(Ie).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var Be = Pe.fromRed().isOdd();
  return (Me && !Be || !Me && Be) && (Pe = Pe.redNeg()), this.point(t, Pe);
};
ShortCurve.prototype.validate = function Ae(t) {
  if (t.inf)
    return !0;
  var Me = t.x, Ie = t.y, Pe = this.a.redMul(Me), Be = Me.redSqr().redMul(Me).redIAdd(Pe).redIAdd(this.b);
  return Ie.redSqr().redISub(Be).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function Ae(t, Me, Ie) {
  for (var Pe = this._endoWnafT1, Be = this._endoWnafT2, Te = 0; Te < t.length; Te++) {
    var je = this._endoSplit(Me[Te]), Ve = t[Te], fi = Ve._getBeta();
    je.k1.negative && (je.k1.ineg(), Ve = Ve.neg(!0)), je.k2.negative && (je.k2.ineg(), fi = fi.neg(!0)), Pe[Te * 2] = Ve, Pe[Te * 2 + 1] = fi, Be[Te * 2] = je.k1, Be[Te * 2 + 1] = je.k2;
  }
  for (var Ue = this._wnafMulAdd(1, Pe, Be, Te * 2, Ie), bi = 0; bi < Te * 2; bi++)
    Pe[bi] = null, Be[bi] = null;
  return Ue;
};
function Point(Ae, t, Me, Ie) {
  base.BasePoint.call(this, Ae, "affine"), t === null && Me === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$8(t, 16), this.y = new BN$8(Me, 16), Ie && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits_browser(Point, base.BasePoint);
ShortCurve.prototype.point = function Ae(t, Me, Ie) {
  return new Point(this, t, Me, Ie);
};
ShortCurve.prototype.pointFromJSON = function Ae(t, Me) {
  return Point.fromJSON(this, t, Me);
};
Point.prototype._getBeta = function Ae() {
  if (this.curve.endo) {
    var t = this.precomputed;
    if (t && t.beta)
      return t.beta;
    var Me = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (t) {
      var Ie = this.curve, Pe = function(Be) {
        return Ie.point(Be.x.redMul(Ie.endo.beta), Be.y);
      };
      t.beta = Me, Me.precomputed = {
        beta: null,
        naf: t.naf && {
          wnd: t.naf.wnd,
          points: t.naf.points.map(Pe)
        },
        doubles: t.doubles && {
          step: t.doubles.step,
          points: t.doubles.points.map(Pe)
        }
      };
    }
    return Me;
  }
};
Point.prototype.toJSON = function Ae() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point.fromJSON = function Ae(t, Me, Ie) {
  typeof Me == "string" && (Me = JSON.parse(Me));
  var Pe = t.point(Me[0], Me[1], Ie);
  if (!Me[2])
    return Pe;
  function Be(je) {
    return t.point(je[0], je[1], Ie);
  }
  var Te = Me[2];
  return Pe.precomputed = {
    beta: null,
    doubles: Te.doubles && {
      step: Te.doubles.step,
      points: [Pe].concat(Te.doubles.points.map(Be))
    },
    naf: Te.naf && {
      wnd: Te.naf.wnd,
      points: [Pe].concat(Te.naf.points.map(Be))
    }
  }, Pe;
};
Point.prototype.inspect = function Ae() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function Ae() {
  return this.inf;
};
Point.prototype.add = function Ae(t) {
  if (this.inf)
    return t;
  if (t.inf)
    return this;
  if (this.eq(t))
    return this.dbl();
  if (this.neg().eq(t))
    return this.curve.point(null, null);
  if (this.x.cmp(t.x) === 0)
    return this.curve.point(null, null);
  var Me = this.y.redSub(t.y);
  Me.cmpn(0) !== 0 && (Me = Me.redMul(this.x.redSub(t.x).redInvm()));
  var Ie = Me.redSqr().redISub(this.x).redISub(t.x), Pe = Me.redMul(this.x.redSub(Ie)).redISub(this.y);
  return this.curve.point(Ie, Pe);
};
Point.prototype.dbl = function Ae() {
  if (this.inf)
    return this;
  var t = this.y.redAdd(this.y);
  if (t.cmpn(0) === 0)
    return this.curve.point(null, null);
  var Me = this.curve.a, Ie = this.x.redSqr(), Pe = t.redInvm(), Be = Ie.redAdd(Ie).redIAdd(Ie).redIAdd(Me).redMul(Pe), Te = Be.redSqr().redISub(this.x.redAdd(this.x)), je = Be.redMul(this.x.redSub(Te)).redISub(this.y);
  return this.curve.point(Te, je);
};
Point.prototype.getX = function Ae() {
  return this.x.fromRed();
};
Point.prototype.getY = function Ae() {
  return this.y.fromRed();
};
Point.prototype.mul = function Ae(t) {
  return t = new BN$8(t, 16), this.isInfinity() ? this : this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [t]) : this.curve._wnafMul(this, t);
};
Point.prototype.mulAdd = function Ae(t, Me, Ie) {
  var Pe = [this, Me], Be = [t, Ie];
  return this.curve.endo ? this.curve._endoWnafMulAdd(Pe, Be) : this.curve._wnafMulAdd(1, Pe, Be, 2);
};
Point.prototype.jmulAdd = function Ae(t, Me, Ie) {
  var Pe = [this, Me], Be = [t, Ie];
  return this.curve.endo ? this.curve._endoWnafMulAdd(Pe, Be, !0) : this.curve._wnafMulAdd(1, Pe, Be, 2, !0);
};
Point.prototype.eq = function Ae(t) {
  return this === t || this.inf === t.inf && (this.inf || this.x.cmp(t.x) === 0 && this.y.cmp(t.y) === 0);
};
Point.prototype.neg = function Ae(t) {
  if (this.inf)
    return this;
  var Me = this.curve.point(this.x, this.y.redNeg());
  if (t && this.precomputed) {
    var Ie = this.precomputed, Pe = function(Be) {
      return Be.neg();
    };
    Me.precomputed = {
      naf: Ie.naf && {
        wnd: Ie.naf.wnd,
        points: Ie.naf.points.map(Pe)
      },
      doubles: Ie.doubles && {
        step: Ie.doubles.step,
        points: Ie.doubles.points.map(Pe)
      }
    };
  }
  return Me;
};
Point.prototype.toJ = function Ae() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var t = this.curve.jpoint(this.x, this.y, this.curve.one);
  return t;
};
function JPoint(Ae, t, Me, Ie) {
  base.BasePoint.call(this, Ae, "jacobian"), t === null && Me === null && Ie === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$8(0)) : (this.x = new BN$8(t, 16), this.y = new BN$8(Me, 16), this.z = new BN$8(Ie, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base.BasePoint);
ShortCurve.prototype.jpoint = function Ae(t, Me, Ie) {
  return new JPoint(this, t, Me, Ie);
};
JPoint.prototype.toP = function Ae() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var t = this.z.redInvm(), Me = t.redSqr(), Ie = this.x.redMul(Me), Pe = this.y.redMul(Me).redMul(t);
  return this.curve.point(Ie, Pe);
};
JPoint.prototype.neg = function Ae() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function Ae(t) {
  if (this.isInfinity())
    return t;
  if (t.isInfinity())
    return this;
  var Me = t.z.redSqr(), Ie = this.z.redSqr(), Pe = this.x.redMul(Me), Be = t.x.redMul(Ie), Te = this.y.redMul(Me.redMul(t.z)), je = t.y.redMul(Ie.redMul(this.z)), Ve = Pe.redSub(Be), fi = Te.redSub(je);
  if (Ve.cmpn(0) === 0)
    return fi.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var Ue = Ve.redSqr(), bi = Ue.redMul(Ve), vi = Pe.redMul(Ue), mi = fi.redSqr().redIAdd(bi).redISub(vi).redISub(vi), _i = fi.redMul(vi.redISub(mi)).redISub(Te.redMul(bi)), $i = this.z.redMul(t.z).redMul(Ve);
  return this.curve.jpoint(mi, _i, $i);
};
JPoint.prototype.mixedAdd = function Ae(t) {
  if (this.isInfinity())
    return t.toJ();
  if (t.isInfinity())
    return this;
  var Me = this.z.redSqr(), Ie = this.x, Pe = t.x.redMul(Me), Be = this.y, Te = t.y.redMul(Me).redMul(this.z), je = Ie.redSub(Pe), Ve = Be.redSub(Te);
  if (je.cmpn(0) === 0)
    return Ve.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var fi = je.redSqr(), Ue = fi.redMul(je), bi = Ie.redMul(fi), vi = Ve.redSqr().redIAdd(Ue).redISub(bi).redISub(bi), mi = Ve.redMul(bi.redISub(vi)).redISub(Be.redMul(Ue)), _i = this.z.redMul(je);
  return this.curve.jpoint(vi, mi, _i);
};
JPoint.prototype.dblp = function Ae(t) {
  if (t === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!t)
    return this.dbl();
  var Me;
  if (this.curve.zeroA || this.curve.threeA) {
    var Ie = this;
    for (Me = 0; Me < t; Me++)
      Ie = Ie.dbl();
    return Ie;
  }
  var Pe = this.curve.a, Be = this.curve.tinv, Te = this.x, je = this.y, Ve = this.z, fi = Ve.redSqr().redSqr(), Ue = je.redAdd(je);
  for (Me = 0; Me < t; Me++) {
    var bi = Te.redSqr(), vi = Ue.redSqr(), mi = vi.redSqr(), _i = bi.redAdd(bi).redIAdd(bi).redIAdd(Pe.redMul(fi)), $i = Te.redMul(vi), Ci = _i.redSqr().redISub($i.redAdd($i)), Ui = $i.redISub(Ci), ki = _i.redMul(Ui);
    ki = ki.redIAdd(ki).redISub(mi);
    var Ji = Ue.redMul(Ve);
    Me + 1 < t && (fi = fi.redMul(mi)), Te = Ci, Ve = Ji, Ue = ki;
  }
  return this.curve.jpoint(Te, Ue.redMul(Be), Ve);
};
JPoint.prototype.dbl = function Ae() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function Ae() {
  var t, Me, Ie;
  if (this.zOne) {
    var Pe = this.x.redSqr(), Be = this.y.redSqr(), Te = Be.redSqr(), je = this.x.redAdd(Be).redSqr().redISub(Pe).redISub(Te);
    je = je.redIAdd(je);
    var Ve = Pe.redAdd(Pe).redIAdd(Pe), fi = Ve.redSqr().redISub(je).redISub(je), Ue = Te.redIAdd(Te);
    Ue = Ue.redIAdd(Ue), Ue = Ue.redIAdd(Ue), t = fi, Me = Ve.redMul(je.redISub(fi)).redISub(Ue), Ie = this.y.redAdd(this.y);
  } else {
    var bi = this.x.redSqr(), vi = this.y.redSqr(), mi = vi.redSqr(), _i = this.x.redAdd(vi).redSqr().redISub(bi).redISub(mi);
    _i = _i.redIAdd(_i);
    var $i = bi.redAdd(bi).redIAdd(bi), Ci = $i.redSqr(), Ui = mi.redIAdd(mi);
    Ui = Ui.redIAdd(Ui), Ui = Ui.redIAdd(Ui), t = Ci.redISub(_i).redISub(_i), Me = $i.redMul(_i.redISub(t)).redISub(Ui), Ie = this.y.redMul(this.z), Ie = Ie.redIAdd(Ie);
  }
  return this.curve.jpoint(t, Me, Ie);
};
JPoint.prototype._threeDbl = function Ae() {
  var t, Me, Ie;
  if (this.zOne) {
    var Pe = this.x.redSqr(), Be = this.y.redSqr(), Te = Be.redSqr(), je = this.x.redAdd(Be).redSqr().redISub(Pe).redISub(Te);
    je = je.redIAdd(je);
    var Ve = Pe.redAdd(Pe).redIAdd(Pe).redIAdd(this.curve.a), fi = Ve.redSqr().redISub(je).redISub(je);
    t = fi;
    var Ue = Te.redIAdd(Te);
    Ue = Ue.redIAdd(Ue), Ue = Ue.redIAdd(Ue), Me = Ve.redMul(je.redISub(fi)).redISub(Ue), Ie = this.y.redAdd(this.y);
  } else {
    var bi = this.z.redSqr(), vi = this.y.redSqr(), mi = this.x.redMul(vi), _i = this.x.redSub(bi).redMul(this.x.redAdd(bi));
    _i = _i.redAdd(_i).redIAdd(_i);
    var $i = mi.redIAdd(mi);
    $i = $i.redIAdd($i);
    var Ci = $i.redAdd($i);
    t = _i.redSqr().redISub(Ci), Ie = this.y.redAdd(this.z).redSqr().redISub(vi).redISub(bi);
    var Ui = vi.redSqr();
    Ui = Ui.redIAdd(Ui), Ui = Ui.redIAdd(Ui), Ui = Ui.redIAdd(Ui), Me = _i.redMul($i.redISub(t)).redISub(Ui);
  }
  return this.curve.jpoint(t, Me, Ie);
};
JPoint.prototype._dbl = function Ae() {
  var t = this.curve.a, Me = this.x, Ie = this.y, Pe = this.z, Be = Pe.redSqr().redSqr(), Te = Me.redSqr(), je = Ie.redSqr(), Ve = Te.redAdd(Te).redIAdd(Te).redIAdd(t.redMul(Be)), fi = Me.redAdd(Me);
  fi = fi.redIAdd(fi);
  var Ue = fi.redMul(je), bi = Ve.redSqr().redISub(Ue.redAdd(Ue)), vi = Ue.redISub(bi), mi = je.redSqr();
  mi = mi.redIAdd(mi), mi = mi.redIAdd(mi), mi = mi.redIAdd(mi);
  var _i = Ve.redMul(vi).redISub(mi), $i = Ie.redAdd(Ie).redMul(Pe);
  return this.curve.jpoint(bi, _i, $i);
};
JPoint.prototype.trpl = function Ae() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var t = this.x.redSqr(), Me = this.y.redSqr(), Ie = this.z.redSqr(), Pe = Me.redSqr(), Be = t.redAdd(t).redIAdd(t), Te = Be.redSqr(), je = this.x.redAdd(Me).redSqr().redISub(t).redISub(Pe);
  je = je.redIAdd(je), je = je.redAdd(je).redIAdd(je), je = je.redISub(Te);
  var Ve = je.redSqr(), fi = Pe.redIAdd(Pe);
  fi = fi.redIAdd(fi), fi = fi.redIAdd(fi), fi = fi.redIAdd(fi);
  var Ue = Be.redIAdd(je).redSqr().redISub(Te).redISub(Ve).redISub(fi), bi = Me.redMul(Ue);
  bi = bi.redIAdd(bi), bi = bi.redIAdd(bi);
  var vi = this.x.redMul(Ve).redISub(bi);
  vi = vi.redIAdd(vi), vi = vi.redIAdd(vi);
  var mi = this.y.redMul(Ue.redMul(fi.redISub(Ue)).redISub(je.redMul(Ve)));
  mi = mi.redIAdd(mi), mi = mi.redIAdd(mi), mi = mi.redIAdd(mi);
  var _i = this.z.redAdd(je).redSqr().redISub(Ie).redISub(Ve);
  return this.curve.jpoint(vi, mi, _i);
};
JPoint.prototype.mul = function Ae(t, Me) {
  return t = new BN$8(t, Me), this.curve._wnafMul(this, t);
};
JPoint.prototype.eq = function Ae(t) {
  if (t.type === "affine")
    return this.eq(t.toJ());
  if (this === t)
    return !0;
  var Me = this.z.redSqr(), Ie = t.z.redSqr();
  if (this.x.redMul(Ie).redISub(t.x.redMul(Me)).cmpn(0) !== 0)
    return !1;
  var Pe = Me.redMul(this.z), Be = Ie.redMul(t.z);
  return this.y.redMul(Be).redISub(t.y.redMul(Pe)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function Ae(t) {
  var Me = this.z.redSqr(), Ie = t.toRed(this.curve.red).redMul(Me);
  if (this.x.cmp(Ie) === 0)
    return !0;
  for (var Pe = t.clone(), Be = this.curve.redN.redMul(Me); ; ) {
    if (Pe.iadd(this.curve.n), Pe.cmp(this.curve.p) >= 0)
      return !1;
    if (Ie.redIAdd(Be), this.x.cmp(Ie) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function Ae() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function Ae() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(Ae, t) {
  var Me = t;
  Me.base = base, Me.short = short_1, Me.mont = /*RicMoo:ethers:require(./mont)*/
  null, Me.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
}), curves_1 = createCommonjsModule(function(Ae, t) {
  var Me = t, Ie = utils_1$1.assert;
  function Pe(je) {
    je.type === "short" ? this.curve = new curve_1.short(je) : je.type === "edwards" ? this.curve = new curve_1.edwards(je) : this.curve = new curve_1.mont(je), this.g = this.curve.g, this.n = this.curve.n, this.hash = je.hash, Ie(this.g.validate(), "Invalid curve"), Ie(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  Me.PresetCurve = Pe;
  function Be(je, Ve) {
    Object.defineProperty(Me, je, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var fi = new Pe(Ve);
        return Object.defineProperty(Me, je, {
          configurable: !0,
          enumerable: !0,
          value: fi
        }), fi;
      }
    });
  }
  Be("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash$4.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), Be("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash$4.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), Be("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash$4.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), Be("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash$4.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), Be("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash$4.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), Be("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$4.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), Be("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$4.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var Te;
  try {
    Te = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch {
    Te = void 0;
  }
  Be("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash$4.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      Te
    ]
  });
});
function HmacDRBG(Ae) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(Ae);
  this.hash = Ae.hash, this.predResist = !!Ae.predResist, this.outLen = this.hash.outSize, this.minEntropy = Ae.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var t = utils_1.toArray(Ae.entropy, Ae.entropyEnc || "hex"), Me = utils_1.toArray(Ae.nonce, Ae.nonceEnc || "hex"), Ie = utils_1.toArray(Ae.pers, Ae.persEnc || "hex");
  minimalisticAssert(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(t, Me, Ie);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function Ae(t, Me, Ie) {
  var Pe = t.concat(Me).concat(Ie);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var Be = 0; Be < this.V.length; Be++)
    this.K[Be] = 0, this.V[Be] = 1;
  this._update(Pe), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function Ae() {
  return new hash$4.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function Ae(t) {
  var Me = this._hmac().update(this.V).update([0]);
  t && (Me = Me.update(t)), this.K = Me.digest(), this.V = this._hmac().update(this.V).digest(), t && (this.K = this._hmac().update(this.V).update([1]).update(t).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG.prototype.reseed = function Ae(t, Me, Ie, Pe) {
  typeof Me != "string" && (Pe = Ie, Ie = Me, Me = null), t = utils_1.toArray(t, Me), Ie = utils_1.toArray(Ie, Pe), minimalisticAssert(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(t.concat(Ie || [])), this._reseed = 1;
};
HmacDRBG.prototype.generate = function Ae(t, Me, Ie, Pe) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof Me != "string" && (Pe = Ie, Ie = Me, Me = null), Ie && (Ie = utils_1.toArray(Ie, Pe || "hex"), this._update(Ie));
  for (var Be = []; Be.length < t; )
    this.V = this._hmac().update(this.V).digest(), Be = Be.concat(this.V);
  var Te = Be.slice(0, t);
  return this._update(Ie), this._reseed++, utils_1.encode(Te, Me);
};
var assert$3 = utils_1$1.assert;
function KeyPair(Ae, t) {
  this.ec = Ae, this.priv = null, this.pub = null, t.priv && this._importPrivate(t.priv, t.privEnc), t.pub && this._importPublic(t.pub, t.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function Ae(t, Me, Ie) {
  return Me instanceof KeyPair ? Me : new KeyPair(t, {
    pub: Me,
    pubEnc: Ie
  });
};
KeyPair.fromPrivate = function Ae(t, Me, Ie) {
  return Me instanceof KeyPair ? Me : new KeyPair(t, {
    priv: Me,
    privEnc: Ie
  });
};
KeyPair.prototype.validate = function Ae() {
  var t = this.getPublic();
  return t.isInfinity() ? { result: !1, reason: "Invalid public key" } : t.validate() ? t.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair.prototype.getPublic = function Ae(t, Me) {
  return typeof t == "string" && (Me = t, t = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), Me ? this.pub.encode(Me, t) : this.pub;
};
KeyPair.prototype.getPrivate = function Ae(t) {
  return t === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair.prototype._importPrivate = function Ae(t, Me) {
  this.priv = new BN$8(t, Me || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function Ae(t, Me) {
  if (t.x || t.y) {
    this.ec.curve.type === "mont" ? assert$3(t.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$3(t.x && t.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(t.x, t.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(t, Me);
};
KeyPair.prototype.derive = function Ae(t) {
  return t.validate() || assert$3(t.validate(), "public point not validated"), t.mul(this.priv).getX();
};
KeyPair.prototype.sign = function Ae(t, Me, Ie) {
  return this.ec.sign(t, this, Me, Ie);
};
KeyPair.prototype.verify = function Ae(t, Me) {
  return this.ec.verify(t, Me, this);
};
KeyPair.prototype.inspect = function Ae() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4 = utils_1$1.assert;
function Signature(Ae, t) {
  if (Ae instanceof Signature)
    return Ae;
  this._importDER(Ae, t) || (assert$4(Ae.r && Ae.s, "Signature without r or s"), this.r = new BN$8(Ae.r, 16), this.s = new BN$8(Ae.s, 16), Ae.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = Ae.recoveryParam);
}
var signature = Signature;
function Position() {
  this.place = 0;
}
function getLength(Ae, t) {
  var Me = Ae[t.place++];
  if (!(Me & 128))
    return Me;
  var Ie = Me & 15;
  if (Ie === 0 || Ie > 4)
    return !1;
  for (var Pe = 0, Be = 0, Te = t.place; Be < Ie; Be++, Te++)
    Pe <<= 8, Pe |= Ae[Te], Pe >>>= 0;
  return Pe <= 127 ? !1 : (t.place = Te, Pe);
}
function rmPadding(Ae) {
  for (var t = 0, Me = Ae.length - 1; !Ae[t] && !(Ae[t + 1] & 128) && t < Me; )
    t++;
  return t === 0 ? Ae : Ae.slice(t);
}
Signature.prototype._importDER = function Ae(t, Me) {
  t = utils_1$1.toArray(t, Me);
  var Ie = new Position();
  if (t[Ie.place++] !== 48)
    return !1;
  var Pe = getLength(t, Ie);
  if (Pe === !1 || Pe + Ie.place !== t.length || t[Ie.place++] !== 2)
    return !1;
  var Be = getLength(t, Ie);
  if (Be === !1)
    return !1;
  var Te = t.slice(Ie.place, Be + Ie.place);
  if (Ie.place += Be, t[Ie.place++] !== 2)
    return !1;
  var je = getLength(t, Ie);
  if (je === !1 || t.length !== je + Ie.place)
    return !1;
  var Ve = t.slice(Ie.place, je + Ie.place);
  if (Te[0] === 0)
    if (Te[1] & 128)
      Te = Te.slice(1);
    else
      return !1;
  if (Ve[0] === 0)
    if (Ve[1] & 128)
      Ve = Ve.slice(1);
    else
      return !1;
  return this.r = new BN$8(Te), this.s = new BN$8(Ve), this.recoveryParam = null, !0;
};
function constructLength(Ae, t) {
  if (t < 128) {
    Ae.push(t);
    return;
  }
  var Me = 1 + (Math.log(t) / Math.LN2 >>> 3);
  for (Ae.push(Me | 128); --Me; )
    Ae.push(t >>> (Me << 3) & 255);
  Ae.push(t);
}
Signature.prototype.toDER = function Ae(t) {
  var Me = this.r.toArray(), Ie = this.s.toArray();
  for (Me[0] & 128 && (Me = [0].concat(Me)), Ie[0] & 128 && (Ie = [0].concat(Ie)), Me = rmPadding(Me), Ie = rmPadding(Ie); !Ie[0] && !(Ie[1] & 128); )
    Ie = Ie.slice(1);
  var Pe = [2];
  constructLength(Pe, Me.length), Pe = Pe.concat(Me), Pe.push(2), constructLength(Pe, Ie.length);
  var Be = Pe.concat(Ie), Te = [48];
  return constructLength(Te, Be.length), Te = Te.concat(Be), utils_1$1.encode(Te, t);
};
var rand = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
), assert$5 = utils_1$1.assert;
function EC(Ae) {
  if (!(this instanceof EC))
    return new EC(Ae);
  typeof Ae == "string" && (assert$5(
    Object.prototype.hasOwnProperty.call(curves_1, Ae),
    "Unknown curve " + Ae
  ), Ae = curves_1[Ae]), Ae instanceof curves_1.PresetCurve && (Ae = { curve: Ae }), this.curve = Ae.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = Ae.curve.g, this.g.precompute(Ae.curve.n.bitLength() + 1), this.hash = Ae.hash || Ae.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function Ae(t) {
  return new key(this, t);
};
EC.prototype.keyFromPrivate = function Ae(t, Me) {
  return key.fromPrivate(this, t, Me);
};
EC.prototype.keyFromPublic = function Ae(t, Me) {
  return key.fromPublic(this, t, Me);
};
EC.prototype.genKeyPair = function Ae(t) {
  t || (t = {});
  for (var Me = new hmacDrbg({
    hash: this.hash,
    pers: t.pers,
    persEnc: t.persEnc || "utf8",
    entropy: t.entropy || rand(this.hash.hmacStrength),
    entropyEnc: t.entropy && t.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), Ie = this.n.byteLength(), Pe = this.n.sub(new BN$8(2)); ; ) {
    var Be = new BN$8(Me.generate(Ie));
    if (!(Be.cmp(Pe) > 0))
      return Be.iaddn(1), this.keyFromPrivate(Be);
  }
};
EC.prototype._truncateToN = function Ae(t, Me) {
  var Ie = t.byteLength() * 8 - this.n.bitLength();
  return Ie > 0 && (t = t.ushrn(Ie)), !Me && t.cmp(this.n) >= 0 ? t.sub(this.n) : t;
};
EC.prototype.sign = function Ae(t, Me, Ie, Pe) {
  typeof Ie == "object" && (Pe = Ie, Ie = null), Pe || (Pe = {}), Me = this.keyFromPrivate(Me, Ie), t = this._truncateToN(new BN$8(t, 16));
  for (var Be = this.n.byteLength(), Te = Me.getPrivate().toArray("be", Be), je = t.toArray("be", Be), Ve = new hmacDrbg({
    hash: this.hash,
    entropy: Te,
    nonce: je,
    pers: Pe.pers,
    persEnc: Pe.persEnc || "utf8"
  }), fi = this.n.sub(new BN$8(1)), Ue = 0; ; Ue++) {
    var bi = Pe.k ? Pe.k(Ue) : new BN$8(Ve.generate(this.n.byteLength()));
    if (bi = this._truncateToN(bi, !0), !(bi.cmpn(1) <= 0 || bi.cmp(fi) >= 0)) {
      var vi = this.g.mul(bi);
      if (!vi.isInfinity()) {
        var mi = vi.getX(), _i = mi.umod(this.n);
        if (_i.cmpn(0) !== 0) {
          var $i = bi.invm(this.n).mul(_i.mul(Me.getPrivate()).iadd(t));
          if ($i = $i.umod(this.n), $i.cmpn(0) !== 0) {
            var Ci = (vi.getY().isOdd() ? 1 : 0) | (mi.cmp(_i) !== 0 ? 2 : 0);
            return Pe.canonical && $i.cmp(this.nh) > 0 && ($i = this.n.sub($i), Ci ^= 1), new signature({ r: _i, s: $i, recoveryParam: Ci });
          }
        }
      }
    }
  }
};
EC.prototype.verify = function Ae(t, Me, Ie, Pe) {
  t = this._truncateToN(new BN$8(t, 16)), Ie = this.keyFromPublic(Ie, Pe), Me = new signature(Me, "hex");
  var Be = Me.r, Te = Me.s;
  if (Be.cmpn(1) < 0 || Be.cmp(this.n) >= 0 || Te.cmpn(1) < 0 || Te.cmp(this.n) >= 0)
    return !1;
  var je = Te.invm(this.n), Ve = je.mul(t).umod(this.n), fi = je.mul(Be).umod(this.n), Ue;
  return this.curve._maxwellTrick ? (Ue = this.g.jmulAdd(Ve, Ie.getPublic(), fi), Ue.isInfinity() ? !1 : Ue.eqXToP(Be)) : (Ue = this.g.mulAdd(Ve, Ie.getPublic(), fi), Ue.isInfinity() ? !1 : Ue.getX().umod(this.n).cmp(Be) === 0);
};
EC.prototype.recoverPubKey = function(Ae, t, Me, Ie) {
  assert$5((3 & Me) === Me, "The recovery param is more than two bits"), t = new signature(t, Ie);
  var Pe = this.n, Be = new BN$8(Ae), Te = t.r, je = t.s, Ve = Me & 1, fi = Me >> 1;
  if (Te.cmp(this.curve.p.umod(this.curve.n)) >= 0 && fi)
    throw new Error("Unable to find sencond key candinate");
  fi ? Te = this.curve.pointFromX(Te.add(this.curve.n), Ve) : Te = this.curve.pointFromX(Te, Ve);
  var Ue = t.r.invm(Pe), bi = Pe.sub(Be).mul(Ue).umod(Pe), vi = je.mul(Ue).umod(Pe);
  return this.g.mulAdd(bi, Te, vi);
};
EC.prototype.getKeyRecoveryParam = function(Ae, t, Me, Ie) {
  if (t = new signature(t, Ie), t.recoveryParam !== null)
    return t.recoveryParam;
  for (var Pe = 0; Pe < 4; Pe++) {
    var Be;
    try {
      Be = this.recoverPubKey(Ae, t, Pe);
    } catch {
      continue;
    }
    if (Be.eq(Me))
      return Pe;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(Ae, t) {
  var Me = t;
  Me.version = "6.5.4", Me.utils = utils_1$1, Me.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }, Me.curve = curve_1, Me.curves = curves_1, Me.ec = ec, Me.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
}), EC$1 = elliptic_1.ec;
const version = "signing-key/5.7.0", logger = new Logger(version);
let _curve = null;
function getCurve() {
  return _curve || (_curve = new EC$1("secp256k1")), _curve;
}
class SigningKey {
  constructor(t) {
    defineReadOnly(this, "curve", "secp256k1"), defineReadOnly(this, "privateKey", hexlify(t)), hexDataLength(this.privateKey) !== 32 && logger.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    const Me = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + Me.getPublic(!1, "hex")), defineReadOnly(this, "compressedPublicKey", "0x" + Me.getPublic(!0, "hex")), defineReadOnly(this, "_isSigningKey", !0);
  }
  _addPoint(t) {
    const Me = getCurve().keyFromPublic(arrayify(this.publicKey)), Ie = getCurve().keyFromPublic(arrayify(t));
    return "0x" + Me.pub.add(Ie.pub).encodeCompressed("hex");
  }
  signDigest(t) {
    const Me = getCurve().keyFromPrivate(arrayify(this.privateKey)), Ie = arrayify(t);
    Ie.length !== 32 && logger.throwArgumentError("bad digest length", "digest", t);
    const Pe = Me.sign(Ie, { canonical: !0 });
    return splitSignature({
      recoveryParam: Pe.recoveryParam,
      r: hexZeroPad("0x" + Pe.r.toString(16), 32),
      s: hexZeroPad("0x" + Pe.s.toString(16), 32)
    });
  }
  computeSharedSecret(t) {
    const Me = getCurve().keyFromPrivate(arrayify(this.privateKey)), Ie = getCurve().keyFromPublic(arrayify(computePublicKey(t)));
    return hexZeroPad("0x" + Me.derive(Ie.getPublic()).toString(16), 32);
  }
  static isSigningKey(t) {
    return !!(t && t._isSigningKey);
  }
}
function recoverPublicKey(Ae, t) {
  const Me = splitSignature(t), Ie = { r: arrayify(Me.r), s: arrayify(Me.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(Ae), Ie, Me.recoveryParam).encode("hex", !1);
}
function computePublicKey(Ae, t) {
  const Me = arrayify(Ae);
  return Me.length === 32 ? new SigningKey(Me).publicKey : Me.length === 33 ? "0x" + getCurve().keyFromPublic(Me).getPublic(!1, "hex") : Me.length === 65 ? hexlify(Me) : logger.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
var TransactionTypes;
(function(Ae) {
  Ae[Ae.legacy = 0] = "legacy", Ae[Ae.eip2930 = 1] = "eip2930", Ae[Ae.eip1559 = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function computeAddress(Ae) {
  const t = computePublicKey(Ae);
  return getAddress(hexDataSlice(keccak256(hexDataSlice(t, 1)), 12));
}
function recoverAddress(Ae, t) {
  return computeAddress(recoverPublicKey(arrayify(Ae), t));
}
var chacha20poly1305 = {}, chacha = {};
Object.defineProperty(chacha, "__esModule", { value: !0 });
var binary_1 = binary, wipe_1$2 = wipe$1, ROUNDS = 20;
function core(Ae, t, Me) {
  for (var Ie = 1634760805, Pe = 857760878, Be = 2036477234, Te = 1797285236, je = Me[3] << 24 | Me[2] << 16 | Me[1] << 8 | Me[0], Ve = Me[7] << 24 | Me[6] << 16 | Me[5] << 8 | Me[4], fi = Me[11] << 24 | Me[10] << 16 | Me[9] << 8 | Me[8], Ue = Me[15] << 24 | Me[14] << 16 | Me[13] << 8 | Me[12], bi = Me[19] << 24 | Me[18] << 16 | Me[17] << 8 | Me[16], vi = Me[23] << 24 | Me[22] << 16 | Me[21] << 8 | Me[20], mi = Me[27] << 24 | Me[26] << 16 | Me[25] << 8 | Me[24], _i = Me[31] << 24 | Me[30] << 16 | Me[29] << 8 | Me[28], $i = t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0], Ci = t[7] << 24 | t[6] << 16 | t[5] << 8 | t[4], Ui = t[11] << 24 | t[10] << 16 | t[9] << 8 | t[8], ki = t[15] << 24 | t[14] << 16 | t[13] << 8 | t[12], Ji = Ie, Hi = Pe, Zi = Be, Qi = Te, Bi = je, Xi = Ve, ns = fi, ls = Ue, vn = bi, Mi = vi, Ai = mi, wi = _i, Ei = $i, Ti = Ci, Pi = Ui, qi = ki, Oi = 0; Oi < ROUNDS; Oi += 2)
    Ji = Ji + Bi | 0, Ei ^= Ji, Ei = Ei >>> 16 | Ei << 16, vn = vn + Ei | 0, Bi ^= vn, Bi = Bi >>> 20 | Bi << 12, Hi = Hi + Xi | 0, Ti ^= Hi, Ti = Ti >>> 16 | Ti << 16, Mi = Mi + Ti | 0, Xi ^= Mi, Xi = Xi >>> 20 | Xi << 12, Zi = Zi + ns | 0, Pi ^= Zi, Pi = Pi >>> 16 | Pi << 16, Ai = Ai + Pi | 0, ns ^= Ai, ns = ns >>> 20 | ns << 12, Qi = Qi + ls | 0, qi ^= Qi, qi = qi >>> 16 | qi << 16, wi = wi + qi | 0, ls ^= wi, ls = ls >>> 20 | ls << 12, Zi = Zi + ns | 0, Pi ^= Zi, Pi = Pi >>> 24 | Pi << 8, Ai = Ai + Pi | 0, ns ^= Ai, ns = ns >>> 25 | ns << 7, Qi = Qi + ls | 0, qi ^= Qi, qi = qi >>> 24 | qi << 8, wi = wi + qi | 0, ls ^= wi, ls = ls >>> 25 | ls << 7, Hi = Hi + Xi | 0, Ti ^= Hi, Ti = Ti >>> 24 | Ti << 8, Mi = Mi + Ti | 0, Xi ^= Mi, Xi = Xi >>> 25 | Xi << 7, Ji = Ji + Bi | 0, Ei ^= Ji, Ei = Ei >>> 24 | Ei << 8, vn = vn + Ei | 0, Bi ^= vn, Bi = Bi >>> 25 | Bi << 7, Ji = Ji + Xi | 0, qi ^= Ji, qi = qi >>> 16 | qi << 16, Ai = Ai + qi | 0, Xi ^= Ai, Xi = Xi >>> 20 | Xi << 12, Hi = Hi + ns | 0, Ei ^= Hi, Ei = Ei >>> 16 | Ei << 16, wi = wi + Ei | 0, ns ^= wi, ns = ns >>> 20 | ns << 12, Zi = Zi + ls | 0, Ti ^= Zi, Ti = Ti >>> 16 | Ti << 16, vn = vn + Ti | 0, ls ^= vn, ls = ls >>> 20 | ls << 12, Qi = Qi + Bi | 0, Pi ^= Qi, Pi = Pi >>> 16 | Pi << 16, Mi = Mi + Pi | 0, Bi ^= Mi, Bi = Bi >>> 20 | Bi << 12, Zi = Zi + ls | 0, Ti ^= Zi, Ti = Ti >>> 24 | Ti << 8, vn = vn + Ti | 0, ls ^= vn, ls = ls >>> 25 | ls << 7, Qi = Qi + Bi | 0, Pi ^= Qi, Pi = Pi >>> 24 | Pi << 8, Mi = Mi + Pi | 0, Bi ^= Mi, Bi = Bi >>> 25 | Bi << 7, Hi = Hi + ns | 0, Ei ^= Hi, Ei = Ei >>> 24 | Ei << 8, wi = wi + Ei | 0, ns ^= wi, ns = ns >>> 25 | ns << 7, Ji = Ji + Xi | 0, qi ^= Ji, qi = qi >>> 24 | qi << 8, Ai = Ai + qi | 0, Xi ^= Ai, Xi = Xi >>> 25 | Xi << 7;
  binary_1.writeUint32LE(Ji + Ie | 0, Ae, 0), binary_1.writeUint32LE(Hi + Pe | 0, Ae, 4), binary_1.writeUint32LE(Zi + Be | 0, Ae, 8), binary_1.writeUint32LE(Qi + Te | 0, Ae, 12), binary_1.writeUint32LE(Bi + je | 0, Ae, 16), binary_1.writeUint32LE(Xi + Ve | 0, Ae, 20), binary_1.writeUint32LE(ns + fi | 0, Ae, 24), binary_1.writeUint32LE(ls + Ue | 0, Ae, 28), binary_1.writeUint32LE(vn + bi | 0, Ae, 32), binary_1.writeUint32LE(Mi + vi | 0, Ae, 36), binary_1.writeUint32LE(Ai + mi | 0, Ae, 40), binary_1.writeUint32LE(wi + _i | 0, Ae, 44), binary_1.writeUint32LE(Ei + $i | 0, Ae, 48), binary_1.writeUint32LE(Ti + Ci | 0, Ae, 52), binary_1.writeUint32LE(Pi + Ui | 0, Ae, 56), binary_1.writeUint32LE(qi + ki | 0, Ae, 60);
}
function streamXOR(Ae, t, Me, Ie, Pe) {
  if (Pe === void 0 && (Pe = 0), Ae.length !== 32)
    throw new Error("ChaCha: key size must be 32 bytes");
  if (Ie.length < Me.length)
    throw new Error("ChaCha: destination is shorter than source");
  var Be, Te;
  if (Pe === 0) {
    if (t.length !== 8 && t.length !== 12)
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    Be = new Uint8Array(16), Te = Be.length - t.length, Be.set(t, Te);
  } else {
    if (t.length !== 16)
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    Be = t, Te = Pe;
  }
  for (var je = new Uint8Array(64), Ve = 0; Ve < Me.length; Ve += 64) {
    core(je, Be, Ae);
    for (var fi = Ve; fi < Ve + 64 && fi < Me.length; fi++)
      Ie[fi] = Me[fi] ^ je[fi - Ve];
    incrementCounter(Be, 0, Te);
  }
  return wipe_1$2.wipe(je), Pe === 0 && wipe_1$2.wipe(Be), Ie;
}
chacha.streamXOR = streamXOR;
function stream(Ae, t, Me, Ie) {
  return Ie === void 0 && (Ie = 0), wipe_1$2.wipe(Me), streamXOR(Ae, t, Me, Me, Ie);
}
chacha.stream = stream;
function incrementCounter(Ae, t, Me) {
  for (var Ie = 1; Me--; )
    Ie = Ie + (Ae[t] & 255) | 0, Ae[t] = Ie & 255, Ie >>>= 8, t++;
  if (Ie > 0)
    throw new Error("ChaCha: counter overflow");
}
var poly1305 = {}, constantTime = {};
Object.defineProperty(constantTime, "__esModule", { value: !0 });
function select(Ae, t, Me) {
  return ~(Ae - 1) & t | Ae - 1 & Me;
}
constantTime.select = select;
function lessOrEqual(Ae, t) {
  return (Ae | 0) - (t | 0) - 1 >>> 31 & 1;
}
constantTime.lessOrEqual = lessOrEqual;
function compare(Ae, t) {
  if (Ae.length !== t.length)
    return 0;
  for (var Me = 0, Ie = 0; Ie < Ae.length; Ie++)
    Me |= Ae[Ie] ^ t[Ie];
  return 1 & Me - 1 >>> 8;
}
constantTime.compare = compare;
function equal(Ae, t) {
  return Ae.length === 0 || t.length === 0 ? !1 : compare(Ae, t) !== 0;
}
constantTime.equal = equal;
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  var t = constantTime, Me = wipe$1;
  Ae.DIGEST_LENGTH = 16;
  var Ie = (
    /** @class */
    function() {
      function Te(je) {
        this.digestLength = Ae.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
        var Ve = je[0] | je[1] << 8;
        this._r[0] = Ve & 8191;
        var fi = je[2] | je[3] << 8;
        this._r[1] = (Ve >>> 13 | fi << 3) & 8191;
        var Ue = je[4] | je[5] << 8;
        this._r[2] = (fi >>> 10 | Ue << 6) & 7939;
        var bi = je[6] | je[7] << 8;
        this._r[3] = (Ue >>> 7 | bi << 9) & 8191;
        var vi = je[8] | je[9] << 8;
        this._r[4] = (bi >>> 4 | vi << 12) & 255, this._r[5] = vi >>> 1 & 8190;
        var mi = je[10] | je[11] << 8;
        this._r[6] = (vi >>> 14 | mi << 2) & 8191;
        var _i = je[12] | je[13] << 8;
        this._r[7] = (mi >>> 11 | _i << 5) & 8065;
        var $i = je[14] | je[15] << 8;
        this._r[8] = (_i >>> 8 | $i << 8) & 8191, this._r[9] = $i >>> 5 & 127, this._pad[0] = je[16] | je[17] << 8, this._pad[1] = je[18] | je[19] << 8, this._pad[2] = je[20] | je[21] << 8, this._pad[3] = je[22] | je[23] << 8, this._pad[4] = je[24] | je[25] << 8, this._pad[5] = je[26] | je[27] << 8, this._pad[6] = je[28] | je[29] << 8, this._pad[7] = je[30] | je[31] << 8;
      }
      return Te.prototype._blocks = function(je, Ve, fi) {
        for (var Ue = this._fin ? 0 : 2048, bi = this._h[0], vi = this._h[1], mi = this._h[2], _i = this._h[3], $i = this._h[4], Ci = this._h[5], Ui = this._h[6], ki = this._h[7], Ji = this._h[8], Hi = this._h[9], Zi = this._r[0], Qi = this._r[1], Bi = this._r[2], Xi = this._r[3], ns = this._r[4], ls = this._r[5], vn = this._r[6], Mi = this._r[7], Ai = this._r[8], wi = this._r[9]; fi >= 16; ) {
          var Ei = je[Ve + 0] | je[Ve + 1] << 8;
          bi += Ei & 8191;
          var Ti = je[Ve + 2] | je[Ve + 3] << 8;
          vi += (Ei >>> 13 | Ti << 3) & 8191;
          var Pi = je[Ve + 4] | je[Ve + 5] << 8;
          mi += (Ti >>> 10 | Pi << 6) & 8191;
          var qi = je[Ve + 6] | je[Ve + 7] << 8;
          _i += (Pi >>> 7 | qi << 9) & 8191;
          var Oi = je[Ve + 8] | je[Ve + 9] << 8;
          $i += (qi >>> 4 | Oi << 12) & 8191, Ci += Oi >>> 1 & 8191;
          var Si = je[Ve + 10] | je[Ve + 11] << 8;
          Ui += (Oi >>> 14 | Si << 2) & 8191;
          var Ni = je[Ve + 12] | je[Ve + 13] << 8;
          ki += (Si >>> 11 | Ni << 5) & 8191;
          var xi = je[Ve + 14] | je[Ve + 15] << 8;
          Ji += (Ni >>> 8 | xi << 8) & 8191, Hi += xi >>> 5 | Ue;
          var Wi = 0, ts = Wi;
          ts += bi * Zi, ts += vi * (5 * wi), ts += mi * (5 * Ai), ts += _i * (5 * Mi), ts += $i * (5 * vn), Wi = ts >>> 13, ts &= 8191, ts += Ci * (5 * ls), ts += Ui * (5 * ns), ts += ki * (5 * Xi), ts += Ji * (5 * Bi), ts += Hi * (5 * Qi), Wi += ts >>> 13, ts &= 8191;
          var Ki = Wi;
          Ki += bi * Qi, Ki += vi * Zi, Ki += mi * (5 * wi), Ki += _i * (5 * Ai), Ki += $i * (5 * Mi), Wi = Ki >>> 13, Ki &= 8191, Ki += Ci * (5 * vn), Ki += Ui * (5 * ls), Ki += ki * (5 * ns), Ki += Ji * (5 * Xi), Ki += Hi * (5 * Bi), Wi += Ki >>> 13, Ki &= 8191;
          var fn = Wi;
          fn += bi * Bi, fn += vi * Qi, fn += mi * Zi, fn += _i * (5 * wi), fn += $i * (5 * Ai), Wi = fn >>> 13, fn &= 8191, fn += Ci * (5 * Mi), fn += Ui * (5 * vn), fn += ki * (5 * ls), fn += Ji * (5 * ns), fn += Hi * (5 * Xi), Wi += fn >>> 13, fn &= 8191;
          var Ii = Wi;
          Ii += bi * Xi, Ii += vi * Bi, Ii += mi * Qi, Ii += _i * Zi, Ii += $i * (5 * wi), Wi = Ii >>> 13, Ii &= 8191, Ii += Ci * (5 * Ai), Ii += Ui * (5 * Mi), Ii += ki * (5 * vn), Ii += Ji * (5 * ls), Ii += Hi * (5 * ns), Wi += Ii >>> 13, Ii &= 8191;
          var Fi = Wi;
          Fi += bi * ns, Fi += vi * Xi, Fi += mi * Bi, Fi += _i * Qi, Fi += $i * Zi, Wi = Fi >>> 13, Fi &= 8191, Fi += Ci * (5 * wi), Fi += Ui * (5 * Ai), Fi += ki * (5 * Mi), Fi += Ji * (5 * vn), Fi += Hi * (5 * ls), Wi += Fi >>> 13, Fi &= 8191;
          var Gi = Wi;
          Gi += bi * ls, Gi += vi * ns, Gi += mi * Xi, Gi += _i * Bi, Gi += $i * Qi, Wi = Gi >>> 13, Gi &= 8191, Gi += Ci * Zi, Gi += Ui * (5 * wi), Gi += ki * (5 * Ai), Gi += Ji * (5 * Mi), Gi += Hi * (5 * vn), Wi += Gi >>> 13, Gi &= 8191;
          var Ri = Wi;
          Ri += bi * vn, Ri += vi * ls, Ri += mi * ns, Ri += _i * Xi, Ri += $i * Bi, Wi = Ri >>> 13, Ri &= 8191, Ri += Ci * Qi, Ri += Ui * Zi, Ri += ki * (5 * wi), Ri += Ji * (5 * Ai), Ri += Hi * (5 * Mi), Wi += Ri >>> 13, Ri &= 8191;
          var ji = Wi;
          ji += bi * Mi, ji += vi * vn, ji += mi * ls, ji += _i * ns, ji += $i * Xi, Wi = ji >>> 13, ji &= 8191, ji += Ci * Bi, ji += Ui * Qi, ji += ki * Zi, ji += Ji * (5 * wi), ji += Hi * (5 * Ai), Wi += ji >>> 13, ji &= 8191;
          var Vi = Wi;
          Vi += bi * Ai, Vi += vi * Mi, Vi += mi * vn, Vi += _i * ls, Vi += $i * ns, Wi = Vi >>> 13, Vi &= 8191, Vi += Ci * Xi, Vi += Ui * Bi, Vi += ki * Qi, Vi += Ji * Zi, Vi += Hi * (5 * wi), Wi += Vi >>> 13, Vi &= 8191;
          var is = Wi;
          is += bi * wi, is += vi * Ai, is += mi * Mi, is += _i * vn, is += $i * ls, Wi = is >>> 13, is &= 8191, is += Ci * ns, is += Ui * Xi, is += ki * Bi, is += Ji * Qi, is += Hi * Zi, Wi += is >>> 13, is &= 8191, Wi = (Wi << 2) + Wi | 0, Wi = Wi + ts | 0, ts = Wi & 8191, Wi = Wi >>> 13, Ki += Wi, bi = ts, vi = Ki, mi = fn, _i = Ii, $i = Fi, Ci = Gi, Ui = Ri, ki = ji, Ji = Vi, Hi = is, Ve += 16, fi -= 16;
        }
        this._h[0] = bi, this._h[1] = vi, this._h[2] = mi, this._h[3] = _i, this._h[4] = $i, this._h[5] = Ci, this._h[6] = Ui, this._h[7] = ki, this._h[8] = Ji, this._h[9] = Hi;
      }, Te.prototype.finish = function(je, Ve) {
        Ve === void 0 && (Ve = 0);
        var fi = new Uint16Array(10), Ue, bi, vi, mi;
        if (this._leftover) {
          for (mi = this._leftover, this._buffer[mi++] = 1; mi < 16; mi++)
            this._buffer[mi] = 0;
          this._fin = 1, this._blocks(this._buffer, 0, 16);
        }
        for (Ue = this._h[1] >>> 13, this._h[1] &= 8191, mi = 2; mi < 10; mi++)
          this._h[mi] += Ue, Ue = this._h[mi] >>> 13, this._h[mi] &= 8191;
        for (this._h[0] += Ue * 5, Ue = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += Ue, Ue = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += Ue, fi[0] = this._h[0] + 5, Ue = fi[0] >>> 13, fi[0] &= 8191, mi = 1; mi < 10; mi++)
          fi[mi] = this._h[mi] + Ue, Ue = fi[mi] >>> 13, fi[mi] &= 8191;
        for (fi[9] -= 8192, bi = (Ue ^ 1) - 1, mi = 0; mi < 10; mi++)
          fi[mi] &= bi;
        for (bi = ~bi, mi = 0; mi < 10; mi++)
          this._h[mi] = this._h[mi] & bi | fi[mi];
        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, vi = this._h[0] + this._pad[0], this._h[0] = vi & 65535, mi = 1; mi < 8; mi++)
          vi = (this._h[mi] + this._pad[mi] | 0) + (vi >>> 16) | 0, this._h[mi] = vi & 65535;
        return je[Ve + 0] = this._h[0] >>> 0, je[Ve + 1] = this._h[0] >>> 8, je[Ve + 2] = this._h[1] >>> 0, je[Ve + 3] = this._h[1] >>> 8, je[Ve + 4] = this._h[2] >>> 0, je[Ve + 5] = this._h[2] >>> 8, je[Ve + 6] = this._h[3] >>> 0, je[Ve + 7] = this._h[3] >>> 8, je[Ve + 8] = this._h[4] >>> 0, je[Ve + 9] = this._h[4] >>> 8, je[Ve + 10] = this._h[5] >>> 0, je[Ve + 11] = this._h[5] >>> 8, je[Ve + 12] = this._h[6] >>> 0, je[Ve + 13] = this._h[6] >>> 8, je[Ve + 14] = this._h[7] >>> 0, je[Ve + 15] = this._h[7] >>> 8, this._finished = !0, this;
      }, Te.prototype.update = function(je) {
        var Ve = 0, fi = je.length, Ue;
        if (this._leftover) {
          Ue = 16 - this._leftover, Ue > fi && (Ue = fi);
          for (var bi = 0; bi < Ue; bi++)
            this._buffer[this._leftover + bi] = je[Ve + bi];
          if (fi -= Ue, Ve += Ue, this._leftover += Ue, this._leftover < 16)
            return this;
          this._blocks(this._buffer, 0, 16), this._leftover = 0;
        }
        if (fi >= 16 && (Ue = fi - fi % 16, this._blocks(je, Ve, Ue), Ve += Ue, fi -= Ue), fi) {
          for (var bi = 0; bi < fi; bi++)
            this._buffer[this._leftover + bi] = je[Ve + bi];
          this._leftover += fi;
        }
        return this;
      }, Te.prototype.digest = function() {
        if (this._finished)
          throw new Error("Poly1305 was finished");
        var je = new Uint8Array(16);
        return this.finish(je), je;
      }, Te.prototype.clean = function() {
        return Me.wipe(this._buffer), Me.wipe(this._r), Me.wipe(this._h), Me.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;
      }, Te;
    }()
  );
  Ae.Poly1305 = Ie;
  function Pe(Te, je) {
    var Ve = new Ie(Te);
    Ve.update(je);
    var fi = Ve.digest();
    return Ve.clean(), fi;
  }
  Ae.oneTimeAuth = Pe;
  function Be(Te, je) {
    return Te.length !== Ae.DIGEST_LENGTH || je.length !== Ae.DIGEST_LENGTH ? !1 : t.equal(Te, je);
  }
  Ae.equal = Be;
})(poly1305);
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  var t = chacha, Me = poly1305, Ie = wipe$1, Pe = binary, Be = constantTime;
  Ae.KEY_LENGTH = 32, Ae.NONCE_LENGTH = 12, Ae.TAG_LENGTH = 16;
  var Te = new Uint8Array(16), je = (
    /** @class */
    function() {
      function Ve(fi) {
        if (this.nonceLength = Ae.NONCE_LENGTH, this.tagLength = Ae.TAG_LENGTH, fi.length !== Ae.KEY_LENGTH)
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(fi);
      }
      return Ve.prototype.seal = function(fi, Ue, bi, vi) {
        if (fi.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        var mi = new Uint8Array(16);
        mi.set(fi, mi.length - fi.length);
        var _i = new Uint8Array(32);
        t.stream(this._key, mi, _i, 4);
        var $i = Ue.length + this.tagLength, Ci;
        if (vi) {
          if (vi.length !== $i)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          Ci = vi;
        } else
          Ci = new Uint8Array($i);
        return t.streamXOR(this._key, mi, Ue, Ci, 4), this._authenticate(Ci.subarray(Ci.length - this.tagLength, Ci.length), _i, Ci.subarray(0, Ci.length - this.tagLength), bi), Ie.wipe(mi), Ci;
      }, Ve.prototype.open = function(fi, Ue, bi, vi) {
        if (fi.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        if (Ue.length < this.tagLength)
          return null;
        var mi = new Uint8Array(16);
        mi.set(fi, mi.length - fi.length);
        var _i = new Uint8Array(32);
        t.stream(this._key, mi, _i, 4);
        var $i = new Uint8Array(this.tagLength);
        if (this._authenticate($i, _i, Ue.subarray(0, Ue.length - this.tagLength), bi), !Be.equal($i, Ue.subarray(Ue.length - this.tagLength, Ue.length)))
          return null;
        var Ci = Ue.length - this.tagLength, Ui;
        if (vi) {
          if (vi.length !== Ci)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          Ui = vi;
        } else
          Ui = new Uint8Array(Ci);
        return t.streamXOR(this._key, mi, Ue.subarray(0, Ue.length - this.tagLength), Ui, 4), Ie.wipe(mi), Ui;
      }, Ve.prototype.clean = function() {
        return Ie.wipe(this._key), this;
      }, Ve.prototype._authenticate = function(fi, Ue, bi, vi) {
        var mi = new Me.Poly1305(Ue);
        vi && (mi.update(vi), vi.length % 16 > 0 && mi.update(Te.subarray(vi.length % 16))), mi.update(bi), bi.length % 16 > 0 && mi.update(Te.subarray(bi.length % 16));
        var _i = new Uint8Array(8);
        vi && Pe.writeUint64LE(vi.length, _i), mi.update(_i), Pe.writeUint64LE(bi.length, _i), mi.update(_i);
        for (var $i = mi.digest(), Ci = 0; Ci < $i.length; Ci++)
          fi[Ci] = $i[Ci];
        mi.clean(), Ie.wipe($i), Ie.wipe(_i);
      }, Ve;
    }()
  );
  Ae.ChaCha20Poly1305 = je;
})(chacha20poly1305);
var hkdf = {}, hmac$1 = {}, hash = {};
Object.defineProperty(hash, "__esModule", { value: !0 });
function isSerializableHash(Ae) {
  return typeof Ae.saveState < "u" && typeof Ae.restoreState < "u" && typeof Ae.cleanSavedState < "u";
}
hash.isSerializableHash = isSerializableHash;
Object.defineProperty(hmac$1, "__esModule", { value: !0 });
var hash_1 = hash, constant_time_1 = constantTime, wipe_1$1 = wipe$1, HMAC = (
  /** @class */
  function() {
    function Ae(t, Me) {
      this._finished = !1, this._inner = new t(), this._outer = new t(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
      var Ie = new Uint8Array(this.blockSize);
      Me.length > this.blockSize ? this._inner.update(Me).finish(Ie).clean() : Ie.set(Me);
      for (var Pe = 0; Pe < Ie.length; Pe++)
        Ie[Pe] ^= 54;
      this._inner.update(Ie);
      for (var Pe = 0; Pe < Ie.length; Pe++)
        Ie[Pe] ^= 106;
      this._outer.update(Ie), hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), wipe_1$1.wipe(Ie);
    }
    return Ae.prototype.reset = function() {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer))
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, Ae.prototype.clean = function() {
      hash_1.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), hash_1.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();
    }, Ae.prototype.update = function(t) {
      return this._inner.update(t), this;
    }, Ae.prototype.finish = function(t) {
      return this._finished ? (this._outer.finish(t), this) : (this._inner.finish(t), this._outer.update(t.subarray(0, this.digestLength)).finish(t), this._finished = !0, this);
    }, Ae.prototype.digest = function() {
      var t = new Uint8Array(this.digestLength);
      return this.finish(t), t;
    }, Ae.prototype.saveState = function() {
      if (!hash_1.isSerializableHash(this._inner))
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      return this._inner.saveState();
    }, Ae.prototype.restoreState = function(t) {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer))
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      return this._inner.restoreState(t), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, Ae.prototype.cleanSavedState = function(t) {
      if (!hash_1.isSerializableHash(this._inner))
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      this._inner.cleanSavedState(t);
    }, Ae;
  }()
);
hmac$1.HMAC = HMAC;
function hmac(Ae, t, Me) {
  var Ie = new HMAC(Ae, t);
  Ie.update(Me);
  var Pe = Ie.digest();
  return Ie.clean(), Pe;
}
hmac$1.hmac = hmac;
hmac$1.equal = constant_time_1.equal;
Object.defineProperty(hkdf, "__esModule", { value: !0 });
var hmac_1 = hmac$1, wipe_1 = wipe$1, HKDF = (
  /** @class */
  function() {
    function Ae(t, Me, Ie, Pe) {
      Ie === void 0 && (Ie = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = t, this._info = Pe;
      var Be = hmac_1.hmac(this._hash, Ie, Me);
      this._hmac = new hmac_1.HMAC(t, Be), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;
    }
    return Ae.prototype._fillBuffer = function() {
      this._counter[0]++;
      var t = this._counter[0];
      if (t === 0)
        throw new Error("hkdf: cannot expand more");
      this._hmac.reset(), t > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;
    }, Ae.prototype.expand = function(t) {
      for (var Me = new Uint8Array(t), Ie = 0; Ie < Me.length; Ie++)
        this._bufpos === this._buffer.length && this._fillBuffer(), Me[Ie] = this._buffer[this._bufpos++];
      return Me;
    }, Ae.prototype.clean = function() {
      this._hmac.clean(), wipe_1.wipe(this._buffer), wipe_1.wipe(this._counter), this._bufpos = 0;
    }, Ae;
  }()
), HKDF_1 = hkdf.HKDF = HKDF, sha256 = {};
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  var t = binary, Me = wipe$1;
  Ae.DIGEST_LENGTH = 32, Ae.BLOCK_SIZE = 64;
  var Ie = (
    /** @class */
    function() {
      function je() {
        this.digestLength = Ae.DIGEST_LENGTH, this.blockSize = Ae.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return je.prototype._initState = function() {
        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
      }, je.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, je.prototype.clean = function() {
        Me.wipe(this._buffer), Me.wipe(this._temp), this.reset();
      }, je.prototype.update = function(Ve, fi) {
        if (fi === void 0 && (fi = Ve.length), this._finished)
          throw new Error("SHA256: can't update because hash was finished.");
        var Ue = 0;
        if (this._bytesHashed += fi, this._bufferLength > 0) {
          for (; this._bufferLength < this.blockSize && fi > 0; )
            this._buffer[this._bufferLength++] = Ve[Ue++], fi--;
          this._bufferLength === this.blockSize && (Be(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (fi >= this.blockSize && (Ue = Be(this._temp, this._state, Ve, Ue, fi), fi %= this.blockSize); fi > 0; )
          this._buffer[this._bufferLength++] = Ve[Ue++], fi--;
        return this;
      }, je.prototype.finish = function(Ve) {
        if (!this._finished) {
          var fi = this._bytesHashed, Ue = this._bufferLength, bi = fi / 536870912 | 0, vi = fi << 3, mi = fi % 64 < 56 ? 64 : 128;
          this._buffer[Ue] = 128;
          for (var _i = Ue + 1; _i < mi - 8; _i++)
            this._buffer[_i] = 0;
          t.writeUint32BE(bi, this._buffer, mi - 8), t.writeUint32BE(vi, this._buffer, mi - 4), Be(this._temp, this._state, this._buffer, 0, mi), this._finished = !0;
        }
        for (var _i = 0; _i < this.digestLength / 4; _i++)
          t.writeUint32BE(this._state[_i], Ve, _i * 4);
        return this;
      }, je.prototype.digest = function() {
        var Ve = new Uint8Array(this.digestLength);
        return this.finish(Ve), Ve;
      }, je.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, je.prototype.restoreState = function(Ve) {
        return this._state.set(Ve.state), this._bufferLength = Ve.bufferLength, Ve.buffer && this._buffer.set(Ve.buffer), this._bytesHashed = Ve.bytesHashed, this._finished = !1, this;
      }, je.prototype.cleanSavedState = function(Ve) {
        Me.wipe(Ve.state), Ve.buffer && Me.wipe(Ve.buffer), Ve.bufferLength = 0, Ve.bytesHashed = 0;
      }, je;
    }()
  );
  Ae.SHA256 = Ie;
  var Pe = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function Be(je, Ve, fi, Ue, bi) {
    for (; bi >= 64; ) {
      for (var vi = Ve[0], mi = Ve[1], _i = Ve[2], $i = Ve[3], Ci = Ve[4], Ui = Ve[5], ki = Ve[6], Ji = Ve[7], Hi = 0; Hi < 16; Hi++) {
        var Zi = Ue + Hi * 4;
        je[Hi] = t.readUint32BE(fi, Zi);
      }
      for (var Hi = 16; Hi < 64; Hi++) {
        var Qi = je[Hi - 2], Bi = (Qi >>> 17 | Qi << 15) ^ (Qi >>> 19 | Qi << 13) ^ Qi >>> 10;
        Qi = je[Hi - 15];
        var Xi = (Qi >>> 7 | Qi << 25) ^ (Qi >>> 18 | Qi << 14) ^ Qi >>> 3;
        je[Hi] = (Bi + je[Hi - 7] | 0) + (Xi + je[Hi - 16] | 0);
      }
      for (var Hi = 0; Hi < 64; Hi++) {
        var Bi = (((Ci >>> 6 | Ci << 26) ^ (Ci >>> 11 | Ci << 21) ^ (Ci >>> 25 | Ci << 7)) + (Ci & Ui ^ ~Ci & ki) | 0) + (Ji + (Pe[Hi] + je[Hi] | 0) | 0) | 0, Xi = ((vi >>> 2 | vi << 30) ^ (vi >>> 13 | vi << 19) ^ (vi >>> 22 | vi << 10)) + (vi & mi ^ vi & _i ^ mi & _i) | 0;
        Ji = ki, ki = Ui, Ui = Ci, Ci = $i + Bi | 0, $i = _i, _i = mi, mi = vi, vi = Bi + Xi | 0;
      }
      Ve[0] += vi, Ve[1] += mi, Ve[2] += _i, Ve[3] += $i, Ve[4] += Ci, Ve[5] += Ui, Ve[6] += ki, Ve[7] += Ji, Ue += 64, bi -= 64;
    }
    return Ue;
  }
  function Te(je) {
    var Ve = new Ie();
    Ve.update(je);
    var fi = Ve.digest();
    return Ve.clean(), fi;
  }
  Ae.hash = Te;
})(sha256);
var x25519 = {};
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 }), Ae.sharedKey = Ae.generateKeyPair = Ae.generateKeyPairFromSeed = Ae.scalarMultBase = Ae.scalarMult = Ae.SHARED_KEY_LENGTH = Ae.SECRET_KEY_LENGTH = Ae.PUBLIC_KEY_LENGTH = void 0;
  const t = random, Me = wipe$1;
  Ae.PUBLIC_KEY_LENGTH = 32, Ae.SECRET_KEY_LENGTH = 32, Ae.SHARED_KEY_LENGTH = 32;
  function Ie(Hi) {
    const Zi = new Float64Array(16);
    if (Hi)
      for (let Qi = 0; Qi < Hi.length; Qi++)
        Zi[Qi] = Hi[Qi];
    return Zi;
  }
  const Pe = new Uint8Array(32);
  Pe[0] = 9;
  const Be = Ie([56129, 1]);
  function Te(Hi) {
    let Zi = 1;
    for (let Qi = 0; Qi < 16; Qi++) {
      let Bi = Hi[Qi] + Zi + 65535;
      Zi = Math.floor(Bi / 65536), Hi[Qi] = Bi - Zi * 65536;
    }
    Hi[0] += Zi - 1 + 37 * (Zi - 1);
  }
  function je(Hi, Zi, Qi) {
    const Bi = ~(Qi - 1);
    for (let Xi = 0; Xi < 16; Xi++) {
      const ns = Bi & (Hi[Xi] ^ Zi[Xi]);
      Hi[Xi] ^= ns, Zi[Xi] ^= ns;
    }
  }
  function Ve(Hi, Zi) {
    const Qi = Ie(), Bi = Ie();
    for (let Xi = 0; Xi < 16; Xi++)
      Bi[Xi] = Zi[Xi];
    Te(Bi), Te(Bi), Te(Bi);
    for (let Xi = 0; Xi < 2; Xi++) {
      Qi[0] = Bi[0] - 65517;
      for (let ls = 1; ls < 15; ls++)
        Qi[ls] = Bi[ls] - 65535 - (Qi[ls - 1] >> 16 & 1), Qi[ls - 1] &= 65535;
      Qi[15] = Bi[15] - 32767 - (Qi[14] >> 16 & 1);
      const ns = Qi[15] >> 16 & 1;
      Qi[14] &= 65535, je(Bi, Qi, 1 - ns);
    }
    for (let Xi = 0; Xi < 16; Xi++)
      Hi[2 * Xi] = Bi[Xi] & 255, Hi[2 * Xi + 1] = Bi[Xi] >> 8;
  }
  function fi(Hi, Zi) {
    for (let Qi = 0; Qi < 16; Qi++)
      Hi[Qi] = Zi[2 * Qi] + (Zi[2 * Qi + 1] << 8);
    Hi[15] &= 32767;
  }
  function Ue(Hi, Zi, Qi) {
    for (let Bi = 0; Bi < 16; Bi++)
      Hi[Bi] = Zi[Bi] + Qi[Bi];
  }
  function bi(Hi, Zi, Qi) {
    for (let Bi = 0; Bi < 16; Bi++)
      Hi[Bi] = Zi[Bi] - Qi[Bi];
  }
  function vi(Hi, Zi, Qi) {
    let Bi, Xi, ns = 0, ls = 0, vn = 0, Mi = 0, Ai = 0, wi = 0, Ei = 0, Ti = 0, Pi = 0, qi = 0, Oi = 0, Si = 0, Ni = 0, xi = 0, Wi = 0, ts = 0, Ki = 0, fn = 0, Ii = 0, Fi = 0, Gi = 0, Ri = 0, ji = 0, Vi = 0, is = 0, os = 0, ds = 0, ps = 0, ea = 0, ia = 0, hs = 0, fa = Qi[0], gs = Qi[1], sa = Qi[2], aa = Qi[3], Ds = Qi[4], ra = Qi[5], ca = Qi[6], ta = Qi[7], oa = Qi[8], da = Qi[9], Yi = Qi[10], Li = Qi[11], zi = Qi[12], En = Qi[13], ss = Qi[14], as = Qi[15];
    Bi = Zi[0], ns += Bi * fa, ls += Bi * gs, vn += Bi * sa, Mi += Bi * aa, Ai += Bi * Ds, wi += Bi * ra, Ei += Bi * ca, Ti += Bi * ta, Pi += Bi * oa, qi += Bi * da, Oi += Bi * Yi, Si += Bi * Li, Ni += Bi * zi, xi += Bi * En, Wi += Bi * ss, ts += Bi * as, Bi = Zi[1], ls += Bi * fa, vn += Bi * gs, Mi += Bi * sa, Ai += Bi * aa, wi += Bi * Ds, Ei += Bi * ra, Ti += Bi * ca, Pi += Bi * ta, qi += Bi * oa, Oi += Bi * da, Si += Bi * Yi, Ni += Bi * Li, xi += Bi * zi, Wi += Bi * En, ts += Bi * ss, Ki += Bi * as, Bi = Zi[2], vn += Bi * fa, Mi += Bi * gs, Ai += Bi * sa, wi += Bi * aa, Ei += Bi * Ds, Ti += Bi * ra, Pi += Bi * ca, qi += Bi * ta, Oi += Bi * oa, Si += Bi * da, Ni += Bi * Yi, xi += Bi * Li, Wi += Bi * zi, ts += Bi * En, Ki += Bi * ss, fn += Bi * as, Bi = Zi[3], Mi += Bi * fa, Ai += Bi * gs, wi += Bi * sa, Ei += Bi * aa, Ti += Bi * Ds, Pi += Bi * ra, qi += Bi * ca, Oi += Bi * ta, Si += Bi * oa, Ni += Bi * da, xi += Bi * Yi, Wi += Bi * Li, ts += Bi * zi, Ki += Bi * En, fn += Bi * ss, Ii += Bi * as, Bi = Zi[4], Ai += Bi * fa, wi += Bi * gs, Ei += Bi * sa, Ti += Bi * aa, Pi += Bi * Ds, qi += Bi * ra, Oi += Bi * ca, Si += Bi * ta, Ni += Bi * oa, xi += Bi * da, Wi += Bi * Yi, ts += Bi * Li, Ki += Bi * zi, fn += Bi * En, Ii += Bi * ss, Fi += Bi * as, Bi = Zi[5], wi += Bi * fa, Ei += Bi * gs, Ti += Bi * sa, Pi += Bi * aa, qi += Bi * Ds, Oi += Bi * ra, Si += Bi * ca, Ni += Bi * ta, xi += Bi * oa, Wi += Bi * da, ts += Bi * Yi, Ki += Bi * Li, fn += Bi * zi, Ii += Bi * En, Fi += Bi * ss, Gi += Bi * as, Bi = Zi[6], Ei += Bi * fa, Ti += Bi * gs, Pi += Bi * sa, qi += Bi * aa, Oi += Bi * Ds, Si += Bi * ra, Ni += Bi * ca, xi += Bi * ta, Wi += Bi * oa, ts += Bi * da, Ki += Bi * Yi, fn += Bi * Li, Ii += Bi * zi, Fi += Bi * En, Gi += Bi * ss, Ri += Bi * as, Bi = Zi[7], Ti += Bi * fa, Pi += Bi * gs, qi += Bi * sa, Oi += Bi * aa, Si += Bi * Ds, Ni += Bi * ra, xi += Bi * ca, Wi += Bi * ta, ts += Bi * oa, Ki += Bi * da, fn += Bi * Yi, Ii += Bi * Li, Fi += Bi * zi, Gi += Bi * En, Ri += Bi * ss, ji += Bi * as, Bi = Zi[8], Pi += Bi * fa, qi += Bi * gs, Oi += Bi * sa, Si += Bi * aa, Ni += Bi * Ds, xi += Bi * ra, Wi += Bi * ca, ts += Bi * ta, Ki += Bi * oa, fn += Bi * da, Ii += Bi * Yi, Fi += Bi * Li, Gi += Bi * zi, Ri += Bi * En, ji += Bi * ss, Vi += Bi * as, Bi = Zi[9], qi += Bi * fa, Oi += Bi * gs, Si += Bi * sa, Ni += Bi * aa, xi += Bi * Ds, Wi += Bi * ra, ts += Bi * ca, Ki += Bi * ta, fn += Bi * oa, Ii += Bi * da, Fi += Bi * Yi, Gi += Bi * Li, Ri += Bi * zi, ji += Bi * En, Vi += Bi * ss, is += Bi * as, Bi = Zi[10], Oi += Bi * fa, Si += Bi * gs, Ni += Bi * sa, xi += Bi * aa, Wi += Bi * Ds, ts += Bi * ra, Ki += Bi * ca, fn += Bi * ta, Ii += Bi * oa, Fi += Bi * da, Gi += Bi * Yi, Ri += Bi * Li, ji += Bi * zi, Vi += Bi * En, is += Bi * ss, os += Bi * as, Bi = Zi[11], Si += Bi * fa, Ni += Bi * gs, xi += Bi * sa, Wi += Bi * aa, ts += Bi * Ds, Ki += Bi * ra, fn += Bi * ca, Ii += Bi * ta, Fi += Bi * oa, Gi += Bi * da, Ri += Bi * Yi, ji += Bi * Li, Vi += Bi * zi, is += Bi * En, os += Bi * ss, ds += Bi * as, Bi = Zi[12], Ni += Bi * fa, xi += Bi * gs, Wi += Bi * sa, ts += Bi * aa, Ki += Bi * Ds, fn += Bi * ra, Ii += Bi * ca, Fi += Bi * ta, Gi += Bi * oa, Ri += Bi * da, ji += Bi * Yi, Vi += Bi * Li, is += Bi * zi, os += Bi * En, ds += Bi * ss, ps += Bi * as, Bi = Zi[13], xi += Bi * fa, Wi += Bi * gs, ts += Bi * sa, Ki += Bi * aa, fn += Bi * Ds, Ii += Bi * ra, Fi += Bi * ca, Gi += Bi * ta, Ri += Bi * oa, ji += Bi * da, Vi += Bi * Yi, is += Bi * Li, os += Bi * zi, ds += Bi * En, ps += Bi * ss, ea += Bi * as, Bi = Zi[14], Wi += Bi * fa, ts += Bi * gs, Ki += Bi * sa, fn += Bi * aa, Ii += Bi * Ds, Fi += Bi * ra, Gi += Bi * ca, Ri += Bi * ta, ji += Bi * oa, Vi += Bi * da, is += Bi * Yi, os += Bi * Li, ds += Bi * zi, ps += Bi * En, ea += Bi * ss, ia += Bi * as, Bi = Zi[15], ts += Bi * fa, Ki += Bi * gs, fn += Bi * sa, Ii += Bi * aa, Fi += Bi * Ds, Gi += Bi * ra, Ri += Bi * ca, ji += Bi * ta, Vi += Bi * oa, is += Bi * da, os += Bi * Yi, ds += Bi * Li, ps += Bi * zi, ea += Bi * En, ia += Bi * ss, hs += Bi * as, ns += 38 * Ki, ls += 38 * fn, vn += 38 * Ii, Mi += 38 * Fi, Ai += 38 * Gi, wi += 38 * Ri, Ei += 38 * ji, Ti += 38 * Vi, Pi += 38 * is, qi += 38 * os, Oi += 38 * ds, Si += 38 * ps, Ni += 38 * ea, xi += 38 * ia, Wi += 38 * hs, Xi = 1, Bi = ns + Xi + 65535, Xi = Math.floor(Bi / 65536), ns = Bi - Xi * 65536, Bi = ls + Xi + 65535, Xi = Math.floor(Bi / 65536), ls = Bi - Xi * 65536, Bi = vn + Xi + 65535, Xi = Math.floor(Bi / 65536), vn = Bi - Xi * 65536, Bi = Mi + Xi + 65535, Xi = Math.floor(Bi / 65536), Mi = Bi - Xi * 65536, Bi = Ai + Xi + 65535, Xi = Math.floor(Bi / 65536), Ai = Bi - Xi * 65536, Bi = wi + Xi + 65535, Xi = Math.floor(Bi / 65536), wi = Bi - Xi * 65536, Bi = Ei + Xi + 65535, Xi = Math.floor(Bi / 65536), Ei = Bi - Xi * 65536, Bi = Ti + Xi + 65535, Xi = Math.floor(Bi / 65536), Ti = Bi - Xi * 65536, Bi = Pi + Xi + 65535, Xi = Math.floor(Bi / 65536), Pi = Bi - Xi * 65536, Bi = qi + Xi + 65535, Xi = Math.floor(Bi / 65536), qi = Bi - Xi * 65536, Bi = Oi + Xi + 65535, Xi = Math.floor(Bi / 65536), Oi = Bi - Xi * 65536, Bi = Si + Xi + 65535, Xi = Math.floor(Bi / 65536), Si = Bi - Xi * 65536, Bi = Ni + Xi + 65535, Xi = Math.floor(Bi / 65536), Ni = Bi - Xi * 65536, Bi = xi + Xi + 65535, Xi = Math.floor(Bi / 65536), xi = Bi - Xi * 65536, Bi = Wi + Xi + 65535, Xi = Math.floor(Bi / 65536), Wi = Bi - Xi * 65536, Bi = ts + Xi + 65535, Xi = Math.floor(Bi / 65536), ts = Bi - Xi * 65536, ns += Xi - 1 + 37 * (Xi - 1), Xi = 1, Bi = ns + Xi + 65535, Xi = Math.floor(Bi / 65536), ns = Bi - Xi * 65536, Bi = ls + Xi + 65535, Xi = Math.floor(Bi / 65536), ls = Bi - Xi * 65536, Bi = vn + Xi + 65535, Xi = Math.floor(Bi / 65536), vn = Bi - Xi * 65536, Bi = Mi + Xi + 65535, Xi = Math.floor(Bi / 65536), Mi = Bi - Xi * 65536, Bi = Ai + Xi + 65535, Xi = Math.floor(Bi / 65536), Ai = Bi - Xi * 65536, Bi = wi + Xi + 65535, Xi = Math.floor(Bi / 65536), wi = Bi - Xi * 65536, Bi = Ei + Xi + 65535, Xi = Math.floor(Bi / 65536), Ei = Bi - Xi * 65536, Bi = Ti + Xi + 65535, Xi = Math.floor(Bi / 65536), Ti = Bi - Xi * 65536, Bi = Pi + Xi + 65535, Xi = Math.floor(Bi / 65536), Pi = Bi - Xi * 65536, Bi = qi + Xi + 65535, Xi = Math.floor(Bi / 65536), qi = Bi - Xi * 65536, Bi = Oi + Xi + 65535, Xi = Math.floor(Bi / 65536), Oi = Bi - Xi * 65536, Bi = Si + Xi + 65535, Xi = Math.floor(Bi / 65536), Si = Bi - Xi * 65536, Bi = Ni + Xi + 65535, Xi = Math.floor(Bi / 65536), Ni = Bi - Xi * 65536, Bi = xi + Xi + 65535, Xi = Math.floor(Bi / 65536), xi = Bi - Xi * 65536, Bi = Wi + Xi + 65535, Xi = Math.floor(Bi / 65536), Wi = Bi - Xi * 65536, Bi = ts + Xi + 65535, Xi = Math.floor(Bi / 65536), ts = Bi - Xi * 65536, ns += Xi - 1 + 37 * (Xi - 1), Hi[0] = ns, Hi[1] = ls, Hi[2] = vn, Hi[3] = Mi, Hi[4] = Ai, Hi[5] = wi, Hi[6] = Ei, Hi[7] = Ti, Hi[8] = Pi, Hi[9] = qi, Hi[10] = Oi, Hi[11] = Si, Hi[12] = Ni, Hi[13] = xi, Hi[14] = Wi, Hi[15] = ts;
  }
  function mi(Hi, Zi) {
    vi(Hi, Zi, Zi);
  }
  function _i(Hi, Zi) {
    const Qi = Ie();
    for (let Bi = 0; Bi < 16; Bi++)
      Qi[Bi] = Zi[Bi];
    for (let Bi = 253; Bi >= 0; Bi--)
      mi(Qi, Qi), Bi !== 2 && Bi !== 4 && vi(Qi, Qi, Zi);
    for (let Bi = 0; Bi < 16; Bi++)
      Hi[Bi] = Qi[Bi];
  }
  function $i(Hi, Zi) {
    const Qi = new Uint8Array(32), Bi = new Float64Array(80), Xi = Ie(), ns = Ie(), ls = Ie(), vn = Ie(), Mi = Ie(), Ai = Ie();
    for (let Pi = 0; Pi < 31; Pi++)
      Qi[Pi] = Hi[Pi];
    Qi[31] = Hi[31] & 127 | 64, Qi[0] &= 248, fi(Bi, Zi);
    for (let Pi = 0; Pi < 16; Pi++)
      ns[Pi] = Bi[Pi];
    Xi[0] = vn[0] = 1;
    for (let Pi = 254; Pi >= 0; --Pi) {
      const qi = Qi[Pi >>> 3] >>> (Pi & 7) & 1;
      je(Xi, ns, qi), je(ls, vn, qi), Ue(Mi, Xi, ls), bi(Xi, Xi, ls), Ue(ls, ns, vn), bi(ns, ns, vn), mi(vn, Mi), mi(Ai, Xi), vi(Xi, ls, Xi), vi(ls, ns, Mi), Ue(Mi, Xi, ls), bi(Xi, Xi, ls), mi(ns, Xi), bi(ls, vn, Ai), vi(Xi, ls, Be), Ue(Xi, Xi, vn), vi(ls, ls, Xi), vi(Xi, vn, Ai), vi(vn, ns, Bi), mi(ns, Mi), je(Xi, ns, qi), je(ls, vn, qi);
    }
    for (let Pi = 0; Pi < 16; Pi++)
      Bi[Pi + 16] = Xi[Pi], Bi[Pi + 32] = ls[Pi], Bi[Pi + 48] = ns[Pi], Bi[Pi + 64] = vn[Pi];
    const wi = Bi.subarray(32), Ei = Bi.subarray(16);
    _i(wi, wi), vi(Ei, Ei, wi);
    const Ti = new Uint8Array(32);
    return Ve(Ti, Ei), Ti;
  }
  Ae.scalarMult = $i;
  function Ci(Hi) {
    return $i(Hi, Pe);
  }
  Ae.scalarMultBase = Ci;
  function Ui(Hi) {
    if (Hi.length !== Ae.SECRET_KEY_LENGTH)
      throw new Error(`x25519: seed must be ${Ae.SECRET_KEY_LENGTH} bytes`);
    const Zi = new Uint8Array(Hi);
    return {
      publicKey: Ci(Zi),
      secretKey: Zi
    };
  }
  Ae.generateKeyPairFromSeed = Ui;
  function ki(Hi) {
    const Zi = (0, t.randomBytes)(32, Hi), Qi = Ui(Zi);
    return (0, Me.wipe)(Zi), Qi;
  }
  Ae.generateKeyPair = ki;
  function Ji(Hi, Zi, Qi = !1) {
    if (Hi.length !== Ae.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect secret key length");
    if (Zi.length !== Ae.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect public key length");
    const Bi = $i(Hi, Zi);
    if (Qi) {
      let Xi = 0;
      for (let ns = 0; ns < Bi.length; ns++)
        Xi |= Bi[ns];
      if (Xi === 0)
        throw new Error("X25519: invalid shared key");
    }
    return Bi;
  }
  Ae.sharedKey = Ji;
})(x25519);
const C$2 = { waku: { publish: "waku_publish", batchPublish: "waku_batchPublish", subscribe: "waku_subscribe", batchSubscribe: "waku_batchSubscribe", subscription: "waku_subscription", unsubscribe: "waku_unsubscribe", batchUnsubscribe: "waku_batchUnsubscribe", batchFetchMessages: "waku_batchFetchMessages" }, irn: { publish: "irn_publish", batchPublish: "irn_batchPublish", subscribe: "irn_subscribe", batchSubscribe: "irn_batchSubscribe", subscription: "irn_subscription", unsubscribe: "irn_unsubscribe", batchUnsubscribe: "irn_batchUnsubscribe", batchFetchMessages: "irn_batchFetchMessages" }, iridium: { publish: "iridium_publish", batchPublish: "iridium_batchPublish", subscribe: "iridium_subscribe", batchSubscribe: "iridium_batchSubscribe", subscription: "iridium_subscription", unsubscribe: "iridium_unsubscribe", batchUnsubscribe: "iridium_batchUnsubscribe", batchFetchMessages: "iridium_batchFetchMessages" } }, H$1 = ":";
function re$2(Ae) {
  const [t, Me] = Ae.split(H$1);
  return { namespace: t, reference: Me };
}
function W$2(Ae, t) {
  return Ae.includes(":") ? [Ae] : t.chains || [];
}
var gt$3 = Object.defineProperty, Ke = Object.getOwnPropertySymbols, vt$2 = Object.prototype.hasOwnProperty, bt$2 = Object.prototype.propertyIsEnumerable, Le$1 = (Ae, t, Me) => t in Ae ? gt$3(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Me }) : Ae[t] = Me, Fe = (Ae, t) => {
  for (var Me in t || (t = {})) vt$2.call(t, Me) && Le$1(Ae, Me, t[Me]);
  if (Ke) for (var Me of Ke(t)) bt$2.call(t, Me) && Le$1(Ae, Me, t[Me]);
  return Ae;
};
const qe = "ReactNative", y$1 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, He = "js";
function ce$1() {
  return typeof process$1 < "u" && typeof process$1.versions < "u" && typeof process$1.versions.node < "u";
}
function _$1() {
  return !getDocument_1() && !!getNavigator_1() && navigator.product === qe;
}
function V$3() {
  return !ce$1() && !!getNavigator_1() && !!getDocument_1();
}
function P$2() {
  return _$1() ? y$1.reactNative : ce$1() ? y$1.node : V$3() ? y$1.browser : y$1.unknown;
}
function Ot$2() {
  var Ae;
  try {
    return _$1() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (Ae = global.Application) == null ? void 0 : Ae.applicationId : void 0;
  } catch {
    return;
  }
}
function We$2(Ae, t) {
  let Me = queryString.parse(Ae);
  return Me = Fe(Fe({}, Me), t), Ae = queryString.stringify(Me), Ae;
}
function Nt$2() {
  return getWindowMetadata_1() || { name: "", description: "", url: "", icons: [""] };
}
function Je$1() {
  if (P$2() === y$1.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: Me, Version: Ie } = global.Platform;
    return [Me, Ie].join("-");
  }
  const Ae = detect();
  if (Ae === null) return "unknown";
  const t = Ae.os ? Ae.os.replace(" ", "").toLowerCase() : "unknown";
  return Ae.type === "browser" ? [t, Ae.name, Ae.version].join("-") : [t, Ae.version].join("-");
}
function ze() {
  var Ae;
  const t = P$2();
  return t === y$1.browser ? [t, ((Ae = getLocation_1()) == null ? void 0 : Ae.host) || "unknown"].join(":") : t;
}
function Ge(Ae, t, Me) {
  const Ie = Je$1(), Pe = ze();
  return [[Ae, t].join("-"), [He, Me].join("-"), Ie, Pe].join("/");
}
function $t$2({ protocol: Ae, version: t, relayUrl: Me, sdkVersion: Ie, auth: Pe, projectId: Be, useOnCloseEvent: Te, bundleId: je }) {
  const Ve = Me.split("?"), fi = Ge(Ae, t, Ie), Ue = { auth: Pe, ua: fi, projectId: Be, useOnCloseEvent: Te || void 0, origin: je || void 0 }, bi = We$2(Ve[1] || "", Ue);
  return Ve[0] + "?" + bi;
}
function $$2(Ae, t) {
  return Ae.filter((Me) => t.includes(Me)).length === Ae.length;
}
function Tt$2(Ae) {
  return Object.fromEntries(Ae.entries());
}
function Pt$2(Ae) {
  return new Map(Object.entries(Ae));
}
function _t$2(Ae = cjs$3.FIVE_MINUTES, t) {
  const Me = cjs$3.toMiliseconds(Ae || cjs$3.FIVE_MINUTES);
  let Ie, Pe, Be;
  return { resolve: (Te) => {
    Be && Ie && (clearTimeout(Be), Ie(Te));
  }, reject: (Te) => {
    Be && Pe && (clearTimeout(Be), Pe(Te));
  }, done: () => new Promise((Te, je) => {
    Be = setTimeout(() => {
      je(new Error(t));
    }, Me), Ie = Te, Pe = je;
  }) };
}
function kt$2(Ae, t, Me) {
  return new Promise(async (Ie, Pe) => {
    const Be = setTimeout(() => Pe(new Error(Me)), t);
    try {
      const Te = await Ae;
      Ie(Te);
    } catch (Te) {
      Pe(Te);
    }
    clearTimeout(Be);
  });
}
function ae$2(Ae, t) {
  if (typeof t == "string" && t.startsWith(`${Ae}:`)) return t;
  if (Ae.toLowerCase() === "topic") {
    if (typeof t != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${t}`;
  } else if (Ae.toLowerCase() === "id") {
    if (typeof t != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${t}`;
  }
  throw new Error(`Unknown expirer target type: ${Ae}`);
}
function Dt$2(Ae) {
  return ae$2("topic", Ae);
}
function xt$2(Ae) {
  return ae$2("id", Ae);
}
function Vt$2(Ae) {
  const [t, Me] = Ae.split(":"), Ie = { id: void 0, topic: void 0 };
  if (t === "topic" && typeof Me == "string") Ie.topic = Me;
  else if (t === "id" && Number.isInteger(Number(Me))) Ie.id = Number(Me);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${Me}`);
  return Ie;
}
function Mt$2(Ae, t) {
  return cjs$3.fromMiliseconds(Date.now() + cjs$3.toMiliseconds(Ae));
}
function Kt$2(Ae) {
  return Date.now() >= cjs$3.toMiliseconds(Ae);
}
function Lt$2(Ae, t) {
  return `${Ae}${t ? `:${t}` : ""}`;
}
function N(Ae = [], t = []) {
  return [.../* @__PURE__ */ new Set([...Ae, ...t])];
}
async function Ft$2({ id: Ae, topic: t, wcDeepLink: Me }) {
  var Ie;
  try {
    if (!Me) return;
    const Pe = typeof Me == "string" ? JSON.parse(Me) : Me, Be = Pe == null ? void 0 : Pe.href;
    if (typeof Be != "string") return;
    const Te = Xe$1(Be, Ae, t), je = P$2();
    if (je === y$1.browser) {
      if (!((Ie = getDocument_1()) != null && Ie.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      Te.startsWith("https://") || Te.startsWith("http://") ? window.open(Te, "_blank", "noreferrer noopener") : window.open(Te, en$1() ? "_blank" : "_self", "noreferrer noopener");
    } else je === y$1.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(Te);
  } catch (Pe) {
    console.error(Pe);
  }
}
function Xe$1(Ae, t, Me) {
  const Ie = `requestId=${t}&sessionTopic=${Me}`;
  Ae.endsWith("/") && (Ae = Ae.slice(0, -1));
  let Pe = `${Ae}`;
  if (Ae.startsWith("https://t.me")) {
    const Be = Ae.includes("?") ? "&startapp=" : "?startapp=";
    Pe = `${Pe}${Be}${nn$1(Ie, !0)}`;
  } else Pe = `${Pe}/wc?${Ie}`;
  return Pe;
}
async function qt$2(Ae, t) {
  let Me = "";
  try {
    if (V$3() && (Me = localStorage.getItem(t), Me)) return Me;
    Me = await Ae.getItem(t);
  } catch (Ie) {
    console.error(Ie);
  }
  return Me;
}
function Bt$2(Ae, t) {
  if (!Ae.includes(t)) return null;
  const Me = Ae.split(/([&,?,=])/), Ie = Me.indexOf(t);
  return Me[Ie + 2];
}
function Ht$2() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (Ae) => {
    const t = Math.random() * 16 | 0;
    return (Ae === "x" ? t : t & 3 | 8).toString(16);
  });
}
function Wt$2() {
  return typeof process$1 < "u" && process$1.env.IS_VITEST === "true";
}
function en$1() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function nn$1(Ae, t = !1) {
  const Me = Buffer$1.from(Ae).toString("base64");
  return t ? Me.replace(/[=]/g, "") : Me;
}
function le$1(Ae) {
  return Buffer$1.from(Ae, "base64").toString("utf-8");
}
const Jt$2 = "https://rpc.walletconnect.org/v1";
async function tn$1(Ae, t, Me, Ie, Pe, Be) {
  switch (Me.t) {
    case "eip191":
      return rn$1(Ae, t, Me.s);
    case "eip1271":
      return await on$1(Ae, t, Me.s, Ie, Pe, Be);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${Me.t}`);
  }
}
function rn$1(Ae, t, Me) {
  return recoverAddress(hashMessage(t), Me).toLowerCase() === Ae.toLowerCase();
}
async function on$1(Ae, t, Me, Ie, Pe, Be) {
  const Te = re$2(Ie);
  if (!Te.namespace || !Te.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${Ie}`);
  try {
    const je = "0x1626ba7e", Ve = "0000000000000000000000000000000000000000000000000000000000000040", fi = "0000000000000000000000000000000000000000000000000000000000000041", Ue = Me.substring(2), bi = hashMessage(t).substring(2), vi = je + bi + Ve + fi + Ue, mi = await fetch(`${Be || Jt$2}/?chainId=${Ie}&projectId=${Pe}`, { method: "POST", body: JSON.stringify({ id: zt$2(), jsonrpc: "2.0", method: "eth_call", params: [{ to: Ae, data: vi }, "latest"] }) }), { result: _i } = await mi.json();
    return _i ? _i.slice(0, je.length).toLowerCase() === je.toLowerCase() : !1;
  } catch (je) {
    return console.error("isValidEip1271Signature: ", je), !1;
  }
}
function zt$2() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
var Gt$2 = Object.defineProperty, Yt$2 = Object.defineProperties, Qt$2 = Object.getOwnPropertyDescriptors, sn$1 = Object.getOwnPropertySymbols, Zt$2 = Object.prototype.hasOwnProperty, Xt$2 = Object.prototype.propertyIsEnumerable, cn$1 = (Ae, t, Me) => t in Ae ? Gt$2(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Me }) : Ae[t] = Me, de$1 = (Ae, t) => {
  for (var Me in t || (t = {})) Zt$2.call(t, Me) && cn$1(Ae, Me, t[Me]);
  if (sn$1) for (var Me of sn$1(t)) Xt$2.call(t, Me) && cn$1(Ae, Me, t[Me]);
  return Ae;
}, an$1 = (Ae, t) => Yt$2(Ae, Qt$2(t));
const er$2 = "did:pkh:", z$4 = (Ae) => Ae == null ? void 0 : Ae.split(":"), un$1 = (Ae) => {
  const t = Ae && z$4(Ae);
  if (t) return Ae.includes(er$2) ? t[3] : t[1];
}, ln$1 = (Ae) => {
  const t = Ae && z$4(Ae);
  if (t) return t[2] + ":" + t[3];
}, fe$2 = (Ae) => {
  const t = Ae && z$4(Ae);
  if (t) return t.pop();
};
async function nr$2(Ae) {
  const { cacao: t, projectId: Me } = Ae, { s: Ie, p: Pe } = t, Be = dn$1(Pe, Pe.iss), Te = fe$2(Pe.iss);
  return await tn$1(Te, Be, Ie, ln$1(Pe.iss), Me);
}
const dn$1 = (Ae, t) => {
  const Me = `${Ae.domain} wants you to sign in with your Ethereum account:`, Ie = fe$2(t);
  if (!Ae.aud && !Ae.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let Pe = Ae.statement || void 0;
  const Be = `URI: ${Ae.aud || Ae.uri}`, Te = `Version: ${Ae.version}`, je = `Chain ID: ${un$1(t)}`, Ve = `Nonce: ${Ae.nonce}`, fi = `Issued At: ${Ae.iat}`, Ue = Ae.exp ? `Expiration Time: ${Ae.exp}` : void 0, bi = Ae.nbf ? `Not Before: ${Ae.nbf}` : void 0, vi = Ae.requestId ? `Request ID: ${Ae.requestId}` : void 0, mi = Ae.resources ? `Resources:${Ae.resources.map(($i) => `
- ${$i}`).join("")}` : void 0, _i = Y$2(Ae.resources);
  if (_i) {
    const $i = R$2(_i);
    Pe = he$1(Pe, $i);
  }
  return [Me, Ie, "", Pe, "", Be, Te, je, Ve, fi, Ue, bi, vi, mi].filter(($i) => $i != null).join(`
`);
};
function hn$1(Ae) {
  return Buffer$1.from(JSON.stringify(Ae)).toString("base64");
}
function yn$1(Ae) {
  return JSON.parse(Buffer$1.from(Ae, "base64").toString("utf-8"));
}
function O$3(Ae) {
  if (!Ae) throw new Error("No recap provided, value is undefined");
  if (!Ae.att) throw new Error("No `att` property found");
  const t = Object.keys(Ae.att);
  if (!(t != null && t.length)) throw new Error("No resources found in `att` property");
  t.forEach((Me) => {
    const Ie = Ae.att[Me];
    if (Array.isArray(Ie)) throw new Error(`Resource must be an object: ${Me}`);
    if (typeof Ie != "object") throw new Error(`Resource must be an object: ${Me}`);
    if (!Object.keys(Ie).length) throw new Error(`Resource object is empty: ${Me}`);
    Object.keys(Ie).forEach((Pe) => {
      const Be = Ie[Pe];
      if (!Array.isArray(Be)) throw new Error(`Ability limits ${Pe} must be an array of objects, found: ${Be}`);
      if (!Be.length) throw new Error(`Value of ${Pe} is empty array, must be an array with objects`);
      Be.forEach((Te) => {
        if (typeof Te != "object") throw new Error(`Ability limits (${Pe}) must be an array of objects, found: ${Te}`);
      });
    });
  });
}
function gn$1(Ae, t, Me, Ie = {}) {
  return Me == null || Me.sort((Pe, Be) => Pe.localeCompare(Be)), { att: { [Ae]: pe$1(t, Me, Ie) } };
}
function pe$1(Ae, t, Me = {}) {
  t = t == null ? void 0 : t.sort((Pe, Be) => Pe.localeCompare(Be));
  const Ie = t.map((Pe) => ({ [`${Ae}/${Pe}`]: [Me] }));
  return Object.assign({}, ...Ie);
}
function G$1(Ae) {
  return O$3(Ae), `urn:recap:${hn$1(Ae).replace(/=/g, "")}`;
}
function R$2(Ae) {
  const t = yn$1(Ae.replace("urn:recap:", ""));
  return O$3(t), t;
}
function ir$2(Ae, t, Me) {
  const Ie = gn$1(Ae, t, Me);
  return G$1(Ie);
}
function me$3(Ae) {
  return Ae && Ae.includes("urn:recap:");
}
function cr$2(Ae, t) {
  const Me = R$2(Ae), Ie = R$2(t), Pe = bn$1(Me, Ie);
  return G$1(Pe);
}
function bn$1(Ae, t) {
  O$3(Ae), O$3(t);
  const Me = Object.keys(Ae.att).concat(Object.keys(t.att)).sort((Pe, Be) => Pe.localeCompare(Be)), Ie = { att: {} };
  return Me.forEach((Pe) => {
    var Be, Te;
    Object.keys(((Be = Ae.att) == null ? void 0 : Be[Pe]) || {}).concat(Object.keys(((Te = t.att) == null ? void 0 : Te[Pe]) || {})).sort((je, Ve) => je.localeCompare(Ve)).forEach((je) => {
      var Ve, fi;
      Ie.att[Pe] = an$1(de$1({}, Ie.att[Pe]), { [je]: ((Ve = Ae.att[Pe]) == null ? void 0 : Ve[je]) || ((fi = t.att[Pe]) == null ? void 0 : fi[je]) });
    });
  }), Ie;
}
function he$1(Ae = "", t) {
  O$3(t);
  const Me = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (Ae.includes(Me)) return Ae;
  const Ie = [];
  let Pe = 0;
  Object.keys(t.att).forEach((je) => {
    const Ve = Object.keys(t.att[je]).map((bi) => ({ ability: bi.split("/")[0], action: bi.split("/")[1] }));
    Ve.sort((bi, vi) => bi.action.localeCompare(vi.action));
    const fi = {};
    Ve.forEach((bi) => {
      fi[bi.ability] || (fi[bi.ability] = []), fi[bi.ability].push(bi.action);
    });
    const Ue = Object.keys(fi).map((bi) => (Pe++, `(${Pe}) '${bi}': '${fi[bi].join("', '")}' for '${je}'.`));
    Ie.push(Ue.join(", ").replace(".,", "."));
  });
  const Be = Ie.join(" "), Te = `${Me}${Be}`;
  return `${Ae ? Ae + " " : ""}${Te}`;
}
function ar$2(Ae) {
  var t;
  const Me = R$2(Ae);
  O$3(Me);
  const Ie = (t = Me.att) == null ? void 0 : t.eip155;
  return Ie ? Object.keys(Ie).map((Pe) => Pe.split("/")[1]) : [];
}
function ur$2(Ae) {
  const t = R$2(Ae);
  O$3(t);
  const Me = [];
  return Object.values(t.att).forEach((Ie) => {
    Object.values(Ie).forEach((Pe) => {
      var Be;
      (Be = Pe == null ? void 0 : Pe[0]) != null && Be.chains && Me.push(Pe[0].chains);
    });
  }), [...new Set(Me.flat())];
}
function Y$2(Ae) {
  if (!Ae) return;
  const t = Ae == null ? void 0 : Ae[Ae.length - 1];
  return me$3(t) ? t : void 0;
}
const ye$3 = "base10", g$1 = "base16", ge$1 = "base64pad", lr$2 = "base64url", k$1 = "utf8", ve$1 = 0, D$2 = 1, M$2 = 2, dr$2 = 0, wn = 1, K$2 = 12, be$3 = 32;
function fr$2() {
  const Ae = x25519.generateKeyPair();
  return { privateKey: toString(Ae.secretKey, g$1), publicKey: toString(Ae.publicKey, g$1) };
}
function pr$2() {
  const Ae = random.randomBytes(be$3);
  return toString(Ae, g$1);
}
function mr$2(Ae, t) {
  const Me = x25519.sharedKey(fromString(Ae, g$1), fromString(t, g$1), !0), Ie = new HKDF_1(sha256.SHA256, Me).expand(be$3);
  return toString(Ie, g$1);
}
function hr$2(Ae) {
  const t = sha256.hash(fromString(Ae, g$1));
  return toString(t, g$1);
}
function yr$2(Ae) {
  const t = sha256.hash(fromString(Ae, k$1));
  return toString(t, g$1);
}
function Ee$2(Ae) {
  return fromString(`${Ae}`, ye$3);
}
function A(Ae) {
  return Number(toString(Ae, ye$3));
}
function gr$2(Ae) {
  const t = Ee$2(typeof Ae.type < "u" ? Ae.type : ve$1);
  if (A(t) === D$2 && typeof Ae.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const Me = typeof Ae.senderPublicKey < "u" ? fromString(Ae.senderPublicKey, g$1) : void 0, Ie = typeof Ae.iv < "u" ? fromString(Ae.iv, g$1) : random.randomBytes(K$2), Pe = new chacha20poly1305.ChaCha20Poly1305(fromString(Ae.symKey, g$1)).seal(Ie, fromString(Ae.message, k$1));
  return we$3({ type: t, sealed: Pe, iv: Ie, senderPublicKey: Me, encoding: Ae.encoding });
}
function vr$2(Ae, t) {
  const Me = Ee$2(M$2), Ie = random.randomBytes(K$2), Pe = fromString(Ae, k$1);
  return we$3({ type: Me, sealed: Pe, iv: Ie, encoding: t });
}
function br$2(Ae) {
  const t = new chacha20poly1305.ChaCha20Poly1305(fromString(Ae.symKey, g$1)), { sealed: Me, iv: Ie } = Q$1({ encoded: Ae.encoded, encoding: Ae == null ? void 0 : Ae.encoding }), Pe = t.open(Ie, Me);
  if (Pe === null) throw new Error("Failed to decrypt");
  return toString(Pe, k$1);
}
function Er$2(Ae, t) {
  const { sealed: Me } = Q$1({ encoded: Ae, encoding: t });
  return toString(Me, k$1);
}
function we$3(Ae) {
  const { encoding: t = ge$1 } = Ae;
  if (A(Ae.type) === M$2) return toString(concat$1([Ae.type, Ae.sealed]), t);
  if (A(Ae.type) === D$2) {
    if (typeof Ae.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat$1([Ae.type, Ae.senderPublicKey, Ae.iv, Ae.sealed]), t);
  }
  return toString(concat$1([Ae.type, Ae.iv, Ae.sealed]), t);
}
function Q$1(Ae) {
  const { encoded: t, encoding: Me = ge$1 } = Ae, Ie = fromString(t, Me), Pe = Ie.slice(dr$2, wn), Be = wn;
  if (A(Pe) === D$2) {
    const fi = Be + be$3, Ue = fi + K$2, bi = Ie.slice(Be, fi), vi = Ie.slice(fi, Ue), mi = Ie.slice(Ue);
    return { type: Pe, sealed: mi, iv: vi, senderPublicKey: bi };
  }
  if (A(Pe) === M$2) {
    const fi = Ie.slice(Be), Ue = random.randomBytes(K$2);
    return { type: Pe, sealed: fi, iv: Ue };
  }
  const Te = Be + K$2, je = Ie.slice(Be, Te), Ve = Ie.slice(Te);
  return { type: Pe, sealed: Ve, iv: je };
}
function wr$2(Ae, t) {
  const Me = Q$1({ encoded: Ae, encoding: t == null ? void 0 : t.encoding });
  return On({ type: A(Me.type), senderPublicKey: typeof Me.senderPublicKey < "u" ? toString(Me.senderPublicKey, g$1) : void 0, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey });
}
function On(Ae) {
  const t = (Ae == null ? void 0 : Ae.type) || ve$1;
  if (t === D$2) {
    if (typeof (Ae == null ? void 0 : Ae.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (Ae == null ? void 0 : Ae.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: t, senderPublicKey: Ae == null ? void 0 : Ae.senderPublicKey, receiverPublicKey: Ae == null ? void 0 : Ae.receiverPublicKey };
}
function Or$2(Ae) {
  return Ae.type === D$2 && typeof Ae.senderPublicKey == "string" && typeof Ae.receiverPublicKey == "string";
}
function Nr$2(Ae) {
  return Ae.type === M$2;
}
function Nn(Ae) {
  return new ellipticExports.ec("p256").keyFromPublic({ x: Buffer$1.from(Ae.x, "base64").toString("hex"), y: Buffer$1.from(Ae.y, "base64").toString("hex") }, "hex");
}
function Sr$2(Ae) {
  let t = Ae.replace(/-/g, "+").replace(/_/g, "/");
  const Me = t.length % 4;
  return Me > 0 && (t += "=".repeat(4 - Me)), t;
}
function $r$2(Ae) {
  return Buffer$1.from(Sr$2(Ae), "base64");
}
function Rr$2(Ae, t) {
  const [Me, Ie, Pe] = Ae.split("."), Be = $r$2(Pe);
  if (Be.length !== 64) throw new Error("Invalid signature length");
  const Te = Be.slice(0, 32).toString("hex"), je = Be.slice(32, 64).toString("hex"), Ve = `${Me}.${Ie}`, fi = new sha256.SHA256().update(Buffer$1.from(Ve)).digest(), Ue = Nn(t), bi = Buffer$1.from(fi).toString("hex");
  if (!Ue.verify(bi, { r: Te, s: je })) throw new Error("Invalid signature");
  return decodeJWT(Ae).payload;
}
const Sn = "irn";
function Ir$1(Ae) {
  return (Ae == null ? void 0 : Ae.relay) || { protocol: Sn };
}
function jr$1(Ae) {
  const t = C$2[Ae];
  if (typeof t > "u") throw new Error(`Relay Protocol not supported: ${Ae}`);
  return t;
}
var Tr$2 = Object.defineProperty, Pr$2 = Object.defineProperties, Ar$2 = Object.getOwnPropertyDescriptors, $n = Object.getOwnPropertySymbols, Cr$2 = Object.prototype.hasOwnProperty, Ur$1 = Object.prototype.propertyIsEnumerable, Rn = (Ae, t, Me) => t in Ae ? Tr$2(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Me }) : Ae[t] = Me, In = (Ae, t) => {
  for (var Me in t || (t = {})) Cr$2.call(t, Me) && Rn(Ae, Me, t[Me]);
  if ($n) for (var Me of $n(t)) Ur$1.call(t, Me) && Rn(Ae, Me, t[Me]);
  return Ae;
}, _r$2 = (Ae, t) => Pr$2(Ae, Ar$2(t));
function jn(Ae, t = "-") {
  const Me = {}, Ie = "relay" + t;
  return Object.keys(Ae).forEach((Pe) => {
    if (Pe.startsWith(Ie)) {
      const Be = Pe.replace(Ie, ""), Te = Ae[Pe];
      Me[Be] = Te;
    }
  }), Me;
}
function kr$1(Ae) {
  if (!Ae.includes("wc:")) {
    const Ve = le$1(Ae);
    Ve != null && Ve.includes("wc:") && (Ae = Ve);
  }
  Ae = Ae.includes("wc://") ? Ae.replace("wc://", "") : Ae, Ae = Ae.includes("wc:") ? Ae.replace("wc:", "") : Ae;
  const t = Ae.indexOf(":"), Me = Ae.indexOf("?") !== -1 ? Ae.indexOf("?") : void 0, Ie = Ae.substring(0, t), Pe = Ae.substring(t + 1, Me).split("@"), Be = typeof Me < "u" ? Ae.substring(Me) : "", Te = queryString.parse(Be), je = typeof Te.methods == "string" ? Te.methods.split(",") : void 0;
  return { protocol: Ie, topic: Tn(Pe[0]), version: parseInt(Pe[1], 10), symKey: Te.symKey, relay: jn(Te), methods: je, expiryTimestamp: Te.expiryTimestamp ? parseInt(Te.expiryTimestamp, 10) : void 0 };
}
function Tn(Ae) {
  return Ae.startsWith("//") ? Ae.substring(2) : Ae;
}
function Pn(Ae, t = "-") {
  const Me = "relay", Ie = {};
  return Object.keys(Ae).forEach((Pe) => {
    const Be = Me + t + Pe;
    Ae[Pe] && (Ie[Be] = Ae[Pe]);
  }), Ie;
}
function Dr$2(Ae) {
  return `${Ae.protocol}:${Ae.topic}@${Ae.version}?` + queryString.stringify(In(_r$2(In({ symKey: Ae.symKey }, Pn(Ae.relay)), { expiryTimestamp: Ae.expiryTimestamp }), Ae.methods ? { methods: Ae.methods.join(",") } : {}));
}
function xr$2(Ae, t, Me) {
  return `${Ae}?wc_ev=${Me}&topic=${t}`;
}
var Vr$1 = Object.defineProperty, Mr$1 = Object.defineProperties, Kr$1 = Object.getOwnPropertyDescriptors, An = Object.getOwnPropertySymbols, Lr$1 = Object.prototype.hasOwnProperty, Fr$2 = Object.prototype.propertyIsEnumerable, Cn = (Ae, t, Me) => t in Ae ? Vr$1(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Me }) : Ae[t] = Me, qr$1 = (Ae, t) => {
  for (var Me in t || (t = {})) Lr$1.call(t, Me) && Cn(Ae, Me, t[Me]);
  if (An) for (var Me of An(t)) Fr$2.call(t, Me) && Cn(Ae, Me, t[Me]);
  return Ae;
}, Br$2 = (Ae, t) => Mr$1(Ae, Kr$1(t));
function C$1(Ae) {
  const t = [];
  return Ae.forEach((Me) => {
    const [Ie, Pe] = Me.split(":");
    t.push(`${Ie}:${Pe}`);
  }), t;
}
function Un(Ae) {
  const t = [];
  return Object.values(Ae).forEach((Me) => {
    t.push(...C$1(Me.accounts));
  }), t;
}
function _n(Ae, t) {
  const Me = [];
  return Object.values(Ae).forEach((Ie) => {
    C$1(Ie.accounts).includes(t) && Me.push(...Ie.methods);
  }), Me;
}
function kn(Ae, t) {
  const Me = [];
  return Object.values(Ae).forEach((Ie) => {
    C$1(Ie.accounts).includes(t) && Me.push(...Ie.events);
  }), Me;
}
function Wr$1(Ae) {
  const { proposal: { requiredNamespaces: t, optionalNamespaces: Me = {} }, supportedNamespaces: Ie } = Ae, Pe = Ne(t), Be = Ne(Me), Te = {};
  Object.keys(Ie).forEach((fi) => {
    const Ue = Ie[fi].chains, bi = Ie[fi].methods, vi = Ie[fi].events, mi = Ie[fi].accounts;
    Ue.forEach((_i) => {
      if (!mi.some(($i) => $i.includes(_i))) throw new Error(`No accounts provided for chain ${_i} in namespace ${fi}`);
    }), Te[fi] = { chains: Ue, methods: bi, events: vi, accounts: mi };
  });
  const je = zn(t, Te, "approve()");
  if (je) throw new Error(je.message);
  const Ve = {};
  return !Object.keys(t).length && !Object.keys(Me).length ? Te : (Object.keys(Pe).forEach((fi) => {
    const Ue = Ie[fi].chains.filter((_i) => {
      var $i, Ci;
      return (Ci = ($i = Pe[fi]) == null ? void 0 : $i.chains) == null ? void 0 : Ci.includes(_i);
    }), bi = Ie[fi].methods.filter((_i) => {
      var $i, Ci;
      return (Ci = ($i = Pe[fi]) == null ? void 0 : $i.methods) == null ? void 0 : Ci.includes(_i);
    }), vi = Ie[fi].events.filter((_i) => {
      var $i, Ci;
      return (Ci = ($i = Pe[fi]) == null ? void 0 : $i.events) == null ? void 0 : Ci.includes(_i);
    }), mi = Ue.map((_i) => Ie[fi].accounts.filter(($i) => $i.includes(`${_i}:`))).flat();
    Ve[fi] = { chains: Ue, methods: bi, events: vi, accounts: mi };
  }), Object.keys(Be).forEach((fi) => {
    var Ue, bi, vi, mi, _i, $i;
    if (!Ie[fi]) return;
    const Ci = (bi = (Ue = Be[fi]) == null ? void 0 : Ue.chains) == null ? void 0 : bi.filter((Hi) => Ie[fi].chains.includes(Hi)), Ui = Ie[fi].methods.filter((Hi) => {
      var Zi, Qi;
      return (Qi = (Zi = Be[fi]) == null ? void 0 : Zi.methods) == null ? void 0 : Qi.includes(Hi);
    }), ki = Ie[fi].events.filter((Hi) => {
      var Zi, Qi;
      return (Qi = (Zi = Be[fi]) == null ? void 0 : Zi.events) == null ? void 0 : Qi.includes(Hi);
    }), Ji = Ci == null ? void 0 : Ci.map((Hi) => Ie[fi].accounts.filter((Zi) => Zi.includes(`${Hi}:`))).flat();
    Ve[fi] = { chains: N((vi = Ve[fi]) == null ? void 0 : vi.chains, Ci), methods: N((mi = Ve[fi]) == null ? void 0 : mi.methods, Ui), events: N((_i = Ve[fi]) == null ? void 0 : _i.events, ki), accounts: N(($i = Ve[fi]) == null ? void 0 : $i.accounts, Ji) };
  }), Ve);
}
function Oe(Ae) {
  return Ae.includes(":");
}
function Dn$1(Ae) {
  return Oe(Ae) ? Ae.split(":")[0] : Ae;
}
function Ne(Ae) {
  var t, Me, Ie;
  const Pe = {};
  if (!Z$3(Ae)) return Pe;
  for (const [Be, Te] of Object.entries(Ae)) {
    const je = Oe(Be) ? [Be] : Te.chains, Ve = Te.methods || [], fi = Te.events || [], Ue = Dn$1(Be);
    Pe[Ue] = Br$2(qr$1({}, Pe[Ue]), { chains: N(je, (t = Pe[Ue]) == null ? void 0 : t.chains), methods: N(Ve, (Me = Pe[Ue]) == null ? void 0 : Me.methods), events: N(fi, (Ie = Pe[Ue]) == null ? void 0 : Ie.events) });
  }
  return Pe;
}
function xn(Ae) {
  const t = {};
  return Ae == null || Ae.forEach((Me) => {
    const [Ie, Pe] = Me.split(":");
    t[Ie] || (t[Ie] = { accounts: [], chains: [], events: [] }), t[Ie].accounts.push(Me), t[Ie].chains.push(`${Ie}:${Pe}`);
  }), t;
}
function Jr$1(Ae, t) {
  t = t.map((Ie) => Ie.replace("did:pkh:", ""));
  const Me = xn(t);
  for (const [Ie, Pe] of Object.entries(Me)) Pe.methods ? Pe.methods = N(Pe.methods, Ae) : Pe.methods = Ae, Pe.events = ["chainChanged", "accountsChanged"];
  return Me;
}
const Vn = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, Mn = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function S$4(Ae, t) {
  const { message: Me, code: Ie } = Mn[Ae];
  return { message: t ? `${Me} ${t}` : Me, code: Ie };
}
function U$2(Ae, t) {
  const { message: Me, code: Ie } = Vn[Ae];
  return { message: t ? `${Me} ${t}` : Me, code: Ie };
}
function L$2(Ae, t) {
  return !!Array.isArray(Ae);
}
function Z$3(Ae) {
  return Object.getPrototypeOf(Ae) === Object.prototype && Object.keys(Ae).length;
}
function I$3(Ae) {
  return typeof Ae > "u";
}
function b$2(Ae, t) {
  return t && I$3(Ae) ? !0 : typeof Ae == "string" && !!Ae.trim().length;
}
function X$1(Ae, t) {
  return typeof Ae == "number" && !isNaN(Ae);
}
function zr$2(Ae, t) {
  const { requiredNamespaces: Me } = t, Ie = Object.keys(Ae.namespaces), Pe = Object.keys(Me);
  let Be = !0;
  return $$2(Pe, Ie) ? (Ie.forEach((Te) => {
    const { accounts: je, methods: Ve, events: fi } = Ae.namespaces[Te], Ue = C$1(je), bi = Me[Te];
    (!$$2(W$2(Te, bi), Ue) || !$$2(bi.methods, Ve) || !$$2(bi.events, fi)) && (Be = !1);
  }), Be) : !1;
}
function F$2(Ae) {
  return b$2(Ae, !1) && Ae.includes(":") ? Ae.split(":").length === 2 : !1;
}
function Kn(Ae) {
  if (b$2(Ae, !1) && Ae.includes(":")) {
    const t = Ae.split(":");
    if (t.length === 3) {
      const Me = t[0] + ":" + t[1];
      return !!t[2] && F$2(Me);
    }
  }
  return !1;
}
function Gr$1(Ae) {
  function t(Me) {
    try {
      return typeof new URL(Me) < "u";
    } catch {
      return !1;
    }
  }
  try {
    if (b$2(Ae, !1)) {
      if (t(Ae)) return !0;
      const Me = le$1(Ae);
      return t(Me);
    }
  } catch {
  }
  return !1;
}
function Yr$1(Ae) {
  var t;
  return (t = Ae == null ? void 0 : Ae.proposer) == null ? void 0 : t.publicKey;
}
function Qr$1(Ae) {
  return Ae == null ? void 0 : Ae.topic;
}
function Zr$1(Ae, t) {
  let Me = null;
  return b$2(Ae == null ? void 0 : Ae.publicKey, !1) || (Me = S$4("MISSING_OR_INVALID", `${t} controller public key should be a string`)), Me;
}
function Se(Ae) {
  let t = !0;
  return L$2(Ae) ? Ae.length && (t = Ae.every((Me) => b$2(Me, !1))) : t = !1, t;
}
function Ln(Ae, t, Me) {
  let Ie = null;
  return L$2(t) && t.length ? t.forEach((Pe) => {
    Ie || F$2(Pe) || (Ie = U$2("UNSUPPORTED_CHAINS", `${Me}, chain ${Pe} should be a string and conform to "namespace:chainId" format`));
  }) : F$2(Ae) || (Ie = U$2("UNSUPPORTED_CHAINS", `${Me}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), Ie;
}
function Fn(Ae, t, Me) {
  let Ie = null;
  return Object.entries(Ae).forEach(([Pe, Be]) => {
    if (Ie) return;
    const Te = Ln(Pe, W$2(Pe, Be), `${t} ${Me}`);
    Te && (Ie = Te);
  }), Ie;
}
function qn(Ae, t) {
  let Me = null;
  return L$2(Ae) ? Ae.forEach((Ie) => {
    Me || Kn(Ie) || (Me = U$2("UNSUPPORTED_ACCOUNTS", `${t}, account ${Ie} should be a string and conform to "namespace:chainId:address" format`));
  }) : Me = U$2("UNSUPPORTED_ACCOUNTS", `${t}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), Me;
}
function Bn(Ae, t) {
  let Me = null;
  return Object.values(Ae).forEach((Ie) => {
    if (Me) return;
    const Pe = qn(Ie == null ? void 0 : Ie.accounts, `${t} namespace`);
    Pe && (Me = Pe);
  }), Me;
}
function Hn(Ae, t) {
  let Me = null;
  return Se(Ae == null ? void 0 : Ae.methods) ? Se(Ae == null ? void 0 : Ae.events) || (Me = U$2("UNSUPPORTED_EVENTS", `${t}, events should be an array of strings or empty array for no events`)) : Me = U$2("UNSUPPORTED_METHODS", `${t}, methods should be an array of strings or empty array for no methods`), Me;
}
function $e(Ae, t) {
  let Me = null;
  return Object.values(Ae).forEach((Ie) => {
    if (Me) return;
    const Pe = Hn(Ie, `${t}, namespace`);
    Pe && (Me = Pe);
  }), Me;
}
function Xr$1(Ae, t, Me) {
  let Ie = null;
  if (Ae && Z$3(Ae)) {
    const Pe = $e(Ae, t);
    Pe && (Ie = Pe);
    const Be = Fn(Ae, t, Me);
    Be && (Ie = Be);
  } else Ie = S$4("MISSING_OR_INVALID", `${t}, ${Me} should be an object with data`);
  return Ie;
}
function Wn(Ae, t) {
  let Me = null;
  if (Ae && Z$3(Ae)) {
    const Ie = $e(Ae, t);
    Ie && (Me = Ie);
    const Pe = Bn(Ae, t);
    Pe && (Me = Pe);
  } else Me = S$4("MISSING_OR_INVALID", `${t}, namespaces should be an object with data`);
  return Me;
}
function Jn(Ae) {
  return b$2(Ae.protocol, !0);
}
function eo(Ae, t) {
  let Me = !1;
  return Ae ? Ae && L$2(Ae) && Ae.length && Ae.forEach((Ie) => {
    Me = Jn(Ie);
  }) : Me = !0, Me;
}
function no(Ae) {
  return typeof Ae == "number";
}
function to(Ae) {
  return typeof Ae < "u" && typeof Ae !== null;
}
function ro(Ae) {
  return !(!Ae || typeof Ae != "object" || !Ae.code || !X$1(Ae.code) || !Ae.message || !b$2(Ae.message, !1));
}
function oo(Ae) {
  return !(I$3(Ae) || !b$2(Ae.method, !1));
}
function so(Ae) {
  return !(I$3(Ae) || I$3(Ae.result) && I$3(Ae.error) || !X$1(Ae.id) || !b$2(Ae.jsonrpc, !1));
}
function io(Ae) {
  return !(I$3(Ae) || !b$2(Ae.name, !1));
}
function co(Ae, t) {
  return !(!F$2(t) || !Un(Ae).includes(t));
}
function ao(Ae, t, Me) {
  return b$2(Me, !1) ? _n(Ae, t).includes(Me) : !1;
}
function uo(Ae, t, Me) {
  return b$2(Me, !1) ? kn(Ae, t).includes(Me) : !1;
}
function zn(Ae, t, Me) {
  let Ie = null;
  const Pe = lo(Ae), Be = fo(t), Te = Object.keys(Pe), je = Object.keys(Be), Ve = Gn(Object.keys(Ae)), fi = Gn(Object.keys(t)), Ue = Ve.filter((bi) => !fi.includes(bi));
  return Ue.length && (Ie = S$4("NON_CONFORMING_NAMESPACES", `${Me} namespaces keys don't satisfy requiredNamespaces.
      Required: ${Ue.toString()}
      Received: ${Object.keys(t).toString()}`)), $$2(Te, je) || (Ie = S$4("NON_CONFORMING_NAMESPACES", `${Me} namespaces chains don't satisfy required namespaces.
      Required: ${Te.toString()}
      Approved: ${je.toString()}`)), Object.keys(t).forEach((bi) => {
    if (!bi.includes(":") || Ie) return;
    const vi = C$1(t[bi].accounts);
    vi.includes(bi) || (Ie = S$4("NON_CONFORMING_NAMESPACES", `${Me} namespaces accounts don't satisfy namespace accounts for ${bi}
        Required: ${bi}
        Approved: ${vi.toString()}`));
  }), Te.forEach((bi) => {
    Ie || ($$2(Pe[bi].methods, Be[bi].methods) ? $$2(Pe[bi].events, Be[bi].events) || (Ie = S$4("NON_CONFORMING_NAMESPACES", `${Me} namespaces events don't satisfy namespace events for ${bi}`)) : Ie = S$4("NON_CONFORMING_NAMESPACES", `${Me} namespaces methods don't satisfy namespace methods for ${bi}`));
  }), Ie;
}
function lo(Ae) {
  const t = {};
  return Object.keys(Ae).forEach((Me) => {
    var Ie;
    Me.includes(":") ? t[Me] = Ae[Me] : (Ie = Ae[Me].chains) == null || Ie.forEach((Pe) => {
      t[Pe] = { methods: Ae[Me].methods, events: Ae[Me].events };
    });
  }), t;
}
function Gn(Ae) {
  return [...new Set(Ae.map((t) => t.includes(":") ? t.split(":")[0] : t))];
}
function fo(Ae) {
  const t = {};
  return Object.keys(Ae).forEach((Me) => {
    if (Me.includes(":")) t[Me] = Ae[Me];
    else {
      const Ie = C$1(Ae[Me].accounts);
      Ie == null || Ie.forEach((Pe) => {
        t[Pe] = { accounts: Ae[Me].accounts.filter((Be) => Be.includes(`${Pe}:`)), methods: Ae[Me].methods, events: Ae[Me].events };
      });
    }
  }), t;
}
function po(Ae, t) {
  return X$1(Ae) && Ae <= t.max && Ae >= t.min;
}
function mo() {
  const Ae = P$2();
  return new Promise((t) => {
    switch (Ae) {
      case y$1.browser:
        t(Yn());
        break;
      case y$1.reactNative:
        t(Qn());
        break;
      case y$1.node:
        t(Zn());
        break;
      default:
        t(!0);
    }
  });
}
function Yn() {
  return V$3() && (navigator == null ? void 0 : navigator.onLine);
}
async function Qn() {
  if (_$1() && typeof global < "u" && global != null && global.NetInfo) {
    const Ae = await (global == null ? void 0 : global.NetInfo.fetch());
    return Ae == null ? void 0 : Ae.isConnected;
  }
  return !0;
}
function Zn() {
  return !0;
}
function ho(Ae) {
  switch (P$2()) {
    case y$1.browser:
      Xn(Ae);
      break;
    case y$1.reactNative:
      et$2(Ae);
      break;
  }
}
function Xn(Ae) {
  !_$1() && V$3() && (window.addEventListener("online", () => Ae(!0)), window.addEventListener("offline", () => Ae(!1)));
}
function et$2(Ae) {
  _$1() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener((t) => Ae(t == null ? void 0 : t.isConnected)));
}
const Re = {};
class yo {
  static get(t) {
    return Re[t];
  }
  static set(t, Me) {
    Re[t] = Me;
  }
  static delete(t) {
    delete Re[t];
  }
}
const PARSE_ERROR = "PARSE_ERROR", INVALID_REQUEST = "INVALID_REQUEST", METHOD_NOT_FOUND = "METHOD_NOT_FOUND", INVALID_PARAMS = "INVALID_PARAMS", INTERNAL_ERROR = "INTERNAL_ERROR", SERVER_ERROR = "SERVER_ERROR", RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603], STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
}, DEFAULT_ERROR = SERVER_ERROR;
function isReservedErrorCode(Ae) {
  return RESERVED_ERROR_CODES.includes(Ae);
}
function getError(Ae) {
  return Object.keys(STANDARD_ERROR_MAP).includes(Ae) ? STANDARD_ERROR_MAP[Ae] : STANDARD_ERROR_MAP[DEFAULT_ERROR];
}
function getErrorByCode(Ae) {
  const t = Object.values(STANDARD_ERROR_MAP).find((Me) => Me.code === Ae);
  return t || STANDARD_ERROR_MAP[DEFAULT_ERROR];
}
function parseConnectionError(Ae, t, Me) {
  return Ae.message.includes("getaddrinfo ENOTFOUND") || Ae.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${Me} RPC url at ${t}`) : Ae;
}
var cjs = {}, crypto$1 = {}, hasRequiredCrypto;
function requireCrypto() {
  if (hasRequiredCrypto) return crypto$1;
  hasRequiredCrypto = 1, Object.defineProperty(crypto$1, "__esModule", { value: !0 }), crypto$1.isBrowserCryptoAvailable = crypto$1.getSubtleCrypto = crypto$1.getBrowerCrypto = void 0;
  function Ae() {
    return (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.crypto) || (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.msCrypto) || {};
  }
  crypto$1.getBrowerCrypto = Ae;
  function t() {
    const Ie = Ae();
    return Ie.subtle || Ie.webkitSubtle;
  }
  crypto$1.getSubtleCrypto = t;
  function Me() {
    return !!Ae() && !!t();
  }
  return crypto$1.isBrowserCryptoAvailable = Me, crypto$1;
}
var env = {}, hasRequiredEnv;
function requireEnv() {
  if (hasRequiredEnv) return env;
  hasRequiredEnv = 1, Object.defineProperty(env, "__esModule", { value: !0 }), env.isBrowser = env.isNode = env.isReactNative = void 0;
  function Ae() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  env.isReactNative = Ae;
  function t() {
    return typeof process$1 < "u" && typeof process$1.versions < "u" && typeof process$1.versions.node < "u";
  }
  env.isNode = t;
  function Me() {
    return !Ae() && !t();
  }
  return env.isBrowser = Me, env;
}
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  const t = require$$0$1;
  t.__exportStar(requireCrypto(), Ae), t.__exportStar(requireEnv(), Ae);
})(cjs);
function payloadId(Ae = 3) {
  const t = Date.now() * Math.pow(10, Ae), Me = Math.floor(Math.random() * Math.pow(10, Ae));
  return t + Me;
}
function getBigIntRpcId(Ae = 6) {
  return BigInt(payloadId(Ae));
}
function formatJsonRpcRequest(Ae, t, Me) {
  return {
    id: Me || payloadId(),
    jsonrpc: "2.0",
    method: Ae,
    params: t
  };
}
function formatJsonRpcResult(Ae, t) {
  return {
    id: Ae,
    jsonrpc: "2.0",
    result: t
  };
}
function formatJsonRpcError(Ae, t, Me) {
  return {
    id: Ae,
    jsonrpc: "2.0",
    error: formatErrorMessage(t)
  };
}
function formatErrorMessage(Ae, t) {
  return typeof Ae > "u" ? getError(INTERNAL_ERROR) : (typeof Ae == "string" && (Ae = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: Ae })), isReservedErrorCode(Ae.code) && (Ae = getErrorByCode(Ae.code)), Ae);
}
class e {
}
class n extends e {
  constructor() {
    super();
  }
}
class r extends n {
  constructor(t) {
    super();
  }
}
const WS_REGEX = "^wss?:";
function getUrlProtocol(Ae) {
  const t = Ae.match(new RegExp(/^\w+:/, "gi"));
  if (!(!t || !t.length))
    return t[0];
}
function matchRegexProtocol(Ae, t) {
  const Me = getUrlProtocol(Ae);
  return typeof Me > "u" ? !1 : new RegExp(t).test(Me);
}
function isWsUrl(Ae) {
  return matchRegexProtocol(Ae, WS_REGEX);
}
function isLocalhostUrl(Ae) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(Ae);
}
function isJsonRpcPayload(Ae) {
  return typeof Ae == "object" && "id" in Ae && "jsonrpc" in Ae && Ae.jsonrpc === "2.0";
}
function isJsonRpcRequest(Ae) {
  return isJsonRpcPayload(Ae) && "method" in Ae;
}
function isJsonRpcResponse(Ae) {
  return isJsonRpcPayload(Ae) && (isJsonRpcResult(Ae) || isJsonRpcError(Ae));
}
function isJsonRpcResult(Ae) {
  return "result" in Ae;
}
function isJsonRpcError(Ae) {
  return "error" in Ae;
}
let o$1 = class extends r {
  constructor(t) {
    super(t), this.events = new eventsExports.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(t), this.connection.connected && this.registerEventListeners();
  }
  async connect(t = this.connection) {
    await this.open(t);
  }
  async disconnect() {
    await this.close();
  }
  on(t, Me) {
    this.events.on(t, Me);
  }
  once(t, Me) {
    this.events.once(t, Me);
  }
  off(t, Me) {
    this.events.off(t, Me);
  }
  removeListener(t, Me) {
    this.events.removeListener(t, Me);
  }
  async request(t, Me) {
    return this.requestStrict(formatJsonRpcRequest(t.method, t.params || [], t.id || getBigIntRpcId().toString()), Me);
  }
  async requestStrict(t, Me) {
    return new Promise(async (Ie, Pe) => {
      if (!this.connection.connected) try {
        await this.open();
      } catch (Be) {
        Pe(Be);
      }
      this.events.on(`${t.id}`, (Be) => {
        isJsonRpcError(Be) ? Pe(Be.error) : Ie(Be.result);
      });
      try {
        await this.connection.send(t, Me);
      } catch (Be) {
        Pe(Be);
      }
    });
  }
  setConnection(t = this.connection) {
    return t;
  }
  onPayload(t) {
    this.events.emit("payload", t), isJsonRpcResponse(t) ? this.events.emit(`${t.id}`, t) : this.events.emit("message", { type: t.method, data: t.params });
  }
  onClose(t) {
    t && t.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${t.code} ${t.reason ? `(${t.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(t = this.connection) {
    this.connection === t && this.connection.connected || (this.connection.connected && this.close(), typeof t == "string" && (await this.connection.open(t), t = this.connection), this.connection = this.setConnection(t), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (t) => this.onPayload(t)), this.connection.on("close", (t) => this.onClose(t)), this.connection.on("error", (t) => this.events.emit("error", t)), this.connection.on("register_error", (t) => this.onClose()), this.hasRegisteredEventListeners = !0);
  }
};
const w$1 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"), b$1 = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", a = (Ae) => Ae.split("?")[0], h = 10, S$3 = w$1();
let f$2 = class {
  constructor(t) {
    if (this.url = t, this.events = new eventsExports.EventEmitter(), this.registering = !1, !isWsUrl(t)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${t}`);
    this.url = t;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(t, Me) {
    this.events.on(t, Me);
  }
  once(t, Me) {
    this.events.once(t, Me);
  }
  off(t, Me) {
    this.events.off(t, Me);
  }
  removeListener(t, Me) {
    this.events.removeListener(t, Me);
  }
  async open(t = this.url) {
    await this.register(t);
  }
  async close() {
    return new Promise((t, Me) => {
      if (typeof this.socket > "u") {
        Me(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (Ie) => {
        this.onClose(Ie), t();
      }, this.socket.close();
    });
  }
  async send(t) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(t));
    } catch (Me) {
      this.onError(t.id, Me);
    }
  }
  register(t = this.url) {
    if (!isWsUrl(t)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${t}`);
    if (this.registering) {
      const Me = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= Me || this.events.listenerCount("open") >= Me) && this.events.setMaxListeners(Me + 1), new Promise((Ie, Pe) => {
        this.events.once("register_error", (Be) => {
          this.resetMaxListeners(), Pe(Be);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return Pe(new Error("WebSocket connection is missing or invalid"));
          Ie(this.socket);
        });
      });
    }
    return this.url = t, this.registering = !0, new Promise((Me, Ie) => {
      const Pe = new URLSearchParams(t).get("origin"), Be = cjs.isReactNative() ? { headers: { origin: Pe } } : { rejectUnauthorized: !isLocalhostUrl(t) }, Te = new S$3(t, [], Be);
      b$1() ? Te.onerror = (je) => {
        const Ve = je;
        Ie(this.emitError(Ve.error));
      } : Te.on("error", (je) => {
        Ie(this.emitError(je));
      }), Te.onopen = () => {
        this.onOpen(Te), Me(Te);
      };
    });
  }
  onOpen(t) {
    t.onmessage = (Me) => this.onPayload(Me), t.onclose = (Me) => this.onClose(Me), this.socket = t, this.registering = !1, this.events.emit("open");
  }
  onClose(t) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", t);
  }
  onPayload(t) {
    if (typeof t.data > "u") return;
    const Me = typeof t.data == "string" ? safeJsonParse(t.data) : t.data;
    this.events.emit("payload", Me);
  }
  onError(t, Me) {
    const Ie = this.parseError(Me), Pe = Ie.message || Ie.toString(), Be = formatJsonRpcError(t, Pe);
    this.events.emit("payload", Be);
  }
  parseError(t, Me = this.url) {
    return parseConnectionError(t, a(Me), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h && this.events.setMaxListeners(h);
  }
  emitError(t) {
    const Me = this.parseError(new Error((t == null ? void 0 : t.message) || `WebSocket connection failed for host: ${a(this.url)}`));
    return this.events.emit("register_error", Me), Me;
  }
};
var lodash_isequal = { exports: {} };
lodash_isequal.exports;
(function(Ae, t) {
  var Me = 200, Ie = "__lodash_hash_undefined__", Pe = 1, Be = 2, Te = 9007199254740991, je = "[object Arguments]", Ve = "[object Array]", fi = "[object AsyncFunction]", Ue = "[object Boolean]", bi = "[object Date]", vi = "[object Error]", mi = "[object Function]", _i = "[object GeneratorFunction]", $i = "[object Map]", Ci = "[object Number]", Ui = "[object Null]", ki = "[object Object]", Ji = "[object Promise]", Hi = "[object Proxy]", Zi = "[object RegExp]", Qi = "[object Set]", Bi = "[object String]", Xi = "[object Symbol]", ns = "[object Undefined]", ls = "[object WeakMap]", vn = "[object ArrayBuffer]", Mi = "[object DataView]", Ai = "[object Float32Array]", wi = "[object Float64Array]", Ei = "[object Int8Array]", Ti = "[object Int16Array]", Pi = "[object Int32Array]", qi = "[object Uint8Array]", Oi = "[object Uint8ClampedArray]", Si = "[object Uint16Array]", Ni = "[object Uint32Array]", xi = /[\\^$.*+?()[\]{}|]/g, Wi = /^\[object .+?Constructor\]$/, ts = /^(?:0|[1-9]\d*)$/, Ki = {};
  Ki[Ai] = Ki[wi] = Ki[Ei] = Ki[Ti] = Ki[Pi] = Ki[qi] = Ki[Oi] = Ki[Si] = Ki[Ni] = !0, Ki[je] = Ki[Ve] = Ki[vn] = Ki[Ue] = Ki[Mi] = Ki[bi] = Ki[vi] = Ki[mi] = Ki[$i] = Ki[Ci] = Ki[ki] = Ki[Zi] = Ki[Qi] = Ki[Bi] = Ki[ls] = !1;
  var fn = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, Ii = typeof self == "object" && self && self.Object === Object && self, Fi = fn || Ii || Function("return this")(), Gi = t && !t.nodeType && t, Ri = Gi && !0 && Ae && !Ae.nodeType && Ae, ji = Ri && Ri.exports === Gi, Vi = ji && fn.process, is = function() {
    try {
      return Vi && Vi.binding && Vi.binding("util");
    } catch {
    }
  }(), os = is && is.isTypedArray;
  function ds(rs, cs) {
    for (var bs = -1, ba = rs == null ? 0 : rs.length, La = 0, Oa = []; ++bs < ba; ) {
      var Ua = rs[bs];
      cs(Ua, bs, rs) && (Oa[La++] = Ua);
    }
    return Oa;
  }
  function ps(rs, cs) {
    for (var bs = -1, ba = cs.length, La = rs.length; ++bs < ba; )
      rs[La + bs] = cs[bs];
    return rs;
  }
  function ea(rs, cs) {
    for (var bs = -1, ba = rs == null ? 0 : rs.length; ++bs < ba; )
      if (cs(rs[bs], bs, rs))
        return !0;
    return !1;
  }
  function ia(rs, cs) {
    for (var bs = -1, ba = Array(rs); ++bs < rs; )
      ba[bs] = cs(bs);
    return ba;
  }
  function hs(rs) {
    return function(cs) {
      return rs(cs);
    };
  }
  function fa(rs, cs) {
    return rs.has(cs);
  }
  function gs(rs, cs) {
    return rs == null ? void 0 : rs[cs];
  }
  function sa(rs) {
    var cs = -1, bs = Array(rs.size);
    return rs.forEach(function(ba, La) {
      bs[++cs] = [La, ba];
    }), bs;
  }
  function aa(rs, cs) {
    return function(bs) {
      return rs(cs(bs));
    };
  }
  function Ds(rs) {
    var cs = -1, bs = Array(rs.size);
    return rs.forEach(function(ba) {
      bs[++cs] = ba;
    }), bs;
  }
  var ra = Array.prototype, ca = Function.prototype, ta = Object.prototype, oa = Fi["__core-js_shared__"], da = ca.toString, Yi = ta.hasOwnProperty, Li = function() {
    var rs = /[^.]+$/.exec(oa && oa.keys && oa.keys.IE_PROTO || "");
    return rs ? "Symbol(src)_1." + rs : "";
  }(), zi = ta.toString, En = RegExp(
    "^" + da.call(Yi).replace(xi, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), ss = ji ? Fi.Buffer : void 0, as = Fi.Symbol, us = Fi.Uint8Array, ua = ta.propertyIsEnumerable, ma = ra.splice, na = as ? as.toStringTag : void 0, wa = Object.getOwnPropertySymbols, ya = ss ? ss.isBuffer : void 0, $a = aa(Object.keys, Object), Sa = Oo(Fi, "DataView"), Ea = Oo(Fi, "Map"), la = Oo(Fi, "Promise"), xa = Oo(Fi, "Set"), Aa = Oo(Fi, "WeakMap"), ha = Oo(Object, "create"), Ia = Bo(Sa), Da = Bo(Ea), va = Bo(la), Pa = Bo(xa), Ba = Bo(Aa), pa = as ? as.prototype : void 0, Ra = pa ? pa.valueOf : void 0;
  function _a(rs) {
    var cs = -1, bs = rs == null ? 0 : rs.length;
    for (this.clear(); ++cs < bs; ) {
      var ba = rs[cs];
      this.set(ba[0], ba[1]);
    }
  }
  function ga() {
    this.__data__ = ha ? ha(null) : {}, this.size = 0;
  }
  function Ca(rs) {
    var cs = this.has(rs) && delete this.__data__[rs];
    return this.size -= cs ? 1 : 0, cs;
  }
  function Na(rs) {
    var cs = this.__data__;
    if (ha) {
      var bs = cs[rs];
      return bs === Ie ? void 0 : bs;
    }
    return Yi.call(cs, rs) ? cs[rs] : void 0;
  }
  function Ma(rs) {
    var cs = this.__data__;
    return ha ? cs[rs] !== void 0 : Yi.call(cs, rs);
  }
  function Fa(rs, cs) {
    var bs = this.__data__;
    return this.size += this.has(rs) ? 0 : 1, bs[rs] = ha && cs === void 0 ? Ie : cs, this;
  }
  _a.prototype.clear = ga, _a.prototype.delete = Ca, _a.prototype.get = Na, _a.prototype.has = Ma, _a.prototype.set = Fa;
  function qa(rs) {
    var cs = -1, bs = rs == null ? 0 : rs.length;
    for (this.clear(); ++cs < bs; ) {
      var ba = rs[cs];
      this.set(ba[0], ba[1]);
    }
  }
  function Ta() {
    this.__data__ = [], this.size = 0;
  }
  function Va(rs) {
    var cs = this.__data__, bs = Lo(cs, rs);
    if (bs < 0)
      return !1;
    var ba = cs.length - 1;
    return bs == ba ? cs.pop() : ma.call(cs, bs, 1), --this.size, !0;
  }
  function Ga(rs) {
    var cs = this.__data__, bs = Lo(cs, rs);
    return bs < 0 ? void 0 : cs[bs][1];
  }
  function Ja(rs) {
    return Lo(this.__data__, rs) > -1;
  }
  function Xa(rs, cs) {
    var bs = this.__data__, ba = Lo(bs, rs);
    return ba < 0 ? (++this.size, bs.push([rs, cs])) : bs[ba][1] = cs, this;
  }
  qa.prototype.clear = Ta, qa.prototype.delete = Va, qa.prototype.get = Ga, qa.prototype.has = Ja, qa.prototype.set = Xa;
  function ja(rs) {
    var cs = -1, bs = rs == null ? 0 : rs.length;
    for (this.clear(); ++cs < bs; ) {
      var ba = rs[cs];
      this.set(ba[0], ba[1]);
    }
  }
  function go() {
    this.size = 0, this.__data__ = {
      hash: new _a(),
      map: new (Ea || qa)(),
      string: new _a()
    };
  }
  function wo(rs) {
    var cs = ko(this, rs).delete(rs);
    return this.size -= cs ? 1 : 0, cs;
  }
  function _o(rs) {
    return ko(this, rs).get(rs);
  }
  function $o(rs) {
    return ko(this, rs).has(rs);
  }
  function Eo(rs, cs) {
    var bs = ko(this, rs), ba = bs.size;
    return bs.set(rs, cs), this.size += bs.size == ba ? 0 : 1, this;
  }
  ja.prototype.clear = go, ja.prototype.delete = wo, ja.prototype.get = _o, ja.prototype.has = $o, ja.prototype.set = Eo;
  function Za(rs) {
    var cs = -1, bs = rs == null ? 0 : rs.length;
    for (this.__data__ = new ja(); ++cs < bs; )
      this.add(rs[cs]);
  }
  function So(rs) {
    return this.__data__.set(rs, Ie), this;
  }
  function xo(rs) {
    return this.__data__.has(rs);
  }
  Za.prototype.add = Za.prototype.push = So, Za.prototype.has = xo;
  function Ha(rs) {
    var cs = this.__data__ = new qa(rs);
    this.size = cs.size;
  }
  function Ao() {
    this.__data__ = new qa(), this.size = 0;
  }
  function Ro(rs) {
    var cs = this.__data__, bs = cs.delete(rs);
    return this.size = cs.size, bs;
  }
  function Mo(rs) {
    return this.__data__.get(rs);
  }
  function qo(rs) {
    return this.__data__.has(rs);
  }
  function To(rs, cs) {
    var bs = this.__data__;
    if (bs instanceof qa) {
      var ba = bs.__data__;
      if (!Ea || ba.length < Me - 1)
        return ba.push([rs, cs]), this.size = ++bs.size, this;
      bs = this.__data__ = new ja(ba);
    }
    return bs.set(rs, cs), this.size = bs.size, this;
  }
  Ha.prototype.clear = Ao, Ha.prototype.delete = Ro, Ha.prototype.get = Mo, Ha.prototype.has = qo, Ha.prototype.set = To;
  function sf(rs, cs) {
    var bs = Uo(rs), ba = !bs && wf(rs), La = !bs && !ba && Ko(rs), Oa = !bs && !ba && !La && Qo(rs), Ua = bs || ba || La || Oa, za = Ua ? ia(rs.length, String) : [], Ka = za.length;
    for (var ka in rs)
      Yi.call(rs, ka) && !(Ua && // Safari 9 has enumerable `arguments.length` in strict mode.
      (ka == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      La && (ka == "offset" || ka == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      Oa && (ka == "buffer" || ka == "byteLength" || ka == "byteOffset") || // Skip index properties.
      bf(ka, Ka))) && za.push(ka);
    return za;
  }
  function Lo(rs, cs) {
    for (var bs = rs.length; bs--; )
      if (Jo(rs[bs][0], cs))
        return bs;
    return -1;
  }
  function af(rs, cs, bs) {
    var ba = cs(rs);
    return Uo(rs) ? ba : ps(ba, bs(rs));
  }
  function No(rs) {
    return rs == null ? rs === void 0 ? ns : Ui : na && na in Object(rs) ? df(rs) : mf(rs);
  }
  function Ho(rs) {
    return Fo(rs) && No(rs) == je;
  }
  function Wo(rs, cs, bs, ba, La) {
    return rs === cs ? !0 : rs == null || cs == null || !Fo(rs) && !Fo(cs) ? rs !== rs && cs !== cs : of(rs, cs, bs, ba, Wo, La);
  }
  function of(rs, cs, bs, ba, La, Oa) {
    var Ua = Uo(rs), za = Uo(cs), Ka = Ua ? Ve : Do(rs), ka = za ? Ve : Do(cs);
    Ka = Ka == je ? ki : Ka, ka = ka == je ? ki : ka;
    var Ya = Ka == ki, vo = ka == ki, Wa = Ka == ka;
    if (Wa && Ko(rs)) {
      if (!Ko(cs))
        return !1;
      Ua = !0, Ya = !1;
    }
    if (Wa && !Ya)
      return Oa || (Oa = new Ha()), Ua || Qo(rs) ? Vo(rs, cs, bs, ba, La, Oa) : hf(rs, cs, Ka, bs, ba, La, Oa);
    if (!(bs & Pe)) {
      var Qa = Ya && Yi.call(rs, "__wrapped__"), bo = vo && Yi.call(cs, "__wrapped__");
      if (Qa || bo) {
        var Po = Qa ? rs.value() : rs, Io = bo ? cs.value() : cs;
        return Oa || (Oa = new Ha()), La(Po, Io, bs, ba, Oa);
      }
    }
    return Wa ? (Oa || (Oa = new Ha()), lf(rs, cs, bs, ba, La, Oa)) : !1;
  }
  function ff(rs) {
    if (!Zo(rs) || gf(rs))
      return !1;
    var cs = Xo(rs) ? En : Wi;
    return cs.test(Bo(rs));
  }
  function cf(rs) {
    return Fo(rs) && Yo(rs.length) && !!Ki[No(rs)];
  }
  function uf(rs) {
    if (!yf(rs))
      return $a(rs);
    var cs = [];
    for (var bs in Object(rs))
      Yi.call(rs, bs) && bs != "constructor" && cs.push(bs);
    return cs;
  }
  function Vo(rs, cs, bs, ba, La, Oa) {
    var Ua = bs & Pe, za = rs.length, Ka = cs.length;
    if (za != Ka && !(Ua && Ka > za))
      return !1;
    var ka = Oa.get(rs);
    if (ka && Oa.get(cs))
      return ka == cs;
    var Ya = -1, vo = !0, Wa = bs & Be ? new Za() : void 0;
    for (Oa.set(rs, cs), Oa.set(cs, rs); ++Ya < za; ) {
      var Qa = rs[Ya], bo = cs[Ya];
      if (ba)
        var Po = Ua ? ba(bo, Qa, Ya, cs, rs, Oa) : ba(Qa, bo, Ya, rs, cs, Oa);
      if (Po !== void 0) {
        if (Po)
          continue;
        vo = !1;
        break;
      }
      if (Wa) {
        if (!ea(cs, function(Io, Co) {
          if (!fa(Wa, Co) && (Qa === Io || La(Qa, Io, bs, ba, Oa)))
            return Wa.push(Co);
        })) {
          vo = !1;
          break;
        }
      } else if (!(Qa === bo || La(Qa, bo, bs, ba, Oa))) {
        vo = !1;
        break;
      }
    }
    return Oa.delete(rs), Oa.delete(cs), vo;
  }
  function hf(rs, cs, bs, ba, La, Oa, Ua) {
    switch (bs) {
      case Mi:
        if (rs.byteLength != cs.byteLength || rs.byteOffset != cs.byteOffset)
          return !1;
        rs = rs.buffer, cs = cs.buffer;
      case vn:
        return !(rs.byteLength != cs.byteLength || !Oa(new us(rs), new us(cs)));
      case Ue:
      case bi:
      case Ci:
        return Jo(+rs, +cs);
      case vi:
        return rs.name == cs.name && rs.message == cs.message;
      case Zi:
      case Bi:
        return rs == cs + "";
      case $i:
        var za = sa;
      case Qi:
        var Ka = ba & Pe;
        if (za || (za = Ds), rs.size != cs.size && !Ka)
          return !1;
        var ka = Ua.get(rs);
        if (ka)
          return ka == cs;
        ba |= Be, Ua.set(rs, cs);
        var Ya = Vo(za(rs), za(cs), ba, La, Oa, Ua);
        return Ua.delete(rs), Ya;
      case Xi:
        if (Ra)
          return Ra.call(rs) == Ra.call(cs);
    }
    return !1;
  }
  function lf(rs, cs, bs, ba, La, Oa) {
    var Ua = bs & Pe, za = Go(rs), Ka = za.length, ka = Go(cs), Ya = ka.length;
    if (Ka != Ya && !Ua)
      return !1;
    for (var vo = Ka; vo--; ) {
      var Wa = za[vo];
      if (!(Ua ? Wa in cs : Yi.call(cs, Wa)))
        return !1;
    }
    var Qa = Oa.get(rs);
    if (Qa && Oa.get(cs))
      return Qa == cs;
    var bo = !0;
    Oa.set(rs, cs), Oa.set(cs, rs);
    for (var Po = Ua; ++vo < Ka; ) {
      Wa = za[vo];
      var Io = rs[Wa], Co = cs[Wa];
      if (ba)
        var ef = Ua ? ba(Co, Io, Wa, cs, rs, Oa) : ba(Io, Co, Wa, rs, cs, Oa);
      if (!(ef === void 0 ? Io === Co || La(Io, Co, bs, ba, Oa) : ef)) {
        bo = !1;
        break;
      }
      Po || (Po = Wa == "constructor");
    }
    if (bo && !Po) {
      var jo = rs.constructor, zo = cs.constructor;
      jo != zo && "constructor" in rs && "constructor" in cs && !(typeof jo == "function" && jo instanceof jo && typeof zo == "function" && zo instanceof zo) && (bo = !1);
    }
    return Oa.delete(rs), Oa.delete(cs), bo;
  }
  function Go(rs) {
    return af(rs, Ef, pf);
  }
  function ko(rs, cs) {
    var bs = rs.__data__;
    return vf(cs) ? bs[typeof cs == "string" ? "string" : "hash"] : bs.map;
  }
  function Oo(rs, cs) {
    var bs = gs(rs, cs);
    return ff(bs) ? bs : void 0;
  }
  function df(rs) {
    var cs = Yi.call(rs, na), bs = rs[na];
    try {
      rs[na] = void 0;
      var ba = !0;
    } catch {
    }
    var La = zi.call(rs);
    return ba && (cs ? rs[na] = bs : delete rs[na]), La;
  }
  var pf = wa ? function(rs) {
    return rs == null ? [] : (rs = Object(rs), ds(wa(rs), function(cs) {
      return ua.call(rs, cs);
    }));
  } : Sf, Do = No;
  (Sa && Do(new Sa(new ArrayBuffer(1))) != Mi || Ea && Do(new Ea()) != $i || la && Do(la.resolve()) != Ji || xa && Do(new xa()) != Qi || Aa && Do(new Aa()) != ls) && (Do = function(rs) {
    var cs = No(rs), bs = cs == ki ? rs.constructor : void 0, ba = bs ? Bo(bs) : "";
    if (ba)
      switch (ba) {
        case Ia:
          return Mi;
        case Da:
          return $i;
        case va:
          return Ji;
        case Pa:
          return Qi;
        case Ba:
          return ls;
      }
    return cs;
  });
  function bf(rs, cs) {
    return cs = cs ?? Te, !!cs && (typeof rs == "number" || ts.test(rs)) && rs > -1 && rs % 1 == 0 && rs < cs;
  }
  function vf(rs) {
    var cs = typeof rs;
    return cs == "string" || cs == "number" || cs == "symbol" || cs == "boolean" ? rs !== "__proto__" : rs === null;
  }
  function gf(rs) {
    return !!Li && Li in rs;
  }
  function yf(rs) {
    var cs = rs && rs.constructor, bs = typeof cs == "function" && cs.prototype || ta;
    return rs === bs;
  }
  function mf(rs) {
    return zi.call(rs);
  }
  function Bo(rs) {
    if (rs != null) {
      try {
        return da.call(rs);
      } catch {
      }
      try {
        return rs + "";
      } catch {
      }
    }
    return "";
  }
  function Jo(rs, cs) {
    return rs === cs || rs !== rs && cs !== cs;
  }
  var wf = Ho(/* @__PURE__ */ function() {
    return arguments;
  }()) ? Ho : function(rs) {
    return Fo(rs) && Yi.call(rs, "callee") && !ua.call(rs, "callee");
  }, Uo = Array.isArray;
  function _f(rs) {
    return rs != null && Yo(rs.length) && !Xo(rs);
  }
  var Ko = ya || xf;
  function $f(rs, cs) {
    return Wo(rs, cs);
  }
  function Xo(rs) {
    if (!Zo(rs))
      return !1;
    var cs = No(rs);
    return cs == mi || cs == _i || cs == fi || cs == Hi;
  }
  function Yo(rs) {
    return typeof rs == "number" && rs > -1 && rs % 1 == 0 && rs <= Te;
  }
  function Zo(rs) {
    var cs = typeof rs;
    return rs != null && (cs == "object" || cs == "function");
  }
  function Fo(rs) {
    return rs != null && typeof rs == "object";
  }
  var Qo = os ? hs(os) : cf;
  function Ef(rs) {
    return _f(rs) ? sf(rs) : uf(rs);
  }
  function Sf() {
    return [];
  }
  function xf() {
    return !1;
  }
  Ae.exports = $f;
})(lodash_isequal, lodash_isequal.exports);
var lodash_isequalExports = lodash_isequal.exports;
const ys$1 = /* @__PURE__ */ getDefaultExportFromCjs(lodash_isequalExports), ye$2 = "wc", De$1 = 2, ie$2 = "core", x$3 = `${ye$2}@2:${ie$2}:`, Ye = { name: ie$2, logger: "error" }, Je = { database: ":memory:" }, Xe = "crypto", me$2 = "client_ed25519_seed", We$1 = cjs$3.ONE_DAY, Ze$1 = "keychain", Qe = "0.3", et$1 = "messages", tt$1 = "0.3", it$2 = cjs$3.SIX_HOURS, st$2 = "publisher", rt$2 = "irn", nt$2 = "error", be$2 = "wss://relay.walletconnect.org", ot$2 = "relayer", v$2 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" }, at$2 = "_subscription", I$2 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, ht$2 = 0.1, se$2 = "2.17.1", M$1 = { link_mode: "link_mode", relay: "relay" }, ct$2 = "0.3", lt$2 = "WALLETCONNECT_CLIENT_ID", fe$1 = "WALLETCONNECT_LINK_MODE_APPS", O$2 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, ut$2 = "subscription", dt$2 = "0.3", pt$2 = cjs$3.FIVE_SECONDS * 1e3, gt$2 = "pairing", yt$2 = "0.3", B$2 = { wc_pairingDelete: { req: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: cjs$3.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: cjs$3.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 0 } } }, V$2 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" }, P$1 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, Dt$1 = "history", mt$1 = "0.3", bt$1 = "expirer", S$2 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, ft$1 = "0.3", _t$1 = "verify-api", vs$1 = "https://verify.walletconnect.com", Et$1 = "https://verify.walletconnect.org", J$1 = Et$1, vt$1 = `${J$1}/v3`, wt$1 = [vs$1, Et$1], It$1 = "echo", Tt$1 = "https://echo.walletconnect.com", z$3 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" }, $$1 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" }, Is$1 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" }, Ts$1 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" }, Cs = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" }, Ps$1 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" }, Ct$1 = 0.1, Pt$1 = "event-client", St$1 = 86400, Rt$1 = "https://pulse.walletconnect.org/batch";
function Ss$1(Ae, t) {
  if (Ae.length >= 255) throw new TypeError("Alphabet too long");
  for (var Me = new Uint8Array(256), Ie = 0; Ie < Me.length; Ie++) Me[Ie] = 255;
  for (var Pe = 0; Pe < Ae.length; Pe++) {
    var Be = Ae.charAt(Pe), Te = Be.charCodeAt(0);
    if (Me[Te] !== 255) throw new TypeError(Be + " is ambiguous");
    Me[Te] = Pe;
  }
  var je = Ae.length, Ve = Ae.charAt(0), fi = Math.log(je) / Math.log(256), Ue = Math.log(256) / Math.log(je);
  function bi(_i) {
    if (_i instanceof Uint8Array || (ArrayBuffer.isView(_i) ? _i = new Uint8Array(_i.buffer, _i.byteOffset, _i.byteLength) : Array.isArray(_i) && (_i = Uint8Array.from(_i))), !(_i instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (_i.length === 0) return "";
    for (var $i = 0, Ci = 0, Ui = 0, ki = _i.length; Ui !== ki && _i[Ui] === 0; ) Ui++, $i++;
    for (var Ji = (ki - Ui) * Ue + 1 >>> 0, Hi = new Uint8Array(Ji); Ui !== ki; ) {
      for (var Zi = _i[Ui], Qi = 0, Bi = Ji - 1; (Zi !== 0 || Qi < Ci) && Bi !== -1; Bi--, Qi++) Zi += 256 * Hi[Bi] >>> 0, Hi[Bi] = Zi % je >>> 0, Zi = Zi / je >>> 0;
      if (Zi !== 0) throw new Error("Non-zero carry");
      Ci = Qi, Ui++;
    }
    for (var Xi = Ji - Ci; Xi !== Ji && Hi[Xi] === 0; ) Xi++;
    for (var ns = Ve.repeat($i); Xi < Ji; ++Xi) ns += Ae.charAt(Hi[Xi]);
    return ns;
  }
  function vi(_i) {
    if (typeof _i != "string") throw new TypeError("Expected String");
    if (_i.length === 0) return new Uint8Array();
    var $i = 0;
    if (_i[$i] !== " ") {
      for (var Ci = 0, Ui = 0; _i[$i] === Ve; ) Ci++, $i++;
      for (var ki = (_i.length - $i) * fi + 1 >>> 0, Ji = new Uint8Array(ki); _i[$i]; ) {
        var Hi = Me[_i.charCodeAt($i)];
        if (Hi === 255) return;
        for (var Zi = 0, Qi = ki - 1; (Hi !== 0 || Zi < Ui) && Qi !== -1; Qi--, Zi++) Hi += je * Ji[Qi] >>> 0, Ji[Qi] = Hi % 256 >>> 0, Hi = Hi / 256 >>> 0;
        if (Hi !== 0) throw new Error("Non-zero carry");
        Ui = Zi, $i++;
      }
      if (_i[$i] !== " ") {
        for (var Bi = ki - Ui; Bi !== ki && Ji[Bi] === 0; ) Bi++;
        for (var Xi = new Uint8Array(Ci + (ki - Bi)), ns = Ci; Bi !== ki; ) Xi[ns++] = Ji[Bi++];
        return Xi;
      }
    }
  }
  function mi(_i) {
    var $i = vi(_i);
    if ($i) return $i;
    throw new Error(`Non-${t} character`);
  }
  return { encode: bi, decodeUnsafe: vi, decode: mi };
}
var Rs$1 = Ss$1, xs = Rs$1;
const xt$1 = (Ae) => {
  if (Ae instanceof Uint8Array && Ae.constructor.name === "Uint8Array") return Ae;
  if (Ae instanceof ArrayBuffer) return new Uint8Array(Ae);
  if (ArrayBuffer.isView(Ae)) return new Uint8Array(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  throw new Error("Unknown type, must be binary type");
}, Os = (Ae) => new TextEncoder().encode(Ae), As = (Ae) => new TextDecoder().decode(Ae);
let Ns$1 = class {
  constructor(t, Me, Ie) {
    this.name = t, this.prefix = Me, this.baseEncode = Ie;
  }
  encode(t) {
    if (t instanceof Uint8Array) return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
};
class zs {
  constructor(t, Me, Ie) {
    if (this.name = t, this.prefix = Me, Me.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = Me.codePointAt(0), this.baseDecode = Ie;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(t) {
    return Ot$1(this, t);
  }
}
class Ls {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return Ot$1(this, t);
  }
  decode(t) {
    const Me = t[0], Ie = this.decoders[Me];
    if (Ie) return Ie.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const Ot$1 = (Ae, t) => new Ls({ ...Ae.decoders || { [Ae.prefix]: Ae }, ...t.decoders || { [t.prefix]: t } });
class $s {
  constructor(t, Me, Ie, Pe) {
    this.name = t, this.prefix = Me, this.baseEncode = Ie, this.baseDecode = Pe, this.encoder = new Ns$1(t, Me, Ie), this.decoder = new zs(t, Me, Pe);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
}
const re$1 = ({ name: Ae, prefix: t, encode: Me, decode: Ie }) => new $s(Ae, t, Me, Ie), X = ({ prefix: Ae, name: t, alphabet: Me }) => {
  const { encode: Ie, decode: Pe } = xs(Me, t);
  return re$1({ prefix: Ae, name: t, encode: Ie, decode: (Be) => xt$1(Pe(Be)) });
}, ks = (Ae, t, Me, Ie) => {
  const Pe = {};
  for (let Ue = 0; Ue < t.length; ++Ue) Pe[t[Ue]] = Ue;
  let Be = Ae.length;
  for (; Ae[Be - 1] === "="; ) --Be;
  const Te = new Uint8Array(Be * Me / 8 | 0);
  let je = 0, Ve = 0, fi = 0;
  for (let Ue = 0; Ue < Be; ++Ue) {
    const bi = Pe[Ae[Ue]];
    if (bi === void 0) throw new SyntaxError(`Non-${Ie} character`);
    Ve = Ve << Me | bi, je += Me, je >= 8 && (je -= 8, Te[fi++] = 255 & Ve >> je);
  }
  if (je >= Me || 255 & Ve << 8 - je) throw new SyntaxError("Unexpected end of data");
  return Te;
}, Ms = (Ae, t, Me) => {
  const Ie = t[t.length - 1] === "=", Pe = (1 << Me) - 1;
  let Be = "", Te = 0, je = 0;
  for (let Ve = 0; Ve < Ae.length; ++Ve) for (je = je << 8 | Ae[Ve], Te += 8; Te > Me; ) Te -= Me, Be += t[Pe & je >> Te];
  if (Te && (Be += t[Pe & je << Me - Te]), Ie) for (; Be.length * Me & 7; ) Be += "=";
  return Be;
}, f$1 = ({ name: Ae, prefix: t, bitsPerChar: Me, alphabet: Ie }) => re$1({ prefix: t, name: Ae, encode(Pe) {
  return Ms(Pe, Ie, Me);
}, decode(Pe) {
  return ks(Pe, Ie, Me, Ae);
} }), Us = re$1({ prefix: "\0", name: "identity", encode: (Ae) => As(Ae), decode: (Ae) => Os(Ae) });
var Fs = Object.freeze({ __proto__: null, identity: Us });
const Ks = f$1({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Bs = Object.freeze({ __proto__: null, base2: Ks });
const Vs = f$1({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var js = Object.freeze({ __proto__: null, base8: Vs });
const qs$1 = X({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Gs = Object.freeze({ __proto__: null, base10: qs$1 });
const Hs = f$1({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), Ys = f$1({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Js = Object.freeze({ __proto__: null, base16: Hs, base16upper: Ys });
const Xs = f$1({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), Ws = f$1({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), Zs = f$1({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), Qs = f$1({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), er$1 = f$1({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), tr$1 = f$1({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), ir$1 = f$1({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), sr$1 = f$1({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), rr$1 = f$1({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var nr$1 = Object.freeze({ __proto__: null, base32: Xs, base32upper: Ws, base32pad: Zs, base32padupper: Qs, base32hex: er$1, base32hexupper: tr$1, base32hexpad: ir$1, base32hexpadupper: sr$1, base32z: rr$1 });
const or$1 = X({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), ar$1 = X({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var hr$1 = Object.freeze({ __proto__: null, base36: or$1, base36upper: ar$1 });
const cr$1 = X({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), lr$1 = X({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var ur$1 = Object.freeze({ __proto__: null, base58btc: cr$1, base58flickr: lr$1 });
const dr$1 = f$1({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), pr$1 = f$1({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), gr$1 = f$1({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), yr$1 = f$1({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Dr$1 = Object.freeze({ __proto__: null, base64: dr$1, base64pad: pr$1, base64url: gr$1, base64urlpad: yr$1 });
const At$1 = Array.from(""), mr$1 = At$1.reduce((Ae, t, Me) => (Ae[Me] = t, Ae), []), br$1 = At$1.reduce((Ae, t, Me) => (Ae[t.codePointAt(0)] = Me, Ae), []);
function fr$1(Ae) {
  return Ae.reduce((t, Me) => (t += mr$1[Me], t), "");
}
function _r$1(Ae) {
  const t = [];
  for (const Me of Ae) {
    const Ie = br$1[Me.codePointAt(0)];
    if (Ie === void 0) throw new Error(`Non-base256emoji character: ${Me}`);
    t.push(Ie);
  }
  return new Uint8Array(t);
}
const Er$1 = re$1({ prefix: "", name: "base256emoji", encode: fr$1, decode: _r$1 });
var vr$1 = Object.freeze({ __proto__: null, base256emoji: Er$1 }), wr$1 = zt$1, Nt$1 = 128, Ir = 127, Tr$1 = ~Ir, Cr$1 = Math.pow(2, 31);
function zt$1(Ae, t, Me) {
  t = t || [], Me = Me || 0;
  for (var Ie = Me; Ae >= Cr$1; ) t[Me++] = Ae & 255 | Nt$1, Ae /= 128;
  for (; Ae & Tr$1; ) t[Me++] = Ae & 255 | Nt$1, Ae >>>= 7;
  return t[Me] = Ae | 0, zt$1.bytes = Me - Ie + 1, t;
}
var Pr$1 = _e$1, Sr$1 = 128, Lt$1 = 127;
function _e$1(Ae, Ie) {
  var Me = 0, Ie = Ie || 0, Pe = 0, Be = Ie, Te, je = Ae.length;
  do {
    if (Be >= je) throw _e$1.bytes = 0, new RangeError("Could not decode varint");
    Te = Ae[Be++], Me += Pe < 28 ? (Te & Lt$1) << Pe : (Te & Lt$1) * Math.pow(2, Pe), Pe += 7;
  } while (Te >= Sr$1);
  return _e$1.bytes = Be - Ie, Me;
}
var Rr$1 = Math.pow(2, 7), xr$1 = Math.pow(2, 14), Or$1 = Math.pow(2, 21), Ar$1 = Math.pow(2, 28), Nr$1 = Math.pow(2, 35), zr$1 = Math.pow(2, 42), Lr = Math.pow(2, 49), $r$1 = Math.pow(2, 56), kr = Math.pow(2, 63), Mr = function(Ae) {
  return Ae < Rr$1 ? 1 : Ae < xr$1 ? 2 : Ae < Or$1 ? 3 : Ae < Ar$1 ? 4 : Ae < Nr$1 ? 5 : Ae < zr$1 ? 6 : Ae < Lr ? 7 : Ae < $r$1 ? 8 : Ae < kr ? 9 : 10;
}, Ur = { encode: wr$1, decode: Pr$1, encodingLength: Mr }, $t$1 = Ur;
const kt$1 = (Ae, t, Me = 0) => ($t$1.encode(Ae, t, Me), t), Mt$1 = (Ae) => $t$1.encodingLength(Ae), Ee$1 = (Ae, t) => {
  const Me = t.byteLength, Ie = Mt$1(Ae), Pe = Ie + Mt$1(Me), Be = new Uint8Array(Pe + Me);
  return kt$1(Ae, Be, 0), kt$1(Me, Be, Ie), Be.set(t, Pe), new Fr$1(Ae, Me, t, Be);
};
let Fr$1 = class {
  constructor(t, Me, Ie, Pe) {
    this.code = t, this.size = Me, this.digest = Ie, this.bytes = Pe;
  }
};
const Ut$1 = ({ name: Ae, code: t, encode: Me }) => new Kr(Ae, t, Me);
class Kr {
  constructor(t, Me, Ie) {
    this.name = t, this.code = Me, this.encode = Ie;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const Me = this.encode(t);
      return Me instanceof Uint8Array ? Ee$1(this.code, Me) : Me.then((Ie) => Ee$1(this.code, Ie));
    } else throw Error("Unknown type, must be binary type");
  }
}
const Ft$1 = (Ae) => async (t) => new Uint8Array(await crypto.subtle.digest(Ae, t)), Br$1 = Ut$1({ name: "sha2-256", code: 18, encode: Ft$1("SHA-256") }), Vr = Ut$1({ name: "sha2-512", code: 19, encode: Ft$1("SHA-512") });
var jr = Object.freeze({ __proto__: null, sha256: Br$1, sha512: Vr });
const Kt$1 = 0, qr = "identity", Bt$1 = xt$1, Gr = (Ae) => Ee$1(Kt$1, Bt$1(Ae)), Hr = { code: Kt$1, name: qr, encode: Bt$1, digest: Gr };
var Yr = Object.freeze({ __proto__: null, identity: Hr });
new TextEncoder(), new TextDecoder();
const Vt$1 = { ...Fs, ...Bs, ...js, ...Gs, ...Js, ...nr$1, ...hr$1, ...ur$1, ...Dr$1, ...vr$1 };
({ ...jr, ...Yr });
function Jr(Ae = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(Ae) : new Uint8Array(Ae);
}
function jt$1(Ae, t, Me, Ie) {
  return { name: Ae, prefix: t, encoder: { name: Ae, prefix: t, encode: Me }, decoder: { decode: Ie } };
}
const qt$1 = jt$1("utf8", "u", (Ae) => "u" + new TextDecoder("utf8").decode(Ae), (Ae) => new TextEncoder().encode(Ae.substring(1))), ve = jt$1("ascii", "a", (Ae) => {
  let t = "a";
  for (let Me = 0; Me < Ae.length; Me++) t += String.fromCharCode(Ae[Me]);
  return t;
}, (Ae) => {
  Ae = Ae.substring(1);
  const t = Jr(Ae.length);
  for (let Me = 0; Me < Ae.length; Me++) t[Me] = Ae.charCodeAt(Me);
  return t;
}), Xr = { utf8: qt$1, "utf-8": qt$1, hex: Vt$1.base16, latin1: ve, ascii: ve, binary: ve, ...Vt$1 };
function Wr(Ae, t = "utf8") {
  const Me = Xr[t];
  if (!Me) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(Ae, "utf8") : Me.decoder.decode(`${Me.prefix}${Ae}`);
}
let Gt$1 = class {
  constructor(t, Me) {
    this.core = t, this.logger = Me, this.keychain = /* @__PURE__ */ new Map(), this.name = Ze$1, this.version = Qe, this.initialized = !1, this.storagePrefix = x$3, this.init = async () => {
      if (!this.initialized) {
        const Ie = await this.getKeyChain();
        typeof Ie < "u" && (this.keychain = Ie), this.initialized = !0;
      }
    }, this.has = (Ie) => (this.isInitialized(), this.keychain.has(Ie)), this.set = async (Ie, Pe) => {
      this.isInitialized(), this.keychain.set(Ie, Pe), await this.persist();
    }, this.get = (Ie) => {
      this.isInitialized();
      const Pe = this.keychain.get(Ie);
      if (typeof Pe > "u") {
        const { message: Be } = S$4("NO_MATCHING_KEY", `${this.name}: ${Ie}`);
        throw new Error(Be);
      }
      return Pe;
    }, this.del = async (Ie) => {
      this.isInitialized(), this.keychain.delete(Ie), await this.persist();
    }, this.core = t, this.logger = E$1(Me, this.name);
  }
  get context() {
    return y$3(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(t) {
    await this.core.storage.setItem(this.storageKey, Tt$2(t));
  }
  async getKeyChain() {
    const t = await this.core.storage.getItem(this.storageKey);
    return typeof t < "u" ? Pt$2(t) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}, Ht$1 = class {
  constructor(t, Me, Ie) {
    this.core = t, this.logger = Me, this.name = Xe, this.randomSessionIdentifier = pr$2(), this.initialized = !1, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0);
    }, this.hasKeys = (Pe) => (this.isInitialized(), this.keychain.has(Pe)), this.getClientId = async () => {
      this.isInitialized();
      const Pe = await this.getClientSeed(), Be = generateKeyPair(Pe);
      return encodeIss(Be.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const Pe = fr$2();
      return this.setPrivateKey(Pe.publicKey, Pe.privateKey);
    }, this.signJWT = async (Pe) => {
      this.isInitialized();
      const Be = await this.getClientSeed(), Te = generateKeyPair(Be), je = this.randomSessionIdentifier;
      return await signJWT(je, Pe, We$1, Te);
    }, this.generateSharedKey = (Pe, Be, Te) => {
      this.isInitialized();
      const je = this.getPrivateKey(Pe), Ve = mr$2(je, Be);
      return this.setSymKey(Ve, Te);
    }, this.setSymKey = async (Pe, Be) => {
      this.isInitialized();
      const Te = Be || hr$2(Pe);
      return await this.keychain.set(Te, Pe), Te;
    }, this.deleteKeyPair = async (Pe) => {
      this.isInitialized(), await this.keychain.del(Pe);
    }, this.deleteSymKey = async (Pe) => {
      this.isInitialized(), await this.keychain.del(Pe);
    }, this.encode = async (Pe, Be, Te) => {
      this.isInitialized();
      const je = On(Te), Ve = safeJsonStringify(Be);
      if (Nr$2(je)) return vr$2(Ve, Te == null ? void 0 : Te.encoding);
      if (Or$2(je)) {
        const vi = je.senderPublicKey, mi = je.receiverPublicKey;
        Pe = await this.generateSharedKey(vi, mi);
      }
      const fi = this.getSymKey(Pe), { type: Ue, senderPublicKey: bi } = je;
      return gr$2({ type: Ue, symKey: fi, message: Ve, senderPublicKey: bi, encoding: Te == null ? void 0 : Te.encoding });
    }, this.decode = async (Pe, Be, Te) => {
      this.isInitialized();
      const je = wr$2(Be, Te);
      if (Nr$2(je)) {
        const Ve = Er$2(Be, Te == null ? void 0 : Te.encoding);
        return safeJsonParse(Ve);
      }
      if (Or$2(je)) {
        const Ve = je.receiverPublicKey, fi = je.senderPublicKey;
        Pe = await this.generateSharedKey(Ve, fi);
      }
      try {
        const Ve = this.getSymKey(Pe), fi = br$2({ symKey: Ve, encoded: Be, encoding: Te == null ? void 0 : Te.encoding });
        return safeJsonParse(fi);
      } catch (Ve) {
        this.logger.error(`Failed to decode message from topic: '${Pe}', clientId: '${await this.getClientId()}'`), this.logger.error(Ve);
      }
    }, this.getPayloadType = (Pe, Be = ge$1) => {
      const Te = Q$1({ encoded: Pe, encoding: Be });
      return A(Te.type);
    }, this.getPayloadSenderPublicKey = (Pe, Be = ge$1) => {
      const Te = Q$1({ encoded: Pe, encoding: Be });
      return Te.senderPublicKey ? toString(Te.senderPublicKey, g$1) : void 0;
    }, this.core = t, this.logger = E$1(Me, this.name), this.keychain = Ie || new Gt$1(this.core, this.logger);
  }
  get context() {
    return y$3(this.logger);
  }
  async setPrivateKey(t, Me) {
    return await this.keychain.set(t, Me), t;
  }
  getPrivateKey(t) {
    return this.keychain.get(t);
  }
  async getClientSeed() {
    let t = "";
    try {
      t = this.keychain.get(me$2);
    } catch {
      t = pr$2(), await this.keychain.set(me$2, t);
    }
    return Wr(t, "base16");
  }
  getSymKey(t) {
    return this.keychain.get(t);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}, Yt$1 = class extends a$1 {
  constructor(t, Me) {
    super(t, Me), this.logger = t, this.core = Me, this.messages = /* @__PURE__ */ new Map(), this.name = et$1, this.version = tt$1, this.initialized = !1, this.storagePrefix = x$3, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const Ie = await this.getRelayerMessages();
          typeof Ie < "u" && (this.messages = Ie), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (Ie) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(Ie);
        } finally {
          this.initialized = !0;
        }
      }
    }, this.set = async (Ie, Pe) => {
      this.isInitialized();
      const Be = yr$2(Pe);
      let Te = this.messages.get(Ie);
      return typeof Te > "u" && (Te = {}), typeof Te[Be] < "u" || (Te[Be] = Pe, this.messages.set(Ie, Te), await this.persist()), Be;
    }, this.get = (Ie) => {
      this.isInitialized();
      let Pe = this.messages.get(Ie);
      return typeof Pe > "u" && (Pe = {}), Pe;
    }, this.has = (Ie, Pe) => {
      this.isInitialized();
      const Be = this.get(Ie), Te = yr$2(Pe);
      return typeof Be[Te] < "u";
    }, this.del = async (Ie) => {
      this.isInitialized(), this.messages.delete(Ie), await this.persist();
    }, this.logger = E$1(t, this.name), this.core = Me;
  }
  get context() {
    return y$3(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(t) {
    await this.core.storage.setItem(this.storageKey, Tt$2(t));
  }
  async getRelayerMessages() {
    const t = await this.core.storage.getItem(this.storageKey);
    return typeof t < "u" ? Pt$2(t) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
};
class Zr extends g$2 {
  constructor(t, Me) {
    super(t, Me), this.relayer = t, this.logger = Me, this.events = new eventsExports.EventEmitter(), this.name = st$2, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = cjs$3.toMiliseconds(cjs$3.ONE_MINUTE), this.failedPublishTimeout = cjs$3.toMiliseconds(cjs$3.ONE_SECOND), this.needsTransportRestart = !1, this.publish = async (Ie, Pe, Be) => {
      var Te;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: Ie, message: Pe, opts: Be } });
      const je = (Be == null ? void 0 : Be.ttl) || it$2, Ve = Ir$1(Be), fi = (Be == null ? void 0 : Be.prompt) || !1, Ue = (Be == null ? void 0 : Be.tag) || 0, bi = (Be == null ? void 0 : Be.id) || getBigIntRpcId().toString(), vi = { topic: Ie, message: Pe, opts: { ttl: je, relay: Ve, prompt: fi, tag: Ue, id: bi, attestation: Be == null ? void 0 : Be.attestation } }, mi = `Failed to publish payload, please try again. id:${bi} tag:${Ue}`, _i = Date.now();
      let $i, Ci = 1;
      try {
        for (; $i === void 0; ) {
          if (Date.now() - _i > this.publishTimeout) throw new Error(mi);
          this.logger.trace({ id: bi, attempts: Ci }, `publisher.publish - attempt ${Ci}`), $i = await await kt$2(this.rpcPublish(Ie, Pe, je, Ve, fi, Ue, bi, Be == null ? void 0 : Be.attestation).catch((Ui) => this.logger.warn(Ui)), this.publishTimeout, mi), Ci++, $i || await new Promise((Ui) => setTimeout(Ui, this.failedPublishTimeout));
        }
        this.relayer.events.emit(v$2.publish, vi), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { id: bi, topic: Ie, message: Pe, opts: Be } });
      } catch (Ui) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(Ui), (Te = Be == null ? void 0 : Be.internal) != null && Te.throwOnFailedPublish) throw Ui;
        this.queue.set(bi, vi);
      }
    }, this.on = (Ie, Pe) => {
      this.events.on(Ie, Pe);
    }, this.once = (Ie, Pe) => {
      this.events.once(Ie, Pe);
    }, this.off = (Ie, Pe) => {
      this.events.off(Ie, Pe);
    }, this.removeListener = (Ie, Pe) => {
      this.events.removeListener(Ie, Pe);
    }, this.relayer = t, this.logger = E$1(Me, this.name), this.registerEventListeners();
  }
  get context() {
    return y$3(this.logger);
  }
  rpcPublish(t, Me, Ie, Pe, Be, Te, je, Ve) {
    var fi, Ue, bi, vi;
    const mi = { method: jr$1(Pe.protocol).publish, params: { topic: t, message: Me, ttl: Ie, prompt: Be, tag: Te, attestation: Ve }, id: je };
    return I$3((fi = mi.params) == null ? void 0 : fi.prompt) && ((Ue = mi.params) == null || delete Ue.prompt), I$3((bi = mi.params) == null ? void 0 : bi.tag) && ((vi = mi.params) == null || delete vi.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: mi }), this.relayer.request(mi);
  }
  removeRequestFromQueue(t) {
    this.queue.delete(t);
  }
  checkQueue() {
    this.queue.forEach(async (t) => {
      const { topic: Me, message: Ie, opts: Pe } = t;
      await this.publish(Me, Ie, Pe);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r$1.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = !1, this.relayer.events.emit(v$2.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(v$2.message_ack, (t) => {
      this.removeRequestFromQueue(t.id.toString());
    });
  }
}
class Qr {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (t, Me) => {
      const Ie = this.get(t);
      this.exists(t, Me) || this.map.set(t, [...Ie, Me]);
    }, this.get = (t) => this.map.get(t) || [], this.exists = (t, Me) => this.get(t).includes(Me), this.delete = (t, Me) => {
      if (typeof Me > "u") {
        this.map.delete(t);
        return;
      }
      if (!this.map.has(t)) return;
      const Ie = this.get(t);
      if (!this.exists(t, Me)) return;
      const Pe = Ie.filter((Be) => Be !== Me);
      if (!Pe.length) {
        this.map.delete(t);
        return;
      }
      this.map.set(t, Pe);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var en = Object.defineProperty, tn = Object.defineProperties, sn = Object.getOwnPropertyDescriptors, Jt$1 = Object.getOwnPropertySymbols, rn = Object.prototype.hasOwnProperty, nn = Object.prototype.propertyIsEnumerable, Xt$1 = (Ae, t, Me) => t in Ae ? en(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Me }) : Ae[t] = Me, W$1 = (Ae, t) => {
  for (var Me in t || (t = {})) rn.call(t, Me) && Xt$1(Ae, Me, t[Me]);
  if (Jt$1) for (var Me of Jt$1(t)) nn.call(t, Me) && Xt$1(Ae, Me, t[Me]);
  return Ae;
}, we$2 = (Ae, t) => tn(Ae, sn(t));
let Wt$1 = class extends d$1 {
  constructor(t, Me) {
    super(t, Me), this.relayer = t, this.logger = Me, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new Qr(), this.events = new eventsExports.EventEmitter(), this.name = ut$2, this.version = dt$2, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = x$3, this.subscribeTimeout = cjs$3.toMiliseconds(cjs$3.ONE_MINUTE), this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.pendingBatchMessages = [], this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = !0;
    }, this.subscribe = async (Ie, Pe) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: Ie, opts: Pe } });
      try {
        const Be = Ir$1(Pe), Te = { topic: Ie, relay: Be, transportType: Pe == null ? void 0 : Pe.transportType };
        this.pending.set(Ie, Te);
        const je = await this.rpcSubscribe(Ie, Be, Pe);
        return typeof je == "string" && (this.onSubscribe(je, Te), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: Ie, opts: Pe } })), je;
      } catch (Be) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(Be), Be;
      }
    }, this.unsubscribe = async (Ie, Pe) => {
      await this.restartToComplete(), this.isInitialized(), typeof (Pe == null ? void 0 : Pe.id) < "u" ? await this.unsubscribeById(Ie, Pe.id, Pe) : await this.unsubscribeByTopic(Ie, Pe);
    }, this.isSubscribed = async (Ie) => {
      if (this.topics.includes(Ie)) return !0;
      const Pe = `${this.pendingSubscriptionWatchLabel}_${Ie}`;
      return await new Promise((Be, Te) => {
        const je = new cjs$3.Watch();
        je.start(Pe);
        const Ve = setInterval(() => {
          !this.pending.has(Ie) && this.topics.includes(Ie) && (clearInterval(Ve), je.stop(Pe), Be(!0)), je.elapsed(Pe) >= pt$2 && (clearInterval(Ve), je.stop(Pe), Te(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => !1);
    }, this.on = (Ie, Pe) => {
      this.events.on(Ie, Pe);
    }, this.once = (Ie, Pe) => {
      this.events.once(Ie, Pe);
    }, this.off = (Ie, Pe) => {
      this.events.off(Ie, Pe);
    }, this.removeListener = (Ie, Pe) => {
      this.events.removeListener(Ie, Pe);
    }, this.start = async () => {
      await this.onConnect();
    }, this.stop = async () => {
      await this.onDisconnect();
    }, this.restart = async () => {
      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;
    }, this.relayer = t, this.logger = E$1(Me, this.name), this.clientId = "";
  }
  get context() {
    return y$3(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(t, Me) {
    let Ie = !1;
    try {
      Ie = this.getSubscription(t).topic === Me;
    } catch {
    }
    return Ie;
  }
  onEnable() {
    this.cached = [], this.initialized = !0;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(t, Me) {
    const Ie = this.topicMap.get(t);
    await Promise.all(Ie.map(async (Pe) => await this.unsubscribeById(t, Pe, Me)));
  }
  async unsubscribeById(t, Me, Ie) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: t, id: Me, opts: Ie } });
    try {
      const Pe = Ir$1(Ie);
      await this.rpcUnsubscribe(t, Me, Pe);
      const Be = U$2("USER_DISCONNECTED", `${this.name}, ${t}`);
      await this.onUnsubscribe(t, Me, Be), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: t, id: Me, opts: Ie } });
    } catch (Pe) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(Pe), Pe;
    }
  }
  async rpcSubscribe(t, Me, Ie) {
    var Pe;
    (Ie == null ? void 0 : Ie.transportType) === M$1.relay && await this.restartToComplete();
    const Be = { method: jr$1(Me.protocol).subscribe, params: { topic: t } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: Be });
    const Te = (Pe = Ie == null ? void 0 : Ie.internal) == null ? void 0 : Pe.throwOnFailedPublish;
    try {
      const je = yr$2(t + this.clientId);
      if ((Ie == null ? void 0 : Ie.transportType) === M$1.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(Be).catch((fi) => this.logger.warn(fi));
      }, cjs$3.toMiliseconds(cjs$3.ONE_SECOND)), je;
      const Ve = await kt$2(this.relayer.request(Be).catch((fi) => this.logger.warn(fi)), this.subscribeTimeout, `Subscribing to ${t} failed, please try again`);
      if (!Ve && Te) throw new Error(`Subscribing to ${t} failed, please try again`);
      return Ve ? je : null;
    } catch (je) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(v$2.connection_stalled), Te) throw je;
    }
    return null;
  }
  async rpcBatchSubscribe(t) {
    if (!t.length) return;
    const Me = t[0].relay, Ie = { method: jr$1(Me.protocol).batchSubscribe, params: { topics: t.map((Pe) => Pe.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: Ie });
    try {
      return await await kt$2(this.relayer.request(Ie).catch((Pe) => this.logger.warn(Pe)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(v$2.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(t) {
    if (!t.length) return;
    const Me = t[0].relay, Ie = { method: jr$1(Me.protocol).batchFetchMessages, params: { topics: t.map((Be) => Be.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: Ie });
    let Pe;
    try {
      Pe = await await kt$2(this.relayer.request(Ie).catch((Be) => this.logger.warn(Be)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(v$2.connection_stalled);
    }
    return Pe;
  }
  rpcUnsubscribe(t, Me, Ie) {
    const Pe = { method: jr$1(Ie.protocol).unsubscribe, params: { topic: t, id: Me } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: Pe }), this.relayer.request(Pe);
  }
  onSubscribe(t, Me) {
    this.setSubscription(t, we$2(W$1({}, Me), { id: t })), this.pending.delete(Me.topic);
  }
  onBatchSubscribe(t) {
    t.length && t.forEach((Me) => {
      this.setSubscription(Me.id, W$1({}, Me)), this.pending.delete(Me.topic);
    });
  }
  async onUnsubscribe(t, Me, Ie) {
    this.events.removeAllListeners(Me), this.hasSubscription(Me, t) && this.deleteSubscription(Me, Ie), await this.relayer.messages.del(t);
  }
  async setRelayerSubscriptions(t) {
    await this.relayer.core.storage.setItem(this.storageKey, t);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(t, Me) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: t, subscription: Me }), this.addSubscription(t, Me);
  }
  addSubscription(t, Me) {
    this.subscriptions.set(t, W$1({}, Me)), this.topicMap.set(Me.topic, t), this.events.emit(O$2.created, Me);
  }
  getSubscription(t) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: t });
    const Me = this.subscriptions.get(t);
    if (!Me) {
      const { message: Ie } = S$4("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw new Error(Ie);
    }
    return Me;
  }
  deleteSubscription(t, Me) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: t, reason: Me });
    const Ie = this.getSubscription(t);
    this.subscriptions.delete(t), this.topicMap.delete(Ie.topic, t), this.events.emit(O$2.deleted, we$2(W$1({}, Ie), { reason: Me }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(O$2.sync);
  }
  async reset() {
    if (this.cached.length) {
      const t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let Me = 0; Me < t; Me++) {
        const Ie = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchFetchMessages(Ie), await this.batchSubscribe(Ie);
      }
    }
    this.events.emit(O$2.resubscribed);
  }
  async restore() {
    try {
      const t = await this.getRelayerSubscriptions();
      if (typeof t > "u" || !t.length) return;
      if (this.subscriptions.size) {
        const { message: Me } = S$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Me), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(Me);
      }
      this.cached = t, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(t);
    }
  }
  async batchSubscribe(t) {
    if (!t.length) return;
    const Me = await this.rpcBatchSubscribe(t);
    L$2(Me) && this.onBatchSubscribe(Me.map((Ie, Pe) => we$2(W$1({}, t[Pe]), { id: Ie })));
  }
  async batchFetchMessages(t) {
    if (!t.length) return;
    this.logger.trace(`Fetching batch messages for ${t.length} subscriptions`);
    const Me = await this.rpcBatchFetchMessages(t);
    Me && Me.messages && (this.pendingBatchMessages = this.pendingBatchMessages.concat(Me.messages));
  }
  async onConnect() {
    await this.restart(), this.onEnable();
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || !this.relayer.connected) return;
    const t = [];
    this.pending.forEach((Me) => {
      t.push(Me);
    }), await this.batchSubscribe(t), this.pendingBatchMessages.length && (await this.relayer.handleBatchMessageEvents(this.pendingBatchMessages), this.pendingBatchMessages = []);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r$1.pulse, async () => {
      await this.checkPending();
    }), this.events.on(O$2.created, async (t) => {
      const Me = O$2.created;
      this.logger.info(`Emitting ${Me}`), this.logger.debug({ type: "event", event: Me, data: t }), await this.persist();
    }), this.events.on(O$2.deleted, async (t) => {
      const Me = O$2.deleted;
      this.logger.info(`Emitting ${Me}`), this.logger.debug({ type: "event", event: Me, data: t }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  async restartToComplete() {
    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen(), this.restartInProgress && await new Promise((t) => {
      const Me = setInterval(() => {
        this.restartInProgress || (clearInterval(Me), t());
      }, this.pollingInterval);
    });
  }
};
var on = Object.defineProperty, Zt$1 = Object.getOwnPropertySymbols, an = Object.prototype.hasOwnProperty, hn = Object.prototype.propertyIsEnumerable, Qt$1 = (Ae, t, Me) => t in Ae ? on(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Me }) : Ae[t] = Me, ei = (Ae, t) => {
  for (var Me in t || (t = {})) an.call(t, Me) && Qt$1(Ae, Me, t[Me]);
  if (Zt$1) for (var Me of Zt$1(t)) hn.call(t, Me) && Qt$1(Ae, Me, t[Me]);
  return Ae;
};
class ti extends u {
  constructor(t) {
    super(t), this.protocol = "wc", this.version = 2, this.events = new eventsExports.EventEmitter(), this.name = ot$2, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "stalled", "interrupted"], this.hasExperiencedNetworkDisruption = !1, this.requestsInFlight = /* @__PURE__ */ new Map(), this.heartBeatTimeout = cjs$3.toMiliseconds(cjs$3.THIRTY_SECONDS + cjs$3.ONE_SECOND), this.request = async (Me) => {
      var Ie, Pe;
      this.logger.debug("Publishing Request Payload");
      const Be = Me.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        const Te = this.provider.request(Me);
        this.requestsInFlight.set(Be, { promise: Te, request: Me }), this.logger.trace({ id: Be, method: Me.method, topic: (Ie = Me.params) == null ? void 0 : Ie.topic }, "relayer.request - attempt to publish...");
        const je = await new Promise(async (Ve, fi) => {
          const Ue = () => {
            fi(new Error(`relayer.request - publish interrupted, id: ${Be}`));
          };
          this.provider.on(I$2.disconnect, Ue);
          const bi = await Te;
          this.provider.off(I$2.disconnect, Ue), Ve(bi);
        });
        return this.logger.trace({ id: Be, method: Me.method, topic: (Pe = Me.params) == null ? void 0 : Pe.topic }, "relayer.request - published"), je;
      } catch (Te) {
        throw this.logger.debug(`Failed to Publish Request: ${Be}`), Te;
      } finally {
        this.requestsInFlight.delete(Be);
      }
    }, this.resetPingTimeout = () => {
      if (ce$1()) try {
        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
          var Me, Ie, Pe;
          (Pe = (Ie = (Me = this.provider) == null ? void 0 : Me.connection) == null ? void 0 : Ie.socket) == null || Pe.terminate();
        }, this.heartBeatTimeout);
      } catch (Me) {
        this.logger.warn(Me);
      }
    }, this.onPayloadHandler = (Me) => {
      this.onProviderPayload(Me), this.resetPingTimeout();
    }, this.onConnectHandler = () => {
      this.logger.trace("relayer connected"), this.startPingTimeout(), this.events.emit(v$2.connect);
    }, this.onDisconnectHandler = () => {
      this.logger.trace("relayer disconnected"), this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (Me) => {
      this.logger.error(Me), this.events.emit(v$2.error, Me), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(I$2.payload, this.onPayloadHandler), this.provider.on(I$2.connect, this.onConnectHandler), this.provider.on(I$2.disconnect, this.onDisconnectHandler), this.provider.on(I$2.error, this.onProviderErrorHandler);
    }, this.core = t.core, this.logger = typeof t.logger < "u" && typeof t.logger != "string" ? E$1(t.logger, this.name) : qt$3(k$2({ level: t.logger || nt$2 })), this.messages = new Yt$1(this.logger, t.core), this.subscriber = new Wt$1(this, this.logger), this.publisher = new Zr(this, this.logger), this.relayUrl = (t == null ? void 0 : t.relayUrl) || be$2, this.projectId = t.projectId, this.bundleId = Ot$2(), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = !0, this.subscriber.cached.length > 0) try {
      await this.transportOpen();
    } catch (t) {
      this.logger.warn(t);
    }
  }
  get context() {
    return y$3(this.logger);
  }
  get connected() {
    var t, Me, Ie;
    return ((Ie = (Me = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : Me.socket) == null ? void 0 : Ie.readyState) === 1;
  }
  get connecting() {
    var t, Me, Ie;
    return ((Ie = (Me = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : Me.socket) == null ? void 0 : Ie.readyState) === 0;
  }
  async publish(t, Me, Ie) {
    this.isInitialized(), await this.publisher.publish(t, Me, Ie), await this.recordMessageEvent({ topic: t, message: Me, publishedAt: Date.now(), transportType: M$1.relay });
  }
  async subscribe(t, Me) {
    var Ie, Pe, Be;
    this.isInitialized(), (Me == null ? void 0 : Me.transportType) === "relay" && await this.toEstablishConnection();
    const Te = typeof ((Ie = Me == null ? void 0 : Me.internal) == null ? void 0 : Ie.throwOnFailedPublish) > "u" ? !0 : (Pe = Me == null ? void 0 : Me.internal) == null ? void 0 : Pe.throwOnFailedPublish;
    let je = ((Be = this.subscriber.topicMap.get(t)) == null ? void 0 : Be[0]) || "", Ve;
    const fi = (Ue) => {
      Ue.topic === t && (this.subscriber.off(O$2.created, fi), Ve());
    };
    return await Promise.all([new Promise((Ue) => {
      Ve = Ue, this.subscriber.on(O$2.created, fi);
    }), new Promise(async (Ue, bi) => {
      je = await this.subscriber.subscribe(t, ei({ internal: { throwOnFailedPublish: Te } }, Me)).catch((vi) => {
        Te && bi(vi);
      }) || je, Ue();
    })]), je;
  }
  async unsubscribe(t, Me) {
    this.isInitialized(), await this.subscriber.unsubscribe(t, Me);
  }
  on(t, Me) {
    this.events.on(t, Me);
  }
  once(t, Me) {
    this.events.once(t, Me);
  }
  off(t, Me) {
    this.events.off(t, Me);
  }
  removeListener(t, Me) {
    this.events.removeListener(t, Me);
  }
  async transportDisconnect() {
    if (!this.hasExperiencedNetworkDisruption && this.connected && this.requestsInFlight.size > 0) try {
      await Promise.all(Array.from(this.requestsInFlight.values()).map((t) => t.promise));
    } catch (t) {
      this.logger.warn(t);
    }
    this.hasExperiencedNetworkDisruption || this.connected ? await kt$2(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = !0, await this.transportDisconnect();
  }
  async transportOpen(t) {
    await this.confirmOnlineStateOrThrow(), t && t !== this.relayUrl && (this.relayUrl = t, await this.transportDisconnect()), await this.createProvider(), this.connectionAttemptInProgress = !0, this.transportExplicitlyClosed = !1;
    try {
      await new Promise(async (Me, Ie) => {
        const Pe = () => {
          this.provider.off(I$2.disconnect, Pe), Ie(new Error("Connection interrupted while trying to subscribe"));
        };
        this.provider.on(I$2.disconnect, Pe), await kt$2(this.provider.connect(), cjs$3.toMiliseconds(cjs$3.ONE_MINUTE), `Socket stalled when trying to connect to ${this.relayUrl}`).catch((Be) => {
          Ie(Be);
        }).finally(() => {
          clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;
        }), this.subscriber.start().catch((Be) => {
          this.logger.error(Be), this.onDisconnectHandler();
        }), this.hasExperiencedNetworkDisruption = !1, Me();
      });
    } catch (Me) {
      this.logger.error(Me);
      const Ie = Me;
      if (this.hasExperiencedNetworkDisruption = !0, !this.isConnectionStalled(Ie.message)) throw Me;
    } finally {
      this.connectionAttemptInProgress = !1;
    }
  }
  async restartTransport(t) {
    this.connectionAttemptInProgress || (this.relayUrl = t || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await mo()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(t) {
    if ((t == null ? void 0 : t.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const Me = t.sort((Ie, Pe) => Ie.publishedAt - Pe.publishedAt);
    this.logger.trace(`Batch of ${Me.length} message events sorted`);
    for (const Ie of Me) try {
      await this.onMessageEvent(Ie);
    } catch (Pe) {
      this.logger.warn(Pe);
    }
    this.logger.trace(`Batch of ${Me.length} message events processed`);
  }
  async onLinkMessageEvent(t, Me) {
    const { topic: Ie } = t;
    if (!Me.sessionExists) {
      const Pe = Mt$2(cjs$3.FIVE_MINUTES), Be = { topic: Ie, expiry: Pe, relay: { protocol: "irn" }, active: !1 };
      await this.core.pairing.pairings.set(Ie, Be);
    }
    this.events.emit(v$2.message, t), await this.recordMessageEvent(t);
  }
  startPingTimeout() {
    var t, Me, Ie, Pe, Be;
    if (ce$1()) try {
      (Me = (t = this.provider) == null ? void 0 : t.connection) != null && Me.socket && ((Be = (Pe = (Ie = this.provider) == null ? void 0 : Ie.connection) == null ? void 0 : Pe.socket) == null || Be.once("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (Te) {
      this.logger.warn(Te);
    }
  }
  isConnectionStalled(t) {
    return this.staleConnectionErrors.some((Me) => t.includes(Me));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const t = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o$1(new f$2($t$2({ sdkVersion: se$2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: t, useOnCloseEvent: !0, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(t) {
    const { topic: Me, message: Ie } = t;
    await this.messages.set(Me, Ie);
  }
  async shouldIgnoreMessageEvent(t) {
    const { topic: Me, message: Ie } = t;
    if (!Ie || Ie.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${Ie}`), !0;
    if (!await this.subscriber.isSubscribed(Me)) return this.logger.debug(`Ignoring message for non-subscribed topic ${Me}`), !0;
    const Pe = this.messages.has(Me, Ie);
    return Pe && this.logger.debug(`Ignoring duplicate message: ${Ie}`), Pe;
  }
  async onProviderPayload(t) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: t }), isJsonRpcRequest(t)) {
      if (!t.method.endsWith(at$2)) return;
      const Me = t.params, { topic: Ie, message: Pe, publishedAt: Be, attestation: Te } = Me.data, je = { topic: Ie, message: Pe, publishedAt: Be, transportType: M$1.relay, attestation: Te };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(ei({ type: "event", event: Me.id }, je)), this.events.emit(Me.id, je), await this.acknowledgePayload(t), await this.onMessageEvent(je);
    } else isJsonRpcResponse(t) && this.events.emit(v$2.message_ack, t);
  }
  async onMessageEvent(t) {
    await this.shouldIgnoreMessageEvent(t) || (this.events.emit(v$2.message, t), await this.recordMessageEvent(t));
  }
  async acknowledgePayload(t) {
    const Me = formatJsonRpcResult(t.id, !0);
    await this.provider.connection.send(Me);
  }
  unregisterProviderListeners() {
    this.provider.off(I$2.payload, this.onPayloadHandler), this.provider.off(I$2.connect, this.onConnectHandler), this.provider.off(I$2.disconnect, this.onDisconnectHandler), this.provider.off(I$2.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let t = await mo();
    ho(async (Me) => {
      t !== Me && (t = Me, Me ? await this.restartTransport().catch((Ie) => this.logger.error(Ie)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportDisconnect(), this.transportExplicitlyClosed = !1));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), this.requestsInFlight.clear(), clearTimeout(this.pingTimeout), this.events.emit(v$2.disconnect), this.connectionAttemptInProgress = !1, !this.transportExplicitlyClosed && (this.reconnectTimeout || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((t) => this.logger.error(t));
    }, cjs$3.toMiliseconds(ht$2))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (this.connectionAttemptInProgress && await new Promise((t) => {
      const Me = setInterval(() => {
        this.connected && (clearInterval(Me), t());
      }, this.connectionStatusPollingInterval);
    }), await this.transportOpen());
  }
}
var cn = Object.defineProperty, ii = Object.getOwnPropertySymbols, ln = Object.prototype.hasOwnProperty, un = Object.prototype.propertyIsEnumerable, si = (Ae, t, Me) => t in Ae ? cn(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Me }) : Ae[t] = Me, ri = (Ae, t) => {
  for (var Me in t || (t = {})) ln.call(t, Me) && si(Ae, Me, t[Me]);
  if (ii) for (var Me of ii(t)) un.call(t, Me) && si(Ae, Me, t[Me]);
  return Ae;
};
class ni extends p$1 {
  constructor(t, Me, Ie, Pe = x$3, Be = void 0) {
    super(t, Me, Ie, Pe), this.core = t, this.logger = Me, this.name = Ie, this.map = /* @__PURE__ */ new Map(), this.version = ct$2, this.cached = [], this.initialized = !1, this.storagePrefix = x$3, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((Te) => {
        this.getKey && Te !== null && !I$3(Te) ? this.map.set(this.getKey(Te), Te) : Yr$1(Te) ? this.map.set(Te.id, Te) : Qr$1(Te) && this.map.set(Te.topic, Te);
      }), this.cached = [], this.initialized = !0);
    }, this.set = async (Te, je) => {
      this.isInitialized(), this.map.has(Te) ? await this.update(Te, je) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: Te, value: je }), this.map.set(Te, je), await this.persist());
    }, this.get = (Te) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: Te }), this.getData(Te)), this.getAll = (Te) => (this.isInitialized(), Te ? this.values.filter((je) => Object.keys(Te).every((Ve) => ys$1(je[Ve], Te[Ve]))) : this.values), this.update = async (Te, je) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: Te, update: je });
      const Ve = ri(ri({}, this.getData(Te)), je);
      this.map.set(Te, Ve), await this.persist();
    }, this.delete = async (Te, je) => {
      this.isInitialized(), this.map.has(Te) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: Te, reason: je }), this.map.delete(Te), this.addToRecentlyDeleted(Te), await this.persist());
    }, this.logger = E$1(Me, this.name), this.storagePrefix = Pe, this.getKey = Be;
  }
  get context() {
    return y$3(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(t) {
    this.recentlyDeleted.push(t), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(t) {
    await this.core.storage.setItem(this.storageKey, t);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(t) {
    const Me = this.map.get(t);
    if (!Me) {
      if (this.recentlyDeleted.includes(t)) {
        const { message: Pe } = S$4("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${t}`);
        throw this.logger.error(Pe), new Error(Pe);
      }
      const { message: Ie } = S$4("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw this.logger.error(Ie), new Error(Ie);
    }
    return Me;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const t = await this.getDataStore();
      if (typeof t > "u" || !t.length) return;
      if (this.map.size) {
        const { message: Me } = S$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Me), new Error(Me);
      }
      this.cached = t, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(t);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class oi {
  constructor(t, Me) {
    this.core = t, this.logger = Me, this.name = gt$2, this.version = yt$2, this.events = new es(), this.initialized = !1, this.storagePrefix = x$3, this.ignoredPayloadTypes = [D$2], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
    }, this.register = ({ methods: Ie }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...Ie])];
    }, this.create = async (Ie) => {
      this.isInitialized();
      const Pe = pr$2(), Be = await this.core.crypto.setSymKey(Pe), Te = Mt$2(cjs$3.FIVE_MINUTES), je = { protocol: rt$2 }, Ve = { topic: Be, expiry: Te, relay: je, active: !1, methods: Ie == null ? void 0 : Ie.methods }, fi = Dr$2({ protocol: this.core.protocol, version: this.core.version, topic: Be, symKey: Pe, relay: je, expiryTimestamp: Te, methods: Ie == null ? void 0 : Ie.methods });
      return this.events.emit(V$2.create, Ve), this.core.expirer.set(Be, Te), await this.pairings.set(Be, Ve), await this.core.relayer.subscribe(Be, { transportType: Ie == null ? void 0 : Ie.transportType }), { topic: Be, uri: fi };
    }, this.pair = async (Ie) => {
      this.isInitialized();
      const Pe = this.core.eventClient.createEvent({ properties: { topic: Ie == null ? void 0 : Ie.uri, trace: [z$3.pairing_started] } });
      this.isValidPair(Ie, Pe);
      const { topic: Be, symKey: Te, relay: je, expiryTimestamp: Ve, methods: fi } = kr$1(Ie.uri);
      Pe.props.properties.topic = Be, Pe.addTrace(z$3.pairing_uri_validation_success), Pe.addTrace(z$3.pairing_uri_not_expired);
      let Ue;
      if (this.pairings.keys.includes(Be)) {
        if (Ue = this.pairings.get(Be), Pe.addTrace(z$3.existing_pairing), Ue.active) throw Pe.setError($$1.active_pairing_already_exists), new Error(`Pairing already exists: ${Be}. Please try again with a new connection URI.`);
        Pe.addTrace(z$3.pairing_not_expired);
      }
      const bi = Ve || Mt$2(cjs$3.FIVE_MINUTES), vi = { topic: Be, relay: je, expiry: bi, active: !1, methods: fi };
      this.core.expirer.set(Be, bi), await this.pairings.set(Be, vi), Pe.addTrace(z$3.store_new_pairing), Ie.activatePairing && await this.activate({ topic: Be }), this.events.emit(V$2.create, vi), Pe.addTrace(z$3.emit_inactive_pairing), this.core.crypto.keychain.has(Be) || await this.core.crypto.setSymKey(Te, Be), Pe.addTrace(z$3.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        Pe.setError($$1.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(Be, { relay: je });
      } catch (mi) {
        throw Pe.setError($$1.subscribe_pairing_topic_failure), mi;
      }
      return Pe.addTrace(z$3.subscribe_pairing_topic_success), vi;
    }, this.activate = async ({ topic: Ie }) => {
      this.isInitialized();
      const Pe = Mt$2(cjs$3.THIRTY_DAYS);
      this.core.expirer.set(Ie, Pe), await this.pairings.update(Ie, { active: !0, expiry: Pe });
    }, this.ping = async (Ie) => {
      this.isInitialized(), await this.isValidPing(Ie);
      const { topic: Pe } = Ie;
      if (this.pairings.keys.includes(Pe)) {
        const Be = await this.sendRequest(Pe, "wc_pairingPing", {}), { done: Te, resolve: je, reject: Ve } = _t$2();
        this.events.once(Lt$2("pairing_ping", Be), ({ error: fi }) => {
          fi ? Ve(fi) : je();
        }), await Te();
      }
    }, this.updateExpiry = async ({ topic: Ie, expiry: Pe }) => {
      this.isInitialized(), await this.pairings.update(Ie, { expiry: Pe });
    }, this.updateMetadata = async ({ topic: Ie, metadata: Pe }) => {
      this.isInitialized(), await this.pairings.update(Ie, { peerMetadata: Pe });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (Ie) => {
      this.isInitialized(), await this.isValidDisconnect(Ie);
      const { topic: Pe } = Ie;
      this.pairings.keys.includes(Pe) && (await this.sendRequest(Pe, "wc_pairingDelete", U$2("USER_DISCONNECTED")), await this.deletePairing(Pe));
    }, this.formatUriFromPairing = (Ie) => {
      this.isInitialized();
      const { topic: Pe, relay: Be, expiry: Te, methods: je } = Ie, Ve = this.core.crypto.keychain.get(Pe);
      return Dr$2({ protocol: this.core.protocol, version: this.core.version, topic: Pe, symKey: Ve, relay: Be, expiryTimestamp: Te, methods: je });
    }, this.sendRequest = async (Ie, Pe, Be) => {
      const Te = formatJsonRpcRequest(Pe, Be), je = await this.core.crypto.encode(Ie, Te), Ve = B$2[Pe].req;
      return this.core.history.set(Ie, Te), this.core.relayer.publish(Ie, je, Ve), Te.id;
    }, this.sendResult = async (Ie, Pe, Be) => {
      const Te = formatJsonRpcResult(Ie, Be), je = await this.core.crypto.encode(Pe, Te), Ve = await this.core.history.get(Pe, Ie), fi = B$2[Ve.request.method].res;
      await this.core.relayer.publish(Pe, je, fi), await this.core.history.resolve(Te);
    }, this.sendError = async (Ie, Pe, Be) => {
      const Te = formatJsonRpcError(Ie, Be), je = await this.core.crypto.encode(Pe, Te), Ve = await this.core.history.get(Pe, Ie), fi = B$2[Ve.request.method] ? B$2[Ve.request.method].res : B$2.unregistered_method.res;
      await this.core.relayer.publish(Pe, je, fi), await this.core.history.resolve(Te);
    }, this.deletePairing = async (Ie, Pe) => {
      await this.core.relayer.unsubscribe(Ie), await Promise.all([this.pairings.delete(Ie, U$2("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(Ie), Pe ? Promise.resolve() : this.core.expirer.del(Ie)]);
    }, this.cleanup = async () => {
      const Ie = this.pairings.getAll().filter((Pe) => Kt$2(Pe.expiry));
      await Promise.all(Ie.map((Pe) => this.deletePairing(Pe.topic)));
    }, this.onRelayEventRequest = (Ie) => {
      const { topic: Pe, payload: Be } = Ie;
      switch (Be.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(Pe, Be);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(Pe, Be);
        default:
          return this.onUnknownRpcMethodRequest(Pe, Be);
      }
    }, this.onRelayEventResponse = async (Ie) => {
      const { topic: Pe, payload: Be } = Ie, Te = (await this.core.history.get(Pe, Be.id)).request.method;
      switch (Te) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(Pe, Be);
        default:
          return this.onUnknownRpcMethodResponse(Te);
      }
    }, this.onPairingPingRequest = async (Ie, Pe) => {
      const { id: Be } = Pe;
      try {
        this.isValidPing({ topic: Ie }), await this.sendResult(Be, Ie, !0), this.events.emit(V$2.ping, { id: Be, topic: Ie });
      } catch (Te) {
        await this.sendError(Be, Ie, Te), this.logger.error(Te);
      }
    }, this.onPairingPingResponse = (Ie, Pe) => {
      const { id: Be } = Pe;
      setTimeout(() => {
        isJsonRpcResult(Pe) ? this.events.emit(Lt$2("pairing_ping", Be), {}) : isJsonRpcError(Pe) && this.events.emit(Lt$2("pairing_ping", Be), { error: Pe.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (Ie, Pe) => {
      const { id: Be } = Pe;
      try {
        this.isValidDisconnect({ topic: Ie }), await this.deletePairing(Ie), this.events.emit(V$2.delete, { id: Be, topic: Ie });
      } catch (Te) {
        await this.sendError(Be, Ie, Te), this.logger.error(Te);
      }
    }, this.onUnknownRpcMethodRequest = async (Ie, Pe) => {
      const { id: Be, method: Te } = Pe;
      try {
        if (this.registeredMethods.includes(Te)) return;
        const je = U$2("WC_METHOD_UNSUPPORTED", Te);
        await this.sendError(Be, Ie, je), this.logger.error(je);
      } catch (je) {
        await this.sendError(Be, Ie, je), this.logger.error(je);
      }
    }, this.onUnknownRpcMethodResponse = (Ie) => {
      this.registeredMethods.includes(Ie) || this.logger.error(U$2("WC_METHOD_UNSUPPORTED", Ie));
    }, this.isValidPair = (Ie, Pe) => {
      var Be;
      if (!to(Ie)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `pair() params: ${Ie}`);
        throw Pe.setError($$1.malformed_pairing_uri), new Error(je);
      }
      if (!Gr$1(Ie.uri)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `pair() uri: ${Ie.uri}`);
        throw Pe.setError($$1.malformed_pairing_uri), new Error(je);
      }
      const Te = kr$1(Ie == null ? void 0 : Ie.uri);
      if (!((Be = Te == null ? void 0 : Te.relay) != null && Be.protocol)) {
        const { message: je } = S$4("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw Pe.setError($$1.malformed_pairing_uri), new Error(je);
      }
      if (!(Te != null && Te.symKey)) {
        const { message: je } = S$4("MISSING_OR_INVALID", "pair() uri#symKey");
        throw Pe.setError($$1.malformed_pairing_uri), new Error(je);
      }
      if (Te != null && Te.expiryTimestamp && cjs$3.toMiliseconds(Te == null ? void 0 : Te.expiryTimestamp) < Date.now()) {
        Pe.setError($$1.pairing_expired);
        const { message: je } = S$4("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(je);
      }
    }, this.isValidPing = async (Ie) => {
      if (!to(Ie)) {
        const { message: Be } = S$4("MISSING_OR_INVALID", `ping() params: ${Ie}`);
        throw new Error(Be);
      }
      const { topic: Pe } = Ie;
      await this.isValidPairingTopic(Pe);
    }, this.isValidDisconnect = async (Ie) => {
      if (!to(Ie)) {
        const { message: Be } = S$4("MISSING_OR_INVALID", `disconnect() params: ${Ie}`);
        throw new Error(Be);
      }
      const { topic: Pe } = Ie;
      await this.isValidPairingTopic(Pe);
    }, this.isValidPairingTopic = async (Ie) => {
      if (!b$2(Ie, !1)) {
        const { message: Pe } = S$4("MISSING_OR_INVALID", `pairing topic should be a string: ${Ie}`);
        throw new Error(Pe);
      }
      if (!this.pairings.keys.includes(Ie)) {
        const { message: Pe } = S$4("NO_MATCHING_KEY", `pairing topic doesn't exist: ${Ie}`);
        throw new Error(Pe);
      }
      if (Kt$2(this.pairings.get(Ie).expiry)) {
        await this.deletePairing(Ie);
        const { message: Pe } = S$4("EXPIRED", `pairing topic: ${Ie}`);
        throw new Error(Pe);
      }
    }, this.core = t, this.logger = E$1(Me, this.name), this.pairings = new ni(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y$3(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(v$2.message, async (t) => {
      const { topic: Me, message: Ie, transportType: Pe } = t;
      if (!this.pairings.keys.includes(Me) || Pe === M$1.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(Ie))) return;
      const Be = await this.core.crypto.decode(Me, Ie);
      try {
        isJsonRpcRequest(Be) ? (this.core.history.set(Me, Be), this.onRelayEventRequest({ topic: Me, payload: Be })) : isJsonRpcResponse(Be) && (await this.core.history.resolve(Be), await this.onRelayEventResponse({ topic: Me, payload: Be }), this.core.history.delete(Me, Be.id));
      } catch (Te) {
        this.logger.error(Te);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(S$2.expired, async (t) => {
      const { topic: Me } = Vt$2(t.target);
      Me && this.pairings.keys.includes(Me) && (await this.deletePairing(Me, !0), this.events.emit(V$2.expire, { topic: Me }));
    });
  }
}
class ai extends h$1 {
  constructor(t, Me) {
    super(t, Me), this.core = t, this.logger = Me, this.records = /* @__PURE__ */ new Map(), this.events = new eventsExports.EventEmitter(), this.name = Dt$1, this.version = mt$1, this.cached = [], this.initialized = !1, this.storagePrefix = x$3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((Ie) => this.records.set(Ie.id, Ie)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.set = (Ie, Pe, Be) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: Ie, request: Pe, chainId: Be }), this.records.has(Pe.id)) return;
      const Te = { id: Pe.id, topic: Ie, request: { method: Pe.method, params: Pe.params || null }, chainId: Be, expiry: Mt$2(cjs$3.THIRTY_DAYS) };
      this.records.set(Te.id, Te), this.persist(), this.events.emit(P$1.created, Te);
    }, this.resolve = async (Ie) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: Ie }), !this.records.has(Ie.id)) return;
      const Pe = await this.getRecord(Ie.id);
      typeof Pe.response > "u" && (Pe.response = isJsonRpcError(Ie) ? { error: Ie.error } : { result: Ie.result }, this.records.set(Pe.id, Pe), this.persist(), this.events.emit(P$1.updated, Pe));
    }, this.get = async (Ie, Pe) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: Ie, id: Pe }), await this.getRecord(Pe)), this.delete = (Ie, Pe) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: Pe }), this.values.forEach((Be) => {
        if (Be.topic === Ie) {
          if (typeof Pe < "u" && Be.id !== Pe) return;
          this.records.delete(Be.id), this.events.emit(P$1.deleted, Be);
        }
      }), this.persist();
    }, this.exists = async (Ie, Pe) => (this.isInitialized(), this.records.has(Pe) ? (await this.getRecord(Pe)).topic === Ie : !1), this.on = (Ie, Pe) => {
      this.events.on(Ie, Pe);
    }, this.once = (Ie, Pe) => {
      this.events.once(Ie, Pe);
    }, this.off = (Ie, Pe) => {
      this.events.off(Ie, Pe);
    }, this.removeListener = (Ie, Pe) => {
      this.events.removeListener(Ie, Pe);
    }, this.logger = E$1(Me, this.name);
  }
  get context() {
    return y$3(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const t = [];
    return this.values.forEach((Me) => {
      if (typeof Me.response < "u") return;
      const Ie = { topic: Me.topic, request: formatJsonRpcRequest(Me.request.method, Me.request.params, Me.id), chainId: Me.chainId };
      return t.push(Ie);
    }), t;
  }
  async setJsonRpcRecords(t) {
    await this.core.storage.setItem(this.storageKey, t);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(t) {
    this.isInitialized();
    const Me = this.records.get(t);
    if (!Me) {
      const { message: Ie } = S$4("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw new Error(Ie);
    }
    return Me;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(P$1.sync);
  }
  async restore() {
    try {
      const t = await this.getJsonRpcRecords();
      if (typeof t > "u" || !t.length) return;
      if (this.records.size) {
        const { message: Me } = S$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Me), new Error(Me);
      }
      this.cached = t, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(t);
    }
  }
  registerEventListeners() {
    this.events.on(P$1.created, (t) => {
      const Me = P$1.created;
      this.logger.info(`Emitting ${Me}`), this.logger.debug({ type: "event", event: Me, record: t });
    }), this.events.on(P$1.updated, (t) => {
      const Me = P$1.updated;
      this.logger.info(`Emitting ${Me}`), this.logger.debug({ type: "event", event: Me, record: t });
    }), this.events.on(P$1.deleted, (t) => {
      const Me = P$1.deleted;
      this.logger.info(`Emitting ${Me}`), this.logger.debug({ type: "event", event: Me, record: t });
    }), this.core.heartbeat.on(r$1.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let t = !1;
      this.records.forEach((Me) => {
        cjs$3.toMiliseconds(Me.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${Me.id}`), this.records.delete(Me.id), this.events.emit(P$1.deleted, Me, !1), t = !0);
      }), t && this.persist();
    } catch (t) {
      this.logger.warn(t);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class hi extends x$4 {
  constructor(t, Me) {
    super(t, Me), this.core = t, this.logger = Me, this.expirations = /* @__PURE__ */ new Map(), this.events = new eventsExports.EventEmitter(), this.name = bt$1, this.version = ft$1, this.cached = [], this.initialized = !1, this.storagePrefix = x$3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((Ie) => this.expirations.set(Ie.target, Ie)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.has = (Ie) => {
      try {
        const Pe = this.formatTarget(Ie);
        return typeof this.getExpiration(Pe) < "u";
      } catch {
        return !1;
      }
    }, this.set = (Ie, Pe) => {
      this.isInitialized();
      const Be = this.formatTarget(Ie), Te = { target: Be, expiry: Pe };
      this.expirations.set(Be, Te), this.checkExpiry(Be, Te), this.events.emit(S$2.created, { target: Be, expiration: Te });
    }, this.get = (Ie) => {
      this.isInitialized();
      const Pe = this.formatTarget(Ie);
      return this.getExpiration(Pe);
    }, this.del = (Ie) => {
      if (this.isInitialized(), this.has(Ie)) {
        const Pe = this.formatTarget(Ie), Be = this.getExpiration(Pe);
        this.expirations.delete(Pe), this.events.emit(S$2.deleted, { target: Pe, expiration: Be });
      }
    }, this.on = (Ie, Pe) => {
      this.events.on(Ie, Pe);
    }, this.once = (Ie, Pe) => {
      this.events.once(Ie, Pe);
    }, this.off = (Ie, Pe) => {
      this.events.off(Ie, Pe);
    }, this.removeListener = (Ie, Pe) => {
      this.events.removeListener(Ie, Pe);
    }, this.logger = E$1(Me, this.name);
  }
  get context() {
    return y$3(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(t) {
    if (typeof t == "string") return Dt$2(t);
    if (typeof t == "number") return xt$2(t);
    const { message: Me } = S$4("UNKNOWN_TYPE", `Target type: ${typeof t}`);
    throw new Error(Me);
  }
  async setExpirations(t) {
    await this.core.storage.setItem(this.storageKey, t);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(S$2.sync);
  }
  async restore() {
    try {
      const t = await this.getExpirations();
      if (typeof t > "u" || !t.length) return;
      if (this.expirations.size) {
        const { message: Me } = S$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Me), new Error(Me);
      }
      this.cached = t, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(t);
    }
  }
  getExpiration(t) {
    const Me = this.expirations.get(t);
    if (!Me) {
      const { message: Ie } = S$4("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw this.logger.warn(Ie), new Error(Ie);
    }
    return Me;
  }
  checkExpiry(t, Me) {
    const { expiry: Ie } = Me;
    cjs$3.toMiliseconds(Ie) - Date.now() <= 0 && this.expire(t, Me);
  }
  expire(t, Me) {
    this.expirations.delete(t), this.events.emit(S$2.expired, { target: t, expiration: Me });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((t, Me) => this.checkExpiry(Me, t));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r$1.pulse, () => this.checkExpirations()), this.events.on(S$2.created, (t) => {
      const Me = S$2.created;
      this.logger.info(`Emitting ${Me}`), this.logger.debug({ type: "event", event: Me, data: t }), this.persist();
    }), this.events.on(S$2.expired, (t) => {
      const Me = S$2.expired;
      this.logger.info(`Emitting ${Me}`), this.logger.debug({ type: "event", event: Me, data: t }), this.persist();
    }), this.events.on(S$2.deleted, (t) => {
      const Me = S$2.deleted;
      this.logger.info(`Emitting ${Me}`), this.logger.debug({ type: "event", event: Me, data: t }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class ci extends y$2 {
  constructor(t, Me, Ie) {
    super(t, Me, Ie), this.core = t, this.logger = Me, this.store = Ie, this.name = _t$1, this.verifyUrlV3 = vt$1, this.storagePrefix = x$3, this.version = De$1, this.init = async () => {
      var Pe;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && cjs$3.toMiliseconds((Pe = this.publicKey) == null ? void 0 : Pe.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }, this.register = async (Pe) => {
      if (!V$3() || this.isDevEnv) return;
      const Be = window.location.origin, { id: Te, decryptedId: je } = Pe, Ve = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${Be}&id=${Te}&decryptedId=${je}`;
      try {
        const fi = getDocument_1(), Ue = this.startAbortTimer(cjs$3.ONE_SECOND * 5), bi = await new Promise((vi, mi) => {
          const _i = () => {
            window.removeEventListener("message", Ci), fi.body.removeChild($i), mi("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", _i);
          const $i = fi.createElement("iframe");
          $i.src = Ve, $i.style.display = "none", $i.addEventListener("error", _i, { signal: this.abortController.signal });
          const Ci = (Ui) => {
            if (Ui.data && typeof Ui.data == "string") try {
              const ki = JSON.parse(Ui.data);
              if (ki.type === "verify_attestation") {
                if (decodeJWT(ki.attestation).payload.id !== Te) return;
                clearInterval(Ue), fi.body.removeChild($i), this.abortController.signal.removeEventListener("abort", _i), window.removeEventListener("message", Ci), vi(ki.attestation === null ? "" : ki.attestation);
              }
            } catch (ki) {
              this.logger.warn(ki);
            }
          };
          fi.body.appendChild($i), window.addEventListener("message", Ci, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", bi), bi;
      } catch (fi) {
        this.logger.warn(fi);
      }
      return "";
    }, this.resolve = async (Pe) => {
      if (this.isDevEnv) return "";
      const { attestationId: Be, hash: Te, encryptedId: je } = Pe;
      if (Be === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (Be) {
        if (decodeJWT(Be).payload.id !== je) return;
        const fi = await this.isValidJwtAttestation(Be);
        if (fi) {
          if (!fi.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return fi;
        }
      }
      if (!Te) return;
      const Ve = this.getVerifyUrl(Pe == null ? void 0 : Pe.verifyUrl);
      return this.fetchAttestation(Te, Ve);
    }, this.fetchAttestation = async (Pe, Be) => {
      this.logger.debug(`resolving attestation: ${Pe} from url: ${Be}`);
      const Te = this.startAbortTimer(cjs$3.ONE_SECOND * 5), je = await fetch(`${Be}/attestation/${Pe}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(Te), je.status === 200 ? await je.json() : void 0;
    }, this.getVerifyUrl = (Pe) => {
      let Be = Pe || J$1;
      return wt$1.includes(Be) || (this.logger.info(`verify url: ${Be}, not included in trusted list, assigning default: ${J$1}`), Be = J$1), Be;
    }, this.fetchPublicKey = async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const Pe = this.startAbortTimer(cjs$3.FIVE_SECONDS), Be = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(Pe), await Be.json();
      } catch (Pe) {
        this.logger.warn(Pe);
      }
    }, this.persistPublicKey = async (Pe) => {
      this.logger.debug("persisting public key to local storage", Pe), await this.store.setItem(this.storeKey, Pe), this.publicKey = Pe;
    }, this.removePublicKey = async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }, this.isValidJwtAttestation = async (Pe) => {
      const Be = await this.getPublicKey();
      try {
        if (Be) return this.validateAttestation(Pe, Be);
      } catch (je) {
        this.logger.error(je), this.logger.warn("error validating attestation");
      }
      const Te = await this.fetchAndPersistPublicKey();
      try {
        if (Te) return this.validateAttestation(Pe, Te);
      } catch (je) {
        this.logger.error(je), this.logger.warn("error validating attestation");
      }
    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (Be) => {
        const Te = await this.fetchPublicKey();
        Te && (await this.persistPublicKey(Te), Be(Te));
      });
      const Pe = await this.fetchPromise;
      return this.fetchPromise = void 0, Pe;
    }, this.validateAttestation = (Pe, Be) => {
      const Te = Rr$2(Pe, Be.publicKey), je = { hasExpired: cjs$3.toMiliseconds(Te.exp) < Date.now(), payload: Te };
      if (je.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: je.payload.origin, isScam: je.payload.isScam, isVerified: je.payload.isVerified };
    }, this.logger = E$1(Me, this.name), this.abortController = new AbortController(), this.isDevEnv = Wt$2(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y$3(this.logger);
  }
  startAbortTimer(t) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), cjs$3.toMiliseconds(t));
  }
}
class li extends v$3 {
  constructor(t, Me) {
    super(t, Me), this.projectId = t, this.logger = Me, this.context = It$1, this.registerDeviceToken = async (Ie) => {
      const { clientId: Pe, token: Be, notificationType: Te, enableEncrypted: je = !1 } = Ie, Ve = `${Tt$1}/${this.projectId}/clients`;
      await fetch(Ve, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: Pe, type: Te, token: Be, always_raw: je }) });
    }, this.logger = E$1(Me, this.context);
  }
}
var dn = Object.defineProperty, ui = Object.getOwnPropertySymbols, pn = Object.prototype.hasOwnProperty, gn = Object.prototype.propertyIsEnumerable, di = (Ae, t, Me) => t in Ae ? dn(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Me }) : Ae[t] = Me, Z$2 = (Ae, t) => {
  for (var Me in t || (t = {})) pn.call(t, Me) && di(Ae, Me, t[Me]);
  if (ui) for (var Me of ui(t)) gn.call(t, Me) && di(Ae, Me, t[Me]);
  return Ae;
};
class pi extends C$3 {
  constructor(t, Me, Ie = !0) {
    super(t, Me, Ie), this.core = t, this.logger = Me, this.context = Pt$1, this.storagePrefix = x$3, this.storageVersion = Ct$1, this.events = /* @__PURE__ */ new Map(), this.shouldPersist = !1, this.init = async () => {
      if (!Wt$2()) try {
        const Pe = { eventId: Ht$2(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Ge(this.core.relayer.protocol, this.core.relayer.version, se$2) } } };
        await this.sendEvent([Pe]);
      } catch (Pe) {
        this.logger.warn(Pe);
      }
    }, this.createEvent = (Pe) => {
      const { event: Be = "ERROR", type: Te = "", properties: { topic: je, trace: Ve } } = Pe, fi = Ht$2(), Ue = this.core.projectId || "", bi = Date.now(), vi = Z$2({ eventId: fi, timestamp: bi, props: { event: Be, type: Te, properties: { topic: je, trace: Ve } }, bundleId: Ue, domain: this.getAppDomain() }, this.setMethods(fi));
      return this.telemetryEnabled && (this.events.set(fi, vi), this.shouldPersist = !0), vi;
    }, this.getEvent = (Pe) => {
      const { eventId: Be, topic: Te } = Pe;
      if (Be) return this.events.get(Be);
      const je = Array.from(this.events.values()).find((Ve) => Ve.props.properties.topic === Te);
      if (je) return Z$2(Z$2({}, je), this.setMethods(je.eventId));
    }, this.deleteEvent = (Pe) => {
      const { eventId: Be } = Pe;
      this.events.delete(Be), this.shouldPersist = !0;
    }, this.setEventListeners = () => {
      this.core.heartbeat.on(r$1.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((Pe) => {
          cjs$3.fromMiliseconds(Date.now()) - cjs$3.fromMiliseconds(Pe.timestamp) > St$1 && (this.events.delete(Pe.eventId), this.shouldPersist = !0);
        });
      });
    }, this.setMethods = (Pe) => ({ addTrace: (Be) => this.addTrace(Pe, Be), setError: (Be) => this.setError(Pe, Be) }), this.addTrace = (Pe, Be) => {
      const Te = this.events.get(Pe);
      Te && (Te.props.properties.trace.push(Be), this.events.set(Pe, Te), this.shouldPersist = !0);
    }, this.setError = (Pe, Be) => {
      const Te = this.events.get(Pe);
      Te && (Te.props.type = Be, Te.timestamp = Date.now(), this.events.set(Pe, Te), this.shouldPersist = !0);
    }, this.persist = async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = !1;
    }, this.restore = async () => {
      try {
        const Pe = await this.core.storage.getItem(this.storageKey) || [];
        if (!Pe.length) return;
        Pe.forEach((Be) => {
          this.events.set(Be.eventId, Z$2(Z$2({}, Be), this.setMethods(Be.eventId)));
        });
      } catch (Pe) {
        this.logger.warn(Pe);
      }
    }, this.submit = async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const Pe = [];
      for (const [Be, Te] of this.events) Te.props.type && Pe.push(Te);
      if (Pe.length !== 0) try {
        if ((await this.sendEvent(Pe)).ok) for (const Be of Pe) this.events.delete(Be.eventId), this.shouldPersist = !0;
      } catch (Be) {
        this.logger.warn(Be);
      }
    }, this.sendEvent = async (Pe) => {
      const Be = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${Rt$1}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${se$2}${Be}`, { method: "POST", body: JSON.stringify(Pe) });
    }, this.getAppDomain = () => Nt$2().url, this.logger = E$1(Me, this.context), this.telemetryEnabled = Ie, Ie ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
}
var yn = Object.defineProperty, gi = Object.getOwnPropertySymbols, Dn = Object.prototype.hasOwnProperty, mn = Object.prototype.propertyIsEnumerable, yi = (Ae, t, Me) => t in Ae ? yn(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Me }) : Ae[t] = Me, Di = (Ae, t) => {
  for (var Me in t || (t = {})) Dn.call(t, Me) && yi(Ae, Me, t[Me]);
  if (gi) for (var Me of gi(t)) mn.call(t, Me) && yi(Ae, Me, t[Me]);
  return Ae;
};
let ne$2 = class rf extends n$1 {
  constructor(t) {
    var Me;
    super(t), this.protocol = ye$2, this.version = De$1, this.name = ie$2, this.events = new eventsExports.EventEmitter(), this.initialized = !1, this.on = (Te, je) => this.events.on(Te, je), this.once = (Te, je) => this.events.once(Te, je), this.off = (Te, je) => this.events.off(Te, je), this.removeListener = (Te, je) => this.events.removeListener(Te, je), this.dispatchEnvelope = ({ topic: Te, message: je, sessionExists: Ve }) => {
      if (!Te || !je) return;
      const fi = { topic: Te, message: je, publishedAt: Date.now(), transportType: M$1.link_mode };
      this.relayer.onLinkMessageEvent(fi, { sessionExists: Ve });
    }, this.projectId = t == null ? void 0 : t.projectId, this.relayUrl = (t == null ? void 0 : t.relayUrl) || be$2, this.customStoragePrefix = t != null && t.customStoragePrefix ? `:${t.customStoragePrefix}` : "";
    const Ie = k$2({ level: typeof (t == null ? void 0 : t.logger) == "string" && t.logger ? t.logger : Ye.logger }), { logger: Pe, chunkLoggerController: Be } = A$1({ opts: Ie, maxSizeInBytes: t == null ? void 0 : t.maxLogBlobSizeInBytes, loggerOverride: t == null ? void 0 : t.logger });
    this.logChunkController = Be, (Me = this.logChunkController) != null && Me.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var Te, je;
      (Te = this.logChunkController) != null && Te.downloadLogsBlobInBrowser && ((je = this.logChunkController) == null || je.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E$1(Pe, this.name), this.heartbeat = new i$1(), this.crypto = new Ht$1(this, this.logger, t == null ? void 0 : t.keychain), this.history = new ai(this, this.logger), this.expirer = new hi(this, this.logger), this.storage = t != null && t.storage ? t.storage : new h$2(Di(Di({}, Je), t == null ? void 0 : t.storageOptions)), this.relayer = new ti({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new oi(this, this.logger), this.verify = new ci(this, this.logger, this.storage), this.echoClient = new li(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new pi(this, this.logger, t == null ? void 0 : t.telemetryEnabled);
  }
  static async init(t) {
    const Me = new rf(t);
    await Me.initialize();
    const Ie = await Me.crypto.getClientId();
    return await Me.storage.setItem(lt$2, Ie), Me;
  }
  get context() {
    return y$3(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var t;
    return (t = this.logChunkController) == null ? void 0 : t.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(t) {
    this.linkModeSupportedApps.includes(t) || (this.linkModeSupportedApps.push(t), await this.storage.setItem(fe$1, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.eventClient.init(), this.linkModeSupportedApps = await this.storage.getItem(fe$1) || [], this.initialized = !0, this.logger.info("Core Initialization Success");
    } catch (t) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, t), this.logger.error(t.message), t;
    }
  }
};
const bn = ne$2;
function unfetch_module(Ae, t) {
  return t = t || {}, new Promise(function(Me, Ie) {
    var Pe = new XMLHttpRequest(), Be = [], Te = [], je = {}, Ve = function() {
      return { ok: (Pe.status / 100 | 0) == 2, statusText: Pe.statusText, status: Pe.status, url: Pe.responseURL, text: function() {
        return Promise.resolve(Pe.responseText);
      }, json: function() {
        return Promise.resolve(Pe.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([Pe.response]));
      }, clone: Ve, headers: { keys: function() {
        return Be;
      }, entries: function() {
        return Te;
      }, get: function(Ue) {
        return je[Ue.toLowerCase()];
      }, has: function(Ue) {
        return Ue.toLowerCase() in je;
      } } };
    };
    for (var fi in Pe.open(t.method || "get", Ae, !0), Pe.onload = function() {
      Pe.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(Ue, bi, vi) {
        Be.push(bi = bi.toLowerCase()), Te.push([bi, vi]), je[bi] = je[bi] ? je[bi] + "," + vi : vi;
      }), Me(Ve());
    }, Pe.onerror = Ie, Pe.withCredentials = t.credentials == "include", t.headers) Pe.setRequestHeader(fi, t.headers[fi]);
    Pe.send(t.body || null);
  });
}
const unfetch_module$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: unfetch_module
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(unfetch_module$1);
var browser = self.fetch || (self.fetch = require$$0.default || require$$0);
const ke = /* @__PURE__ */ getDefaultExportFromCjs(browser);
class G {
  constructor(t) {
    this.client = t;
  }
}
class H {
  constructor(t) {
    this.opts = t;
  }
}
const Y$1 = "https://rpc.walletconnect.com/v1", R$1 = { wc_authRequest: { req: { ttl: cjs$3.ONE_DAY, prompt: !0, tag: 3e3 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 3001 } } }, U$1 = { min: cjs$3.FIVE_MINUTES, max: cjs$3.SEVEN_DAYS }, $ = "wc", Q = 1, Z$1 = "auth", B$1 = "authClient", F$1 = `${$}@1:${Z$1}:`, x$2 = `${F$1}:PUB_KEY`;
function z$2(Ae) {
  return Ae == null ? void 0 : Ae.split(":");
}
function Ze(Ae) {
  const t = Ae && z$2(Ae);
  if (t) return t[3];
}
function We(Ae) {
  const t = Ae && z$2(Ae);
  if (t) return t[2] + ":" + t[3];
}
function W(Ae) {
  const t = Ae && z$2(Ae);
  if (t) return t.pop();
}
async function et(Ae, t, Me, Ie, Pe) {
  switch (Me.t) {
    case "eip191":
      return tt(Ae, t, Me.s);
    case "eip1271":
      return await rt$1(Ae, t, Me.s, Ie, Pe);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${Me.t}`);
  }
}
function tt(Ae, t, Me) {
  return recoverAddress(hashMessage(t), Me).toLowerCase() === Ae.toLowerCase();
}
async function rt$1(Ae, t, Me, Ie, Pe) {
  try {
    const Be = "0x1626ba7e", Te = "0000000000000000000000000000000000000000000000000000000000000040", je = "0000000000000000000000000000000000000000000000000000000000000041", Ve = Me.substring(2), fi = hashMessage(t).substring(2), Ue = Be + fi + Te + je + Ve, bi = await ke(`${Y$1}/?chainId=${Ie}&projectId=${Pe}`, { method: "POST", body: JSON.stringify({ id: it$1(), jsonrpc: "2.0", method: "eth_call", params: [{ to: Ae, data: Ue }, "latest"] }) }), { result: vi } = await bi.json();
    return vi ? vi.slice(0, Be.length).toLowerCase() === Be.toLowerCase() : !1;
  } catch (Be) {
    return console.error("isValidEip1271Signature: ", Be), !1;
  }
}
function it$1() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function ee$1(Ae) {
  return Ae.getAll().filter((t) => "requester" in t);
}
function te$1(Ae, t) {
  return ee$1(Ae).find((Me) => Me.id === t);
}
function nt$1(Ae) {
  const t = Gr$1(Ae.aud), Me = new RegExp(`${Ae.domain}`).test(Ae.aud), Ie = !!Ae.nonce, Pe = Ae.type ? Ae.type === "eip4361" : !0, Be = Ae.expiry;
  if (Be && !po(Be, U$1)) {
    const { message: Te } = S$4("MISSING_OR_INVALID", `request() expiry: ${Be}. Expiry must be a number (in seconds) between ${U$1.min} and ${U$1.max}`);
    throw new Error(Te);
  }
  return !!(t && Me && Ie && Pe);
}
function st$1(Ae, t) {
  return !!te$1(t, Ae.id);
}
function ot$1(Ae = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(Ae) : new Uint8Array(Ae);
}
function ut$1(Ae, t) {
  if (Ae.length >= 255) throw new TypeError("Alphabet too long");
  for (var Me = new Uint8Array(256), Ie = 0; Ie < Me.length; Ie++) Me[Ie] = 255;
  for (var Pe = 0; Pe < Ae.length; Pe++) {
    var Be = Ae.charAt(Pe), Te = Be.charCodeAt(0);
    if (Me[Te] !== 255) throw new TypeError(Be + " is ambiguous");
    Me[Te] = Pe;
  }
  var je = Ae.length, Ve = Ae.charAt(0), fi = Math.log(je) / Math.log(256), Ue = Math.log(256) / Math.log(je);
  function bi(_i) {
    if (_i instanceof Uint8Array || (ArrayBuffer.isView(_i) ? _i = new Uint8Array(_i.buffer, _i.byteOffset, _i.byteLength) : Array.isArray(_i) && (_i = Uint8Array.from(_i))), !(_i instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (_i.length === 0) return "";
    for (var $i = 0, Ci = 0, Ui = 0, ki = _i.length; Ui !== ki && _i[Ui] === 0; ) Ui++, $i++;
    for (var Ji = (ki - Ui) * Ue + 1 >>> 0, Hi = new Uint8Array(Ji); Ui !== ki; ) {
      for (var Zi = _i[Ui], Qi = 0, Bi = Ji - 1; (Zi !== 0 || Qi < Ci) && Bi !== -1; Bi--, Qi++) Zi += 256 * Hi[Bi] >>> 0, Hi[Bi] = Zi % je >>> 0, Zi = Zi / je >>> 0;
      if (Zi !== 0) throw new Error("Non-zero carry");
      Ci = Qi, Ui++;
    }
    for (var Xi = Ji - Ci; Xi !== Ji && Hi[Xi] === 0; ) Xi++;
    for (var ns = Ve.repeat($i); Xi < Ji; ++Xi) ns += Ae.charAt(Hi[Xi]);
    return ns;
  }
  function vi(_i) {
    if (typeof _i != "string") throw new TypeError("Expected String");
    if (_i.length === 0) return new Uint8Array();
    var $i = 0;
    if (_i[$i] !== " ") {
      for (var Ci = 0, Ui = 0; _i[$i] === Ve; ) Ci++, $i++;
      for (var ki = (_i.length - $i) * fi + 1 >>> 0, Ji = new Uint8Array(ki); _i[$i]; ) {
        var Hi = Me[_i.charCodeAt($i)];
        if (Hi === 255) return;
        for (var Zi = 0, Qi = ki - 1; (Hi !== 0 || Zi < Ui) && Qi !== -1; Qi--, Zi++) Hi += je * Ji[Qi] >>> 0, Ji[Qi] = Hi % 256 >>> 0, Hi = Hi / 256 >>> 0;
        if (Hi !== 0) throw new Error("Non-zero carry");
        Ui = Zi, $i++;
      }
      if (_i[$i] !== " ") {
        for (var Bi = ki - Ui; Bi !== ki && Ji[Bi] === 0; ) Bi++;
        for (var Xi = new Uint8Array(Ci + (ki - Bi)), ns = Ci; Bi !== ki; ) Xi[ns++] = Ji[Bi++];
        return Xi;
      }
    }
  }
  function mi(_i) {
    var $i = vi(_i);
    if ($i) return $i;
    throw new Error(`Non-${t} character`);
  }
  return { encode: bi, decodeUnsafe: vi, decode: mi };
}
var at$1 = ut$1, Dt = at$1;
const re = (Ae) => {
  if (Ae instanceof Uint8Array && Ae.constructor.name === "Uint8Array") return Ae;
  if (Ae instanceof ArrayBuffer) return new Uint8Array(Ae);
  if (ArrayBuffer.isView(Ae)) return new Uint8Array(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  throw new Error("Unknown type, must be binary type");
}, ct$1 = (Ae) => new TextEncoder().encode(Ae), ht$1 = (Ae) => new TextDecoder().decode(Ae);
let lt$1 = class {
  constructor(t, Me, Ie) {
    this.name = t, this.prefix = Me, this.baseEncode = Ie;
  }
  encode(t) {
    if (t instanceof Uint8Array) return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
}, dt$1 = class {
  constructor(t, Me, Ie) {
    if (this.name = t, this.prefix = Me, Me.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = Me.codePointAt(0), this.baseDecode = Ie;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(t) {
    return ie$1(this, t);
  }
}, pt$1 = class {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return ie$1(this, t);
  }
  decode(t) {
    const Me = t[0], Ie = this.decoders[Me];
    if (Ie) return Ie.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
const ie$1 = (Ae, t) => new pt$1({ ...Ae.decoders || { [Ae.prefix]: Ae }, ...t.decoders || { [t.prefix]: t } });
class ft {
  constructor(t, Me, Ie, Pe) {
    this.name = t, this.prefix = Me, this.baseEncode = Ie, this.baseDecode = Pe, this.encoder = new lt$1(t, Me, Ie), this.decoder = new dt$1(t, Me, Pe);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
}
const O$1 = ({ name: Ae, prefix: t, encode: Me, decode: Ie }) => new ft(Ae, t, Me, Ie), T$1 = ({ prefix: Ae, name: t, alphabet: Me }) => {
  const { encode: Ie, decode: Pe } = Dt(Me, t);
  return O$1({ prefix: Ae, name: t, encode: Ie, decode: (Be) => re(Pe(Be)) });
}, gt$1 = (Ae, t, Me, Ie) => {
  const Pe = {};
  for (let Ue = 0; Ue < t.length; ++Ue) Pe[t[Ue]] = Ue;
  let Be = Ae.length;
  for (; Ae[Be - 1] === "="; ) --Be;
  const Te = new Uint8Array(Be * Me / 8 | 0);
  let je = 0, Ve = 0, fi = 0;
  for (let Ue = 0; Ue < Be; ++Ue) {
    const bi = Pe[Ae[Ue]];
    if (bi === void 0) throw new SyntaxError(`Non-${Ie} character`);
    Ve = Ve << Me | bi, je += Me, je >= 8 && (je -= 8, Te[fi++] = 255 & Ve >> je);
  }
  if (je >= Me || 255 & Ve << 8 - je) throw new SyntaxError("Unexpected end of data");
  return Te;
}, Et = (Ae, t, Me) => {
  const Ie = t[t.length - 1] === "=", Pe = (1 << Me) - 1;
  let Be = "", Te = 0, je = 0;
  for (let Ve = 0; Ve < Ae.length; ++Ve) for (je = je << 8 | Ae[Ve], Te += 8; Te > Me; ) Te -= Me, Be += t[Pe & je >> Te];
  if (Te && (Be += t[Pe & je << Me - Te]), Ie) for (; Be.length * Me & 7; ) Be += "=";
  return Be;
}, d = ({ name: Ae, prefix: t, bitsPerChar: Me, alphabet: Ie }) => O$1({ prefix: t, name: Ae, encode(Pe) {
  return Et(Pe, Ie, Me);
}, decode(Pe) {
  return gt$1(Pe, Ie, Me, Ae);
} }), bt = O$1({ prefix: "\0", name: "identity", encode: (Ae) => ht$1(Ae), decode: (Ae) => ct$1(Ae) });
var yt$1 = Object.freeze({ __proto__: null, identity: bt });
const wt = d({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Ct = Object.freeze({ __proto__: null, base2: wt });
const mt = d({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var vt = Object.freeze({ __proto__: null, base8: mt });
const At = T$1({ prefix: "9", name: "base10", alphabet: "0123456789" });
var _t = Object.freeze({ __proto__: null, base10: At });
const xt = d({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), Rt = d({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ft = Object.freeze({ __proto__: null, base16: xt, base16upper: Rt });
const Tt = d({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), It = d({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), qt = d({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), Ut = d({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), Ot = d({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), St = d({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), Pt = d({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), Nt = d({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), $t = d({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Bt = Object.freeze({ __proto__: null, base32: Tt, base32upper: It, base32pad: qt, base32padupper: Ut, base32hex: Ot, base32hexupper: St, base32hexpad: Pt, base32hexpadupper: Nt, base32z: $t });
const zt = T$1({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), jt = T$1({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Mt = Object.freeze({ __proto__: null, base36: zt, base36upper: jt });
const Lt = T$1({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), Kt = T$1({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Vt = Object.freeze({ __proto__: null, base58btc: Lt, base58flickr: Kt });
const kt = d({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), Jt = d({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), Xt = d({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), Gt = d({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ht = Object.freeze({ __proto__: null, base64: kt, base64pad: Jt, base64url: Xt, base64urlpad: Gt });
const ne$1 = Array.from(""), Yt = ne$1.reduce((Ae, t, Me) => (Ae[Me] = t, Ae), []), Qt = ne$1.reduce((Ae, t, Me) => (Ae[t.codePointAt(0)] = Me, Ae), []);
function Zt(Ae) {
  return Ae.reduce((t, Me) => (t += Yt[Me], t), "");
}
function Wt(Ae) {
  const t = [];
  for (const Me of Ae) {
    const Ie = Qt[Me.codePointAt(0)];
    if (Ie === void 0) throw new Error(`Non-base256emoji character: ${Me}`);
    t.push(Ie);
  }
  return new Uint8Array(t);
}
const er = O$1({ prefix: "", name: "base256emoji", encode: Zt, decode: Wt });
var tr = Object.freeze({ __proto__: null, base256emoji: er }), rr = oe$1, se$1 = 128, ir = 127, nr = ~ir, sr = Math.pow(2, 31);
function oe$1(Ae, t, Me) {
  t = t || [], Me = Me || 0;
  for (var Ie = Me; Ae >= sr; ) t[Me++] = Ae & 255 | se$1, Ae /= 128;
  for (; Ae & nr; ) t[Me++] = Ae & 255 | se$1, Ae >>>= 7;
  return t[Me] = Ae | 0, oe$1.bytes = Me - Ie + 1, t;
}
var or = j$1, ur = 128, ue = 127;
function j$1(Ae, Ie) {
  var Me = 0, Ie = Ie || 0, Pe = 0, Be = Ie, Te, je = Ae.length;
  do {
    if (Be >= je) throw j$1.bytes = 0, new RangeError("Could not decode varint");
    Te = Ae[Be++], Me += Pe < 28 ? (Te & ue) << Pe : (Te & ue) * Math.pow(2, Pe), Pe += 7;
  } while (Te >= ur);
  return j$1.bytes = Be - Ie, Me;
}
var ar = Math.pow(2, 7), Dr = Math.pow(2, 14), cr = Math.pow(2, 21), hr = Math.pow(2, 28), lr = Math.pow(2, 35), dr = Math.pow(2, 42), pr = Math.pow(2, 49), fr = Math.pow(2, 56), gr = Math.pow(2, 63), Er = function(Ae) {
  return Ae < ar ? 1 : Ae < Dr ? 2 : Ae < cr ? 3 : Ae < hr ? 4 : Ae < lr ? 5 : Ae < dr ? 6 : Ae < pr ? 7 : Ae < fr ? 8 : Ae < gr ? 9 : 10;
}, br = { encode: rr, decode: or, encodingLength: Er }, ae$1 = br;
const De = (Ae, t, Me = 0) => (ae$1.encode(Ae, t, Me), t), ce = (Ae) => ae$1.encodingLength(Ae), M = (Ae, t) => {
  const Me = t.byteLength, Ie = ce(Ae), Pe = Ie + ce(Me), Be = new Uint8Array(Pe + Me);
  return De(Ae, Be, 0), De(Me, Be, Ie), Be.set(t, Pe), new yr(Ae, Me, t, Be);
};
class yr {
  constructor(t, Me, Ie, Pe) {
    this.code = t, this.size = Me, this.digest = Ie, this.bytes = Pe;
  }
}
const he = ({ name: Ae, code: t, encode: Me }) => new wr(Ae, t, Me);
class wr {
  constructor(t, Me, Ie) {
    this.name = t, this.code = Me, this.encode = Ie;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const Me = this.encode(t);
      return Me instanceof Uint8Array ? M(this.code, Me) : Me.then((Ie) => M(this.code, Ie));
    } else throw Error("Unknown type, must be binary type");
  }
}
const le = (Ae) => async (t) => new Uint8Array(await crypto.subtle.digest(Ae, t)), Cr = he({ name: "sha2-256", code: 18, encode: le("SHA-256") }), mr = he({ name: "sha2-512", code: 19, encode: le("SHA-512") });
var vr = Object.freeze({ __proto__: null, sha256: Cr, sha512: mr });
const de = 0, Ar = "identity", pe = re, _r = (Ae) => M(de, pe(Ae)), xr = { code: de, name: Ar, encode: pe, digest: _r };
var Rr = Object.freeze({ __proto__: null, identity: xr });
new TextEncoder(), new TextDecoder();
const fe = { ...yt$1, ...Ct, ...vt, ..._t, ...Ft, ...Bt, ...Mt, ...Vt, ...Ht, ...tr };
({ ...vr, ...Rr });
function ge(Ae, t, Me, Ie) {
  return { name: Ae, prefix: t, encoder: { name: Ae, prefix: t, encode: Me }, decoder: { decode: Ie } };
}
const Ee = ge("utf8", "u", (Ae) => "u" + new TextDecoder("utf8").decode(Ae), (Ae) => new TextEncoder().encode(Ae.substring(1))), L$1 = ge("ascii", "a", (Ae) => {
  let t = "a";
  for (let Me = 0; Me < Ae.length; Me++) t += String.fromCharCode(Ae[Me]);
  return t;
}, (Ae) => {
  Ae = Ae.substring(1);
  const t = ot$1(Ae.length);
  for (let Me = 0; Me < Ae.length; Me++) t[Me] = Ae.charCodeAt(Me);
  return t;
}), be$1 = { utf8: Ee, "utf-8": Ee, hex: fe.base16, latin1: L$1, ascii: L$1, binary: L$1, ...fe };
function Fr(Ae, t = "utf8") {
  const Me = be$1[t];
  if (!Me) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(Ae, "utf8") : Me.decoder.decode(`${Me.prefix}${Ae}`);
}
function Tr(Ae, t = "utf8") {
  const Me = be$1[t];
  if (!Me) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(Ae.buffer, Ae.byteOffset, Ae.byteLength).toString("utf8") : Me.encoder.encode(Ae).substring(1);
}
const ye$1 = "base16", we$1 = "utf8";
function K$1(Ae) {
  const t = sha256.hash(Fr(Ae, we$1));
  return Tr(t, ye$1);
}
var Or = Object.defineProperty, Sr = Object.defineProperties, Pr = Object.getOwnPropertyDescriptors, Ce$1 = Object.getOwnPropertySymbols, Nr = Object.prototype.hasOwnProperty, $r = Object.prototype.propertyIsEnumerable, me$1 = (Ae, t, Me) => t in Ae ? Or(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Me }) : Ae[t] = Me, I$1 = (Ae, t) => {
  for (var Me in t || (t = {})) Nr.call(t, Me) && me$1(Ae, Me, t[Me]);
  if (Ce$1) for (var Me of Ce$1(t)) $r.call(t, Me) && me$1(Ae, Me, t[Me]);
  return Ae;
}, V$1 = (Ae, t) => Sr(Ae, Pr(t));
class Br extends G {
  constructor(t) {
    super(t), this.initialized = !1, this.name = "authEngine", this.init = () => {
      this.initialized || (this.registerRelayerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(R$1) }), this.initialized = !0);
    }, this.request = async (Me, Ie) => {
      if (this.isInitialized(), !nt$1(Me)) throw new Error("Invalid request");
      if (Ie != null && Ie.topic) return await this.requestOnKnownPairing(Ie.topic, Me);
      const { chainId: Pe, statement: Be, aud: Te, domain: je, nonce: Ve, type: fi, exp: Ue, nbf: bi } = Me, { topic: vi, uri: mi } = await this.client.core.pairing.create();
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: vi, uri: mi } });
      const _i = await this.client.core.crypto.generateKeyPair(), $i = hr$2(_i);
      await this.client.authKeys.set(x$2, { responseTopic: $i, publicKey: _i }), await this.client.pairingTopics.set($i, { topic: $i, pairingTopic: vi }), await this.client.core.relayer.subscribe($i), this.client.logger.info(`sending request to new pairing topic: ${vi}`);
      const Ci = await this.sendRequest(vi, "wc_authRequest", { payloadParams: { type: fi ?? "eip4361", chainId: Pe, statement: Be, aud: Te, domain: je, version: "1", nonce: Ve, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: Ue, nbf: bi }, requester: { publicKey: _i, metadata: this.client.metadata } }, {}, Me.expiry);
      return this.client.logger.info(`sent request to new pairing topic: ${vi}`), { uri: mi, id: Ci };
    }, this.respond = async (Me, Ie) => {
      if (this.isInitialized(), !st$1(Me, this.client.requests)) throw new Error("Invalid response");
      const Pe = te$1(this.client.requests, Me.id);
      if (!Pe) throw new Error(`Could not find pending auth request with id ${Me.id}`);
      const Be = Pe.requester.publicKey, Te = await this.client.core.crypto.generateKeyPair(), je = hr$2(Be), Ve = { type: D$2, receiverPublicKey: Be, senderPublicKey: Te };
      if ("error" in Me) {
        await this.sendError(Pe.id, je, Me, Ve);
        return;
      }
      const fi = { h: { t: "eip4361" }, p: V$1(I$1({}, Pe.cacaoPayload), { iss: Ie }), s: Me.signature };
      await this.sendResult(Pe.id, je, fi, Ve), await this.client.core.pairing.activate({ topic: Pe.pairingTopic }), await this.client.requests.update(Pe.id, I$1({}, fi));
    }, this.getPendingRequests = () => ee$1(this.client.requests), this.formatMessage = (Me, Ie) => {
      this.client.logger.debug(`formatMessage, cacao is: ${JSON.stringify(Me)}`);
      const Pe = `${Me.domain} wants you to sign in with your Ethereum account:`, Be = W(Ie), Te = Me.statement, je = `URI: ${Me.aud}`, Ve = `Version: ${Me.version}`, fi = `Chain ID: ${Ze(Ie)}`, Ue = `Nonce: ${Me.nonce}`, bi = `Issued At: ${Me.iat}`, vi = Me.exp ? `Expiry: ${Me.exp}` : void 0, mi = Me.resources && Me.resources.length > 0 ? `Resources:
${Me.resources.map((_i) => `- ${_i}`).join(`
`)}` : void 0;
      return [Pe, Be, "", Te, "", je, Ve, fi, Ue, bi, vi, mi].filter((_i) => _i != null).join(`
`);
    }, this.setExpiry = async (Me, Ie) => {
      this.client.core.pairing.pairings.keys.includes(Me) && await this.client.core.pairing.updateExpiry({ topic: Me, expiry: Ie }), this.client.core.expirer.set(Me, Ie);
    }, this.sendRequest = async (Me, Ie, Pe, Be, Te) => {
      const je = formatJsonRpcRequest(Ie, Pe), Ve = await this.client.core.crypto.encode(Me, je, Be), fi = R$1[Ie].req;
      if (Te && (fi.ttl = Te), this.client.core.history.set(Me, je), V$3()) {
        const Ue = K$1(JSON.stringify(je));
        this.client.core.verify.register({ attestationId: Ue });
      }
      return await this.client.core.relayer.publish(Me, Ve, V$1(I$1({}, fi), { internal: { throwOnFailedPublish: !0 } })), je.id;
    }, this.sendResult = async (Me, Ie, Pe, Be) => {
      const Te = formatJsonRpcResult(Me, Pe), je = await this.client.core.crypto.encode(Ie, Te, Be), Ve = await this.client.core.history.get(Ie, Me), fi = R$1[Ve.request.method].res;
      return await this.client.core.relayer.publish(Ie, je, V$1(I$1({}, fi), { internal: { throwOnFailedPublish: !0 } })), await this.client.core.history.resolve(Te), Te.id;
    }, this.sendError = async (Me, Ie, Pe, Be) => {
      const Te = formatJsonRpcError(Me, Pe.error), je = await this.client.core.crypto.encode(Ie, Te, Be), Ve = await this.client.core.history.get(Ie, Me), fi = R$1[Ve.request.method].res;
      return await this.client.core.relayer.publish(Ie, je, fi), await this.client.core.history.resolve(Te), Te.id;
    }, this.requestOnKnownPairing = async (Me, Ie) => {
      const Pe = this.client.core.pairing.pairings.getAll({ active: !0 }).find((mi) => mi.topic === Me);
      if (!Pe) throw new Error(`Could not find pairing for provided topic ${Me}`);
      const { publicKey: Be } = this.client.authKeys.get(x$2), { chainId: Te, statement: je, aud: Ve, domain: fi, nonce: Ue, type: bi } = Ie, vi = await this.sendRequest(Pe.topic, "wc_authRequest", { payloadParams: { type: bi ?? "eip4361", chainId: Te, statement: je, aud: Ve, domain: fi, version: "1", nonce: Ue, iat: (/* @__PURE__ */ new Date()).toISOString() }, requester: { publicKey: Be, metadata: this.client.metadata } }, {}, Ie.expiry);
      return this.client.logger.info(`sent request to known pairing topic: ${Pe.topic}`), { id: vi };
    }, this.onPairingCreated = (Me) => {
      const Ie = this.getPendingRequests();
      if (Ie) {
        const Pe = Object.values(Ie).find((Be) => Be.pairingTopic === Me.topic);
        Pe && this.handleAuthRequest(Pe);
      }
    }, this.onRelayEventRequest = (Me) => {
      const { topic: Ie, payload: Pe } = Me, Be = Pe.method;
      switch (Be) {
        case "wc_authRequest":
          return this.onAuthRequest(Ie, Pe);
        default:
          return this.client.logger.info(`Unsupported request method ${Be}`);
      }
    }, this.onRelayEventResponse = async (Me) => {
      const { topic: Ie, payload: Pe } = Me, Be = (await this.client.core.history.get(Ie, Pe.id)).request.method;
      switch (Be) {
        case "wc_authRequest":
          return this.onAuthResponse(Ie, Pe);
        default:
          return this.client.logger.info(`Unsupported response method ${Be}`);
      }
    }, this.onAuthRequest = async (Me, Ie) => {
      const { requester: Pe, payloadParams: Be } = Ie.params;
      this.client.logger.info({ type: "onAuthRequest", topic: Me, payload: Ie });
      const Te = K$1(JSON.stringify(Ie)), je = await this.getVerifyContext(Te, this.client.metadata), Ve = { requester: Pe, pairingTopic: Me, id: Ie.id, cacaoPayload: Be, verifyContext: je };
      await this.client.requests.set(Ie.id, Ve), this.handleAuthRequest(Ve);
    }, this.handleAuthRequest = async (Me) => {
      const { id: Ie, pairingTopic: Pe, requester: Be, cacaoPayload: Te, verifyContext: je } = Me;
      try {
        this.client.emit("auth_request", { id: Ie, topic: Pe, params: { requester: Be, cacaoPayload: Te }, verifyContext: je });
      } catch (Ve) {
        await this.sendError(Me.id, Me.pairingTopic, Ve), this.client.logger.error(Ve);
      }
    }, this.onAuthResponse = async (Me, Ie) => {
      const { id: Pe } = Ie;
      if (this.client.logger.info({ type: "onAuthResponse", topic: Me, response: Ie }), isJsonRpcResult(Ie)) {
        const { pairingTopic: Be } = this.client.pairingTopics.get(Me);
        await this.client.core.pairing.activate({ topic: Be });
        const { s: Te, p: je } = Ie.result;
        await this.client.requests.set(Pe, I$1({ id: Pe, pairingTopic: Be }, Ie.result));
        const Ve = this.formatMessage(je, je.iss);
        this.client.logger.debug(`reconstructed message:
`, JSON.stringify(Ve)), this.client.logger.debug("payload.iss:", je.iss), this.client.logger.debug("signature:", Te);
        const fi = W(je.iss), Ue = We(je.iss);
        if (!fi) throw new Error("Could not derive address from `payload.iss`");
        if (!Ue) throw new Error("Could not derive chainId from `payload.iss`");
        this.client.logger.debug("walletAddress extracted from `payload.iss`:", fi), await et(fi, Ve, Te, Ue, this.client.projectId) ? this.client.emit("auth_response", { id: Pe, topic: Me, params: Ie }) : this.client.emit("auth_response", { id: Pe, topic: Me, params: { message: "Invalid signature", code: -1 } });
      } else isJsonRpcError(Ie) && this.client.emit("auth_response", { id: Pe, topic: Me, params: Ie });
    }, this.getVerifyContext = async (Me, Ie) => {
      const Pe = { verified: { verifyUrl: Ie.verifyUrl || "", validation: "UNKNOWN", origin: Ie.url || "" } };
      try {
        const Be = await this.client.core.verify.resolve({ attestationId: Me, verifyUrl: Ie.verifyUrl });
        Be && (Pe.verified.origin = Be.origin, Pe.verified.isScam = Be.isScam, Pe.verified.validation = origin === new URL(Ie.url).origin ? "VALID" : "INVALID");
      } catch (Be) {
        this.client.logger.error(Be);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(Pe)}`), Pe;
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(v$2.message, async (t) => {
      const { topic: Me, message: Ie } = t, { responseTopic: Pe, publicKey: Be } = this.client.authKeys.keys.includes(x$2) ? this.client.authKeys.get(x$2) : { responseTopic: void 0, publicKey: void 0 };
      if (Pe && Me !== Pe) {
        this.client.logger.debug("[Auth] Ignoring message from unknown topic", Me);
        return;
      }
      const Te = await this.client.core.crypto.decode(Me, Ie, { receiverPublicKey: Be });
      isJsonRpcRequest(Te) ? (this.client.core.history.set(Me, Te), this.onRelayEventRequest({ topic: Me, payload: Te })) : isJsonRpcResponse(Te) && (await this.client.core.history.resolve(Te), this.onRelayEventResponse({ topic: Me, payload: Te }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(V$2.create, (t) => this.onPairingCreated(t));
  }
}
let S$1 = class nf extends H {
  constructor(t) {
    super(t), this.protocol = $, this.version = Q, this.name = B$1, this.events = new eventsExports.EventEmitter(), this.emit = (Ie, Pe) => this.events.emit(Ie, Pe), this.on = (Ie, Pe) => this.events.on(Ie, Pe), this.once = (Ie, Pe) => this.events.once(Ie, Pe), this.off = (Ie, Pe) => this.events.off(Ie, Pe), this.removeListener = (Ie, Pe) => this.events.removeListener(Ie, Pe), this.request = async (Ie, Pe) => {
      try {
        return await this.engine.request(Ie, Pe);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.respond = async (Ie, Pe) => {
      try {
        return await this.engine.respond(Ie, Pe);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.getPendingRequests = () => {
      try {
        return this.engine.getPendingRequests();
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.formatMessage = (Ie, Pe) => {
      try {
        return this.engine.formatMessage(Ie, Pe);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    };
    const Me = typeof t.logger < "u" && typeof t.logger != "string" ? t.logger : qt$3(k$2({ level: t.logger || "error" }));
    this.name = (t == null ? void 0 : t.name) || B$1, this.metadata = t.metadata, this.projectId = t.projectId, this.core = t.core || new bn(t), this.logger = E$1(Me, this.name), this.authKeys = new ni(this.core, this.logger, "authKeys", F$1, () => x$2), this.pairingTopics = new ni(this.core, this.logger, "pairingTopics", F$1), this.requests = new ni(this.core, this.logger, "requests", F$1, (Ie) => Ie.id), this.engine = new Br(this);
  }
  static async init(t) {
    const Me = new nf(t);
    return await Me.initialize(), Me;
  }
  get context() {
    return y$3(this.logger);
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.authKeys.init(), await this.requests.init(), await this.pairingTopics.init(), await this.engine.init(), this.logger.info("AuthClient Initialization Success"), this.logger.info({ authClient: this });
    } catch (t) {
      throw this.logger.info("AuthClient Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
const zr = S$1, be = "wc", Ce = 2, Le = "client", ye = `${be}@${Ce}:${Le}:`, we = { name: Le, logger: "error", controller: !1, relayUrl: "wss://relay.walletconnect.org" }, xe = "WALLETCONNECT_DEEPLINK_CHOICE", st = "proposal", it = "Proposal expired", rt = "session", z$1 = cjs$3.SEVEN_DAYS, nt = "engine", v$1 = { wc_sessionPropose: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1101 }, reject: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1120 }, autoReject: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1121 } }, wc_sessionSettle: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1114 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: cjs$3.ONE_HOUR, prompt: !0, tag: 1116 }, res: { ttl: cjs$3.ONE_HOUR, prompt: !1, tag: 1117 }, reject: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1118 }, autoReject: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1119 } } }, me = { min: cjs$3.FIVE_MINUTES, max: cjs$3.SEVEN_DAYS }, x$1 = { idle: "IDLE", active: "ACTIVE" }, ot = "request", at = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"], ct = "wc", lt = "auth", pt = "authKeys", ht = "pairingTopics", dt = "requests", oe = `${ct}@${1.5}:${lt}:`, ae = `${oe}:PUB_KEY`;
var ys = Object.defineProperty, ws = Object.defineProperties, ms = Object.getOwnPropertyDescriptors, ut = Object.getOwnPropertySymbols, _s = Object.prototype.hasOwnProperty, Es = Object.prototype.propertyIsEnumerable, gt = (Ae, t, Me) => t in Ae ? ys(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Me }) : Ae[t] = Me, I = (Ae, t) => {
  for (var Me in t || (t = {})) _s.call(t, Me) && gt(Ae, Me, t[Me]);
  if (ut) for (var Me of ut(t)) Es.call(t, Me) && gt(Ae, Me, t[Me]);
  return Ae;
}, D$1 = (Ae, t) => ws(Ae, ms(t));
class Rs extends M$3 {
  constructor(t) {
    super(t), this.name = nt, this.events = new es(), this.initialized = !1, this.requestQueue = { state: x$1.idle, queue: [] }, this.sessionRequestQueue = { state: x$1.idle, queue: [] }, this.requestQueueDelay = cjs$3.ONE_SECOND, this.expectedPairingMethodMap = /* @__PURE__ */ new Map(), this.recentlyDeletedMap = /* @__PURE__ */ new Map(), this.recentlyDeletedLimit = 200, this.relayMessageCache = [], this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(v$1) }), this.initialized = !0, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, cjs$3.toMiliseconds(this.requestQueueDelay)));
    }, this.connect = async (Me) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const Ie = D$1(I({}, Me), { requiredNamespaces: Me.requiredNamespaces || {}, optionalNamespaces: Me.optionalNamespaces || {} });
      await this.isValidConnect(Ie);
      const { pairingTopic: Pe, requiredNamespaces: Be, optionalNamespaces: Te, sessionProperties: je, relays: Ve } = Ie;
      let fi = Pe, Ue, bi = !1;
      try {
        fi && (bi = this.client.core.pairing.pairings.get(fi).active);
      } catch (Hi) {
        throw this.client.logger.error(`connect() -> pairing.get(${fi}) failed`), Hi;
      }
      if (!fi || !bi) {
        const { topic: Hi, uri: Zi } = await this.client.core.pairing.create();
        fi = Hi, Ue = Zi;
      }
      if (!fi) {
        const { message: Hi } = S$4("NO_MATCHING_KEY", `connect() pairing topic: ${fi}`);
        throw new Error(Hi);
      }
      const vi = await this.client.core.crypto.generateKeyPair(), mi = v$1.wc_sessionPropose.req.ttl || cjs$3.FIVE_MINUTES, _i = Mt$2(mi), $i = I({ requiredNamespaces: Be, optionalNamespaces: Te, relays: Ve ?? [{ protocol: rt$2 }], proposer: { publicKey: vi, metadata: this.client.metadata }, expiryTimestamp: _i, pairingTopic: fi }, je && { sessionProperties: je }), { reject: Ci, resolve: Ui, done: ki } = _t$2(mi, it);
      this.events.once(Lt$2("session_connect"), async ({ error: Hi, session: Zi }) => {
        if (Hi) Ci(Hi);
        else if (Zi) {
          Zi.self.publicKey = vi;
          const Qi = D$1(I({}, Zi), { pairingTopic: $i.pairingTopic, requiredNamespaces: $i.requiredNamespaces, optionalNamespaces: $i.optionalNamespaces, transportType: M$1.relay });
          await this.client.session.set(Zi.topic, Qi), await this.setExpiry(Zi.topic, Zi.expiry), fi && await this.client.core.pairing.updateMetadata({ topic: fi, metadata: Zi.peer.metadata }), this.cleanupDuplicatePairings(Qi), Ui(Qi);
        }
      });
      const Ji = await this.sendRequest({ topic: fi, method: "wc_sessionPropose", params: $i, throwOnFailedPublish: !0 });
      return await this.setProposal(Ji, I({ id: Ji }, $i)), { uri: Ue, approval: ki };
    }, this.pair = async (Me) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(Me);
      } catch (Ie) {
        throw this.client.logger.error("pair() failed"), Ie;
      }
    }, this.approve = async (Me) => {
      var Ie, Pe, Be;
      const Te = this.client.core.eventClient.createEvent({ properties: { topic: (Ie = Me == null ? void 0 : Me.id) == null ? void 0 : Ie.toString(), trace: [Is$1.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (Xi) {
        throw Te.setError(Ts$1.no_internet_connection), Xi;
      }
      try {
        await this.isValidProposalId(Me == null ? void 0 : Me.id);
      } catch (Xi) {
        throw this.client.logger.error(`approve() -> proposal.get(${Me == null ? void 0 : Me.id}) failed`), Te.setError(Ts$1.proposal_not_found), Xi;
      }
      try {
        await this.isValidApprove(Me);
      } catch (Xi) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), Te.setError(Ts$1.session_approve_namespace_validation_failure), Xi;
      }
      const { id: je, relayProtocol: Ve, namespaces: fi, sessionProperties: Ue, sessionConfig: bi } = Me, vi = this.client.proposal.get(je);
      this.client.core.eventClient.deleteEvent({ eventId: Te.eventId });
      const { pairingTopic: mi, proposer: _i, requiredNamespaces: $i, optionalNamespaces: Ci } = vi;
      let Ui = (Pe = this.client.core.eventClient) == null ? void 0 : Pe.getEvent({ topic: mi });
      Ui || (Ui = (Be = this.client.core.eventClient) == null ? void 0 : Be.createEvent({ type: Is$1.session_approve_started, properties: { topic: mi, trace: [Is$1.session_approve_started, Is$1.session_namespaces_validation_success] } }));
      const ki = await this.client.core.crypto.generateKeyPair(), Ji = _i.publicKey, Hi = await this.client.core.crypto.generateSharedKey(ki, Ji), Zi = I(I({ relay: { protocol: Ve ?? "irn" }, namespaces: fi, controller: { publicKey: ki, metadata: this.client.metadata }, expiry: Mt$2(z$1) }, Ue && { sessionProperties: Ue }), bi && { sessionConfig: bi }), Qi = M$1.relay;
      Ui.addTrace(Is$1.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(Hi, { transportType: Qi });
      } catch (Xi) {
        throw Ui.setError(Ts$1.subscribe_session_topic_failure), Xi;
      }
      Ui.addTrace(Is$1.subscribe_session_topic_success);
      const Bi = D$1(I({}, Zi), { topic: Hi, requiredNamespaces: $i, optionalNamespaces: Ci, pairingTopic: mi, acknowledged: !1, self: Zi.controller, peer: { publicKey: _i.publicKey, metadata: _i.metadata }, controller: ki, transportType: M$1.relay });
      await this.client.session.set(Hi, Bi), Ui.addTrace(Is$1.store_session);
      try {
        Ui.addTrace(Is$1.publishing_session_settle), await this.sendRequest({ topic: Hi, method: "wc_sessionSettle", params: Zi, throwOnFailedPublish: !0 }).catch((Xi) => {
          throw Ui == null || Ui.setError(Ts$1.session_settle_publish_failure), Xi;
        }), Ui.addTrace(Is$1.session_settle_publish_success), Ui.addTrace(Is$1.publishing_session_approve), await this.sendResult({ id: je, topic: mi, result: { relay: { protocol: Ve ?? "irn" }, responderPublicKey: ki }, throwOnFailedPublish: !0 }).catch((Xi) => {
          throw Ui == null || Ui.setError(Ts$1.session_approve_publish_failure), Xi;
        }), Ui.addTrace(Is$1.session_approve_publish_success);
      } catch (Xi) {
        throw this.client.logger.error(Xi), this.client.session.delete(Hi, U$2("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(Hi), Xi;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: Ui.eventId }), await this.client.core.pairing.updateMetadata({ topic: mi, metadata: _i.metadata }), await this.client.proposal.delete(je, U$2("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: mi }), await this.setExpiry(Hi, Mt$2(z$1)), { topic: Hi, acknowledged: () => Promise.resolve(this.client.session.get(Hi)) };
    }, this.reject = async (Me) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(Me);
      } catch (Te) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), Te;
      }
      const { id: Ie, reason: Pe } = Me;
      let Be;
      try {
        Be = this.client.proposal.get(Ie).pairingTopic;
      } catch (Te) {
        throw this.client.logger.error(`reject() -> proposal.get(${Ie}) failed`), Te;
      }
      Be && (await this.sendError({ id: Ie, topic: Be, error: Pe, rpcOpts: v$1.wc_sessionPropose.reject }), await this.client.proposal.delete(Ie, U$2("USER_DISCONNECTED")));
    }, this.update = async (Me) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(Me);
      } catch (bi) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), bi;
      }
      const { topic: Ie, namespaces: Pe } = Me, { done: Be, resolve: Te, reject: je } = _t$2(), Ve = payloadId(), fi = getBigIntRpcId().toString(), Ue = this.client.session.get(Ie).namespaces;
      return this.events.once(Lt$2("session_update", Ve), ({ error: bi }) => {
        bi ? je(bi) : Te();
      }), await this.client.session.update(Ie, { namespaces: Pe }), await this.sendRequest({ topic: Ie, method: "wc_sessionUpdate", params: { namespaces: Pe }, throwOnFailedPublish: !0, clientRpcId: Ve, relayRpcId: fi }).catch((bi) => {
        this.client.logger.error(bi), this.client.session.update(Ie, { namespaces: Ue }), je(bi);
      }), { acknowledged: Be };
    }, this.extend = async (Me) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(Me);
      } catch (Ve) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), Ve;
      }
      const { topic: Ie } = Me, Pe = payloadId(), { done: Be, resolve: Te, reject: je } = _t$2();
      return this.events.once(Lt$2("session_extend", Pe), ({ error: Ve }) => {
        Ve ? je(Ve) : Te();
      }), await this.setExpiry(Ie, Mt$2(z$1)), this.sendRequest({ topic: Ie, method: "wc_sessionExtend", params: {}, clientRpcId: Pe, throwOnFailedPublish: !0 }).catch((Ve) => {
        je(Ve);
      }), { acknowledged: Be };
    }, this.request = async (Me) => {
      this.isInitialized();
      try {
        await this.isValidRequest(Me);
      } catch (_i) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), _i;
      }
      const { chainId: Ie, request: Pe, topic: Be, expiry: Te = v$1.wc_sessionRequest.req.ttl } = Me, je = this.client.session.get(Be);
      (je == null ? void 0 : je.transportType) === M$1.relay && await this.confirmOnlineStateOrThrow();
      const Ve = payloadId(), fi = getBigIntRpcId().toString(), { done: Ue, resolve: bi, reject: vi } = _t$2(Te, "Request expired. Please try again.");
      this.events.once(Lt$2("session_request", Ve), ({ error: _i, result: $i }) => {
        _i ? vi(_i) : bi($i);
      });
      const mi = this.getAppLinkIfEnabled(je.peer.metadata, je.transportType);
      return mi ? (await this.sendRequest({ clientRpcId: Ve, relayRpcId: fi, topic: Be, method: "wc_sessionRequest", params: { request: D$1(I({}, Pe), { expiryTimestamp: Mt$2(Te) }), chainId: Ie }, expiry: Te, throwOnFailedPublish: !0, appLink: mi }).catch((_i) => vi(_i)), this.client.events.emit("session_request_sent", { topic: Be, request: Pe, chainId: Ie, id: Ve }), await Ue()) : await Promise.all([new Promise(async (_i) => {
        await this.sendRequest({ clientRpcId: Ve, relayRpcId: fi, topic: Be, method: "wc_sessionRequest", params: { request: D$1(I({}, Pe), { expiryTimestamp: Mt$2(Te) }), chainId: Ie }, expiry: Te, throwOnFailedPublish: !0 }).catch(($i) => vi($i)), this.client.events.emit("session_request_sent", { topic: Be, request: Pe, chainId: Ie, id: Ve }), _i();
      }), new Promise(async (_i) => {
        var $i;
        if (!(($i = je.sessionConfig) != null && $i.disableDeepLink)) {
          const Ci = await qt$2(this.client.core.storage, xe);
          await Ft$2({ id: Ve, topic: Be, wcDeepLink: Ci });
        }
        _i();
      }), Ue()]).then((_i) => _i[2]);
    }, this.respond = async (Me) => {
      this.isInitialized(), await this.isValidRespond(Me);
      const { topic: Ie, response: Pe } = Me, { id: Be } = Pe, Te = this.client.session.get(Ie);
      Te.transportType === M$1.relay && await this.confirmOnlineStateOrThrow();
      const je = this.getAppLinkIfEnabled(Te.peer.metadata, Te.transportType);
      isJsonRpcResult(Pe) ? await this.sendResult({ id: Be, topic: Ie, result: Pe.result, throwOnFailedPublish: !0, appLink: je }) : isJsonRpcError(Pe) && await this.sendError({ id: Be, topic: Ie, error: Pe.error, appLink: je }), this.cleanupAfterResponse(Me);
    }, this.ping = async (Me) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(Me);
      } catch (Pe) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), Pe;
      }
      const { topic: Ie } = Me;
      if (this.client.session.keys.includes(Ie)) {
        const Pe = payloadId(), Be = getBigIntRpcId().toString(), { done: Te, resolve: je, reject: Ve } = _t$2();
        this.events.once(Lt$2("session_ping", Pe), ({ error: fi }) => {
          fi ? Ve(fi) : je();
        }), await Promise.all([this.sendRequest({ topic: Ie, method: "wc_sessionPing", params: {}, throwOnFailedPublish: !0, clientRpcId: Pe, relayRpcId: Be }), Te()]);
      } else this.client.core.pairing.pairings.keys.includes(Ie) && await this.client.core.pairing.ping({ topic: Ie });
    }, this.emit = async (Me) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(Me);
      const { topic: Ie, event: Pe, chainId: Be } = Me, Te = getBigIntRpcId().toString();
      await this.sendRequest({ topic: Ie, method: "wc_sessionEvent", params: { event: Pe, chainId: Be }, throwOnFailedPublish: !0, relayRpcId: Te });
    }, this.disconnect = async (Me) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(Me);
      const { topic: Ie } = Me;
      if (this.client.session.keys.includes(Ie)) await this.sendRequest({ topic: Ie, method: "wc_sessionDelete", params: U$2("USER_DISCONNECTED"), throwOnFailedPublish: !0 }), await this.deleteSession({ topic: Ie, emitEvent: !1 });
      else if (this.client.core.pairing.pairings.keys.includes(Ie)) await this.client.core.pairing.disconnect({ topic: Ie });
      else {
        const { message: Pe } = S$4("MISMATCHED_TOPIC", `Session or pairing topic not found: ${Ie}`);
        throw new Error(Pe);
      }
    }, this.find = (Me) => (this.isInitialized(), this.client.session.getAll().filter((Ie) => zr$2(Ie, Me))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (Me, Ie) => {
      var Pe;
      this.isInitialized(), this.isValidAuthenticate(Me);
      const Be = Ie && this.client.core.linkModeSupportedApps.includes(Ie) && ((Pe = this.client.metadata.redirect) == null ? void 0 : Pe.linkMode), Te = Be ? M$1.link_mode : M$1.relay;
      Te === M$1.relay && await this.confirmOnlineStateOrThrow();
      const { chains: je, statement: Ve = "", uri: fi, domain: Ue, nonce: bi, type: vi, exp: mi, nbf: _i, methods: $i = [], expiry: Ci } = Me, Ui = [...Me.resources || []], { topic: ki, uri: Ji } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: Te });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: ki, uri: Ji } });
      const Hi = await this.client.core.crypto.generateKeyPair(), Zi = hr$2(Hi);
      if (await Promise.all([this.client.auth.authKeys.set(ae, { responseTopic: Zi, publicKey: Hi }), this.client.auth.pairingTopics.set(Zi, { topic: Zi, pairingTopic: ki })]), await this.client.core.relayer.subscribe(Zi, { transportType: Te }), this.client.logger.info(`sending request to new pairing topic: ${ki}`), $i.length > 0) {
        const { namespace: qi } = re$2(je[0]);
        let Oi = ir$2(qi, "request", $i);
        Y$2(Ui) && (Oi = cr$2(Oi, Ui.pop())), Ui.push(Oi);
      }
      const Qi = Ci && Ci > v$1.wc_sessionAuthenticate.req.ttl ? Ci : v$1.wc_sessionAuthenticate.req.ttl, Bi = { authPayload: { type: vi ?? "caip122", chains: je, statement: Ve, aud: fi, domain: Ue, version: "1", nonce: bi, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: mi, nbf: _i, resources: Ui }, requester: { publicKey: Hi, metadata: this.client.metadata }, expiryTimestamp: Mt$2(Qi) }, Xi = { eip155: { chains: je, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...$i])], events: ["chainChanged", "accountsChanged"] } }, ns = { requiredNamespaces: {}, optionalNamespaces: Xi, relays: [{ protocol: "irn" }], pairingTopic: ki, proposer: { publicKey: Hi, metadata: this.client.metadata }, expiryTimestamp: Mt$2(v$1.wc_sessionPropose.req.ttl) }, { done: ls, resolve: vn, reject: Mi } = _t$2(Qi, "Request expired"), Ai = async ({ error: qi, session: Oi }) => {
        if (this.events.off(Lt$2("session_request", Ei), wi), qi) Mi(qi);
        else if (Oi) {
          Oi.self.publicKey = Hi, await this.client.session.set(Oi.topic, Oi), await this.setExpiry(Oi.topic, Oi.expiry), ki && await this.client.core.pairing.updateMetadata({ topic: ki, metadata: Oi.peer.metadata });
          const Si = this.client.session.get(Oi.topic);
          await this.deleteProposal(Ti), vn({ session: Si });
        }
      }, wi = async (qi) => {
        var Oi, Si, Ni;
        if (await this.deletePendingAuthRequest(Ei, { message: "fulfilled", code: 0 }), qi.error) {
          const Fi = U$2("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return qi.error.code === Fi.code ? void 0 : (this.events.off(Lt$2("session_connect"), Ai), Mi(qi.error.message));
        }
        await this.deleteProposal(Ti), this.events.off(Lt$2("session_connect"), Ai);
        const { cacaos: xi, responder: Wi } = qi.result, ts = [], Ki = [];
        for (const Fi of xi) {
          await nr$2({ cacao: Fi, projectId: this.client.core.projectId }) || (this.client.logger.error(Fi, "Signature verification failed"), Mi(U$2("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: Gi } = Fi, Ri = Y$2(Gi.resources), ji = [ln$1(Gi.iss)], Vi = fe$2(Gi.iss);
          if (Ri) {
            const is = ar$2(Ri), os = ur$2(Ri);
            ts.push(...is), ji.push(...os);
          }
          for (const is of ji) Ki.push(`${is}:${Vi}`);
        }
        const fn = await this.client.core.crypto.generateSharedKey(Hi, Wi.publicKey);
        let Ii;
        ts.length > 0 && (Ii = { topic: fn, acknowledged: !0, self: { publicKey: Hi, metadata: this.client.metadata }, peer: Wi, controller: Wi.publicKey, expiry: Mt$2(z$1), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: ki, namespaces: Jr$1([...new Set(ts)], [...new Set(Ki)]), transportType: Te }, await this.client.core.relayer.subscribe(fn, { transportType: Te }), await this.client.session.set(fn, Ii), ki && await this.client.core.pairing.updateMetadata({ topic: ki, metadata: Wi.metadata }), Ii = this.client.session.get(fn)), (Oi = this.client.metadata.redirect) != null && Oi.linkMode && (Si = Wi.metadata.redirect) != null && Si.linkMode && (Ni = Wi.metadata.redirect) != null && Ni.universal && Ie && (this.client.core.addLinkModeSupportedApp(Wi.metadata.redirect.universal), this.client.session.update(fn, { transportType: M$1.link_mode })), vn({ auths: xi, session: Ii });
      }, Ei = payloadId(), Ti = payloadId();
      this.events.once(Lt$2("session_connect"), Ai), this.events.once(Lt$2("session_request", Ei), wi);
      let Pi;
      try {
        if (Be) {
          const qi = formatJsonRpcRequest("wc_sessionAuthenticate", Bi, Ei);
          this.client.core.history.set(ki, qi);
          const Oi = await this.client.core.crypto.encode("", qi, { type: M$2, encoding: lr$2 });
          Pi = xr$2(Ie, ki, Oi);
        } else await Promise.all([this.sendRequest({ topic: ki, method: "wc_sessionAuthenticate", params: Bi, expiry: Me.expiry, throwOnFailedPublish: !0, clientRpcId: Ei }), this.sendRequest({ topic: ki, method: "wc_sessionPropose", params: ns, expiry: v$1.wc_sessionPropose.req.ttl, throwOnFailedPublish: !0, clientRpcId: Ti })]);
      } catch (qi) {
        throw this.events.off(Lt$2("session_connect"), Ai), this.events.off(Lt$2("session_request", Ei), wi), qi;
      }
      return await this.setProposal(Ti, I({ id: Ti }, ns)), await this.setAuthRequest(Ei, { request: D$1(I({}, Bi), { verifyContext: {} }), pairingTopic: ki, transportType: Te }), { uri: Pi ?? Ji, response: ls };
    }, this.approveSessionAuthenticate = async (Me) => {
      const { id: Ie, auths: Pe } = Me, Be = this.client.core.eventClient.createEvent({ properties: { topic: Ie.toString(), trace: [Cs.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (Ci) {
        throw Be.setError(Ps$1.no_internet_connection), Ci;
      }
      const Te = this.getPendingAuthRequest(Ie);
      if (!Te) throw Be.setError(Ps$1.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${Ie}`);
      const je = Te.transportType || M$1.relay;
      je === M$1.relay && await this.confirmOnlineStateOrThrow();
      const Ve = Te.requester.publicKey, fi = await this.client.core.crypto.generateKeyPair(), Ue = hr$2(Ve), bi = { type: D$2, receiverPublicKey: Ve, senderPublicKey: fi }, vi = [], mi = [];
      for (const Ci of Pe) {
        if (!await nr$2({ cacao: Ci, projectId: this.client.core.projectId })) {
          Be.setError(Ps$1.invalid_cacao);
          const Zi = U$2("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: Ie, topic: Ue, error: Zi, encodeOpts: bi }), new Error(Zi.message);
        }
        Be.addTrace(Cs.cacaos_verified);
        const { p: Ui } = Ci, ki = Y$2(Ui.resources), Ji = [ln$1(Ui.iss)], Hi = fe$2(Ui.iss);
        if (ki) {
          const Zi = ar$2(ki), Qi = ur$2(ki);
          vi.push(...Zi), Ji.push(...Qi);
        }
        for (const Zi of Ji) mi.push(`${Zi}:${Hi}`);
      }
      const _i = await this.client.core.crypto.generateSharedKey(fi, Ve);
      Be.addTrace(Cs.create_authenticated_session_topic);
      let $i;
      if ((vi == null ? void 0 : vi.length) > 0) {
        $i = { topic: _i, acknowledged: !0, self: { publicKey: fi, metadata: this.client.metadata }, peer: { publicKey: Ve, metadata: Te.requester.metadata }, controller: Ve, expiry: Mt$2(z$1), authentication: Pe, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: Te.pairingTopic, namespaces: Jr$1([...new Set(vi)], [...new Set(mi)]), transportType: je }, Be.addTrace(Cs.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(_i, { transportType: je });
        } catch (Ci) {
          throw Be.setError(Ps$1.subscribe_authenticated_session_topic_failure), Ci;
        }
        Be.addTrace(Cs.subscribe_authenticated_session_topic_success), await this.client.session.set(_i, $i), Be.addTrace(Cs.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: Te.pairingTopic, metadata: Te.requester.metadata });
      }
      Be.addTrace(Cs.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: Ue, id: Ie, result: { cacaos: Pe, responder: { publicKey: fi, metadata: this.client.metadata } }, encodeOpts: bi, throwOnFailedPublish: !0, appLink: this.getAppLinkIfEnabled(Te.requester.metadata, je) });
      } catch (Ci) {
        throw Be.setError(Ps$1.authenticated_session_approve_publish_failure), Ci;
      }
      return await this.client.auth.requests.delete(Ie, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: Te.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: Be.eventId }), { session: $i };
    }, this.rejectSessionAuthenticate = async (Me) => {
      this.isInitialized();
      const { id: Ie, reason: Pe } = Me, Be = this.getPendingAuthRequest(Ie);
      if (!Be) throw new Error(`Could not find pending auth request with id ${Ie}`);
      Be.transportType === M$1.relay && await this.confirmOnlineStateOrThrow();
      const Te = Be.requester.publicKey, je = await this.client.core.crypto.generateKeyPair(), Ve = hr$2(Te), fi = { type: D$2, receiverPublicKey: Te, senderPublicKey: je };
      await this.sendError({ id: Ie, topic: Ve, error: Pe, encodeOpts: fi, rpcOpts: v$1.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(Be.requester.metadata, Be.transportType) }), await this.client.auth.requests.delete(Ie, { message: "rejected", code: 0 }), await this.client.proposal.delete(Ie, U$2("USER_DISCONNECTED"));
    }, this.formatAuthMessage = (Me) => {
      this.isInitialized();
      const { request: Ie, iss: Pe } = Me;
      return dn$1(Ie, Pe);
    }, this.processRelayMessageCache = () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const Me = this.relayMessageCache.shift();
          Me && await this.onRelayMessage(Me);
        } catch (Me) {
          this.client.logger.error(Me);
        }
      }, 50);
    }, this.cleanupDuplicatePairings = async (Me) => {
      if (Me.pairingTopic) try {
        const Ie = this.client.core.pairing.pairings.get(Me.pairingTopic), Pe = this.client.core.pairing.pairings.getAll().filter((Be) => {
          var Te, je;
          return ((Te = Be.peerMetadata) == null ? void 0 : Te.url) && ((je = Be.peerMetadata) == null ? void 0 : je.url) === Me.peer.metadata.url && Be.topic && Be.topic !== Ie.topic;
        });
        if (Pe.length === 0) return;
        this.client.logger.info(`Cleaning up ${Pe.length} duplicate pairing(s)`), await Promise.all(Pe.map((Be) => this.client.core.pairing.disconnect({ topic: Be.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (Ie) {
        this.client.logger.error(Ie);
      }
    }, this.deleteSession = async (Me) => {
      var Ie;
      const { topic: Pe, expirerHasDeleted: Be = !1, emitEvent: Te = !0, id: je = 0 } = Me, { self: Ve } = this.client.session.get(Pe);
      await this.client.core.relayer.unsubscribe(Pe), await this.client.session.delete(Pe, U$2("USER_DISCONNECTED")), this.addToRecentlyDeleted(Pe, "session"), this.client.core.crypto.keychain.has(Ve.publicKey) && await this.client.core.crypto.deleteKeyPair(Ve.publicKey), this.client.core.crypto.keychain.has(Pe) && await this.client.core.crypto.deleteSymKey(Pe), Be || this.client.core.expirer.del(Pe), this.client.core.storage.removeItem(xe).catch((fi) => this.client.logger.warn(fi)), this.getPendingSessionRequests().forEach((fi) => {
        fi.topic === Pe && this.deletePendingSessionRequest(fi.id, U$2("USER_DISCONNECTED"));
      }), Pe === ((Ie = this.sessionRequestQueue.queue[0]) == null ? void 0 : Ie.topic) && (this.sessionRequestQueue.state = x$1.idle), Te && this.client.events.emit("session_delete", { id: je, topic: Pe });
    }, this.deleteProposal = async (Me, Ie) => {
      if (Ie) try {
        const Pe = this.client.proposal.get(Me), Be = this.client.core.eventClient.getEvent({ topic: Pe.pairingTopic });
        Be == null || Be.setError(Ts$1.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(Me, U$2("USER_DISCONNECTED")), Ie ? Promise.resolve() : this.client.core.expirer.del(Me)]), this.addToRecentlyDeleted(Me, "proposal");
    }, this.deletePendingSessionRequest = async (Me, Ie, Pe = !1) => {
      await Promise.all([this.client.pendingRequest.delete(Me, Ie), Pe ? Promise.resolve() : this.client.core.expirer.del(Me)]), this.addToRecentlyDeleted(Me, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((Be) => Be.id !== Me), Pe && (this.sessionRequestQueue.state = x$1.idle, this.client.events.emit("session_request_expire", { id: Me }));
    }, this.deletePendingAuthRequest = async (Me, Ie, Pe = !1) => {
      await Promise.all([this.client.auth.requests.delete(Me, Ie), Pe ? Promise.resolve() : this.client.core.expirer.del(Me)]);
    }, this.setExpiry = async (Me, Ie) => {
      this.client.session.keys.includes(Me) && (this.client.core.expirer.set(Me, Ie), await this.client.session.update(Me, { expiry: Ie }));
    }, this.setProposal = async (Me, Ie) => {
      this.client.core.expirer.set(Me, Mt$2(v$1.wc_sessionPropose.req.ttl)), await this.client.proposal.set(Me, Ie);
    }, this.setAuthRequest = async (Me, Ie) => {
      const { request: Pe, pairingTopic: Be, transportType: Te = M$1.relay } = Ie;
      this.client.core.expirer.set(Me, Pe.expiryTimestamp), await this.client.auth.requests.set(Me, { authPayload: Pe.authPayload, requester: Pe.requester, expiryTimestamp: Pe.expiryTimestamp, id: Me, pairingTopic: Be, verifyContext: Pe.verifyContext, transportType: Te });
    }, this.setPendingSessionRequest = async (Me) => {
      const { id: Ie, topic: Pe, params: Be, verifyContext: Te } = Me, je = Be.request.expiryTimestamp || Mt$2(v$1.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(Ie, je), await this.client.pendingRequest.set(Ie, { id: Ie, topic: Pe, params: Be, verifyContext: Te });
    }, this.sendRequest = async (Me) => {
      const { topic: Ie, method: Pe, params: Be, expiry: Te, relayRpcId: je, clientRpcId: Ve, throwOnFailedPublish: fi, appLink: Ue } = Me, bi = formatJsonRpcRequest(Pe, Be, Ve);
      let vi;
      const mi = !!Ue;
      try {
        const Ci = mi ? lr$2 : ge$1;
        vi = await this.client.core.crypto.encode(Ie, bi, { encoding: Ci });
      } catch (Ci) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${Ie} failed`), Ci;
      }
      let _i;
      if (at.includes(Pe)) {
        const Ci = yr$2(JSON.stringify(bi)), Ui = yr$2(vi);
        _i = await this.client.core.verify.register({ id: Ui, decryptedId: Ci });
      }
      const $i = v$1[Pe].req;
      if ($i.attestation = _i, Te && ($i.ttl = Te), je && ($i.id = je), this.client.core.history.set(Ie, bi), mi) {
        const Ci = xr$2(Ue, Ie, vi);
        await global.Linking.openURL(Ci, this.client.name);
      } else {
        const Ci = v$1[Pe].req;
        Te && (Ci.ttl = Te), je && (Ci.id = je), fi ? (Ci.internal = D$1(I({}, Ci.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(Ie, vi, Ci)) : this.client.core.relayer.publish(Ie, vi, Ci).catch((Ui) => this.client.logger.error(Ui));
      }
      return bi.id;
    }, this.sendResult = async (Me) => {
      const { id: Ie, topic: Pe, result: Be, throwOnFailedPublish: Te, encodeOpts: je, appLink: Ve } = Me, fi = formatJsonRpcResult(Ie, Be);
      let Ue;
      const bi = Ve && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const mi = bi ? lr$2 : ge$1;
        Ue = await this.client.core.crypto.encode(Pe, fi, D$1(I({}, je || {}), { encoding: mi }));
      } catch (mi) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${Pe} failed`), mi;
      }
      let vi;
      try {
        vi = await this.client.core.history.get(Pe, Ie);
      } catch (mi) {
        throw this.client.logger.error(`sendResult() -> history.get(${Pe}, ${Ie}) failed`), mi;
      }
      if (bi) {
        const mi = xr$2(Ve, Pe, Ue);
        await global.Linking.openURL(mi, this.client.name);
      } else {
        const mi = v$1[vi.request.method].res;
        Te ? (mi.internal = D$1(I({}, mi.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(Pe, Ue, mi)) : this.client.core.relayer.publish(Pe, Ue, mi).catch((_i) => this.client.logger.error(_i));
      }
      await this.client.core.history.resolve(fi);
    }, this.sendError = async (Me) => {
      const { id: Ie, topic: Pe, error: Be, encodeOpts: Te, rpcOpts: je, appLink: Ve } = Me, fi = formatJsonRpcError(Ie, Be);
      let Ue;
      const bi = Ve && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const mi = bi ? lr$2 : ge$1;
        Ue = await this.client.core.crypto.encode(Pe, fi, D$1(I({}, Te || {}), { encoding: mi }));
      } catch (mi) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${Pe} failed`), mi;
      }
      let vi;
      try {
        vi = await this.client.core.history.get(Pe, Ie);
      } catch (mi) {
        throw this.client.logger.error(`sendError() -> history.get(${Pe}, ${Ie}) failed`), mi;
      }
      if (bi) {
        const mi = xr$2(Ve, Pe, Ue);
        await global.Linking.openURL(mi, this.client.name);
      } else {
        const mi = je || v$1[vi.request.method].res;
        this.client.core.relayer.publish(Pe, Ue, mi);
      }
      await this.client.core.history.resolve(fi);
    }, this.cleanup = async () => {
      const Me = [], Ie = [];
      this.client.session.getAll().forEach((Pe) => {
        let Be = !1;
        Kt$2(Pe.expiry) && (Be = !0), this.client.core.crypto.keychain.has(Pe.topic) || (Be = !0), Be && Me.push(Pe.topic);
      }), this.client.proposal.getAll().forEach((Pe) => {
        Kt$2(Pe.expiryTimestamp) && Ie.push(Pe.id);
      }), await Promise.all([...Me.map((Pe) => this.deleteSession({ topic: Pe })), ...Ie.map((Pe) => this.deleteProposal(Pe))]);
    }, this.onRelayEventRequest = async (Me) => {
      this.requestQueue.queue.push(Me), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === x$1.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = x$1.active;
        const Me = this.requestQueue.queue.shift();
        if (Me) try {
          await this.processRequest(Me);
        } catch (Ie) {
          this.client.logger.warn(Ie);
        }
      }
      this.requestQueue.state = x$1.idle;
    }, this.processRequest = async (Me) => {
      const { topic: Ie, payload: Pe, attestation: Be, transportType: Te, encryptedId: je } = Me, Ve = Pe.method;
      if (!this.shouldIgnorePairingRequest({ topic: Ie, requestMethod: Ve })) switch (Ve) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: Ie, payload: Pe, attestation: Be, encryptedId: je });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(Ie, Pe);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(Ie, Pe);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(Ie, Pe);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(Ie, Pe);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(Ie, Pe);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: Ie, payload: Pe, attestation: Be, encryptedId: je, transportType: Te });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(Ie, Pe);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: Ie, payload: Pe, attestation: Be, encryptedId: je, transportType: Te });
        default:
          return this.client.logger.info(`Unsupported request method ${Ve}`);
      }
    }, this.onRelayEventResponse = async (Me) => {
      const { topic: Ie, payload: Pe, transportType: Be } = Me, Te = (await this.client.core.history.get(Ie, Pe.id)).request.method;
      switch (Te) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(Ie, Pe, Be);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(Ie, Pe);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(Ie, Pe);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(Ie, Pe);
        case "wc_sessionPing":
          return this.onSessionPingResponse(Ie, Pe);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(Ie, Pe);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(Ie, Pe);
        default:
          return this.client.logger.info(`Unsupported response method ${Te}`);
      }
    }, this.onRelayEventUnknownPayload = (Me) => {
      const { topic: Ie } = Me, { message: Pe } = S$4("MISSING_OR_INVALID", `Decoded payload on topic ${Ie} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(Pe);
    }, this.shouldIgnorePairingRequest = (Me) => {
      const { topic: Ie, requestMethod: Pe } = Me, Be = this.expectedPairingMethodMap.get(Ie);
      return !Be || Be.includes(Pe) ? !1 : !!(Be.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }, this.onSessionProposeRequest = async (Me) => {
      const { topic: Ie, payload: Pe, attestation: Be, encryptedId: Te } = Me, { params: je, id: Ve } = Pe;
      try {
        const fi = this.client.core.eventClient.getEvent({ topic: Ie });
        this.isValidConnect(I({}, Pe.params));
        const Ue = je.expiryTimestamp || Mt$2(v$1.wc_sessionPropose.req.ttl), bi = I({ id: Ve, pairingTopic: Ie, expiryTimestamp: Ue }, je);
        await this.setProposal(Ve, bi);
        const vi = await this.getVerifyContext({ attestationId: Be, hash: yr$2(JSON.stringify(Pe)), encryptedId: Te, metadata: bi.proposer.metadata });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), fi == null || fi.setError($$1.proposal_listener_not_found)), fi == null || fi.addTrace(z$3.emit_session_proposal), this.client.events.emit("session_proposal", { id: Ve, params: bi, verifyContext: vi });
      } catch (fi) {
        await this.sendError({ id: Ve, topic: Ie, error: fi, rpcOpts: v$1.wc_sessionPropose.autoReject }), this.client.logger.error(fi);
      }
    }, this.onSessionProposeResponse = async (Me, Ie, Pe) => {
      const { id: Be } = Ie;
      if (isJsonRpcResult(Ie)) {
        const { result: Te } = Ie;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: Te });
        const je = this.client.proposal.get(Be);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: je });
        const Ve = je.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: Ve });
        const fi = Te.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: fi });
        const Ue = await this.client.core.crypto.generateSharedKey(Ve, fi);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: Ue });
        const bi = await this.client.core.relayer.subscribe(Ue, { transportType: Pe });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: bi }), await this.client.core.pairing.activate({ topic: Me });
      } else if (isJsonRpcError(Ie)) {
        await this.client.proposal.delete(Be, U$2("USER_DISCONNECTED"));
        const Te = Lt$2("session_connect");
        if (this.events.listenerCount(Te) === 0) throw new Error(`emitting ${Te} without any listeners, 954`);
        this.events.emit(Lt$2("session_connect"), { error: Ie.error });
      }
    }, this.onSessionSettleRequest = async (Me, Ie) => {
      const { id: Pe, params: Be } = Ie;
      try {
        this.isValidSessionSettleRequest(Be);
        const { relay: Te, controller: je, expiry: Ve, namespaces: fi, sessionProperties: Ue, sessionConfig: bi } = Ie.params, vi = D$1(I(I({ topic: Me, relay: Te, expiry: Ve, namespaces: fi, acknowledged: !0, pairingTopic: "", requiredNamespaces: {}, optionalNamespaces: {}, controller: je.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: je.publicKey, metadata: je.metadata } }, Ue && { sessionProperties: Ue }), bi && { sessionConfig: bi }), { transportType: M$1.relay }), mi = Lt$2("session_connect");
        if (this.events.listenerCount(mi) === 0) throw new Error(`emitting ${mi} without any listeners 997`);
        this.events.emit(Lt$2("session_connect"), { session: vi }), await this.sendResult({ id: Ie.id, topic: Me, result: !0, throwOnFailedPublish: !0 });
      } catch (Te) {
        await this.sendError({ id: Pe, topic: Me, error: Te }), this.client.logger.error(Te);
      }
    }, this.onSessionSettleResponse = async (Me, Ie) => {
      const { id: Pe } = Ie;
      isJsonRpcResult(Ie) ? (await this.client.session.update(Me, { acknowledged: !0 }), this.events.emit(Lt$2("session_approve", Pe), {})) : isJsonRpcError(Ie) && (await this.client.session.delete(Me, U$2("USER_DISCONNECTED")), this.events.emit(Lt$2("session_approve", Pe), { error: Ie.error }));
    }, this.onSessionUpdateRequest = async (Me, Ie) => {
      const { params: Pe, id: Be } = Ie;
      try {
        const Te = `${Me}_session_update`, je = yo.get(Te);
        if (je && this.isRequestOutOfSync(je, Be)) {
          this.client.logger.info(`Discarding out of sync request - ${Be}`), this.sendError({ id: Be, topic: Me, error: U$2("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(I({ topic: Me }, Pe));
        try {
          yo.set(Te, Be), await this.client.session.update(Me, { namespaces: Pe.namespaces }), await this.sendResult({ id: Be, topic: Me, result: !0, throwOnFailedPublish: !0 });
        } catch (Ve) {
          throw yo.delete(Te), Ve;
        }
        this.client.events.emit("session_update", { id: Be, topic: Me, params: Pe });
      } catch (Te) {
        await this.sendError({ id: Be, topic: Me, error: Te }), this.client.logger.error(Te);
      }
    }, this.isRequestOutOfSync = (Me, Ie) => parseInt(Ie.toString().slice(0, -3)) <= parseInt(Me.toString().slice(0, -3)), this.onSessionUpdateResponse = (Me, Ie) => {
      const { id: Pe } = Ie, Be = Lt$2("session_update", Pe);
      if (this.events.listenerCount(Be) === 0) throw new Error(`emitting ${Be} without any listeners`);
      isJsonRpcResult(Ie) ? this.events.emit(Lt$2("session_update", Pe), {}) : isJsonRpcError(Ie) && this.events.emit(Lt$2("session_update", Pe), { error: Ie.error });
    }, this.onSessionExtendRequest = async (Me, Ie) => {
      const { id: Pe } = Ie;
      try {
        this.isValidExtend({ topic: Me }), await this.setExpiry(Me, Mt$2(z$1)), await this.sendResult({ id: Pe, topic: Me, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_extend", { id: Pe, topic: Me });
      } catch (Be) {
        await this.sendError({ id: Pe, topic: Me, error: Be }), this.client.logger.error(Be);
      }
    }, this.onSessionExtendResponse = (Me, Ie) => {
      const { id: Pe } = Ie, Be = Lt$2("session_extend", Pe);
      if (this.events.listenerCount(Be) === 0) throw new Error(`emitting ${Be} without any listeners`);
      isJsonRpcResult(Ie) ? this.events.emit(Lt$2("session_extend", Pe), {}) : isJsonRpcError(Ie) && this.events.emit(Lt$2("session_extend", Pe), { error: Ie.error });
    }, this.onSessionPingRequest = async (Me, Ie) => {
      const { id: Pe } = Ie;
      try {
        this.isValidPing({ topic: Me }), await this.sendResult({ id: Pe, topic: Me, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_ping", { id: Pe, topic: Me });
      } catch (Be) {
        await this.sendError({ id: Pe, topic: Me, error: Be }), this.client.logger.error(Be);
      }
    }, this.onSessionPingResponse = (Me, Ie) => {
      const { id: Pe } = Ie, Be = Lt$2("session_ping", Pe);
      if (this.events.listenerCount(Be) === 0) throw new Error(`emitting ${Be} without any listeners`);
      setTimeout(() => {
        isJsonRpcResult(Ie) ? this.events.emit(Lt$2("session_ping", Pe), {}) : isJsonRpcError(Ie) && this.events.emit(Lt$2("session_ping", Pe), { error: Ie.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (Me, Ie) => {
      const { id: Pe } = Ie;
      try {
        this.isValidDisconnect({ topic: Me, reason: Ie.params }), Promise.all([new Promise((Be) => {
          this.client.core.relayer.once(v$2.publish, async () => {
            Be(await this.deleteSession({ topic: Me, id: Pe }));
          });
        }), this.sendResult({ id: Pe, topic: Me, result: !0, throwOnFailedPublish: !0 }), this.cleanupPendingSentRequestsForTopic({ topic: Me, error: U$2("USER_DISCONNECTED") })]).catch((Be) => this.client.logger.error(Be));
      } catch (Be) {
        this.client.logger.error(Be);
      }
    }, this.onSessionRequest = async (Me) => {
      var Ie, Pe, Be;
      const { topic: Te, payload: je, attestation: Ve, encryptedId: fi, transportType: Ue } = Me, { id: bi, params: vi } = je;
      try {
        await this.isValidRequest(I({ topic: Te }, vi));
        const mi = this.client.session.get(Te), _i = await this.getVerifyContext({ attestationId: Ve, hash: yr$2(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", vi, bi))), encryptedId: fi, metadata: mi.peer.metadata, transportType: Ue }), $i = { id: bi, topic: Te, params: vi, verifyContext: _i };
        await this.setPendingSessionRequest($i), Ue === M$1.link_mode && (Ie = mi.peer.metadata.redirect) != null && Ie.universal && this.client.core.addLinkModeSupportedApp((Pe = mi.peer.metadata.redirect) == null ? void 0 : Pe.universal), (Be = this.client.signConfig) != null && Be.disableRequestQueue ? this.emitSessionRequest($i) : (this.addSessionRequestToSessionRequestQueue($i), this.processSessionRequestQueue());
      } catch (mi) {
        await this.sendError({ id: bi, topic: Te, error: mi }), this.client.logger.error(mi);
      }
    }, this.onSessionRequestResponse = (Me, Ie) => {
      const { id: Pe } = Ie, Be = Lt$2("session_request", Pe);
      if (this.events.listenerCount(Be) === 0) throw new Error(`emitting ${Be} without any listeners`);
      isJsonRpcResult(Ie) ? this.events.emit(Lt$2("session_request", Pe), { result: Ie.result }) : isJsonRpcError(Ie) && this.events.emit(Lt$2("session_request", Pe), { error: Ie.error });
    }, this.onSessionEventRequest = async (Me, Ie) => {
      const { id: Pe, params: Be } = Ie;
      try {
        const Te = `${Me}_session_event_${Be.event.name}`, je = yo.get(Te);
        if (je && this.isRequestOutOfSync(je, Pe)) {
          this.client.logger.info(`Discarding out of sync request - ${Pe}`);
          return;
        }
        this.isValidEmit(I({ topic: Me }, Be)), this.client.events.emit("session_event", { id: Pe, topic: Me, params: Be }), yo.set(Te, Pe);
      } catch (Te) {
        await this.sendError({ id: Pe, topic: Me, error: Te }), this.client.logger.error(Te);
      }
    }, this.onSessionAuthenticateResponse = (Me, Ie) => {
      const { id: Pe } = Ie;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: Me, payload: Ie }), isJsonRpcResult(Ie) ? this.events.emit(Lt$2("session_request", Pe), { result: Ie.result }) : isJsonRpcError(Ie) && this.events.emit(Lt$2("session_request", Pe), { error: Ie.error });
    }, this.onSessionAuthenticateRequest = async (Me) => {
      var Ie;
      const { topic: Pe, payload: Be, attestation: Te, encryptedId: je, transportType: Ve } = Me;
      try {
        const { requester: fi, authPayload: Ue, expiryTimestamp: bi } = Be.params, vi = await this.getVerifyContext({ attestationId: Te, hash: yr$2(JSON.stringify(Be)), encryptedId: je, metadata: fi.metadata, transportType: Ve }), mi = { requester: fi, pairingTopic: Pe, id: Be.id, authPayload: Ue, verifyContext: vi, expiryTimestamp: bi };
        await this.setAuthRequest(Be.id, { request: mi, pairingTopic: Pe, transportType: Ve }), Ve === M$1.link_mode && (Ie = fi.metadata.redirect) != null && Ie.universal && this.client.core.addLinkModeSupportedApp(fi.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: Pe, params: Be.params, id: Be.id, verifyContext: vi });
      } catch (fi) {
        this.client.logger.error(fi);
        const Ue = Be.params.requester.publicKey, bi = await this.client.core.crypto.generateKeyPair(), vi = this.getAppLinkIfEnabled(Be.params.requester.metadata, Ve), mi = { type: D$2, receiverPublicKey: Ue, senderPublicKey: bi };
        await this.sendError({ id: Be.id, topic: Pe, error: fi, encodeOpts: mi, rpcOpts: v$1.wc_sessionAuthenticate.autoReject, appLink: vi });
      }
    }, this.addSessionRequestToSessionRequestQueue = (Me) => {
      this.sessionRequestQueue.queue.push(Me);
    }, this.cleanupAfterResponse = (Me) => {
      this.deletePendingSessionRequest(Me.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = x$1.idle, this.processSessionRequestQueue();
      }, cjs$3.toMiliseconds(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: Me, error: Ie }) => {
      const Pe = this.client.core.history.pending;
      Pe.length > 0 && Pe.filter((Be) => Be.topic === Me && Be.request.method === "wc_sessionRequest").forEach((Be) => {
        const Te = Be.request.id, je = Lt$2("session_request", Te);
        if (this.events.listenerCount(je) === 0) throw new Error(`emitting ${je} without any listeners`);
        this.events.emit(Lt$2("session_request", Be.request.id), { error: Ie });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === x$1.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const Me = this.sessionRequestQueue.queue[0];
      if (!Me) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = x$1.active, this.emitSessionRequest(Me);
      } catch (Ie) {
        this.client.logger.error(Ie);
      }
    }, this.emitSessionRequest = (Me) => {
      this.client.events.emit("session_request", Me);
    }, this.onPairingCreated = (Me) => {
      if (Me.methods && this.expectedPairingMethodMap.set(Me.topic, Me.methods), Me.active) return;
      const Ie = this.client.proposal.getAll().find((Pe) => Pe.pairingTopic === Me.topic);
      Ie && this.onSessionProposeRequest({ topic: Me.topic, payload: formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: Ie.requiredNamespaces, optionalNamespaces: Ie.optionalNamespaces, relays: Ie.relays, proposer: Ie.proposer, sessionProperties: Ie.sessionProperties }, Ie.id) });
    }, this.isValidConnect = async (Me) => {
      if (!to(Me)) {
        const { message: Ve } = S$4("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(Me)}`);
        throw new Error(Ve);
      }
      const { pairingTopic: Ie, requiredNamespaces: Pe, optionalNamespaces: Be, sessionProperties: Te, relays: je } = Me;
      if (I$3(Ie) || await this.isValidPairingTopic(Ie), !eo(je)) {
        const { message: Ve } = S$4("MISSING_OR_INVALID", `connect() relays: ${je}`);
        throw new Error(Ve);
      }
      !I$3(Pe) && Z$3(Pe) !== 0 && this.validateNamespaces(Pe, "requiredNamespaces"), !I$3(Be) && Z$3(Be) !== 0 && this.validateNamespaces(Be, "optionalNamespaces"), I$3(Te) || this.validateSessionProps(Te, "sessionProperties");
    }, this.validateNamespaces = (Me, Ie) => {
      const Pe = Xr$1(Me, "connect()", Ie);
      if (Pe) throw new Error(Pe.message);
    }, this.isValidApprove = async (Me) => {
      if (!to(Me)) throw new Error(S$4("MISSING_OR_INVALID", `approve() params: ${Me}`).message);
      const { id: Ie, namespaces: Pe, relayProtocol: Be, sessionProperties: Te } = Me;
      this.checkRecentlyDeleted(Ie), await this.isValidProposalId(Ie);
      const je = this.client.proposal.get(Ie), Ve = Wn(Pe, "approve()");
      if (Ve) throw new Error(Ve.message);
      const fi = zn(je.requiredNamespaces, Pe, "approve()");
      if (fi) throw new Error(fi.message);
      if (!b$2(Be, !0)) {
        const { message: Ue } = S$4("MISSING_OR_INVALID", `approve() relayProtocol: ${Be}`);
        throw new Error(Ue);
      }
      I$3(Te) || this.validateSessionProps(Te, "sessionProperties");
    }, this.isValidReject = async (Me) => {
      if (!to(Me)) {
        const { message: Be } = S$4("MISSING_OR_INVALID", `reject() params: ${Me}`);
        throw new Error(Be);
      }
      const { id: Ie, reason: Pe } = Me;
      if (this.checkRecentlyDeleted(Ie), await this.isValidProposalId(Ie), !ro(Pe)) {
        const { message: Be } = S$4("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(Pe)}`);
        throw new Error(Be);
      }
    }, this.isValidSessionSettleRequest = (Me) => {
      if (!to(Me)) {
        const { message: fi } = S$4("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${Me}`);
        throw new Error(fi);
      }
      const { relay: Ie, controller: Pe, namespaces: Be, expiry: Te } = Me;
      if (!Jn(Ie)) {
        const { message: fi } = S$4("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(fi);
      }
      const je = Zr$1(Pe, "onSessionSettleRequest()");
      if (je) throw new Error(je.message);
      const Ve = Wn(Be, "onSessionSettleRequest()");
      if (Ve) throw new Error(Ve.message);
      if (Kt$2(Te)) {
        const { message: fi } = S$4("EXPIRED", "onSessionSettleRequest()");
        throw new Error(fi);
      }
    }, this.isValidUpdate = async (Me) => {
      if (!to(Me)) {
        const { message: Ve } = S$4("MISSING_OR_INVALID", `update() params: ${Me}`);
        throw new Error(Ve);
      }
      const { topic: Ie, namespaces: Pe } = Me;
      this.checkRecentlyDeleted(Ie), await this.isValidSessionTopic(Ie);
      const Be = this.client.session.get(Ie), Te = Wn(Pe, "update()");
      if (Te) throw new Error(Te.message);
      const je = zn(Be.requiredNamespaces, Pe, "update()");
      if (je) throw new Error(je.message);
    }, this.isValidExtend = async (Me) => {
      if (!to(Me)) {
        const { message: Pe } = S$4("MISSING_OR_INVALID", `extend() params: ${Me}`);
        throw new Error(Pe);
      }
      const { topic: Ie } = Me;
      this.checkRecentlyDeleted(Ie), await this.isValidSessionTopic(Ie);
    }, this.isValidRequest = async (Me) => {
      if (!to(Me)) {
        const { message: Ve } = S$4("MISSING_OR_INVALID", `request() params: ${Me}`);
        throw new Error(Ve);
      }
      const { topic: Ie, request: Pe, chainId: Be, expiry: Te } = Me;
      this.checkRecentlyDeleted(Ie), await this.isValidSessionTopic(Ie);
      const { namespaces: je } = this.client.session.get(Ie);
      if (!co(je, Be)) {
        const { message: Ve } = S$4("MISSING_OR_INVALID", `request() chainId: ${Be}`);
        throw new Error(Ve);
      }
      if (!oo(Pe)) {
        const { message: Ve } = S$4("MISSING_OR_INVALID", `request() ${JSON.stringify(Pe)}`);
        throw new Error(Ve);
      }
      if (!ao(je, Be, Pe.method)) {
        const { message: Ve } = S$4("MISSING_OR_INVALID", `request() method: ${Pe.method}`);
        throw new Error(Ve);
      }
      if (Te && !po(Te, me)) {
        const { message: Ve } = S$4("MISSING_OR_INVALID", `request() expiry: ${Te}. Expiry must be a number (in seconds) between ${me.min} and ${me.max}`);
        throw new Error(Ve);
      }
    }, this.isValidRespond = async (Me) => {
      var Ie;
      if (!to(Me)) {
        const { message: Te } = S$4("MISSING_OR_INVALID", `respond() params: ${Me}`);
        throw new Error(Te);
      }
      const { topic: Pe, response: Be } = Me;
      try {
        await this.isValidSessionTopic(Pe);
      } catch (Te) {
        throw (Ie = Me == null ? void 0 : Me.response) != null && Ie.id && this.cleanupAfterResponse(Me), Te;
      }
      if (!so(Be)) {
        const { message: Te } = S$4("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(Be)}`);
        throw new Error(Te);
      }
    }, this.isValidPing = async (Me) => {
      if (!to(Me)) {
        const { message: Pe } = S$4("MISSING_OR_INVALID", `ping() params: ${Me}`);
        throw new Error(Pe);
      }
      const { topic: Ie } = Me;
      await this.isValidSessionOrPairingTopic(Ie);
    }, this.isValidEmit = async (Me) => {
      if (!to(Me)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `emit() params: ${Me}`);
        throw new Error(je);
      }
      const { topic: Ie, event: Pe, chainId: Be } = Me;
      await this.isValidSessionTopic(Ie);
      const { namespaces: Te } = this.client.session.get(Ie);
      if (!co(Te, Be)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `emit() chainId: ${Be}`);
        throw new Error(je);
      }
      if (!io(Pe)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(Pe)}`);
        throw new Error(je);
      }
      if (!uo(Te, Be, Pe.name)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(Pe)}`);
        throw new Error(je);
      }
    }, this.isValidDisconnect = async (Me) => {
      if (!to(Me)) {
        const { message: Pe } = S$4("MISSING_OR_INVALID", `disconnect() params: ${Me}`);
        throw new Error(Pe);
      }
      const { topic: Ie } = Me;
      await this.isValidSessionOrPairingTopic(Ie);
    }, this.isValidAuthenticate = (Me) => {
      const { chains: Ie, uri: Pe, domain: Be, nonce: Te } = Me;
      if (!Array.isArray(Ie) || Ie.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!b$2(Pe, !1)) throw new Error("uri is required parameter");
      if (!b$2(Be, !1)) throw new Error("domain is required parameter");
      if (!b$2(Te, !1)) throw new Error("nonce is required parameter");
      if ([...new Set(Ie.map((Ve) => re$2(Ve).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: je } = re$2(Ie[0]);
      if (je !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }, this.getVerifyContext = async (Me) => {
      const { attestationId: Ie, hash: Pe, encryptedId: Be, metadata: Te, transportType: je } = Me, Ve = { verified: { verifyUrl: Te.verifyUrl || J$1, validation: "UNKNOWN", origin: Te.url || "" } };
      try {
        if (je === M$1.link_mode) {
          const Ue = this.getAppLinkIfEnabled(Te, je);
          return Ve.verified.validation = Ue && new URL(Ue).origin === new URL(Te.url).origin ? "VALID" : "INVALID", Ve;
        }
        const fi = await this.client.core.verify.resolve({ attestationId: Ie, hash: Pe, encryptedId: Be, verifyUrl: Te.verifyUrl });
        fi && (Ve.verified.origin = fi.origin, Ve.verified.isScam = fi.isScam, Ve.verified.validation = fi.origin === new URL(Te.url).origin ? "VALID" : "INVALID");
      } catch (fi) {
        this.client.logger.warn(fi);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(Ve)}`), Ve;
    }, this.validateSessionProps = (Me, Ie) => {
      Object.values(Me).forEach((Pe) => {
        if (!b$2(Pe, !1)) {
          const { message: Be } = S$4("MISSING_OR_INVALID", `${Ie} must be in Record<string, string> format. Received: ${JSON.stringify(Pe)}`);
          throw new Error(Be);
        }
      });
    }, this.getPendingAuthRequest = (Me) => {
      const Ie = this.client.auth.requests.get(Me);
      return typeof Ie == "object" ? Ie : void 0;
    }, this.addToRecentlyDeleted = (Me, Ie) => {
      if (this.recentlyDeletedMap.set(Me, Ie), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let Pe = 0;
        const Be = this.recentlyDeletedLimit / 2;
        for (const Te of this.recentlyDeletedMap.keys()) {
          if (Pe++ >= Be) break;
          this.recentlyDeletedMap.delete(Te);
        }
      }
    }, this.checkRecentlyDeleted = (Me) => {
      const Ie = this.recentlyDeletedMap.get(Me);
      if (Ie) {
        const { message: Pe } = S$4("MISSING_OR_INVALID", `Record was recently deleted - ${Ie}: ${Me}`);
        throw new Error(Pe);
      }
    }, this.isLinkModeEnabled = (Me, Ie) => {
      var Pe, Be, Te, je, Ve, fi, Ue, bi, vi;
      return !Me || Ie !== M$1.link_mode ? !1 : ((Be = (Pe = this.client.metadata) == null ? void 0 : Pe.redirect) == null ? void 0 : Be.linkMode) === !0 && ((je = (Te = this.client.metadata) == null ? void 0 : Te.redirect) == null ? void 0 : je.universal) !== void 0 && ((fi = (Ve = this.client.metadata) == null ? void 0 : Ve.redirect) == null ? void 0 : fi.universal) !== "" && ((Ue = Me == null ? void 0 : Me.redirect) == null ? void 0 : Ue.universal) !== void 0 && ((bi = Me == null ? void 0 : Me.redirect) == null ? void 0 : bi.universal) !== "" && ((vi = Me == null ? void 0 : Me.redirect) == null ? void 0 : vi.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(Me.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }, this.getAppLinkIfEnabled = (Me, Ie) => {
      var Pe;
      return this.isLinkModeEnabled(Me, Ie) ? (Pe = Me == null ? void 0 : Me.redirect) == null ? void 0 : Pe.universal : void 0;
    }, this.handleLinkModeMessage = ({ url: Me }) => {
      if (!Me || !Me.includes("wc_ev") || !Me.includes("topic")) return;
      const Ie = Bt$2(Me, "topic") || "", Pe = decodeURIComponent(Bt$2(Me, "wc_ev") || ""), Be = this.client.session.keys.includes(Ie);
      Be && this.client.session.update(Ie, { transportType: M$1.link_mode }), this.client.core.dispatchEnvelope({ topic: Ie, message: Pe, sessionExists: Be });
    }, this.registerLinkModeListeners = async () => {
      var Me;
      if (Wt$2() || _$1() && (Me = this.client.metadata.redirect) != null && Me.linkMode) {
        const Ie = global == null ? void 0 : global.Linking;
        if (typeof Ie < "u") {
          Ie.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const Pe = await Ie.getInitialURL();
          Pe && setTimeout(() => {
            this.handleLinkModeMessage({ url: Pe });
          }, 50);
        }
      }
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(v$2.message, (t) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(t) : this.onRelayMessage(t);
    });
  }
  async onRelayMessage(t) {
    const { topic: Me, message: Ie, attestation: Pe, transportType: Be } = t, { publicKey: Te } = this.client.auth.authKeys.keys.includes(ae) ? this.client.auth.authKeys.get(ae) : { responseTopic: void 0, publicKey: void 0 }, je = await this.client.core.crypto.decode(Me, Ie, { receiverPublicKey: Te, encoding: Be === M$1.link_mode ? lr$2 : ge$1 });
    try {
      isJsonRpcRequest(je) ? (this.client.core.history.set(Me, je), this.onRelayEventRequest({ topic: Me, payload: je, attestation: Pe, transportType: Be, encryptedId: yr$2(Ie) })) : isJsonRpcResponse(je) ? (await this.client.core.history.resolve(je), await this.onRelayEventResponse({ topic: Me, payload: je, transportType: Be }), this.client.core.history.delete(Me, je.id)) : this.onRelayEventUnknownPayload({ topic: Me, payload: je, transportType: Be });
    } catch (Ve) {
      this.client.logger.error(Ve);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(S$2.expired, async (t) => {
      const { topic: Me, id: Ie } = Vt$2(t.target);
      if (Ie && this.client.pendingRequest.keys.includes(Ie)) return await this.deletePendingSessionRequest(Ie, S$4("EXPIRED"), !0);
      if (Ie && this.client.auth.requests.keys.includes(Ie)) return await this.deletePendingAuthRequest(Ie, S$4("EXPIRED"), !0);
      Me ? this.client.session.keys.includes(Me) && (await this.deleteSession({ topic: Me, expirerHasDeleted: !0 }), this.client.events.emit("session_expire", { topic: Me })) : Ie && (await this.deleteProposal(Ie, !0), this.client.events.emit("proposal_expire", { id: Ie }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(V$2.create, (t) => this.onPairingCreated(t)), this.client.core.pairing.events.on(V$2.delete, (t) => {
      this.addToRecentlyDeleted(t.topic, "pairing");
    });
  }
  isValidPairingTopic(t) {
    if (!b$2(t, !1)) {
      const { message: Me } = S$4("MISSING_OR_INVALID", `pairing topic should be a string: ${t}`);
      throw new Error(Me);
    }
    if (!this.client.core.pairing.pairings.keys.includes(t)) {
      const { message: Me } = S$4("NO_MATCHING_KEY", `pairing topic doesn't exist: ${t}`);
      throw new Error(Me);
    }
    if (Kt$2(this.client.core.pairing.pairings.get(t).expiry)) {
      const { message: Me } = S$4("EXPIRED", `pairing topic: ${t}`);
      throw new Error(Me);
    }
  }
  async isValidSessionTopic(t) {
    if (!b$2(t, !1)) {
      const { message: Me } = S$4("MISSING_OR_INVALID", `session topic should be a string: ${t}`);
      throw new Error(Me);
    }
    if (this.checkRecentlyDeleted(t), !this.client.session.keys.includes(t)) {
      const { message: Me } = S$4("NO_MATCHING_KEY", `session topic doesn't exist: ${t}`);
      throw new Error(Me);
    }
    if (Kt$2(this.client.session.get(t).expiry)) {
      await this.deleteSession({ topic: t });
      const { message: Me } = S$4("EXPIRED", `session topic: ${t}`);
      throw new Error(Me);
    }
    if (!this.client.core.crypto.keychain.has(t)) {
      const { message: Me } = S$4("MISSING_OR_INVALID", `session topic does not exist in keychain: ${t}`);
      throw await this.deleteSession({ topic: t }), new Error(Me);
    }
  }
  async isValidSessionOrPairingTopic(t) {
    if (this.checkRecentlyDeleted(t), this.client.session.keys.includes(t)) await this.isValidSessionTopic(t);
    else if (this.client.core.pairing.pairings.keys.includes(t)) this.isValidPairingTopic(t);
    else if (b$2(t, !1)) {
      const { message: Me } = S$4("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${t}`);
      throw new Error(Me);
    } else {
      const { message: Me } = S$4("MISSING_OR_INVALID", `session or pairing topic should be a string: ${t}`);
      throw new Error(Me);
    }
  }
  async isValidProposalId(t) {
    if (!no(t)) {
      const { message: Me } = S$4("MISSING_OR_INVALID", `proposal id should be a number: ${t}`);
      throw new Error(Me);
    }
    if (!this.client.proposal.keys.includes(t)) {
      const { message: Me } = S$4("NO_MATCHING_KEY", `proposal id doesn't exist: ${t}`);
      throw new Error(Me);
    }
    if (Kt$2(this.client.proposal.get(t).expiryTimestamp)) {
      await this.deleteProposal(t);
      const { message: Me } = S$4("EXPIRED", `proposal id: ${t}`);
      throw new Error(Me);
    }
  }
}
class Ss extends ni {
  constructor(t, Me) {
    super(t, Me, st, ye), this.core = t, this.logger = Me;
  }
}
class yt extends ni {
  constructor(t, Me) {
    super(t, Me, rt, ye), this.core = t, this.logger = Me;
  }
}
class Is extends ni {
  constructor(t, Me) {
    super(t, Me, ot, ye, (Ie) => Ie.id), this.core = t, this.logger = Me;
  }
}
class fs extends ni {
  constructor(t, Me) {
    super(t, Me, pt, oe, () => ae), this.core = t, this.logger = Me;
  }
}
class vs extends ni {
  constructor(t, Me) {
    super(t, Me, ht, oe), this.core = t, this.logger = Me;
  }
}
class qs extends ni {
  constructor(t, Me) {
    super(t, Me, dt, oe, (Ie) => Ie.id), this.core = t, this.logger = Me;
  }
}
class Ts {
  constructor(t, Me) {
    this.core = t, this.logger = Me, this.authKeys = new fs(this.core, this.logger), this.pairingTopics = new vs(this.core, this.logger), this.requests = new qs(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
}
class _e extends S$5 {
  constructor(t) {
    super(t), this.protocol = be, this.version = Ce, this.name = we.name, this.events = new eventsExports.EventEmitter(), this.on = (Ie, Pe) => this.events.on(Ie, Pe), this.once = (Ie, Pe) => this.events.once(Ie, Pe), this.off = (Ie, Pe) => this.events.off(Ie, Pe), this.removeListener = (Ie, Pe) => this.events.removeListener(Ie, Pe), this.removeAllListeners = (Ie) => this.events.removeAllListeners(Ie), this.connect = async (Ie) => {
      try {
        return await this.engine.connect(Ie);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.pair = async (Ie) => {
      try {
        return await this.engine.pair(Ie);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.approve = async (Ie) => {
      try {
        return await this.engine.approve(Ie);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.reject = async (Ie) => {
      try {
        return await this.engine.reject(Ie);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.update = async (Ie) => {
      try {
        return await this.engine.update(Ie);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.extend = async (Ie) => {
      try {
        return await this.engine.extend(Ie);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.request = async (Ie) => {
      try {
        return await this.engine.request(Ie);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.respond = async (Ie) => {
      try {
        return await this.engine.respond(Ie);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.ping = async (Ie) => {
      try {
        return await this.engine.ping(Ie);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.emit = async (Ie) => {
      try {
        return await this.engine.emit(Ie);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.disconnect = async (Ie) => {
      try {
        return await this.engine.disconnect(Ie);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.find = (Ie) => {
      try {
        return this.engine.find(Ie);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.authenticate = async (Ie, Pe) => {
      try {
        return await this.engine.authenticate(Ie, Pe);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.formatAuthMessage = (Ie) => {
      try {
        return this.engine.formatAuthMessage(Ie);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.approveSessionAuthenticate = async (Ie) => {
      try {
        return await this.engine.approveSessionAuthenticate(Ie);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.rejectSessionAuthenticate = async (Ie) => {
      try {
        return await this.engine.rejectSessionAuthenticate(Ie);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.name = (t == null ? void 0 : t.name) || we.name, this.metadata = (t == null ? void 0 : t.metadata) || Nt$2(), this.signConfig = t == null ? void 0 : t.signConfig;
    const Me = typeof (t == null ? void 0 : t.logger) < "u" && typeof (t == null ? void 0 : t.logger) != "string" ? t.logger : qt$3(k$2({ level: (t == null ? void 0 : t.logger) || we.logger }));
    this.core = (t == null ? void 0 : t.core) || new bn(t), this.logger = E$1(Me, this.name), this.session = new yt(this.core, this.logger), this.proposal = new Ss(this.core, this.logger), this.pendingRequest = new Is(this.core, this.logger), this.engine = new Rs(this), this.auth = new Ts(this.core, this.logger);
  }
  static async init(t) {
    const Me = new _e(t);
    return await Me.initialize(), Me;
  }
  get context() {
    return y$3(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), this.engine.processRelayMessageCache();
    } catch (t) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(t.message), t;
    }
  }
}
const Ns = yt, Ps = _e;
var l = { exports: {} }, c = typeof Reflect == "object" ? Reflect : null, y = c && typeof c.apply == "function" ? c.apply : function(Ae, t, Me) {
  return Function.prototype.apply.call(Ae, t, Me);
}, f;
c && typeof c.ownKeys == "function" ? f = c.ownKeys : Object.getOwnPropertySymbols ? f = function(Ae) {
  return Object.getOwnPropertyNames(Ae).concat(Object.getOwnPropertySymbols(Ae));
} : f = function(Ae) {
  return Object.getOwnPropertyNames(Ae);
};
function k(Ae) {
  console && console.warn && console.warn(Ae);
}
var w = Number.isNaN || function(Ae) {
  return Ae !== Ae;
};
function o() {
  o.init.call(this);
}
l.exports = o, l.exports.once = K, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
var L = 10;
function g(Ae) {
  if (typeof Ae != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof Ae);
}
Object.defineProperty(o, "defaultMaxListeners", { enumerable: !0, get: function() {
  return L;
}, set: function(Ae) {
  if (typeof Ae != "number" || Ae < 0 || w(Ae)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + Ae + ".");
  L = Ae;
} }), o.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o.prototype.setMaxListeners = function(Ae) {
  if (typeof Ae != "number" || Ae < 0 || w(Ae)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + Ae + ".");
  return this._maxListeners = Ae, this;
};
function _(Ae) {
  return Ae._maxListeners === void 0 ? o.defaultMaxListeners : Ae._maxListeners;
}
o.prototype.getMaxListeners = function() {
  return _(this);
}, o.prototype.emit = function(Ae) {
  for (var t = [], Me = 1; Me < arguments.length; Me++) t.push(arguments[Me]);
  var Ie = Ae === "error", Pe = this._events;
  if (Pe !== void 0) Ie = Ie && Pe.error === void 0;
  else if (!Ie) return !1;
  if (Ie) {
    var Be;
    if (t.length > 0 && (Be = t[0]), Be instanceof Error) throw Be;
    var Te = new Error("Unhandled error." + (Be ? " (" + Be.message + ")" : ""));
    throw Te.context = Be, Te;
  }
  var je = Pe[Ae];
  if (je === void 0) return !1;
  if (typeof je == "function") y(je, this, t);
  else for (var Ve = je.length, fi = O(je, Ve), Me = 0; Me < Ve; ++Me) y(fi[Me], this, t);
  return !0;
};
function S(Ae, t, Me, Ie) {
  var Pe, Be, Te;
  if (g(Me), Be = Ae._events, Be === void 0 ? (Be = Ae._events = /* @__PURE__ */ Object.create(null), Ae._eventsCount = 0) : (Be.newListener !== void 0 && (Ae.emit("newListener", t, Me.listener ? Me.listener : Me), Be = Ae._events), Te = Be[t]), Te === void 0) Te = Be[t] = Me, ++Ae._eventsCount;
  else if (typeof Te == "function" ? Te = Be[t] = Ie ? [Me, Te] : [Te, Me] : Ie ? Te.unshift(Me) : Te.push(Me), Pe = _(Ae), Pe > 0 && Te.length > Pe && !Te.warned) {
    Te.warned = !0;
    var je = new Error("Possible EventEmitter memory leak detected. " + Te.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    je.name = "MaxListenersExceededWarning", je.emitter = Ae, je.type = t, je.count = Te.length, k(je);
  }
  return Ae;
}
o.prototype.addListener = function(Ae, t) {
  return S(this, Ae, t, !1);
}, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(Ae, t) {
  return S(this, Ae, t, !0);
};
function D() {
  if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function C(Ae, t, Me) {
  var Ie = { fired: !1, wrapFn: void 0, target: Ae, type: t, listener: Me }, Pe = D.bind(Ie);
  return Pe.listener = Me, Ie.wrapFn = Pe, Pe;
}
o.prototype.once = function(Ae, t) {
  return g(t), this.on(Ae, C(this, Ae, t)), this;
}, o.prototype.prependOnceListener = function(Ae, t) {
  return g(t), this.prependListener(Ae, C(this, Ae, t)), this;
}, o.prototype.removeListener = function(Ae, t) {
  var Me, Ie, Pe, Be, Te;
  if (g(t), Ie = this._events, Ie === void 0) return this;
  if (Me = Ie[Ae], Me === void 0) return this;
  if (Me === t || Me.listener === t) --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete Ie[Ae], Ie.removeListener && this.emit("removeListener", Ae, Me.listener || t));
  else if (typeof Me != "function") {
    for (Pe = -1, Be = Me.length - 1; Be >= 0; Be--) if (Me[Be] === t || Me[Be].listener === t) {
      Te = Me[Be].listener, Pe = Be;
      break;
    }
    if (Pe < 0) return this;
    Pe === 0 ? Me.shift() : F(Me, Pe), Me.length === 1 && (Ie[Ae] = Me[0]), Ie.removeListener !== void 0 && this.emit("removeListener", Ae, Te || t);
  }
  return this;
}, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(Ae) {
  var t, Me, Ie;
  if (Me = this._events, Me === void 0) return this;
  if (Me.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Me[Ae] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Me[Ae]), this;
  if (arguments.length === 0) {
    var Pe = Object.keys(Me), Be;
    for (Ie = 0; Ie < Pe.length; ++Ie) Be = Pe[Ie], Be !== "removeListener" && this.removeAllListeners(Be);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = Me[Ae], typeof t == "function") this.removeListener(Ae, t);
  else if (t !== void 0) for (Ie = t.length - 1; Ie >= 0; Ie--) this.removeListener(Ae, t[Ie]);
  return this;
};
function b(Ae, t, Me) {
  var Ie = Ae._events;
  if (Ie === void 0) return [];
  var Pe = Ie[t];
  return Pe === void 0 ? [] : typeof Pe == "function" ? Me ? [Pe.listener || Pe] : [Pe] : Me ? z(Pe) : O(Pe, Pe.length);
}
o.prototype.listeners = function(Ae) {
  return b(this, Ae, !0);
}, o.prototype.rawListeners = function(Ae) {
  return b(this, Ae, !1);
}, o.listenerCount = function(Ae, t) {
  return typeof Ae.listenerCount == "function" ? Ae.listenerCount(t) : E.call(Ae, t);
}, o.prototype.listenerCount = E;
function E(Ae) {
  var t = this._events;
  if (t !== void 0) {
    var Me = t[Ae];
    if (typeof Me == "function") return 1;
    if (Me !== void 0) return Me.length;
  }
  return 0;
}
o.prototype.eventNames = function() {
  return this._eventsCount > 0 ? f(this._events) : [];
};
function O(Ae, t) {
  for (var Me = new Array(t), Ie = 0; Ie < t; ++Ie) Me[Ie] = Ae[Ie];
  return Me;
}
function F(Ae, t) {
  for (; t + 1 < Ae.length; t++) Ae[t] = Ae[t + 1];
  Ae.pop();
}
function z(Ae) {
  for (var t = new Array(Ae.length), Me = 0; Me < t.length; ++Me) t[Me] = Ae[Me].listener || Ae[Me];
  return t;
}
function K(Ae, t) {
  return new Promise(function(Me, Ie) {
    function Pe(Te) {
      Ae.removeListener(t, Be), Ie(Te);
    }
    function Be() {
      typeof Ae.removeListener == "function" && Ae.removeListener("error", Pe), Me([].slice.call(arguments));
    }
    R(Ae, t, Be, { once: !0 }), t !== "error" && U(Ae, Pe, { once: !0 });
  });
}
function U(Ae, t, Me) {
  typeof Ae.on == "function" && R(Ae, "error", t, Me);
}
function R(Ae, t, Me, Ie) {
  if (typeof Ae.on == "function") Ie.once ? Ae.once(t, Me) : Ae.on(t, Me);
  else if (typeof Ae.addEventListener == "function") Ae.addEventListener(t, function Pe(Be) {
    Ie.once && Ae.removeEventListener(t, Pe), Me(Be);
  });
  else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof Ae);
}
const p = "Web3Wallet";
class x {
  constructor(t) {
    this.opts = t;
  }
}
class P {
  constructor(t) {
    this.client = t;
  }
}
var V = Object.defineProperty, B = Object.defineProperties, J = Object.getOwnPropertyDescriptors, q = Object.getOwnPropertySymbols, Y = Object.prototype.hasOwnProperty, Z = Object.prototype.propertyIsEnumerable, j = (Ae, t, Me) => t in Ae ? V(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Me }) : Ae[t] = Me, ee = (Ae, t) => {
  for (var Me in t || (t = {})) Y.call(t, Me) && j(Ae, Me, t[Me]);
  if (q) for (var Me of q(t)) Z.call(t, Me) && j(Ae, Me, t[Me]);
  return Ae;
}, te = (Ae, t) => B(Ae, J(t));
class se extends P {
  constructor(t) {
    super(t), this.init = async () => {
      this.signClient = await Ps.init({ core: this.client.core, metadata: this.client.metadata, signConfig: this.client.signConfig }), this.authClient = await zr.init({ core: this.client.core, projectId: "", metadata: this.client.metadata });
    }, this.pair = async (Me) => {
      await this.client.core.pairing.pair(Me);
    }, this.approveSession = async (Me) => {
      const { topic: Ie, acknowledged: Pe } = await this.signClient.approve(te(ee({}, Me), { id: Me.id, namespaces: Me.namespaces, sessionProperties: Me.sessionProperties, sessionConfig: Me.sessionConfig }));
      return await Pe(), this.signClient.session.get(Ie);
    }, this.rejectSession = async (Me) => await this.signClient.reject(Me), this.updateSession = async (Me) => await this.signClient.update(Me), this.extendSession = async (Me) => await this.signClient.extend(Me), this.respondSessionRequest = async (Me) => await this.signClient.respond(Me), this.disconnectSession = async (Me) => await this.signClient.disconnect(Me), this.emitSessionEvent = async (Me) => await this.signClient.emit(Me), this.getActiveSessions = () => this.signClient.session.getAll().reduce((Me, Ie) => (Me[Ie.topic] = Ie, Me), {}), this.getPendingSessionProposals = () => this.signClient.proposal.getAll(), this.getPendingSessionRequests = () => this.signClient.getPendingSessionRequests(), this.respondAuthRequest = async (Me, Ie) => await this.authClient.respond(Me, Ie), this.getPendingAuthRequests = () => this.authClient.requests.getAll().filter((Me) => "requester" in Me), this.formatMessage = (Me, Ie) => this.authClient.formatMessage(Me, Ie), this.approveSessionAuthenticate = async (Me) => await this.signClient.approveSessionAuthenticate(Me), this.rejectSessionAuthenticate = async (Me) => await this.signClient.rejectSessionAuthenticate(Me), this.formatAuthMessage = (Me) => this.signClient.formatAuthMessage(Me), this.registerDeviceToken = (Me) => this.client.core.echoClient.registerDeviceToken(Me), this.on = (Me, Ie) => (this.setEvent(Me, "off"), this.setEvent(Me, "on"), this.client.events.on(Me, Ie)), this.once = (Me, Ie) => (this.setEvent(Me, "off"), this.setEvent(Me, "once"), this.client.events.once(Me, Ie)), this.off = (Me, Ie) => (this.setEvent(Me, "off"), this.client.events.off(Me, Ie)), this.removeListener = (Me, Ie) => (this.setEvent(Me, "removeListener"), this.client.events.removeListener(Me, Ie)), this.onSessionRequest = (Me) => {
      this.client.events.emit("session_request", Me);
    }, this.onSessionProposal = (Me) => {
      this.client.events.emit("session_proposal", Me);
    }, this.onSessionDelete = (Me) => {
      this.client.events.emit("session_delete", Me);
    }, this.onAuthRequest = (Me) => {
      this.client.events.emit("auth_request", Me);
    }, this.onProposalExpire = (Me) => {
      this.client.events.emit("proposal_expire", Me);
    }, this.onSessionRequestExpire = (Me) => {
      this.client.events.emit("session_request_expire", Me);
    }, this.onSessionRequestAuthenticate = (Me) => {
      this.client.events.emit("session_authenticate", Me);
    }, this.setEvent = (Me, Ie) => {
      switch (Me) {
        case "session_request":
          this.signClient.events[Ie]("session_request", this.onSessionRequest);
          break;
        case "session_proposal":
          this.signClient.events[Ie]("session_proposal", this.onSessionProposal);
          break;
        case "session_delete":
          this.signClient.events[Ie]("session_delete", this.onSessionDelete);
          break;
        case "auth_request":
          this.authClient[Ie]("auth_request", this.onAuthRequest);
          break;
        case "proposal_expire":
          this.signClient.events[Ie]("proposal_expire", this.onProposalExpire);
          break;
        case "session_request_expire":
          this.signClient.events[Ie]("session_request_expire", this.onSessionRequestExpire);
          break;
        case "session_authenticate":
          this.signClient.events[Ie]("session_authenticate", this.onSessionRequestAuthenticate);
          break;
      }
    }, this.signClient = {}, this.authClient = {};
  }
}
const ne = { decryptMessage: async (Ae) => {
  const t = { core: new bn({ storageOptions: Ae.storageOptions, storage: Ae.storage }) };
  await t.core.crypto.init();
  const Me = t.core.crypto.decode(Ae.topic, Ae.encryptedMessage);
  return t.core = null, Me;
}, getMetadata: async (Ae) => {
  const t = { core: new bn({ storageOptions: Ae.storageOptions, storage: Ae.storage }), sessionStore: null };
  t.sessionStore = new Ns(t.core, t.core.logger), await t.sessionStore.init();
  const Me = t.sessionStore.get(Ae.topic), Ie = Me == null ? void 0 : Me.peer.metadata;
  return t.core = null, t.sessionStore = null, Ie;
} }, T = class extends x {
  constructor(Ae) {
    super(Ae), this.events = new l.exports(), this.on = (t, Me) => this.engine.on(t, Me), this.once = (t, Me) => this.engine.once(t, Me), this.off = (t, Me) => this.engine.off(t, Me), this.removeListener = (t, Me) => this.engine.removeListener(t, Me), this.pair = async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (Me) {
        throw this.logger.error(Me.message), Me;
      }
    }, this.approveSession = async (t) => {
      try {
        return await this.engine.approveSession(t);
      } catch (Me) {
        throw this.logger.error(Me.message), Me;
      }
    }, this.rejectSession = async (t) => {
      try {
        return await this.engine.rejectSession(t);
      } catch (Me) {
        throw this.logger.error(Me.message), Me;
      }
    }, this.updateSession = async (t) => {
      try {
        return await this.engine.updateSession(t);
      } catch (Me) {
        throw this.logger.error(Me.message), Me;
      }
    }, this.extendSession = async (t) => {
      try {
        return await this.engine.extendSession(t);
      } catch (Me) {
        throw this.logger.error(Me.message), Me;
      }
    }, this.respondSessionRequest = async (t) => {
      try {
        return await this.engine.respondSessionRequest(t);
      } catch (Me) {
        throw this.logger.error(Me.message), Me;
      }
    }, this.disconnectSession = async (t) => {
      try {
        return await this.engine.disconnectSession(t);
      } catch (Me) {
        throw this.logger.error(Me.message), Me;
      }
    }, this.emitSessionEvent = async (t) => {
      try {
        return await this.engine.emitSessionEvent(t);
      } catch (Me) {
        throw this.logger.error(Me.message), Me;
      }
    }, this.getActiveSessions = () => {
      try {
        return this.engine.getActiveSessions();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionProposals = () => {
      try {
        return this.engine.getPendingSessionProposals();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.respondAuthRequest = async (t, Me) => {
      try {
        return await this.engine.respondAuthRequest(t, Me);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.getPendingAuthRequests = () => {
      try {
        return this.engine.getPendingAuthRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.formatMessage = (t, Me) => {
      try {
        return this.engine.formatMessage(t, Me);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.registerDeviceToken = (t) => {
      try {
        return this.engine.registerDeviceToken(t);
      } catch (Me) {
        throw this.logger.error(Me.message), Me;
      }
    }, this.approveSessionAuthenticate = (t) => {
      try {
        return this.engine.approveSessionAuthenticate(t);
      } catch (Me) {
        throw this.logger.error(Me.message), Me;
      }
    }, this.rejectSessionAuthenticate = (t) => {
      try {
        return this.engine.rejectSessionAuthenticate(t);
      } catch (Me) {
        throw this.logger.error(Me.message), Me;
      }
    }, this.formatAuthMessage = (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (Me) {
        throw this.logger.error(Me.message), Me;
      }
    }, this.metadata = Ae.metadata, this.name = Ae.name || p, this.signConfig = Ae.signConfig, this.core = Ae.core, this.logger = this.core.logger, this.engine = new se(this);
  }
  static async init(Ae) {
    const t = new T(Ae);
    return await t.initialize(), t;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.engine.init(), this.logger.info("Web3Wallet Initialization Success");
    } catch (Ae) {
      throw this.logger.info("Web3Wallet Initialization Failure"), this.logger.error(Ae.message), Ae;
    }
  }
};
let v = T;
v.notifications = ne;
const ie = v;
export {
  Buffer$1 as B,
  EC$2 as E,
  U$2 as U,
  Wr$1 as W,
  callBindExports as a,
  ellipticExports as b,
  callBound$2 as c,
  BN$8 as d,
  eventsExports as e,
  bnExports$1 as f,
  global as g,
  bn as h,
  ie as i,
  require$$0$3 as r,
  string_decoder as s
};

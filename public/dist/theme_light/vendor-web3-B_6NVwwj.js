var mf = Object.defineProperty;
var Uc = (Ae) => {
  throw TypeError(Ae);
};
var vf = (Ae, t, Ie) => t in Ae ? mf(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie;
var jc = (Ae, t, Ie) => vf(Ae, typeof t != "symbol" ? t + "" : t, Ie), Bc = (Ae, t, Ie) => t.has(Ae) || Uc("Cannot " + Ie);
var ea = (Ae, t, Ie) => (Bc(Ae, t, "read from private field"), Ie ? Ie.call(Ae) : t.get(Ae)), ia = (Ae, t, Ie) => t.has(Ae) ? Uc("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(Ae) : t.set(Ae, Ie), Jo = (Ae, t, Ie, Be) => (Bc(Ae, t, "write to private field"), Be ? Be.call(Ae, Ie) : t.set(Ae, Ie), Ie), mc = (Ae, t, Ie) => (Bc(Ae, t, "access private method"), Ie);
import { d as commonjsGlobal, g as getDefaultExportFromCjs, e as getAugmentedNamespace, p as process$1$1 } from "./vendor-react-D6ZgZFQ5.js";
function _typeof(Ae) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, _typeof(Ae);
}
function toPrimitive(Ae, t) {
  if (_typeof(Ae) != "object" || !Ae) return Ae;
  var Ie = Ae[Symbol.toPrimitive];
  if (Ie !== void 0) {
    var Be = Ie.call(Ae, t || "default");
    if (_typeof(Be) != "object") return Be;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(Ae);
}
function toPropertyKey(Ae) {
  var t = toPrimitive(Ae, "string");
  return _typeof(t) == "symbol" ? t : t + "";
}
function _defineProperty(Ae, t, Ie) {
  return (t = toPropertyKey(t)) in Ae ? Object.defineProperty(Ae, t, {
    value: Ie,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : Ae[t] = Ie, Ae;
}
const defineProperty = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _defineProperty
}, Symbol.toStringTag, { value: "Module" }));
function fixProto$1(Ae, t) {
  var Ie = Object.setPrototypeOf;
  Ie ? Ie(Ae, t) : Ae.__proto__ = t;
}
function fixStack$1(Ae, t) {
  t === void 0 && (t = Ae.constructor);
  var Ie = Error.captureStackTrace;
  Ie && Ie(Ae, t);
}
var __extends$1 = /* @__PURE__ */ function() {
  var Ae = function(Ie, Be) {
    return Ae = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(Pe, Te) {
      Pe.__proto__ = Te;
    } || function(Pe, Te) {
      for (var Me in Te)
        Object.prototype.hasOwnProperty.call(Te, Me) && (Pe[Me] = Te[Me]);
    }, Ae(Ie, Be);
  };
  return function(t, Ie) {
    if (typeof Ie != "function" && Ie !== null) throw new TypeError("Class extends value " + String(Ie) + " is not a constructor or null");
    Ae(t, Ie);
    function Be() {
      this.constructor = t;
    }
    t.prototype = Ie === null ? Object.create(Ie) : (Be.prototype = Ie.prototype, new Be());
  };
}(), CustomError$1 = function(Ae) {
  __extends$1(t, Ae);
  function t(Ie, Be) {
    var Pe = this.constructor, Te = Ae.call(this, Ie, Be) || this;
    return Object.defineProperty(Te, "name", {
      value: Pe.name,
      enumerable: !1,
      configurable: !0
    }), fixProto$1(Te, Pe.prototype), fixStack$1(Te), Te;
  }
  return t;
}(Error);
function serializeError$1(Ae) {
  const t = Ae.findIndex((Te) => Te instanceof Error), Ie = Ae.findIndex((Te) => typeof Te == "string"), Be = Ae.findIndex((Te) => Te && typeof Te == "object" && "status" in Te && "type" in Te);
  let Pe;
  if (Be !== -1) {
    const Te = Ae[Be];
    Pe = new Error(`${Te.status} ${Te.type.toString()} ${Te.statusText}`);
  } else t !== -1 ? Pe = Ae.splice(t, 1)[0] : Ie !== -1 ? Pe = new Error(Ae.splice(Ie, 1)[0]) : Pe = new Error("Unknown error");
  return [Pe, Ae];
}
class Web3AuthError extends CustomError$1 {
  constructor(t, Ie, Be) {
    super(Ie), _defineProperty(this, "code", void 0), _defineProperty(this, "message", void 0), _defineProperty(this, "cause", void 0), this.code = t, this.message = Ie || "", this.cause = Be, Object.defineProperty(this, "name", {
      value: "Web3AuthError"
    });
  }
  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      cause: serializeError$1([this.cause])
    };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
}
class WalletInitializationError extends Web3AuthError {
  constructor(t, Ie, Be) {
    super(t, Ie, Be), Object.defineProperty(this, "name", {
      value: "WalletInitializationError"
    });
  }
  static fromCode(t, Ie = "", Be) {
    return new WalletInitializationError(t, `${WalletInitializationError.messages[t]}, ${Ie}`, Be);
  }
  // Custom methods
  static notFound(t = "", Ie) {
    return WalletInitializationError.fromCode(5001, t, Ie);
  }
  static notInstalled(t = "", Ie) {
    return WalletInitializationError.fromCode(5002, t, Ie);
  }
  static notReady(t = "", Ie) {
    return WalletInitializationError.fromCode(5003, t, Ie);
  }
  static windowBlocked(t = "", Ie) {
    return WalletInitializationError.fromCode(5004, t, Ie);
  }
  static windowClosed(t = "", Ie) {
    return WalletInitializationError.fromCode(5005, t, Ie);
  }
  static incompatibleChainNameSpace(t = "", Ie) {
    return WalletInitializationError.fromCode(5006, t, Ie);
  }
  static duplicateAdapterError(t = "", Ie) {
    return WalletInitializationError.fromCode(5007, t, Ie);
  }
  static invalidProviderConfigError(t = "", Ie) {
    return WalletInitializationError.fromCode(5008, t, Ie);
  }
  static providerNotReadyError(t = "", Ie) {
    return WalletInitializationError.fromCode(5009, t, Ie);
  }
  static rpcConnectionError(t = "", Ie) {
    return WalletInitializationError.fromCode(5010, t, Ie);
  }
  static invalidParams(t = "", Ie) {
    return WalletInitializationError.fromCode(5011, t, Ie);
  }
  static invalidNetwork(t = "", Ie) {
    return WalletInitializationError.fromCode(5013, t, Ie);
  }
}
_defineProperty(WalletInitializationError, "messages", {
  5e3: "Custom",
  5001: "Wallet is not found",
  5002: "Wallet is not installed",
  5003: "Wallet is not ready yet",
  5004: "Wallet window is blocked",
  5005: "Wallet window has been closed by the user",
  5006: "Incompatible chain namespace provided",
  5007: "Adapter has already been included",
  5008: "Invalid provider Config",
  5009: "Provider is not ready yet",
  5010: "Failed to connect with rpc url",
  5011: "Invalid params passed in",
  5013: "Invalid network provided"
});
class WalletLoginError extends Web3AuthError {
  constructor(t, Ie, Be) {
    super(t, Ie, Be), Object.defineProperty(this, "name", {
      value: "WalletLoginError"
    });
  }
  static fromCode(t, Ie = "", Be) {
    return new WalletLoginError(t, `${WalletLoginError.messages[t]}. ${Ie}`, Be);
  }
  static connectionError(t = "", Ie) {
    return WalletLoginError.fromCode(5111, t, Ie);
  }
  static disconnectionError(t = "", Ie) {
    return WalletLoginError.fromCode(5112, t, Ie);
  }
  static notConnectedError(t = "", Ie) {
    return WalletLoginError.fromCode(5113, t, Ie);
  }
  static popupClosed(t = "", Ie) {
    return WalletLoginError.fromCode(5114, t, Ie);
  }
  static mfaEnabled(t = "", Ie) {
    return WalletLoginError.fromCode(5115, t, Ie);
  }
  static chainConfigNotAdded(t = "", Ie) {
    return WalletLoginError.fromCode(5116, t, Ie);
  }
  static unsupportedOperation(t = "", Ie) {
    return WalletLoginError.fromCode(5117, t, Ie);
  }
  static coreKitKeyNotFound(t = "", Ie) {
    return WalletLoginError.fromCode(5118, t, Ie);
  }
  static userNotLoggedIn(t = "", Ie) {
    return WalletLoginError.fromCode(5119, t, Ie);
  }
}
_defineProperty(WalletLoginError, "messages", {
  5e3: "Custom",
  5111: "Failed to connect with wallet",
  5112: "Failed to disconnect from wallet",
  5113: "Wallet is not connected",
  5114: "Wallet popup has been closed by the user",
  5115: "User has already enabled mfa, please use the @web3auth/web3auth-web sdk for login with mfa",
  5116: "Chain config has not been added. Please add the chain config before calling switchChain",
  5117: "Unsupported operation",
  5118: "useCoreKitKey flag is enabled but coreKitKey is not available",
  5119: "User not logged in."
});
class WalletOperationsError extends Web3AuthError {
  constructor(t, Ie, Be) {
    super(t, Ie, Be), Object.defineProperty(this, "name", {
      value: "WalletOperationsError"
    });
  }
  static fromCode(t, Ie = "", Be) {
    return new WalletOperationsError(t, `${WalletOperationsError.messages[t]}, ${Ie}`, Be);
  }
  // Custom methods
  static chainIDNotAllowed(t = "", Ie) {
    return WalletOperationsError.fromCode(5201, t, Ie);
  }
  static operationNotAllowed(t = "", Ie) {
    return WalletOperationsError.fromCode(5202, t, Ie);
  }
  static chainNamespaceNotAllowed(t = "", Ie) {
    return WalletOperationsError.fromCode(5203, t, Ie);
  }
}
_defineProperty(WalletOperationsError, "messages", {
  5e3: "Custom",
  5201: "Provided chainId is not allowed",
  5202: "This operation is not allowed"
});
class WalletProviderError extends Web3AuthError {
  constructor(t, Ie, Be) {
    super(t, Ie, Be), Object.defineProperty(this, "name", {
      value: "WalletProviderError"
    });
  }
  static fromCode(t, Ie = "", Be) {
    return new WalletOperationsError(t, `${WalletProviderError.messages[t]}, ${Ie}`, Be);
  }
  // Custom methods
  static invalidRequestArgs(t = "", Ie) {
    return WalletOperationsError.fromCode(5301, t, Ie);
  }
  static invalidRequestMethod(t = "", Ie) {
    return WalletOperationsError.fromCode(5302, t, Ie);
  }
  static invalidRequestParams(t = "", Ie) {
    return WalletOperationsError.fromCode(5303, t, Ie);
  }
}
_defineProperty(WalletProviderError, "messages", {
  5e3: "Custom",
  5301: "Expected a single, non-array, object argument.",
  5302: "'args.method' must be a non-empty string.",
  5303: "'args.params' must be an object or array if provided."
});
const CHAIN_NAMESPACES = {
  EIP155: "eip155",
  SOLANA: "solana",
  CASPER: "casper",
  XRPL: "xrpl",
  OTHER: "other"
};
var loglevel$2 = { exports: {} };
(function(Ae) {
  (function(t, Ie) {
    Ae.exports ? Ae.exports = Ie() : t.log = Ie();
  })(commonjsGlobal, function() {
    var t = function() {
    }, Ie = "undefined", Be = typeof window !== Ie && typeof window.navigator !== Ie && /Trident\/|MSIE /.test(window.navigator.userAgent), Pe = [
      "trace",
      "debug",
      "info",
      "warn",
      "error"
    ], Te = {}, Me = null;
    function Ue(mi, _i) {
      var Ei = mi[_i];
      if (typeof Ei.bind == "function")
        return Ei.bind(mi);
      try {
        return Function.prototype.bind.call(Ei, mi);
      } catch {
        return function() {
          return Function.prototype.apply.apply(Ei, [mi, arguments]);
        };
      }
    }
    function je() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function fn(mi) {
      return mi === "debug" && (mi = "log"), typeof console === Ie ? !1 : mi === "trace" && Be ? je : console[mi] !== void 0 ? Ue(console, mi) : console.log !== void 0 ? Ue(console, "log") : t;
    }
    function Ve() {
      for (var mi = this.getLevel(), _i = 0; _i < Pe.length; _i++) {
        var Ei = Pe[_i];
        this[Ei] = _i < mi ? t : this.methodFactory(Ei, mi, this.name);
      }
      if (this.log = this.debug, typeof console === Ie && mi < this.levels.SILENT)
        return "No console available for logging";
    }
    function vn(mi) {
      return function() {
        typeof console !== Ie && (Ve.call(this), this[mi].apply(this, arguments));
      };
    }
    function En(mi, _i, Ei) {
      return fn(mi) || vn.apply(this, arguments);
    }
    function fi(mi, _i) {
      var Ei = this, Si, Mi, Oi, Fi = "loglevel";
      typeof mi == "string" ? Fi += ":" + mi : typeof mi == "symbol" && (Fi = void 0);
      function Ui(zi) {
        var xi = (Pe[zi] || "silent").toUpperCase();
        if (!(typeof window === Ie || !Fi)) {
          try {
            window.localStorage[Fi] = xi;
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(Fi) + "=" + xi + ";";
          } catch {
          }
        }
      }
      function Pi() {
        var zi;
        if (!(typeof window === Ie || !Fi)) {
          try {
            zi = window.localStorage[Fi];
          } catch {
          }
          if (typeof zi === Ie)
            try {
              var xi = window.document.cookie, $i = encodeURIComponent(Fi), vi = xi.indexOf($i + "=");
              vi !== -1 && (zi = /^([^;]+)/.exec(
                xi.slice(vi + $i.length + 1)
              )[1]);
            } catch {
            }
          return Ei.levels[zi] === void 0 && (zi = void 0), zi;
        }
      }
      function Bi() {
        if (!(typeof window === Ie || !Fi)) {
          try {
            window.localStorage.removeItem(Fi);
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(Fi) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch {
          }
        }
      }
      function ji(zi) {
        var xi = zi;
        if (typeof xi == "string" && Ei.levels[xi.toUpperCase()] !== void 0 && (xi = Ei.levels[xi.toUpperCase()]), typeof xi == "number" && xi >= 0 && xi <= Ei.levels.SILENT)
          return xi;
        throw new TypeError("log.setLevel() called with invalid level: " + zi);
      }
      Ei.name = mi, Ei.levels = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        SILENT: 5
      }, Ei.methodFactory = _i || En, Ei.getLevel = function() {
        return Oi ?? Mi ?? Si;
      }, Ei.setLevel = function(zi, xi) {
        return Oi = ji(zi), xi !== !1 && Ui(Oi), Ve.call(Ei);
      }, Ei.setDefaultLevel = function(zi) {
        Mi = ji(zi), Pi() || Ei.setLevel(zi, !1);
      }, Ei.resetLevel = function() {
        Oi = null, Bi(), Ve.call(Ei);
      }, Ei.enableAll = function(zi) {
        Ei.setLevel(Ei.levels.TRACE, zi);
      }, Ei.disableAll = function(zi) {
        Ei.setLevel(Ei.levels.SILENT, zi);
      }, Ei.rebuild = function() {
        if (Me !== Ei && (Si = ji(Me.getLevel())), Ve.call(Ei), Me === Ei)
          for (var zi in Te)
            Te[zi].rebuild();
      }, Si = ji(
        Me ? Me.getLevel() : "WARN"
      );
      var Zi = Pi();
      Zi != null && (Oi = ji(Zi)), Ve.call(Ei);
    }
    Me = new fi(), Me.getLogger = function(_i) {
      if (typeof _i != "symbol" && typeof _i != "string" || _i === "")
        throw new TypeError("You must supply a name when creating a logger.");
      var Ei = Te[_i];
      return Ei || (Ei = Te[_i] = new fi(
        _i,
        Me.methodFactory
      )), Ei;
    };
    var bi = typeof window !== Ie ? window.log : void 0;
    return Me.noConflict = function() {
      return typeof window !== Ie && window.log === Me && (window.log = bi), Me;
    }, Me.getLoggers = function() {
      return Te;
    }, Me.default = Me, Me;
  });
})(loglevel$2);
var loglevelExports = loglevel$2.exports;
const loglevel$1 = /* @__PURE__ */ getDefaultExportFromCjs(loglevelExports);
var loglevel = loglevel$1.getLogger("web3auth-logger");
function ownKeys(Ae, t) {
  var Ie = Object.keys(Ae);
  if (Object.getOwnPropertySymbols) {
    var Be = Object.getOwnPropertySymbols(Ae);
    t && (Be = Be.filter(function(Pe) {
      return Object.getOwnPropertyDescriptor(Ae, Pe).enumerable;
    })), Ie.push.apply(Ie, Be);
  }
  return Ie;
}
function _objectSpread2(Ae) {
  for (var t = 1; t < arguments.length; t++) {
    var Ie = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ownKeys(Object(Ie), !0).forEach(function(Be) {
      _defineProperty(Ae, Be, Ie[Be]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Ae, Object.getOwnPropertyDescriptors(Ie)) : ownKeys(Object(Ie)).forEach(function(Be) {
      Object.defineProperty(Ae, Be, Object.getOwnPropertyDescriptor(Ie, Be));
    });
  }
  return Ae;
}
var buffer$2 = {}, base64Js = {};
base64Js.byteLength = byteLength$1;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup$2 = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len = code.length; i$2 < len; ++i$2)
  lookup$2[i$2] = code[i$2], revLookup[code.charCodeAt(i$2)] = i$2;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(Ae) {
  var t = Ae.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var Ie = Ae.indexOf("=");
  Ie === -1 && (Ie = t);
  var Be = Ie === t ? 0 : 4 - Ie % 4;
  return [Ie, Be];
}
function byteLength$1(Ae) {
  var t = getLens(Ae), Ie = t[0], Be = t[1];
  return (Ie + Be) * 3 / 4 - Be;
}
function _byteLength(Ae, t, Ie) {
  return (t + Ie) * 3 / 4 - Ie;
}
function toByteArray(Ae) {
  var t, Ie = getLens(Ae), Be = Ie[0], Pe = Ie[1], Te = new Arr(_byteLength(Ae, Be, Pe)), Me = 0, Ue = Pe > 0 ? Be - 4 : Be, je;
  for (je = 0; je < Ue; je += 4)
    t = revLookup[Ae.charCodeAt(je)] << 18 | revLookup[Ae.charCodeAt(je + 1)] << 12 | revLookup[Ae.charCodeAt(je + 2)] << 6 | revLookup[Ae.charCodeAt(je + 3)], Te[Me++] = t >> 16 & 255, Te[Me++] = t >> 8 & 255, Te[Me++] = t & 255;
  return Pe === 2 && (t = revLookup[Ae.charCodeAt(je)] << 2 | revLookup[Ae.charCodeAt(je + 1)] >> 4, Te[Me++] = t & 255), Pe === 1 && (t = revLookup[Ae.charCodeAt(je)] << 10 | revLookup[Ae.charCodeAt(je + 1)] << 4 | revLookup[Ae.charCodeAt(je + 2)] >> 2, Te[Me++] = t >> 8 & 255, Te[Me++] = t & 255), Te;
}
function tripletToBase64(Ae) {
  return lookup$2[Ae >> 18 & 63] + lookup$2[Ae >> 12 & 63] + lookup$2[Ae >> 6 & 63] + lookup$2[Ae & 63];
}
function encodeChunk(Ae, t, Ie) {
  for (var Be, Pe = [], Te = t; Te < Ie; Te += 3)
    Be = (Ae[Te] << 16 & 16711680) + (Ae[Te + 1] << 8 & 65280) + (Ae[Te + 2] & 255), Pe.push(tripletToBase64(Be));
  return Pe.join("");
}
function fromByteArray(Ae) {
  for (var t, Ie = Ae.length, Be = Ie % 3, Pe = [], Te = 16383, Me = 0, Ue = Ie - Be; Me < Ue; Me += Te)
    Pe.push(encodeChunk(Ae, Me, Me + Te > Ue ? Ue : Me + Te));
  return Be === 1 ? (t = Ae[Ie - 1], Pe.push(
    lookup$2[t >> 2] + lookup$2[t << 4 & 63] + "=="
  )) : Be === 2 && (t = (Ae[Ie - 2] << 8) + Ae[Ie - 1], Pe.push(
    lookup$2[t >> 10] + lookup$2[t >> 4 & 63] + lookup$2[t << 2 & 63] + "="
  )), Pe.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(Ae, t, Ie, Be, Pe) {
  var Te, Me, Ue = Pe * 8 - Be - 1, je = (1 << Ue) - 1, fn = je >> 1, Ve = -7, vn = Ie ? Pe - 1 : 0, En = Ie ? -1 : 1, fi = Ae[t + vn];
  for (vn += En, Te = fi & (1 << -Ve) - 1, fi >>= -Ve, Ve += Ue; Ve > 0; Te = Te * 256 + Ae[t + vn], vn += En, Ve -= 8)
    ;
  for (Me = Te & (1 << -Ve) - 1, Te >>= -Ve, Ve += Be; Ve > 0; Me = Me * 256 + Ae[t + vn], vn += En, Ve -= 8)
    ;
  if (Te === 0)
    Te = 1 - fn;
  else {
    if (Te === je)
      return Me ? NaN : (fi ? -1 : 1) * (1 / 0);
    Me = Me + Math.pow(2, Be), Te = Te - fn;
  }
  return (fi ? -1 : 1) * Me * Math.pow(2, Te - Be);
};
ieee754.write = function(Ae, t, Ie, Be, Pe, Te) {
  var Me, Ue, je, fn = Te * 8 - Pe - 1, Ve = (1 << fn) - 1, vn = Ve >> 1, En = Pe === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, fi = Be ? 0 : Te - 1, bi = Be ? 1 : -1, mi = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (Ue = isNaN(t) ? 1 : 0, Me = Ve) : (Me = Math.floor(Math.log(t) / Math.LN2), t * (je = Math.pow(2, -Me)) < 1 && (Me--, je *= 2), Me + vn >= 1 ? t += En / je : t += En * Math.pow(2, 1 - vn), t * je >= 2 && (Me++, je /= 2), Me + vn >= Ve ? (Ue = 0, Me = Ve) : Me + vn >= 1 ? (Ue = (t * je - 1) * Math.pow(2, Pe), Me = Me + vn) : (Ue = t * Math.pow(2, vn - 1) * Math.pow(2, Pe), Me = 0)); Pe >= 8; Ae[Ie + fi] = Ue & 255, fi += bi, Ue /= 256, Pe -= 8)
    ;
  for (Me = Me << Pe | Ue, fn += Pe; fn > 0; Ae[Ie + fi] = Me & 255, fi += bi, Me /= 256, fn -= 8)
    ;
  Ae[Ie + fi - bi] |= mi * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(Ae) {
  const t = base64Js, Ie = ieee754, Be = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  Ae.Buffer = Ve, Ae.SlowBuffer = Fi, Ae.INSPECT_MAX_BYTES = 50;
  const Pe = 2147483647;
  Ae.kMaxLength = Pe;
  const { Uint8Array: Te, ArrayBuffer: Me, SharedArrayBuffer: Ue } = globalThis;
  Ve.TYPED_ARRAY_SUPPORT = je(), !Ve.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function je() {
    try {
      const rs = new Te(1), Gi = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(Gi, Te.prototype), Object.setPrototypeOf(rs, Gi), rs.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(Ve.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (Ve.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(Ve.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (Ve.isBuffer(this))
        return this.byteOffset;
    }
  });
  function fn(rs) {
    if (rs > Pe)
      throw new RangeError('The value "' + rs + '" is invalid for option "size"');
    const Gi = new Te(rs);
    return Object.setPrototypeOf(Gi, Ve.prototype), Gi;
  }
  function Ve(rs, Gi, Ji) {
    if (typeof rs == "number") {
      if (typeof Gi == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return bi(rs);
    }
    return vn(rs, Gi, Ji);
  }
  Ve.poolSize = 8192;
  function vn(rs, Gi, Ji) {
    if (typeof rs == "string")
      return mi(rs, Gi);
    if (Me.isView(rs))
      return Ei(rs);
    if (rs == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof rs
      );
    if (Io(rs, Me) || rs && Io(rs.buffer, Me) || typeof Ue < "u" && (Io(rs, Ue) || rs && Io(rs.buffer, Ue)))
      return Si(rs, Gi, Ji);
    if (typeof rs == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const ss = rs.valueOf && rs.valueOf();
    if (ss != null && ss !== rs)
      return Ve.from(ss, Gi, Ji);
    const ls = Mi(rs);
    if (ls) return ls;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof rs[Symbol.toPrimitive] == "function")
      return Ve.from(rs[Symbol.toPrimitive]("string"), Gi, Ji);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof rs
    );
  }
  Ve.from = function(rs, Gi, Ji) {
    return vn(rs, Gi, Ji);
  }, Object.setPrototypeOf(Ve.prototype, Te.prototype), Object.setPrototypeOf(Ve, Te);
  function En(rs) {
    if (typeof rs != "number")
      throw new TypeError('"size" argument must be of type number');
    if (rs < 0)
      throw new RangeError('The value "' + rs + '" is invalid for option "size"');
  }
  function fi(rs, Gi, Ji) {
    return En(rs), rs <= 0 ? fn(rs) : Gi !== void 0 ? typeof Ji == "string" ? fn(rs).fill(Gi, Ji) : fn(rs).fill(Gi) : fn(rs);
  }
  Ve.alloc = function(rs, Gi, Ji) {
    return fi(rs, Gi, Ji);
  };
  function bi(rs) {
    return En(rs), fn(rs < 0 ? 0 : Oi(rs) | 0);
  }
  Ve.allocUnsafe = function(rs) {
    return bi(rs);
  }, Ve.allocUnsafeSlow = function(rs) {
    return bi(rs);
  };
  function mi(rs, Gi) {
    if ((typeof Gi != "string" || Gi === "") && (Gi = "utf8"), !Ve.isEncoding(Gi))
      throw new TypeError("Unknown encoding: " + Gi);
    const Ji = Ui(rs, Gi) | 0;
    let ss = fn(Ji);
    const ls = ss.write(rs, Gi);
    return ls !== Ji && (ss = ss.slice(0, ls)), ss;
  }
  function _i(rs) {
    const Gi = rs.length < 0 ? 0 : Oi(rs.length) | 0, Ji = fn(Gi);
    for (let ss = 0; ss < Gi; ss += 1)
      Ji[ss] = rs[ss] & 255;
    return Ji;
  }
  function Ei(rs) {
    if (Io(rs, Te)) {
      const Gi = new Te(rs);
      return Si(Gi.buffer, Gi.byteOffset, Gi.byteLength);
    }
    return _i(rs);
  }
  function Si(rs, Gi, Ji) {
    if (Gi < 0 || rs.byteLength < Gi)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (rs.byteLength < Gi + (Ji || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let ss;
    return Gi === void 0 && Ji === void 0 ? ss = new Te(rs) : Ji === void 0 ? ss = new Te(rs, Gi) : ss = new Te(rs, Gi, Ji), Object.setPrototypeOf(ss, Ve.prototype), ss;
  }
  function Mi(rs) {
    if (Ve.isBuffer(rs)) {
      const Gi = Oi(rs.length) | 0, Ji = fn(Gi);
      return Ji.length === 0 || rs.copy(Ji, 0, 0, Gi), Ji;
    }
    if (rs.length !== void 0)
      return typeof rs.length != "number" || To(rs.length) ? fn(0) : _i(rs);
    if (rs.type === "Buffer" && Array.isArray(rs.data))
      return _i(rs.data);
  }
  function Oi(rs) {
    if (rs >= Pe)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Pe.toString(16) + " bytes");
    return rs | 0;
  }
  function Fi(rs) {
    return +rs != rs && (rs = 0), Ve.alloc(+rs);
  }
  Ve.isBuffer = function(Gi) {
    return Gi != null && Gi._isBuffer === !0 && Gi !== Ve.prototype;
  }, Ve.compare = function(Gi, Ji) {
    if (Io(Gi, Te) && (Gi = Ve.from(Gi, Gi.offset, Gi.byteLength)), Io(Ji, Te) && (Ji = Ve.from(Ji, Ji.offset, Ji.byteLength)), !Ve.isBuffer(Gi) || !Ve.isBuffer(Ji))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (Gi === Ji) return 0;
    let ss = Gi.length, ls = Ji.length;
    for (let ds = 0, bs = Math.min(ss, ls); ds < bs; ++ds)
      if (Gi[ds] !== Ji[ds]) {
        ss = Gi[ds], ls = Ji[ds];
        break;
      }
    return ss < ls ? -1 : ls < ss ? 1 : 0;
  }, Ve.isEncoding = function(Gi) {
    switch (String(Gi).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, Ve.concat = function(Gi, Ji) {
    if (!Array.isArray(Gi))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (Gi.length === 0)
      return Ve.alloc(0);
    let ss;
    if (Ji === void 0)
      for (Ji = 0, ss = 0; ss < Gi.length; ++ss)
        Ji += Gi[ss].length;
    const ls = Ve.allocUnsafe(Ji);
    let ds = 0;
    for (ss = 0; ss < Gi.length; ++ss) {
      let bs = Gi[ss];
      if (Io(bs, Te))
        ds + bs.length > ls.length ? (Ve.isBuffer(bs) || (bs = Ve.from(bs)), bs.copy(ls, ds)) : Te.prototype.set.call(
          ls,
          bs,
          ds
        );
      else if (Ve.isBuffer(bs))
        bs.copy(ls, ds);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      ds += bs.length;
    }
    return ls;
  };
  function Ui(rs, Gi) {
    if (Ve.isBuffer(rs))
      return rs.length;
    if (Me.isView(rs) || Io(rs, Me))
      return rs.byteLength;
    if (typeof rs != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof rs
      );
    const Ji = rs.length, ss = arguments.length > 2 && arguments[2] === !0;
    if (!ss && Ji === 0) return 0;
    let ls = !1;
    for (; ; )
      switch (Gi) {
        case "ascii":
        case "latin1":
        case "binary":
          return Ji;
        case "utf8":
        case "utf-8":
          return So(rs).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ji * 2;
        case "hex":
          return Ji >>> 1;
        case "base64":
          return Ro(rs).length;
        default:
          if (ls)
            return ss ? -1 : So(rs).length;
          Gi = ("" + Gi).toLowerCase(), ls = !0;
      }
  }
  Ve.byteLength = Ui;
  function Pi(rs, Gi, Ji) {
    let ss = !1;
    if ((Gi === void 0 || Gi < 0) && (Gi = 0), Gi > this.length || ((Ji === void 0 || Ji > this.length) && (Ji = this.length), Ji <= 0) || (Ji >>>= 0, Gi >>>= 0, Ji <= Gi))
      return "";
    for (rs || (rs = "utf8"); ; )
      switch (rs) {
        case "hex":
          return Ni(this, Gi, Ji);
        case "utf8":
        case "utf-8":
          return Ri(this, Gi, Ji);
        case "ascii":
          return Ii(this, Gi, Ji);
        case "latin1":
        case "binary":
          return Li(this, Gi, Ji);
        case "base64":
          return Ai(this, Gi, Ji);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Vi(this, Gi, Ji);
        default:
          if (ss) throw new TypeError("Unknown encoding: " + rs);
          rs = (rs + "").toLowerCase(), ss = !0;
      }
  }
  Ve.prototype._isBuffer = !0;
  function Bi(rs, Gi, Ji) {
    const ss = rs[Gi];
    rs[Gi] = rs[Ji], rs[Ji] = ss;
  }
  Ve.prototype.swap16 = function() {
    const Gi = this.length;
    if (Gi % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let Ji = 0; Ji < Gi; Ji += 2)
      Bi(this, Ji, Ji + 1);
    return this;
  }, Ve.prototype.swap32 = function() {
    const Gi = this.length;
    if (Gi % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let Ji = 0; Ji < Gi; Ji += 4)
      Bi(this, Ji, Ji + 3), Bi(this, Ji + 1, Ji + 2);
    return this;
  }, Ve.prototype.swap64 = function() {
    const Gi = this.length;
    if (Gi % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let Ji = 0; Ji < Gi; Ji += 8)
      Bi(this, Ji, Ji + 7), Bi(this, Ji + 1, Ji + 6), Bi(this, Ji + 2, Ji + 5), Bi(this, Ji + 3, Ji + 4);
    return this;
  }, Ve.prototype.toString = function() {
    const Gi = this.length;
    return Gi === 0 ? "" : arguments.length === 0 ? Ri(this, 0, Gi) : Pi.apply(this, arguments);
  }, Ve.prototype.toLocaleString = Ve.prototype.toString, Ve.prototype.equals = function(Gi) {
    if (!Ve.isBuffer(Gi)) throw new TypeError("Argument must be a Buffer");
    return this === Gi ? !0 : Ve.compare(this, Gi) === 0;
  }, Ve.prototype.inspect = function() {
    let Gi = "";
    const Ji = Ae.INSPECT_MAX_BYTES;
    return Gi = this.toString("hex", 0, Ji).replace(/(.{2})/g, "$1 ").trim(), this.length > Ji && (Gi += " ... "), "<Buffer " + Gi + ">";
  }, Be && (Ve.prototype[Be] = Ve.prototype.inspect), Ve.prototype.compare = function(Gi, Ji, ss, ls, ds) {
    if (Io(Gi, Te) && (Gi = Ve.from(Gi, Gi.offset, Gi.byteLength)), !Ve.isBuffer(Gi))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Gi
      );
    if (Ji === void 0 && (Ji = 0), ss === void 0 && (ss = Gi ? Gi.length : 0), ls === void 0 && (ls = 0), ds === void 0 && (ds = this.length), Ji < 0 || ss > Gi.length || ls < 0 || ds > this.length)
      throw new RangeError("out of range index");
    if (ls >= ds && Ji >= ss)
      return 0;
    if (ls >= ds)
      return -1;
    if (Ji >= ss)
      return 1;
    if (Ji >>>= 0, ss >>>= 0, ls >>>= 0, ds >>>= 0, this === Gi) return 0;
    let bs = ds - ls, Mo = ss - Ji;
    const Fo = Math.min(bs, Mo), Bo = this.slice(ls, ds), Uo = Gi.slice(Ji, ss);
    for (let Lo = 0; Lo < Fo; ++Lo)
      if (Bo[Lo] !== Uo[Lo]) {
        bs = Bo[Lo], Mo = Uo[Lo];
        break;
      }
    return bs < Mo ? -1 : Mo < bs ? 1 : 0;
  };
  function ji(rs, Gi, Ji, ss, ls) {
    if (rs.length === 0) return -1;
    if (typeof Ji == "string" ? (ss = Ji, Ji = 0) : Ji > 2147483647 ? Ji = 2147483647 : Ji < -2147483648 && (Ji = -2147483648), Ji = +Ji, To(Ji) && (Ji = ls ? 0 : rs.length - 1), Ji < 0 && (Ji = rs.length + Ji), Ji >= rs.length) {
      if (ls) return -1;
      Ji = rs.length - 1;
    } else if (Ji < 0)
      if (ls) Ji = 0;
      else return -1;
    if (typeof Gi == "string" && (Gi = Ve.from(Gi, ss)), Ve.isBuffer(Gi))
      return Gi.length === 0 ? -1 : Zi(rs, Gi, Ji, ss, ls);
    if (typeof Gi == "number")
      return Gi = Gi & 255, typeof Te.prototype.indexOf == "function" ? ls ? Te.prototype.indexOf.call(rs, Gi, Ji) : Te.prototype.lastIndexOf.call(rs, Gi, Ji) : Zi(rs, [Gi], Ji, ss, ls);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Zi(rs, Gi, Ji, ss, ls) {
    let ds = 1, bs = rs.length, Mo = Gi.length;
    if (ss !== void 0 && (ss = String(ss).toLowerCase(), ss === "ucs2" || ss === "ucs-2" || ss === "utf16le" || ss === "utf-16le")) {
      if (rs.length < 2 || Gi.length < 2)
        return -1;
      ds = 2, bs /= 2, Mo /= 2, Ji /= 2;
    }
    function Fo(Uo, Lo) {
      return ds === 1 ? Uo[Lo] : Uo.readUInt16BE(Lo * ds);
    }
    let Bo;
    if (ls) {
      let Uo = -1;
      for (Bo = Ji; Bo < bs; Bo++)
        if (Fo(rs, Bo) === Fo(Gi, Uo === -1 ? 0 : Bo - Uo)) {
          if (Uo === -1 && (Uo = Bo), Bo - Uo + 1 === Mo) return Uo * ds;
        } else
          Uo !== -1 && (Bo -= Bo - Uo), Uo = -1;
    } else
      for (Ji + Mo > bs && (Ji = bs - Mo), Bo = Ji; Bo >= 0; Bo--) {
        let Uo = !0;
        for (let Lo = 0; Lo < Mo; Lo++)
          if (Fo(rs, Bo + Lo) !== Fo(Gi, Lo)) {
            Uo = !1;
            break;
          }
        if (Uo) return Bo;
      }
    return -1;
  }
  Ve.prototype.includes = function(Gi, Ji, ss) {
    return this.indexOf(Gi, Ji, ss) !== -1;
  }, Ve.prototype.indexOf = function(Gi, Ji, ss) {
    return ji(this, Gi, Ji, ss, !0);
  }, Ve.prototype.lastIndexOf = function(Gi, Ji, ss) {
    return ji(this, Gi, Ji, ss, !1);
  };
  function zi(rs, Gi, Ji, ss) {
    Ji = Number(Ji) || 0;
    const ls = rs.length - Ji;
    ss ? (ss = Number(ss), ss > ls && (ss = ls)) : ss = ls;
    const ds = Gi.length;
    ss > ds / 2 && (ss = ds / 2);
    let bs;
    for (bs = 0; bs < ss; ++bs) {
      const Mo = parseInt(Gi.substr(bs * 2, 2), 16);
      if (To(Mo)) return bs;
      rs[Ji + bs] = Mo;
    }
    return bs;
  }
  function xi(rs, Gi, Ji, ss) {
    return $o(So(Gi, rs.length - Ji), rs, Ji, ss);
  }
  function $i(rs, Gi, Ji, ss) {
    return $o(_o(Gi), rs, Ji, ss);
  }
  function vi(rs, Gi, Ji, ss) {
    return $o(Ro(Gi), rs, Ji, ss);
  }
  function wi(rs, Gi, Ji, ss) {
    return $o(vo(Gi, rs.length - Ji), rs, Ji, ss);
  }
  Ve.prototype.write = function(Gi, Ji, ss, ls) {
    if (Ji === void 0)
      ls = "utf8", ss = this.length, Ji = 0;
    else if (ss === void 0 && typeof Ji == "string")
      ls = Ji, ss = this.length, Ji = 0;
    else if (isFinite(Ji))
      Ji = Ji >>> 0, isFinite(ss) ? (ss = ss >>> 0, ls === void 0 && (ls = "utf8")) : (ls = ss, ss = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const ds = this.length - Ji;
    if ((ss === void 0 || ss > ds) && (ss = ds), Gi.length > 0 && (ss < 0 || Ji < 0) || Ji > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    ls || (ls = "utf8");
    let bs = !1;
    for (; ; )
      switch (ls) {
        case "hex":
          return zi(this, Gi, Ji, ss);
        case "utf8":
        case "utf-8":
          return xi(this, Gi, Ji, ss);
        case "ascii":
        case "latin1":
        case "binary":
          return $i(this, Gi, Ji, ss);
        case "base64":
          return vi(this, Gi, Ji, ss);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return wi(this, Gi, Ji, ss);
        default:
          if (bs) throw new TypeError("Unknown encoding: " + ls);
          ls = ("" + ls).toLowerCase(), bs = !0;
      }
  }, Ve.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function Ai(rs, Gi, Ji) {
    return Gi === 0 && Ji === rs.length ? t.fromByteArray(rs) : t.fromByteArray(rs.slice(Gi, Ji));
  }
  function Ri(rs, Gi, Ji) {
    Ji = Math.min(rs.length, Ji);
    const ss = [];
    let ls = Gi;
    for (; ls < Ji; ) {
      const ds = rs[ls];
      let bs = null, Mo = ds > 239 ? 4 : ds > 223 ? 3 : ds > 191 ? 2 : 1;
      if (ls + Mo <= Ji) {
        let Fo, Bo, Uo, Lo;
        switch (Mo) {
          case 1:
            ds < 128 && (bs = ds);
            break;
          case 2:
            Fo = rs[ls + 1], (Fo & 192) === 128 && (Lo = (ds & 31) << 6 | Fo & 63, Lo > 127 && (bs = Lo));
            break;
          case 3:
            Fo = rs[ls + 1], Bo = rs[ls + 2], (Fo & 192) === 128 && (Bo & 192) === 128 && (Lo = (ds & 15) << 12 | (Fo & 63) << 6 | Bo & 63, Lo > 2047 && (Lo < 55296 || Lo > 57343) && (bs = Lo));
            break;
          case 4:
            Fo = rs[ls + 1], Bo = rs[ls + 2], Uo = rs[ls + 3], (Fo & 192) === 128 && (Bo & 192) === 128 && (Uo & 192) === 128 && (Lo = (ds & 15) << 18 | (Fo & 63) << 12 | (Bo & 63) << 6 | Uo & 63, Lo > 65535 && Lo < 1114112 && (bs = Lo));
        }
      }
      bs === null ? (bs = 65533, Mo = 1) : bs > 65535 && (bs -= 65536, ss.push(bs >>> 10 & 1023 | 55296), bs = 56320 | bs & 1023), ss.push(bs), ls += Mo;
    }
    return Ci(ss);
  }
  const Ti = 4096;
  function Ci(rs) {
    const Gi = rs.length;
    if (Gi <= Ti)
      return String.fromCharCode.apply(String, rs);
    let Ji = "", ss = 0;
    for (; ss < Gi; )
      Ji += String.fromCharCode.apply(
        String,
        rs.slice(ss, ss += Ti)
      );
    return Ji;
  }
  function Ii(rs, Gi, Ji) {
    let ss = "";
    Ji = Math.min(rs.length, Ji);
    for (let ls = Gi; ls < Ji; ++ls)
      ss += String.fromCharCode(rs[ls] & 127);
    return ss;
  }
  function Li(rs, Gi, Ji) {
    let ss = "";
    Ji = Math.min(rs.length, Ji);
    for (let ls = Gi; ls < Ji; ++ls)
      ss += String.fromCharCode(rs[ls]);
    return ss;
  }
  function Ni(rs, Gi, Ji) {
    const ss = rs.length;
    (!Gi || Gi < 0) && (Gi = 0), (!Ji || Ji < 0 || Ji > ss) && (Ji = ss);
    let ls = "";
    for (let ds = Gi; ds < Ji; ++ds)
      ls += Ao[rs[ds]];
    return ls;
  }
  function Vi(rs, Gi, Ji) {
    const ss = rs.slice(Gi, Ji);
    let ls = "";
    for (let ds = 0; ds < ss.length - 1; ds += 2)
      ls += String.fromCharCode(ss[ds] + ss[ds + 1] * 256);
    return ls;
  }
  Ve.prototype.slice = function(Gi, Ji) {
    const ss = this.length;
    Gi = ~~Gi, Ji = Ji === void 0 ? ss : ~~Ji, Gi < 0 ? (Gi += ss, Gi < 0 && (Gi = 0)) : Gi > ss && (Gi = ss), Ji < 0 ? (Ji += ss, Ji < 0 && (Ji = 0)) : Ji > ss && (Ji = ss), Ji < Gi && (Ji = Gi);
    const ls = this.subarray(Gi, Ji);
    return Object.setPrototypeOf(ls, Ve.prototype), ls;
  };
  function is(rs, Gi, Ji) {
    if (rs % 1 !== 0 || rs < 0) throw new RangeError("offset is not uint");
    if (rs + Gi > Ji) throw new RangeError("Trying to access beyond buffer length");
  }
  Ve.prototype.readUintLE = Ve.prototype.readUIntLE = function(Gi, Ji, ss) {
    Gi = Gi >>> 0, Ji = Ji >>> 0, ss || is(Gi, Ji, this.length);
    let ls = this[Gi], ds = 1, bs = 0;
    for (; ++bs < Ji && (ds *= 256); )
      ls += this[Gi + bs] * ds;
    return ls;
  }, Ve.prototype.readUintBE = Ve.prototype.readUIntBE = function(Gi, Ji, ss) {
    Gi = Gi >>> 0, Ji = Ji >>> 0, ss || is(Gi, Ji, this.length);
    let ls = this[Gi + --Ji], ds = 1;
    for (; Ji > 0 && (ds *= 256); )
      ls += this[Gi + --Ji] * ds;
    return ls;
  }, Ve.prototype.readUint8 = Ve.prototype.readUInt8 = function(Gi, Ji) {
    return Gi = Gi >>> 0, Ji || is(Gi, 1, this.length), this[Gi];
  }, Ve.prototype.readUint16LE = Ve.prototype.readUInt16LE = function(Gi, Ji) {
    return Gi = Gi >>> 0, Ji || is(Gi, 2, this.length), this[Gi] | this[Gi + 1] << 8;
  }, Ve.prototype.readUint16BE = Ve.prototype.readUInt16BE = function(Gi, Ji) {
    return Gi = Gi >>> 0, Ji || is(Gi, 2, this.length), this[Gi] << 8 | this[Gi + 1];
  }, Ve.prototype.readUint32LE = Ve.prototype.readUInt32LE = function(Gi, Ji) {
    return Gi = Gi >>> 0, Ji || is(Gi, 4, this.length), (this[Gi] | this[Gi + 1] << 8 | this[Gi + 2] << 16) + this[Gi + 3] * 16777216;
  }, Ve.prototype.readUint32BE = Ve.prototype.readUInt32BE = function(Gi, Ji) {
    return Gi = Gi >>> 0, Ji || is(Gi, 4, this.length), this[Gi] * 16777216 + (this[Gi + 1] << 16 | this[Gi + 2] << 8 | this[Gi + 3]);
  }, Ve.prototype.readBigUInt64LE = Po(function(Gi) {
    Gi = Gi >>> 0, ps(Gi, "offset");
    const Ji = this[Gi], ss = this[Gi + 7];
    (Ji === void 0 || ss === void 0) && Ds(Gi, this.length - 8);
    const ls = Ji + this[++Gi] * 2 ** 8 + this[++Gi] * 2 ** 16 + this[++Gi] * 2 ** 24, ds = this[++Gi] + this[++Gi] * 2 ** 8 + this[++Gi] * 2 ** 16 + ss * 2 ** 24;
    return BigInt(ls) + (BigInt(ds) << BigInt(32));
  }), Ve.prototype.readBigUInt64BE = Po(function(Gi) {
    Gi = Gi >>> 0, ps(Gi, "offset");
    const Ji = this[Gi], ss = this[Gi + 7];
    (Ji === void 0 || ss === void 0) && Ds(Gi, this.length - 8);
    const ls = Ji * 2 ** 24 + this[++Gi] * 2 ** 16 + this[++Gi] * 2 ** 8 + this[++Gi], ds = this[++Gi] * 2 ** 24 + this[++Gi] * 2 ** 16 + this[++Gi] * 2 ** 8 + ss;
    return (BigInt(ls) << BigInt(32)) + BigInt(ds);
  }), Ve.prototype.readIntLE = function(Gi, Ji, ss) {
    Gi = Gi >>> 0, Ji = Ji >>> 0, ss || is(Gi, Ji, this.length);
    let ls = this[Gi], ds = 1, bs = 0;
    for (; ++bs < Ji && (ds *= 256); )
      ls += this[Gi + bs] * ds;
    return ds *= 128, ls >= ds && (ls -= Math.pow(2, 8 * Ji)), ls;
  }, Ve.prototype.readIntBE = function(Gi, Ji, ss) {
    Gi = Gi >>> 0, Ji = Ji >>> 0, ss || is(Gi, Ji, this.length);
    let ls = Ji, ds = 1, bs = this[Gi + --ls];
    for (; ls > 0 && (ds *= 256); )
      bs += this[Gi + --ls] * ds;
    return ds *= 128, bs >= ds && (bs -= Math.pow(2, 8 * Ji)), bs;
  }, Ve.prototype.readInt8 = function(Gi, Ji) {
    return Gi = Gi >>> 0, Ji || is(Gi, 1, this.length), this[Gi] & 128 ? (255 - this[Gi] + 1) * -1 : this[Gi];
  }, Ve.prototype.readInt16LE = function(Gi, Ji) {
    Gi = Gi >>> 0, Ji || is(Gi, 2, this.length);
    const ss = this[Gi] | this[Gi + 1] << 8;
    return ss & 32768 ? ss | 4294901760 : ss;
  }, Ve.prototype.readInt16BE = function(Gi, Ji) {
    Gi = Gi >>> 0, Ji || is(Gi, 2, this.length);
    const ss = this[Gi + 1] | this[Gi] << 8;
    return ss & 32768 ? ss | 4294901760 : ss;
  }, Ve.prototype.readInt32LE = function(Gi, Ji) {
    return Gi = Gi >>> 0, Ji || is(Gi, 4, this.length), this[Gi] | this[Gi + 1] << 8 | this[Gi + 2] << 16 | this[Gi + 3] << 24;
  }, Ve.prototype.readInt32BE = function(Gi, Ji) {
    return Gi = Gi >>> 0, Ji || is(Gi, 4, this.length), this[Gi] << 24 | this[Gi + 1] << 16 | this[Gi + 2] << 8 | this[Gi + 3];
  }, Ve.prototype.readBigInt64LE = Po(function(Gi) {
    Gi = Gi >>> 0, ps(Gi, "offset");
    const Ji = this[Gi], ss = this[Gi + 7];
    (Ji === void 0 || ss === void 0) && Ds(Gi, this.length - 8);
    const ls = this[Gi + 4] + this[Gi + 5] * 2 ** 8 + this[Gi + 6] * 2 ** 16 + (ss << 24);
    return (BigInt(ls) << BigInt(32)) + BigInt(Ji + this[++Gi] * 2 ** 8 + this[++Gi] * 2 ** 16 + this[++Gi] * 2 ** 24);
  }), Ve.prototype.readBigInt64BE = Po(function(Gi) {
    Gi = Gi >>> 0, ps(Gi, "offset");
    const Ji = this[Gi], ss = this[Gi + 7];
    (Ji === void 0 || ss === void 0) && Ds(Gi, this.length - 8);
    const ls = (Ji << 24) + // Overflow
    this[++Gi] * 2 ** 16 + this[++Gi] * 2 ** 8 + this[++Gi];
    return (BigInt(ls) << BigInt(32)) + BigInt(this[++Gi] * 2 ** 24 + this[++Gi] * 2 ** 16 + this[++Gi] * 2 ** 8 + ss);
  }), Ve.prototype.readFloatLE = function(Gi, Ji) {
    return Gi = Gi >>> 0, Ji || is(Gi, 4, this.length), Ie.read(this, Gi, !0, 23, 4);
  }, Ve.prototype.readFloatBE = function(Gi, Ji) {
    return Gi = Gi >>> 0, Ji || is(Gi, 4, this.length), Ie.read(this, Gi, !1, 23, 4);
  }, Ve.prototype.readDoubleLE = function(Gi, Ji) {
    return Gi = Gi >>> 0, Ji || is(Gi, 8, this.length), Ie.read(this, Gi, !0, 52, 8);
  }, Ve.prototype.readDoubleBE = function(Gi, Ji) {
    return Gi = Gi >>> 0, Ji || is(Gi, 8, this.length), Ie.read(this, Gi, !1, 52, 8);
  };
  function Ki(rs, Gi, Ji, ss, ls, ds) {
    if (!Ve.isBuffer(rs)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (Gi > ls || Gi < ds) throw new RangeError('"value" argument is out of bounds');
    if (Ji + ss > rs.length) throw new RangeError("Index out of range");
  }
  Ve.prototype.writeUintLE = Ve.prototype.writeUIntLE = function(Gi, Ji, ss, ls) {
    if (Gi = +Gi, Ji = Ji >>> 0, ss = ss >>> 0, !ls) {
      const Mo = Math.pow(2, 8 * ss) - 1;
      Ki(this, Gi, Ji, ss, Mo, 0);
    }
    let ds = 1, bs = 0;
    for (this[Ji] = Gi & 255; ++bs < ss && (ds *= 256); )
      this[Ji + bs] = Gi / ds & 255;
    return Ji + ss;
  }, Ve.prototype.writeUintBE = Ve.prototype.writeUIntBE = function(Gi, Ji, ss, ls) {
    if (Gi = +Gi, Ji = Ji >>> 0, ss = ss >>> 0, !ls) {
      const Mo = Math.pow(2, 8 * ss) - 1;
      Ki(this, Gi, Ji, ss, Mo, 0);
    }
    let ds = ss - 1, bs = 1;
    for (this[Ji + ds] = Gi & 255; --ds >= 0 && (bs *= 256); )
      this[Ji + ds] = Gi / bs & 255;
    return Ji + ss;
  }, Ve.prototype.writeUint8 = Ve.prototype.writeUInt8 = function(Gi, Ji, ss) {
    return Gi = +Gi, Ji = Ji >>> 0, ss || Ki(this, Gi, Ji, 1, 255, 0), this[Ji] = Gi & 255, Ji + 1;
  }, Ve.prototype.writeUint16LE = Ve.prototype.writeUInt16LE = function(Gi, Ji, ss) {
    return Gi = +Gi, Ji = Ji >>> 0, ss || Ki(this, Gi, Ji, 2, 65535, 0), this[Ji] = Gi & 255, this[Ji + 1] = Gi >>> 8, Ji + 2;
  }, Ve.prototype.writeUint16BE = Ve.prototype.writeUInt16BE = function(Gi, Ji, ss) {
    return Gi = +Gi, Ji = Ji >>> 0, ss || Ki(this, Gi, Ji, 2, 65535, 0), this[Ji] = Gi >>> 8, this[Ji + 1] = Gi & 255, Ji + 2;
  }, Ve.prototype.writeUint32LE = Ve.prototype.writeUInt32LE = function(Gi, Ji, ss) {
    return Gi = +Gi, Ji = Ji >>> 0, ss || Ki(this, Gi, Ji, 4, 4294967295, 0), this[Ji + 3] = Gi >>> 24, this[Ji + 2] = Gi >>> 16, this[Ji + 1] = Gi >>> 8, this[Ji] = Gi & 255, Ji + 4;
  }, Ve.prototype.writeUint32BE = Ve.prototype.writeUInt32BE = function(Gi, Ji, ss) {
    return Gi = +Gi, Ji = Ji >>> 0, ss || Ki(this, Gi, Ji, 4, 4294967295, 0), this[Ji] = Gi >>> 24, this[Ji + 1] = Gi >>> 16, this[Ji + 2] = Gi >>> 8, this[Ji + 3] = Gi & 255, Ji + 4;
  };
  function ts(rs, Gi, Ji, ss, ls) {
    us(Gi, ss, ls, rs, Ji, 7);
    let ds = Number(Gi & BigInt(4294967295));
    rs[Ji++] = ds, ds = ds >> 8, rs[Ji++] = ds, ds = ds >> 8, rs[Ji++] = ds, ds = ds >> 8, rs[Ji++] = ds;
    let bs = Number(Gi >> BigInt(32) & BigInt(4294967295));
    return rs[Ji++] = bs, bs = bs >> 8, rs[Ji++] = bs, bs = bs >> 8, rs[Ji++] = bs, bs = bs >> 8, rs[Ji++] = bs, Ji;
  }
  function qi(rs, Gi, Ji, ss, ls) {
    us(Gi, ss, ls, rs, Ji, 7);
    let ds = Number(Gi & BigInt(4294967295));
    rs[Ji + 7] = ds, ds = ds >> 8, rs[Ji + 6] = ds, ds = ds >> 8, rs[Ji + 5] = ds, ds = ds >> 8, rs[Ji + 4] = ds;
    let bs = Number(Gi >> BigInt(32) & BigInt(4294967295));
    return rs[Ji + 3] = bs, bs = bs >> 8, rs[Ji + 2] = bs, bs = bs >> 8, rs[Ji + 1] = bs, bs = bs >> 8, rs[Ji] = bs, Ji + 8;
  }
  Ve.prototype.writeBigUInt64LE = Po(function(Gi, Ji = 0) {
    return ts(this, Gi, Ji, BigInt(0), BigInt("0xffffffffffffffff"));
  }), Ve.prototype.writeBigUInt64BE = Po(function(Gi, Ji = 0) {
    return qi(this, Gi, Ji, BigInt(0), BigInt("0xffffffffffffffff"));
  }), Ve.prototype.writeIntLE = function(Gi, Ji, ss, ls) {
    if (Gi = +Gi, Ji = Ji >>> 0, !ls) {
      const Fo = Math.pow(2, 8 * ss - 1);
      Ki(this, Gi, Ji, ss, Fo - 1, -Fo);
    }
    let ds = 0, bs = 1, Mo = 0;
    for (this[Ji] = Gi & 255; ++ds < ss && (bs *= 256); )
      Gi < 0 && Mo === 0 && this[Ji + ds - 1] !== 0 && (Mo = 1), this[Ji + ds] = (Gi / bs >> 0) - Mo & 255;
    return Ji + ss;
  }, Ve.prototype.writeIntBE = function(Gi, Ji, ss, ls) {
    if (Gi = +Gi, Ji = Ji >>> 0, !ls) {
      const Fo = Math.pow(2, 8 * ss - 1);
      Ki(this, Gi, Ji, ss, Fo - 1, -Fo);
    }
    let ds = ss - 1, bs = 1, Mo = 0;
    for (this[Ji + ds] = Gi & 255; --ds >= 0 && (bs *= 256); )
      Gi < 0 && Mo === 0 && this[Ji + ds + 1] !== 0 && (Mo = 1), this[Ji + ds] = (Gi / bs >> 0) - Mo & 255;
    return Ji + ss;
  }, Ve.prototype.writeInt8 = function(Gi, Ji, ss) {
    return Gi = +Gi, Ji = Ji >>> 0, ss || Ki(this, Gi, Ji, 1, 127, -128), Gi < 0 && (Gi = 255 + Gi + 1), this[Ji] = Gi & 255, Ji + 1;
  }, Ve.prototype.writeInt16LE = function(Gi, Ji, ss) {
    return Gi = +Gi, Ji = Ji >>> 0, ss || Ki(this, Gi, Ji, 2, 32767, -32768), this[Ji] = Gi & 255, this[Ji + 1] = Gi >>> 8, Ji + 2;
  }, Ve.prototype.writeInt16BE = function(Gi, Ji, ss) {
    return Gi = +Gi, Ji = Ji >>> 0, ss || Ki(this, Gi, Ji, 2, 32767, -32768), this[Ji] = Gi >>> 8, this[Ji + 1] = Gi & 255, Ji + 2;
  }, Ve.prototype.writeInt32LE = function(Gi, Ji, ss) {
    return Gi = +Gi, Ji = Ji >>> 0, ss || Ki(this, Gi, Ji, 4, 2147483647, -2147483648), this[Ji] = Gi & 255, this[Ji + 1] = Gi >>> 8, this[Ji + 2] = Gi >>> 16, this[Ji + 3] = Gi >>> 24, Ji + 4;
  }, Ve.prototype.writeInt32BE = function(Gi, Ji, ss) {
    return Gi = +Gi, Ji = Ji >>> 0, ss || Ki(this, Gi, Ji, 4, 2147483647, -2147483648), Gi < 0 && (Gi = 4294967295 + Gi + 1), this[Ji] = Gi >>> 24, this[Ji + 1] = Gi >>> 16, this[Ji + 2] = Gi >>> 8, this[Ji + 3] = Gi & 255, Ji + 4;
  }, Ve.prototype.writeBigInt64LE = Po(function(Gi, Ji = 0) {
    return ts(this, Gi, Ji, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), Ve.prototype.writeBigInt64BE = Po(function(Gi, Ji = 0) {
    return qi(this, Gi, Ji, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Hi(rs, Gi, Ji, ss, ls, ds) {
    if (Ji + ss > rs.length) throw new RangeError("Index out of range");
    if (Ji < 0) throw new RangeError("Index out of range");
  }
  function Xi(rs, Gi, Ji, ss, ls) {
    return Gi = +Gi, Ji = Ji >>> 0, ls || Hi(rs, Gi, Ji, 4), Ie.write(rs, Gi, Ji, ss, 23, 4), Ji + 4;
  }
  Ve.prototype.writeFloatLE = function(Gi, Ji, ss) {
    return Xi(this, Gi, Ji, !0, ss);
  }, Ve.prototype.writeFloatBE = function(Gi, Ji, ss) {
    return Xi(this, Gi, Ji, !1, ss);
  };
  function ki(rs, Gi, Ji, ss, ls) {
    return Gi = +Gi, Ji = Ji >>> 0, ls || Hi(rs, Gi, Ji, 8), Ie.write(rs, Gi, Ji, ss, 52, 8), Ji + 8;
  }
  Ve.prototype.writeDoubleLE = function(Gi, Ji, ss) {
    return ki(this, Gi, Ji, !0, ss);
  }, Ve.prototype.writeDoubleBE = function(Gi, Ji, ss) {
    return ki(this, Gi, Ji, !1, ss);
  }, Ve.prototype.copy = function(Gi, Ji, ss, ls) {
    if (!Ve.isBuffer(Gi)) throw new TypeError("argument should be a Buffer");
    if (ss || (ss = 0), !ls && ls !== 0 && (ls = this.length), Ji >= Gi.length && (Ji = Gi.length), Ji || (Ji = 0), ls > 0 && ls < ss && (ls = ss), ls === ss || Gi.length === 0 || this.length === 0) return 0;
    if (Ji < 0)
      throw new RangeError("targetStart out of bounds");
    if (ss < 0 || ss >= this.length) throw new RangeError("Index out of range");
    if (ls < 0) throw new RangeError("sourceEnd out of bounds");
    ls > this.length && (ls = this.length), Gi.length - Ji < ls - ss && (ls = Gi.length - Ji + ss);
    const ds = ls - ss;
    return this === Gi && typeof Te.prototype.copyWithin == "function" ? this.copyWithin(Ji, ss, ls) : Te.prototype.set.call(
      Gi,
      this.subarray(ss, ls),
      Ji
    ), ds;
  }, Ve.prototype.fill = function(Gi, Ji, ss, ls) {
    if (typeof Gi == "string") {
      if (typeof Ji == "string" ? (ls = Ji, Ji = 0, ss = this.length) : typeof ss == "string" && (ls = ss, ss = this.length), ls !== void 0 && typeof ls != "string")
        throw new TypeError("encoding must be a string");
      if (typeof ls == "string" && !Ve.isEncoding(ls))
        throw new TypeError("Unknown encoding: " + ls);
      if (Gi.length === 1) {
        const bs = Gi.charCodeAt(0);
        (ls === "utf8" && bs < 128 || ls === "latin1") && (Gi = bs);
      }
    } else typeof Gi == "number" ? Gi = Gi & 255 : typeof Gi == "boolean" && (Gi = Number(Gi));
    if (Ji < 0 || this.length < Ji || this.length < ss)
      throw new RangeError("Out of range index");
    if (ss <= Ji)
      return this;
    Ji = Ji >>> 0, ss = ss === void 0 ? this.length : ss >>> 0, Gi || (Gi = 0);
    let ds;
    if (typeof Gi == "number")
      for (ds = Ji; ds < ss; ++ds)
        this[ds] = Gi;
    else {
      const bs = Ve.isBuffer(Gi) ? Gi : Ve.from(Gi, ls), Mo = bs.length;
      if (Mo === 0)
        throw new TypeError('The value "' + Gi + '" is invalid for argument "value"');
      for (ds = 0; ds < ss - Ji; ++ds)
        this[ds + Ji] = bs[ds % Mo];
    }
    return this;
  };
  const Wi = {};
  function Yi(rs, Gi, Ji) {
    Wi[rs] = class extends Ji {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: Gi.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${rs}]`, this.stack, delete this.name;
      }
      get code() {
        return rs;
      }
      set code(ls) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: ls,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${rs}]: ${this.message}`;
      }
    };
  }
  Yi(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(rs) {
      return rs ? `${rs} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Yi(
    "ERR_INVALID_ARG_TYPE",
    function(rs, Gi) {
      return `The "${rs}" argument must be of type number. Received type ${typeof Gi}`;
    },
    TypeError
  ), Yi(
    "ERR_OUT_OF_RANGE",
    function(rs, Gi, Ji) {
      let ss = `The value of "${rs}" is out of range.`, ls = Ji;
      return Number.isInteger(Ji) && Math.abs(Ji) > 2 ** 32 ? ls = Qi(String(Ji)) : typeof Ji == "bigint" && (ls = String(Ji), (Ji > BigInt(2) ** BigInt(32) || Ji < -(BigInt(2) ** BigInt(32))) && (ls = Qi(ls)), ls += "n"), ss += ` It must be ${Gi}. Received ${ls}`, ss;
    },
    RangeError
  );
  function Qi(rs) {
    let Gi = "", Ji = rs.length;
    const ss = rs[0] === "-" ? 1 : 0;
    for (; Ji >= ss + 4; Ji -= 3)
      Gi = `_${rs.slice(Ji - 3, Ji)}${Gi}`;
    return `${rs.slice(0, Ji)}${Gi}`;
  }
  function ns(rs, Gi, Ji) {
    ps(Gi, "offset"), (rs[Gi] === void 0 || rs[Gi + Ji] === void 0) && Ds(Gi, rs.length - (Ji + 1));
  }
  function us(rs, Gi, Ji, ss, ls, ds) {
    if (rs > Ji || rs < Gi) {
      const bs = typeof Gi == "bigint" ? "n" : "";
      let Mo;
      throw Gi === 0 || Gi === BigInt(0) ? Mo = `>= 0${bs} and < 2${bs} ** ${(ds + 1) * 8}${bs}` : Mo = `>= -(2${bs} ** ${(ds + 1) * 8 - 1}${bs}) and < 2 ** ${(ds + 1) * 8 - 1}${bs}`, new Wi.ERR_OUT_OF_RANGE("value", Mo, rs);
    }
    ns(ss, ls, ds);
  }
  function ps(rs, Gi) {
    if (typeof rs != "number")
      throw new Wi.ERR_INVALID_ARG_TYPE(Gi, "number", rs);
  }
  function Ds(rs, Gi, Ji) {
    throw Math.floor(rs) !== rs ? (ps(rs, Ji), new Wi.ERR_OUT_OF_RANGE("offset", "an integer", rs)) : Gi < 0 ? new Wi.ERR_BUFFER_OUT_OF_BOUNDS() : new Wi.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${Gi}`,
      rs
    );
  }
  const Eo = /[^+/0-9A-Za-z-_]/g;
  function hs(rs) {
    if (rs = rs.split("=")[0], rs = rs.trim().replace(Eo, ""), rs.length < 2) return "";
    for (; rs.length % 4 !== 0; )
      rs = rs + "=";
    return rs;
  }
  function So(rs, Gi) {
    Gi = Gi || 1 / 0;
    let Ji;
    const ss = rs.length;
    let ls = null;
    const ds = [];
    for (let bs = 0; bs < ss; ++bs) {
      if (Ji = rs.charCodeAt(bs), Ji > 55295 && Ji < 57344) {
        if (!ls) {
          if (Ji > 56319) {
            (Gi -= 3) > -1 && ds.push(239, 191, 189);
            continue;
          } else if (bs + 1 === ss) {
            (Gi -= 3) > -1 && ds.push(239, 191, 189);
            continue;
          }
          ls = Ji;
          continue;
        }
        if (Ji < 56320) {
          (Gi -= 3) > -1 && ds.push(239, 191, 189), ls = Ji;
          continue;
        }
        Ji = (ls - 55296 << 10 | Ji - 56320) + 65536;
      } else ls && (Gi -= 3) > -1 && ds.push(239, 191, 189);
      if (ls = null, Ji < 128) {
        if ((Gi -= 1) < 0) break;
        ds.push(Ji);
      } else if (Ji < 2048) {
        if ((Gi -= 2) < 0) break;
        ds.push(
          Ji >> 6 | 192,
          Ji & 63 | 128
        );
      } else if (Ji < 65536) {
        if ((Gi -= 3) < 0) break;
        ds.push(
          Ji >> 12 | 224,
          Ji >> 6 & 63 | 128,
          Ji & 63 | 128
        );
      } else if (Ji < 1114112) {
        if ((Gi -= 4) < 0) break;
        ds.push(
          Ji >> 18 | 240,
          Ji >> 12 & 63 | 128,
          Ji >> 6 & 63 | 128,
          Ji & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return ds;
  }
  function _o(rs) {
    const Gi = [];
    for (let Ji = 0; Ji < rs.length; ++Ji)
      Gi.push(rs.charCodeAt(Ji) & 255);
    return Gi;
  }
  function vo(rs, Gi) {
    let Ji, ss, ls;
    const ds = [];
    for (let bs = 0; bs < rs.length && !((Gi -= 2) < 0); ++bs)
      Ji = rs.charCodeAt(bs), ss = Ji >> 8, ls = Ji % 256, ds.push(ls), ds.push(ss);
    return ds;
  }
  function Ro(rs) {
    return t.toByteArray(hs(rs));
  }
  function $o(rs, Gi, Ji, ss) {
    let ls;
    for (ls = 0; ls < ss && !(ls + Ji >= Gi.length || ls >= rs.length); ++ls)
      Gi[ls + Ji] = rs[ls];
    return ls;
  }
  function Io(rs, Gi) {
    return rs instanceof Gi || rs != null && rs.constructor != null && rs.constructor.name != null && rs.constructor.name === Gi.name;
  }
  function To(rs) {
    return rs !== rs;
  }
  const Ao = function() {
    const rs = "0123456789abcdef", Gi = new Array(256);
    for (let Ji = 0; Ji < 16; ++Ji) {
      const ss = Ji * 16;
      for (let ls = 0; ls < 16; ++ls)
        Gi[ss + ls] = rs[Ji] + rs[ls];
    }
    return Gi;
  }();
  function Po(rs) {
    return typeof BigInt > "u" ? Co : rs;
  }
  function Co() {
    throw new Error("BigInt not supported");
  }
})(buffer$2);
const Buffer$3 = buffer$2.Buffer, Blob$1 = buffer$2.Blob, BlobOptions = buffer$2.BlobOptions, Buffer$1$1 = buffer$2.Buffer, File$1 = buffer$2.File, FileOptions = buffer$2.FileOptions, INSPECT_MAX_BYTES = buffer$2.INSPECT_MAX_BYTES, SlowBuffer = buffer$2.SlowBuffer, TranscodeEncoding = buffer$2.TranscodeEncoding, atob$1 = buffer$2.atob, btoa$1 = buffer$2.btoa, constants$2 = buffer$2.constants, isAscii = buffer$2.isAscii, isUtf8 = buffer$2.isUtf8, kMaxLength = buffer$2.kMaxLength, kStringMaxLength = buffer$2.kStringMaxLength, resolveObjectURL = buffer$2.resolveObjectURL, transcode = buffer$2.transcode, dist$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: Blob$1,
  BlobOptions,
  Buffer: Buffer$1$1,
  File: File$1,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob: atob$1,
  btoa: btoa$1,
  constants: constants$2,
  default: Buffer$3,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
var bn$3 = { exports: {} };
const require$$0$4 = /* @__PURE__ */ getAugmentedNamespace(dist$1);
bn$3.exports;
(function(Ae) {
  (function(t, Ie) {
    function Be($i, vi) {
      if (!$i) throw new Error(vi || "Assertion failed");
    }
    function Pe($i, vi) {
      $i.super_ = vi;
      var wi = function() {
      };
      wi.prototype = vi.prototype, $i.prototype = new wi(), $i.prototype.constructor = $i;
    }
    function Te($i, vi, wi) {
      if (Te.isBN($i))
        return $i;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, $i !== null && ((vi === "le" || vi === "be") && (wi = vi, vi = 10), this._init($i || 0, vi || 10, wi || "be"));
    }
    typeof t == "object" ? t.exports = Te : Ie.BN = Te, Te.BN = Te, Te.wordSize = 26;
    var Me;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? Me = window.Buffer : Me = require$$0$4.Buffer;
    } catch {
    }
    Te.isBN = function(vi) {
      return vi instanceof Te ? !0 : vi !== null && typeof vi == "object" && vi.constructor.wordSize === Te.wordSize && Array.isArray(vi.words);
    }, Te.max = function(vi, wi) {
      return vi.cmp(wi) > 0 ? vi : wi;
    }, Te.min = function(vi, wi) {
      return vi.cmp(wi) < 0 ? vi : wi;
    }, Te.prototype._init = function(vi, wi, Ai) {
      if (typeof vi == "number")
        return this._initNumber(vi, wi, Ai);
      if (typeof vi == "object")
        return this._initArray(vi, wi, Ai);
      wi === "hex" && (wi = 16), Be(wi === (wi | 0) && wi >= 2 && wi <= 36), vi = vi.toString().replace(/\s+/g, "");
      var Ri = 0;
      vi[0] === "-" && (Ri++, this.negative = 1), Ri < vi.length && (wi === 16 ? this._parseHex(vi, Ri, Ai) : (this._parseBase(vi, wi, Ri), Ai === "le" && this._initArray(this.toArray(), wi, Ai)));
    }, Te.prototype._initNumber = function(vi, wi, Ai) {
      vi < 0 && (this.negative = 1, vi = -vi), vi < 67108864 ? (this.words = [vi & 67108863], this.length = 1) : vi < 4503599627370496 ? (this.words = [
        vi & 67108863,
        vi / 67108864 & 67108863
      ], this.length = 2) : (Be(vi < 9007199254740992), this.words = [
        vi & 67108863,
        vi / 67108864 & 67108863,
        1
      ], this.length = 3), Ai === "le" && this._initArray(this.toArray(), wi, Ai);
    }, Te.prototype._initArray = function(vi, wi, Ai) {
      if (Be(typeof vi.length == "number"), vi.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(vi.length / 3), this.words = new Array(this.length);
      for (var Ri = 0; Ri < this.length; Ri++)
        this.words[Ri] = 0;
      var Ti, Ci, Ii = 0;
      if (Ai === "be")
        for (Ri = vi.length - 1, Ti = 0; Ri >= 0; Ri -= 3)
          Ci = vi[Ri] | vi[Ri - 1] << 8 | vi[Ri - 2] << 16, this.words[Ti] |= Ci << Ii & 67108863, this.words[Ti + 1] = Ci >>> 26 - Ii & 67108863, Ii += 24, Ii >= 26 && (Ii -= 26, Ti++);
      else if (Ai === "le")
        for (Ri = 0, Ti = 0; Ri < vi.length; Ri += 3)
          Ci = vi[Ri] | vi[Ri + 1] << 8 | vi[Ri + 2] << 16, this.words[Ti] |= Ci << Ii & 67108863, this.words[Ti + 1] = Ci >>> 26 - Ii & 67108863, Ii += 24, Ii >= 26 && (Ii -= 26, Ti++);
      return this._strip();
    };
    function Ue($i, vi) {
      var wi = $i.charCodeAt(vi);
      if (wi >= 48 && wi <= 57)
        return wi - 48;
      if (wi >= 65 && wi <= 70)
        return wi - 55;
      if (wi >= 97 && wi <= 102)
        return wi - 87;
      Be(!1, "Invalid character in " + $i);
    }
    function je($i, vi, wi) {
      var Ai = Ue($i, wi);
      return wi - 1 >= vi && (Ai |= Ue($i, wi - 1) << 4), Ai;
    }
    Te.prototype._parseHex = function(vi, wi, Ai) {
      this.length = Math.ceil((vi.length - wi) / 6), this.words = new Array(this.length);
      for (var Ri = 0; Ri < this.length; Ri++)
        this.words[Ri] = 0;
      var Ti = 0, Ci = 0, Ii;
      if (Ai === "be")
        for (Ri = vi.length - 1; Ri >= wi; Ri -= 2)
          Ii = je(vi, wi, Ri) << Ti, this.words[Ci] |= Ii & 67108863, Ti >= 18 ? (Ti -= 18, Ci += 1, this.words[Ci] |= Ii >>> 26) : Ti += 8;
      else {
        var Li = vi.length - wi;
        for (Ri = Li % 2 === 0 ? wi + 1 : wi; Ri < vi.length; Ri += 2)
          Ii = je(vi, wi, Ri) << Ti, this.words[Ci] |= Ii & 67108863, Ti >= 18 ? (Ti -= 18, Ci += 1, this.words[Ci] |= Ii >>> 26) : Ti += 8;
      }
      this._strip();
    };
    function fn($i, vi, wi, Ai) {
      for (var Ri = 0, Ti = 0, Ci = Math.min($i.length, wi), Ii = vi; Ii < Ci; Ii++) {
        var Li = $i.charCodeAt(Ii) - 48;
        Ri *= Ai, Li >= 49 ? Ti = Li - 49 + 10 : Li >= 17 ? Ti = Li - 17 + 10 : Ti = Li, Be(Li >= 0 && Ti < Ai, "Invalid character"), Ri += Ti;
      }
      return Ri;
    }
    Te.prototype._parseBase = function(vi, wi, Ai) {
      this.words = [0], this.length = 1;
      for (var Ri = 0, Ti = 1; Ti <= 67108863; Ti *= wi)
        Ri++;
      Ri--, Ti = Ti / wi | 0;
      for (var Ci = vi.length - Ai, Ii = Ci % Ri, Li = Math.min(Ci, Ci - Ii) + Ai, Ni = 0, Vi = Ai; Vi < Li; Vi += Ri)
        Ni = fn(vi, Vi, Vi + Ri, wi), this.imuln(Ti), this.words[0] + Ni < 67108864 ? this.words[0] += Ni : this._iaddn(Ni);
      if (Ii !== 0) {
        var is = 1;
        for (Ni = fn(vi, Vi, vi.length, wi), Vi = 0; Vi < Ii; Vi++)
          is *= wi;
        this.imuln(is), this.words[0] + Ni < 67108864 ? this.words[0] += Ni : this._iaddn(Ni);
      }
      this._strip();
    }, Te.prototype.copy = function(vi) {
      vi.words = new Array(this.length);
      for (var wi = 0; wi < this.length; wi++)
        vi.words[wi] = this.words[wi];
      vi.length = this.length, vi.negative = this.negative, vi.red = this.red;
    };
    function Ve($i, vi) {
      $i.words = vi.words, $i.length = vi.length, $i.negative = vi.negative, $i.red = vi.red;
    }
    if (Te.prototype._move = function(vi) {
      Ve(vi, this);
    }, Te.prototype.clone = function() {
      var vi = new Te(null);
      return this.copy(vi), vi;
    }, Te.prototype._expand = function(vi) {
      for (; this.length < vi; )
        this.words[this.length++] = 0;
      return this;
    }, Te.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, Te.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        Te.prototype[Symbol.for("nodejs.util.inspect.custom")] = vn;
      } catch {
        Te.prototype.inspect = vn;
      }
    else
      Te.prototype.inspect = vn;
    function vn() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var En = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], fi = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], bi = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    Te.prototype.toString = function(vi, wi) {
      vi = vi || 10, wi = wi | 0 || 1;
      var Ai;
      if (vi === 16 || vi === "hex") {
        Ai = "";
        for (var Ri = 0, Ti = 0, Ci = 0; Ci < this.length; Ci++) {
          var Ii = this.words[Ci], Li = ((Ii << Ri | Ti) & 16777215).toString(16);
          Ti = Ii >>> 24 - Ri & 16777215, Ri += 2, Ri >= 26 && (Ri -= 26, Ci--), Ti !== 0 || Ci !== this.length - 1 ? Ai = En[6 - Li.length] + Li + Ai : Ai = Li + Ai;
        }
        for (Ti !== 0 && (Ai = Ti.toString(16) + Ai); Ai.length % wi !== 0; )
          Ai = "0" + Ai;
        return this.negative !== 0 && (Ai = "-" + Ai), Ai;
      }
      if (vi === (vi | 0) && vi >= 2 && vi <= 36) {
        var Ni = fi[vi], Vi = bi[vi];
        Ai = "";
        var is = this.clone();
        for (is.negative = 0; !is.isZero(); ) {
          var Ki = is.modrn(Vi).toString(vi);
          is = is.idivn(Vi), is.isZero() ? Ai = Ki + Ai : Ai = En[Ni - Ki.length] + Ki + Ai;
        }
        for (this.isZero() && (Ai = "0" + Ai); Ai.length % wi !== 0; )
          Ai = "0" + Ai;
        return this.negative !== 0 && (Ai = "-" + Ai), Ai;
      }
      Be(!1, "Base should be between 2 and 36");
    }, Te.prototype.toNumber = function() {
      var vi = this.words[0];
      return this.length === 2 ? vi += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? vi += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && Be(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -vi : vi;
    }, Te.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, Me && (Te.prototype.toBuffer = function(vi, wi) {
      return this.toArrayLike(Me, vi, wi);
    }), Te.prototype.toArray = function(vi, wi) {
      return this.toArrayLike(Array, vi, wi);
    };
    var mi = function(vi, wi) {
      return vi.allocUnsafe ? vi.allocUnsafe(wi) : new vi(wi);
    };
    Te.prototype.toArrayLike = function(vi, wi, Ai) {
      this._strip();
      var Ri = this.byteLength(), Ti = Ai || Math.max(1, Ri);
      Be(Ri <= Ti, "byte array longer than desired length"), Be(Ti > 0, "Requested array length <= 0");
      var Ci = mi(vi, Ti), Ii = wi === "le" ? "LE" : "BE";
      return this["_toArrayLike" + Ii](Ci, Ri), Ci;
    }, Te.prototype._toArrayLikeLE = function(vi, wi) {
      for (var Ai = 0, Ri = 0, Ti = 0, Ci = 0; Ti < this.length; Ti++) {
        var Ii = this.words[Ti] << Ci | Ri;
        vi[Ai++] = Ii & 255, Ai < vi.length && (vi[Ai++] = Ii >> 8 & 255), Ai < vi.length && (vi[Ai++] = Ii >> 16 & 255), Ci === 6 ? (Ai < vi.length && (vi[Ai++] = Ii >> 24 & 255), Ri = 0, Ci = 0) : (Ri = Ii >>> 24, Ci += 2);
      }
      if (Ai < vi.length)
        for (vi[Ai++] = Ri; Ai < vi.length; )
          vi[Ai++] = 0;
    }, Te.prototype._toArrayLikeBE = function(vi, wi) {
      for (var Ai = vi.length - 1, Ri = 0, Ti = 0, Ci = 0; Ti < this.length; Ti++) {
        var Ii = this.words[Ti] << Ci | Ri;
        vi[Ai--] = Ii & 255, Ai >= 0 && (vi[Ai--] = Ii >> 8 & 255), Ai >= 0 && (vi[Ai--] = Ii >> 16 & 255), Ci === 6 ? (Ai >= 0 && (vi[Ai--] = Ii >> 24 & 255), Ri = 0, Ci = 0) : (Ri = Ii >>> 24, Ci += 2);
      }
      if (Ai >= 0)
        for (vi[Ai--] = Ri; Ai >= 0; )
          vi[Ai--] = 0;
    }, Math.clz32 ? Te.prototype._countBits = function(vi) {
      return 32 - Math.clz32(vi);
    } : Te.prototype._countBits = function(vi) {
      var wi = vi, Ai = 0;
      return wi >= 4096 && (Ai += 13, wi >>>= 13), wi >= 64 && (Ai += 7, wi >>>= 7), wi >= 8 && (Ai += 4, wi >>>= 4), wi >= 2 && (Ai += 2, wi >>>= 2), Ai + wi;
    }, Te.prototype._zeroBits = function(vi) {
      if (vi === 0) return 26;
      var wi = vi, Ai = 0;
      return wi & 8191 || (Ai += 13, wi >>>= 13), wi & 127 || (Ai += 7, wi >>>= 7), wi & 15 || (Ai += 4, wi >>>= 4), wi & 3 || (Ai += 2, wi >>>= 2), wi & 1 || Ai++, Ai;
    }, Te.prototype.bitLength = function() {
      var vi = this.words[this.length - 1], wi = this._countBits(vi);
      return (this.length - 1) * 26 + wi;
    };
    function _i($i) {
      for (var vi = new Array($i.bitLength()), wi = 0; wi < vi.length; wi++) {
        var Ai = wi / 26 | 0, Ri = wi % 26;
        vi[wi] = $i.words[Ai] >>> Ri & 1;
      }
      return vi;
    }
    Te.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var vi = 0, wi = 0; wi < this.length; wi++) {
        var Ai = this._zeroBits(this.words[wi]);
        if (vi += Ai, Ai !== 26) break;
      }
      return vi;
    }, Te.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, Te.prototype.toTwos = function(vi) {
      return this.negative !== 0 ? this.abs().inotn(vi).iaddn(1) : this.clone();
    }, Te.prototype.fromTwos = function(vi) {
      return this.testn(vi - 1) ? this.notn(vi).iaddn(1).ineg() : this.clone();
    }, Te.prototype.isNeg = function() {
      return this.negative !== 0;
    }, Te.prototype.neg = function() {
      return this.clone().ineg();
    }, Te.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, Te.prototype.iuor = function(vi) {
      for (; this.length < vi.length; )
        this.words[this.length++] = 0;
      for (var wi = 0; wi < vi.length; wi++)
        this.words[wi] = this.words[wi] | vi.words[wi];
      return this._strip();
    }, Te.prototype.ior = function(vi) {
      return Be((this.negative | vi.negative) === 0), this.iuor(vi);
    }, Te.prototype.or = function(vi) {
      return this.length > vi.length ? this.clone().ior(vi) : vi.clone().ior(this);
    }, Te.prototype.uor = function(vi) {
      return this.length > vi.length ? this.clone().iuor(vi) : vi.clone().iuor(this);
    }, Te.prototype.iuand = function(vi) {
      var wi;
      this.length > vi.length ? wi = vi : wi = this;
      for (var Ai = 0; Ai < wi.length; Ai++)
        this.words[Ai] = this.words[Ai] & vi.words[Ai];
      return this.length = wi.length, this._strip();
    }, Te.prototype.iand = function(vi) {
      return Be((this.negative | vi.negative) === 0), this.iuand(vi);
    }, Te.prototype.and = function(vi) {
      return this.length > vi.length ? this.clone().iand(vi) : vi.clone().iand(this);
    }, Te.prototype.uand = function(vi) {
      return this.length > vi.length ? this.clone().iuand(vi) : vi.clone().iuand(this);
    }, Te.prototype.iuxor = function(vi) {
      var wi, Ai;
      this.length > vi.length ? (wi = this, Ai = vi) : (wi = vi, Ai = this);
      for (var Ri = 0; Ri < Ai.length; Ri++)
        this.words[Ri] = wi.words[Ri] ^ Ai.words[Ri];
      if (this !== wi)
        for (; Ri < wi.length; Ri++)
          this.words[Ri] = wi.words[Ri];
      return this.length = wi.length, this._strip();
    }, Te.prototype.ixor = function(vi) {
      return Be((this.negative | vi.negative) === 0), this.iuxor(vi);
    }, Te.prototype.xor = function(vi) {
      return this.length > vi.length ? this.clone().ixor(vi) : vi.clone().ixor(this);
    }, Te.prototype.uxor = function(vi) {
      return this.length > vi.length ? this.clone().iuxor(vi) : vi.clone().iuxor(this);
    }, Te.prototype.inotn = function(vi) {
      Be(typeof vi == "number" && vi >= 0);
      var wi = Math.ceil(vi / 26) | 0, Ai = vi % 26;
      this._expand(wi), Ai > 0 && wi--;
      for (var Ri = 0; Ri < wi; Ri++)
        this.words[Ri] = ~this.words[Ri] & 67108863;
      return Ai > 0 && (this.words[Ri] = ~this.words[Ri] & 67108863 >> 26 - Ai), this._strip();
    }, Te.prototype.notn = function(vi) {
      return this.clone().inotn(vi);
    }, Te.prototype.setn = function(vi, wi) {
      Be(typeof vi == "number" && vi >= 0);
      var Ai = vi / 26 | 0, Ri = vi % 26;
      return this._expand(Ai + 1), wi ? this.words[Ai] = this.words[Ai] | 1 << Ri : this.words[Ai] = this.words[Ai] & ~(1 << Ri), this._strip();
    }, Te.prototype.iadd = function(vi) {
      var wi;
      if (this.negative !== 0 && vi.negative === 0)
        return this.negative = 0, wi = this.isub(vi), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && vi.negative !== 0)
        return vi.negative = 0, wi = this.isub(vi), vi.negative = 1, wi._normSign();
      var Ai, Ri;
      this.length > vi.length ? (Ai = this, Ri = vi) : (Ai = vi, Ri = this);
      for (var Ti = 0, Ci = 0; Ci < Ri.length; Ci++)
        wi = (Ai.words[Ci] | 0) + (Ri.words[Ci] | 0) + Ti, this.words[Ci] = wi & 67108863, Ti = wi >>> 26;
      for (; Ti !== 0 && Ci < Ai.length; Ci++)
        wi = (Ai.words[Ci] | 0) + Ti, this.words[Ci] = wi & 67108863, Ti = wi >>> 26;
      if (this.length = Ai.length, Ti !== 0)
        this.words[this.length] = Ti, this.length++;
      else if (Ai !== this)
        for (; Ci < Ai.length; Ci++)
          this.words[Ci] = Ai.words[Ci];
      return this;
    }, Te.prototype.add = function(vi) {
      var wi;
      return vi.negative !== 0 && this.negative === 0 ? (vi.negative = 0, wi = this.sub(vi), vi.negative ^= 1, wi) : vi.negative === 0 && this.negative !== 0 ? (this.negative = 0, wi = vi.sub(this), this.negative = 1, wi) : this.length > vi.length ? this.clone().iadd(vi) : vi.clone().iadd(this);
    }, Te.prototype.isub = function(vi) {
      if (vi.negative !== 0) {
        vi.negative = 0;
        var wi = this.iadd(vi);
        return vi.negative = 1, wi._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(vi), this.negative = 1, this._normSign();
      var Ai = this.cmp(vi);
      if (Ai === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var Ri, Ti;
      Ai > 0 ? (Ri = this, Ti = vi) : (Ri = vi, Ti = this);
      for (var Ci = 0, Ii = 0; Ii < Ti.length; Ii++)
        wi = (Ri.words[Ii] | 0) - (Ti.words[Ii] | 0) + Ci, Ci = wi >> 26, this.words[Ii] = wi & 67108863;
      for (; Ci !== 0 && Ii < Ri.length; Ii++)
        wi = (Ri.words[Ii] | 0) + Ci, Ci = wi >> 26, this.words[Ii] = wi & 67108863;
      if (Ci === 0 && Ii < Ri.length && Ri !== this)
        for (; Ii < Ri.length; Ii++)
          this.words[Ii] = Ri.words[Ii];
      return this.length = Math.max(this.length, Ii), Ri !== this && (this.negative = 1), this._strip();
    }, Te.prototype.sub = function(vi) {
      return this.clone().isub(vi);
    };
    function Ei($i, vi, wi) {
      wi.negative = vi.negative ^ $i.negative;
      var Ai = $i.length + vi.length | 0;
      wi.length = Ai, Ai = Ai - 1 | 0;
      var Ri = $i.words[0] | 0, Ti = vi.words[0] | 0, Ci = Ri * Ti, Ii = Ci & 67108863, Li = Ci / 67108864 | 0;
      wi.words[0] = Ii;
      for (var Ni = 1; Ni < Ai; Ni++) {
        for (var Vi = Li >>> 26, is = Li & 67108863, Ki = Math.min(Ni, vi.length - 1), ts = Math.max(0, Ni - $i.length + 1); ts <= Ki; ts++) {
          var qi = Ni - ts | 0;
          Ri = $i.words[qi] | 0, Ti = vi.words[ts] | 0, Ci = Ri * Ti + is, Vi += Ci / 67108864 | 0, is = Ci & 67108863;
        }
        wi.words[Ni] = is | 0, Li = Vi | 0;
      }
      return Li !== 0 ? wi.words[Ni] = Li | 0 : wi.length--, wi._strip();
    }
    var Si = function(vi, wi, Ai) {
      var Ri = vi.words, Ti = wi.words, Ci = Ai.words, Ii = 0, Li, Ni, Vi, is = Ri[0] | 0, Ki = is & 8191, ts = is >>> 13, qi = Ri[1] | 0, Hi = qi & 8191, Xi = qi >>> 13, ki = Ri[2] | 0, Wi = ki & 8191, Yi = ki >>> 13, Qi = Ri[3] | 0, ns = Qi & 8191, us = Qi >>> 13, ps = Ri[4] | 0, Ds = ps & 8191, Eo = ps >>> 13, hs = Ri[5] | 0, So = hs & 8191, _o = hs >>> 13, vo = Ri[6] | 0, Ro = vo & 8191, $o = vo >>> 13, Io = Ri[7] | 0, To = Io & 8191, Ao = Io >>> 13, Po = Ri[8] | 0, Co = Po & 8191, rs = Po >>> 13, Gi = Ri[9] | 0, Ji = Gi & 8191, ss = Gi >>> 13, ls = Ti[0] | 0, ds = ls & 8191, bs = ls >>> 13, Mo = Ti[1] | 0, Fo = Mo & 8191, Bo = Mo >>> 13, Uo = Ti[2] | 0, Lo = Uo & 8191, Go = Uo >>> 13, Yo = Ti[3] | 0, Ko = Yo & 8191, No = Yo >>> 13, Wo = Ti[4] | 0, os = Wo & 8191, as = Wo >>> 13, go = Ti[5] | 0, bo = go & 8191, wo = go >>> 13, qo = Ti[6] | 0, jo = qo & 8191, Oo = qo >>> 13, Ho = Ti[7] | 0, zo = Ho & 8191, Do = Ho >>> 13, Xo = Ti[8] | 0, na = Xo & 8191, Vo = Xo >>> 13, ra = Ti[9] | 0, Zo = ra & 8191, ta = ra >>> 13;
      Ai.negative = vi.negative ^ wi.negative, Ai.length = 19, Li = Math.imul(Ki, ds), Ni = Math.imul(Ki, bs), Ni = Ni + Math.imul(ts, ds) | 0, Vi = Math.imul(ts, bs);
      var ca = (Ii + Li | 0) + ((Ni & 8191) << 13) | 0;
      Ii = (Vi + (Ni >>> 13) | 0) + (ca >>> 26) | 0, ca &= 67108863, Li = Math.imul(Hi, ds), Ni = Math.imul(Hi, bs), Ni = Ni + Math.imul(Xi, ds) | 0, Vi = Math.imul(Xi, bs), Li = Li + Math.imul(Ki, Fo) | 0, Ni = Ni + Math.imul(Ki, Bo) | 0, Ni = Ni + Math.imul(ts, Fo) | 0, Vi = Vi + Math.imul(ts, Bo) | 0;
      var oa = (Ii + Li | 0) + ((Ni & 8191) << 13) | 0;
      Ii = (Vi + (Ni >>> 13) | 0) + (oa >>> 26) | 0, oa &= 67108863, Li = Math.imul(Wi, ds), Ni = Math.imul(Wi, bs), Ni = Ni + Math.imul(Yi, ds) | 0, Vi = Math.imul(Yi, bs), Li = Li + Math.imul(Hi, Fo) | 0, Ni = Ni + Math.imul(Hi, Bo) | 0, Ni = Ni + Math.imul(Xi, Fo) | 0, Vi = Vi + Math.imul(Xi, Bo) | 0, Li = Li + Math.imul(Ki, Lo) | 0, Ni = Ni + Math.imul(Ki, Go) | 0, Ni = Ni + Math.imul(ts, Lo) | 0, Vi = Vi + Math.imul(ts, Go) | 0;
      var ga = (Ii + Li | 0) + ((Ni & 8191) << 13) | 0;
      Ii = (Vi + (Ni >>> 13) | 0) + (ga >>> 26) | 0, ga &= 67108863, Li = Math.imul(ns, ds), Ni = Math.imul(ns, bs), Ni = Ni + Math.imul(us, ds) | 0, Vi = Math.imul(us, bs), Li = Li + Math.imul(Wi, Fo) | 0, Ni = Ni + Math.imul(Wi, Bo) | 0, Ni = Ni + Math.imul(Yi, Fo) | 0, Vi = Vi + Math.imul(Yi, Bo) | 0, Li = Li + Math.imul(Hi, Lo) | 0, Ni = Ni + Math.imul(Hi, Go) | 0, Ni = Ni + Math.imul(Xi, Lo) | 0, Vi = Vi + Math.imul(Xi, Go) | 0, Li = Li + Math.imul(Ki, Ko) | 0, Ni = Ni + Math.imul(Ki, No) | 0, Ni = Ni + Math.imul(ts, Ko) | 0, Vi = Vi + Math.imul(ts, No) | 0;
      var ba = (Ii + Li | 0) + ((Ni & 8191) << 13) | 0;
      Ii = (Vi + (Ni >>> 13) | 0) + (ba >>> 26) | 0, ba &= 67108863, Li = Math.imul(Ds, ds), Ni = Math.imul(Ds, bs), Ni = Ni + Math.imul(Eo, ds) | 0, Vi = Math.imul(Eo, bs), Li = Li + Math.imul(ns, Fo) | 0, Ni = Ni + Math.imul(ns, Bo) | 0, Ni = Ni + Math.imul(us, Fo) | 0, Vi = Vi + Math.imul(us, Bo) | 0, Li = Li + Math.imul(Wi, Lo) | 0, Ni = Ni + Math.imul(Wi, Go) | 0, Ni = Ni + Math.imul(Yi, Lo) | 0, Vi = Vi + Math.imul(Yi, Go) | 0, Li = Li + Math.imul(Hi, Ko) | 0, Ni = Ni + Math.imul(Hi, No) | 0, Ni = Ni + Math.imul(Xi, Ko) | 0, Vi = Vi + Math.imul(Xi, No) | 0, Li = Li + Math.imul(Ki, os) | 0, Ni = Ni + Math.imul(Ki, as) | 0, Ni = Ni + Math.imul(ts, os) | 0, Vi = Vi + Math.imul(ts, as) | 0;
      var ua = (Ii + Li | 0) + ((Ni & 8191) << 13) | 0;
      Ii = (Vi + (Ni >>> 13) | 0) + (ua >>> 26) | 0, ua &= 67108863, Li = Math.imul(So, ds), Ni = Math.imul(So, bs), Ni = Ni + Math.imul(_o, ds) | 0, Vi = Math.imul(_o, bs), Li = Li + Math.imul(Ds, Fo) | 0, Ni = Ni + Math.imul(Ds, Bo) | 0, Ni = Ni + Math.imul(Eo, Fo) | 0, Vi = Vi + Math.imul(Eo, Bo) | 0, Li = Li + Math.imul(ns, Lo) | 0, Ni = Ni + Math.imul(ns, Go) | 0, Ni = Ni + Math.imul(us, Lo) | 0, Vi = Vi + Math.imul(us, Go) | 0, Li = Li + Math.imul(Wi, Ko) | 0, Ni = Ni + Math.imul(Wi, No) | 0, Ni = Ni + Math.imul(Yi, Ko) | 0, Vi = Vi + Math.imul(Yi, No) | 0, Li = Li + Math.imul(Hi, os) | 0, Ni = Ni + Math.imul(Hi, as) | 0, Ni = Ni + Math.imul(Xi, os) | 0, Vi = Vi + Math.imul(Xi, as) | 0, Li = Li + Math.imul(Ki, bo) | 0, Ni = Ni + Math.imul(Ki, wo) | 0, Ni = Ni + Math.imul(ts, bo) | 0, Vi = Vi + Math.imul(ts, wo) | 0;
      var Aa = (Ii + Li | 0) + ((Ni & 8191) << 13) | 0;
      Ii = (Vi + (Ni >>> 13) | 0) + (Aa >>> 26) | 0, Aa &= 67108863, Li = Math.imul(Ro, ds), Ni = Math.imul(Ro, bs), Ni = Ni + Math.imul($o, ds) | 0, Vi = Math.imul($o, bs), Li = Li + Math.imul(So, Fo) | 0, Ni = Ni + Math.imul(So, Bo) | 0, Ni = Ni + Math.imul(_o, Fo) | 0, Vi = Vi + Math.imul(_o, Bo) | 0, Li = Li + Math.imul(Ds, Lo) | 0, Ni = Ni + Math.imul(Ds, Go) | 0, Ni = Ni + Math.imul(Eo, Lo) | 0, Vi = Vi + Math.imul(Eo, Go) | 0, Li = Li + Math.imul(ns, Ko) | 0, Ni = Ni + Math.imul(ns, No) | 0, Ni = Ni + Math.imul(us, Ko) | 0, Vi = Vi + Math.imul(us, No) | 0, Li = Li + Math.imul(Wi, os) | 0, Ni = Ni + Math.imul(Wi, as) | 0, Ni = Ni + Math.imul(Yi, os) | 0, Vi = Vi + Math.imul(Yi, as) | 0, Li = Li + Math.imul(Hi, bo) | 0, Ni = Ni + Math.imul(Hi, wo) | 0, Ni = Ni + Math.imul(Xi, bo) | 0, Vi = Vi + Math.imul(Xi, wo) | 0, Li = Li + Math.imul(Ki, jo) | 0, Ni = Ni + Math.imul(Ki, Oo) | 0, Ni = Ni + Math.imul(ts, jo) | 0, Vi = Vi + Math.imul(ts, Oo) | 0;
      var Ra = (Ii + Li | 0) + ((Ni & 8191) << 13) | 0;
      Ii = (Vi + (Ni >>> 13) | 0) + (Ra >>> 26) | 0, Ra &= 67108863, Li = Math.imul(To, ds), Ni = Math.imul(To, bs), Ni = Ni + Math.imul(Ao, ds) | 0, Vi = Math.imul(Ao, bs), Li = Li + Math.imul(Ro, Fo) | 0, Ni = Ni + Math.imul(Ro, Bo) | 0, Ni = Ni + Math.imul($o, Fo) | 0, Vi = Vi + Math.imul($o, Bo) | 0, Li = Li + Math.imul(So, Lo) | 0, Ni = Ni + Math.imul(So, Go) | 0, Ni = Ni + Math.imul(_o, Lo) | 0, Vi = Vi + Math.imul(_o, Go) | 0, Li = Li + Math.imul(Ds, Ko) | 0, Ni = Ni + Math.imul(Ds, No) | 0, Ni = Ni + Math.imul(Eo, Ko) | 0, Vi = Vi + Math.imul(Eo, No) | 0, Li = Li + Math.imul(ns, os) | 0, Ni = Ni + Math.imul(ns, as) | 0, Ni = Ni + Math.imul(us, os) | 0, Vi = Vi + Math.imul(us, as) | 0, Li = Li + Math.imul(Wi, bo) | 0, Ni = Ni + Math.imul(Wi, wo) | 0, Ni = Ni + Math.imul(Yi, bo) | 0, Vi = Vi + Math.imul(Yi, wo) | 0, Li = Li + Math.imul(Hi, jo) | 0, Ni = Ni + Math.imul(Hi, Oo) | 0, Ni = Ni + Math.imul(Xi, jo) | 0, Vi = Vi + Math.imul(Xi, Oo) | 0, Li = Li + Math.imul(Ki, zo) | 0, Ni = Ni + Math.imul(Ki, Do) | 0, Ni = Ni + Math.imul(ts, zo) | 0, Vi = Vi + Math.imul(ts, Do) | 0;
      var Ia = (Ii + Li | 0) + ((Ni & 8191) << 13) | 0;
      Ii = (Vi + (Ni >>> 13) | 0) + (Ia >>> 26) | 0, Ia &= 67108863, Li = Math.imul(Co, ds), Ni = Math.imul(Co, bs), Ni = Ni + Math.imul(rs, ds) | 0, Vi = Math.imul(rs, bs), Li = Li + Math.imul(To, Fo) | 0, Ni = Ni + Math.imul(To, Bo) | 0, Ni = Ni + Math.imul(Ao, Fo) | 0, Vi = Vi + Math.imul(Ao, Bo) | 0, Li = Li + Math.imul(Ro, Lo) | 0, Ni = Ni + Math.imul(Ro, Go) | 0, Ni = Ni + Math.imul($o, Lo) | 0, Vi = Vi + Math.imul($o, Go) | 0, Li = Li + Math.imul(So, Ko) | 0, Ni = Ni + Math.imul(So, No) | 0, Ni = Ni + Math.imul(_o, Ko) | 0, Vi = Vi + Math.imul(_o, No) | 0, Li = Li + Math.imul(Ds, os) | 0, Ni = Ni + Math.imul(Ds, as) | 0, Ni = Ni + Math.imul(Eo, os) | 0, Vi = Vi + Math.imul(Eo, as) | 0, Li = Li + Math.imul(ns, bo) | 0, Ni = Ni + Math.imul(ns, wo) | 0, Ni = Ni + Math.imul(us, bo) | 0, Vi = Vi + Math.imul(us, wo) | 0, Li = Li + Math.imul(Wi, jo) | 0, Ni = Ni + Math.imul(Wi, Oo) | 0, Ni = Ni + Math.imul(Yi, jo) | 0, Vi = Vi + Math.imul(Yi, Oo) | 0, Li = Li + Math.imul(Hi, zo) | 0, Ni = Ni + Math.imul(Hi, Do) | 0, Ni = Ni + Math.imul(Xi, zo) | 0, Vi = Vi + Math.imul(Xi, Do) | 0, Li = Li + Math.imul(Ki, na) | 0, Ni = Ni + Math.imul(Ki, Vo) | 0, Ni = Ni + Math.imul(ts, na) | 0, Vi = Vi + Math.imul(ts, Vo) | 0;
      var Ba = (Ii + Li | 0) + ((Ni & 8191) << 13) | 0;
      Ii = (Vi + (Ni >>> 13) | 0) + (Ba >>> 26) | 0, Ba &= 67108863, Li = Math.imul(Ji, ds), Ni = Math.imul(Ji, bs), Ni = Ni + Math.imul(ss, ds) | 0, Vi = Math.imul(ss, bs), Li = Li + Math.imul(Co, Fo) | 0, Ni = Ni + Math.imul(Co, Bo) | 0, Ni = Ni + Math.imul(rs, Fo) | 0, Vi = Vi + Math.imul(rs, Bo) | 0, Li = Li + Math.imul(To, Lo) | 0, Ni = Ni + Math.imul(To, Go) | 0, Ni = Ni + Math.imul(Ao, Lo) | 0, Vi = Vi + Math.imul(Ao, Go) | 0, Li = Li + Math.imul(Ro, Ko) | 0, Ni = Ni + Math.imul(Ro, No) | 0, Ni = Ni + Math.imul($o, Ko) | 0, Vi = Vi + Math.imul($o, No) | 0, Li = Li + Math.imul(So, os) | 0, Ni = Ni + Math.imul(So, as) | 0, Ni = Ni + Math.imul(_o, os) | 0, Vi = Vi + Math.imul(_o, as) | 0, Li = Li + Math.imul(Ds, bo) | 0, Ni = Ni + Math.imul(Ds, wo) | 0, Ni = Ni + Math.imul(Eo, bo) | 0, Vi = Vi + Math.imul(Eo, wo) | 0, Li = Li + Math.imul(ns, jo) | 0, Ni = Ni + Math.imul(ns, Oo) | 0, Ni = Ni + Math.imul(us, jo) | 0, Vi = Vi + Math.imul(us, Oo) | 0, Li = Li + Math.imul(Wi, zo) | 0, Ni = Ni + Math.imul(Wi, Do) | 0, Ni = Ni + Math.imul(Yi, zo) | 0, Vi = Vi + Math.imul(Yi, Do) | 0, Li = Li + Math.imul(Hi, na) | 0, Ni = Ni + Math.imul(Hi, Vo) | 0, Ni = Ni + Math.imul(Xi, na) | 0, Vi = Vi + Math.imul(Xi, Vo) | 0, Li = Li + Math.imul(Ki, Zo) | 0, Ni = Ni + Math.imul(Ki, ta) | 0, Ni = Ni + Math.imul(ts, Zo) | 0, Vi = Vi + Math.imul(ts, ta) | 0;
      var Pa = (Ii + Li | 0) + ((Ni & 8191) << 13) | 0;
      Ii = (Vi + (Ni >>> 13) | 0) + (Pa >>> 26) | 0, Pa &= 67108863, Li = Math.imul(Ji, Fo), Ni = Math.imul(Ji, Bo), Ni = Ni + Math.imul(ss, Fo) | 0, Vi = Math.imul(ss, Bo), Li = Li + Math.imul(Co, Lo) | 0, Ni = Ni + Math.imul(Co, Go) | 0, Ni = Ni + Math.imul(rs, Lo) | 0, Vi = Vi + Math.imul(rs, Go) | 0, Li = Li + Math.imul(To, Ko) | 0, Ni = Ni + Math.imul(To, No) | 0, Ni = Ni + Math.imul(Ao, Ko) | 0, Vi = Vi + Math.imul(Ao, No) | 0, Li = Li + Math.imul(Ro, os) | 0, Ni = Ni + Math.imul(Ro, as) | 0, Ni = Ni + Math.imul($o, os) | 0, Vi = Vi + Math.imul($o, as) | 0, Li = Li + Math.imul(So, bo) | 0, Ni = Ni + Math.imul(So, wo) | 0, Ni = Ni + Math.imul(_o, bo) | 0, Vi = Vi + Math.imul(_o, wo) | 0, Li = Li + Math.imul(Ds, jo) | 0, Ni = Ni + Math.imul(Ds, Oo) | 0, Ni = Ni + Math.imul(Eo, jo) | 0, Vi = Vi + Math.imul(Eo, Oo) | 0, Li = Li + Math.imul(ns, zo) | 0, Ni = Ni + Math.imul(ns, Do) | 0, Ni = Ni + Math.imul(us, zo) | 0, Vi = Vi + Math.imul(us, Do) | 0, Li = Li + Math.imul(Wi, na) | 0, Ni = Ni + Math.imul(Wi, Vo) | 0, Ni = Ni + Math.imul(Yi, na) | 0, Vi = Vi + Math.imul(Yi, Vo) | 0, Li = Li + Math.imul(Hi, Zo) | 0, Ni = Ni + Math.imul(Hi, ta) | 0, Ni = Ni + Math.imul(Xi, Zo) | 0, Vi = Vi + Math.imul(Xi, ta) | 0;
      var va = (Ii + Li | 0) + ((Ni & 8191) << 13) | 0;
      Ii = (Vi + (Ni >>> 13) | 0) + (va >>> 26) | 0, va &= 67108863, Li = Math.imul(Ji, Lo), Ni = Math.imul(Ji, Go), Ni = Ni + Math.imul(ss, Lo) | 0, Vi = Math.imul(ss, Go), Li = Li + Math.imul(Co, Ko) | 0, Ni = Ni + Math.imul(Co, No) | 0, Ni = Ni + Math.imul(rs, Ko) | 0, Vi = Vi + Math.imul(rs, No) | 0, Li = Li + Math.imul(To, os) | 0, Ni = Ni + Math.imul(To, as) | 0, Ni = Ni + Math.imul(Ao, os) | 0, Vi = Vi + Math.imul(Ao, as) | 0, Li = Li + Math.imul(Ro, bo) | 0, Ni = Ni + Math.imul(Ro, wo) | 0, Ni = Ni + Math.imul($o, bo) | 0, Vi = Vi + Math.imul($o, wo) | 0, Li = Li + Math.imul(So, jo) | 0, Ni = Ni + Math.imul(So, Oo) | 0, Ni = Ni + Math.imul(_o, jo) | 0, Vi = Vi + Math.imul(_o, Oo) | 0, Li = Li + Math.imul(Ds, zo) | 0, Ni = Ni + Math.imul(Ds, Do) | 0, Ni = Ni + Math.imul(Eo, zo) | 0, Vi = Vi + Math.imul(Eo, Do) | 0, Li = Li + Math.imul(ns, na) | 0, Ni = Ni + Math.imul(ns, Vo) | 0, Ni = Ni + Math.imul(us, na) | 0, Vi = Vi + Math.imul(us, Vo) | 0, Li = Li + Math.imul(Wi, Zo) | 0, Ni = Ni + Math.imul(Wi, ta) | 0, Ni = Ni + Math.imul(Yi, Zo) | 0, Vi = Vi + Math.imul(Yi, ta) | 0;
      var Ta = (Ii + Li | 0) + ((Ni & 8191) << 13) | 0;
      Ii = (Vi + (Ni >>> 13) | 0) + (Ta >>> 26) | 0, Ta &= 67108863, Li = Math.imul(Ji, Ko), Ni = Math.imul(Ji, No), Ni = Ni + Math.imul(ss, Ko) | 0, Vi = Math.imul(ss, No), Li = Li + Math.imul(Co, os) | 0, Ni = Ni + Math.imul(Co, as) | 0, Ni = Ni + Math.imul(rs, os) | 0, Vi = Vi + Math.imul(rs, as) | 0, Li = Li + Math.imul(To, bo) | 0, Ni = Ni + Math.imul(To, wo) | 0, Ni = Ni + Math.imul(Ao, bo) | 0, Vi = Vi + Math.imul(Ao, wo) | 0, Li = Li + Math.imul(Ro, jo) | 0, Ni = Ni + Math.imul(Ro, Oo) | 0, Ni = Ni + Math.imul($o, jo) | 0, Vi = Vi + Math.imul($o, Oo) | 0, Li = Li + Math.imul(So, zo) | 0, Ni = Ni + Math.imul(So, Do) | 0, Ni = Ni + Math.imul(_o, zo) | 0, Vi = Vi + Math.imul(_o, Do) | 0, Li = Li + Math.imul(Ds, na) | 0, Ni = Ni + Math.imul(Ds, Vo) | 0, Ni = Ni + Math.imul(Eo, na) | 0, Vi = Vi + Math.imul(Eo, Vo) | 0, Li = Li + Math.imul(ns, Zo) | 0, Ni = Ni + Math.imul(ns, ta) | 0, Ni = Ni + Math.imul(us, Zo) | 0, Vi = Vi + Math.imul(us, ta) | 0;
      var Ma = (Ii + Li | 0) + ((Ni & 8191) << 13) | 0;
      Ii = (Vi + (Ni >>> 13) | 0) + (Ma >>> 26) | 0, Ma &= 67108863, Li = Math.imul(Ji, os), Ni = Math.imul(Ji, as), Ni = Ni + Math.imul(ss, os) | 0, Vi = Math.imul(ss, as), Li = Li + Math.imul(Co, bo) | 0, Ni = Ni + Math.imul(Co, wo) | 0, Ni = Ni + Math.imul(rs, bo) | 0, Vi = Vi + Math.imul(rs, wo) | 0, Li = Li + Math.imul(To, jo) | 0, Ni = Ni + Math.imul(To, Oo) | 0, Ni = Ni + Math.imul(Ao, jo) | 0, Vi = Vi + Math.imul(Ao, Oo) | 0, Li = Li + Math.imul(Ro, zo) | 0, Ni = Ni + Math.imul(Ro, Do) | 0, Ni = Ni + Math.imul($o, zo) | 0, Vi = Vi + Math.imul($o, Do) | 0, Li = Li + Math.imul(So, na) | 0, Ni = Ni + Math.imul(So, Vo) | 0, Ni = Ni + Math.imul(_o, na) | 0, Vi = Vi + Math.imul(_o, Vo) | 0, Li = Li + Math.imul(Ds, Zo) | 0, Ni = Ni + Math.imul(Ds, ta) | 0, Ni = Ni + Math.imul(Eo, Zo) | 0, Vi = Vi + Math.imul(Eo, ta) | 0;
      var ha = (Ii + Li | 0) + ((Ni & 8191) << 13) | 0;
      Ii = (Vi + (Ni >>> 13) | 0) + (ha >>> 26) | 0, ha &= 67108863, Li = Math.imul(Ji, bo), Ni = Math.imul(Ji, wo), Ni = Ni + Math.imul(ss, bo) | 0, Vi = Math.imul(ss, wo), Li = Li + Math.imul(Co, jo) | 0, Ni = Ni + Math.imul(Co, Oo) | 0, Ni = Ni + Math.imul(rs, jo) | 0, Vi = Vi + Math.imul(rs, Oo) | 0, Li = Li + Math.imul(To, zo) | 0, Ni = Ni + Math.imul(To, Do) | 0, Ni = Ni + Math.imul(Ao, zo) | 0, Vi = Vi + Math.imul(Ao, Do) | 0, Li = Li + Math.imul(Ro, na) | 0, Ni = Ni + Math.imul(Ro, Vo) | 0, Ni = Ni + Math.imul($o, na) | 0, Vi = Vi + Math.imul($o, Vo) | 0, Li = Li + Math.imul(So, Zo) | 0, Ni = Ni + Math.imul(So, ta) | 0, Ni = Ni + Math.imul(_o, Zo) | 0, Vi = Vi + Math.imul(_o, ta) | 0;
      var Ca = (Ii + Li | 0) + ((Ni & 8191) << 13) | 0;
      Ii = (Vi + (Ni >>> 13) | 0) + (Ca >>> 26) | 0, Ca &= 67108863, Li = Math.imul(Ji, jo), Ni = Math.imul(Ji, Oo), Ni = Ni + Math.imul(ss, jo) | 0, Vi = Math.imul(ss, Oo), Li = Li + Math.imul(Co, zo) | 0, Ni = Ni + Math.imul(Co, Do) | 0, Ni = Ni + Math.imul(rs, zo) | 0, Vi = Vi + Math.imul(rs, Do) | 0, Li = Li + Math.imul(To, na) | 0, Ni = Ni + Math.imul(To, Vo) | 0, Ni = Ni + Math.imul(Ao, na) | 0, Vi = Vi + Math.imul(Ao, Vo) | 0, Li = Li + Math.imul(Ro, Zo) | 0, Ni = Ni + Math.imul(Ro, ta) | 0, Ni = Ni + Math.imul($o, Zo) | 0, Vi = Vi + Math.imul($o, ta) | 0;
      var Na = (Ii + Li | 0) + ((Ni & 8191) << 13) | 0;
      Ii = (Vi + (Ni >>> 13) | 0) + (Na >>> 26) | 0, Na &= 67108863, Li = Math.imul(Ji, zo), Ni = Math.imul(Ji, Do), Ni = Ni + Math.imul(ss, zo) | 0, Vi = Math.imul(ss, Do), Li = Li + Math.imul(Co, na) | 0, Ni = Ni + Math.imul(Co, Vo) | 0, Ni = Ni + Math.imul(rs, na) | 0, Vi = Vi + Math.imul(rs, Vo) | 0, Li = Li + Math.imul(To, Zo) | 0, Ni = Ni + Math.imul(To, ta) | 0, Ni = Ni + Math.imul(Ao, Zo) | 0, Vi = Vi + Math.imul(Ao, ta) | 0;
      var Oa = (Ii + Li | 0) + ((Ni & 8191) << 13) | 0;
      Ii = (Vi + (Ni >>> 13) | 0) + (Oa >>> 26) | 0, Oa &= 67108863, Li = Math.imul(Ji, na), Ni = Math.imul(Ji, Vo), Ni = Ni + Math.imul(ss, na) | 0, Vi = Math.imul(ss, Vo), Li = Li + Math.imul(Co, Zo) | 0, Ni = Ni + Math.imul(Co, ta) | 0, Ni = Ni + Math.imul(rs, Zo) | 0, Vi = Vi + Math.imul(rs, ta) | 0;
      var pc = (Ii + Li | 0) + ((Ni & 8191) << 13) | 0;
      Ii = (Vi + (Ni >>> 13) | 0) + (pc >>> 26) | 0, pc &= 67108863, Li = Math.imul(Ji, Zo), Ni = Math.imul(Ji, ta), Ni = Ni + Math.imul(ss, Zo) | 0, Vi = Math.imul(ss, ta);
      var gc = (Ii + Li | 0) + ((Ni & 8191) << 13) | 0;
      return Ii = (Vi + (Ni >>> 13) | 0) + (gc >>> 26) | 0, gc &= 67108863, Ci[0] = ca, Ci[1] = oa, Ci[2] = ga, Ci[3] = ba, Ci[4] = ua, Ci[5] = Aa, Ci[6] = Ra, Ci[7] = Ia, Ci[8] = Ba, Ci[9] = Pa, Ci[10] = va, Ci[11] = Ta, Ci[12] = Ma, Ci[13] = ha, Ci[14] = Ca, Ci[15] = Na, Ci[16] = Oa, Ci[17] = pc, Ci[18] = gc, Ii !== 0 && (Ci[19] = Ii, Ai.length++), Ai;
    };
    Math.imul || (Si = Ei);
    function Mi($i, vi, wi) {
      wi.negative = vi.negative ^ $i.negative, wi.length = $i.length + vi.length;
      for (var Ai = 0, Ri = 0, Ti = 0; Ti < wi.length - 1; Ti++) {
        var Ci = Ri;
        Ri = 0;
        for (var Ii = Ai & 67108863, Li = Math.min(Ti, vi.length - 1), Ni = Math.max(0, Ti - $i.length + 1); Ni <= Li; Ni++) {
          var Vi = Ti - Ni, is = $i.words[Vi] | 0, Ki = vi.words[Ni] | 0, ts = is * Ki, qi = ts & 67108863;
          Ci = Ci + (ts / 67108864 | 0) | 0, qi = qi + Ii | 0, Ii = qi & 67108863, Ci = Ci + (qi >>> 26) | 0, Ri += Ci >>> 26, Ci &= 67108863;
        }
        wi.words[Ti] = Ii, Ai = Ci, Ci = Ri;
      }
      return Ai !== 0 ? wi.words[Ti] = Ai : wi.length--, wi._strip();
    }
    function Oi($i, vi, wi) {
      return Mi($i, vi, wi);
    }
    Te.prototype.mulTo = function(vi, wi) {
      var Ai, Ri = this.length + vi.length;
      return this.length === 10 && vi.length === 10 ? Ai = Si(this, vi, wi) : Ri < 63 ? Ai = Ei(this, vi, wi) : Ri < 1024 ? Ai = Mi(this, vi, wi) : Ai = Oi(this, vi, wi), Ai;
    }, Te.prototype.mul = function(vi) {
      var wi = new Te(null);
      return wi.words = new Array(this.length + vi.length), this.mulTo(vi, wi);
    }, Te.prototype.mulf = function(vi) {
      var wi = new Te(null);
      return wi.words = new Array(this.length + vi.length), Oi(this, vi, wi);
    }, Te.prototype.imul = function(vi) {
      return this.clone().mulTo(vi, this);
    }, Te.prototype.imuln = function(vi) {
      var wi = vi < 0;
      wi && (vi = -vi), Be(typeof vi == "number"), Be(vi < 67108864);
      for (var Ai = 0, Ri = 0; Ri < this.length; Ri++) {
        var Ti = (this.words[Ri] | 0) * vi, Ci = (Ti & 67108863) + (Ai & 67108863);
        Ai >>= 26, Ai += Ti / 67108864 | 0, Ai += Ci >>> 26, this.words[Ri] = Ci & 67108863;
      }
      return Ai !== 0 && (this.words[Ri] = Ai, this.length++), wi ? this.ineg() : this;
    }, Te.prototype.muln = function(vi) {
      return this.clone().imuln(vi);
    }, Te.prototype.sqr = function() {
      return this.mul(this);
    }, Te.prototype.isqr = function() {
      return this.imul(this.clone());
    }, Te.prototype.pow = function(vi) {
      var wi = _i(vi);
      if (wi.length === 0) return new Te(1);
      for (var Ai = this, Ri = 0; Ri < wi.length && wi[Ri] === 0; Ri++, Ai = Ai.sqr())
        ;
      if (++Ri < wi.length)
        for (var Ti = Ai.sqr(); Ri < wi.length; Ri++, Ti = Ti.sqr())
          wi[Ri] !== 0 && (Ai = Ai.mul(Ti));
      return Ai;
    }, Te.prototype.iushln = function(vi) {
      Be(typeof vi == "number" && vi >= 0);
      var wi = vi % 26, Ai = (vi - wi) / 26, Ri = 67108863 >>> 26 - wi << 26 - wi, Ti;
      if (wi !== 0) {
        var Ci = 0;
        for (Ti = 0; Ti < this.length; Ti++) {
          var Ii = this.words[Ti] & Ri, Li = (this.words[Ti] | 0) - Ii << wi;
          this.words[Ti] = Li | Ci, Ci = Ii >>> 26 - wi;
        }
        Ci && (this.words[Ti] = Ci, this.length++);
      }
      if (Ai !== 0) {
        for (Ti = this.length - 1; Ti >= 0; Ti--)
          this.words[Ti + Ai] = this.words[Ti];
        for (Ti = 0; Ti < Ai; Ti++)
          this.words[Ti] = 0;
        this.length += Ai;
      }
      return this._strip();
    }, Te.prototype.ishln = function(vi) {
      return Be(this.negative === 0), this.iushln(vi);
    }, Te.prototype.iushrn = function(vi, wi, Ai) {
      Be(typeof vi == "number" && vi >= 0);
      var Ri;
      wi ? Ri = (wi - wi % 26) / 26 : Ri = 0;
      var Ti = vi % 26, Ci = Math.min((vi - Ti) / 26, this.length), Ii = 67108863 ^ 67108863 >>> Ti << Ti, Li = Ai;
      if (Ri -= Ci, Ri = Math.max(0, Ri), Li) {
        for (var Ni = 0; Ni < Ci; Ni++)
          Li.words[Ni] = this.words[Ni];
        Li.length = Ci;
      }
      if (Ci !== 0) if (this.length > Ci)
        for (this.length -= Ci, Ni = 0; Ni < this.length; Ni++)
          this.words[Ni] = this.words[Ni + Ci];
      else
        this.words[0] = 0, this.length = 1;
      var Vi = 0;
      for (Ni = this.length - 1; Ni >= 0 && (Vi !== 0 || Ni >= Ri); Ni--) {
        var is = this.words[Ni] | 0;
        this.words[Ni] = Vi << 26 - Ti | is >>> Ti, Vi = is & Ii;
      }
      return Li && Vi !== 0 && (Li.words[Li.length++] = Vi), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, Te.prototype.ishrn = function(vi, wi, Ai) {
      return Be(this.negative === 0), this.iushrn(vi, wi, Ai);
    }, Te.prototype.shln = function(vi) {
      return this.clone().ishln(vi);
    }, Te.prototype.ushln = function(vi) {
      return this.clone().iushln(vi);
    }, Te.prototype.shrn = function(vi) {
      return this.clone().ishrn(vi);
    }, Te.prototype.ushrn = function(vi) {
      return this.clone().iushrn(vi);
    }, Te.prototype.testn = function(vi) {
      Be(typeof vi == "number" && vi >= 0);
      var wi = vi % 26, Ai = (vi - wi) / 26, Ri = 1 << wi;
      if (this.length <= Ai) return !1;
      var Ti = this.words[Ai];
      return !!(Ti & Ri);
    }, Te.prototype.imaskn = function(vi) {
      Be(typeof vi == "number" && vi >= 0);
      var wi = vi % 26, Ai = (vi - wi) / 26;
      if (Be(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Ai)
        return this;
      if (wi !== 0 && Ai++, this.length = Math.min(Ai, this.length), wi !== 0) {
        var Ri = 67108863 ^ 67108863 >>> wi << wi;
        this.words[this.length - 1] &= Ri;
      }
      return this._strip();
    }, Te.prototype.maskn = function(vi) {
      return this.clone().imaskn(vi);
    }, Te.prototype.iaddn = function(vi) {
      return Be(typeof vi == "number"), Be(vi < 67108864), vi < 0 ? this.isubn(-vi) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= vi ? (this.words[0] = vi - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(vi), this.negative = 1, this) : this._iaddn(vi);
    }, Te.prototype._iaddn = function(vi) {
      this.words[0] += vi;
      for (var wi = 0; wi < this.length && this.words[wi] >= 67108864; wi++)
        this.words[wi] -= 67108864, wi === this.length - 1 ? this.words[wi + 1] = 1 : this.words[wi + 1]++;
      return this.length = Math.max(this.length, wi + 1), this;
    }, Te.prototype.isubn = function(vi) {
      if (Be(typeof vi == "number"), Be(vi < 67108864), vi < 0) return this.iaddn(-vi);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(vi), this.negative = 1, this;
      if (this.words[0] -= vi, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var wi = 0; wi < this.length && this.words[wi] < 0; wi++)
          this.words[wi] += 67108864, this.words[wi + 1] -= 1;
      return this._strip();
    }, Te.prototype.addn = function(vi) {
      return this.clone().iaddn(vi);
    }, Te.prototype.subn = function(vi) {
      return this.clone().isubn(vi);
    }, Te.prototype.iabs = function() {
      return this.negative = 0, this;
    }, Te.prototype.abs = function() {
      return this.clone().iabs();
    }, Te.prototype._ishlnsubmul = function(vi, wi, Ai) {
      var Ri = vi.length + Ai, Ti;
      this._expand(Ri);
      var Ci, Ii = 0;
      for (Ti = 0; Ti < vi.length; Ti++) {
        Ci = (this.words[Ti + Ai] | 0) + Ii;
        var Li = (vi.words[Ti] | 0) * wi;
        Ci -= Li & 67108863, Ii = (Ci >> 26) - (Li / 67108864 | 0), this.words[Ti + Ai] = Ci & 67108863;
      }
      for (; Ti < this.length - Ai; Ti++)
        Ci = (this.words[Ti + Ai] | 0) + Ii, Ii = Ci >> 26, this.words[Ti + Ai] = Ci & 67108863;
      if (Ii === 0) return this._strip();
      for (Be(Ii === -1), Ii = 0, Ti = 0; Ti < this.length; Ti++)
        Ci = -(this.words[Ti] | 0) + Ii, Ii = Ci >> 26, this.words[Ti] = Ci & 67108863;
      return this.negative = 1, this._strip();
    }, Te.prototype._wordDiv = function(vi, wi) {
      var Ai = this.length - vi.length, Ri = this.clone(), Ti = vi, Ci = Ti.words[Ti.length - 1] | 0, Ii = this._countBits(Ci);
      Ai = 26 - Ii, Ai !== 0 && (Ti = Ti.ushln(Ai), Ri.iushln(Ai), Ci = Ti.words[Ti.length - 1] | 0);
      var Li = Ri.length - Ti.length, Ni;
      if (wi !== "mod") {
        Ni = new Te(null), Ni.length = Li + 1, Ni.words = new Array(Ni.length);
        for (var Vi = 0; Vi < Ni.length; Vi++)
          Ni.words[Vi] = 0;
      }
      var is = Ri.clone()._ishlnsubmul(Ti, 1, Li);
      is.negative === 0 && (Ri = is, Ni && (Ni.words[Li] = 1));
      for (var Ki = Li - 1; Ki >= 0; Ki--) {
        var ts = (Ri.words[Ti.length + Ki] | 0) * 67108864 + (Ri.words[Ti.length + Ki - 1] | 0);
        for (ts = Math.min(ts / Ci | 0, 67108863), Ri._ishlnsubmul(Ti, ts, Ki); Ri.negative !== 0; )
          ts--, Ri.negative = 0, Ri._ishlnsubmul(Ti, 1, Ki), Ri.isZero() || (Ri.negative ^= 1);
        Ni && (Ni.words[Ki] = ts);
      }
      return Ni && Ni._strip(), Ri._strip(), wi !== "div" && Ai !== 0 && Ri.iushrn(Ai), {
        div: Ni || null,
        mod: Ri
      };
    }, Te.prototype.divmod = function(vi, wi, Ai) {
      if (Be(!vi.isZero()), this.isZero())
        return {
          div: new Te(0),
          mod: new Te(0)
        };
      var Ri, Ti, Ci;
      return this.negative !== 0 && vi.negative === 0 ? (Ci = this.neg().divmod(vi, wi), wi !== "mod" && (Ri = Ci.div.neg()), wi !== "div" && (Ti = Ci.mod.neg(), Ai && Ti.negative !== 0 && Ti.iadd(vi)), {
        div: Ri,
        mod: Ti
      }) : this.negative === 0 && vi.negative !== 0 ? (Ci = this.divmod(vi.neg(), wi), wi !== "mod" && (Ri = Ci.div.neg()), {
        div: Ri,
        mod: Ci.mod
      }) : this.negative & vi.negative ? (Ci = this.neg().divmod(vi.neg(), wi), wi !== "div" && (Ti = Ci.mod.neg(), Ai && Ti.negative !== 0 && Ti.isub(vi)), {
        div: Ci.div,
        mod: Ti
      }) : vi.length > this.length || this.cmp(vi) < 0 ? {
        div: new Te(0),
        mod: this
      } : vi.length === 1 ? wi === "div" ? {
        div: this.divn(vi.words[0]),
        mod: null
      } : wi === "mod" ? {
        div: null,
        mod: new Te(this.modrn(vi.words[0]))
      } : {
        div: this.divn(vi.words[0]),
        mod: new Te(this.modrn(vi.words[0]))
      } : this._wordDiv(vi, wi);
    }, Te.prototype.div = function(vi) {
      return this.divmod(vi, "div", !1).div;
    }, Te.prototype.mod = function(vi) {
      return this.divmod(vi, "mod", !1).mod;
    }, Te.prototype.umod = function(vi) {
      return this.divmod(vi, "mod", !0).mod;
    }, Te.prototype.divRound = function(vi) {
      var wi = this.divmod(vi);
      if (wi.mod.isZero()) return wi.div;
      var Ai = wi.div.negative !== 0 ? wi.mod.isub(vi) : wi.mod, Ri = vi.ushrn(1), Ti = vi.andln(1), Ci = Ai.cmp(Ri);
      return Ci < 0 || Ti === 1 && Ci === 0 ? wi.div : wi.div.negative !== 0 ? wi.div.isubn(1) : wi.div.iaddn(1);
    }, Te.prototype.modrn = function(vi) {
      var wi = vi < 0;
      wi && (vi = -vi), Be(vi <= 67108863);
      for (var Ai = (1 << 26) % vi, Ri = 0, Ti = this.length - 1; Ti >= 0; Ti--)
        Ri = (Ai * Ri + (this.words[Ti] | 0)) % vi;
      return wi ? -Ri : Ri;
    }, Te.prototype.modn = function(vi) {
      return this.modrn(vi);
    }, Te.prototype.idivn = function(vi) {
      var wi = vi < 0;
      wi && (vi = -vi), Be(vi <= 67108863);
      for (var Ai = 0, Ri = this.length - 1; Ri >= 0; Ri--) {
        var Ti = (this.words[Ri] | 0) + Ai * 67108864;
        this.words[Ri] = Ti / vi | 0, Ai = Ti % vi;
      }
      return this._strip(), wi ? this.ineg() : this;
    }, Te.prototype.divn = function(vi) {
      return this.clone().idivn(vi);
    }, Te.prototype.egcd = function(vi) {
      Be(vi.negative === 0), Be(!vi.isZero());
      var wi = this, Ai = vi.clone();
      wi.negative !== 0 ? wi = wi.umod(vi) : wi = wi.clone();
      for (var Ri = new Te(1), Ti = new Te(0), Ci = new Te(0), Ii = new Te(1), Li = 0; wi.isEven() && Ai.isEven(); )
        wi.iushrn(1), Ai.iushrn(1), ++Li;
      for (var Ni = Ai.clone(), Vi = wi.clone(); !wi.isZero(); ) {
        for (var is = 0, Ki = 1; !(wi.words[0] & Ki) && is < 26; ++is, Ki <<= 1) ;
        if (is > 0)
          for (wi.iushrn(is); is-- > 0; )
            (Ri.isOdd() || Ti.isOdd()) && (Ri.iadd(Ni), Ti.isub(Vi)), Ri.iushrn(1), Ti.iushrn(1);
        for (var ts = 0, qi = 1; !(Ai.words[0] & qi) && ts < 26; ++ts, qi <<= 1) ;
        if (ts > 0)
          for (Ai.iushrn(ts); ts-- > 0; )
            (Ci.isOdd() || Ii.isOdd()) && (Ci.iadd(Ni), Ii.isub(Vi)), Ci.iushrn(1), Ii.iushrn(1);
        wi.cmp(Ai) >= 0 ? (wi.isub(Ai), Ri.isub(Ci), Ti.isub(Ii)) : (Ai.isub(wi), Ci.isub(Ri), Ii.isub(Ti));
      }
      return {
        a: Ci,
        b: Ii,
        gcd: Ai.iushln(Li)
      };
    }, Te.prototype._invmp = function(vi) {
      Be(vi.negative === 0), Be(!vi.isZero());
      var wi = this, Ai = vi.clone();
      wi.negative !== 0 ? wi = wi.umod(vi) : wi = wi.clone();
      for (var Ri = new Te(1), Ti = new Te(0), Ci = Ai.clone(); wi.cmpn(1) > 0 && Ai.cmpn(1) > 0; ) {
        for (var Ii = 0, Li = 1; !(wi.words[0] & Li) && Ii < 26; ++Ii, Li <<= 1) ;
        if (Ii > 0)
          for (wi.iushrn(Ii); Ii-- > 0; )
            Ri.isOdd() && Ri.iadd(Ci), Ri.iushrn(1);
        for (var Ni = 0, Vi = 1; !(Ai.words[0] & Vi) && Ni < 26; ++Ni, Vi <<= 1) ;
        if (Ni > 0)
          for (Ai.iushrn(Ni); Ni-- > 0; )
            Ti.isOdd() && Ti.iadd(Ci), Ti.iushrn(1);
        wi.cmp(Ai) >= 0 ? (wi.isub(Ai), Ri.isub(Ti)) : (Ai.isub(wi), Ti.isub(Ri));
      }
      var is;
      return wi.cmpn(1) === 0 ? is = Ri : is = Ti, is.cmpn(0) < 0 && is.iadd(vi), is;
    }, Te.prototype.gcd = function(vi) {
      if (this.isZero()) return vi.abs();
      if (vi.isZero()) return this.abs();
      var wi = this.clone(), Ai = vi.clone();
      wi.negative = 0, Ai.negative = 0;
      for (var Ri = 0; wi.isEven() && Ai.isEven(); Ri++)
        wi.iushrn(1), Ai.iushrn(1);
      do {
        for (; wi.isEven(); )
          wi.iushrn(1);
        for (; Ai.isEven(); )
          Ai.iushrn(1);
        var Ti = wi.cmp(Ai);
        if (Ti < 0) {
          var Ci = wi;
          wi = Ai, Ai = Ci;
        } else if (Ti === 0 || Ai.cmpn(1) === 0)
          break;
        wi.isub(Ai);
      } while (!0);
      return Ai.iushln(Ri);
    }, Te.prototype.invm = function(vi) {
      return this.egcd(vi).a.umod(vi);
    }, Te.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, Te.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, Te.prototype.andln = function(vi) {
      return this.words[0] & vi;
    }, Te.prototype.bincn = function(vi) {
      Be(typeof vi == "number");
      var wi = vi % 26, Ai = (vi - wi) / 26, Ri = 1 << wi;
      if (this.length <= Ai)
        return this._expand(Ai + 1), this.words[Ai] |= Ri, this;
      for (var Ti = Ri, Ci = Ai; Ti !== 0 && Ci < this.length; Ci++) {
        var Ii = this.words[Ci] | 0;
        Ii += Ti, Ti = Ii >>> 26, Ii &= 67108863, this.words[Ci] = Ii;
      }
      return Ti !== 0 && (this.words[Ci] = Ti, this.length++), this;
    }, Te.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, Te.prototype.cmpn = function(vi) {
      var wi = vi < 0;
      if (this.negative !== 0 && !wi) return -1;
      if (this.negative === 0 && wi) return 1;
      this._strip();
      var Ai;
      if (this.length > 1)
        Ai = 1;
      else {
        wi && (vi = -vi), Be(vi <= 67108863, "Number is too big");
        var Ri = this.words[0] | 0;
        Ai = Ri === vi ? 0 : Ri < vi ? -1 : 1;
      }
      return this.negative !== 0 ? -Ai | 0 : Ai;
    }, Te.prototype.cmp = function(vi) {
      if (this.negative !== 0 && vi.negative === 0) return -1;
      if (this.negative === 0 && vi.negative !== 0) return 1;
      var wi = this.ucmp(vi);
      return this.negative !== 0 ? -wi | 0 : wi;
    }, Te.prototype.ucmp = function(vi) {
      if (this.length > vi.length) return 1;
      if (this.length < vi.length) return -1;
      for (var wi = 0, Ai = this.length - 1; Ai >= 0; Ai--) {
        var Ri = this.words[Ai] | 0, Ti = vi.words[Ai] | 0;
        if (Ri !== Ti) {
          Ri < Ti ? wi = -1 : Ri > Ti && (wi = 1);
          break;
        }
      }
      return wi;
    }, Te.prototype.gtn = function(vi) {
      return this.cmpn(vi) === 1;
    }, Te.prototype.gt = function(vi) {
      return this.cmp(vi) === 1;
    }, Te.prototype.gten = function(vi) {
      return this.cmpn(vi) >= 0;
    }, Te.prototype.gte = function(vi) {
      return this.cmp(vi) >= 0;
    }, Te.prototype.ltn = function(vi) {
      return this.cmpn(vi) === -1;
    }, Te.prototype.lt = function(vi) {
      return this.cmp(vi) === -1;
    }, Te.prototype.lten = function(vi) {
      return this.cmpn(vi) <= 0;
    }, Te.prototype.lte = function(vi) {
      return this.cmp(vi) <= 0;
    }, Te.prototype.eqn = function(vi) {
      return this.cmpn(vi) === 0;
    }, Te.prototype.eq = function(vi) {
      return this.cmp(vi) === 0;
    }, Te.red = function(vi) {
      return new zi(vi);
    }, Te.prototype.toRed = function(vi) {
      return Be(!this.red, "Already a number in reduction context"), Be(this.negative === 0, "red works only with positives"), vi.convertTo(this)._forceRed(vi);
    }, Te.prototype.fromRed = function() {
      return Be(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, Te.prototype._forceRed = function(vi) {
      return this.red = vi, this;
    }, Te.prototype.forceRed = function(vi) {
      return Be(!this.red, "Already a number in reduction context"), this._forceRed(vi);
    }, Te.prototype.redAdd = function(vi) {
      return Be(this.red, "redAdd works only with red numbers"), this.red.add(this, vi);
    }, Te.prototype.redIAdd = function(vi) {
      return Be(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, vi);
    }, Te.prototype.redSub = function(vi) {
      return Be(this.red, "redSub works only with red numbers"), this.red.sub(this, vi);
    }, Te.prototype.redISub = function(vi) {
      return Be(this.red, "redISub works only with red numbers"), this.red.isub(this, vi);
    }, Te.prototype.redShl = function(vi) {
      return Be(this.red, "redShl works only with red numbers"), this.red.shl(this, vi);
    }, Te.prototype.redMul = function(vi) {
      return Be(this.red, "redMul works only with red numbers"), this.red._verify2(this, vi), this.red.mul(this, vi);
    }, Te.prototype.redIMul = function(vi) {
      return Be(this.red, "redMul works only with red numbers"), this.red._verify2(this, vi), this.red.imul(this, vi);
    }, Te.prototype.redSqr = function() {
      return Be(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, Te.prototype.redISqr = function() {
      return Be(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, Te.prototype.redSqrt = function() {
      return Be(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, Te.prototype.redInvm = function() {
      return Be(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, Te.prototype.redNeg = function() {
      return Be(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, Te.prototype.redPow = function(vi) {
      return Be(this.red && !vi.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, vi);
    };
    var Fi = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ui($i, vi) {
      this.name = $i, this.p = new Te(vi, 16), this.n = this.p.bitLength(), this.k = new Te(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Ui.prototype._tmp = function() {
      var vi = new Te(null);
      return vi.words = new Array(Math.ceil(this.n / 13)), vi;
    }, Ui.prototype.ireduce = function(vi) {
      var wi = vi, Ai;
      do
        this.split(wi, this.tmp), wi = this.imulK(wi), wi = wi.iadd(this.tmp), Ai = wi.bitLength();
      while (Ai > this.n);
      var Ri = Ai < this.n ? -1 : wi.ucmp(this.p);
      return Ri === 0 ? (wi.words[0] = 0, wi.length = 1) : Ri > 0 ? wi.isub(this.p) : wi.strip !== void 0 ? wi.strip() : wi._strip(), wi;
    }, Ui.prototype.split = function(vi, wi) {
      vi.iushrn(this.n, 0, wi);
    }, Ui.prototype.imulK = function(vi) {
      return vi.imul(this.k);
    };
    function Pi() {
      Ui.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    Pe(Pi, Ui), Pi.prototype.split = function(vi, wi) {
      for (var Ai = 4194303, Ri = Math.min(vi.length, 9), Ti = 0; Ti < Ri; Ti++)
        wi.words[Ti] = vi.words[Ti];
      if (wi.length = Ri, vi.length <= 9) {
        vi.words[0] = 0, vi.length = 1;
        return;
      }
      var Ci = vi.words[9];
      for (wi.words[wi.length++] = Ci & Ai, Ti = 10; Ti < vi.length; Ti++) {
        var Ii = vi.words[Ti] | 0;
        vi.words[Ti - 10] = (Ii & Ai) << 4 | Ci >>> 22, Ci = Ii;
      }
      Ci >>>= 22, vi.words[Ti - 10] = Ci, Ci === 0 && vi.length > 10 ? vi.length -= 10 : vi.length -= 9;
    }, Pi.prototype.imulK = function(vi) {
      vi.words[vi.length] = 0, vi.words[vi.length + 1] = 0, vi.length += 2;
      for (var wi = 0, Ai = 0; Ai < vi.length; Ai++) {
        var Ri = vi.words[Ai] | 0;
        wi += Ri * 977, vi.words[Ai] = wi & 67108863, wi = Ri * 64 + (wi / 67108864 | 0);
      }
      return vi.words[vi.length - 1] === 0 && (vi.length--, vi.words[vi.length - 1] === 0 && vi.length--), vi;
    };
    function Bi() {
      Ui.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    Pe(Bi, Ui);
    function ji() {
      Ui.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    Pe(ji, Ui);
    function Zi() {
      Ui.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    Pe(Zi, Ui), Zi.prototype.imulK = function(vi) {
      for (var wi = 0, Ai = 0; Ai < vi.length; Ai++) {
        var Ri = (vi.words[Ai] | 0) * 19 + wi, Ti = Ri & 67108863;
        Ri >>>= 26, vi.words[Ai] = Ti, wi = Ri;
      }
      return wi !== 0 && (vi.words[vi.length++] = wi), vi;
    }, Te._prime = function(vi) {
      if (Fi[vi]) return Fi[vi];
      var wi;
      if (vi === "k256")
        wi = new Pi();
      else if (vi === "p224")
        wi = new Bi();
      else if (vi === "p192")
        wi = new ji();
      else if (vi === "p25519")
        wi = new Zi();
      else
        throw new Error("Unknown prime " + vi);
      return Fi[vi] = wi, wi;
    };
    function zi($i) {
      if (typeof $i == "string") {
        var vi = Te._prime($i);
        this.m = vi.p, this.prime = vi;
      } else
        Be($i.gtn(1), "modulus must be greater than 1"), this.m = $i, this.prime = null;
    }
    zi.prototype._verify1 = function(vi) {
      Be(vi.negative === 0, "red works only with positives"), Be(vi.red, "red works only with red numbers");
    }, zi.prototype._verify2 = function(vi, wi) {
      Be((vi.negative | wi.negative) === 0, "red works only with positives"), Be(
        vi.red && vi.red === wi.red,
        "red works only with red numbers"
      );
    }, zi.prototype.imod = function(vi) {
      return this.prime ? this.prime.ireduce(vi)._forceRed(this) : (Ve(vi, vi.umod(this.m)._forceRed(this)), vi);
    }, zi.prototype.neg = function(vi) {
      return vi.isZero() ? vi.clone() : this.m.sub(vi)._forceRed(this);
    }, zi.prototype.add = function(vi, wi) {
      this._verify2(vi, wi);
      var Ai = vi.add(wi);
      return Ai.cmp(this.m) >= 0 && Ai.isub(this.m), Ai._forceRed(this);
    }, zi.prototype.iadd = function(vi, wi) {
      this._verify2(vi, wi);
      var Ai = vi.iadd(wi);
      return Ai.cmp(this.m) >= 0 && Ai.isub(this.m), Ai;
    }, zi.prototype.sub = function(vi, wi) {
      this._verify2(vi, wi);
      var Ai = vi.sub(wi);
      return Ai.cmpn(0) < 0 && Ai.iadd(this.m), Ai._forceRed(this);
    }, zi.prototype.isub = function(vi, wi) {
      this._verify2(vi, wi);
      var Ai = vi.isub(wi);
      return Ai.cmpn(0) < 0 && Ai.iadd(this.m), Ai;
    }, zi.prototype.shl = function(vi, wi) {
      return this._verify1(vi), this.imod(vi.ushln(wi));
    }, zi.prototype.imul = function(vi, wi) {
      return this._verify2(vi, wi), this.imod(vi.imul(wi));
    }, zi.prototype.mul = function(vi, wi) {
      return this._verify2(vi, wi), this.imod(vi.mul(wi));
    }, zi.prototype.isqr = function(vi) {
      return this.imul(vi, vi.clone());
    }, zi.prototype.sqr = function(vi) {
      return this.mul(vi, vi);
    }, zi.prototype.sqrt = function(vi) {
      if (vi.isZero()) return vi.clone();
      var wi = this.m.andln(3);
      if (Be(wi % 2 === 1), wi === 3) {
        var Ai = this.m.add(new Te(1)).iushrn(2);
        return this.pow(vi, Ai);
      }
      for (var Ri = this.m.subn(1), Ti = 0; !Ri.isZero() && Ri.andln(1) === 0; )
        Ti++, Ri.iushrn(1);
      Be(!Ri.isZero());
      var Ci = new Te(1).toRed(this), Ii = Ci.redNeg(), Li = this.m.subn(1).iushrn(1), Ni = this.m.bitLength();
      for (Ni = new Te(2 * Ni * Ni).toRed(this); this.pow(Ni, Li).cmp(Ii) !== 0; )
        Ni.redIAdd(Ii);
      for (var Vi = this.pow(Ni, Ri), is = this.pow(vi, Ri.addn(1).iushrn(1)), Ki = this.pow(vi, Ri), ts = Ti; Ki.cmp(Ci) !== 0; ) {
        for (var qi = Ki, Hi = 0; qi.cmp(Ci) !== 0; Hi++)
          qi = qi.redSqr();
        Be(Hi < ts);
        var Xi = this.pow(Vi, new Te(1).iushln(ts - Hi - 1));
        is = is.redMul(Xi), Vi = Xi.redSqr(), Ki = Ki.redMul(Vi), ts = Hi;
      }
      return is;
    }, zi.prototype.invm = function(vi) {
      var wi = vi._invmp(this.m);
      return wi.negative !== 0 ? (wi.negative = 0, this.imod(wi).redNeg()) : this.imod(wi);
    }, zi.prototype.pow = function(vi, wi) {
      if (wi.isZero()) return new Te(1).toRed(this);
      if (wi.cmpn(1) === 0) return vi.clone();
      var Ai = 4, Ri = new Array(1 << Ai);
      Ri[0] = new Te(1).toRed(this), Ri[1] = vi;
      for (var Ti = 2; Ti < Ri.length; Ti++)
        Ri[Ti] = this.mul(Ri[Ti - 1], vi);
      var Ci = Ri[0], Ii = 0, Li = 0, Ni = wi.bitLength() % 26;
      for (Ni === 0 && (Ni = 26), Ti = wi.length - 1; Ti >= 0; Ti--) {
        for (var Vi = wi.words[Ti], is = Ni - 1; is >= 0; is--) {
          var Ki = Vi >> is & 1;
          if (Ci !== Ri[0] && (Ci = this.sqr(Ci)), Ki === 0 && Ii === 0) {
            Li = 0;
            continue;
          }
          Ii <<= 1, Ii |= Ki, Li++, !(Li !== Ai && (Ti !== 0 || is !== 0)) && (Ci = this.mul(Ci, Ri[Ii]), Li = 0, Ii = 0);
        }
        Ni = 26;
      }
      return Ci;
    }, zi.prototype.convertTo = function(vi) {
      var wi = vi.umod(this.m);
      return wi === vi ? wi.clone() : wi;
    }, zi.prototype.convertFrom = function(vi) {
      var wi = vi.clone();
      return wi.red = null, wi;
    }, Te.mont = function(vi) {
      return new xi(vi);
    };
    function xi($i) {
      zi.call(this, $i), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new Te(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    Pe(xi, zi), xi.prototype.convertTo = function(vi) {
      return this.imod(vi.ushln(this.shift));
    }, xi.prototype.convertFrom = function(vi) {
      var wi = this.imod(vi.mul(this.rinv));
      return wi.red = null, wi;
    }, xi.prototype.imul = function(vi, wi) {
      if (vi.isZero() || wi.isZero())
        return vi.words[0] = 0, vi.length = 1, vi;
      var Ai = vi.imul(wi), Ri = Ai.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Ti = Ai.isub(Ri).iushrn(this.shift), Ci = Ti;
      return Ti.cmp(this.m) >= 0 ? Ci = Ti.isub(this.m) : Ti.cmpn(0) < 0 && (Ci = Ti.iadd(this.m)), Ci._forceRed(this);
    }, xi.prototype.mul = function(vi, wi) {
      if (vi.isZero() || wi.isZero()) return new Te(0)._forceRed(this);
      var Ai = vi.mul(wi), Ri = Ai.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Ti = Ai.isub(Ri).iushrn(this.shift), Ci = Ti;
      return Ti.cmp(this.m) >= 0 ? Ci = Ti.isub(this.m) : Ti.cmpn(0) < 0 && (Ci = Ti.iadd(this.m)), Ci._forceRed(this);
    }, xi.prototype.invm = function(vi) {
      var wi = this.imod(vi._invmp(this.m).mul(this.r2));
      return wi._forceRed(this);
    };
  })(Ae, commonjsGlobal);
})(bn$3);
var bnExports = bn$3.exports;
const BN$1 = /* @__PURE__ */ getDefaultExportFromCjs(bnExports);
function number$2(Ae) {
  if (!Number.isSafeInteger(Ae) || Ae < 0)
    throw new Error(`positive integer expected, not ${Ae}`);
}
function bool(Ae) {
  if (typeof Ae != "boolean")
    throw new Error(`boolean expected, not ${Ae}`);
}
function isBytes$4(Ae) {
  return Ae instanceof Uint8Array || Ae != null && typeof Ae == "object" && Ae.constructor.name === "Uint8Array";
}
function bytes$2(Ae, ...t) {
  if (!isBytes$4(Ae))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(Ae.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${Ae.length}`);
}
function hash$7(Ae) {
  if (typeof Ae != "function" || typeof Ae.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$2(Ae.outputLen), number$2(Ae.blockLen);
}
function exists$2(Ae, t = !0) {
  if (Ae.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && Ae.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$2(Ae, t) {
  bytes$2(Ae);
  const Ie = t.outputLen;
  if (Ae.length < Ie)
    throw new Error(`digestInto() expects output buffer of length at least ${Ie}`);
}
const assert$e = { number: number$2, bool, bytes: bytes$2, hash: hash$7, exists: exists$2, output: output$2 }, crypto$4 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u32$2 = (Ae) => new Uint32Array(Ae.buffer, Ae.byteOffset, Math.floor(Ae.byteLength / 4)), createView$2 = (Ae) => new DataView(Ae.buffer, Ae.byteOffset, Ae.byteLength), rotr$2 = (Ae, t) => Ae << 32 - t | Ae >>> t, isLE$2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, byteSwap$1 = (Ae) => Ae << 24 & 4278190080 | Ae << 8 & 16711680 | Ae >>> 8 & 65280 | Ae >>> 24 & 255;
function byteSwap32$1(Ae) {
  for (let t = 0; t < Ae.length; t++)
    Ae[t] = byteSwap$1(Ae[t]);
}
function utf8ToBytes$5(Ae) {
  if (typeof Ae != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof Ae}`);
  return new Uint8Array(new TextEncoder().encode(Ae));
}
function toBytes$4(Ae) {
  return typeof Ae == "string" && (Ae = utf8ToBytes$5(Ae)), bytes$2(Ae), Ae;
}
function concatBytes$6(...Ae) {
  let t = 0;
  for (let Be = 0; Be < Ae.length; Be++) {
    const Pe = Ae[Be];
    bytes$2(Pe), t += Pe.length;
  }
  const Ie = new Uint8Array(t);
  for (let Be = 0, Pe = 0; Be < Ae.length; Be++) {
    const Te = Ae[Be];
    Ie.set(Te, Pe), Pe += Te.length;
  }
  return Ie;
}
let Hash$2 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$2(Ae) {
  const t = (Be) => Ae().update(toBytes$4(Be)).digest(), Ie = Ae();
  return t.outputLen = Ie.outputLen, t.blockLen = Ie.blockLen, t.create = () => Ae(), t;
}
function randomBytes$2(Ae = 32) {
  if (crypto$4 && typeof crypto$4.getRandomValues == "function")
    return crypto$4.getRandomValues(new Uint8Array(Ae));
  throw new Error("crypto.getRandomValues must be defined");
}
let HMAC$3 = class extends Hash$2 {
  constructor(t, Ie) {
    super(), this.finished = !1, this.destroyed = !1, hash$7(t);
    const Be = toBytes$4(Ie);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const Pe = this.blockLen, Te = new Uint8Array(Pe);
    Te.set(Be.length > Pe ? t.create().update(Be).digest() : Be);
    for (let Me = 0; Me < Te.length; Me++)
      Te[Me] ^= 54;
    this.iHash.update(Te), this.oHash = t.create();
    for (let Me = 0; Me < Te.length; Me++)
      Te[Me] ^= 106;
    this.oHash.update(Te), Te.fill(0);
  }
  update(t) {
    return exists$2(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    exists$2(this), bytes$2(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: Ie, iHash: Be, finished: Pe, destroyed: Te, blockLen: Me, outputLen: Ue } = this;
    return t = t, t.finished = Pe, t.destroyed = Te, t.blockLen = Me, t.outputLen = Ue, t.oHash = Ie._cloneInto(t.oHash), t.iHash = Be._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const hmac$5 = (Ae, t, Ie) => new HMAC$3(Ae, t).update(Ie).digest();
hmac$5.create = (Ae, t) => new HMAC$3(Ae, t);
function setBigUint64$2(Ae, t, Ie, Be) {
  if (typeof Ae.setBigUint64 == "function")
    return Ae.setBigUint64(t, Ie, Be);
  const Pe = BigInt(32), Te = BigInt(4294967295), Me = Number(Ie >> Pe & Te), Ue = Number(Ie & Te), je = Be ? 4 : 0, fn = Be ? 0 : 4;
  Ae.setUint32(t + je, Me, Be), Ae.setUint32(t + fn, Ue, Be);
}
const Chi$2 = (Ae, t, Ie) => Ae & t ^ ~Ae & Ie, Maj$2 = (Ae, t, Ie) => Ae & t ^ Ae & Ie ^ t & Ie;
let HashMD$1 = class extends Hash$2 {
  constructor(t, Ie, Be, Pe) {
    super(), this.blockLen = t, this.outputLen = Ie, this.padOffset = Be, this.isLE = Pe, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = createView$2(this.buffer);
  }
  update(t) {
    exists$2(this);
    const { view: Ie, buffer: Be, blockLen: Pe } = this;
    t = toBytes$4(t);
    const Te = t.length;
    for (let Me = 0; Me < Te; ) {
      const Ue = Math.min(Pe - this.pos, Te - Me);
      if (Ue === Pe) {
        const je = createView$2(t);
        for (; Pe <= Te - Me; Me += Pe)
          this.process(je, Me);
        continue;
      }
      Be.set(t.subarray(Me, Me + Ue), this.pos), this.pos += Ue, Me += Ue, this.pos === Pe && (this.process(Ie, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    exists$2(this), output$2(t, this), this.finished = !0;
    const { buffer: Ie, view: Be, blockLen: Pe, isLE: Te } = this;
    let { pos: Me } = this;
    Ie[Me++] = 128, this.buffer.subarray(Me).fill(0), this.padOffset > Pe - Me && (this.process(Be, 0), Me = 0);
    for (let vn = Me; vn < Pe; vn++)
      Ie[vn] = 0;
    setBigUint64$2(Be, Pe - 8, BigInt(this.length * 8), Te), this.process(Be, 0);
    const Ue = createView$2(t), je = this.outputLen;
    if (je % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const fn = je / 4, Ve = this.get();
    if (fn > Ve.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let vn = 0; vn < fn; vn++)
      Ue.setUint32(4 * vn, Ve[vn], Te);
  }
  digest() {
    const { buffer: t, outputLen: Ie } = this;
    this.digestInto(t);
    const Be = t.slice(0, Ie);
    return this.destroy(), Be;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: Ie, buffer: Be, length: Pe, finished: Te, destroyed: Me, pos: Ue } = this;
    return t.length = Pe, t.pos = Ue, t.finished = Te, t.destroyed = Me, Pe % Ie && t.buffer.set(Be), t;
  }
};
const SHA256_K$2 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), SHA256_IV$1 = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W$2 = /* @__PURE__ */ new Uint32Array(64);
let SHA256$4 = class extends HashMD$1 {
  constructor() {
    super(64, 32, 8, !1), this.A = SHA256_IV$1[0] | 0, this.B = SHA256_IV$1[1] | 0, this.C = SHA256_IV$1[2] | 0, this.D = SHA256_IV$1[3] | 0, this.E = SHA256_IV$1[4] | 0, this.F = SHA256_IV$1[5] | 0, this.G = SHA256_IV$1[6] | 0, this.H = SHA256_IV$1[7] | 0;
  }
  get() {
    const { A: t, B: Ie, C: Be, D: Pe, E: Te, F: Me, G: Ue, H: je } = this;
    return [t, Ie, Be, Pe, Te, Me, Ue, je];
  }
  // prettier-ignore
  set(t, Ie, Be, Pe, Te, Me, Ue, je) {
    this.A = t | 0, this.B = Ie | 0, this.C = Be | 0, this.D = Pe | 0, this.E = Te | 0, this.F = Me | 0, this.G = Ue | 0, this.H = je | 0;
  }
  process(t, Ie) {
    for (let vn = 0; vn < 16; vn++, Ie += 4)
      SHA256_W$2[vn] = t.getUint32(Ie, !1);
    for (let vn = 16; vn < 64; vn++) {
      const En = SHA256_W$2[vn - 15], fi = SHA256_W$2[vn - 2], bi = rotr$2(En, 7) ^ rotr$2(En, 18) ^ En >>> 3, mi = rotr$2(fi, 17) ^ rotr$2(fi, 19) ^ fi >>> 10;
      SHA256_W$2[vn] = mi + SHA256_W$2[vn - 7] + bi + SHA256_W$2[vn - 16] | 0;
    }
    let { A: Be, B: Pe, C: Te, D: Me, E: Ue, F: je, G: fn, H: Ve } = this;
    for (let vn = 0; vn < 64; vn++) {
      const En = rotr$2(Ue, 6) ^ rotr$2(Ue, 11) ^ rotr$2(Ue, 25), fi = Ve + En + Chi$2(Ue, je, fn) + SHA256_K$2[vn] + SHA256_W$2[vn] | 0, mi = (rotr$2(Be, 2) ^ rotr$2(Be, 13) ^ rotr$2(Be, 22)) + Maj$2(Be, Pe, Te) | 0;
      Ve = fn, fn = je, je = Ue, Ue = Me + fi | 0, Me = Te, Te = Pe, Pe = Be, Be = fi + mi | 0;
    }
    Be = Be + this.A | 0, Pe = Pe + this.B | 0, Te = Te + this.C | 0, Me = Me + this.D | 0, Ue = Ue + this.E | 0, je = je + this.F | 0, fn = fn + this.G | 0, Ve = Ve + this.H | 0, this.set(Be, Pe, Te, Me, Ue, je, fn, Ve);
  }
  roundClean() {
    SHA256_W$2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const sha256$7 = /* @__PURE__ */ wrapConstructor$2(() => new SHA256$4()), U32_MASK64$2 = /* @__PURE__ */ BigInt(2 ** 32 - 1), _32n$2 = /* @__PURE__ */ BigInt(32);
function fromBig$2(Ae, t = !1) {
  return t ? { h: Number(Ae & U32_MASK64$2), l: Number(Ae >> _32n$2 & U32_MASK64$2) } : { h: Number(Ae >> _32n$2 & U32_MASK64$2) | 0, l: Number(Ae & U32_MASK64$2) | 0 };
}
function split$2(Ae, t = !1) {
  let Ie = new Uint32Array(Ae.length), Be = new Uint32Array(Ae.length);
  for (let Pe = 0; Pe < Ae.length; Pe++) {
    const { h: Te, l: Me } = fromBig$2(Ae[Pe], t);
    [Ie[Pe], Be[Pe]] = [Te, Me];
  }
  return [Ie, Be];
}
const rotlSH$2 = (Ae, t, Ie) => Ae << Ie | t >>> 32 - Ie, rotlSL$2 = (Ae, t, Ie) => t << Ie | Ae >>> 32 - Ie, rotlBH$2 = (Ae, t, Ie) => t << Ie - 32 | Ae >>> 64 - Ie, rotlBL$2 = (Ae, t, Ie) => Ae << Ie - 32 | t >>> 64 - Ie;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$e = /* @__PURE__ */ BigInt(0), _1n$h = /* @__PURE__ */ BigInt(1), _2n$b = /* @__PURE__ */ BigInt(2);
function isBytes$3(Ae) {
  return Ae instanceof Uint8Array || Ae != null && typeof Ae == "object" && Ae.constructor.name === "Uint8Array";
}
function abytes$1(Ae) {
  if (!isBytes$3(Ae))
    throw new Error("Uint8Array expected");
}
const hexes$3 = /* @__PURE__ */ Array.from({ length: 256 }, (Ae, t) => t.toString(16).padStart(2, "0"));
function bytesToHex$4(Ae) {
  abytes$1(Ae);
  let t = "";
  for (let Ie = 0; Ie < Ae.length; Ie++)
    t += hexes$3[Ae[Ie]];
  return t;
}
function numberToHexUnpadded$2(Ae) {
  const t = Ae.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function hexToNumber$3(Ae) {
  if (typeof Ae != "string")
    throw new Error("hex string expected, got " + typeof Ae);
  return BigInt(Ae === "" ? "0" : `0x${Ae}`);
}
const asciis$1 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16$1(Ae) {
  if (Ae >= asciis$1._0 && Ae <= asciis$1._9)
    return Ae - asciis$1._0;
  if (Ae >= asciis$1._A && Ae <= asciis$1._F)
    return Ae - (asciis$1._A - 10);
  if (Ae >= asciis$1._a && Ae <= asciis$1._f)
    return Ae - (asciis$1._a - 10);
}
function hexToBytes$4(Ae) {
  if (typeof Ae != "string")
    throw new Error("hex string expected, got " + typeof Ae);
  const t = Ae.length, Ie = t / 2;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const Be = new Uint8Array(Ie);
  for (let Pe = 0, Te = 0; Pe < Ie; Pe++, Te += 2) {
    const Me = asciiToBase16$1(Ae.charCodeAt(Te)), Ue = asciiToBase16$1(Ae.charCodeAt(Te + 1));
    if (Me === void 0 || Ue === void 0) {
      const je = Ae[Te] + Ae[Te + 1];
      throw new Error('hex string expected, got non-hex character "' + je + '" at index ' + Te);
    }
    Be[Pe] = Me * 16 + Ue;
  }
  return Be;
}
function bytesToNumberBE$2(Ae) {
  return hexToNumber$3(bytesToHex$4(Ae));
}
function bytesToNumberLE$2(Ae) {
  return abytes$1(Ae), hexToNumber$3(bytesToHex$4(Uint8Array.from(Ae).reverse()));
}
function numberToBytesBE$2(Ae, t) {
  return hexToBytes$4(Ae.toString(16).padStart(t * 2, "0"));
}
function numberToBytesLE$2(Ae, t) {
  return numberToBytesBE$2(Ae, t).reverse();
}
function numberToVarBytesBE$2(Ae) {
  return hexToBytes$4(numberToHexUnpadded$2(Ae));
}
function ensureBytes$2(Ae, t, Ie) {
  let Be;
  if (typeof t == "string")
    try {
      Be = hexToBytes$4(t);
    } catch (Te) {
      throw new Error(`${Ae} must be valid hex string, got "${t}". Cause: ${Te}`);
    }
  else if (isBytes$3(t))
    Be = Uint8Array.from(t);
  else
    throw new Error(`${Ae} must be hex string or Uint8Array`);
  const Pe = Be.length;
  if (typeof Ie == "number" && Pe !== Ie)
    throw new Error(`${Ae} expected ${Ie} bytes, got ${Pe}`);
  return Be;
}
function concatBytes$5(...Ae) {
  let t = 0;
  for (let Be = 0; Be < Ae.length; Be++) {
    const Pe = Ae[Be];
    abytes$1(Pe), t += Pe.length;
  }
  const Ie = new Uint8Array(t);
  for (let Be = 0, Pe = 0; Be < Ae.length; Be++) {
    const Te = Ae[Be];
    Ie.set(Te, Pe), Pe += Te.length;
  }
  return Ie;
}
function equalBytes$2(Ae, t) {
  if (Ae.length !== t.length)
    return !1;
  let Ie = 0;
  for (let Be = 0; Be < Ae.length; Be++)
    Ie |= Ae[Be] ^ t[Be];
  return Ie === 0;
}
function utf8ToBytes$4(Ae) {
  if (typeof Ae != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof Ae}`);
  return new Uint8Array(new TextEncoder().encode(Ae));
}
function bitLen$2(Ae) {
  let t;
  for (t = 0; Ae > _0n$e; Ae >>= _1n$h, t += 1)
    ;
  return t;
}
function bitGet$2(Ae, t) {
  return Ae >> BigInt(t) & _1n$h;
}
function bitSet$2(Ae, t, Ie) {
  return Ae | (Ie ? _1n$h : _0n$e) << BigInt(t);
}
const bitMask$2 = (Ae) => (_2n$b << BigInt(Ae - 1)) - _1n$h, u8n$2 = (Ae) => new Uint8Array(Ae), u8fr$2 = (Ae) => Uint8Array.from(Ae);
function createHmacDrbg$2(Ae, t, Ie) {
  if (typeof Ae != "number" || Ae < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof Ie != "function")
    throw new Error("hmacFn must be a function");
  let Be = u8n$2(Ae), Pe = u8n$2(Ae), Te = 0;
  const Me = () => {
    Be.fill(1), Pe.fill(0), Te = 0;
  }, Ue = (...vn) => Ie(Pe, Be, ...vn), je = (vn = u8n$2()) => {
    Pe = Ue(u8fr$2([0]), vn), Be = Ue(), vn.length !== 0 && (Pe = Ue(u8fr$2([1]), vn), Be = Ue());
  }, fn = () => {
    if (Te++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let vn = 0;
    const En = [];
    for (; vn < t; ) {
      Be = Ue();
      const fi = Be.slice();
      En.push(fi), vn += Be.length;
    }
    return concatBytes$5(...En);
  };
  return (vn, En) => {
    Me(), je(vn);
    let fi;
    for (; !(fi = En(fn())); )
      je();
    return Me(), fi;
  };
}
const validatorFns$2 = {
  bigint: (Ae) => typeof Ae == "bigint",
  function: (Ae) => typeof Ae == "function",
  boolean: (Ae) => typeof Ae == "boolean",
  string: (Ae) => typeof Ae == "string",
  stringOrUint8Array: (Ae) => typeof Ae == "string" || isBytes$3(Ae),
  isSafeInteger: (Ae) => Number.isSafeInteger(Ae),
  array: (Ae) => Array.isArray(Ae),
  field: (Ae, t) => t.Fp.isValid(Ae),
  hash: (Ae) => typeof Ae == "function" && Number.isSafeInteger(Ae.outputLen)
};
function validateObject$5(Ae, t, Ie = {}) {
  const Be = (Pe, Te, Me) => {
    const Ue = validatorFns$2[Te];
    if (typeof Ue != "function")
      throw new Error(`Invalid validator "${Te}", expected function`);
    const je = Ae[Pe];
    if (!(Me && je === void 0) && !Ue(je, Ae))
      throw new Error(`Invalid param ${String(Pe)}=${je} (${typeof je}), expected ${Te}`);
  };
  for (const [Pe, Te] of Object.entries(t))
    Be(Pe, Te, !1);
  for (const [Pe, Te] of Object.entries(Ie))
    Be(Pe, Te, !0);
  return Ae;
}
const ut$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  abytes: abytes$1,
  bitGet: bitGet$2,
  bitLen: bitLen$2,
  bitMask: bitMask$2,
  bitSet: bitSet$2,
  bytesToHex: bytesToHex$4,
  bytesToNumberBE: bytesToNumberBE$2,
  bytesToNumberLE: bytesToNumberLE$2,
  concatBytes: concatBytes$5,
  createHmacDrbg: createHmacDrbg$2,
  ensureBytes: ensureBytes$2,
  equalBytes: equalBytes$2,
  hexToBytes: hexToBytes$4,
  hexToNumber: hexToNumber$3,
  isBytes: isBytes$3,
  numberToBytesBE: numberToBytesBE$2,
  numberToBytesLE: numberToBytesLE$2,
  numberToHexUnpadded: numberToHexUnpadded$2,
  numberToVarBytesBE: numberToVarBytesBE$2,
  utf8ToBytes: utf8ToBytes$4,
  validateObject: validateObject$5
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$d = BigInt(0), _1n$g = BigInt(1), _2n$a = BigInt(2), _3n$5 = BigInt(3), _4n$2 = BigInt(4), _5n$2 = BigInt(5), _8n$2 = BigInt(8);
BigInt(9);
BigInt(16);
function mod$2(Ae, t) {
  const Ie = Ae % t;
  return Ie >= _0n$d ? Ie : t + Ie;
}
function pow$2(Ae, t, Ie) {
  if (Ie <= _0n$d || t < _0n$d)
    throw new Error("Expected power/modulo > 0");
  if (Ie === _1n$g)
    return _0n$d;
  let Be = _1n$g;
  for (; t > _0n$d; )
    t & _1n$g && (Be = Be * Ae % Ie), Ae = Ae * Ae % Ie, t >>= _1n$g;
  return Be;
}
function pow2$2(Ae, t, Ie) {
  let Be = Ae;
  for (; t-- > _0n$d; )
    Be *= Be, Be %= Ie;
  return Be;
}
function invert$2(Ae, t) {
  if (Ae === _0n$d || t <= _0n$d)
    throw new Error(`invert: expected positive integers, got n=${Ae} mod=${t}`);
  let Ie = mod$2(Ae, t), Be = t, Pe = _0n$d, Te = _1n$g;
  for (; Ie !== _0n$d; ) {
    const Ue = Be / Ie, je = Be % Ie, fn = Pe - Te * Ue;
    Be = Ie, Ie = je, Pe = Te, Te = fn;
  }
  if (Be !== _1n$g)
    throw new Error("invert: does not exist");
  return mod$2(Pe, t);
}
function tonelliShanks$2(Ae) {
  const t = (Ae - _1n$g) / _2n$a;
  let Ie, Be, Pe;
  for (Ie = Ae - _1n$g, Be = 0; Ie % _2n$a === _0n$d; Ie /= _2n$a, Be++)
    ;
  for (Pe = _2n$a; Pe < Ae && pow$2(Pe, t, Ae) !== Ae - _1n$g; Pe++)
    ;
  if (Be === 1) {
    const Me = (Ae + _1n$g) / _4n$2;
    return function(je, fn) {
      const Ve = je.pow(fn, Me);
      if (!je.eql(je.sqr(Ve), fn))
        throw new Error("Cannot find square root");
      return Ve;
    };
  }
  const Te = (Ie + _1n$g) / _2n$a;
  return function(Ue, je) {
    if (Ue.pow(je, t) === Ue.neg(Ue.ONE))
      throw new Error("Cannot find square root");
    let fn = Be, Ve = Ue.pow(Ue.mul(Ue.ONE, Pe), Ie), vn = Ue.pow(je, Te), En = Ue.pow(je, Ie);
    for (; !Ue.eql(En, Ue.ONE); ) {
      if (Ue.eql(En, Ue.ZERO))
        return Ue.ZERO;
      let fi = 1;
      for (let mi = Ue.sqr(En); fi < fn && !Ue.eql(mi, Ue.ONE); fi++)
        mi = Ue.sqr(mi);
      const bi = Ue.pow(Ve, _1n$g << BigInt(fn - fi - 1));
      Ve = Ue.sqr(bi), vn = Ue.mul(vn, bi), En = Ue.mul(En, Ve), fn = fi;
    }
    return vn;
  };
}
function FpSqrt$2(Ae) {
  if (Ae % _4n$2 === _3n$5) {
    const t = (Ae + _1n$g) / _4n$2;
    return function(Be, Pe) {
      const Te = Be.pow(Pe, t);
      if (!Be.eql(Be.sqr(Te), Pe))
        throw new Error("Cannot find square root");
      return Te;
    };
  }
  if (Ae % _8n$2 === _5n$2) {
    const t = (Ae - _5n$2) / _8n$2;
    return function(Be, Pe) {
      const Te = Be.mul(Pe, _2n$a), Me = Be.pow(Te, t), Ue = Be.mul(Pe, Me), je = Be.mul(Be.mul(Ue, _2n$a), Me), fn = Be.mul(Ue, Be.sub(je, Be.ONE));
      if (!Be.eql(Be.sqr(fn), Pe))
        throw new Error("Cannot find square root");
      return fn;
    };
  }
  return tonelliShanks$2(Ae);
}
const FIELD_FIELDS$2 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField$2(Ae) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, Ie = FIELD_FIELDS$2.reduce((Be, Pe) => (Be[Pe] = "function", Be), t);
  return validateObject$5(Ae, Ie);
}
function FpPow$2(Ae, t, Ie) {
  if (Ie < _0n$d)
    throw new Error("Expected power > 0");
  if (Ie === _0n$d)
    return Ae.ONE;
  if (Ie === _1n$g)
    return t;
  let Be = Ae.ONE, Pe = t;
  for (; Ie > _0n$d; )
    Ie & _1n$g && (Be = Ae.mul(Be, Pe)), Pe = Ae.sqr(Pe), Ie >>= _1n$g;
  return Be;
}
function FpInvertBatch$2(Ae, t) {
  const Ie = new Array(t.length), Be = t.reduce((Te, Me, Ue) => Ae.is0(Me) ? Te : (Ie[Ue] = Te, Ae.mul(Te, Me)), Ae.ONE), Pe = Ae.inv(Be);
  return t.reduceRight((Te, Me, Ue) => Ae.is0(Me) ? Te : (Ie[Ue] = Ae.mul(Te, Ie[Ue]), Ae.mul(Te, Me)), Pe), Ie;
}
function nLength$2(Ae, t) {
  const Ie = t !== void 0 ? t : Ae.toString(2).length, Be = Math.ceil(Ie / 8);
  return { nBitLength: Ie, nByteLength: Be };
}
function Field$2(Ae, t, Ie = !1, Be = {}) {
  if (Ae <= _0n$d)
    throw new Error(`Expected Field ORDER > 0, got ${Ae}`);
  const { nBitLength: Pe, nByteLength: Te } = nLength$2(Ae, t);
  if (Te > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const Me = FpSqrt$2(Ae), Ue = Object.freeze({
    ORDER: Ae,
    BITS: Pe,
    BYTES: Te,
    MASK: bitMask$2(Pe),
    ZERO: _0n$d,
    ONE: _1n$g,
    create: (je) => mod$2(je, Ae),
    isValid: (je) => {
      if (typeof je != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof je}`);
      return _0n$d <= je && je < Ae;
    },
    is0: (je) => je === _0n$d,
    isOdd: (je) => (je & _1n$g) === _1n$g,
    neg: (je) => mod$2(-je, Ae),
    eql: (je, fn) => je === fn,
    sqr: (je) => mod$2(je * je, Ae),
    add: (je, fn) => mod$2(je + fn, Ae),
    sub: (je, fn) => mod$2(je - fn, Ae),
    mul: (je, fn) => mod$2(je * fn, Ae),
    pow: (je, fn) => FpPow$2(Ue, je, fn),
    div: (je, fn) => mod$2(je * invert$2(fn, Ae), Ae),
    // Same as above, but doesn't normalize
    sqrN: (je) => je * je,
    addN: (je, fn) => je + fn,
    subN: (je, fn) => je - fn,
    mulN: (je, fn) => je * fn,
    inv: (je) => invert$2(je, Ae),
    sqrt: Be.sqrt || ((je) => Me(Ue, je)),
    invertBatch: (je) => FpInvertBatch$2(Ue, je),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (je, fn, Ve) => Ve ? fn : je,
    toBytes: (je) => Ie ? numberToBytesLE$2(je, Te) : numberToBytesBE$2(je, Te),
    fromBytes: (je) => {
      if (je.length !== Te)
        throw new Error(`Fp.fromBytes: expected ${Te}, got ${je.length}`);
      return Ie ? bytesToNumberLE$2(je) : bytesToNumberBE$2(je);
    }
  });
  return Object.freeze(Ue);
}
function getFieldBytesLength$2(Ae) {
  if (typeof Ae != "bigint")
    throw new Error("field order must be bigint");
  const t = Ae.toString(2).length;
  return Math.ceil(t / 8);
}
function getMinHashLength$2(Ae) {
  const t = getFieldBytesLength$2(Ae);
  return t + Math.ceil(t / 2);
}
function mapHashToField$2(Ae, t, Ie = !1) {
  const Be = Ae.length, Pe = getFieldBytesLength$2(t), Te = getMinHashLength$2(t);
  if (Be < 16 || Be < Te || Be > 1024)
    throw new Error(`expected ${Te}-1024 bytes of input, got ${Be}`);
  const Me = Ie ? bytesToNumberBE$2(Ae) : bytesToNumberLE$2(Ae), Ue = mod$2(Me, t - _1n$g) + _1n$g;
  return Ie ? numberToBytesLE$2(Ue, Pe) : numberToBytesBE$2(Ue, Pe);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$c = BigInt(0), _1n$f = BigInt(1);
function wNAF$2(Ae, t) {
  const Ie = (Pe, Te) => {
    const Me = Te.negate();
    return Pe ? Me : Te;
  }, Be = (Pe) => {
    const Te = Math.ceil(t / Pe) + 1, Me = 2 ** (Pe - 1);
    return { windows: Te, windowSize: Me };
  };
  return {
    constTimeNegate: Ie,
    // non-const time multiplication ladder
    unsafeLadder(Pe, Te) {
      let Me = Ae.ZERO, Ue = Pe;
      for (; Te > _0n$c; )
        Te & _1n$f && (Me = Me.add(Ue)), Ue = Ue.double(), Te >>= _1n$f;
      return Me;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(Pe, Te) {
      const { windows: Me, windowSize: Ue } = Be(Te), je = [];
      let fn = Pe, Ve = fn;
      for (let vn = 0; vn < Me; vn++) {
        Ve = fn, je.push(Ve);
        for (let En = 1; En < Ue; En++)
          Ve = Ve.add(fn), je.push(Ve);
        fn = Ve.double();
      }
      return je;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(Pe, Te, Me) {
      const { windows: Ue, windowSize: je } = Be(Pe);
      let fn = Ae.ZERO, Ve = Ae.BASE;
      const vn = BigInt(2 ** Pe - 1), En = 2 ** Pe, fi = BigInt(Pe);
      for (let bi = 0; bi < Ue; bi++) {
        const mi = bi * je;
        let _i = Number(Me & vn);
        Me >>= fi, _i > je && (_i -= En, Me += _1n$f);
        const Ei = mi, Si = mi + Math.abs(_i) - 1, Mi = bi % 2 !== 0, Oi = _i < 0;
        _i === 0 ? Ve = Ve.add(Ie(Mi, Te[Ei])) : fn = fn.add(Ie(Oi, Te[Si]));
      }
      return { p: fn, f: Ve };
    },
    wNAFCached(Pe, Te, Me, Ue) {
      const je = Pe._WINDOW_SIZE || 1;
      let fn = Te.get(Pe);
      return fn || (fn = this.precomputeWindow(Pe, je), je !== 1 && Te.set(Pe, Ue(fn))), this.wNAF(je, fn, Me);
    }
  };
}
function validateBasic$2(Ae) {
  return validateField$2(Ae.Fp), validateObject$5(Ae, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...nLength$2(Ae.n, Ae.nBitLength),
    ...Ae,
    p: Ae.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts$2(Ae) {
  const t = validateBasic$2(Ae);
  validateObject$5(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: Ie, Fp: Be, a: Pe } = t;
  if (Ie) {
    if (!Be.eql(Pe, Be.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof Ie != "object" || typeof Ie.beta != "bigint" || typeof Ie.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: b2n$2, hexToBytes: h2b$2 } = ut$5, DER$2 = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(t = "") {
      super(t);
    }
  },
  _parseInt(Ae) {
    const { Err: t } = DER$2;
    if (Ae.length < 2 || Ae[0] !== 2)
      throw new t("Invalid signature integer tag");
    const Ie = Ae[1], Be = Ae.subarray(2, Ie + 2);
    if (!Ie || Be.length !== Ie)
      throw new t("Invalid signature integer: wrong length");
    if (Be[0] & 128)
      throw new t("Invalid signature integer: negative");
    if (Be[0] === 0 && !(Be[1] & 128))
      throw new t("Invalid signature integer: unnecessary leading zero");
    return { d: b2n$2(Be), l: Ae.subarray(Ie + 2) };
  },
  toSig(Ae) {
    const { Err: t } = DER$2, Ie = typeof Ae == "string" ? h2b$2(Ae) : Ae;
    abytes$1(Ie);
    let Be = Ie.length;
    if (Be < 2 || Ie[0] != 48)
      throw new t("Invalid signature tag");
    if (Ie[1] !== Be - 2)
      throw new t("Invalid signature: incorrect length");
    const { d: Pe, l: Te } = DER$2._parseInt(Ie.subarray(2)), { d: Me, l: Ue } = DER$2._parseInt(Te);
    if (Ue.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: Pe, s: Me };
  },
  hexFromSig(Ae) {
    const t = (fn) => Number.parseInt(fn[0], 16) & 8 ? "00" + fn : fn, Ie = (fn) => {
      const Ve = fn.toString(16);
      return Ve.length & 1 ? `0${Ve}` : Ve;
    }, Be = t(Ie(Ae.s)), Pe = t(Ie(Ae.r)), Te = Be.length / 2, Me = Pe.length / 2, Ue = Ie(Te), je = Ie(Me);
    return `30${Ie(Me + Te + 4)}02${je}${Pe}02${Ue}${Be}`;
  }
}, _0n$b = BigInt(0), _1n$e = BigInt(1);
BigInt(2);
const _3n$4 = BigInt(3);
BigInt(4);
function weierstrassPoints$2(Ae) {
  const t = validatePointOpts$2(Ae), { Fp: Ie } = t, Be = t.toBytes || ((bi, mi, _i) => {
    const Ei = mi.toAffine();
    return concatBytes$5(Uint8Array.from([4]), Ie.toBytes(Ei.x), Ie.toBytes(Ei.y));
  }), Pe = t.fromBytes || ((bi) => {
    const mi = bi.subarray(1), _i = Ie.fromBytes(mi.subarray(0, Ie.BYTES)), Ei = Ie.fromBytes(mi.subarray(Ie.BYTES, 2 * Ie.BYTES));
    return { x: _i, y: Ei };
  });
  function Te(bi) {
    const { a: mi, b: _i } = t, Ei = Ie.sqr(bi), Si = Ie.mul(Ei, bi);
    return Ie.add(Ie.add(Si, Ie.mul(bi, mi)), _i);
  }
  if (!Ie.eql(Ie.sqr(t.Gy), Te(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function Me(bi) {
    return typeof bi == "bigint" && _0n$b < bi && bi < t.n;
  }
  function Ue(bi) {
    if (!Me(bi))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function je(bi) {
    const { allowedPrivateKeyLengths: mi, nByteLength: _i, wrapPrivateKey: Ei, n: Si } = t;
    if (mi && typeof bi != "bigint") {
      if (isBytes$3(bi) && (bi = bytesToHex$4(bi)), typeof bi != "string" || !mi.includes(bi.length))
        throw new Error("Invalid key");
      bi = bi.padStart(_i * 2, "0");
    }
    let Mi;
    try {
      Mi = typeof bi == "bigint" ? bi : bytesToNumberBE$2(ensureBytes$2("private key", bi, _i));
    } catch {
      throw new Error(`private key must be ${_i} bytes, hex or bigint, not ${typeof bi}`);
    }
    return Ei && (Mi = mod$2(Mi, Si)), Ue(Mi), Mi;
  }
  const fn = /* @__PURE__ */ new Map();
  function Ve(bi) {
    if (!(bi instanceof vn))
      throw new Error("ProjectivePoint expected");
  }
  class vn {
    constructor(mi, _i, Ei) {
      if (this.px = mi, this.py = _i, this.pz = Ei, mi == null || !Ie.isValid(mi))
        throw new Error("x required");
      if (_i == null || !Ie.isValid(_i))
        throw new Error("y required");
      if (Ei == null || !Ie.isValid(Ei))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(mi) {
      const { x: _i, y: Ei } = mi || {};
      if (!mi || !Ie.isValid(_i) || !Ie.isValid(Ei))
        throw new Error("invalid affine point");
      if (mi instanceof vn)
        throw new Error("projective point not allowed");
      const Si = (Mi) => Ie.eql(Mi, Ie.ZERO);
      return Si(_i) && Si(Ei) ? vn.ZERO : new vn(_i, Ei, Ie.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(mi) {
      const _i = Ie.invertBatch(mi.map((Ei) => Ei.pz));
      return mi.map((Ei, Si) => Ei.toAffine(_i[Si])).map(vn.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(mi) {
      const _i = vn.fromAffine(Pe(ensureBytes$2("pointHex", mi)));
      return _i.assertValidity(), _i;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(mi) {
      return vn.BASE.multiply(je(mi));
    }
    // "Private method", don't use it directly
    _setWindowSize(mi) {
      this._WINDOW_SIZE = mi, fn.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint && !Ie.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: mi, y: _i } = this.toAffine();
      if (!Ie.isValid(mi) || !Ie.isValid(_i))
        throw new Error("bad point: x or y not FE");
      const Ei = Ie.sqr(_i), Si = Te(mi);
      if (!Ie.eql(Ei, Si))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: mi } = this.toAffine();
      if (Ie.isOdd)
        return !Ie.isOdd(mi);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(mi) {
      Ve(mi);
      const { px: _i, py: Ei, pz: Si } = this, { px: Mi, py: Oi, pz: Fi } = mi, Ui = Ie.eql(Ie.mul(_i, Fi), Ie.mul(Mi, Si)), Pi = Ie.eql(Ie.mul(Ei, Fi), Ie.mul(Oi, Si));
      return Ui && Pi;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new vn(this.px, Ie.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: mi, b: _i } = t, Ei = Ie.mul(_i, _3n$4), { px: Si, py: Mi, pz: Oi } = this;
      let Fi = Ie.ZERO, Ui = Ie.ZERO, Pi = Ie.ZERO, Bi = Ie.mul(Si, Si), ji = Ie.mul(Mi, Mi), Zi = Ie.mul(Oi, Oi), zi = Ie.mul(Si, Mi);
      return zi = Ie.add(zi, zi), Pi = Ie.mul(Si, Oi), Pi = Ie.add(Pi, Pi), Fi = Ie.mul(mi, Pi), Ui = Ie.mul(Ei, Zi), Ui = Ie.add(Fi, Ui), Fi = Ie.sub(ji, Ui), Ui = Ie.add(ji, Ui), Ui = Ie.mul(Fi, Ui), Fi = Ie.mul(zi, Fi), Pi = Ie.mul(Ei, Pi), Zi = Ie.mul(mi, Zi), zi = Ie.sub(Bi, Zi), zi = Ie.mul(mi, zi), zi = Ie.add(zi, Pi), Pi = Ie.add(Bi, Bi), Bi = Ie.add(Pi, Bi), Bi = Ie.add(Bi, Zi), Bi = Ie.mul(Bi, zi), Ui = Ie.add(Ui, Bi), Zi = Ie.mul(Mi, Oi), Zi = Ie.add(Zi, Zi), Bi = Ie.mul(Zi, zi), Fi = Ie.sub(Fi, Bi), Pi = Ie.mul(Zi, ji), Pi = Ie.add(Pi, Pi), Pi = Ie.add(Pi, Pi), new vn(Fi, Ui, Pi);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(mi) {
      Ve(mi);
      const { px: _i, py: Ei, pz: Si } = this, { px: Mi, py: Oi, pz: Fi } = mi;
      let Ui = Ie.ZERO, Pi = Ie.ZERO, Bi = Ie.ZERO;
      const ji = t.a, Zi = Ie.mul(t.b, _3n$4);
      let zi = Ie.mul(_i, Mi), xi = Ie.mul(Ei, Oi), $i = Ie.mul(Si, Fi), vi = Ie.add(_i, Ei), wi = Ie.add(Mi, Oi);
      vi = Ie.mul(vi, wi), wi = Ie.add(zi, xi), vi = Ie.sub(vi, wi), wi = Ie.add(_i, Si);
      let Ai = Ie.add(Mi, Fi);
      return wi = Ie.mul(wi, Ai), Ai = Ie.add(zi, $i), wi = Ie.sub(wi, Ai), Ai = Ie.add(Ei, Si), Ui = Ie.add(Oi, Fi), Ai = Ie.mul(Ai, Ui), Ui = Ie.add(xi, $i), Ai = Ie.sub(Ai, Ui), Bi = Ie.mul(ji, wi), Ui = Ie.mul(Zi, $i), Bi = Ie.add(Ui, Bi), Ui = Ie.sub(xi, Bi), Bi = Ie.add(xi, Bi), Pi = Ie.mul(Ui, Bi), xi = Ie.add(zi, zi), xi = Ie.add(xi, zi), $i = Ie.mul(ji, $i), wi = Ie.mul(Zi, wi), xi = Ie.add(xi, $i), $i = Ie.sub(zi, $i), $i = Ie.mul(ji, $i), wi = Ie.add(wi, $i), zi = Ie.mul(xi, wi), Pi = Ie.add(Pi, zi), zi = Ie.mul(Ai, wi), Ui = Ie.mul(vi, Ui), Ui = Ie.sub(Ui, zi), zi = Ie.mul(vi, xi), Bi = Ie.mul(Ai, Bi), Bi = Ie.add(Bi, zi), new vn(Ui, Pi, Bi);
    }
    subtract(mi) {
      return this.add(mi.negate());
    }
    is0() {
      return this.equals(vn.ZERO);
    }
    wNAF(mi) {
      return fi.wNAFCached(this, fn, mi, (_i) => {
        const Ei = Ie.invertBatch(_i.map((Si) => Si.pz));
        return _i.map((Si, Mi) => Si.toAffine(Ei[Mi])).map(vn.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(mi) {
      const _i = vn.ZERO;
      if (mi === _0n$b)
        return _i;
      if (Ue(mi), mi === _1n$e)
        return this;
      const { endo: Ei } = t;
      if (!Ei)
        return fi.unsafeLadder(this, mi);
      let { k1neg: Si, k1: Mi, k2neg: Oi, k2: Fi } = Ei.splitScalar(mi), Ui = _i, Pi = _i, Bi = this;
      for (; Mi > _0n$b || Fi > _0n$b; )
        Mi & _1n$e && (Ui = Ui.add(Bi)), Fi & _1n$e && (Pi = Pi.add(Bi)), Bi = Bi.double(), Mi >>= _1n$e, Fi >>= _1n$e;
      return Si && (Ui = Ui.negate()), Oi && (Pi = Pi.negate()), Pi = new vn(Ie.mul(Pi.px, Ei.beta), Pi.py, Pi.pz), Ui.add(Pi);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(mi) {
      Ue(mi);
      let _i = mi, Ei, Si;
      const { endo: Mi } = t;
      if (Mi) {
        const { k1neg: Oi, k1: Fi, k2neg: Ui, k2: Pi } = Mi.splitScalar(_i);
        let { p: Bi, f: ji } = this.wNAF(Fi), { p: Zi, f: zi } = this.wNAF(Pi);
        Bi = fi.constTimeNegate(Oi, Bi), Zi = fi.constTimeNegate(Ui, Zi), Zi = new vn(Ie.mul(Zi.px, Mi.beta), Zi.py, Zi.pz), Ei = Bi.add(Zi), Si = ji.add(zi);
      } else {
        const { p: Oi, f: Fi } = this.wNAF(_i);
        Ei = Oi, Si = Fi;
      }
      return vn.normalizeZ([Ei, Si])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(mi, _i, Ei) {
      const Si = vn.BASE, Mi = (Fi, Ui) => Ui === _0n$b || Ui === _1n$e || !Fi.equals(Si) ? Fi.multiplyUnsafe(Ui) : Fi.multiply(Ui), Oi = Mi(this, _i).add(Mi(mi, Ei));
      return Oi.is0() ? void 0 : Oi;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(mi) {
      const { px: _i, py: Ei, pz: Si } = this, Mi = this.is0();
      mi == null && (mi = Mi ? Ie.ONE : Ie.inv(Si));
      const Oi = Ie.mul(_i, mi), Fi = Ie.mul(Ei, mi), Ui = Ie.mul(Si, mi);
      if (Mi)
        return { x: Ie.ZERO, y: Ie.ZERO };
      if (!Ie.eql(Ui, Ie.ONE))
        throw new Error("invZ was invalid");
      return { x: Oi, y: Fi };
    }
    isTorsionFree() {
      const { h: mi, isTorsionFree: _i } = t;
      if (mi === _1n$e)
        return !0;
      if (_i)
        return _i(vn, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: mi, clearCofactor: _i } = t;
      return mi === _1n$e ? this : _i ? _i(vn, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(mi = !0) {
      return this.assertValidity(), Be(vn, this, mi);
    }
    toHex(mi = !0) {
      return bytesToHex$4(this.toRawBytes(mi));
    }
  }
  vn.BASE = new vn(t.Gx, t.Gy, Ie.ONE), vn.ZERO = new vn(Ie.ZERO, Ie.ONE, Ie.ZERO);
  const En = t.nBitLength, fi = wNAF$2(vn, t.endo ? Math.ceil(En / 2) : En);
  return {
    CURVE: t,
    ProjectivePoint: vn,
    normPrivateKeyToScalar: je,
    weierstrassEquation: Te,
    isWithinCurveOrder: Me
  };
}
function validateOpts$2(Ae) {
  const t = validateBasic$2(Ae);
  return validateObject$5(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function weierstrass$2(Ae) {
  const t = validateOpts$2(Ae), { Fp: Ie, n: Be } = t, Pe = Ie.BYTES + 1, Te = 2 * Ie.BYTES + 1;
  function Me(wi) {
    return _0n$b < wi && wi < Ie.ORDER;
  }
  function Ue(wi) {
    return mod$2(wi, Be);
  }
  function je(wi) {
    return invert$2(wi, Be);
  }
  const { ProjectivePoint: fn, normPrivateKeyToScalar: Ve, weierstrassEquation: vn, isWithinCurveOrder: En } = weierstrassPoints$2({
    ...t,
    toBytes(wi, Ai, Ri) {
      const Ti = Ai.toAffine(), Ci = Ie.toBytes(Ti.x), Ii = concatBytes$5;
      return Ri ? Ii(Uint8Array.from([Ai.hasEvenY() ? 2 : 3]), Ci) : Ii(Uint8Array.from([4]), Ci, Ie.toBytes(Ti.y));
    },
    fromBytes(wi) {
      const Ai = wi.length, Ri = wi[0], Ti = wi.subarray(1);
      if (Ai === Pe && (Ri === 2 || Ri === 3)) {
        const Ci = bytesToNumberBE$2(Ti);
        if (!Me(Ci))
          throw new Error("Point is not on curve");
        const Ii = vn(Ci);
        let Li;
        try {
          Li = Ie.sqrt(Ii);
        } catch (is) {
          const Ki = is instanceof Error ? ": " + is.message : "";
          throw new Error("Point is not on curve" + Ki);
        }
        const Ni = (Li & _1n$e) === _1n$e;
        return (Ri & 1) === 1 !== Ni && (Li = Ie.neg(Li)), { x: Ci, y: Li };
      } else if (Ai === Te && Ri === 4) {
        const Ci = Ie.fromBytes(Ti.subarray(0, Ie.BYTES)), Ii = Ie.fromBytes(Ti.subarray(Ie.BYTES, 2 * Ie.BYTES));
        return { x: Ci, y: Ii };
      } else
        throw new Error(`Point of length ${Ai} was invalid. Expected ${Pe} compressed bytes or ${Te} uncompressed bytes`);
    }
  }), fi = (wi) => bytesToHex$4(numberToBytesBE$2(wi, t.nByteLength));
  function bi(wi) {
    const Ai = Be >> _1n$e;
    return wi > Ai;
  }
  function mi(wi) {
    return bi(wi) ? Ue(-wi) : wi;
  }
  const _i = (wi, Ai, Ri) => bytesToNumberBE$2(wi.slice(Ai, Ri));
  class Ei {
    constructor(Ai, Ri, Ti) {
      this.r = Ai, this.s = Ri, this.recovery = Ti, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(Ai) {
      const Ri = t.nByteLength;
      return Ai = ensureBytes$2("compactSignature", Ai, Ri * 2), new Ei(_i(Ai, 0, Ri), _i(Ai, Ri, 2 * Ri));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(Ai) {
      const { r: Ri, s: Ti } = DER$2.toSig(ensureBytes$2("DER", Ai));
      return new Ei(Ri, Ti);
    }
    assertValidity() {
      if (!En(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!En(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(Ai) {
      return new Ei(this.r, this.s, Ai);
    }
    recoverPublicKey(Ai) {
      const { r: Ri, s: Ti, recovery: Ci } = this, Ii = Pi(ensureBytes$2("msgHash", Ai));
      if (Ci == null || ![0, 1, 2, 3].includes(Ci))
        throw new Error("recovery id invalid");
      const Li = Ci === 2 || Ci === 3 ? Ri + t.n : Ri;
      if (Li >= Ie.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const Ni = Ci & 1 ? "03" : "02", Vi = fn.fromHex(Ni + fi(Li)), is = je(Li), Ki = Ue(-Ii * is), ts = Ue(Ti * is), qi = fn.BASE.multiplyAndAddUnsafe(Vi, Ki, ts);
      if (!qi)
        throw new Error("point at infinify");
      return qi.assertValidity(), qi;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return bi(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Ei(this.r, Ue(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes$4(this.toDERHex());
    }
    toDERHex() {
      return DER$2.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes$4(this.toCompactHex());
    }
    toCompactHex() {
      return fi(this.r) + fi(this.s);
    }
  }
  const Si = {
    isValidPrivateKey(wi) {
      try {
        return Ve(wi), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: Ve,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const wi = getMinHashLength$2(t.n);
      return mapHashToField$2(t.randomBytes(wi), t.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(wi = 8, Ai = fn.BASE) {
      return Ai._setWindowSize(wi), Ai.multiply(BigInt(3)), Ai;
    }
  };
  function Mi(wi, Ai = !0) {
    return fn.fromPrivateKey(wi).toRawBytes(Ai);
  }
  function Oi(wi) {
    const Ai = isBytes$3(wi), Ri = typeof wi == "string", Ti = (Ai || Ri) && wi.length;
    return Ai ? Ti === Pe || Ti === Te : Ri ? Ti === 2 * Pe || Ti === 2 * Te : wi instanceof fn;
  }
  function Fi(wi, Ai, Ri = !0) {
    if (Oi(wi))
      throw new Error("first arg must be private key");
    if (!Oi(Ai))
      throw new Error("second arg must be public key");
    return fn.fromHex(Ai).multiply(Ve(wi)).toRawBytes(Ri);
  }
  const Ui = t.bits2int || function(wi) {
    const Ai = bytesToNumberBE$2(wi), Ri = wi.length * 8 - t.nBitLength;
    return Ri > 0 ? Ai >> BigInt(Ri) : Ai;
  }, Pi = t.bits2int_modN || function(wi) {
    return Ue(Ui(wi));
  }, Bi = bitMask$2(t.nBitLength);
  function ji(wi) {
    if (typeof wi != "bigint")
      throw new Error("bigint expected");
    if (!(_0n$b <= wi && wi < Bi))
      throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return numberToBytesBE$2(wi, t.nByteLength);
  }
  function Zi(wi, Ai, Ri = zi) {
    if (["recovered", "canonical"].some((Xi) => Xi in Ri))
      throw new Error("sign() legacy options not supported");
    const { hash: Ti, randomBytes: Ci } = t;
    let { lowS: Ii, prehash: Li, extraEntropy: Ni } = Ri;
    Ii == null && (Ii = !0), wi = ensureBytes$2("msgHash", wi), Li && (wi = ensureBytes$2("prehashed msgHash", Ti(wi)));
    const Vi = Pi(wi), is = Ve(Ai), Ki = [ji(is), ji(Vi)];
    if (Ni != null && Ni !== !1) {
      const Xi = Ni === !0 ? Ci(Ie.BYTES) : Ni;
      Ki.push(ensureBytes$2("extraEntropy", Xi));
    }
    const ts = concatBytes$5(...Ki), qi = Vi;
    function Hi(Xi) {
      const ki = Ui(Xi);
      if (!En(ki))
        return;
      const Wi = je(ki), Yi = fn.BASE.multiply(ki).toAffine(), Qi = Ue(Yi.x);
      if (Qi === _0n$b)
        return;
      const ns = Ue(Wi * Ue(qi + Qi * is));
      if (ns === _0n$b)
        return;
      let us = (Yi.x === Qi ? 0 : 2) | Number(Yi.y & _1n$e), ps = ns;
      return Ii && bi(ns) && (ps = mi(ns), us ^= 1), new Ei(Qi, ps, us);
    }
    return { seed: ts, k2sig: Hi };
  }
  const zi = { lowS: t.lowS, prehash: !1 }, xi = { lowS: t.lowS, prehash: !1 };
  function $i(wi, Ai, Ri = zi) {
    const { seed: Ti, k2sig: Ci } = Zi(wi, Ai, Ri), Ii = t;
    return createHmacDrbg$2(Ii.hash.outputLen, Ii.nByteLength, Ii.hmac)(Ti, Ci);
  }
  fn.BASE._setWindowSize(8);
  function vi(wi, Ai, Ri, Ti = xi) {
    var Yi;
    const Ci = wi;
    if (Ai = ensureBytes$2("msgHash", Ai), Ri = ensureBytes$2("publicKey", Ri), "strict" in Ti)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: Ii, prehash: Li } = Ti;
    let Ni, Vi;
    try {
      if (typeof Ci == "string" || isBytes$3(Ci))
        try {
          Ni = Ei.fromDER(Ci);
        } catch (Qi) {
          if (!(Qi instanceof DER$2.Err))
            throw Qi;
          Ni = Ei.fromCompact(Ci);
        }
      else if (typeof Ci == "object" && typeof Ci.r == "bigint" && typeof Ci.s == "bigint") {
        const { r: Qi, s: ns } = Ci;
        Ni = new Ei(Qi, ns);
      } else
        throw new Error("PARSE");
      Vi = fn.fromHex(Ri);
    } catch (Qi) {
      if (Qi.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (Ii && Ni.hasHighS())
      return !1;
    Li && (Ai = t.hash(Ai));
    const { r: is, s: Ki } = Ni, ts = Pi(Ai), qi = je(Ki), Hi = Ue(ts * qi), Xi = Ue(is * qi), ki = (Yi = fn.BASE.multiplyAndAddUnsafe(Vi, Hi, Xi)) == null ? void 0 : Yi.toAffine();
    return ki ? Ue(ki.x) === is : !1;
  }
  return {
    CURVE: t,
    getPublicKey: Mi,
    getSharedSecret: Fi,
    sign: $i,
    verify: vi,
    ProjectivePoint: fn,
    Signature: Ei,
    utils: Si
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash$2(Ae) {
  return {
    hash: Ae,
    hmac: (t, ...Ie) => hmac$5(Ae, t, concatBytes$6(...Ie)),
    randomBytes: randomBytes$2
  };
}
function createCurve$2(Ae, t) {
  const Ie = (Be) => weierstrass$2({ ...Ae, ...getHash$2(Be) });
  return Object.freeze({ ...Ie(t), create: Ie });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P$2 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), secp256k1N$2 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), _1n$d = BigInt(1), _2n$9 = BigInt(2), divNearest$2 = (Ae, t) => (Ae + t / _2n$9) / t;
function sqrtMod$2(Ae) {
  const t = secp256k1P$2, Ie = BigInt(3), Be = BigInt(6), Pe = BigInt(11), Te = BigInt(22), Me = BigInt(23), Ue = BigInt(44), je = BigInt(88), fn = Ae * Ae * Ae % t, Ve = fn * fn * Ae % t, vn = pow2$2(Ve, Ie, t) * Ve % t, En = pow2$2(vn, Ie, t) * Ve % t, fi = pow2$2(En, _2n$9, t) * fn % t, bi = pow2$2(fi, Pe, t) * fi % t, mi = pow2$2(bi, Te, t) * bi % t, _i = pow2$2(mi, Ue, t) * mi % t, Ei = pow2$2(_i, je, t) * _i % t, Si = pow2$2(Ei, Ue, t) * mi % t, Mi = pow2$2(Si, Ie, t) * Ve % t, Oi = pow2$2(Mi, Me, t) * bi % t, Fi = pow2$2(Oi, Be, t) * fn % t, Ui = pow2$2(Fi, _2n$9, t);
  if (!Fp$2.eql(Fp$2.sqr(Ui), Ae))
    throw new Error("Cannot find square root");
  return Ui;
}
const Fp$2 = Field$2(secp256k1P$2, void 0, void 0, { sqrt: sqrtMod$2 }), secp256k1$5 = createCurve$2({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: Fp$2,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N$2,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: !0,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (Ae) => {
      const t = secp256k1N$2, Ie = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), Be = -_1n$d * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), Pe = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), Te = Ie, Me = BigInt("0x100000000000000000000000000000000"), Ue = divNearest$2(Te * Ae, t), je = divNearest$2(-Be * Ae, t);
      let fn = mod$2(Ae - Ue * Ie - je * Pe, t), Ve = mod$2(-Ue * Be - je * Te, t);
      const vn = fn > Me, En = Ve > Me;
      if (vn && (fn = t - fn), En && (Ve = t - Ve), fn > Me || Ve > Me)
        throw new Error("splitScalar: Endomorphism failed, k=" + Ae);
      return { k1neg: vn, k1: fn, k2neg: En, k2: Ve };
    }
  }
}, sha256$7);
BigInt(0);
secp256k1$5.ProjectivePoint;
var hash$6 = {}, utils$e = {}, minimalisticAssert$1 = assert$d;
function assert$d(Ae, t) {
  if (!Ae)
    throw new Error(t || "Assertion failed");
}
assert$d.equal = function(t, Ie, Be) {
  if (t != Ie)
    throw new Error(Be || "Assertion failed: " + t + " != " + Ie);
};
var inherits_browser$1 = { exports: {} }, hasRequiredInherits_browser;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser$1.exports = function(t, Ie) {
    Ie && (t.super_ = Ie, t.prototype = Object.create(Ie.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : inherits_browser$1.exports = function(t, Ie) {
    if (Ie) {
      t.super_ = Ie;
      var Be = function() {
      };
      Be.prototype = Ie.prototype, t.prototype = new Be(), t.prototype.constructor = t;
    }
  }), inherits_browser$1.exports;
}
var assert$c = minimalisticAssert$1, inherits = requireInherits_browser();
utils$e.inherits = inherits;
function isSurrogatePair(Ae, t) {
  return (Ae.charCodeAt(t) & 64512) !== 55296 || t < 0 || t + 1 >= Ae.length ? !1 : (Ae.charCodeAt(t + 1) & 64512) === 56320;
}
function toArray$2(Ae, t) {
  if (Array.isArray(Ae))
    return Ae.slice();
  if (!Ae)
    return [];
  var Ie = [];
  if (typeof Ae == "string")
    if (t) {
      if (t === "hex")
        for (Ae = Ae.replace(/[^a-z0-9]+/ig, ""), Ae.length % 2 !== 0 && (Ae = "0" + Ae), Pe = 0; Pe < Ae.length; Pe += 2)
          Ie.push(parseInt(Ae[Pe] + Ae[Pe + 1], 16));
    } else for (var Be = 0, Pe = 0; Pe < Ae.length; Pe++) {
      var Te = Ae.charCodeAt(Pe);
      Te < 128 ? Ie[Be++] = Te : Te < 2048 ? (Ie[Be++] = Te >> 6 | 192, Ie[Be++] = Te & 63 | 128) : isSurrogatePair(Ae, Pe) ? (Te = 65536 + ((Te & 1023) << 10) + (Ae.charCodeAt(++Pe) & 1023), Ie[Be++] = Te >> 18 | 240, Ie[Be++] = Te >> 12 & 63 | 128, Ie[Be++] = Te >> 6 & 63 | 128, Ie[Be++] = Te & 63 | 128) : (Ie[Be++] = Te >> 12 | 224, Ie[Be++] = Te >> 6 & 63 | 128, Ie[Be++] = Te & 63 | 128);
    }
  else
    for (Pe = 0; Pe < Ae.length; Pe++)
      Ie[Pe] = Ae[Pe] | 0;
  return Ie;
}
utils$e.toArray = toArray$2;
function toHex$1(Ae) {
  for (var t = "", Ie = 0; Ie < Ae.length; Ie++)
    t += zero2(Ae[Ie].toString(16));
  return t;
}
utils$e.toHex = toHex$1;
function htonl(Ae) {
  var t = Ae >>> 24 | Ae >>> 8 & 65280 | Ae << 8 & 16711680 | (Ae & 255) << 24;
  return t >>> 0;
}
utils$e.htonl = htonl;
function toHex32(Ae, t) {
  for (var Ie = "", Be = 0; Be < Ae.length; Be++) {
    var Pe = Ae[Be];
    t === "little" && (Pe = htonl(Pe)), Ie += zero8(Pe.toString(16));
  }
  return Ie;
}
utils$e.toHex32 = toHex32;
function zero2(Ae) {
  return Ae.length === 1 ? "0" + Ae : Ae;
}
utils$e.zero2 = zero2;
function zero8(Ae) {
  return Ae.length === 7 ? "0" + Ae : Ae.length === 6 ? "00" + Ae : Ae.length === 5 ? "000" + Ae : Ae.length === 4 ? "0000" + Ae : Ae.length === 3 ? "00000" + Ae : Ae.length === 2 ? "000000" + Ae : Ae.length === 1 ? "0000000" + Ae : Ae;
}
utils$e.zero8 = zero8;
function join32(Ae, t, Ie, Be) {
  var Pe = Ie - t;
  assert$c(Pe % 4 === 0);
  for (var Te = new Array(Pe / 4), Me = 0, Ue = t; Me < Te.length; Me++, Ue += 4) {
    var je;
    Be === "big" ? je = Ae[Ue] << 24 | Ae[Ue + 1] << 16 | Ae[Ue + 2] << 8 | Ae[Ue + 3] : je = Ae[Ue + 3] << 24 | Ae[Ue + 2] << 16 | Ae[Ue + 1] << 8 | Ae[Ue], Te[Me] = je >>> 0;
  }
  return Te;
}
utils$e.join32 = join32;
function split32(Ae, t) {
  for (var Ie = new Array(Ae.length * 4), Be = 0, Pe = 0; Be < Ae.length; Be++, Pe += 4) {
    var Te = Ae[Be];
    t === "big" ? (Ie[Pe] = Te >>> 24, Ie[Pe + 1] = Te >>> 16 & 255, Ie[Pe + 2] = Te >>> 8 & 255, Ie[Pe + 3] = Te & 255) : (Ie[Pe + 3] = Te >>> 24, Ie[Pe + 2] = Te >>> 16 & 255, Ie[Pe + 1] = Te >>> 8 & 255, Ie[Pe] = Te & 255);
  }
  return Ie;
}
utils$e.split32 = split32;
function rotr32$1(Ae, t) {
  return Ae >>> t | Ae << 32 - t;
}
utils$e.rotr32 = rotr32$1;
function rotl32$2(Ae, t) {
  return Ae << t | Ae >>> 32 - t;
}
utils$e.rotl32 = rotl32$2;
function sum32$3(Ae, t) {
  return Ae + t >>> 0;
}
utils$e.sum32 = sum32$3;
function sum32_3$1(Ae, t, Ie) {
  return Ae + t + Ie >>> 0;
}
utils$e.sum32_3 = sum32_3$1;
function sum32_4$2(Ae, t, Ie, Be) {
  return Ae + t + Ie + Be >>> 0;
}
utils$e.sum32_4 = sum32_4$2;
function sum32_5$2(Ae, t, Ie, Be, Pe) {
  return Ae + t + Ie + Be + Pe >>> 0;
}
utils$e.sum32_5 = sum32_5$2;
function sum64$1(Ae, t, Ie, Be) {
  var Pe = Ae[t], Te = Ae[t + 1], Me = Be + Te >>> 0, Ue = (Me < Be ? 1 : 0) + Ie + Pe;
  Ae[t] = Ue >>> 0, Ae[t + 1] = Me;
}
utils$e.sum64 = sum64$1;
function sum64_hi$1(Ae, t, Ie, Be) {
  var Pe = t + Be >>> 0, Te = (Pe < t ? 1 : 0) + Ae + Ie;
  return Te >>> 0;
}
utils$e.sum64_hi = sum64_hi$1;
function sum64_lo$1(Ae, t, Ie, Be) {
  var Pe = t + Be;
  return Pe >>> 0;
}
utils$e.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(Ae, t, Ie, Be, Pe, Te, Me, Ue) {
  var je = 0, fn = t;
  fn = fn + Be >>> 0, je += fn < t ? 1 : 0, fn = fn + Te >>> 0, je += fn < Te ? 1 : 0, fn = fn + Ue >>> 0, je += fn < Ue ? 1 : 0;
  var Ve = Ae + Ie + Pe + Me + je;
  return Ve >>> 0;
}
utils$e.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(Ae, t, Ie, Be, Pe, Te, Me, Ue) {
  var je = t + Be + Te + Ue;
  return je >>> 0;
}
utils$e.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(Ae, t, Ie, Be, Pe, Te, Me, Ue, je, fn) {
  var Ve = 0, vn = t;
  vn = vn + Be >>> 0, Ve += vn < t ? 1 : 0, vn = vn + Te >>> 0, Ve += vn < Te ? 1 : 0, vn = vn + Ue >>> 0, Ve += vn < Ue ? 1 : 0, vn = vn + fn >>> 0, Ve += vn < fn ? 1 : 0;
  var En = Ae + Ie + Pe + Me + je + Ve;
  return En >>> 0;
}
utils$e.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(Ae, t, Ie, Be, Pe, Te, Me, Ue, je, fn) {
  var Ve = t + Be + Te + Ue + fn;
  return Ve >>> 0;
}
utils$e.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(Ae, t, Ie) {
  var Be = t << 32 - Ie | Ae >>> Ie;
  return Be >>> 0;
}
utils$e.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(Ae, t, Ie) {
  var Be = Ae << 32 - Ie | t >>> Ie;
  return Be >>> 0;
}
utils$e.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(Ae, t, Ie) {
  return Ae >>> Ie;
}
utils$e.shr64_hi = shr64_hi$1;
function shr64_lo$1(Ae, t, Ie) {
  var Be = Ae << 32 - Ie | t >>> Ie;
  return Be >>> 0;
}
utils$e.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$d = utils$e, assert$b = minimalisticAssert$1;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function(t, Ie) {
  if (t = utils$d.toArray(t, Ie), this.pending ? this.pending = this.pending.concat(t) : this.pending = t, this.pendingTotal += t.length, this.pending.length >= this._delta8) {
    t = this.pending;
    var Be = t.length % this._delta8;
    this.pending = t.slice(t.length - Be, t.length), this.pending.length === 0 && (this.pending = null), t = utils$d.join32(t, 0, t.length - Be, this.endian);
    for (var Pe = 0; Pe < t.length; Pe += this._delta32)
      this._update(t, Pe, Pe + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function(t) {
  return this.update(this._pad()), assert$b(this.pending === null), this._digest(t);
};
BlockHash$4.prototype._pad = function() {
  var t = this.pendingTotal, Ie = this._delta8, Be = Ie - (t + this.padLength) % Ie, Pe = new Array(Be + this.padLength);
  Pe[0] = 128;
  for (var Te = 1; Te < Be; Te++)
    Pe[Te] = 0;
  if (t <<= 3, this.endian === "big") {
    for (var Me = 8; Me < this.padLength; Me++)
      Pe[Te++] = 0;
    Pe[Te++] = 0, Pe[Te++] = 0, Pe[Te++] = 0, Pe[Te++] = 0, Pe[Te++] = t >>> 24 & 255, Pe[Te++] = t >>> 16 & 255, Pe[Te++] = t >>> 8 & 255, Pe[Te++] = t & 255;
  } else
    for (Pe[Te++] = t & 255, Pe[Te++] = t >>> 8 & 255, Pe[Te++] = t >>> 16 & 255, Pe[Te++] = t >>> 24 & 255, Pe[Te++] = 0, Pe[Te++] = 0, Pe[Te++] = 0, Pe[Te++] = 0, Me = 8; Me < this.padLength; Me++)
      Pe[Te++] = 0;
  return Pe;
};
var sha$1 = {}, common$4 = {}, utils$c = utils$e, rotr32 = utils$c.rotr32;
function ft_1$1(Ae, t, Ie, Be) {
  if (Ae === 0)
    return ch32$1(t, Ie, Be);
  if (Ae === 1 || Ae === 3)
    return p32(t, Ie, Be);
  if (Ae === 2)
    return maj32$1(t, Ie, Be);
}
common$4.ft_1 = ft_1$1;
function ch32$1(Ae, t, Ie) {
  return Ae & t ^ ~Ae & Ie;
}
common$4.ch32 = ch32$1;
function maj32$1(Ae, t, Ie) {
  return Ae & t ^ Ae & Ie ^ t & Ie;
}
common$4.maj32 = maj32$1;
function p32(Ae, t, Ie) {
  return Ae ^ t ^ Ie;
}
common$4.p32 = p32;
function s0_256$1(Ae) {
  return rotr32(Ae, 2) ^ rotr32(Ae, 13) ^ rotr32(Ae, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(Ae) {
  return rotr32(Ae, 6) ^ rotr32(Ae, 11) ^ rotr32(Ae, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(Ae) {
  return rotr32(Ae, 7) ^ rotr32(Ae, 18) ^ Ae >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(Ae) {
  return rotr32(Ae, 17) ^ rotr32(Ae, 19) ^ Ae >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$b = utils$e, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$b.rotl32, sum32$2 = utils$b.sum32, sum32_5$1 = utils$b.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$b.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function(t, Ie) {
  for (var Be = this.W, Pe = 0; Pe < 16; Pe++)
    Be[Pe] = t[Ie + Pe];
  for (; Pe < Be.length; Pe++)
    Be[Pe] = rotl32$1(Be[Pe - 3] ^ Be[Pe - 8] ^ Be[Pe - 14] ^ Be[Pe - 16], 1);
  var Te = this.h[0], Me = this.h[1], Ue = this.h[2], je = this.h[3], fn = this.h[4];
  for (Pe = 0; Pe < Be.length; Pe++) {
    var Ve = ~~(Pe / 20), vn = sum32_5$1(rotl32$1(Te, 5), ft_1(Ve, Me, Ue, je), fn, Be[Pe], sha1_K[Ve]);
    fn = je, je = Ue, Ue = rotl32$1(Me, 30), Me = Te, Te = vn;
  }
  this.h[0] = sum32$2(this.h[0], Te), this.h[1] = sum32$2(this.h[1], Me), this.h[2] = sum32$2(this.h[2], Ue), this.h[3] = sum32$2(this.h[3], je), this.h[4] = sum32$2(this.h[4], fn);
};
SHA1.prototype._digest = function(t) {
  return t === "hex" ? utils$b.toHex32(this.h, "big") : utils$b.split32(this.h, "big");
};
var utils$a = utils$e, common$2 = common$5, shaCommon = common$4, assert$a = minimalisticAssert$1, sum32$1 = utils$a.sum32, sum32_4$1 = utils$a.sum32_4, sum32_5 = utils$a.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$3() {
  if (!(this instanceof SHA256$3))
    return new SHA256$3();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$a.inherits(SHA256$3, BlockHash$2);
var _256 = SHA256$3;
SHA256$3.blockSize = 512;
SHA256$3.outSize = 256;
SHA256$3.hmacStrength = 192;
SHA256$3.padLength = 64;
SHA256$3.prototype._update = function(t, Ie) {
  for (var Be = this.W, Pe = 0; Pe < 16; Pe++)
    Be[Pe] = t[Ie + Pe];
  for (; Pe < Be.length; Pe++)
    Be[Pe] = sum32_4$1(g1_256(Be[Pe - 2]), Be[Pe - 7], g0_256(Be[Pe - 15]), Be[Pe - 16]);
  var Te = this.h[0], Me = this.h[1], Ue = this.h[2], je = this.h[3], fn = this.h[4], Ve = this.h[5], vn = this.h[6], En = this.h[7];
  for (assert$a(this.k.length === Be.length), Pe = 0; Pe < Be.length; Pe++) {
    var fi = sum32_5(En, s1_256(fn), ch32(fn, Ve, vn), this.k[Pe], Be[Pe]), bi = sum32$1(s0_256(Te), maj32(Te, Me, Ue));
    En = vn, vn = Ve, Ve = fn, fn = sum32$1(je, fi), je = Ue, Ue = Me, Me = Te, Te = sum32$1(fi, bi);
  }
  this.h[0] = sum32$1(this.h[0], Te), this.h[1] = sum32$1(this.h[1], Me), this.h[2] = sum32$1(this.h[2], Ue), this.h[3] = sum32$1(this.h[3], je), this.h[4] = sum32$1(this.h[4], fn), this.h[5] = sum32$1(this.h[5], Ve), this.h[6] = sum32$1(this.h[6], vn), this.h[7] = sum32$1(this.h[7], En);
};
SHA256$3.prototype._digest = function(t) {
  return t === "hex" ? utils$a.toHex32(this.h, "big") : utils$a.split32(this.h, "big");
};
var utils$9 = utils$e, SHA256$2 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256$2.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$9.inherits(SHA224, SHA256$2);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function(t) {
  return t === "hex" ? utils$9.toHex32(this.h.slice(0, 7), "big") : utils$9.split32(this.h.slice(0, 7), "big");
};
var utils$8 = utils$e, common$1 = common$5, assert$9 = minimalisticAssert$1, rotr64_hi = utils$8.rotr64_hi, rotr64_lo = utils$8.rotr64_lo, shr64_hi = utils$8.shr64_hi, shr64_lo = utils$8.shr64_lo, sum64 = utils$8.sum64, sum64_hi = utils$8.sum64_hi, sum64_lo = utils$8.sum64_lo, sum64_4_hi = utils$8.sum64_4_hi, sum64_4_lo = utils$8.sum64_4_lo, sum64_5_hi = utils$8.sum64_5_hi, sum64_5_lo = utils$8.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$2() {
  if (!(this instanceof SHA512$2))
    return new SHA512$2();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$8.inherits(SHA512$2, BlockHash$1);
var _512 = SHA512$2;
SHA512$2.blockSize = 1024;
SHA512$2.outSize = 512;
SHA512$2.hmacStrength = 192;
SHA512$2.padLength = 128;
SHA512$2.prototype._prepareBlock = function(t, Ie) {
  for (var Be = this.W, Pe = 0; Pe < 32; Pe++)
    Be[Pe] = t[Ie + Pe];
  for (; Pe < Be.length; Pe += 2) {
    var Te = g1_512_hi(Be[Pe - 4], Be[Pe - 3]), Me = g1_512_lo(Be[Pe - 4], Be[Pe - 3]), Ue = Be[Pe - 14], je = Be[Pe - 13], fn = g0_512_hi(Be[Pe - 30], Be[Pe - 29]), Ve = g0_512_lo(Be[Pe - 30], Be[Pe - 29]), vn = Be[Pe - 32], En = Be[Pe - 31];
    Be[Pe] = sum64_4_hi(
      Te,
      Me,
      Ue,
      je,
      fn,
      Ve,
      vn,
      En
    ), Be[Pe + 1] = sum64_4_lo(
      Te,
      Me,
      Ue,
      je,
      fn,
      Ve,
      vn,
      En
    );
  }
};
SHA512$2.prototype._update = function(t, Ie) {
  this._prepareBlock(t, Ie);
  var Be = this.W, Pe = this.h[0], Te = this.h[1], Me = this.h[2], Ue = this.h[3], je = this.h[4], fn = this.h[5], Ve = this.h[6], vn = this.h[7], En = this.h[8], fi = this.h[9], bi = this.h[10], mi = this.h[11], _i = this.h[12], Ei = this.h[13], Si = this.h[14], Mi = this.h[15];
  assert$9(this.k.length === Be.length);
  for (var Oi = 0; Oi < Be.length; Oi += 2) {
    var Fi = Si, Ui = Mi, Pi = s1_512_hi(En, fi), Bi = s1_512_lo(En, fi), ji = ch64_hi(En, fi, bi, mi, _i), Zi = ch64_lo(En, fi, bi, mi, _i, Ei), zi = this.k[Oi], xi = this.k[Oi + 1], $i = Be[Oi], vi = Be[Oi + 1], wi = sum64_5_hi(
      Fi,
      Ui,
      Pi,
      Bi,
      ji,
      Zi,
      zi,
      xi,
      $i,
      vi
    ), Ai = sum64_5_lo(
      Fi,
      Ui,
      Pi,
      Bi,
      ji,
      Zi,
      zi,
      xi,
      $i,
      vi
    );
    Fi = s0_512_hi(Pe, Te), Ui = s0_512_lo(Pe, Te), Pi = maj64_hi(Pe, Te, Me, Ue, je), Bi = maj64_lo(Pe, Te, Me, Ue, je, fn);
    var Ri = sum64_hi(Fi, Ui, Pi, Bi), Ti = sum64_lo(Fi, Ui, Pi, Bi);
    Si = _i, Mi = Ei, _i = bi, Ei = mi, bi = En, mi = fi, En = sum64_hi(Ve, vn, wi, Ai), fi = sum64_lo(vn, vn, wi, Ai), Ve = je, vn = fn, je = Me, fn = Ue, Me = Pe, Ue = Te, Pe = sum64_hi(wi, Ai, Ri, Ti), Te = sum64_lo(wi, Ai, Ri, Ti);
  }
  sum64(this.h, 0, Pe, Te), sum64(this.h, 2, Me, Ue), sum64(this.h, 4, je, fn), sum64(this.h, 6, Ve, vn), sum64(this.h, 8, En, fi), sum64(this.h, 10, bi, mi), sum64(this.h, 12, _i, Ei), sum64(this.h, 14, Si, Mi);
};
SHA512$2.prototype._digest = function(t) {
  return t === "hex" ? utils$8.toHex32(this.h, "big") : utils$8.split32(this.h, "big");
};
function ch64_hi(Ae, t, Ie, Be, Pe) {
  var Te = Ae & Ie ^ ~Ae & Pe;
  return Te < 0 && (Te += 4294967296), Te;
}
function ch64_lo(Ae, t, Ie, Be, Pe, Te) {
  var Me = t & Be ^ ~t & Te;
  return Me < 0 && (Me += 4294967296), Me;
}
function maj64_hi(Ae, t, Ie, Be, Pe) {
  var Te = Ae & Ie ^ Ae & Pe ^ Ie & Pe;
  return Te < 0 && (Te += 4294967296), Te;
}
function maj64_lo(Ae, t, Ie, Be, Pe, Te) {
  var Me = t & Be ^ t & Te ^ Be & Te;
  return Me < 0 && (Me += 4294967296), Me;
}
function s0_512_hi(Ae, t) {
  var Ie = rotr64_hi(Ae, t, 28), Be = rotr64_hi(t, Ae, 2), Pe = rotr64_hi(t, Ae, 7), Te = Ie ^ Be ^ Pe;
  return Te < 0 && (Te += 4294967296), Te;
}
function s0_512_lo(Ae, t) {
  var Ie = rotr64_lo(Ae, t, 28), Be = rotr64_lo(t, Ae, 2), Pe = rotr64_lo(t, Ae, 7), Te = Ie ^ Be ^ Pe;
  return Te < 0 && (Te += 4294967296), Te;
}
function s1_512_hi(Ae, t) {
  var Ie = rotr64_hi(Ae, t, 14), Be = rotr64_hi(Ae, t, 18), Pe = rotr64_hi(t, Ae, 9), Te = Ie ^ Be ^ Pe;
  return Te < 0 && (Te += 4294967296), Te;
}
function s1_512_lo(Ae, t) {
  var Ie = rotr64_lo(Ae, t, 14), Be = rotr64_lo(Ae, t, 18), Pe = rotr64_lo(t, Ae, 9), Te = Ie ^ Be ^ Pe;
  return Te < 0 && (Te += 4294967296), Te;
}
function g0_512_hi(Ae, t) {
  var Ie = rotr64_hi(Ae, t, 1), Be = rotr64_hi(Ae, t, 8), Pe = shr64_hi(Ae, t, 7), Te = Ie ^ Be ^ Pe;
  return Te < 0 && (Te += 4294967296), Te;
}
function g0_512_lo(Ae, t) {
  var Ie = rotr64_lo(Ae, t, 1), Be = rotr64_lo(Ae, t, 8), Pe = shr64_lo(Ae, t, 7), Te = Ie ^ Be ^ Pe;
  return Te < 0 && (Te += 4294967296), Te;
}
function g1_512_hi(Ae, t) {
  var Ie = rotr64_hi(Ae, t, 19), Be = rotr64_hi(t, Ae, 29), Pe = shr64_hi(Ae, t, 6), Te = Ie ^ Be ^ Pe;
  return Te < 0 && (Te += 4294967296), Te;
}
function g1_512_lo(Ae, t) {
  var Ie = rotr64_lo(Ae, t, 19), Be = rotr64_lo(t, Ae, 29), Pe = shr64_lo(Ae, t, 6), Te = Ie ^ Be ^ Pe;
  return Te < 0 && (Te += 4294967296), Te;
}
var utils$7 = utils$e, SHA512$1 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512$1.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$7.inherits(SHA384, SHA512$1);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function(t) {
  return t === "hex" ? utils$7.toHex32(this.h.slice(0, 12), "big") : utils$7.split32(this.h.slice(0, 12), "big");
};
sha$1.sha1 = _1;
sha$1.sha224 = _224;
sha$1.sha256 = _256;
sha$1.sha384 = _384;
sha$1.sha512 = _512;
var ripemd = {}, utils$6 = utils$e, common = common$5, rotl32 = utils$6.rotl32, sum32 = utils$6.sum32, sum32_3 = utils$6.sum32_3, sum32_4 = utils$6.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$6.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function(t, Ie) {
  for (var Be = this.h[0], Pe = this.h[1], Te = this.h[2], Me = this.h[3], Ue = this.h[4], je = Be, fn = Pe, Ve = Te, vn = Me, En = Ue, fi = 0; fi < 80; fi++) {
    var bi = sum32(
      rotl32(
        sum32_4(Be, f$4(fi, Pe, Te, Me), t[r$2[fi] + Ie], K$4(fi)),
        s$1[fi]
      ),
      Ue
    );
    Be = Ue, Ue = Me, Me = rotl32(Te, 10), Te = Pe, Pe = bi, bi = sum32(
      rotl32(
        sum32_4(je, f$4(79 - fi, fn, Ve, vn), t[rh[fi] + Ie], Kh(fi)),
        sh[fi]
      ),
      En
    ), je = En, En = vn, vn = rotl32(Ve, 10), Ve = fn, fn = bi;
  }
  bi = sum32_3(this.h[1], Te, vn), this.h[1] = sum32_3(this.h[2], Me, En), this.h[2] = sum32_3(this.h[3], Ue, je), this.h[3] = sum32_3(this.h[4], Be, fn), this.h[4] = sum32_3(this.h[0], Pe, Ve), this.h[0] = bi;
};
RIPEMD160.prototype._digest = function(t) {
  return t === "hex" ? utils$6.toHex32(this.h, "little") : utils$6.split32(this.h, "little");
};
function f$4(Ae, t, Ie, Be) {
  return Ae <= 15 ? t ^ Ie ^ Be : Ae <= 31 ? t & Ie | ~t & Be : Ae <= 47 ? (t | ~Ie) ^ Be : Ae <= 63 ? t & Be | Ie & ~Be : t ^ (Ie | ~Be);
}
function K$4(Ae) {
  return Ae <= 15 ? 0 : Ae <= 31 ? 1518500249 : Ae <= 47 ? 1859775393 : Ae <= 63 ? 2400959708 : 2840853838;
}
function Kh(Ae) {
  return Ae <= 15 ? 1352829926 : Ae <= 31 ? 1548603684 : Ae <= 47 ? 1836072691 : Ae <= 63 ? 2053994217 : 0;
}
var r$2 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s$1 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils$5 = utils$e, assert$8 = minimalisticAssert$1;
function Hmac(Ae, t, Ie) {
  if (!(this instanceof Hmac))
    return new Hmac(Ae, t, Ie);
  this.Hash = Ae, this.blockSize = Ae.blockSize / 8, this.outSize = Ae.outSize / 8, this.inner = null, this.outer = null, this._init(utils$5.toArray(t, Ie));
}
var hmac$4 = Hmac;
Hmac.prototype._init = function(t) {
  t.length > this.blockSize && (t = new this.Hash().update(t).digest()), assert$8(t.length <= this.blockSize);
  for (var Ie = t.length; Ie < this.blockSize; Ie++)
    t.push(0);
  for (Ie = 0; Ie < t.length; Ie++)
    t[Ie] ^= 54;
  for (this.inner = new this.Hash().update(t), Ie = 0; Ie < t.length; Ie++)
    t[Ie] ^= 106;
  this.outer = new this.Hash().update(t);
};
Hmac.prototype.update = function(t, Ie) {
  return this.inner.update(t, Ie), this;
};
Hmac.prototype.digest = function(t) {
  return this.outer.update(this.inner.digest()), this.outer.digest(t);
};
(function(Ae) {
  var t = Ae;
  t.utils = utils$e, t.common = common$5, t.sha = sha$1, t.ripemd = ripemd, t.hmac = hmac$4, t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
})(hash$6);
const hash$5 = /* @__PURE__ */ getDefaultExportFromCjs(hash$6);
var util$2 = {}, types$1 = {}, shams$1 = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var t = {}, Ie = Symbol("test"), Be = Object(Ie);
  if (typeof Ie == "string" || Object.prototype.toString.call(Ie) !== "[object Symbol]" || Object.prototype.toString.call(Be) !== "[object Symbol]")
    return !1;
  var Pe = 42;
  t[Ie] = Pe;
  for (Ie in t)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
    return !1;
  var Te = Object.getOwnPropertySymbols(t);
  if (Te.length !== 1 || Te[0] !== Ie || !Object.prototype.propertyIsEnumerable.call(t, Ie))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var Me = Object.getOwnPropertyDescriptor(t, Ie);
    if (Me.value !== Pe || Me.enumerable !== !0)
      return !1;
  }
  return !0;
}, hasSymbols$2 = shams$1, shams = function() {
  return hasSymbols$2() && !!Symbol.toStringTag;
}, esErrors = Error, _eval = EvalError, range = RangeError, ref = ReferenceError, syntax = SyntaxError, type = TypeError, uri = URIError, origSymbol = typeof Symbol < "u" && Symbol, hasSymbolSham = shams$1, hasSymbols$1 = function() {
  return typeof origSymbol != "function" || typeof Symbol != "function" || typeof origSymbol("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : hasSymbolSham();
}, test = {
  __proto__: null,
  foo: {}
}, $Object = Object, hasProto$1 = function() {
  return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
}, ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$4 = Object.prototype.toString, max = Math.max, funcType = "[object Function]", concatty = function(t, Ie) {
  for (var Be = [], Pe = 0; Pe < t.length; Pe += 1)
    Be[Pe] = t[Pe];
  for (var Te = 0; Te < Ie.length; Te += 1)
    Be[Te + t.length] = Ie[Te];
  return Be;
}, slicy = function(t, Ie) {
  for (var Be = [], Pe = Ie, Te = 0; Pe < t.length; Pe += 1, Te += 1)
    Be[Te] = t[Pe];
  return Be;
}, joiny = function(Ae, t) {
  for (var Ie = "", Be = 0; Be < Ae.length; Be += 1)
    Ie += Ae[Be], Be + 1 < Ae.length && (Ie += t);
  return Ie;
}, implementation$2 = function(t) {
  var Ie = this;
  if (typeof Ie != "function" || toStr$4.apply(Ie) !== funcType)
    throw new TypeError(ERROR_MESSAGE + Ie);
  for (var Be = slicy(arguments, 1), Pe, Te = function() {
    if (this instanceof Pe) {
      var Ve = Ie.apply(
        this,
        concatty(Be, arguments)
      );
      return Object(Ve) === Ve ? Ve : this;
    }
    return Ie.apply(
      t,
      concatty(Be, arguments)
    );
  }, Me = max(0, Ie.length - Be.length), Ue = [], je = 0; je < Me; je++)
    Ue[je] = "$" + je;
  if (Pe = Function("binder", "return function (" + joiny(Ue, ",") + "){ return binder.apply(this,arguments); }")(Te), Ie.prototype) {
    var fn = function() {
    };
    fn.prototype = Ie.prototype, Pe.prototype = new fn(), fn.prototype = null;
  }
  return Pe;
}, implementation$1 = implementation$2, functionBind = Function.prototype.bind || implementation$1, call$1 = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$2 = functionBind, hasown = bind$2.call(call$1, $hasOwn), undefined$1, $Error = esErrors, $EvalError = _eval, $RangeError = range, $ReferenceError = ref, $SyntaxError$1 = syntax, $TypeError$2 = type, $URIError = uri, $Function = Function, getEvalledConstructor = function(Ae) {
  try {
    return $Function('"use strict"; return (' + Ae + ").constructor;")();
  } catch {
  }
}, $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1)
  try {
    $gOPD$1({}, "");
  } catch {
    $gOPD$1 = null;
  }
var throwTypeError = function() {
  throw new $TypeError$2();
}, ThrowTypeError = $gOPD$1 ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols = hasSymbols$1(), hasProto = hasProto$1(), getProto$1 = Object.getPrototypeOf || (hasProto ? function(Ae) {
  return Ae.__proto__;
} : null), needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array), INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$2,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet
};
if (getProto$1)
  try {
    null.error;
  } catch (Ae) {
    var errorProto = getProto$1(getProto$1(Ae));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function Ae(t) {
  var Ie;
  if (t === "%AsyncFunction%")
    Ie = getEvalledConstructor("async function () {}");
  else if (t === "%GeneratorFunction%")
    Ie = getEvalledConstructor("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    Ie = getEvalledConstructor("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var Be = Ae("%AsyncGeneratorFunction%");
    Be && (Ie = Be.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var Pe = Ae("%AsyncGenerator%");
    Pe && getProto$1 && (Ie = getProto$1(Pe.prototype));
  }
  return INTRINSICS[t] = Ie, Ie;
}, LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind$1 = functionBind, hasOwn = hasown, $concat = bind$1.call(Function.call, Array.prototype.concat), $spliceApply = bind$1.call(Function.apply, Array.prototype.splice), $replace = bind$1.call(Function.call, String.prototype.replace), $strSlice = bind$1.call(Function.call, String.prototype.slice), $exec = bind$1.call(Function.call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function(t) {
  var Ie = $strSlice(t, 0, 1), Be = $strSlice(t, -1);
  if (Ie === "%" && Be !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (Be === "%" && Ie !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var Pe = [];
  return $replace(t, rePropName, function(Te, Me, Ue, je) {
    Pe[Pe.length] = Ue ? $replace(je, reEscapeChar, "$1") : Me || Te;
  }), Pe;
}, getBaseIntrinsic = function(t, Ie) {
  var Be = t, Pe;
  if (hasOwn(LEGACY_ALIASES, Be) && (Pe = LEGACY_ALIASES[Be], Be = "%" + Pe[0] + "%"), hasOwn(INTRINSICS, Be)) {
    var Te = INTRINSICS[Be];
    if (Te === needsEval && (Te = doEval(Be)), typeof Te > "u" && !Ie)
      throw new $TypeError$2("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: Pe,
      name: Be,
      value: Te
    };
  }
  throw new $SyntaxError$1("intrinsic " + t + " does not exist!");
}, getIntrinsic = function(t, Ie) {
  if (typeof t != "string" || t.length === 0)
    throw new $TypeError$2("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof Ie != "boolean")
    throw new $TypeError$2('"allowMissing" argument must be a boolean');
  if ($exec(/^%?[^%]*%?$/, t) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var Be = stringToPath(t), Pe = Be.length > 0 ? Be[0] : "", Te = getBaseIntrinsic("%" + Pe + "%", Ie), Me = Te.name, Ue = Te.value, je = !1, fn = Te.alias;
  fn && (Pe = fn[0], $spliceApply(Be, $concat([0, 1], fn)));
  for (var Ve = 1, vn = !0; Ve < Be.length; Ve += 1) {
    var En = Be[Ve], fi = $strSlice(En, 0, 1), bi = $strSlice(En, -1);
    if ((fi === '"' || fi === "'" || fi === "`" || bi === '"' || bi === "'" || bi === "`") && fi !== bi)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((En === "constructor" || !vn) && (je = !0), Pe += "." + En, Me = "%" + Pe + "%", hasOwn(INTRINSICS, Me))
      Ue = INTRINSICS[Me];
    else if (Ue != null) {
      if (!(En in Ue)) {
        if (!Ie)
          throw new $TypeError$2("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if ($gOPD$1 && Ve + 1 >= Be.length) {
        var mi = $gOPD$1(Ue, En);
        vn = !!mi, vn && "get" in mi && !("originalValue" in mi.get) ? Ue = mi.get : Ue = Ue[En];
      } else
        vn = hasOwn(Ue, En), Ue = Ue[En];
      vn && !je && (INTRINSICS[Me] = Ue);
    }
  }
  return Ue;
}, callBind$3 = { exports: {} }, esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var Ae = getIntrinsic, t = Ae("%Object.defineProperty%", !0) || !1;
  if (t)
    try {
      t({}, "a", { value: 1 });
    } catch {
      t = !1;
    }
  return esDefineProperty = t, esDefineProperty;
}
var GetIntrinsic$2 = getIntrinsic, $gOPD = GetIntrinsic$2("%Object.getOwnPropertyDescriptor%", !0);
if ($gOPD)
  try {
    $gOPD([], "length");
  } catch {
    $gOPD = null;
  }
var gopd$1 = $gOPD, $defineProperty$1 = requireEsDefineProperty(), $SyntaxError = syntax, $TypeError$1 = type, gopd = gopd$1, defineDataProperty = function(t, Ie, Be) {
  if (!t || typeof t != "object" && typeof t != "function")
    throw new $TypeError$1("`obj` must be an object or a function`");
  if (typeof Ie != "string" && typeof Ie != "symbol")
    throw new $TypeError$1("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$1("`loose`, if provided, must be a boolean");
  var Pe = arguments.length > 3 ? arguments[3] : null, Te = arguments.length > 4 ? arguments[4] : null, Me = arguments.length > 5 ? arguments[5] : null, Ue = arguments.length > 6 ? arguments[6] : !1, je = !!gopd && gopd(t, Ie);
  if ($defineProperty$1)
    $defineProperty$1(t, Ie, {
      configurable: Me === null && je ? je.configurable : !Me,
      enumerable: Pe === null && je ? je.enumerable : !Pe,
      value: Be,
      writable: Te === null && je ? je.writable : !Te
    });
  else if (Ue || !Pe && !Te && !Me)
    t[Ie] = Be;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $defineProperty = requireEsDefineProperty(), hasPropertyDescriptors = function() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function() {
  if (!$defineProperty)
    return null;
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors, GetIntrinsic$1 = getIntrinsic, define = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD$1 = gopd$1, $TypeError = type, $floor = GetIntrinsic$1("%Math.floor%"), setFunctionLength = function(t, Ie) {
  if (typeof t != "function")
    throw new $TypeError("`fn` is not a function");
  if (typeof Ie != "number" || Ie < 0 || Ie > 4294967295 || $floor(Ie) !== Ie)
    throw new $TypeError("`length` must be a positive 32-bit integer");
  var Be = arguments.length > 2 && !!arguments[2], Pe = !0, Te = !0;
  if ("length" in t && gOPD$1) {
    var Me = gOPD$1(t, "length");
    Me && !Me.configurable && (Pe = !1), Me && !Me.writable && (Te = !1);
  }
  return (Pe || Te || !Be) && (hasDescriptors ? define(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    Ie,
    !0,
    !0
  ) : define(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    Ie
  )), t;
};
(function(Ae) {
  var t = functionBind, Ie = getIntrinsic, Be = setFunctionLength, Pe = type, Te = Ie("%Function.prototype.apply%"), Me = Ie("%Function.prototype.call%"), Ue = Ie("%Reflect.apply%", !0) || t.call(Me, Te), je = requireEsDefineProperty(), fn = Ie("%Math.max%");
  Ae.exports = function(En) {
    if (typeof En != "function")
      throw new Pe("a function is required");
    var fi = Ue(t, Me, arguments);
    return Be(
      fi,
      1 + fn(0, En.length - (arguments.length - 1)),
      !0
    );
  };
  var Ve = function() {
    return Ue(t, Te, arguments);
  };
  je ? je(Ae.exports, "apply", { value: Ve }) : Ae.exports.apply = Ve;
})(callBind$3);
var callBindExports = callBind$3.exports, GetIntrinsic = getIntrinsic, callBind$2 = callBindExports, $indexOf$1 = callBind$2(GetIntrinsic("String.prototype.indexOf")), callBound$3 = function(t, Ie) {
  var Be = GetIntrinsic(t, !!Ie);
  return typeof Be == "function" && $indexOf$1(t, ".prototype.") > -1 ? callBind$2(Be) : Be;
}, hasToStringTag$3 = shams(), callBound$2 = callBound$3, $toString$1 = callBound$2("Object.prototype.toString"), isStandardArguments = function(t) {
  return hasToStringTag$3 && t && typeof t == "object" && Symbol.toStringTag in t ? !1 : $toString$1(t) === "[object Arguments]";
}, isLegacyArguments = function(t) {
  return isStandardArguments(t) ? !0 : t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && $toString$1(t) !== "[object Array]" && $toString$1(t.callee) === "[object Function]";
}, supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments, toStr$3 = Object.prototype.toString, fnToStr$1 = Function.prototype.toString, isFnRegex = /^\s*(?:function)?\*/, hasToStringTag$2 = shams(), getProto = Object.getPrototypeOf, getGeneratorFunc = function() {
  if (!hasToStringTag$2)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, GeneratorFunction, isGeneratorFunction = function(t) {
  if (typeof t != "function")
    return !1;
  if (isFnRegex.test(fnToStr$1.call(t)))
    return !0;
  if (!hasToStringTag$2) {
    var Ie = toStr$3.call(t);
    return Ie === "[object GeneratorFunction]";
  }
  if (!getProto)
    return !1;
  if (typeof GeneratorFunction > "u") {
    var Be = getGeneratorFunc();
    GeneratorFunction = Be ? getProto(Be) : !1;
  }
  return getProto(t) === GeneratorFunction;
}, fnToStr = Function.prototype.toString, reflectApply = typeof Reflect == "object" && Reflect !== null && Reflect.apply, badArrayLike, isCallableMarker;
if (typeof reflectApply == "function" && typeof Object.defineProperty == "function")
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    }), isCallableMarker = {}, reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (Ae) {
    Ae !== isCallableMarker && (reflectApply = null);
  }
else
  reflectApply = null;
var constructorRegex = /^\s*class\b/, isES6ClassFn = function(t) {
  try {
    var Ie = fnToStr.call(t);
    return constructorRegex.test(Ie);
  } catch {
    return !1;
  }
}, tryFunctionObject = function(t) {
  try {
    return isES6ClassFn(t) ? !1 : (fnToStr.call(t), !0);
  } catch {
    return !1;
  }
}, toStr$2 = Object.prototype.toString, objectClass = "[object Object]", fnClass = "[object Function]", genClass = "[object GeneratorFunction]", ddaClass = "[object HTMLAllCollection]", ddaClass2 = "[object HTML document.all class]", ddaClass3 = "[object HTMLCollection]", hasToStringTag$1 = typeof Symbol == "function" && !!Symbol.toStringTag, isIE68 = !(0 in [,]), isDDA = function() {
  return !1;
};
if (typeof document == "object") {
  var all = document.all;
  toStr$2.call(all) === toStr$2.call(document.all) && (isDDA = function(t) {
    if ((isIE68 || !t) && (typeof t > "u" || typeof t == "object"))
      try {
        var Ie = toStr$2.call(t);
        return (Ie === ddaClass || Ie === ddaClass2 || Ie === ddaClass3 || Ie === objectClass) && t("") == null;
      } catch {
      }
    return !1;
  });
}
var isCallable$1 = reflectApply ? function(t) {
  if (isDDA(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  try {
    reflectApply(t, null, badArrayLike);
  } catch (Ie) {
    if (Ie !== isCallableMarker)
      return !1;
  }
  return !isES6ClassFn(t) && tryFunctionObject(t);
} : function(t) {
  if (isDDA(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  if (hasToStringTag$1)
    return tryFunctionObject(t);
  if (isES6ClassFn(t))
    return !1;
  var Ie = toStr$2.call(t);
  return Ie !== fnClass && Ie !== genClass && !/^\[object HTML/.test(Ie) ? !1 : tryFunctionObject(t);
}, isCallable = isCallable$1, toStr$1 = Object.prototype.toString, hasOwnProperty = Object.prototype.hasOwnProperty, forEachArray = function(t, Ie, Be) {
  for (var Pe = 0, Te = t.length; Pe < Te; Pe++)
    hasOwnProperty.call(t, Pe) && (Be == null ? Ie(t[Pe], Pe, t) : Ie.call(Be, t[Pe], Pe, t));
}, forEachString = function(t, Ie, Be) {
  for (var Pe = 0, Te = t.length; Pe < Te; Pe++)
    Be == null ? Ie(t.charAt(Pe), Pe, t) : Ie.call(Be, t.charAt(Pe), Pe, t);
}, forEachObject = function(t, Ie, Be) {
  for (var Pe in t)
    hasOwnProperty.call(t, Pe) && (Be == null ? Ie(t[Pe], Pe, t) : Ie.call(Be, t[Pe], Pe, t));
}, forEach$2 = function(t, Ie, Be) {
  if (!isCallable(Ie))
    throw new TypeError("iterator must be a function");
  var Pe;
  arguments.length >= 3 && (Pe = Be), toStr$1.call(t) === "[object Array]" ? forEachArray(t, Ie, Pe) : typeof t == "string" ? forEachString(t, Ie, Pe) : forEachObject(t, Ie, Pe);
}, forEach_1 = forEach$2, possibleTypedArrayNames = [
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], possibleNames = possibleTypedArrayNames, g$5 = typeof globalThis > "u" ? commonjsGlobal : globalThis, availableTypedArrays$1 = function() {
  for (var t = [], Ie = 0; Ie < possibleNames.length; Ie++)
    typeof g$5[possibleNames[Ie]] == "function" && (t[t.length] = possibleNames[Ie]);
  return t;
}, forEach$1 = forEach_1, availableTypedArrays = availableTypedArrays$1, callBind$1 = callBindExports, callBound$1 = callBound$3, gOPD = gopd$1, $toString = callBound$1("Object.prototype.toString"), hasToStringTag = shams(), g$4 = typeof globalThis > "u" ? commonjsGlobal : globalThis, typedArrays = availableTypedArrays(), $slice = callBound$1("String.prototype.slice"), getPrototypeOf = Object.getPrototypeOf, $indexOf = callBound$1("Array.prototype.indexOf", !0) || function(t, Ie) {
  for (var Be = 0; Be < t.length; Be += 1)
    if (t[Be] === Ie)
      return Be;
  return -1;
}, cache$1 = { __proto__: null };
hasToStringTag && gOPD && getPrototypeOf ? forEach$1(typedArrays, function(Ae) {
  var t = new g$4[Ae]();
  if (Symbol.toStringTag in t) {
    var Ie = getPrototypeOf(t), Be = gOPD(Ie, Symbol.toStringTag);
    if (!Be) {
      var Pe = getPrototypeOf(Ie);
      Be = gOPD(Pe, Symbol.toStringTag);
    }
    cache$1["$" + Ae] = callBind$1(Be.get);
  }
}) : forEach$1(typedArrays, function(Ae) {
  var t = new g$4[Ae](), Ie = t.slice || t.set;
  Ie && (cache$1["$" + Ae] = callBind$1(Ie));
});
var tryTypedArrays = function(t) {
  var Ie = !1;
  return forEach$1(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    cache$1,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(Be, Pe) {
      if (!Ie)
        try {
          "$" + Be(t) === Pe && (Ie = $slice(Pe, 1));
        } catch {
        }
    }
  ), Ie;
}, trySlices = function(t) {
  var Ie = !1;
  return forEach$1(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    cache$1,
    /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
    function(Be, Pe) {
      if (!Ie)
        try {
          Be(t), Ie = $slice(Pe, 1);
        } catch {
        }
    }
  ), Ie;
}, whichTypedArray$1 = function(t) {
  if (!t || typeof t != "object")
    return !1;
  if (!hasToStringTag) {
    var Ie = $slice($toString(t), 8, -1);
    return $indexOf(typedArrays, Ie) > -1 ? Ie : Ie !== "Object" ? !1 : trySlices(t);
  }
  return gOPD ? tryTypedArrays(t) : null;
}, whichTypedArray = whichTypedArray$1, isTypedArray = function(t) {
  return !!whichTypedArray(t);
};
(function(Ae) {
  var t = isArguments$1, Ie = isGeneratorFunction, Be = whichTypedArray$1, Pe = isTypedArray;
  function Te(hs) {
    return hs.call.bind(hs);
  }
  var Me = typeof BigInt < "u", Ue = typeof Symbol < "u", je = Te(Object.prototype.toString), fn = Te(Number.prototype.valueOf), Ve = Te(String.prototype.valueOf), vn = Te(Boolean.prototype.valueOf);
  if (Me)
    var En = Te(BigInt.prototype.valueOf);
  if (Ue)
    var fi = Te(Symbol.prototype.valueOf);
  function bi(hs, So) {
    if (typeof hs != "object")
      return !1;
    try {
      return So(hs), !0;
    } catch {
      return !1;
    }
  }
  Ae.isArgumentsObject = t, Ae.isGeneratorFunction = Ie, Ae.isTypedArray = Pe;
  function mi(hs) {
    return typeof Promise < "u" && hs instanceof Promise || hs !== null && typeof hs == "object" && typeof hs.then == "function" && typeof hs.catch == "function";
  }
  Ae.isPromise = mi;
  function _i(hs) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(hs) : Pe(hs) || Vi(hs);
  }
  Ae.isArrayBufferView = _i;
  function Ei(hs) {
    return Be(hs) === "Uint8Array";
  }
  Ae.isUint8Array = Ei;
  function Si(hs) {
    return Be(hs) === "Uint8ClampedArray";
  }
  Ae.isUint8ClampedArray = Si;
  function Mi(hs) {
    return Be(hs) === "Uint16Array";
  }
  Ae.isUint16Array = Mi;
  function Oi(hs) {
    return Be(hs) === "Uint32Array";
  }
  Ae.isUint32Array = Oi;
  function Fi(hs) {
    return Be(hs) === "Int8Array";
  }
  Ae.isInt8Array = Fi;
  function Ui(hs) {
    return Be(hs) === "Int16Array";
  }
  Ae.isInt16Array = Ui;
  function Pi(hs) {
    return Be(hs) === "Int32Array";
  }
  Ae.isInt32Array = Pi;
  function Bi(hs) {
    return Be(hs) === "Float32Array";
  }
  Ae.isFloat32Array = Bi;
  function ji(hs) {
    return Be(hs) === "Float64Array";
  }
  Ae.isFloat64Array = ji;
  function Zi(hs) {
    return Be(hs) === "BigInt64Array";
  }
  Ae.isBigInt64Array = Zi;
  function zi(hs) {
    return Be(hs) === "BigUint64Array";
  }
  Ae.isBigUint64Array = zi;
  function xi(hs) {
    return je(hs) === "[object Map]";
  }
  xi.working = typeof Map < "u" && xi(/* @__PURE__ */ new Map());
  function $i(hs) {
    return typeof Map > "u" ? !1 : xi.working ? xi(hs) : hs instanceof Map;
  }
  Ae.isMap = $i;
  function vi(hs) {
    return je(hs) === "[object Set]";
  }
  vi.working = typeof Set < "u" && vi(/* @__PURE__ */ new Set());
  function wi(hs) {
    return typeof Set > "u" ? !1 : vi.working ? vi(hs) : hs instanceof Set;
  }
  Ae.isSet = wi;
  function Ai(hs) {
    return je(hs) === "[object WeakMap]";
  }
  Ai.working = typeof WeakMap < "u" && Ai(/* @__PURE__ */ new WeakMap());
  function Ri(hs) {
    return typeof WeakMap > "u" ? !1 : Ai.working ? Ai(hs) : hs instanceof WeakMap;
  }
  Ae.isWeakMap = Ri;
  function Ti(hs) {
    return je(hs) === "[object WeakSet]";
  }
  Ti.working = typeof WeakSet < "u" && Ti(/* @__PURE__ */ new WeakSet());
  function Ci(hs) {
    return Ti(hs);
  }
  Ae.isWeakSet = Ci;
  function Ii(hs) {
    return je(hs) === "[object ArrayBuffer]";
  }
  Ii.working = typeof ArrayBuffer < "u" && Ii(new ArrayBuffer());
  function Li(hs) {
    return typeof ArrayBuffer > "u" ? !1 : Ii.working ? Ii(hs) : hs instanceof ArrayBuffer;
  }
  Ae.isArrayBuffer = Li;
  function Ni(hs) {
    return je(hs) === "[object DataView]";
  }
  Ni.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && Ni(new DataView(new ArrayBuffer(1), 0, 1));
  function Vi(hs) {
    return typeof DataView > "u" ? !1 : Ni.working ? Ni(hs) : hs instanceof DataView;
  }
  Ae.isDataView = Vi;
  var is = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function Ki(hs) {
    return je(hs) === "[object SharedArrayBuffer]";
  }
  function ts(hs) {
    return typeof is > "u" ? !1 : (typeof Ki.working > "u" && (Ki.working = Ki(new is())), Ki.working ? Ki(hs) : hs instanceof is);
  }
  Ae.isSharedArrayBuffer = ts;
  function qi(hs) {
    return je(hs) === "[object AsyncFunction]";
  }
  Ae.isAsyncFunction = qi;
  function Hi(hs) {
    return je(hs) === "[object Map Iterator]";
  }
  Ae.isMapIterator = Hi;
  function Xi(hs) {
    return je(hs) === "[object Set Iterator]";
  }
  Ae.isSetIterator = Xi;
  function ki(hs) {
    return je(hs) === "[object Generator]";
  }
  Ae.isGeneratorObject = ki;
  function Wi(hs) {
    return je(hs) === "[object WebAssembly.Module]";
  }
  Ae.isWebAssemblyCompiledModule = Wi;
  function Yi(hs) {
    return bi(hs, fn);
  }
  Ae.isNumberObject = Yi;
  function Qi(hs) {
    return bi(hs, Ve);
  }
  Ae.isStringObject = Qi;
  function ns(hs) {
    return bi(hs, vn);
  }
  Ae.isBooleanObject = ns;
  function us(hs) {
    return Me && bi(hs, En);
  }
  Ae.isBigIntObject = us;
  function ps(hs) {
    return Ue && bi(hs, fi);
  }
  Ae.isSymbolObject = ps;
  function Ds(hs) {
    return Yi(hs) || Qi(hs) || ns(hs) || us(hs) || ps(hs);
  }
  Ae.isBoxedPrimitive = Ds;
  function Eo(hs) {
    return typeof Uint8Array < "u" && (Li(hs) || ts(hs));
  }
  Ae.isAnyArrayBuffer = Eo, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(hs) {
    Object.defineProperty(Ae, hs, {
      enumerable: !1,
      value: function() {
        throw new Error(hs + " is not supported in userland");
      }
    });
  });
})(types$1);
var isBufferBrowser = function(t) {
  return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
};
(function(Ae) {
  var t = Object.getOwnPropertyDescriptors || function(Vi) {
    for (var is = Object.keys(Vi), Ki = {}, ts = 0; ts < is.length; ts++)
      Ki[is[ts]] = Object.getOwnPropertyDescriptor(Vi, is[ts]);
    return Ki;
  }, Ie = /%[sdj%]/g;
  Ae.format = function(Ni) {
    if (!Fi(Ni)) {
      for (var Vi = [], is = 0; is < arguments.length; is++)
        Vi.push(Me(arguments[is]));
      return Vi.join(" ");
    }
    for (var is = 1, Ki = arguments, ts = Ki.length, qi = String(Ni).replace(Ie, function(Xi) {
      if (Xi === "%%") return "%";
      if (is >= ts) return Xi;
      switch (Xi) {
        case "%s":
          return String(Ki[is++]);
        case "%d":
          return Number(Ki[is++]);
        case "%j":
          try {
            return JSON.stringify(Ki[is++]);
          } catch {
            return "[Circular]";
          }
        default:
          return Xi;
      }
    }), Hi = Ki[is]; is < ts; Hi = Ki[++is])
      Si(Hi) || !ji(Hi) ? qi += " " + Hi : qi += " " + Me(Hi);
    return qi;
  }, Ae.deprecate = function(Ni, Vi) {
    if (typeof process$1$1 < "u" && process$1$1.noDeprecation === !0)
      return Ni;
    if (typeof process$1$1 > "u")
      return function() {
        return Ae.deprecate(Ni, Vi).apply(this, arguments);
      };
    var is = !1;
    function Ki() {
      if (!is) {
        if (process$1$1.throwDeprecation)
          throw new Error(Vi);
        process$1$1.traceDeprecation ? console.trace(Vi) : console.error(Vi), is = !0;
      }
      return Ni.apply(this, arguments);
    }
    return Ki;
  };
  var Be = {}, Pe = /^$/;
  if (process$1$1.env.NODE_DEBUG) {
    var Te = process$1$1.env.NODE_DEBUG;
    Te = Te.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), Pe = new RegExp("^" + Te + "$", "i");
  }
  Ae.debuglog = function(Ni) {
    if (Ni = Ni.toUpperCase(), !Be[Ni])
      if (Pe.test(Ni)) {
        var Vi = process$1$1.pid;
        Be[Ni] = function() {
          var is = Ae.format.apply(Ae, arguments);
          console.error("%s %d: %s", Ni, Vi, is);
        };
      } else
        Be[Ni] = function() {
        };
    return Be[Ni];
  };
  function Me(Ni, Vi) {
    var is = {
      seen: [],
      stylize: je
    };
    return arguments.length >= 3 && (is.depth = arguments[2]), arguments.length >= 4 && (is.colors = arguments[3]), Ei(Vi) ? is.showHidden = Vi : Vi && Ae._extend(is, Vi), Pi(is.showHidden) && (is.showHidden = !1), Pi(is.depth) && (is.depth = 2), Pi(is.colors) && (is.colors = !1), Pi(is.customInspect) && (is.customInspect = !0), is.colors && (is.stylize = Ue), Ve(is, Ni, is.depth);
  }
  Ae.inspect = Me, Me.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, Me.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function Ue(Ni, Vi) {
    var is = Me.styles[Vi];
    return is ? "\x1B[" + Me.colors[is][0] + "m" + Ni + "\x1B[" + Me.colors[is][1] + "m" : Ni;
  }
  function je(Ni, Vi) {
    return Ni;
  }
  function fn(Ni) {
    var Vi = {};
    return Ni.forEach(function(is, Ki) {
      Vi[is] = !0;
    }), Vi;
  }
  function Ve(Ni, Vi, is) {
    if (Ni.customInspect && Vi && xi(Vi.inspect) && // Filter out the util module, it's inspect function is special
    Vi.inspect !== Ae.inspect && // Also filter out any prototype objects using the circular check.
    !(Vi.constructor && Vi.constructor.prototype === Vi)) {
      var Ki = Vi.inspect(is, Ni);
      return Fi(Ki) || (Ki = Ve(Ni, Ki, is)), Ki;
    }
    var ts = vn(Ni, Vi);
    if (ts)
      return ts;
    var qi = Object.keys(Vi), Hi = fn(qi);
    if (Ni.showHidden && (qi = Object.getOwnPropertyNames(Vi)), zi(Vi) && (qi.indexOf("message") >= 0 || qi.indexOf("description") >= 0))
      return En(Vi);
    if (qi.length === 0) {
      if (xi(Vi)) {
        var Xi = Vi.name ? ": " + Vi.name : "";
        return Ni.stylize("[Function" + Xi + "]", "special");
      }
      if (Bi(Vi))
        return Ni.stylize(RegExp.prototype.toString.call(Vi), "regexp");
      if (Zi(Vi))
        return Ni.stylize(Date.prototype.toString.call(Vi), "date");
      if (zi(Vi))
        return En(Vi);
    }
    var ki = "", Wi = !1, Yi = ["{", "}"];
    if (_i(Vi) && (Wi = !0, Yi = ["[", "]"]), xi(Vi)) {
      var Qi = Vi.name ? ": " + Vi.name : "";
      ki = " [Function" + Qi + "]";
    }
    if (Bi(Vi) && (ki = " " + RegExp.prototype.toString.call(Vi)), Zi(Vi) && (ki = " " + Date.prototype.toUTCString.call(Vi)), zi(Vi) && (ki = " " + En(Vi)), qi.length === 0 && (!Wi || Vi.length == 0))
      return Yi[0] + ki + Yi[1];
    if (is < 0)
      return Bi(Vi) ? Ni.stylize(RegExp.prototype.toString.call(Vi), "regexp") : Ni.stylize("[Object]", "special");
    Ni.seen.push(Vi);
    var ns;
    return Wi ? ns = fi(Ni, Vi, is, Hi, qi) : ns = qi.map(function(us) {
      return bi(Ni, Vi, is, Hi, us, Wi);
    }), Ni.seen.pop(), mi(ns, ki, Yi);
  }
  function vn(Ni, Vi) {
    if (Pi(Vi))
      return Ni.stylize("undefined", "undefined");
    if (Fi(Vi)) {
      var is = "'" + JSON.stringify(Vi).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return Ni.stylize(is, "string");
    }
    if (Oi(Vi))
      return Ni.stylize("" + Vi, "number");
    if (Ei(Vi))
      return Ni.stylize("" + Vi, "boolean");
    if (Si(Vi))
      return Ni.stylize("null", "null");
  }
  function En(Ni) {
    return "[" + Error.prototype.toString.call(Ni) + "]";
  }
  function fi(Ni, Vi, is, Ki, ts) {
    for (var qi = [], Hi = 0, Xi = Vi.length; Hi < Xi; ++Hi)
      Ti(Vi, String(Hi)) ? qi.push(bi(
        Ni,
        Vi,
        is,
        Ki,
        String(Hi),
        !0
      )) : qi.push("");
    return ts.forEach(function(ki) {
      ki.match(/^\d+$/) || qi.push(bi(
        Ni,
        Vi,
        is,
        Ki,
        ki,
        !0
      ));
    }), qi;
  }
  function bi(Ni, Vi, is, Ki, ts, qi) {
    var Hi, Xi, ki;
    if (ki = Object.getOwnPropertyDescriptor(Vi, ts) || { value: Vi[ts] }, ki.get ? ki.set ? Xi = Ni.stylize("[Getter/Setter]", "special") : Xi = Ni.stylize("[Getter]", "special") : ki.set && (Xi = Ni.stylize("[Setter]", "special")), Ti(Ki, ts) || (Hi = "[" + ts + "]"), Xi || (Ni.seen.indexOf(ki.value) < 0 ? (Si(is) ? Xi = Ve(Ni, ki.value, null) : Xi = Ve(Ni, ki.value, is - 1), Xi.indexOf(`
`) > -1 && (qi ? Xi = Xi.split(`
`).map(function(Wi) {
      return "  " + Wi;
    }).join(`
`).slice(2) : Xi = `
` + Xi.split(`
`).map(function(Wi) {
      return "   " + Wi;
    }).join(`
`))) : Xi = Ni.stylize("[Circular]", "special")), Pi(Hi)) {
      if (qi && ts.match(/^\d+$/))
        return Xi;
      Hi = JSON.stringify("" + ts), Hi.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Hi = Hi.slice(1, -1), Hi = Ni.stylize(Hi, "name")) : (Hi = Hi.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Hi = Ni.stylize(Hi, "string"));
    }
    return Hi + ": " + Xi;
  }
  function mi(Ni, Vi, is) {
    var Ki = Ni.reduce(function(ts, qi) {
      return qi.indexOf(`
`) >= 0, ts + qi.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return Ki > 60 ? is[0] + (Vi === "" ? "" : Vi + `
 `) + " " + Ni.join(`,
  `) + " " + is[1] : is[0] + Vi + " " + Ni.join(", ") + " " + is[1];
  }
  Ae.types = types$1;
  function _i(Ni) {
    return Array.isArray(Ni);
  }
  Ae.isArray = _i;
  function Ei(Ni) {
    return typeof Ni == "boolean";
  }
  Ae.isBoolean = Ei;
  function Si(Ni) {
    return Ni === null;
  }
  Ae.isNull = Si;
  function Mi(Ni) {
    return Ni == null;
  }
  Ae.isNullOrUndefined = Mi;
  function Oi(Ni) {
    return typeof Ni == "number";
  }
  Ae.isNumber = Oi;
  function Fi(Ni) {
    return typeof Ni == "string";
  }
  Ae.isString = Fi;
  function Ui(Ni) {
    return typeof Ni == "symbol";
  }
  Ae.isSymbol = Ui;
  function Pi(Ni) {
    return Ni === void 0;
  }
  Ae.isUndefined = Pi;
  function Bi(Ni) {
    return ji(Ni) && vi(Ni) === "[object RegExp]";
  }
  Ae.isRegExp = Bi, Ae.types.isRegExp = Bi;
  function ji(Ni) {
    return typeof Ni == "object" && Ni !== null;
  }
  Ae.isObject = ji;
  function Zi(Ni) {
    return ji(Ni) && vi(Ni) === "[object Date]";
  }
  Ae.isDate = Zi, Ae.types.isDate = Zi;
  function zi(Ni) {
    return ji(Ni) && (vi(Ni) === "[object Error]" || Ni instanceof Error);
  }
  Ae.isError = zi, Ae.types.isNativeError = zi;
  function xi(Ni) {
    return typeof Ni == "function";
  }
  Ae.isFunction = xi;
  function $i(Ni) {
    return Ni === null || typeof Ni == "boolean" || typeof Ni == "number" || typeof Ni == "string" || typeof Ni == "symbol" || // ES6 symbol
    typeof Ni > "u";
  }
  Ae.isPrimitive = $i, Ae.isBuffer = isBufferBrowser;
  function vi(Ni) {
    return Object.prototype.toString.call(Ni);
  }
  function wi(Ni) {
    return Ni < 10 ? "0" + Ni.toString(10) : Ni.toString(10);
  }
  var Ai = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function Ri() {
    var Ni = /* @__PURE__ */ new Date(), Vi = [
      wi(Ni.getHours()),
      wi(Ni.getMinutes()),
      wi(Ni.getSeconds())
    ].join(":");
    return [Ni.getDate(), Ai[Ni.getMonth()], Vi].join(" ");
  }
  Ae.log = function() {
    console.log("%s - %s", Ri(), Ae.format.apply(Ae, arguments));
  }, Ae.inherits = requireInherits_browser(), Ae._extend = function(Ni, Vi) {
    if (!Vi || !ji(Vi)) return Ni;
    for (var is = Object.keys(Vi), Ki = is.length; Ki--; )
      Ni[is[Ki]] = Vi[is[Ki]];
    return Ni;
  };
  function Ti(Ni, Vi) {
    return Object.prototype.hasOwnProperty.call(Ni, Vi);
  }
  var Ci = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  Ae.promisify = function(Vi) {
    if (typeof Vi != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (Ci && Vi[Ci]) {
      var is = Vi[Ci];
      if (typeof is != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(is, Ci, {
        value: is,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), is;
    }
    function is() {
      for (var Ki, ts, qi = new Promise(function(ki, Wi) {
        Ki = ki, ts = Wi;
      }), Hi = [], Xi = 0; Xi < arguments.length; Xi++)
        Hi.push(arguments[Xi]);
      Hi.push(function(ki, Wi) {
        ki ? ts(ki) : Ki(Wi);
      });
      try {
        Vi.apply(this, Hi);
      } catch (ki) {
        ts(ki);
      }
      return qi;
    }
    return Object.setPrototypeOf(is, Object.getPrototypeOf(Vi)), Ci && Object.defineProperty(is, Ci, {
      value: is,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      is,
      t(Vi)
    );
  }, Ae.promisify.custom = Ci;
  function Ii(Ni, Vi) {
    if (!Ni) {
      var is = new Error("Promise was rejected with a falsy value");
      is.reason = Ni, Ni = is;
    }
    return Vi(Ni);
  }
  function Li(Ni) {
    if (typeof Ni != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function Vi() {
      for (var is = [], Ki = 0; Ki < arguments.length; Ki++)
        is.push(arguments[Ki]);
      var ts = is.pop();
      if (typeof ts != "function")
        throw new TypeError("The last argument must be of type Function");
      var qi = this, Hi = function() {
        return ts.apply(qi, arguments);
      };
      Ni.apply(this, is).then(
        function(Xi) {
          process$1$1.nextTick(Hi.bind(null, null, Xi));
        },
        function(Xi) {
          process$1$1.nextTick(Ii.bind(null, Xi, Hi));
        }
      );
    }
    return Object.setPrototypeOf(Vi, Object.getPrototypeOf(Ni)), Object.defineProperties(
      Vi,
      t(Ni)
    ), Vi;
  }
  Ae.callbackify = Li;
})(util$2);
var toStr = Object.prototype.toString, isArguments = function(t) {
  var Ie = toStr.call(t), Be = Ie === "[object Arguments]";
  return Be || (Be = Ie !== "[object Array]" && t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && toStr.call(t.callee) === "[object Function]"), Be;
}, implementation, hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var Ae;
  if (!Object.keys) {
    var t = Object.prototype.hasOwnProperty, Ie = Object.prototype.toString, Be = isArguments, Pe = Object.prototype.propertyIsEnumerable, Te = !Pe.call({ toString: null }, "toString"), Me = Pe.call(function() {
    }, "prototype"), Ue = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], je = function(En) {
      var fi = En.constructor;
      return fi && fi.prototype === En;
    }, fn = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, Ve = function() {
      if (typeof window > "u")
        return !1;
      for (var En in window)
        try {
          if (!fn["$" + En] && t.call(window, En) && window[En] !== null && typeof window[En] == "object")
            try {
              je(window[En]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), vn = function(En) {
      if (typeof window > "u" || !Ve)
        return je(En);
      try {
        return je(En);
      } catch {
        return !1;
      }
    };
    Ae = function(fi) {
      var bi = fi !== null && typeof fi == "object", mi = Ie.call(fi) === "[object Function]", _i = Be(fi), Ei = bi && Ie.call(fi) === "[object String]", Si = [];
      if (!bi && !mi && !_i)
        throw new TypeError("Object.keys called on a non-object");
      var Mi = Me && mi;
      if (Ei && fi.length > 0 && !t.call(fi, 0))
        for (var Oi = 0; Oi < fi.length; ++Oi)
          Si.push(String(Oi));
      if (_i && fi.length > 0)
        for (var Fi = 0; Fi < fi.length; ++Fi)
          Si.push(String(Fi));
      else
        for (var Ui in fi)
          !(Mi && Ui === "prototype") && t.call(fi, Ui) && Si.push(String(Ui));
      if (Te)
        for (var Pi = vn(fi), Bi = 0; Bi < Ue.length; ++Bi)
          !(Pi && Ue[Bi] === "constructor") && t.call(fi, Ue[Bi]) && Si.push(Ue[Bi]);
      return Si;
    };
  }
  return implementation = Ae, implementation;
}
var slice$1 = Array.prototype.slice, isArgs = isArguments, origKeys = Object.keys, keysShim = origKeys ? function(t) {
  return origKeys(t);
} : requireImplementation(), originalKeys = Object.keys;
keysShim.shim = function() {
  if (Object.keys) {
    var t = function() {
      var Ie = Object.keys(arguments);
      return Ie && Ie.length === arguments.length;
    }(1, 2);
    t || (Object.keys = function(Be) {
      return isArgs(Be) ? originalKeys(slice$1.call(Be)) : originalKeys(Be);
    });
  } else
    Object.keys = keysShim;
  return Object.keys || keysShim;
};
var objectKeys$1 = keysShim, elliptic = {};
const name = "elliptic", version$8 = "6.5.7", description = "EC cryptography", main = "lib/elliptic.js", files = [
  "lib"
], scripts = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author = "Fedor Indutny <fedor@indutny.com>", license = "MIT", bugs = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage = "https://github.com/indutny/elliptic", devDependencies = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0$3 = {
  name,
  version: version$8,
  description,
  main,
  files,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  dependencies
};
var utils$4 = {}, bn$2 = { exports: {} };
bn$2.exports;
var hasRequiredBn;
function requireBn() {
  return hasRequiredBn || (hasRequiredBn = 1, function(Ae) {
    (function(t, Ie) {
      function Be(zi, xi) {
        if (!zi) throw new Error(xi || "Assertion failed");
      }
      function Pe(zi, xi) {
        zi.super_ = xi;
        var $i = function() {
        };
        $i.prototype = xi.prototype, zi.prototype = new $i(), zi.prototype.constructor = zi;
      }
      function Te(zi, xi, $i) {
        if (Te.isBN(zi))
          return zi;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, zi !== null && ((xi === "le" || xi === "be") && ($i = xi, xi = 10), this._init(zi || 0, xi || 10, $i || "be"));
      }
      typeof t == "object" ? t.exports = Te : Ie.BN = Te, Te.BN = Te, Te.wordSize = 26;
      var Me;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? Me = window.Buffer : Me = require$$0$4.Buffer;
      } catch {
      }
      Te.isBN = function(xi) {
        return xi instanceof Te ? !0 : xi !== null && typeof xi == "object" && xi.constructor.wordSize === Te.wordSize && Array.isArray(xi.words);
      }, Te.max = function(xi, $i) {
        return xi.cmp($i) > 0 ? xi : $i;
      }, Te.min = function(xi, $i) {
        return xi.cmp($i) < 0 ? xi : $i;
      }, Te.prototype._init = function(xi, $i, vi) {
        if (typeof xi == "number")
          return this._initNumber(xi, $i, vi);
        if (typeof xi == "object")
          return this._initArray(xi, $i, vi);
        $i === "hex" && ($i = 16), Be($i === ($i | 0) && $i >= 2 && $i <= 36), xi = xi.toString().replace(/\s+/g, "");
        var wi = 0;
        xi[0] === "-" && (wi++, this.negative = 1), wi < xi.length && ($i === 16 ? this._parseHex(xi, wi, vi) : (this._parseBase(xi, $i, wi), vi === "le" && this._initArray(this.toArray(), $i, vi)));
      }, Te.prototype._initNumber = function(xi, $i, vi) {
        xi < 0 && (this.negative = 1, xi = -xi), xi < 67108864 ? (this.words = [xi & 67108863], this.length = 1) : xi < 4503599627370496 ? (this.words = [
          xi & 67108863,
          xi / 67108864 & 67108863
        ], this.length = 2) : (Be(xi < 9007199254740992), this.words = [
          xi & 67108863,
          xi / 67108864 & 67108863,
          1
        ], this.length = 3), vi === "le" && this._initArray(this.toArray(), $i, vi);
      }, Te.prototype._initArray = function(xi, $i, vi) {
        if (Be(typeof xi.length == "number"), xi.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(xi.length / 3), this.words = new Array(this.length);
        for (var wi = 0; wi < this.length; wi++)
          this.words[wi] = 0;
        var Ai, Ri, Ti = 0;
        if (vi === "be")
          for (wi = xi.length - 1, Ai = 0; wi >= 0; wi -= 3)
            Ri = xi[wi] | xi[wi - 1] << 8 | xi[wi - 2] << 16, this.words[Ai] |= Ri << Ti & 67108863, this.words[Ai + 1] = Ri >>> 26 - Ti & 67108863, Ti += 24, Ti >= 26 && (Ti -= 26, Ai++);
        else if (vi === "le")
          for (wi = 0, Ai = 0; wi < xi.length; wi += 3)
            Ri = xi[wi] | xi[wi + 1] << 8 | xi[wi + 2] << 16, this.words[Ai] |= Ri << Ti & 67108863, this.words[Ai + 1] = Ri >>> 26 - Ti & 67108863, Ti += 24, Ti >= 26 && (Ti -= 26, Ai++);
        return this.strip();
      };
      function Ue(zi, xi) {
        var $i = zi.charCodeAt(xi);
        return $i >= 65 && $i <= 70 ? $i - 55 : $i >= 97 && $i <= 102 ? $i - 87 : $i - 48 & 15;
      }
      function je(zi, xi, $i) {
        var vi = Ue(zi, $i);
        return $i - 1 >= xi && (vi |= Ue(zi, $i - 1) << 4), vi;
      }
      Te.prototype._parseHex = function(xi, $i, vi) {
        this.length = Math.ceil((xi.length - $i) / 6), this.words = new Array(this.length);
        for (var wi = 0; wi < this.length; wi++)
          this.words[wi] = 0;
        var Ai = 0, Ri = 0, Ti;
        if (vi === "be")
          for (wi = xi.length - 1; wi >= $i; wi -= 2)
            Ti = je(xi, $i, wi) << Ai, this.words[Ri] |= Ti & 67108863, Ai >= 18 ? (Ai -= 18, Ri += 1, this.words[Ri] |= Ti >>> 26) : Ai += 8;
        else {
          var Ci = xi.length - $i;
          for (wi = Ci % 2 === 0 ? $i + 1 : $i; wi < xi.length; wi += 2)
            Ti = je(xi, $i, wi) << Ai, this.words[Ri] |= Ti & 67108863, Ai >= 18 ? (Ai -= 18, Ri += 1, this.words[Ri] |= Ti >>> 26) : Ai += 8;
        }
        this.strip();
      };
      function fn(zi, xi, $i, vi) {
        for (var wi = 0, Ai = Math.min(zi.length, $i), Ri = xi; Ri < Ai; Ri++) {
          var Ti = zi.charCodeAt(Ri) - 48;
          wi *= vi, Ti >= 49 ? wi += Ti - 49 + 10 : Ti >= 17 ? wi += Ti - 17 + 10 : wi += Ti;
        }
        return wi;
      }
      Te.prototype._parseBase = function(xi, $i, vi) {
        this.words = [0], this.length = 1;
        for (var wi = 0, Ai = 1; Ai <= 67108863; Ai *= $i)
          wi++;
        wi--, Ai = Ai / $i | 0;
        for (var Ri = xi.length - vi, Ti = Ri % wi, Ci = Math.min(Ri, Ri - Ti) + vi, Ii = 0, Li = vi; Li < Ci; Li += wi)
          Ii = fn(xi, Li, Li + wi, $i), this.imuln(Ai), this.words[0] + Ii < 67108864 ? this.words[0] += Ii : this._iaddn(Ii);
        if (Ti !== 0) {
          var Ni = 1;
          for (Ii = fn(xi, Li, xi.length, $i), Li = 0; Li < Ti; Li++)
            Ni *= $i;
          this.imuln(Ni), this.words[0] + Ii < 67108864 ? this.words[0] += Ii : this._iaddn(Ii);
        }
        this.strip();
      }, Te.prototype.copy = function(xi) {
        xi.words = new Array(this.length);
        for (var $i = 0; $i < this.length; $i++)
          xi.words[$i] = this.words[$i];
        xi.length = this.length, xi.negative = this.negative, xi.red = this.red;
      }, Te.prototype.clone = function() {
        var xi = new Te(null);
        return this.copy(xi), xi;
      }, Te.prototype._expand = function(xi) {
        for (; this.length < xi; )
          this.words[this.length++] = 0;
        return this;
      }, Te.prototype.strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, Te.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, Te.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var Ve = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], vn = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], En = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      Te.prototype.toString = function(xi, $i) {
        xi = xi || 10, $i = $i | 0 || 1;
        var vi;
        if (xi === 16 || xi === "hex") {
          vi = "";
          for (var wi = 0, Ai = 0, Ri = 0; Ri < this.length; Ri++) {
            var Ti = this.words[Ri], Ci = ((Ti << wi | Ai) & 16777215).toString(16);
            Ai = Ti >>> 24 - wi & 16777215, Ai !== 0 || Ri !== this.length - 1 ? vi = Ve[6 - Ci.length] + Ci + vi : vi = Ci + vi, wi += 2, wi >= 26 && (wi -= 26, Ri--);
          }
          for (Ai !== 0 && (vi = Ai.toString(16) + vi); vi.length % $i !== 0; )
            vi = "0" + vi;
          return this.negative !== 0 && (vi = "-" + vi), vi;
        }
        if (xi === (xi | 0) && xi >= 2 && xi <= 36) {
          var Ii = vn[xi], Li = En[xi];
          vi = "";
          var Ni = this.clone();
          for (Ni.negative = 0; !Ni.isZero(); ) {
            var Vi = Ni.modn(Li).toString(xi);
            Ni = Ni.idivn(Li), Ni.isZero() ? vi = Vi + vi : vi = Ve[Ii - Vi.length] + Vi + vi;
          }
          for (this.isZero() && (vi = "0" + vi); vi.length % $i !== 0; )
            vi = "0" + vi;
          return this.negative !== 0 && (vi = "-" + vi), vi;
        }
        Be(!1, "Base should be between 2 and 36");
      }, Te.prototype.toNumber = function() {
        var xi = this.words[0];
        return this.length === 2 ? xi += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? xi += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && Be(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -xi : xi;
      }, Te.prototype.toJSON = function() {
        return this.toString(16);
      }, Te.prototype.toBuffer = function(xi, $i) {
        return Be(typeof Me < "u"), this.toArrayLike(Me, xi, $i);
      }, Te.prototype.toArray = function(xi, $i) {
        return this.toArrayLike(Array, xi, $i);
      }, Te.prototype.toArrayLike = function(xi, $i, vi) {
        var wi = this.byteLength(), Ai = vi || Math.max(1, wi);
        Be(wi <= Ai, "byte array longer than desired length"), Be(Ai > 0, "Requested array length <= 0"), this.strip();
        var Ri = $i === "le", Ti = new xi(Ai), Ci, Ii, Li = this.clone();
        if (Ri) {
          for (Ii = 0; !Li.isZero(); Ii++)
            Ci = Li.andln(255), Li.iushrn(8), Ti[Ii] = Ci;
          for (; Ii < Ai; Ii++)
            Ti[Ii] = 0;
        } else {
          for (Ii = 0; Ii < Ai - wi; Ii++)
            Ti[Ii] = 0;
          for (Ii = 0; !Li.isZero(); Ii++)
            Ci = Li.andln(255), Li.iushrn(8), Ti[Ai - Ii - 1] = Ci;
        }
        return Ti;
      }, Math.clz32 ? Te.prototype._countBits = function(xi) {
        return 32 - Math.clz32(xi);
      } : Te.prototype._countBits = function(xi) {
        var $i = xi, vi = 0;
        return $i >= 4096 && (vi += 13, $i >>>= 13), $i >= 64 && (vi += 7, $i >>>= 7), $i >= 8 && (vi += 4, $i >>>= 4), $i >= 2 && (vi += 2, $i >>>= 2), vi + $i;
      }, Te.prototype._zeroBits = function(xi) {
        if (xi === 0) return 26;
        var $i = xi, vi = 0;
        return $i & 8191 || (vi += 13, $i >>>= 13), $i & 127 || (vi += 7, $i >>>= 7), $i & 15 || (vi += 4, $i >>>= 4), $i & 3 || (vi += 2, $i >>>= 2), $i & 1 || vi++, vi;
      }, Te.prototype.bitLength = function() {
        var xi = this.words[this.length - 1], $i = this._countBits(xi);
        return (this.length - 1) * 26 + $i;
      };
      function fi(zi) {
        for (var xi = new Array(zi.bitLength()), $i = 0; $i < xi.length; $i++) {
          var vi = $i / 26 | 0, wi = $i % 26;
          xi[$i] = (zi.words[vi] & 1 << wi) >>> wi;
        }
        return xi;
      }
      Te.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var xi = 0, $i = 0; $i < this.length; $i++) {
          var vi = this._zeroBits(this.words[$i]);
          if (xi += vi, vi !== 26) break;
        }
        return xi;
      }, Te.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, Te.prototype.toTwos = function(xi) {
        return this.negative !== 0 ? this.abs().inotn(xi).iaddn(1) : this.clone();
      }, Te.prototype.fromTwos = function(xi) {
        return this.testn(xi - 1) ? this.notn(xi).iaddn(1).ineg() : this.clone();
      }, Te.prototype.isNeg = function() {
        return this.negative !== 0;
      }, Te.prototype.neg = function() {
        return this.clone().ineg();
      }, Te.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, Te.prototype.iuor = function(xi) {
        for (; this.length < xi.length; )
          this.words[this.length++] = 0;
        for (var $i = 0; $i < xi.length; $i++)
          this.words[$i] = this.words[$i] | xi.words[$i];
        return this.strip();
      }, Te.prototype.ior = function(xi) {
        return Be((this.negative | xi.negative) === 0), this.iuor(xi);
      }, Te.prototype.or = function(xi) {
        return this.length > xi.length ? this.clone().ior(xi) : xi.clone().ior(this);
      }, Te.prototype.uor = function(xi) {
        return this.length > xi.length ? this.clone().iuor(xi) : xi.clone().iuor(this);
      }, Te.prototype.iuand = function(xi) {
        var $i;
        this.length > xi.length ? $i = xi : $i = this;
        for (var vi = 0; vi < $i.length; vi++)
          this.words[vi] = this.words[vi] & xi.words[vi];
        return this.length = $i.length, this.strip();
      }, Te.prototype.iand = function(xi) {
        return Be((this.negative | xi.negative) === 0), this.iuand(xi);
      }, Te.prototype.and = function(xi) {
        return this.length > xi.length ? this.clone().iand(xi) : xi.clone().iand(this);
      }, Te.prototype.uand = function(xi) {
        return this.length > xi.length ? this.clone().iuand(xi) : xi.clone().iuand(this);
      }, Te.prototype.iuxor = function(xi) {
        var $i, vi;
        this.length > xi.length ? ($i = this, vi = xi) : ($i = xi, vi = this);
        for (var wi = 0; wi < vi.length; wi++)
          this.words[wi] = $i.words[wi] ^ vi.words[wi];
        if (this !== $i)
          for (; wi < $i.length; wi++)
            this.words[wi] = $i.words[wi];
        return this.length = $i.length, this.strip();
      }, Te.prototype.ixor = function(xi) {
        return Be((this.negative | xi.negative) === 0), this.iuxor(xi);
      }, Te.prototype.xor = function(xi) {
        return this.length > xi.length ? this.clone().ixor(xi) : xi.clone().ixor(this);
      }, Te.prototype.uxor = function(xi) {
        return this.length > xi.length ? this.clone().iuxor(xi) : xi.clone().iuxor(this);
      }, Te.prototype.inotn = function(xi) {
        Be(typeof xi == "number" && xi >= 0);
        var $i = Math.ceil(xi / 26) | 0, vi = xi % 26;
        this._expand($i), vi > 0 && $i--;
        for (var wi = 0; wi < $i; wi++)
          this.words[wi] = ~this.words[wi] & 67108863;
        return vi > 0 && (this.words[wi] = ~this.words[wi] & 67108863 >> 26 - vi), this.strip();
      }, Te.prototype.notn = function(xi) {
        return this.clone().inotn(xi);
      }, Te.prototype.setn = function(xi, $i) {
        Be(typeof xi == "number" && xi >= 0);
        var vi = xi / 26 | 0, wi = xi % 26;
        return this._expand(vi + 1), $i ? this.words[vi] = this.words[vi] | 1 << wi : this.words[vi] = this.words[vi] & ~(1 << wi), this.strip();
      }, Te.prototype.iadd = function(xi) {
        var $i;
        if (this.negative !== 0 && xi.negative === 0)
          return this.negative = 0, $i = this.isub(xi), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && xi.negative !== 0)
          return xi.negative = 0, $i = this.isub(xi), xi.negative = 1, $i._normSign();
        var vi, wi;
        this.length > xi.length ? (vi = this, wi = xi) : (vi = xi, wi = this);
        for (var Ai = 0, Ri = 0; Ri < wi.length; Ri++)
          $i = (vi.words[Ri] | 0) + (wi.words[Ri] | 0) + Ai, this.words[Ri] = $i & 67108863, Ai = $i >>> 26;
        for (; Ai !== 0 && Ri < vi.length; Ri++)
          $i = (vi.words[Ri] | 0) + Ai, this.words[Ri] = $i & 67108863, Ai = $i >>> 26;
        if (this.length = vi.length, Ai !== 0)
          this.words[this.length] = Ai, this.length++;
        else if (vi !== this)
          for (; Ri < vi.length; Ri++)
            this.words[Ri] = vi.words[Ri];
        return this;
      }, Te.prototype.add = function(xi) {
        var $i;
        return xi.negative !== 0 && this.negative === 0 ? (xi.negative = 0, $i = this.sub(xi), xi.negative ^= 1, $i) : xi.negative === 0 && this.negative !== 0 ? (this.negative = 0, $i = xi.sub(this), this.negative = 1, $i) : this.length > xi.length ? this.clone().iadd(xi) : xi.clone().iadd(this);
      }, Te.prototype.isub = function(xi) {
        if (xi.negative !== 0) {
          xi.negative = 0;
          var $i = this.iadd(xi);
          return xi.negative = 1, $i._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(xi), this.negative = 1, this._normSign();
        var vi = this.cmp(xi);
        if (vi === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var wi, Ai;
        vi > 0 ? (wi = this, Ai = xi) : (wi = xi, Ai = this);
        for (var Ri = 0, Ti = 0; Ti < Ai.length; Ti++)
          $i = (wi.words[Ti] | 0) - (Ai.words[Ti] | 0) + Ri, Ri = $i >> 26, this.words[Ti] = $i & 67108863;
        for (; Ri !== 0 && Ti < wi.length; Ti++)
          $i = (wi.words[Ti] | 0) + Ri, Ri = $i >> 26, this.words[Ti] = $i & 67108863;
        if (Ri === 0 && Ti < wi.length && wi !== this)
          for (; Ti < wi.length; Ti++)
            this.words[Ti] = wi.words[Ti];
        return this.length = Math.max(this.length, Ti), wi !== this && (this.negative = 1), this.strip();
      }, Te.prototype.sub = function(xi) {
        return this.clone().isub(xi);
      };
      function bi(zi, xi, $i) {
        $i.negative = xi.negative ^ zi.negative;
        var vi = zi.length + xi.length | 0;
        $i.length = vi, vi = vi - 1 | 0;
        var wi = zi.words[0] | 0, Ai = xi.words[0] | 0, Ri = wi * Ai, Ti = Ri & 67108863, Ci = Ri / 67108864 | 0;
        $i.words[0] = Ti;
        for (var Ii = 1; Ii < vi; Ii++) {
          for (var Li = Ci >>> 26, Ni = Ci & 67108863, Vi = Math.min(Ii, xi.length - 1), is = Math.max(0, Ii - zi.length + 1); is <= Vi; is++) {
            var Ki = Ii - is | 0;
            wi = zi.words[Ki] | 0, Ai = xi.words[is] | 0, Ri = wi * Ai + Ni, Li += Ri / 67108864 | 0, Ni = Ri & 67108863;
          }
          $i.words[Ii] = Ni | 0, Ci = Li | 0;
        }
        return Ci !== 0 ? $i.words[Ii] = Ci | 0 : $i.length--, $i.strip();
      }
      var mi = function(xi, $i, vi) {
        var wi = xi.words, Ai = $i.words, Ri = vi.words, Ti = 0, Ci, Ii, Li, Ni = wi[0] | 0, Vi = Ni & 8191, is = Ni >>> 13, Ki = wi[1] | 0, ts = Ki & 8191, qi = Ki >>> 13, Hi = wi[2] | 0, Xi = Hi & 8191, ki = Hi >>> 13, Wi = wi[3] | 0, Yi = Wi & 8191, Qi = Wi >>> 13, ns = wi[4] | 0, us = ns & 8191, ps = ns >>> 13, Ds = wi[5] | 0, Eo = Ds & 8191, hs = Ds >>> 13, So = wi[6] | 0, _o = So & 8191, vo = So >>> 13, Ro = wi[7] | 0, $o = Ro & 8191, Io = Ro >>> 13, To = wi[8] | 0, Ao = To & 8191, Po = To >>> 13, Co = wi[9] | 0, rs = Co & 8191, Gi = Co >>> 13, Ji = Ai[0] | 0, ss = Ji & 8191, ls = Ji >>> 13, ds = Ai[1] | 0, bs = ds & 8191, Mo = ds >>> 13, Fo = Ai[2] | 0, Bo = Fo & 8191, Uo = Fo >>> 13, Lo = Ai[3] | 0, Go = Lo & 8191, Yo = Lo >>> 13, Ko = Ai[4] | 0, No = Ko & 8191, Wo = Ko >>> 13, os = Ai[5] | 0, as = os & 8191, go = os >>> 13, bo = Ai[6] | 0, wo = bo & 8191, qo = bo >>> 13, jo = Ai[7] | 0, Oo = jo & 8191, Ho = jo >>> 13, zo = Ai[8] | 0, Do = zo & 8191, Xo = zo >>> 13, na = Ai[9] | 0, Vo = na & 8191, ra = na >>> 13;
        vi.negative = xi.negative ^ $i.negative, vi.length = 19, Ci = Math.imul(Vi, ss), Ii = Math.imul(Vi, ls), Ii = Ii + Math.imul(is, ss) | 0, Li = Math.imul(is, ls);
        var Zo = (Ti + Ci | 0) + ((Ii & 8191) << 13) | 0;
        Ti = (Li + (Ii >>> 13) | 0) + (Zo >>> 26) | 0, Zo &= 67108863, Ci = Math.imul(ts, ss), Ii = Math.imul(ts, ls), Ii = Ii + Math.imul(qi, ss) | 0, Li = Math.imul(qi, ls), Ci = Ci + Math.imul(Vi, bs) | 0, Ii = Ii + Math.imul(Vi, Mo) | 0, Ii = Ii + Math.imul(is, bs) | 0, Li = Li + Math.imul(is, Mo) | 0;
        var ta = (Ti + Ci | 0) + ((Ii & 8191) << 13) | 0;
        Ti = (Li + (Ii >>> 13) | 0) + (ta >>> 26) | 0, ta &= 67108863, Ci = Math.imul(Xi, ss), Ii = Math.imul(Xi, ls), Ii = Ii + Math.imul(ki, ss) | 0, Li = Math.imul(ki, ls), Ci = Ci + Math.imul(ts, bs) | 0, Ii = Ii + Math.imul(ts, Mo) | 0, Ii = Ii + Math.imul(qi, bs) | 0, Li = Li + Math.imul(qi, Mo) | 0, Ci = Ci + Math.imul(Vi, Bo) | 0, Ii = Ii + Math.imul(Vi, Uo) | 0, Ii = Ii + Math.imul(is, Bo) | 0, Li = Li + Math.imul(is, Uo) | 0;
        var ca = (Ti + Ci | 0) + ((Ii & 8191) << 13) | 0;
        Ti = (Li + (Ii >>> 13) | 0) + (ca >>> 26) | 0, ca &= 67108863, Ci = Math.imul(Yi, ss), Ii = Math.imul(Yi, ls), Ii = Ii + Math.imul(Qi, ss) | 0, Li = Math.imul(Qi, ls), Ci = Ci + Math.imul(Xi, bs) | 0, Ii = Ii + Math.imul(Xi, Mo) | 0, Ii = Ii + Math.imul(ki, bs) | 0, Li = Li + Math.imul(ki, Mo) | 0, Ci = Ci + Math.imul(ts, Bo) | 0, Ii = Ii + Math.imul(ts, Uo) | 0, Ii = Ii + Math.imul(qi, Bo) | 0, Li = Li + Math.imul(qi, Uo) | 0, Ci = Ci + Math.imul(Vi, Go) | 0, Ii = Ii + Math.imul(Vi, Yo) | 0, Ii = Ii + Math.imul(is, Go) | 0, Li = Li + Math.imul(is, Yo) | 0;
        var oa = (Ti + Ci | 0) + ((Ii & 8191) << 13) | 0;
        Ti = (Li + (Ii >>> 13) | 0) + (oa >>> 26) | 0, oa &= 67108863, Ci = Math.imul(us, ss), Ii = Math.imul(us, ls), Ii = Ii + Math.imul(ps, ss) | 0, Li = Math.imul(ps, ls), Ci = Ci + Math.imul(Yi, bs) | 0, Ii = Ii + Math.imul(Yi, Mo) | 0, Ii = Ii + Math.imul(Qi, bs) | 0, Li = Li + Math.imul(Qi, Mo) | 0, Ci = Ci + Math.imul(Xi, Bo) | 0, Ii = Ii + Math.imul(Xi, Uo) | 0, Ii = Ii + Math.imul(ki, Bo) | 0, Li = Li + Math.imul(ki, Uo) | 0, Ci = Ci + Math.imul(ts, Go) | 0, Ii = Ii + Math.imul(ts, Yo) | 0, Ii = Ii + Math.imul(qi, Go) | 0, Li = Li + Math.imul(qi, Yo) | 0, Ci = Ci + Math.imul(Vi, No) | 0, Ii = Ii + Math.imul(Vi, Wo) | 0, Ii = Ii + Math.imul(is, No) | 0, Li = Li + Math.imul(is, Wo) | 0;
        var ga = (Ti + Ci | 0) + ((Ii & 8191) << 13) | 0;
        Ti = (Li + (Ii >>> 13) | 0) + (ga >>> 26) | 0, ga &= 67108863, Ci = Math.imul(Eo, ss), Ii = Math.imul(Eo, ls), Ii = Ii + Math.imul(hs, ss) | 0, Li = Math.imul(hs, ls), Ci = Ci + Math.imul(us, bs) | 0, Ii = Ii + Math.imul(us, Mo) | 0, Ii = Ii + Math.imul(ps, bs) | 0, Li = Li + Math.imul(ps, Mo) | 0, Ci = Ci + Math.imul(Yi, Bo) | 0, Ii = Ii + Math.imul(Yi, Uo) | 0, Ii = Ii + Math.imul(Qi, Bo) | 0, Li = Li + Math.imul(Qi, Uo) | 0, Ci = Ci + Math.imul(Xi, Go) | 0, Ii = Ii + Math.imul(Xi, Yo) | 0, Ii = Ii + Math.imul(ki, Go) | 0, Li = Li + Math.imul(ki, Yo) | 0, Ci = Ci + Math.imul(ts, No) | 0, Ii = Ii + Math.imul(ts, Wo) | 0, Ii = Ii + Math.imul(qi, No) | 0, Li = Li + Math.imul(qi, Wo) | 0, Ci = Ci + Math.imul(Vi, as) | 0, Ii = Ii + Math.imul(Vi, go) | 0, Ii = Ii + Math.imul(is, as) | 0, Li = Li + Math.imul(is, go) | 0;
        var ba = (Ti + Ci | 0) + ((Ii & 8191) << 13) | 0;
        Ti = (Li + (Ii >>> 13) | 0) + (ba >>> 26) | 0, ba &= 67108863, Ci = Math.imul(_o, ss), Ii = Math.imul(_o, ls), Ii = Ii + Math.imul(vo, ss) | 0, Li = Math.imul(vo, ls), Ci = Ci + Math.imul(Eo, bs) | 0, Ii = Ii + Math.imul(Eo, Mo) | 0, Ii = Ii + Math.imul(hs, bs) | 0, Li = Li + Math.imul(hs, Mo) | 0, Ci = Ci + Math.imul(us, Bo) | 0, Ii = Ii + Math.imul(us, Uo) | 0, Ii = Ii + Math.imul(ps, Bo) | 0, Li = Li + Math.imul(ps, Uo) | 0, Ci = Ci + Math.imul(Yi, Go) | 0, Ii = Ii + Math.imul(Yi, Yo) | 0, Ii = Ii + Math.imul(Qi, Go) | 0, Li = Li + Math.imul(Qi, Yo) | 0, Ci = Ci + Math.imul(Xi, No) | 0, Ii = Ii + Math.imul(Xi, Wo) | 0, Ii = Ii + Math.imul(ki, No) | 0, Li = Li + Math.imul(ki, Wo) | 0, Ci = Ci + Math.imul(ts, as) | 0, Ii = Ii + Math.imul(ts, go) | 0, Ii = Ii + Math.imul(qi, as) | 0, Li = Li + Math.imul(qi, go) | 0, Ci = Ci + Math.imul(Vi, wo) | 0, Ii = Ii + Math.imul(Vi, qo) | 0, Ii = Ii + Math.imul(is, wo) | 0, Li = Li + Math.imul(is, qo) | 0;
        var ua = (Ti + Ci | 0) + ((Ii & 8191) << 13) | 0;
        Ti = (Li + (Ii >>> 13) | 0) + (ua >>> 26) | 0, ua &= 67108863, Ci = Math.imul($o, ss), Ii = Math.imul($o, ls), Ii = Ii + Math.imul(Io, ss) | 0, Li = Math.imul(Io, ls), Ci = Ci + Math.imul(_o, bs) | 0, Ii = Ii + Math.imul(_o, Mo) | 0, Ii = Ii + Math.imul(vo, bs) | 0, Li = Li + Math.imul(vo, Mo) | 0, Ci = Ci + Math.imul(Eo, Bo) | 0, Ii = Ii + Math.imul(Eo, Uo) | 0, Ii = Ii + Math.imul(hs, Bo) | 0, Li = Li + Math.imul(hs, Uo) | 0, Ci = Ci + Math.imul(us, Go) | 0, Ii = Ii + Math.imul(us, Yo) | 0, Ii = Ii + Math.imul(ps, Go) | 0, Li = Li + Math.imul(ps, Yo) | 0, Ci = Ci + Math.imul(Yi, No) | 0, Ii = Ii + Math.imul(Yi, Wo) | 0, Ii = Ii + Math.imul(Qi, No) | 0, Li = Li + Math.imul(Qi, Wo) | 0, Ci = Ci + Math.imul(Xi, as) | 0, Ii = Ii + Math.imul(Xi, go) | 0, Ii = Ii + Math.imul(ki, as) | 0, Li = Li + Math.imul(ki, go) | 0, Ci = Ci + Math.imul(ts, wo) | 0, Ii = Ii + Math.imul(ts, qo) | 0, Ii = Ii + Math.imul(qi, wo) | 0, Li = Li + Math.imul(qi, qo) | 0, Ci = Ci + Math.imul(Vi, Oo) | 0, Ii = Ii + Math.imul(Vi, Ho) | 0, Ii = Ii + Math.imul(is, Oo) | 0, Li = Li + Math.imul(is, Ho) | 0;
        var Aa = (Ti + Ci | 0) + ((Ii & 8191) << 13) | 0;
        Ti = (Li + (Ii >>> 13) | 0) + (Aa >>> 26) | 0, Aa &= 67108863, Ci = Math.imul(Ao, ss), Ii = Math.imul(Ao, ls), Ii = Ii + Math.imul(Po, ss) | 0, Li = Math.imul(Po, ls), Ci = Ci + Math.imul($o, bs) | 0, Ii = Ii + Math.imul($o, Mo) | 0, Ii = Ii + Math.imul(Io, bs) | 0, Li = Li + Math.imul(Io, Mo) | 0, Ci = Ci + Math.imul(_o, Bo) | 0, Ii = Ii + Math.imul(_o, Uo) | 0, Ii = Ii + Math.imul(vo, Bo) | 0, Li = Li + Math.imul(vo, Uo) | 0, Ci = Ci + Math.imul(Eo, Go) | 0, Ii = Ii + Math.imul(Eo, Yo) | 0, Ii = Ii + Math.imul(hs, Go) | 0, Li = Li + Math.imul(hs, Yo) | 0, Ci = Ci + Math.imul(us, No) | 0, Ii = Ii + Math.imul(us, Wo) | 0, Ii = Ii + Math.imul(ps, No) | 0, Li = Li + Math.imul(ps, Wo) | 0, Ci = Ci + Math.imul(Yi, as) | 0, Ii = Ii + Math.imul(Yi, go) | 0, Ii = Ii + Math.imul(Qi, as) | 0, Li = Li + Math.imul(Qi, go) | 0, Ci = Ci + Math.imul(Xi, wo) | 0, Ii = Ii + Math.imul(Xi, qo) | 0, Ii = Ii + Math.imul(ki, wo) | 0, Li = Li + Math.imul(ki, qo) | 0, Ci = Ci + Math.imul(ts, Oo) | 0, Ii = Ii + Math.imul(ts, Ho) | 0, Ii = Ii + Math.imul(qi, Oo) | 0, Li = Li + Math.imul(qi, Ho) | 0, Ci = Ci + Math.imul(Vi, Do) | 0, Ii = Ii + Math.imul(Vi, Xo) | 0, Ii = Ii + Math.imul(is, Do) | 0, Li = Li + Math.imul(is, Xo) | 0;
        var Ra = (Ti + Ci | 0) + ((Ii & 8191) << 13) | 0;
        Ti = (Li + (Ii >>> 13) | 0) + (Ra >>> 26) | 0, Ra &= 67108863, Ci = Math.imul(rs, ss), Ii = Math.imul(rs, ls), Ii = Ii + Math.imul(Gi, ss) | 0, Li = Math.imul(Gi, ls), Ci = Ci + Math.imul(Ao, bs) | 0, Ii = Ii + Math.imul(Ao, Mo) | 0, Ii = Ii + Math.imul(Po, bs) | 0, Li = Li + Math.imul(Po, Mo) | 0, Ci = Ci + Math.imul($o, Bo) | 0, Ii = Ii + Math.imul($o, Uo) | 0, Ii = Ii + Math.imul(Io, Bo) | 0, Li = Li + Math.imul(Io, Uo) | 0, Ci = Ci + Math.imul(_o, Go) | 0, Ii = Ii + Math.imul(_o, Yo) | 0, Ii = Ii + Math.imul(vo, Go) | 0, Li = Li + Math.imul(vo, Yo) | 0, Ci = Ci + Math.imul(Eo, No) | 0, Ii = Ii + Math.imul(Eo, Wo) | 0, Ii = Ii + Math.imul(hs, No) | 0, Li = Li + Math.imul(hs, Wo) | 0, Ci = Ci + Math.imul(us, as) | 0, Ii = Ii + Math.imul(us, go) | 0, Ii = Ii + Math.imul(ps, as) | 0, Li = Li + Math.imul(ps, go) | 0, Ci = Ci + Math.imul(Yi, wo) | 0, Ii = Ii + Math.imul(Yi, qo) | 0, Ii = Ii + Math.imul(Qi, wo) | 0, Li = Li + Math.imul(Qi, qo) | 0, Ci = Ci + Math.imul(Xi, Oo) | 0, Ii = Ii + Math.imul(Xi, Ho) | 0, Ii = Ii + Math.imul(ki, Oo) | 0, Li = Li + Math.imul(ki, Ho) | 0, Ci = Ci + Math.imul(ts, Do) | 0, Ii = Ii + Math.imul(ts, Xo) | 0, Ii = Ii + Math.imul(qi, Do) | 0, Li = Li + Math.imul(qi, Xo) | 0, Ci = Ci + Math.imul(Vi, Vo) | 0, Ii = Ii + Math.imul(Vi, ra) | 0, Ii = Ii + Math.imul(is, Vo) | 0, Li = Li + Math.imul(is, ra) | 0;
        var Ia = (Ti + Ci | 0) + ((Ii & 8191) << 13) | 0;
        Ti = (Li + (Ii >>> 13) | 0) + (Ia >>> 26) | 0, Ia &= 67108863, Ci = Math.imul(rs, bs), Ii = Math.imul(rs, Mo), Ii = Ii + Math.imul(Gi, bs) | 0, Li = Math.imul(Gi, Mo), Ci = Ci + Math.imul(Ao, Bo) | 0, Ii = Ii + Math.imul(Ao, Uo) | 0, Ii = Ii + Math.imul(Po, Bo) | 0, Li = Li + Math.imul(Po, Uo) | 0, Ci = Ci + Math.imul($o, Go) | 0, Ii = Ii + Math.imul($o, Yo) | 0, Ii = Ii + Math.imul(Io, Go) | 0, Li = Li + Math.imul(Io, Yo) | 0, Ci = Ci + Math.imul(_o, No) | 0, Ii = Ii + Math.imul(_o, Wo) | 0, Ii = Ii + Math.imul(vo, No) | 0, Li = Li + Math.imul(vo, Wo) | 0, Ci = Ci + Math.imul(Eo, as) | 0, Ii = Ii + Math.imul(Eo, go) | 0, Ii = Ii + Math.imul(hs, as) | 0, Li = Li + Math.imul(hs, go) | 0, Ci = Ci + Math.imul(us, wo) | 0, Ii = Ii + Math.imul(us, qo) | 0, Ii = Ii + Math.imul(ps, wo) | 0, Li = Li + Math.imul(ps, qo) | 0, Ci = Ci + Math.imul(Yi, Oo) | 0, Ii = Ii + Math.imul(Yi, Ho) | 0, Ii = Ii + Math.imul(Qi, Oo) | 0, Li = Li + Math.imul(Qi, Ho) | 0, Ci = Ci + Math.imul(Xi, Do) | 0, Ii = Ii + Math.imul(Xi, Xo) | 0, Ii = Ii + Math.imul(ki, Do) | 0, Li = Li + Math.imul(ki, Xo) | 0, Ci = Ci + Math.imul(ts, Vo) | 0, Ii = Ii + Math.imul(ts, ra) | 0, Ii = Ii + Math.imul(qi, Vo) | 0, Li = Li + Math.imul(qi, ra) | 0;
        var Ba = (Ti + Ci | 0) + ((Ii & 8191) << 13) | 0;
        Ti = (Li + (Ii >>> 13) | 0) + (Ba >>> 26) | 0, Ba &= 67108863, Ci = Math.imul(rs, Bo), Ii = Math.imul(rs, Uo), Ii = Ii + Math.imul(Gi, Bo) | 0, Li = Math.imul(Gi, Uo), Ci = Ci + Math.imul(Ao, Go) | 0, Ii = Ii + Math.imul(Ao, Yo) | 0, Ii = Ii + Math.imul(Po, Go) | 0, Li = Li + Math.imul(Po, Yo) | 0, Ci = Ci + Math.imul($o, No) | 0, Ii = Ii + Math.imul($o, Wo) | 0, Ii = Ii + Math.imul(Io, No) | 0, Li = Li + Math.imul(Io, Wo) | 0, Ci = Ci + Math.imul(_o, as) | 0, Ii = Ii + Math.imul(_o, go) | 0, Ii = Ii + Math.imul(vo, as) | 0, Li = Li + Math.imul(vo, go) | 0, Ci = Ci + Math.imul(Eo, wo) | 0, Ii = Ii + Math.imul(Eo, qo) | 0, Ii = Ii + Math.imul(hs, wo) | 0, Li = Li + Math.imul(hs, qo) | 0, Ci = Ci + Math.imul(us, Oo) | 0, Ii = Ii + Math.imul(us, Ho) | 0, Ii = Ii + Math.imul(ps, Oo) | 0, Li = Li + Math.imul(ps, Ho) | 0, Ci = Ci + Math.imul(Yi, Do) | 0, Ii = Ii + Math.imul(Yi, Xo) | 0, Ii = Ii + Math.imul(Qi, Do) | 0, Li = Li + Math.imul(Qi, Xo) | 0, Ci = Ci + Math.imul(Xi, Vo) | 0, Ii = Ii + Math.imul(Xi, ra) | 0, Ii = Ii + Math.imul(ki, Vo) | 0, Li = Li + Math.imul(ki, ra) | 0;
        var Pa = (Ti + Ci | 0) + ((Ii & 8191) << 13) | 0;
        Ti = (Li + (Ii >>> 13) | 0) + (Pa >>> 26) | 0, Pa &= 67108863, Ci = Math.imul(rs, Go), Ii = Math.imul(rs, Yo), Ii = Ii + Math.imul(Gi, Go) | 0, Li = Math.imul(Gi, Yo), Ci = Ci + Math.imul(Ao, No) | 0, Ii = Ii + Math.imul(Ao, Wo) | 0, Ii = Ii + Math.imul(Po, No) | 0, Li = Li + Math.imul(Po, Wo) | 0, Ci = Ci + Math.imul($o, as) | 0, Ii = Ii + Math.imul($o, go) | 0, Ii = Ii + Math.imul(Io, as) | 0, Li = Li + Math.imul(Io, go) | 0, Ci = Ci + Math.imul(_o, wo) | 0, Ii = Ii + Math.imul(_o, qo) | 0, Ii = Ii + Math.imul(vo, wo) | 0, Li = Li + Math.imul(vo, qo) | 0, Ci = Ci + Math.imul(Eo, Oo) | 0, Ii = Ii + Math.imul(Eo, Ho) | 0, Ii = Ii + Math.imul(hs, Oo) | 0, Li = Li + Math.imul(hs, Ho) | 0, Ci = Ci + Math.imul(us, Do) | 0, Ii = Ii + Math.imul(us, Xo) | 0, Ii = Ii + Math.imul(ps, Do) | 0, Li = Li + Math.imul(ps, Xo) | 0, Ci = Ci + Math.imul(Yi, Vo) | 0, Ii = Ii + Math.imul(Yi, ra) | 0, Ii = Ii + Math.imul(Qi, Vo) | 0, Li = Li + Math.imul(Qi, ra) | 0;
        var va = (Ti + Ci | 0) + ((Ii & 8191) << 13) | 0;
        Ti = (Li + (Ii >>> 13) | 0) + (va >>> 26) | 0, va &= 67108863, Ci = Math.imul(rs, No), Ii = Math.imul(rs, Wo), Ii = Ii + Math.imul(Gi, No) | 0, Li = Math.imul(Gi, Wo), Ci = Ci + Math.imul(Ao, as) | 0, Ii = Ii + Math.imul(Ao, go) | 0, Ii = Ii + Math.imul(Po, as) | 0, Li = Li + Math.imul(Po, go) | 0, Ci = Ci + Math.imul($o, wo) | 0, Ii = Ii + Math.imul($o, qo) | 0, Ii = Ii + Math.imul(Io, wo) | 0, Li = Li + Math.imul(Io, qo) | 0, Ci = Ci + Math.imul(_o, Oo) | 0, Ii = Ii + Math.imul(_o, Ho) | 0, Ii = Ii + Math.imul(vo, Oo) | 0, Li = Li + Math.imul(vo, Ho) | 0, Ci = Ci + Math.imul(Eo, Do) | 0, Ii = Ii + Math.imul(Eo, Xo) | 0, Ii = Ii + Math.imul(hs, Do) | 0, Li = Li + Math.imul(hs, Xo) | 0, Ci = Ci + Math.imul(us, Vo) | 0, Ii = Ii + Math.imul(us, ra) | 0, Ii = Ii + Math.imul(ps, Vo) | 0, Li = Li + Math.imul(ps, ra) | 0;
        var Ta = (Ti + Ci | 0) + ((Ii & 8191) << 13) | 0;
        Ti = (Li + (Ii >>> 13) | 0) + (Ta >>> 26) | 0, Ta &= 67108863, Ci = Math.imul(rs, as), Ii = Math.imul(rs, go), Ii = Ii + Math.imul(Gi, as) | 0, Li = Math.imul(Gi, go), Ci = Ci + Math.imul(Ao, wo) | 0, Ii = Ii + Math.imul(Ao, qo) | 0, Ii = Ii + Math.imul(Po, wo) | 0, Li = Li + Math.imul(Po, qo) | 0, Ci = Ci + Math.imul($o, Oo) | 0, Ii = Ii + Math.imul($o, Ho) | 0, Ii = Ii + Math.imul(Io, Oo) | 0, Li = Li + Math.imul(Io, Ho) | 0, Ci = Ci + Math.imul(_o, Do) | 0, Ii = Ii + Math.imul(_o, Xo) | 0, Ii = Ii + Math.imul(vo, Do) | 0, Li = Li + Math.imul(vo, Xo) | 0, Ci = Ci + Math.imul(Eo, Vo) | 0, Ii = Ii + Math.imul(Eo, ra) | 0, Ii = Ii + Math.imul(hs, Vo) | 0, Li = Li + Math.imul(hs, ra) | 0;
        var Ma = (Ti + Ci | 0) + ((Ii & 8191) << 13) | 0;
        Ti = (Li + (Ii >>> 13) | 0) + (Ma >>> 26) | 0, Ma &= 67108863, Ci = Math.imul(rs, wo), Ii = Math.imul(rs, qo), Ii = Ii + Math.imul(Gi, wo) | 0, Li = Math.imul(Gi, qo), Ci = Ci + Math.imul(Ao, Oo) | 0, Ii = Ii + Math.imul(Ao, Ho) | 0, Ii = Ii + Math.imul(Po, Oo) | 0, Li = Li + Math.imul(Po, Ho) | 0, Ci = Ci + Math.imul($o, Do) | 0, Ii = Ii + Math.imul($o, Xo) | 0, Ii = Ii + Math.imul(Io, Do) | 0, Li = Li + Math.imul(Io, Xo) | 0, Ci = Ci + Math.imul(_o, Vo) | 0, Ii = Ii + Math.imul(_o, ra) | 0, Ii = Ii + Math.imul(vo, Vo) | 0, Li = Li + Math.imul(vo, ra) | 0;
        var ha = (Ti + Ci | 0) + ((Ii & 8191) << 13) | 0;
        Ti = (Li + (Ii >>> 13) | 0) + (ha >>> 26) | 0, ha &= 67108863, Ci = Math.imul(rs, Oo), Ii = Math.imul(rs, Ho), Ii = Ii + Math.imul(Gi, Oo) | 0, Li = Math.imul(Gi, Ho), Ci = Ci + Math.imul(Ao, Do) | 0, Ii = Ii + Math.imul(Ao, Xo) | 0, Ii = Ii + Math.imul(Po, Do) | 0, Li = Li + Math.imul(Po, Xo) | 0, Ci = Ci + Math.imul($o, Vo) | 0, Ii = Ii + Math.imul($o, ra) | 0, Ii = Ii + Math.imul(Io, Vo) | 0, Li = Li + Math.imul(Io, ra) | 0;
        var Ca = (Ti + Ci | 0) + ((Ii & 8191) << 13) | 0;
        Ti = (Li + (Ii >>> 13) | 0) + (Ca >>> 26) | 0, Ca &= 67108863, Ci = Math.imul(rs, Do), Ii = Math.imul(rs, Xo), Ii = Ii + Math.imul(Gi, Do) | 0, Li = Math.imul(Gi, Xo), Ci = Ci + Math.imul(Ao, Vo) | 0, Ii = Ii + Math.imul(Ao, ra) | 0, Ii = Ii + Math.imul(Po, Vo) | 0, Li = Li + Math.imul(Po, ra) | 0;
        var Na = (Ti + Ci | 0) + ((Ii & 8191) << 13) | 0;
        Ti = (Li + (Ii >>> 13) | 0) + (Na >>> 26) | 0, Na &= 67108863, Ci = Math.imul(rs, Vo), Ii = Math.imul(rs, ra), Ii = Ii + Math.imul(Gi, Vo) | 0, Li = Math.imul(Gi, ra);
        var Oa = (Ti + Ci | 0) + ((Ii & 8191) << 13) | 0;
        return Ti = (Li + (Ii >>> 13) | 0) + (Oa >>> 26) | 0, Oa &= 67108863, Ri[0] = Zo, Ri[1] = ta, Ri[2] = ca, Ri[3] = oa, Ri[4] = ga, Ri[5] = ba, Ri[6] = ua, Ri[7] = Aa, Ri[8] = Ra, Ri[9] = Ia, Ri[10] = Ba, Ri[11] = Pa, Ri[12] = va, Ri[13] = Ta, Ri[14] = Ma, Ri[15] = ha, Ri[16] = Ca, Ri[17] = Na, Ri[18] = Oa, Ti !== 0 && (Ri[19] = Ti, vi.length++), vi;
      };
      Math.imul || (mi = bi);
      function _i(zi, xi, $i) {
        $i.negative = xi.negative ^ zi.negative, $i.length = zi.length + xi.length;
        for (var vi = 0, wi = 0, Ai = 0; Ai < $i.length - 1; Ai++) {
          var Ri = wi;
          wi = 0;
          for (var Ti = vi & 67108863, Ci = Math.min(Ai, xi.length - 1), Ii = Math.max(0, Ai - zi.length + 1); Ii <= Ci; Ii++) {
            var Li = Ai - Ii, Ni = zi.words[Li] | 0, Vi = xi.words[Ii] | 0, is = Ni * Vi, Ki = is & 67108863;
            Ri = Ri + (is / 67108864 | 0) | 0, Ki = Ki + Ti | 0, Ti = Ki & 67108863, Ri = Ri + (Ki >>> 26) | 0, wi += Ri >>> 26, Ri &= 67108863;
          }
          $i.words[Ai] = Ti, vi = Ri, Ri = wi;
        }
        return vi !== 0 ? $i.words[Ai] = vi : $i.length--, $i.strip();
      }
      function Ei(zi, xi, $i) {
        var vi = new Si();
        return vi.mulp(zi, xi, $i);
      }
      Te.prototype.mulTo = function(xi, $i) {
        var vi, wi = this.length + xi.length;
        return this.length === 10 && xi.length === 10 ? vi = mi(this, xi, $i) : wi < 63 ? vi = bi(this, xi, $i) : wi < 1024 ? vi = _i(this, xi, $i) : vi = Ei(this, xi, $i), vi;
      };
      function Si(zi, xi) {
        this.x = zi, this.y = xi;
      }
      Si.prototype.makeRBT = function(xi) {
        for (var $i = new Array(xi), vi = Te.prototype._countBits(xi) - 1, wi = 0; wi < xi; wi++)
          $i[wi] = this.revBin(wi, vi, xi);
        return $i;
      }, Si.prototype.revBin = function(xi, $i, vi) {
        if (xi === 0 || xi === vi - 1) return xi;
        for (var wi = 0, Ai = 0; Ai < $i; Ai++)
          wi |= (xi & 1) << $i - Ai - 1, xi >>= 1;
        return wi;
      }, Si.prototype.permute = function(xi, $i, vi, wi, Ai, Ri) {
        for (var Ti = 0; Ti < Ri; Ti++)
          wi[Ti] = $i[xi[Ti]], Ai[Ti] = vi[xi[Ti]];
      }, Si.prototype.transform = function(xi, $i, vi, wi, Ai, Ri) {
        this.permute(Ri, xi, $i, vi, wi, Ai);
        for (var Ti = 1; Ti < Ai; Ti <<= 1)
          for (var Ci = Ti << 1, Ii = Math.cos(2 * Math.PI / Ci), Li = Math.sin(2 * Math.PI / Ci), Ni = 0; Ni < Ai; Ni += Ci)
            for (var Vi = Ii, is = Li, Ki = 0; Ki < Ti; Ki++) {
              var ts = vi[Ni + Ki], qi = wi[Ni + Ki], Hi = vi[Ni + Ki + Ti], Xi = wi[Ni + Ki + Ti], ki = Vi * Hi - is * Xi;
              Xi = Vi * Xi + is * Hi, Hi = ki, vi[Ni + Ki] = ts + Hi, wi[Ni + Ki] = qi + Xi, vi[Ni + Ki + Ti] = ts - Hi, wi[Ni + Ki + Ti] = qi - Xi, Ki !== Ci && (ki = Ii * Vi - Li * is, is = Ii * is + Li * Vi, Vi = ki);
            }
      }, Si.prototype.guessLen13b = function(xi, $i) {
        var vi = Math.max($i, xi) | 1, wi = vi & 1, Ai = 0;
        for (vi = vi / 2 | 0; vi; vi = vi >>> 1)
          Ai++;
        return 1 << Ai + 1 + wi;
      }, Si.prototype.conjugate = function(xi, $i, vi) {
        if (!(vi <= 1))
          for (var wi = 0; wi < vi / 2; wi++) {
            var Ai = xi[wi];
            xi[wi] = xi[vi - wi - 1], xi[vi - wi - 1] = Ai, Ai = $i[wi], $i[wi] = -$i[vi - wi - 1], $i[vi - wi - 1] = -Ai;
          }
      }, Si.prototype.normalize13b = function(xi, $i) {
        for (var vi = 0, wi = 0; wi < $i / 2; wi++) {
          var Ai = Math.round(xi[2 * wi + 1] / $i) * 8192 + Math.round(xi[2 * wi] / $i) + vi;
          xi[wi] = Ai & 67108863, Ai < 67108864 ? vi = 0 : vi = Ai / 67108864 | 0;
        }
        return xi;
      }, Si.prototype.convert13b = function(xi, $i, vi, wi) {
        for (var Ai = 0, Ri = 0; Ri < $i; Ri++)
          Ai = Ai + (xi[Ri] | 0), vi[2 * Ri] = Ai & 8191, Ai = Ai >>> 13, vi[2 * Ri + 1] = Ai & 8191, Ai = Ai >>> 13;
        for (Ri = 2 * $i; Ri < wi; ++Ri)
          vi[Ri] = 0;
        Be(Ai === 0), Be((Ai & -8192) === 0);
      }, Si.prototype.stub = function(xi) {
        for (var $i = new Array(xi), vi = 0; vi < xi; vi++)
          $i[vi] = 0;
        return $i;
      }, Si.prototype.mulp = function(xi, $i, vi) {
        var wi = 2 * this.guessLen13b(xi.length, $i.length), Ai = this.makeRBT(wi), Ri = this.stub(wi), Ti = new Array(wi), Ci = new Array(wi), Ii = new Array(wi), Li = new Array(wi), Ni = new Array(wi), Vi = new Array(wi), is = vi.words;
        is.length = wi, this.convert13b(xi.words, xi.length, Ti, wi), this.convert13b($i.words, $i.length, Li, wi), this.transform(Ti, Ri, Ci, Ii, wi, Ai), this.transform(Li, Ri, Ni, Vi, wi, Ai);
        for (var Ki = 0; Ki < wi; Ki++) {
          var ts = Ci[Ki] * Ni[Ki] - Ii[Ki] * Vi[Ki];
          Ii[Ki] = Ci[Ki] * Vi[Ki] + Ii[Ki] * Ni[Ki], Ci[Ki] = ts;
        }
        return this.conjugate(Ci, Ii, wi), this.transform(Ci, Ii, is, Ri, wi, Ai), this.conjugate(is, Ri, wi), this.normalize13b(is, wi), vi.negative = xi.negative ^ $i.negative, vi.length = xi.length + $i.length, vi.strip();
      }, Te.prototype.mul = function(xi) {
        var $i = new Te(null);
        return $i.words = new Array(this.length + xi.length), this.mulTo(xi, $i);
      }, Te.prototype.mulf = function(xi) {
        var $i = new Te(null);
        return $i.words = new Array(this.length + xi.length), Ei(this, xi, $i);
      }, Te.prototype.imul = function(xi) {
        return this.clone().mulTo(xi, this);
      }, Te.prototype.imuln = function(xi) {
        Be(typeof xi == "number"), Be(xi < 67108864);
        for (var $i = 0, vi = 0; vi < this.length; vi++) {
          var wi = (this.words[vi] | 0) * xi, Ai = (wi & 67108863) + ($i & 67108863);
          $i >>= 26, $i += wi / 67108864 | 0, $i += Ai >>> 26, this.words[vi] = Ai & 67108863;
        }
        return $i !== 0 && (this.words[vi] = $i, this.length++), this;
      }, Te.prototype.muln = function(xi) {
        return this.clone().imuln(xi);
      }, Te.prototype.sqr = function() {
        return this.mul(this);
      }, Te.prototype.isqr = function() {
        return this.imul(this.clone());
      }, Te.prototype.pow = function(xi) {
        var $i = fi(xi);
        if ($i.length === 0) return new Te(1);
        for (var vi = this, wi = 0; wi < $i.length && $i[wi] === 0; wi++, vi = vi.sqr())
          ;
        if (++wi < $i.length)
          for (var Ai = vi.sqr(); wi < $i.length; wi++, Ai = Ai.sqr())
            $i[wi] !== 0 && (vi = vi.mul(Ai));
        return vi;
      }, Te.prototype.iushln = function(xi) {
        Be(typeof xi == "number" && xi >= 0);
        var $i = xi % 26, vi = (xi - $i) / 26, wi = 67108863 >>> 26 - $i << 26 - $i, Ai;
        if ($i !== 0) {
          var Ri = 0;
          for (Ai = 0; Ai < this.length; Ai++) {
            var Ti = this.words[Ai] & wi, Ci = (this.words[Ai] | 0) - Ti << $i;
            this.words[Ai] = Ci | Ri, Ri = Ti >>> 26 - $i;
          }
          Ri && (this.words[Ai] = Ri, this.length++);
        }
        if (vi !== 0) {
          for (Ai = this.length - 1; Ai >= 0; Ai--)
            this.words[Ai + vi] = this.words[Ai];
          for (Ai = 0; Ai < vi; Ai++)
            this.words[Ai] = 0;
          this.length += vi;
        }
        return this.strip();
      }, Te.prototype.ishln = function(xi) {
        return Be(this.negative === 0), this.iushln(xi);
      }, Te.prototype.iushrn = function(xi, $i, vi) {
        Be(typeof xi == "number" && xi >= 0);
        var wi;
        $i ? wi = ($i - $i % 26) / 26 : wi = 0;
        var Ai = xi % 26, Ri = Math.min((xi - Ai) / 26, this.length), Ti = 67108863 ^ 67108863 >>> Ai << Ai, Ci = vi;
        if (wi -= Ri, wi = Math.max(0, wi), Ci) {
          for (var Ii = 0; Ii < Ri; Ii++)
            Ci.words[Ii] = this.words[Ii];
          Ci.length = Ri;
        }
        if (Ri !== 0) if (this.length > Ri)
          for (this.length -= Ri, Ii = 0; Ii < this.length; Ii++)
            this.words[Ii] = this.words[Ii + Ri];
        else
          this.words[0] = 0, this.length = 1;
        var Li = 0;
        for (Ii = this.length - 1; Ii >= 0 && (Li !== 0 || Ii >= wi); Ii--) {
          var Ni = this.words[Ii] | 0;
          this.words[Ii] = Li << 26 - Ai | Ni >>> Ai, Li = Ni & Ti;
        }
        return Ci && Li !== 0 && (Ci.words[Ci.length++] = Li), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, Te.prototype.ishrn = function(xi, $i, vi) {
        return Be(this.negative === 0), this.iushrn(xi, $i, vi);
      }, Te.prototype.shln = function(xi) {
        return this.clone().ishln(xi);
      }, Te.prototype.ushln = function(xi) {
        return this.clone().iushln(xi);
      }, Te.prototype.shrn = function(xi) {
        return this.clone().ishrn(xi);
      }, Te.prototype.ushrn = function(xi) {
        return this.clone().iushrn(xi);
      }, Te.prototype.testn = function(xi) {
        Be(typeof xi == "number" && xi >= 0);
        var $i = xi % 26, vi = (xi - $i) / 26, wi = 1 << $i;
        if (this.length <= vi) return !1;
        var Ai = this.words[vi];
        return !!(Ai & wi);
      }, Te.prototype.imaskn = function(xi) {
        Be(typeof xi == "number" && xi >= 0);
        var $i = xi % 26, vi = (xi - $i) / 26;
        if (Be(this.negative === 0, "imaskn works only with positive numbers"), this.length <= vi)
          return this;
        if ($i !== 0 && vi++, this.length = Math.min(vi, this.length), $i !== 0) {
          var wi = 67108863 ^ 67108863 >>> $i << $i;
          this.words[this.length - 1] &= wi;
        }
        return this.strip();
      }, Te.prototype.maskn = function(xi) {
        return this.clone().imaskn(xi);
      }, Te.prototype.iaddn = function(xi) {
        return Be(typeof xi == "number"), Be(xi < 67108864), xi < 0 ? this.isubn(-xi) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < xi ? (this.words[0] = xi - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(xi), this.negative = 1, this) : this._iaddn(xi);
      }, Te.prototype._iaddn = function(xi) {
        this.words[0] += xi;
        for (var $i = 0; $i < this.length && this.words[$i] >= 67108864; $i++)
          this.words[$i] -= 67108864, $i === this.length - 1 ? this.words[$i + 1] = 1 : this.words[$i + 1]++;
        return this.length = Math.max(this.length, $i + 1), this;
      }, Te.prototype.isubn = function(xi) {
        if (Be(typeof xi == "number"), Be(xi < 67108864), xi < 0) return this.iaddn(-xi);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(xi), this.negative = 1, this;
        if (this.words[0] -= xi, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var $i = 0; $i < this.length && this.words[$i] < 0; $i++)
            this.words[$i] += 67108864, this.words[$i + 1] -= 1;
        return this.strip();
      }, Te.prototype.addn = function(xi) {
        return this.clone().iaddn(xi);
      }, Te.prototype.subn = function(xi) {
        return this.clone().isubn(xi);
      }, Te.prototype.iabs = function() {
        return this.negative = 0, this;
      }, Te.prototype.abs = function() {
        return this.clone().iabs();
      }, Te.prototype._ishlnsubmul = function(xi, $i, vi) {
        var wi = xi.length + vi, Ai;
        this._expand(wi);
        var Ri, Ti = 0;
        for (Ai = 0; Ai < xi.length; Ai++) {
          Ri = (this.words[Ai + vi] | 0) + Ti;
          var Ci = (xi.words[Ai] | 0) * $i;
          Ri -= Ci & 67108863, Ti = (Ri >> 26) - (Ci / 67108864 | 0), this.words[Ai + vi] = Ri & 67108863;
        }
        for (; Ai < this.length - vi; Ai++)
          Ri = (this.words[Ai + vi] | 0) + Ti, Ti = Ri >> 26, this.words[Ai + vi] = Ri & 67108863;
        if (Ti === 0) return this.strip();
        for (Be(Ti === -1), Ti = 0, Ai = 0; Ai < this.length; Ai++)
          Ri = -(this.words[Ai] | 0) + Ti, Ti = Ri >> 26, this.words[Ai] = Ri & 67108863;
        return this.negative = 1, this.strip();
      }, Te.prototype._wordDiv = function(xi, $i) {
        var vi = this.length - xi.length, wi = this.clone(), Ai = xi, Ri = Ai.words[Ai.length - 1] | 0, Ti = this._countBits(Ri);
        vi = 26 - Ti, vi !== 0 && (Ai = Ai.ushln(vi), wi.iushln(vi), Ri = Ai.words[Ai.length - 1] | 0);
        var Ci = wi.length - Ai.length, Ii;
        if ($i !== "mod") {
          Ii = new Te(null), Ii.length = Ci + 1, Ii.words = new Array(Ii.length);
          for (var Li = 0; Li < Ii.length; Li++)
            Ii.words[Li] = 0;
        }
        var Ni = wi.clone()._ishlnsubmul(Ai, 1, Ci);
        Ni.negative === 0 && (wi = Ni, Ii && (Ii.words[Ci] = 1));
        for (var Vi = Ci - 1; Vi >= 0; Vi--) {
          var is = (wi.words[Ai.length + Vi] | 0) * 67108864 + (wi.words[Ai.length + Vi - 1] | 0);
          for (is = Math.min(is / Ri | 0, 67108863), wi._ishlnsubmul(Ai, is, Vi); wi.negative !== 0; )
            is--, wi.negative = 0, wi._ishlnsubmul(Ai, 1, Vi), wi.isZero() || (wi.negative ^= 1);
          Ii && (Ii.words[Vi] = is);
        }
        return Ii && Ii.strip(), wi.strip(), $i !== "div" && vi !== 0 && wi.iushrn(vi), {
          div: Ii || null,
          mod: wi
        };
      }, Te.prototype.divmod = function(xi, $i, vi) {
        if (Be(!xi.isZero()), this.isZero())
          return {
            div: new Te(0),
            mod: new Te(0)
          };
        var wi, Ai, Ri;
        return this.negative !== 0 && xi.negative === 0 ? (Ri = this.neg().divmod(xi, $i), $i !== "mod" && (wi = Ri.div.neg()), $i !== "div" && (Ai = Ri.mod.neg(), vi && Ai.negative !== 0 && Ai.iadd(xi)), {
          div: wi,
          mod: Ai
        }) : this.negative === 0 && xi.negative !== 0 ? (Ri = this.divmod(xi.neg(), $i), $i !== "mod" && (wi = Ri.div.neg()), {
          div: wi,
          mod: Ri.mod
        }) : this.negative & xi.negative ? (Ri = this.neg().divmod(xi.neg(), $i), $i !== "div" && (Ai = Ri.mod.neg(), vi && Ai.negative !== 0 && Ai.isub(xi)), {
          div: Ri.div,
          mod: Ai
        }) : xi.length > this.length || this.cmp(xi) < 0 ? {
          div: new Te(0),
          mod: this
        } : xi.length === 1 ? $i === "div" ? {
          div: this.divn(xi.words[0]),
          mod: null
        } : $i === "mod" ? {
          div: null,
          mod: new Te(this.modn(xi.words[0]))
        } : {
          div: this.divn(xi.words[0]),
          mod: new Te(this.modn(xi.words[0]))
        } : this._wordDiv(xi, $i);
      }, Te.prototype.div = function(xi) {
        return this.divmod(xi, "div", !1).div;
      }, Te.prototype.mod = function(xi) {
        return this.divmod(xi, "mod", !1).mod;
      }, Te.prototype.umod = function(xi) {
        return this.divmod(xi, "mod", !0).mod;
      }, Te.prototype.divRound = function(xi) {
        var $i = this.divmod(xi);
        if ($i.mod.isZero()) return $i.div;
        var vi = $i.div.negative !== 0 ? $i.mod.isub(xi) : $i.mod, wi = xi.ushrn(1), Ai = xi.andln(1), Ri = vi.cmp(wi);
        return Ri < 0 || Ai === 1 && Ri === 0 ? $i.div : $i.div.negative !== 0 ? $i.div.isubn(1) : $i.div.iaddn(1);
      }, Te.prototype.modn = function(xi) {
        Be(xi <= 67108863);
        for (var $i = (1 << 26) % xi, vi = 0, wi = this.length - 1; wi >= 0; wi--)
          vi = ($i * vi + (this.words[wi] | 0)) % xi;
        return vi;
      }, Te.prototype.idivn = function(xi) {
        Be(xi <= 67108863);
        for (var $i = 0, vi = this.length - 1; vi >= 0; vi--) {
          var wi = (this.words[vi] | 0) + $i * 67108864;
          this.words[vi] = wi / xi | 0, $i = wi % xi;
        }
        return this.strip();
      }, Te.prototype.divn = function(xi) {
        return this.clone().idivn(xi);
      }, Te.prototype.egcd = function(xi) {
        Be(xi.negative === 0), Be(!xi.isZero());
        var $i = this, vi = xi.clone();
        $i.negative !== 0 ? $i = $i.umod(xi) : $i = $i.clone();
        for (var wi = new Te(1), Ai = new Te(0), Ri = new Te(0), Ti = new Te(1), Ci = 0; $i.isEven() && vi.isEven(); )
          $i.iushrn(1), vi.iushrn(1), ++Ci;
        for (var Ii = vi.clone(), Li = $i.clone(); !$i.isZero(); ) {
          for (var Ni = 0, Vi = 1; !($i.words[0] & Vi) && Ni < 26; ++Ni, Vi <<= 1) ;
          if (Ni > 0)
            for ($i.iushrn(Ni); Ni-- > 0; )
              (wi.isOdd() || Ai.isOdd()) && (wi.iadd(Ii), Ai.isub(Li)), wi.iushrn(1), Ai.iushrn(1);
          for (var is = 0, Ki = 1; !(vi.words[0] & Ki) && is < 26; ++is, Ki <<= 1) ;
          if (is > 0)
            for (vi.iushrn(is); is-- > 0; )
              (Ri.isOdd() || Ti.isOdd()) && (Ri.iadd(Ii), Ti.isub(Li)), Ri.iushrn(1), Ti.iushrn(1);
          $i.cmp(vi) >= 0 ? ($i.isub(vi), wi.isub(Ri), Ai.isub(Ti)) : (vi.isub($i), Ri.isub(wi), Ti.isub(Ai));
        }
        return {
          a: Ri,
          b: Ti,
          gcd: vi.iushln(Ci)
        };
      }, Te.prototype._invmp = function(xi) {
        Be(xi.negative === 0), Be(!xi.isZero());
        var $i = this, vi = xi.clone();
        $i.negative !== 0 ? $i = $i.umod(xi) : $i = $i.clone();
        for (var wi = new Te(1), Ai = new Te(0), Ri = vi.clone(); $i.cmpn(1) > 0 && vi.cmpn(1) > 0; ) {
          for (var Ti = 0, Ci = 1; !($i.words[0] & Ci) && Ti < 26; ++Ti, Ci <<= 1) ;
          if (Ti > 0)
            for ($i.iushrn(Ti); Ti-- > 0; )
              wi.isOdd() && wi.iadd(Ri), wi.iushrn(1);
          for (var Ii = 0, Li = 1; !(vi.words[0] & Li) && Ii < 26; ++Ii, Li <<= 1) ;
          if (Ii > 0)
            for (vi.iushrn(Ii); Ii-- > 0; )
              Ai.isOdd() && Ai.iadd(Ri), Ai.iushrn(1);
          $i.cmp(vi) >= 0 ? ($i.isub(vi), wi.isub(Ai)) : (vi.isub($i), Ai.isub(wi));
        }
        var Ni;
        return $i.cmpn(1) === 0 ? Ni = wi : Ni = Ai, Ni.cmpn(0) < 0 && Ni.iadd(xi), Ni;
      }, Te.prototype.gcd = function(xi) {
        if (this.isZero()) return xi.abs();
        if (xi.isZero()) return this.abs();
        var $i = this.clone(), vi = xi.clone();
        $i.negative = 0, vi.negative = 0;
        for (var wi = 0; $i.isEven() && vi.isEven(); wi++)
          $i.iushrn(1), vi.iushrn(1);
        do {
          for (; $i.isEven(); )
            $i.iushrn(1);
          for (; vi.isEven(); )
            vi.iushrn(1);
          var Ai = $i.cmp(vi);
          if (Ai < 0) {
            var Ri = $i;
            $i = vi, vi = Ri;
          } else if (Ai === 0 || vi.cmpn(1) === 0)
            break;
          $i.isub(vi);
        } while (!0);
        return vi.iushln(wi);
      }, Te.prototype.invm = function(xi) {
        return this.egcd(xi).a.umod(xi);
      }, Te.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, Te.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, Te.prototype.andln = function(xi) {
        return this.words[0] & xi;
      }, Te.prototype.bincn = function(xi) {
        Be(typeof xi == "number");
        var $i = xi % 26, vi = (xi - $i) / 26, wi = 1 << $i;
        if (this.length <= vi)
          return this._expand(vi + 1), this.words[vi] |= wi, this;
        for (var Ai = wi, Ri = vi; Ai !== 0 && Ri < this.length; Ri++) {
          var Ti = this.words[Ri] | 0;
          Ti += Ai, Ai = Ti >>> 26, Ti &= 67108863, this.words[Ri] = Ti;
        }
        return Ai !== 0 && (this.words[Ri] = Ai, this.length++), this;
      }, Te.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, Te.prototype.cmpn = function(xi) {
        var $i = xi < 0;
        if (this.negative !== 0 && !$i) return -1;
        if (this.negative === 0 && $i) return 1;
        this.strip();
        var vi;
        if (this.length > 1)
          vi = 1;
        else {
          $i && (xi = -xi), Be(xi <= 67108863, "Number is too big");
          var wi = this.words[0] | 0;
          vi = wi === xi ? 0 : wi < xi ? -1 : 1;
        }
        return this.negative !== 0 ? -vi | 0 : vi;
      }, Te.prototype.cmp = function(xi) {
        if (this.negative !== 0 && xi.negative === 0) return -1;
        if (this.negative === 0 && xi.negative !== 0) return 1;
        var $i = this.ucmp(xi);
        return this.negative !== 0 ? -$i | 0 : $i;
      }, Te.prototype.ucmp = function(xi) {
        if (this.length > xi.length) return 1;
        if (this.length < xi.length) return -1;
        for (var $i = 0, vi = this.length - 1; vi >= 0; vi--) {
          var wi = this.words[vi] | 0, Ai = xi.words[vi] | 0;
          if (wi !== Ai) {
            wi < Ai ? $i = -1 : wi > Ai && ($i = 1);
            break;
          }
        }
        return $i;
      }, Te.prototype.gtn = function(xi) {
        return this.cmpn(xi) === 1;
      }, Te.prototype.gt = function(xi) {
        return this.cmp(xi) === 1;
      }, Te.prototype.gten = function(xi) {
        return this.cmpn(xi) >= 0;
      }, Te.prototype.gte = function(xi) {
        return this.cmp(xi) >= 0;
      }, Te.prototype.ltn = function(xi) {
        return this.cmpn(xi) === -1;
      }, Te.prototype.lt = function(xi) {
        return this.cmp(xi) === -1;
      }, Te.prototype.lten = function(xi) {
        return this.cmpn(xi) <= 0;
      }, Te.prototype.lte = function(xi) {
        return this.cmp(xi) <= 0;
      }, Te.prototype.eqn = function(xi) {
        return this.cmpn(xi) === 0;
      }, Te.prototype.eq = function(xi) {
        return this.cmp(xi) === 0;
      }, Te.red = function(xi) {
        return new ji(xi);
      }, Te.prototype.toRed = function(xi) {
        return Be(!this.red, "Already a number in reduction context"), Be(this.negative === 0, "red works only with positives"), xi.convertTo(this)._forceRed(xi);
      }, Te.prototype.fromRed = function() {
        return Be(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, Te.prototype._forceRed = function(xi) {
        return this.red = xi, this;
      }, Te.prototype.forceRed = function(xi) {
        return Be(!this.red, "Already a number in reduction context"), this._forceRed(xi);
      }, Te.prototype.redAdd = function(xi) {
        return Be(this.red, "redAdd works only with red numbers"), this.red.add(this, xi);
      }, Te.prototype.redIAdd = function(xi) {
        return Be(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, xi);
      }, Te.prototype.redSub = function(xi) {
        return Be(this.red, "redSub works only with red numbers"), this.red.sub(this, xi);
      }, Te.prototype.redISub = function(xi) {
        return Be(this.red, "redISub works only with red numbers"), this.red.isub(this, xi);
      }, Te.prototype.redShl = function(xi) {
        return Be(this.red, "redShl works only with red numbers"), this.red.shl(this, xi);
      }, Te.prototype.redMul = function(xi) {
        return Be(this.red, "redMul works only with red numbers"), this.red._verify2(this, xi), this.red.mul(this, xi);
      }, Te.prototype.redIMul = function(xi) {
        return Be(this.red, "redMul works only with red numbers"), this.red._verify2(this, xi), this.red.imul(this, xi);
      }, Te.prototype.redSqr = function() {
        return Be(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, Te.prototype.redISqr = function() {
        return Be(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, Te.prototype.redSqrt = function() {
        return Be(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, Te.prototype.redInvm = function() {
        return Be(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, Te.prototype.redNeg = function() {
        return Be(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, Te.prototype.redPow = function(xi) {
        return Be(this.red && !xi.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, xi);
      };
      var Mi = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function Oi(zi, xi) {
        this.name = zi, this.p = new Te(xi, 16), this.n = this.p.bitLength(), this.k = new Te(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      Oi.prototype._tmp = function() {
        var xi = new Te(null);
        return xi.words = new Array(Math.ceil(this.n / 13)), xi;
      }, Oi.prototype.ireduce = function(xi) {
        var $i = xi, vi;
        do
          this.split($i, this.tmp), $i = this.imulK($i), $i = $i.iadd(this.tmp), vi = $i.bitLength();
        while (vi > this.n);
        var wi = vi < this.n ? -1 : $i.ucmp(this.p);
        return wi === 0 ? ($i.words[0] = 0, $i.length = 1) : wi > 0 ? $i.isub(this.p) : $i.strip !== void 0 ? $i.strip() : $i._strip(), $i;
      }, Oi.prototype.split = function(xi, $i) {
        xi.iushrn(this.n, 0, $i);
      }, Oi.prototype.imulK = function(xi) {
        return xi.imul(this.k);
      };
      function Fi() {
        Oi.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      Pe(Fi, Oi), Fi.prototype.split = function(xi, $i) {
        for (var vi = 4194303, wi = Math.min(xi.length, 9), Ai = 0; Ai < wi; Ai++)
          $i.words[Ai] = xi.words[Ai];
        if ($i.length = wi, xi.length <= 9) {
          xi.words[0] = 0, xi.length = 1;
          return;
        }
        var Ri = xi.words[9];
        for ($i.words[$i.length++] = Ri & vi, Ai = 10; Ai < xi.length; Ai++) {
          var Ti = xi.words[Ai] | 0;
          xi.words[Ai - 10] = (Ti & vi) << 4 | Ri >>> 22, Ri = Ti;
        }
        Ri >>>= 22, xi.words[Ai - 10] = Ri, Ri === 0 && xi.length > 10 ? xi.length -= 10 : xi.length -= 9;
      }, Fi.prototype.imulK = function(xi) {
        xi.words[xi.length] = 0, xi.words[xi.length + 1] = 0, xi.length += 2;
        for (var $i = 0, vi = 0; vi < xi.length; vi++) {
          var wi = xi.words[vi] | 0;
          $i += wi * 977, xi.words[vi] = $i & 67108863, $i = wi * 64 + ($i / 67108864 | 0);
        }
        return xi.words[xi.length - 1] === 0 && (xi.length--, xi.words[xi.length - 1] === 0 && xi.length--), xi;
      };
      function Ui() {
        Oi.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      Pe(Ui, Oi);
      function Pi() {
        Oi.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      Pe(Pi, Oi);
      function Bi() {
        Oi.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      Pe(Bi, Oi), Bi.prototype.imulK = function(xi) {
        for (var $i = 0, vi = 0; vi < xi.length; vi++) {
          var wi = (xi.words[vi] | 0) * 19 + $i, Ai = wi & 67108863;
          wi >>>= 26, xi.words[vi] = Ai, $i = wi;
        }
        return $i !== 0 && (xi.words[xi.length++] = $i), xi;
      }, Te._prime = function(xi) {
        if (Mi[xi]) return Mi[xi];
        var $i;
        if (xi === "k256")
          $i = new Fi();
        else if (xi === "p224")
          $i = new Ui();
        else if (xi === "p192")
          $i = new Pi();
        else if (xi === "p25519")
          $i = new Bi();
        else
          throw new Error("Unknown prime " + xi);
        return Mi[xi] = $i, $i;
      };
      function ji(zi) {
        if (typeof zi == "string") {
          var xi = Te._prime(zi);
          this.m = xi.p, this.prime = xi;
        } else
          Be(zi.gtn(1), "modulus must be greater than 1"), this.m = zi, this.prime = null;
      }
      ji.prototype._verify1 = function(xi) {
        Be(xi.negative === 0, "red works only with positives"), Be(xi.red, "red works only with red numbers");
      }, ji.prototype._verify2 = function(xi, $i) {
        Be((xi.negative | $i.negative) === 0, "red works only with positives"), Be(
          xi.red && xi.red === $i.red,
          "red works only with red numbers"
        );
      }, ji.prototype.imod = function(xi) {
        return this.prime ? this.prime.ireduce(xi)._forceRed(this) : xi.umod(this.m)._forceRed(this);
      }, ji.prototype.neg = function(xi) {
        return xi.isZero() ? xi.clone() : this.m.sub(xi)._forceRed(this);
      }, ji.prototype.add = function(xi, $i) {
        this._verify2(xi, $i);
        var vi = xi.add($i);
        return vi.cmp(this.m) >= 0 && vi.isub(this.m), vi._forceRed(this);
      }, ji.prototype.iadd = function(xi, $i) {
        this._verify2(xi, $i);
        var vi = xi.iadd($i);
        return vi.cmp(this.m) >= 0 && vi.isub(this.m), vi;
      }, ji.prototype.sub = function(xi, $i) {
        this._verify2(xi, $i);
        var vi = xi.sub($i);
        return vi.cmpn(0) < 0 && vi.iadd(this.m), vi._forceRed(this);
      }, ji.prototype.isub = function(xi, $i) {
        this._verify2(xi, $i);
        var vi = xi.isub($i);
        return vi.cmpn(0) < 0 && vi.iadd(this.m), vi;
      }, ji.prototype.shl = function(xi, $i) {
        return this._verify1(xi), this.imod(xi.ushln($i));
      }, ji.prototype.imul = function(xi, $i) {
        return this._verify2(xi, $i), this.imod(xi.imul($i));
      }, ji.prototype.mul = function(xi, $i) {
        return this._verify2(xi, $i), this.imod(xi.mul($i));
      }, ji.prototype.isqr = function(xi) {
        return this.imul(xi, xi.clone());
      }, ji.prototype.sqr = function(xi) {
        return this.mul(xi, xi);
      }, ji.prototype.sqrt = function(xi) {
        if (xi.isZero()) return xi.clone();
        var $i = this.m.andln(3);
        if (Be($i % 2 === 1), $i === 3) {
          var vi = this.m.add(new Te(1)).iushrn(2);
          return this.pow(xi, vi);
        }
        for (var wi = this.m.subn(1), Ai = 0; !wi.isZero() && wi.andln(1) === 0; )
          Ai++, wi.iushrn(1);
        Be(!wi.isZero());
        var Ri = new Te(1).toRed(this), Ti = Ri.redNeg(), Ci = this.m.subn(1).iushrn(1), Ii = this.m.bitLength();
        for (Ii = new Te(2 * Ii * Ii).toRed(this); this.pow(Ii, Ci).cmp(Ti) !== 0; )
          Ii.redIAdd(Ti);
        for (var Li = this.pow(Ii, wi), Ni = this.pow(xi, wi.addn(1).iushrn(1)), Vi = this.pow(xi, wi), is = Ai; Vi.cmp(Ri) !== 0; ) {
          for (var Ki = Vi, ts = 0; Ki.cmp(Ri) !== 0; ts++)
            Ki = Ki.redSqr();
          Be(ts < is);
          var qi = this.pow(Li, new Te(1).iushln(is - ts - 1));
          Ni = Ni.redMul(qi), Li = qi.redSqr(), Vi = Vi.redMul(Li), is = ts;
        }
        return Ni;
      }, ji.prototype.invm = function(xi) {
        var $i = xi._invmp(this.m);
        return $i.negative !== 0 ? ($i.negative = 0, this.imod($i).redNeg()) : this.imod($i);
      }, ji.prototype.pow = function(xi, $i) {
        if ($i.isZero()) return new Te(1).toRed(this);
        if ($i.cmpn(1) === 0) return xi.clone();
        var vi = 4, wi = new Array(1 << vi);
        wi[0] = new Te(1).toRed(this), wi[1] = xi;
        for (var Ai = 2; Ai < wi.length; Ai++)
          wi[Ai] = this.mul(wi[Ai - 1], xi);
        var Ri = wi[0], Ti = 0, Ci = 0, Ii = $i.bitLength() % 26;
        for (Ii === 0 && (Ii = 26), Ai = $i.length - 1; Ai >= 0; Ai--) {
          for (var Li = $i.words[Ai], Ni = Ii - 1; Ni >= 0; Ni--) {
            var Vi = Li >> Ni & 1;
            if (Ri !== wi[0] && (Ri = this.sqr(Ri)), Vi === 0 && Ti === 0) {
              Ci = 0;
              continue;
            }
            Ti <<= 1, Ti |= Vi, Ci++, !(Ci !== vi && (Ai !== 0 || Ni !== 0)) && (Ri = this.mul(Ri, wi[Ti]), Ci = 0, Ti = 0);
          }
          Ii = 26;
        }
        return Ri;
      }, ji.prototype.convertTo = function(xi) {
        var $i = xi.umod(this.m);
        return $i === xi ? $i.clone() : $i;
      }, ji.prototype.convertFrom = function(xi) {
        var $i = xi.clone();
        return $i.red = null, $i;
      }, Te.mont = function(xi) {
        return new Zi(xi);
      };
      function Zi(zi) {
        ji.call(this, zi), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new Te(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      Pe(Zi, ji), Zi.prototype.convertTo = function(xi) {
        return this.imod(xi.ushln(this.shift));
      }, Zi.prototype.convertFrom = function(xi) {
        var $i = this.imod(xi.mul(this.rinv));
        return $i.red = null, $i;
      }, Zi.prototype.imul = function(xi, $i) {
        if (xi.isZero() || $i.isZero())
          return xi.words[0] = 0, xi.length = 1, xi;
        var vi = xi.imul($i), wi = vi.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Ai = vi.isub(wi).iushrn(this.shift), Ri = Ai;
        return Ai.cmp(this.m) >= 0 ? Ri = Ai.isub(this.m) : Ai.cmpn(0) < 0 && (Ri = Ai.iadd(this.m)), Ri._forceRed(this);
      }, Zi.prototype.mul = function(xi, $i) {
        if (xi.isZero() || $i.isZero()) return new Te(0)._forceRed(this);
        var vi = xi.mul($i), wi = vi.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Ai = vi.isub(wi).iushrn(this.shift), Ri = Ai;
        return Ai.cmp(this.m) >= 0 ? Ri = Ai.isub(this.m) : Ai.cmpn(0) < 0 && (Ri = Ai.iadd(this.m)), Ri._forceRed(this);
      }, Zi.prototype.invm = function(xi) {
        var $i = this.imod(xi._invmp(this.m).mul(this.r2));
        return $i._forceRed(this);
      };
    })(Ae, commonjsGlobal);
  }(bn$2)), bn$2.exports;
}
var utils$3 = {}, hasRequiredUtils$3;
function requireUtils$3() {
  return hasRequiredUtils$3 || (hasRequiredUtils$3 = 1, function(Ae) {
    var t = Ae;
    function Ie(Te, Me) {
      if (Array.isArray(Te))
        return Te.slice();
      if (!Te)
        return [];
      var Ue = [];
      if (typeof Te != "string") {
        for (var je = 0; je < Te.length; je++)
          Ue[je] = Te[je] | 0;
        return Ue;
      }
      if (Me === "hex") {
        Te = Te.replace(/[^a-z0-9]+/ig, ""), Te.length % 2 !== 0 && (Te = "0" + Te);
        for (var je = 0; je < Te.length; je += 2)
          Ue.push(parseInt(Te[je] + Te[je + 1], 16));
      } else
        for (var je = 0; je < Te.length; je++) {
          var fn = Te.charCodeAt(je), Ve = fn >> 8, vn = fn & 255;
          Ve ? Ue.push(Ve, vn) : Ue.push(vn);
        }
      return Ue;
    }
    t.toArray = Ie;
    function Be(Te) {
      return Te.length === 1 ? "0" + Te : Te;
    }
    t.zero2 = Be;
    function Pe(Te) {
      for (var Me = "", Ue = 0; Ue < Te.length; Ue++)
        Me += Be(Te[Ue].toString(16));
      return Me;
    }
    t.toHex = Pe, t.encode = function(Me, Ue) {
      return Ue === "hex" ? Pe(Me) : Me;
    };
  }(utils$3)), utils$3;
}
var hasRequiredUtils$2;
function requireUtils$2() {
  return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, function(Ae) {
    var t = Ae, Ie = requireBn(), Be = minimalisticAssert$1, Pe = requireUtils$3();
    t.assert = Be, t.toArray = Pe.toArray, t.zero2 = Pe.zero2, t.toHex = Pe.toHex, t.encode = Pe.encode;
    function Te(Ve, vn, En) {
      var fi = new Array(Math.max(Ve.bitLength(), En) + 1), bi;
      for (bi = 0; bi < fi.length; bi += 1)
        fi[bi] = 0;
      var mi = 1 << vn + 1, _i = Ve.clone();
      for (bi = 0; bi < fi.length; bi++) {
        var Ei, Si = _i.andln(mi - 1);
        _i.isOdd() ? (Si > (mi >> 1) - 1 ? Ei = (mi >> 1) - Si : Ei = Si, _i.isubn(Ei)) : Ei = 0, fi[bi] = Ei, _i.iushrn(1);
      }
      return fi;
    }
    t.getNAF = Te;
    function Me(Ve, vn) {
      var En = [
        [],
        []
      ];
      Ve = Ve.clone(), vn = vn.clone();
      for (var fi = 0, bi = 0, mi; Ve.cmpn(-fi) > 0 || vn.cmpn(-bi) > 0; ) {
        var _i = Ve.andln(3) + fi & 3, Ei = vn.andln(3) + bi & 3;
        _i === 3 && (_i = -1), Ei === 3 && (Ei = -1);
        var Si;
        _i & 1 ? (mi = Ve.andln(7) + fi & 7, (mi === 3 || mi === 5) && Ei === 2 ? Si = -_i : Si = _i) : Si = 0, En[0].push(Si);
        var Mi;
        Ei & 1 ? (mi = vn.andln(7) + bi & 7, (mi === 3 || mi === 5) && _i === 2 ? Mi = -Ei : Mi = Ei) : Mi = 0, En[1].push(Mi), 2 * fi === Si + 1 && (fi = 1 - fi), 2 * bi === Mi + 1 && (bi = 1 - bi), Ve.iushrn(1), vn.iushrn(1);
      }
      return En;
    }
    t.getJSF = Me;
    function Ue(Ve, vn, En) {
      var fi = "_" + vn;
      Ve.prototype[vn] = function() {
        return this[fi] !== void 0 ? this[fi] : this[fi] = En.call(this);
      };
    }
    t.cachedProperty = Ue;
    function je(Ve) {
      return typeof Ve == "string" ? t.toArray(Ve, "hex") : Ve;
    }
    t.parseBytes = je;
    function fn(Ve) {
      return new Ie(Ve, "hex", "le");
    }
    t.intFromLE = fn;
  }(utils$4)), utils$4;
}
var brorand = { exports: {} }, cryptoBrowserify = {}, browser$g = { exports: {} }, safeBuffer$1 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer$1;
function requireSafeBuffer$1() {
  return hasRequiredSafeBuffer$1 || (hasRequiredSafeBuffer$1 = 1, function(Ae, t) {
    var Ie = require$$0$4, Be = Ie.Buffer;
    function Pe(Me, Ue) {
      for (var je in Me)
        Ue[je] = Me[je];
    }
    Be.from && Be.alloc && Be.allocUnsafe && Be.allocUnsafeSlow ? Ae.exports = Ie : (Pe(Ie, t), t.Buffer = Te);
    function Te(Me, Ue, je) {
      return Be(Me, Ue, je);
    }
    Te.prototype = Object.create(Be.prototype), Pe(Be, Te), Te.from = function(Me, Ue, je) {
      if (typeof Me == "number")
        throw new TypeError("Argument must not be a number");
      return Be(Me, Ue, je);
    }, Te.alloc = function(Me, Ue, je) {
      if (typeof Me != "number")
        throw new TypeError("Argument must be a number");
      var fn = Be(Me);
      return Ue !== void 0 ? typeof je == "string" ? fn.fill(Ue, je) : fn.fill(Ue) : fn.fill(0), fn;
    }, Te.allocUnsafe = function(Me) {
      if (typeof Me != "number")
        throw new TypeError("Argument must be a number");
      return Be(Me);
    }, Te.allocUnsafeSlow = function(Me) {
      if (typeof Me != "number")
        throw new TypeError("Argument must be a number");
      return Ie.SlowBuffer(Me);
    };
  }(safeBuffer$1, safeBuffer$1.exports)), safeBuffer$1.exports;
}
var hasRequiredBrowser$c;
function requireBrowser$c() {
  if (hasRequiredBrowser$c) return browser$g.exports;
  hasRequiredBrowser$c = 1;
  var Ae = 65536, t = 4294967295;
  function Ie() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var Be = requireSafeBuffer$1().Buffer, Pe = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  Pe && Pe.getRandomValues ? browser$g.exports = Te : browser$g.exports = Ie;
  function Te(Me, Ue) {
    if (Me > t) throw new RangeError("requested too many random bytes");
    var je = Be.allocUnsafe(Me);
    if (Me > 0)
      if (Me > Ae)
        for (var fn = 0; fn < Me; fn += Ae)
          Pe.getRandomValues(je.slice(fn, fn + Ae));
      else
        Pe.getRandomValues(je);
    return typeof Ue == "function" ? process$1$1.nextTick(function() {
      Ue(null, je);
    }) : je;
  }
  return browser$g.exports;
}
var events = { exports: {} }, R$3 = typeof Reflect == "object" ? Reflect : null, ReflectApply = R$3 && typeof R$3.apply == "function" ? R$3.apply : function(t, Ie, Be) {
  return Function.prototype.apply.call(t, Ie, Be);
}, ReflectOwnKeys;
R$3 && typeof R$3.ownKeys == "function" ? ReflectOwnKeys = R$3.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : ReflectOwnKeys = function(t) {
  return Object.getOwnPropertyNames(t);
};
function ProcessEmitWarning(Ae) {
  console && console.warn && console.warn(Ae);
}
var NumberIsNaN$2 = Number.isNaN || function(t) {
  return t !== t;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once$2;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(Ae) {
  if (typeof Ae != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof Ae);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(Ae) {
    if (typeof Ae != "number" || Ae < 0 || NumberIsNaN$2(Ae))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + Ae + ".");
    defaultMaxListeners = Ae;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || NumberIsNaN$2(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function _getMaxListeners(Ae) {
  return Ae._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : Ae._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function(t) {
  for (var Ie = [], Be = 1; Be < arguments.length; Be++) Ie.push(arguments[Be]);
  var Pe = t === "error", Te = this._events;
  if (Te !== void 0)
    Pe = Pe && Te.error === void 0;
  else if (!Pe)
    return !1;
  if (Pe) {
    var Me;
    if (Ie.length > 0 && (Me = Ie[0]), Me instanceof Error)
      throw Me;
    var Ue = new Error("Unhandled error." + (Me ? " (" + Me.message + ")" : ""));
    throw Ue.context = Me, Ue;
  }
  var je = Te[t];
  if (je === void 0)
    return !1;
  if (typeof je == "function")
    ReflectApply(je, this, Ie);
  else
    for (var fn = je.length, Ve = arrayClone$1(je, fn), Be = 0; Be < fn; ++Be)
      ReflectApply(Ve[Be], this, Ie);
  return !0;
};
function _addListener(Ae, t, Ie, Be) {
  var Pe, Te, Me;
  if (checkListener(Ie), Te = Ae._events, Te === void 0 ? (Te = Ae._events = /* @__PURE__ */ Object.create(null), Ae._eventsCount = 0) : (Te.newListener !== void 0 && (Ae.emit(
    "newListener",
    t,
    Ie.listener ? Ie.listener : Ie
  ), Te = Ae._events), Me = Te[t]), Me === void 0)
    Me = Te[t] = Ie, ++Ae._eventsCount;
  else if (typeof Me == "function" ? Me = Te[t] = Be ? [Ie, Me] : [Me, Ie] : Be ? Me.unshift(Ie) : Me.push(Ie), Pe = _getMaxListeners(Ae), Pe > 0 && Me.length > Pe && !Me.warned) {
    Me.warned = !0;
    var Ue = new Error("Possible EventEmitter memory leak detected. " + Me.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    Ue.name = "MaxListenersExceededWarning", Ue.emitter = Ae, Ue.type = t, Ue.count = Me.length, ProcessEmitWarning(Ue);
  }
  return Ae;
}
EventEmitter.prototype.addListener = function(t, Ie) {
  return _addListener(this, t, Ie, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function(t, Ie) {
  return _addListener(this, t, Ie, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(Ae, t, Ie) {
  var Be = { fired: !1, wrapFn: void 0, target: Ae, type: t, listener: Ie }, Pe = onceWrapper.bind(Be);
  return Pe.listener = Ie, Be.wrapFn = Pe, Pe;
}
EventEmitter.prototype.once = function(t, Ie) {
  return checkListener(Ie), this.on(t, _onceWrap(this, t, Ie)), this;
};
EventEmitter.prototype.prependOnceListener = function(t, Ie) {
  return checkListener(Ie), this.prependListener(t, _onceWrap(this, t, Ie)), this;
};
EventEmitter.prototype.removeListener = function(t, Ie) {
  var Be, Pe, Te, Me, Ue;
  if (checkListener(Ie), Pe = this._events, Pe === void 0)
    return this;
  if (Be = Pe[t], Be === void 0)
    return this;
  if (Be === Ie || Be.listener === Ie)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete Pe[t], Pe.removeListener && this.emit("removeListener", t, Be.listener || Ie));
  else if (typeof Be != "function") {
    for (Te = -1, Me = Be.length - 1; Me >= 0; Me--)
      if (Be[Me] === Ie || Be[Me].listener === Ie) {
        Ue = Be[Me].listener, Te = Me;
        break;
      }
    if (Te < 0)
      return this;
    Te === 0 ? Be.shift() : spliceOne(Be, Te), Be.length === 1 && (Pe[t] = Be[0]), Pe.removeListener !== void 0 && this.emit("removeListener", t, Ue || Ie);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function(t) {
  var Ie, Be, Pe;
  if (Be = this._events, Be === void 0)
    return this;
  if (Be.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Be[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Be[t]), this;
  if (arguments.length === 0) {
    var Te = Object.keys(Be), Me;
    for (Pe = 0; Pe < Te.length; ++Pe)
      Me = Te[Pe], Me !== "removeListener" && this.removeAllListeners(Me);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (Ie = Be[t], typeof Ie == "function")
    this.removeListener(t, Ie);
  else if (Ie !== void 0)
    for (Pe = Ie.length - 1; Pe >= 0; Pe--)
      this.removeListener(t, Ie[Pe]);
  return this;
};
function _listeners(Ae, t, Ie) {
  var Be = Ae._events;
  if (Be === void 0)
    return [];
  var Pe = Be[t];
  return Pe === void 0 ? [] : typeof Pe == "function" ? Ie ? [Pe.listener || Pe] : [Pe] : Ie ? unwrapListeners(Pe) : arrayClone$1(Pe, Pe.length);
}
EventEmitter.prototype.listeners = function(t) {
  return _listeners(this, t, !0);
};
EventEmitter.prototype.rawListeners = function(t) {
  return _listeners(this, t, !1);
};
EventEmitter.listenerCount = function(Ae, t) {
  return typeof Ae.listenerCount == "function" ? Ae.listenerCount(t) : listenerCount.call(Ae, t);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(Ae) {
  var t = this._events;
  if (t !== void 0) {
    var Ie = t[Ae];
    if (typeof Ie == "function")
      return 1;
    if (Ie !== void 0)
      return Ie.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone$1(Ae, t) {
  for (var Ie = new Array(t), Be = 0; Be < t; ++Be)
    Ie[Be] = Ae[Be];
  return Ie;
}
function spliceOne(Ae, t) {
  for (; t + 1 < Ae.length; t++)
    Ae[t] = Ae[t + 1];
  Ae.pop();
}
function unwrapListeners(Ae) {
  for (var t = new Array(Ae.length), Ie = 0; Ie < t.length; ++Ie)
    t[Ie] = Ae[Ie].listener || Ae[Ie];
  return t;
}
function once$2(Ae, t) {
  return new Promise(function(Ie, Be) {
    function Pe(Me) {
      Ae.removeListener(t, Te), Be(Me);
    }
    function Te() {
      typeof Ae.removeListener == "function" && Ae.removeListener("error", Pe), Ie([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(Ae, t, Te, { once: !0 }), t !== "error" && addErrorHandlerIfEventEmitter(Ae, Pe, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(Ae, t, Ie) {
  typeof Ae.on == "function" && eventTargetAgnosticAddListener(Ae, "error", t, Ie);
}
function eventTargetAgnosticAddListener(Ae, t, Ie, Be) {
  if (typeof Ae.on == "function")
    Be.once ? Ae.once(t, Ie) : Ae.on(t, Ie);
  else if (typeof Ae.addEventListener == "function")
    Ae.addEventListener(t, function Pe(Te) {
      Be.once && Ae.removeEventListener(t, Pe), Ie(Te);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof Ae);
}
var eventsExports = events.exports;
const es = /* @__PURE__ */ getDefaultExportFromCjs(eventsExports);
var streamBrowser$1, hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
  return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1, streamBrowser$1 = eventsExports.EventEmitter), streamBrowser$1;
}
var buffer_list$1, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list$1;
  hasRequiredBuffer_list = 1;
  function Ae(bi, mi) {
    var _i = Object.keys(bi);
    if (Object.getOwnPropertySymbols) {
      var Ei = Object.getOwnPropertySymbols(bi);
      mi && (Ei = Ei.filter(function(Si) {
        return Object.getOwnPropertyDescriptor(bi, Si).enumerable;
      })), _i.push.apply(_i, Ei);
    }
    return _i;
  }
  function t(bi) {
    for (var mi = 1; mi < arguments.length; mi++) {
      var _i = arguments[mi] != null ? arguments[mi] : {};
      mi % 2 ? Ae(Object(_i), !0).forEach(function(Ei) {
        Ie(bi, Ei, _i[Ei]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(bi, Object.getOwnPropertyDescriptors(_i)) : Ae(Object(_i)).forEach(function(Ei) {
        Object.defineProperty(bi, Ei, Object.getOwnPropertyDescriptor(_i, Ei));
      });
    }
    return bi;
  }
  function Ie(bi, mi, _i) {
    return mi = Me(mi), mi in bi ? Object.defineProperty(bi, mi, { value: _i, enumerable: !0, configurable: !0, writable: !0 }) : bi[mi] = _i, bi;
  }
  function Be(bi, mi) {
    if (!(bi instanceof mi))
      throw new TypeError("Cannot call a class as a function");
  }
  function Pe(bi, mi) {
    for (var _i = 0; _i < mi.length; _i++) {
      var Ei = mi[_i];
      Ei.enumerable = Ei.enumerable || !1, Ei.configurable = !0, "value" in Ei && (Ei.writable = !0), Object.defineProperty(bi, Me(Ei.key), Ei);
    }
  }
  function Te(bi, mi, _i) {
    return mi && Pe(bi.prototype, mi), Object.defineProperty(bi, "prototype", { writable: !1 }), bi;
  }
  function Me(bi) {
    var mi = Ue(bi, "string");
    return typeof mi == "symbol" ? mi : String(mi);
  }
  function Ue(bi, mi) {
    if (typeof bi != "object" || bi === null) return bi;
    var _i = bi[Symbol.toPrimitive];
    if (_i !== void 0) {
      var Ei = _i.call(bi, mi || "default");
      if (typeof Ei != "object") return Ei;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (mi === "string" ? String : Number)(bi);
  }
  var je = require$$0$4, fn = je.Buffer, Ve = util$2, vn = Ve.inspect, En = vn && vn.custom || "inspect";
  function fi(bi, mi, _i) {
    fn.prototype.copy.call(bi, mi, _i);
  }
  return buffer_list$1 = /* @__PURE__ */ function() {
    function bi() {
      Be(this, bi), this.head = null, this.tail = null, this.length = 0;
    }
    return Te(bi, [{
      key: "push",
      value: function(_i) {
        var Ei = {
          data: _i,
          next: null
        };
        this.length > 0 ? this.tail.next = Ei : this.head = Ei, this.tail = Ei, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(_i) {
        var Ei = {
          data: _i,
          next: this.head
        };
        this.length === 0 && (this.tail = Ei), this.head = Ei, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var _i = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, _i;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(_i) {
        if (this.length === 0) return "";
        for (var Ei = this.head, Si = "" + Ei.data; Ei = Ei.next; ) Si += _i + Ei.data;
        return Si;
      }
    }, {
      key: "concat",
      value: function(_i) {
        if (this.length === 0) return fn.alloc(0);
        for (var Ei = fn.allocUnsafe(_i >>> 0), Si = this.head, Mi = 0; Si; )
          fi(Si.data, Ei, Mi), Mi += Si.data.length, Si = Si.next;
        return Ei;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(_i, Ei) {
        var Si;
        return _i < this.head.data.length ? (Si = this.head.data.slice(0, _i), this.head.data = this.head.data.slice(_i)) : _i === this.head.data.length ? Si = this.shift() : Si = Ei ? this._getString(_i) : this._getBuffer(_i), Si;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(_i) {
        var Ei = this.head, Si = 1, Mi = Ei.data;
        for (_i -= Mi.length; Ei = Ei.next; ) {
          var Oi = Ei.data, Fi = _i > Oi.length ? Oi.length : _i;
          if (Fi === Oi.length ? Mi += Oi : Mi += Oi.slice(0, _i), _i -= Fi, _i === 0) {
            Fi === Oi.length ? (++Si, Ei.next ? this.head = Ei.next : this.head = this.tail = null) : (this.head = Ei, Ei.data = Oi.slice(Fi));
            break;
          }
          ++Si;
        }
        return this.length -= Si, Mi;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(_i) {
        var Ei = fn.allocUnsafe(_i), Si = this.head, Mi = 1;
        for (Si.data.copy(Ei), _i -= Si.data.length; Si = Si.next; ) {
          var Oi = Si.data, Fi = _i > Oi.length ? Oi.length : _i;
          if (Oi.copy(Ei, Ei.length - _i, 0, Fi), _i -= Fi, _i === 0) {
            Fi === Oi.length ? (++Mi, Si.next ? this.head = Si.next : this.head = this.tail = null) : (this.head = Si, Si.data = Oi.slice(Fi));
            break;
          }
          ++Mi;
        }
        return this.length -= Mi, Ei;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: En,
      value: function(_i, Ei) {
        return vn(this, t(t({}, Ei), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), bi;
  }(), buffer_list$1;
}
var destroy_1$2, hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1) return destroy_1$2;
  hasRequiredDestroy$1 = 1;
  function Ae(Me, Ue) {
    var je = this, fn = this._readableState && this._readableState.destroyed, Ve = this._writableState && this._writableState.destroyed;
    return fn || Ve ? (Ue ? Ue(Me) : Me && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1$1.nextTick(Pe, this, Me)) : process$1$1.nextTick(Pe, this, Me)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(Me || null, function(vn) {
      !Ue && vn ? je._writableState ? je._writableState.errorEmitted ? process$1$1.nextTick(Ie, je) : (je._writableState.errorEmitted = !0, process$1$1.nextTick(t, je, vn)) : process$1$1.nextTick(t, je, vn) : Ue ? (process$1$1.nextTick(Ie, je), Ue(vn)) : process$1$1.nextTick(Ie, je);
    }), this);
  }
  function t(Me, Ue) {
    Pe(Me, Ue), Ie(Me);
  }
  function Ie(Me) {
    Me._writableState && !Me._writableState.emitClose || Me._readableState && !Me._readableState.emitClose || Me.emit("close");
  }
  function Be() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function Pe(Me, Ue) {
    Me.emit("error", Ue);
  }
  function Te(Me, Ue) {
    var je = Me._readableState, fn = Me._writableState;
    je && je.autoDestroy || fn && fn.autoDestroy ? Me.destroy(Ue) : Me.emit("error", Ue);
  }
  return destroy_1$2 = {
    destroy: Ae,
    undestroy: Be,
    errorOrDestroy: Te
  }, destroy_1$2;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function Ae(Ue, je) {
    Ue.prototype = Object.create(je.prototype), Ue.prototype.constructor = Ue, Ue.__proto__ = je;
  }
  var t = {};
  function Ie(Ue, je, fn) {
    fn || (fn = Error);
    function Ve(En, fi, bi) {
      return typeof je == "string" ? je : je(En, fi, bi);
    }
    var vn = /* @__PURE__ */ function(En) {
      Ae(fi, En);
      function fi(bi, mi, _i) {
        return En.call(this, Ve(bi, mi, _i)) || this;
      }
      return fi;
    }(fn);
    vn.prototype.name = fn.name, vn.prototype.code = Ue, t[Ue] = vn;
  }
  function Be(Ue, je) {
    if (Array.isArray(Ue)) {
      var fn = Ue.length;
      return Ue = Ue.map(function(Ve) {
        return String(Ve);
      }), fn > 2 ? "one of ".concat(je, " ").concat(Ue.slice(0, fn - 1).join(", "), ", or ") + Ue[fn - 1] : fn === 2 ? "one of ".concat(je, " ").concat(Ue[0], " or ").concat(Ue[1]) : "of ".concat(je, " ").concat(Ue[0]);
    } else
      return "of ".concat(je, " ").concat(String(Ue));
  }
  function Pe(Ue, je, fn) {
    return Ue.substr(0, je.length) === je;
  }
  function Te(Ue, je, fn) {
    return (fn === void 0 || fn > Ue.length) && (fn = Ue.length), Ue.substring(fn - je.length, fn) === je;
  }
  function Me(Ue, je, fn) {
    return typeof fn != "number" && (fn = 0), fn + je.length > Ue.length ? !1 : Ue.indexOf(je, fn) !== -1;
  }
  return Ie("ERR_INVALID_OPT_VALUE", function(Ue, je) {
    return 'The value "' + je + '" is invalid for option "' + Ue + '"';
  }, TypeError), Ie("ERR_INVALID_ARG_TYPE", function(Ue, je, fn) {
    var Ve;
    typeof je == "string" && Pe(je, "not ") ? (Ve = "must not be", je = je.replace(/^not /, "")) : Ve = "must be";
    var vn;
    if (Te(Ue, " argument"))
      vn = "The ".concat(Ue, " ").concat(Ve, " ").concat(Be(je, "type"));
    else {
      var En = Me(Ue, ".") ? "property" : "argument";
      vn = 'The "'.concat(Ue, '" ').concat(En, " ").concat(Ve, " ").concat(Be(je, "type"));
    }
    return vn += ". Received type ".concat(typeof fn), vn;
  }, TypeError), Ie("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), Ie("ERR_METHOD_NOT_IMPLEMENTED", function(Ue) {
    return "The " + Ue + " method is not implemented";
  }), Ie("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), Ie("ERR_STREAM_DESTROYED", function(Ue) {
    return "Cannot call " + Ue + " after a stream was destroyed";
  }), Ie("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), Ie("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), Ie("ERR_STREAM_WRITE_AFTER_END", "write after end"), Ie("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), Ie("ERR_UNKNOWN_ENCODING", function(Ue) {
    return "Unknown encoding: " + Ue;
  }, TypeError), Ie("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = t, errorsBrowser;
}
var state$1, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state$1;
  hasRequiredState = 1;
  var Ae = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function t(Be, Pe, Te) {
    return Be.highWaterMark != null ? Be.highWaterMark : Pe ? Be[Te] : null;
  }
  function Ie(Be, Pe, Te, Me) {
    var Ue = t(Pe, Me, Te);
    if (Ue != null) {
      if (!(isFinite(Ue) && Math.floor(Ue) === Ue) || Ue < 0) {
        var je = Me ? Te : "highWaterMark";
        throw new Ae(je, Ue);
      }
      return Math.floor(Ue);
    }
    return Be.objectMode ? 16 : 16 * 1024;
  }
  return state$1 = {
    getHighWaterMark: Ie
  }, state$1;
}
var browser$f, hasRequiredBrowser$b;
function requireBrowser$b() {
  if (hasRequiredBrowser$b) return browser$f;
  hasRequiredBrowser$b = 1, browser$f = Ae;
  function Ae(Ie, Be) {
    if (t("noDeprecation"))
      return Ie;
    var Pe = !1;
    function Te() {
      if (!Pe) {
        if (t("throwDeprecation"))
          throw new Error(Be);
        t("traceDeprecation") ? console.trace(Be) : console.warn(Be), Pe = !0;
      }
      return Ie.apply(this, arguments);
    }
    return Te;
  }
  function t(Ie) {
    try {
      if (!commonjsGlobal.localStorage) return !1;
    } catch {
      return !1;
    }
    var Be = commonjsGlobal.localStorage[Ie];
    return Be == null ? !1 : String(Be).toLowerCase() === "true";
  }
  return browser$f;
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = Bi;
  function Ae(ts) {
    var qi = this;
    this.next = null, this.entry = null, this.finish = function() {
      Ki(qi, ts);
    };
  }
  var t;
  Bi.WritableState = Ui;
  var Ie = {
    deprecate: requireBrowser$b()
  }, Be = requireStreamBrowser$1(), Pe = require$$0$4.Buffer, Te = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function Me(ts) {
    return Pe.from(ts);
  }
  function Ue(ts) {
    return Pe.isBuffer(ts) || ts instanceof Te;
  }
  var je = requireDestroy$1(), fn = requireState(), Ve = fn.getHighWaterMark, vn = requireErrorsBrowser().codes, En = vn.ERR_INVALID_ARG_TYPE, fi = vn.ERR_METHOD_NOT_IMPLEMENTED, bi = vn.ERR_MULTIPLE_CALLBACK, mi = vn.ERR_STREAM_CANNOT_PIPE, _i = vn.ERR_STREAM_DESTROYED, Ei = vn.ERR_STREAM_NULL_VALUES, Si = vn.ERR_STREAM_WRITE_AFTER_END, Mi = vn.ERR_UNKNOWN_ENCODING, Oi = je.errorOrDestroy;
  requireInherits_browser()(Bi, Be);
  function Fi() {
  }
  function Ui(ts, qi, Hi) {
    t = t || require_stream_duplex$1(), ts = ts || {}, typeof Hi != "boolean" && (Hi = qi instanceof t), this.objectMode = !!ts.objectMode, Hi && (this.objectMode = this.objectMode || !!ts.writableObjectMode), this.highWaterMark = Ve(this, ts, "writableHighWaterMark", Hi), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Xi = ts.decodeStrings === !1;
    this.decodeStrings = !Xi, this.defaultEncoding = ts.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ki) {
      Ai(qi, ki);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = ts.emitClose !== !1, this.autoDestroy = !!ts.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Ae(this);
  }
  Ui.prototype.getBuffer = function() {
    for (var qi = this.bufferedRequest, Hi = []; qi; )
      Hi.push(qi), qi = qi.next;
    return Hi;
  }, function() {
    try {
      Object.defineProperty(Ui.prototype, "buffer", {
        get: Ie.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Pi;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Pi = Function.prototype[Symbol.hasInstance], Object.defineProperty(Bi, Symbol.hasInstance, {
    value: function(qi) {
      return Pi.call(this, qi) ? !0 : this !== Bi ? !1 : qi && qi._writableState instanceof Ui;
    }
  })) : Pi = function(qi) {
    return qi instanceof this;
  };
  function Bi(ts) {
    t = t || require_stream_duplex$1();
    var qi = this instanceof t;
    if (!qi && !Pi.call(Bi, this)) return new Bi(ts);
    this._writableState = new Ui(ts, this, qi), this.writable = !0, ts && (typeof ts.write == "function" && (this._write = ts.write), typeof ts.writev == "function" && (this._writev = ts.writev), typeof ts.destroy == "function" && (this._destroy = ts.destroy), typeof ts.final == "function" && (this._final = ts.final)), Be.call(this);
  }
  Bi.prototype.pipe = function() {
    Oi(this, new mi());
  };
  function ji(ts, qi) {
    var Hi = new Si();
    Oi(ts, Hi), process$1$1.nextTick(qi, Hi);
  }
  function Zi(ts, qi, Hi, Xi) {
    var ki;
    return Hi === null ? ki = new Ei() : typeof Hi != "string" && !qi.objectMode && (ki = new En("chunk", ["string", "Buffer"], Hi)), ki ? (Oi(ts, ki), process$1$1.nextTick(Xi, ki), !1) : !0;
  }
  Bi.prototype.write = function(ts, qi, Hi) {
    var Xi = this._writableState, ki = !1, Wi = !Xi.objectMode && Ue(ts);
    return Wi && !Pe.isBuffer(ts) && (ts = Me(ts)), typeof qi == "function" && (Hi = qi, qi = null), Wi ? qi = "buffer" : qi || (qi = Xi.defaultEncoding), typeof Hi != "function" && (Hi = Fi), Xi.ending ? ji(this, Hi) : (Wi || Zi(this, Xi, ts, Hi)) && (Xi.pendingcb++, ki = xi(this, Xi, Wi, ts, qi, Hi)), ki;
  }, Bi.prototype.cork = function() {
    this._writableState.corked++;
  }, Bi.prototype.uncork = function() {
    var ts = this._writableState;
    ts.corked && (ts.corked--, !ts.writing && !ts.corked && !ts.bufferProcessing && ts.bufferedRequest && Ci(this, ts));
  }, Bi.prototype.setDefaultEncoding = function(qi) {
    if (typeof qi == "string" && (qi = qi.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((qi + "").toLowerCase()) > -1)) throw new Mi(qi);
    return this._writableState.defaultEncoding = qi, this;
  }, Object.defineProperty(Bi.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function zi(ts, qi, Hi) {
    return !ts.objectMode && ts.decodeStrings !== !1 && typeof qi == "string" && (qi = Pe.from(qi, Hi)), qi;
  }
  Object.defineProperty(Bi.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function xi(ts, qi, Hi, Xi, ki, Wi) {
    if (!Hi) {
      var Yi = zi(qi, Xi, ki);
      Xi !== Yi && (Hi = !0, ki = "buffer", Xi = Yi);
    }
    var Qi = qi.objectMode ? 1 : Xi.length;
    qi.length += Qi;
    var ns = qi.length < qi.highWaterMark;
    if (ns || (qi.needDrain = !0), qi.writing || qi.corked) {
      var us = qi.lastBufferedRequest;
      qi.lastBufferedRequest = {
        chunk: Xi,
        encoding: ki,
        isBuf: Hi,
        callback: Wi,
        next: null
      }, us ? us.next = qi.lastBufferedRequest : qi.bufferedRequest = qi.lastBufferedRequest, qi.bufferedRequestCount += 1;
    } else
      $i(ts, qi, !1, Qi, Xi, ki, Wi);
    return ns;
  }
  function $i(ts, qi, Hi, Xi, ki, Wi, Yi) {
    qi.writelen = Xi, qi.writecb = Yi, qi.writing = !0, qi.sync = !0, qi.destroyed ? qi.onwrite(new _i("write")) : Hi ? ts._writev(ki, qi.onwrite) : ts._write(ki, Wi, qi.onwrite), qi.sync = !1;
  }
  function vi(ts, qi, Hi, Xi, ki) {
    --qi.pendingcb, Hi ? (process$1$1.nextTick(ki, Xi), process$1$1.nextTick(Vi, ts, qi), ts._writableState.errorEmitted = !0, Oi(ts, Xi)) : (ki(Xi), ts._writableState.errorEmitted = !0, Oi(ts, Xi), Vi(ts, qi));
  }
  function wi(ts) {
    ts.writing = !1, ts.writecb = null, ts.length -= ts.writelen, ts.writelen = 0;
  }
  function Ai(ts, qi) {
    var Hi = ts._writableState, Xi = Hi.sync, ki = Hi.writecb;
    if (typeof ki != "function") throw new bi();
    if (wi(Hi), qi) vi(ts, Hi, Xi, qi, ki);
    else {
      var Wi = Ii(Hi) || ts.destroyed;
      !Wi && !Hi.corked && !Hi.bufferProcessing && Hi.bufferedRequest && Ci(ts, Hi), Xi ? process$1$1.nextTick(Ri, ts, Hi, Wi, ki) : Ri(ts, Hi, Wi, ki);
    }
  }
  function Ri(ts, qi, Hi, Xi) {
    Hi || Ti(ts, qi), qi.pendingcb--, Xi(), Vi(ts, qi);
  }
  function Ti(ts, qi) {
    qi.length === 0 && qi.needDrain && (qi.needDrain = !1, ts.emit("drain"));
  }
  function Ci(ts, qi) {
    qi.bufferProcessing = !0;
    var Hi = qi.bufferedRequest;
    if (ts._writev && Hi && Hi.next) {
      var Xi = qi.bufferedRequestCount, ki = new Array(Xi), Wi = qi.corkedRequestsFree;
      Wi.entry = Hi;
      for (var Yi = 0, Qi = !0; Hi; )
        ki[Yi] = Hi, Hi.isBuf || (Qi = !1), Hi = Hi.next, Yi += 1;
      ki.allBuffers = Qi, $i(ts, qi, !0, qi.length, ki, "", Wi.finish), qi.pendingcb++, qi.lastBufferedRequest = null, Wi.next ? (qi.corkedRequestsFree = Wi.next, Wi.next = null) : qi.corkedRequestsFree = new Ae(qi), qi.bufferedRequestCount = 0;
    } else {
      for (; Hi; ) {
        var ns = Hi.chunk, us = Hi.encoding, ps = Hi.callback, Ds = qi.objectMode ? 1 : ns.length;
        if ($i(ts, qi, !1, Ds, ns, us, ps), Hi = Hi.next, qi.bufferedRequestCount--, qi.writing)
          break;
      }
      Hi === null && (qi.lastBufferedRequest = null);
    }
    qi.bufferedRequest = Hi, qi.bufferProcessing = !1;
  }
  Bi.prototype._write = function(ts, qi, Hi) {
    Hi(new fi("_write()"));
  }, Bi.prototype._writev = null, Bi.prototype.end = function(ts, qi, Hi) {
    var Xi = this._writableState;
    return typeof ts == "function" ? (Hi = ts, ts = null, qi = null) : typeof qi == "function" && (Hi = qi, qi = null), ts != null && this.write(ts, qi), Xi.corked && (Xi.corked = 1, this.uncork()), Xi.ending || is(this, Xi, Hi), this;
  }, Object.defineProperty(Bi.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function Ii(ts) {
    return ts.ending && ts.length === 0 && ts.bufferedRequest === null && !ts.finished && !ts.writing;
  }
  function Li(ts, qi) {
    ts._final(function(Hi) {
      qi.pendingcb--, Hi && Oi(ts, Hi), qi.prefinished = !0, ts.emit("prefinish"), Vi(ts, qi);
    });
  }
  function Ni(ts, qi) {
    !qi.prefinished && !qi.finalCalled && (typeof ts._final == "function" && !qi.destroyed ? (qi.pendingcb++, qi.finalCalled = !0, process$1$1.nextTick(Li, ts, qi)) : (qi.prefinished = !0, ts.emit("prefinish")));
  }
  function Vi(ts, qi) {
    var Hi = Ii(qi);
    if (Hi && (Ni(ts, qi), qi.pendingcb === 0 && (qi.finished = !0, ts.emit("finish"), qi.autoDestroy))) {
      var Xi = ts._readableState;
      (!Xi || Xi.autoDestroy && Xi.endEmitted) && ts.destroy();
    }
    return Hi;
  }
  function is(ts, qi, Hi) {
    qi.ending = !0, Vi(ts, qi), Hi && (qi.finished ? process$1$1.nextTick(Hi) : ts.once("finish", Hi)), qi.ended = !0, ts.writable = !1;
  }
  function Ki(ts, qi, Hi) {
    var Xi = ts.entry;
    for (ts.entry = null; Xi; ) {
      var ki = Xi.callback;
      qi.pendingcb--, ki(Hi), Xi = Xi.next;
    }
    qi.corkedRequestsFree.next = ts;
  }
  return Object.defineProperty(Bi.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(qi) {
      this._writableState && (this._writableState.destroyed = qi);
    }
  }), Bi.prototype.destroy = je.destroy, Bi.prototype._undestroy = je.undestroy, Bi.prototype._destroy = function(ts, qi) {
    qi(ts);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var Ae = Object.keys || function(fn) {
    var Ve = [];
    for (var vn in fn) Ve.push(vn);
    return Ve;
  };
  _stream_duplex$1 = Me;
  var t = require_stream_readable$1(), Ie = require_stream_writable$1();
  requireInherits_browser()(Me, t);
  for (var Be = Ae(Ie.prototype), Pe = 0; Pe < Be.length; Pe++) {
    var Te = Be[Pe];
    Me.prototype[Te] || (Me.prototype[Te] = Ie.prototype[Te]);
  }
  function Me(fn) {
    if (!(this instanceof Me)) return new Me(fn);
    t.call(this, fn), Ie.call(this, fn), this.allowHalfOpen = !0, fn && (fn.readable === !1 && (this.readable = !1), fn.writable === !1 && (this.writable = !1), fn.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", Ue)));
  }
  Object.defineProperty(Me.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(Me.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(Me.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function Ue() {
    this._writableState.ended || process$1$1.nextTick(je, this);
  }
  function je(fn) {
    fn.end();
  }
  return Object.defineProperty(Me.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(Ve) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = Ve, this._writableState.destroyed = Ve);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, Buffer$2 = requireSafeBuffer$1().Buffer, isEncoding = Buffer$2.isEncoding || function(Ae) {
  switch (Ae = "" + Ae, Ae && Ae.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function _normalizeEncoding(Ae) {
  if (!Ae) return "utf8";
  for (var t; ; )
    switch (Ae) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return Ae;
      default:
        if (t) return;
        Ae = ("" + Ae).toLowerCase(), t = !0;
    }
}
function normalizeEncoding$1(Ae) {
  var t = _normalizeEncoding(Ae);
  if (typeof t != "string" && (Buffer$2.isEncoding === isEncoding || !isEncoding(Ae))) throw new Error("Unknown encoding: " + Ae);
  return t || Ae;
}
string_decoder.StringDecoder = StringDecoder;
function StringDecoder(Ae) {
  this.encoding = normalizeEncoding$1(Ae);
  var t;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text, this.end = utf16End, t = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast, t = 4;
      break;
    case "base64":
      this.text = base64Text, this.end = base64End, t = 3;
      break;
    default:
      this.write = simpleWrite, this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer$2.allocUnsafe(t);
}
StringDecoder.prototype.write = function(Ae) {
  if (Ae.length === 0) return "";
  var t, Ie;
  if (this.lastNeed) {
    if (t = this.fillLast(Ae), t === void 0) return "";
    Ie = this.lastNeed, this.lastNeed = 0;
  } else
    Ie = 0;
  return Ie < Ae.length ? t ? t + this.text(Ae, Ie) : this.text(Ae, Ie) : t || "";
};
StringDecoder.prototype.end = utf8End;
StringDecoder.prototype.text = utf8Text;
StringDecoder.prototype.fillLast = function(Ae) {
  if (this.lastNeed <= Ae.length)
    return Ae.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  Ae.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, Ae.length), this.lastNeed -= Ae.length;
};
function utf8CheckByte(Ae) {
  return Ae <= 127 ? 0 : Ae >> 5 === 6 ? 2 : Ae >> 4 === 14 ? 3 : Ae >> 3 === 30 ? 4 : Ae >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(Ae, t, Ie) {
  var Be = t.length - 1;
  if (Be < Ie) return 0;
  var Pe = utf8CheckByte(t[Be]);
  return Pe >= 0 ? (Pe > 0 && (Ae.lastNeed = Pe - 1), Pe) : --Be < Ie || Pe === -2 ? 0 : (Pe = utf8CheckByte(t[Be]), Pe >= 0 ? (Pe > 0 && (Ae.lastNeed = Pe - 2), Pe) : --Be < Ie || Pe === -2 ? 0 : (Pe = utf8CheckByte(t[Be]), Pe >= 0 ? (Pe > 0 && (Pe === 2 ? Pe = 0 : Ae.lastNeed = Pe - 3), Pe) : 0));
}
function utf8CheckExtraBytes(Ae, t, Ie) {
  if ((t[0] & 192) !== 128)
    return Ae.lastNeed = 0, "";
  if (Ae.lastNeed > 1 && t.length > 1) {
    if ((t[1] & 192) !== 128)
      return Ae.lastNeed = 1, "";
    if (Ae.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
      return Ae.lastNeed = 2, "";
  }
}
function utf8FillLast(Ae) {
  var t = this.lastTotal - this.lastNeed, Ie = utf8CheckExtraBytes(this, Ae);
  if (Ie !== void 0) return Ie;
  if (this.lastNeed <= Ae.length)
    return Ae.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  Ae.copy(this.lastChar, t, 0, Ae.length), this.lastNeed -= Ae.length;
}
function utf8Text(Ae, t) {
  var Ie = utf8CheckIncomplete(this, Ae, t);
  if (!this.lastNeed) return Ae.toString("utf8", t);
  this.lastTotal = Ie;
  var Be = Ae.length - (Ie - this.lastNeed);
  return Ae.copy(this.lastChar, 0, Be), Ae.toString("utf8", t, Be);
}
function utf8End(Ae) {
  var t = Ae && Ae.length ? this.write(Ae) : "";
  return this.lastNeed ? t + "" : t;
}
function utf16Text(Ae, t) {
  if ((Ae.length - t) % 2 === 0) {
    var Ie = Ae.toString("utf16le", t);
    if (Ie) {
      var Be = Ie.charCodeAt(Ie.length - 1);
      if (Be >= 55296 && Be <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = Ae[Ae.length - 2], this.lastChar[1] = Ae[Ae.length - 1], Ie.slice(0, -1);
    }
    return Ie;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = Ae[Ae.length - 1], Ae.toString("utf16le", t, Ae.length - 1);
}
function utf16End(Ae) {
  var t = Ae && Ae.length ? this.write(Ae) : "";
  if (this.lastNeed) {
    var Ie = this.lastTotal - this.lastNeed;
    return t + this.lastChar.toString("utf16le", 0, Ie);
  }
  return t;
}
function base64Text(Ae, t) {
  var Ie = (Ae.length - t) % 3;
  return Ie === 0 ? Ae.toString("base64", t) : (this.lastNeed = 3 - Ie, this.lastTotal = 3, Ie === 1 ? this.lastChar[0] = Ae[Ae.length - 1] : (this.lastChar[0] = Ae[Ae.length - 2], this.lastChar[1] = Ae[Ae.length - 1]), Ae.toString("base64", t, Ae.length - Ie));
}
function base64End(Ae) {
  var t = Ae && Ae.length ? this.write(Ae) : "";
  return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
}
function simpleWrite(Ae) {
  return Ae.toString(this.encoding);
}
function simpleEnd(Ae) {
  return Ae && Ae.length ? this.write(Ae) : "";
}
var endOfStream$1, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream$1;
  hasRequiredEndOfStream = 1;
  var Ae = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function t(Te) {
    var Me = !1;
    return function() {
      if (!Me) {
        Me = !0;
        for (var Ue = arguments.length, je = new Array(Ue), fn = 0; fn < Ue; fn++)
          je[fn] = arguments[fn];
        Te.apply(this, je);
      }
    };
  }
  function Ie() {
  }
  function Be(Te) {
    return Te.setHeader && typeof Te.abort == "function";
  }
  function Pe(Te, Me, Ue) {
    if (typeof Me == "function") return Pe(Te, null, Me);
    Me || (Me = {}), Ue = t(Ue || Ie);
    var je = Me.readable || Me.readable !== !1 && Te.readable, fn = Me.writable || Me.writable !== !1 && Te.writable, Ve = function() {
      Te.writable || En();
    }, vn = Te._writableState && Te._writableState.finished, En = function() {
      fn = !1, vn = !0, je || Ue.call(Te);
    }, fi = Te._readableState && Te._readableState.endEmitted, bi = function() {
      je = !1, fi = !0, fn || Ue.call(Te);
    }, mi = function(Mi) {
      Ue.call(Te, Mi);
    }, _i = function() {
      var Mi;
      if (je && !fi)
        return (!Te._readableState || !Te._readableState.ended) && (Mi = new Ae()), Ue.call(Te, Mi);
      if (fn && !vn)
        return (!Te._writableState || !Te._writableState.ended) && (Mi = new Ae()), Ue.call(Te, Mi);
    }, Ei = function() {
      Te.req.on("finish", En);
    };
    return Be(Te) ? (Te.on("complete", En), Te.on("abort", _i), Te.req ? Ei() : Te.on("request", Ei)) : fn && !Te._writableState && (Te.on("end", Ve), Te.on("close", Ve)), Te.on("end", bi), Te.on("finish", En), Me.error !== !1 && Te.on("error", mi), Te.on("close", _i), function() {
      Te.removeListener("complete", En), Te.removeListener("abort", _i), Te.removeListener("request", Ei), Te.req && Te.req.removeListener("finish", En), Te.removeListener("end", Ve), Te.removeListener("close", Ve), Te.removeListener("finish", En), Te.removeListener("end", bi), Te.removeListener("error", mi), Te.removeListener("close", _i);
    };
  }
  return endOfStream$1 = Pe, endOfStream$1;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var Ae;
  function t(Mi, Oi, Fi) {
    return Oi = Ie(Oi), Oi in Mi ? Object.defineProperty(Mi, Oi, { value: Fi, enumerable: !0, configurable: !0, writable: !0 }) : Mi[Oi] = Fi, Mi;
  }
  function Ie(Mi) {
    var Oi = Be(Mi, "string");
    return typeof Oi == "symbol" ? Oi : String(Oi);
  }
  function Be(Mi, Oi) {
    if (typeof Mi != "object" || Mi === null) return Mi;
    var Fi = Mi[Symbol.toPrimitive];
    if (Fi !== void 0) {
      var Ui = Fi.call(Mi, Oi || "default");
      if (typeof Ui != "object") return Ui;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (Oi === "string" ? String : Number)(Mi);
  }
  var Pe = requireEndOfStream(), Te = Symbol("lastResolve"), Me = Symbol("lastReject"), Ue = Symbol("error"), je = Symbol("ended"), fn = Symbol("lastPromise"), Ve = Symbol("handlePromise"), vn = Symbol("stream");
  function En(Mi, Oi) {
    return {
      value: Mi,
      done: Oi
    };
  }
  function fi(Mi) {
    var Oi = Mi[Te];
    if (Oi !== null) {
      var Fi = Mi[vn].read();
      Fi !== null && (Mi[fn] = null, Mi[Te] = null, Mi[Me] = null, Oi(En(Fi, !1)));
    }
  }
  function bi(Mi) {
    process$1$1.nextTick(fi, Mi);
  }
  function mi(Mi, Oi) {
    return function(Fi, Ui) {
      Mi.then(function() {
        if (Oi[je]) {
          Fi(En(void 0, !0));
          return;
        }
        Oi[Ve](Fi, Ui);
      }, Ui);
    };
  }
  var _i = Object.getPrototypeOf(function() {
  }), Ei = Object.setPrototypeOf((Ae = {
    get stream() {
      return this[vn];
    },
    next: function() {
      var Oi = this, Fi = this[Ue];
      if (Fi !== null)
        return Promise.reject(Fi);
      if (this[je])
        return Promise.resolve(En(void 0, !0));
      if (this[vn].destroyed)
        return new Promise(function(ji, Zi) {
          process$1$1.nextTick(function() {
            Oi[Ue] ? Zi(Oi[Ue]) : ji(En(void 0, !0));
          });
        });
      var Ui = this[fn], Pi;
      if (Ui)
        Pi = new Promise(mi(Ui, this));
      else {
        var Bi = this[vn].read();
        if (Bi !== null)
          return Promise.resolve(En(Bi, !1));
        Pi = new Promise(this[Ve]);
      }
      return this[fn] = Pi, Pi;
    }
  }, t(Ae, Symbol.asyncIterator, function() {
    return this;
  }), t(Ae, "return", function() {
    var Oi = this;
    return new Promise(function(Fi, Ui) {
      Oi[vn].destroy(null, function(Pi) {
        if (Pi) {
          Ui(Pi);
          return;
        }
        Fi(En(void 0, !0));
      });
    });
  }), Ae), _i), Si = function(Oi) {
    var Fi, Ui = Object.create(Ei, (Fi = {}, t(Fi, vn, {
      value: Oi,
      writable: !0
    }), t(Fi, Te, {
      value: null,
      writable: !0
    }), t(Fi, Me, {
      value: null,
      writable: !0
    }), t(Fi, Ue, {
      value: null,
      writable: !0
    }), t(Fi, je, {
      value: Oi._readableState.endEmitted,
      writable: !0
    }), t(Fi, Ve, {
      value: function(Bi, ji) {
        var Zi = Ui[vn].read();
        Zi ? (Ui[fn] = null, Ui[Te] = null, Ui[Me] = null, Bi(En(Zi, !1))) : (Ui[Te] = Bi, Ui[Me] = ji);
      },
      writable: !0
    }), Fi));
    return Ui[fn] = null, Pe(Oi, function(Pi) {
      if (Pi && Pi.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Bi = Ui[Me];
        Bi !== null && (Ui[fn] = null, Ui[Te] = null, Ui[Me] = null, Bi(Pi)), Ui[Ue] = Pi;
        return;
      }
      var ji = Ui[Te];
      ji !== null && (Ui[fn] = null, Ui[Te] = null, Ui[Me] = null, ji(En(void 0, !0))), Ui[je] = !0;
    }), Oi.on("readable", bi.bind(null, Ui)), Ui;
  };
  return async_iterator = Si, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = ji;
  var Ae;
  ji.ReadableState = Bi, eventsExports.EventEmitter;
  var t = function(Yi, Qi) {
    return Yi.listeners(Qi).length;
  }, Ie = requireStreamBrowser$1(), Be = require$$0$4.Buffer, Pe = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function Te(Wi) {
    return Be.from(Wi);
  }
  function Me(Wi) {
    return Be.isBuffer(Wi) || Wi instanceof Pe;
  }
  var Ue = util$2, je;
  Ue && Ue.debuglog ? je = Ue.debuglog("stream") : je = function() {
  };
  var fn = requireBuffer_list(), Ve = requireDestroy$1(), vn = requireState(), En = vn.getHighWaterMark, fi = requireErrorsBrowser().codes, bi = fi.ERR_INVALID_ARG_TYPE, mi = fi.ERR_STREAM_PUSH_AFTER_EOF, _i = fi.ERR_METHOD_NOT_IMPLEMENTED, Ei = fi.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Si, Mi, Oi;
  requireInherits_browser()(ji, Ie);
  var Fi = Ve.errorOrDestroy, Ui = ["error", "close", "destroy", "pause", "resume"];
  function Pi(Wi, Yi, Qi) {
    if (typeof Wi.prependListener == "function") return Wi.prependListener(Yi, Qi);
    !Wi._events || !Wi._events[Yi] ? Wi.on(Yi, Qi) : Array.isArray(Wi._events[Yi]) ? Wi._events[Yi].unshift(Qi) : Wi._events[Yi] = [Qi, Wi._events[Yi]];
  }
  function Bi(Wi, Yi, Qi) {
    Ae = Ae || require_stream_duplex$1(), Wi = Wi || {}, typeof Qi != "boolean" && (Qi = Yi instanceof Ae), this.objectMode = !!Wi.objectMode, Qi && (this.objectMode = this.objectMode || !!Wi.readableObjectMode), this.highWaterMark = En(this, Wi, "readableHighWaterMark", Qi), this.buffer = new fn(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Wi.emitClose !== !1, this.autoDestroy = !!Wi.autoDestroy, this.destroyed = !1, this.defaultEncoding = Wi.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Wi.encoding && (Si || (Si = string_decoder.StringDecoder), this.decoder = new Si(Wi.encoding), this.encoding = Wi.encoding);
  }
  function ji(Wi) {
    if (Ae = Ae || require_stream_duplex$1(), !(this instanceof ji)) return new ji(Wi);
    var Yi = this instanceof Ae;
    this._readableState = new Bi(Wi, this, Yi), this.readable = !0, Wi && (typeof Wi.read == "function" && (this._read = Wi.read), typeof Wi.destroy == "function" && (this._destroy = Wi.destroy)), Ie.call(this);
  }
  Object.defineProperty(ji.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Yi) {
      this._readableState && (this._readableState.destroyed = Yi);
    }
  }), ji.prototype.destroy = Ve.destroy, ji.prototype._undestroy = Ve.undestroy, ji.prototype._destroy = function(Wi, Yi) {
    Yi(Wi);
  }, ji.prototype.push = function(Wi, Yi) {
    var Qi = this._readableState, ns;
    return Qi.objectMode ? ns = !0 : typeof Wi == "string" && (Yi = Yi || Qi.defaultEncoding, Yi !== Qi.encoding && (Wi = Be.from(Wi, Yi), Yi = ""), ns = !0), Zi(this, Wi, Yi, !1, ns);
  }, ji.prototype.unshift = function(Wi) {
    return Zi(this, Wi, null, !0, !1);
  };
  function Zi(Wi, Yi, Qi, ns, us) {
    je("readableAddChunk", Yi);
    var ps = Wi._readableState;
    if (Yi === null)
      ps.reading = !1, Ai(Wi, ps);
    else {
      var Ds;
      if (us || (Ds = xi(ps, Yi)), Ds)
        Fi(Wi, Ds);
      else if (ps.objectMode || Yi && Yi.length > 0)
        if (typeof Yi != "string" && !ps.objectMode && Object.getPrototypeOf(Yi) !== Be.prototype && (Yi = Te(Yi)), ns)
          ps.endEmitted ? Fi(Wi, new Ei()) : zi(Wi, ps, Yi, !0);
        else if (ps.ended)
          Fi(Wi, new mi());
        else {
          if (ps.destroyed)
            return !1;
          ps.reading = !1, ps.decoder && !Qi ? (Yi = ps.decoder.write(Yi), ps.objectMode || Yi.length !== 0 ? zi(Wi, ps, Yi, !1) : Ci(Wi, ps)) : zi(Wi, ps, Yi, !1);
        }
      else ns || (ps.reading = !1, Ci(Wi, ps));
    }
    return !ps.ended && (ps.length < ps.highWaterMark || ps.length === 0);
  }
  function zi(Wi, Yi, Qi, ns) {
    Yi.flowing && Yi.length === 0 && !Yi.sync ? (Yi.awaitDrain = 0, Wi.emit("data", Qi)) : (Yi.length += Yi.objectMode ? 1 : Qi.length, ns ? Yi.buffer.unshift(Qi) : Yi.buffer.push(Qi), Yi.needReadable && Ri(Wi)), Ci(Wi, Yi);
  }
  function xi(Wi, Yi) {
    var Qi;
    return !Me(Yi) && typeof Yi != "string" && Yi !== void 0 && !Wi.objectMode && (Qi = new bi("chunk", ["string", "Buffer", "Uint8Array"], Yi)), Qi;
  }
  ji.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, ji.prototype.setEncoding = function(Wi) {
    Si || (Si = string_decoder.StringDecoder);
    var Yi = new Si(Wi);
    this._readableState.decoder = Yi, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Qi = this._readableState.buffer.head, ns = ""; Qi !== null; )
      ns += Yi.write(Qi.data), Qi = Qi.next;
    return this._readableState.buffer.clear(), ns !== "" && this._readableState.buffer.push(ns), this._readableState.length = ns.length, this;
  };
  var $i = 1073741824;
  function vi(Wi) {
    return Wi >= $i ? Wi = $i : (Wi--, Wi |= Wi >>> 1, Wi |= Wi >>> 2, Wi |= Wi >>> 4, Wi |= Wi >>> 8, Wi |= Wi >>> 16, Wi++), Wi;
  }
  function wi(Wi, Yi) {
    return Wi <= 0 || Yi.length === 0 && Yi.ended ? 0 : Yi.objectMode ? 1 : Wi !== Wi ? Yi.flowing && Yi.length ? Yi.buffer.head.data.length : Yi.length : (Wi > Yi.highWaterMark && (Yi.highWaterMark = vi(Wi)), Wi <= Yi.length ? Wi : Yi.ended ? Yi.length : (Yi.needReadable = !0, 0));
  }
  ji.prototype.read = function(Wi) {
    je("read", Wi), Wi = parseInt(Wi, 10);
    var Yi = this._readableState, Qi = Wi;
    if (Wi !== 0 && (Yi.emittedReadable = !1), Wi === 0 && Yi.needReadable && ((Yi.highWaterMark !== 0 ? Yi.length >= Yi.highWaterMark : Yi.length > 0) || Yi.ended))
      return je("read: emitReadable", Yi.length, Yi.ended), Yi.length === 0 && Yi.ended ? Hi(this) : Ri(this), null;
    if (Wi = wi(Wi, Yi), Wi === 0 && Yi.ended)
      return Yi.length === 0 && Hi(this), null;
    var ns = Yi.needReadable;
    je("need readable", ns), (Yi.length === 0 || Yi.length - Wi < Yi.highWaterMark) && (ns = !0, je("length less than watermark", ns)), Yi.ended || Yi.reading ? (ns = !1, je("reading or ended", ns)) : ns && (je("do read"), Yi.reading = !0, Yi.sync = !0, Yi.length === 0 && (Yi.needReadable = !0), this._read(Yi.highWaterMark), Yi.sync = !1, Yi.reading || (Wi = wi(Qi, Yi)));
    var us;
    return Wi > 0 ? us = qi(Wi, Yi) : us = null, us === null ? (Yi.needReadable = Yi.length <= Yi.highWaterMark, Wi = 0) : (Yi.length -= Wi, Yi.awaitDrain = 0), Yi.length === 0 && (Yi.ended || (Yi.needReadable = !0), Qi !== Wi && Yi.ended && Hi(this)), us !== null && this.emit("data", us), us;
  };
  function Ai(Wi, Yi) {
    if (je("onEofChunk"), !Yi.ended) {
      if (Yi.decoder) {
        var Qi = Yi.decoder.end();
        Qi && Qi.length && (Yi.buffer.push(Qi), Yi.length += Yi.objectMode ? 1 : Qi.length);
      }
      Yi.ended = !0, Yi.sync ? Ri(Wi) : (Yi.needReadable = !1, Yi.emittedReadable || (Yi.emittedReadable = !0, Ti(Wi)));
    }
  }
  function Ri(Wi) {
    var Yi = Wi._readableState;
    je("emitReadable", Yi.needReadable, Yi.emittedReadable), Yi.needReadable = !1, Yi.emittedReadable || (je("emitReadable", Yi.flowing), Yi.emittedReadable = !0, process$1$1.nextTick(Ti, Wi));
  }
  function Ti(Wi) {
    var Yi = Wi._readableState;
    je("emitReadable_", Yi.destroyed, Yi.length, Yi.ended), !Yi.destroyed && (Yi.length || Yi.ended) && (Wi.emit("readable"), Yi.emittedReadable = !1), Yi.needReadable = !Yi.flowing && !Yi.ended && Yi.length <= Yi.highWaterMark, ts(Wi);
  }
  function Ci(Wi, Yi) {
    Yi.readingMore || (Yi.readingMore = !0, process$1$1.nextTick(Ii, Wi, Yi));
  }
  function Ii(Wi, Yi) {
    for (; !Yi.reading && !Yi.ended && (Yi.length < Yi.highWaterMark || Yi.flowing && Yi.length === 0); ) {
      var Qi = Yi.length;
      if (je("maybeReadMore read 0"), Wi.read(0), Qi === Yi.length)
        break;
    }
    Yi.readingMore = !1;
  }
  ji.prototype._read = function(Wi) {
    Fi(this, new _i("_read()"));
  }, ji.prototype.pipe = function(Wi, Yi) {
    var Qi = this, ns = this._readableState;
    switch (ns.pipesCount) {
      case 0:
        ns.pipes = Wi;
        break;
      case 1:
        ns.pipes = [ns.pipes, Wi];
        break;
      default:
        ns.pipes.push(Wi);
        break;
    }
    ns.pipesCount += 1, je("pipe count=%d opts=%j", ns.pipesCount, Yi);
    var us = (!Yi || Yi.end !== !1) && Wi !== process$1$1.stdout && Wi !== process$1$1.stderr, ps = us ? Eo : To;
    ns.endEmitted ? process$1$1.nextTick(ps) : Qi.once("end", ps), Wi.on("unpipe", Ds);
    function Ds(Ao, Po) {
      je("onunpipe"), Ao === Qi && Po && Po.hasUnpiped === !1 && (Po.hasUnpiped = !0, _o());
    }
    function Eo() {
      je("onend"), Wi.end();
    }
    var hs = Li(Qi);
    Wi.on("drain", hs);
    var So = !1;
    function _o() {
      je("cleanup"), Wi.removeListener("close", $o), Wi.removeListener("finish", Io), Wi.removeListener("drain", hs), Wi.removeListener("error", Ro), Wi.removeListener("unpipe", Ds), Qi.removeListener("end", Eo), Qi.removeListener("end", To), Qi.removeListener("data", vo), So = !0, ns.awaitDrain && (!Wi._writableState || Wi._writableState.needDrain) && hs();
    }
    Qi.on("data", vo);
    function vo(Ao) {
      je("ondata");
      var Po = Wi.write(Ao);
      je("dest.write", Po), Po === !1 && ((ns.pipesCount === 1 && ns.pipes === Wi || ns.pipesCount > 1 && ki(ns.pipes, Wi) !== -1) && !So && (je("false write response, pause", ns.awaitDrain), ns.awaitDrain++), Qi.pause());
    }
    function Ro(Ao) {
      je("onerror", Ao), To(), Wi.removeListener("error", Ro), t(Wi, "error") === 0 && Fi(Wi, Ao);
    }
    Pi(Wi, "error", Ro);
    function $o() {
      Wi.removeListener("finish", Io), To();
    }
    Wi.once("close", $o);
    function Io() {
      je("onfinish"), Wi.removeListener("close", $o), To();
    }
    Wi.once("finish", Io);
    function To() {
      je("unpipe"), Qi.unpipe(Wi);
    }
    return Wi.emit("pipe", Qi), ns.flowing || (je("pipe resume"), Qi.resume()), Wi;
  };
  function Li(Wi) {
    return function() {
      var Qi = Wi._readableState;
      je("pipeOnDrain", Qi.awaitDrain), Qi.awaitDrain && Qi.awaitDrain--, Qi.awaitDrain === 0 && t(Wi, "data") && (Qi.flowing = !0, ts(Wi));
    };
  }
  ji.prototype.unpipe = function(Wi) {
    var Yi = this._readableState, Qi = {
      hasUnpiped: !1
    };
    if (Yi.pipesCount === 0) return this;
    if (Yi.pipesCount === 1)
      return Wi && Wi !== Yi.pipes ? this : (Wi || (Wi = Yi.pipes), Yi.pipes = null, Yi.pipesCount = 0, Yi.flowing = !1, Wi && Wi.emit("unpipe", this, Qi), this);
    if (!Wi) {
      var ns = Yi.pipes, us = Yi.pipesCount;
      Yi.pipes = null, Yi.pipesCount = 0, Yi.flowing = !1;
      for (var ps = 0; ps < us; ps++) ns[ps].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var Ds = ki(Yi.pipes, Wi);
    return Ds === -1 ? this : (Yi.pipes.splice(Ds, 1), Yi.pipesCount -= 1, Yi.pipesCount === 1 && (Yi.pipes = Yi.pipes[0]), Wi.emit("unpipe", this, Qi), this);
  }, ji.prototype.on = function(Wi, Yi) {
    var Qi = Ie.prototype.on.call(this, Wi, Yi), ns = this._readableState;
    return Wi === "data" ? (ns.readableListening = this.listenerCount("readable") > 0, ns.flowing !== !1 && this.resume()) : Wi === "readable" && !ns.endEmitted && !ns.readableListening && (ns.readableListening = ns.needReadable = !0, ns.flowing = !1, ns.emittedReadable = !1, je("on readable", ns.length, ns.reading), ns.length ? Ri(this) : ns.reading || process$1$1.nextTick(Vi, this)), Qi;
  }, ji.prototype.addListener = ji.prototype.on, ji.prototype.removeListener = function(Wi, Yi) {
    var Qi = Ie.prototype.removeListener.call(this, Wi, Yi);
    return Wi === "readable" && process$1$1.nextTick(Ni, this), Qi;
  }, ji.prototype.removeAllListeners = function(Wi) {
    var Yi = Ie.prototype.removeAllListeners.apply(this, arguments);
    return (Wi === "readable" || Wi === void 0) && process$1$1.nextTick(Ni, this), Yi;
  };
  function Ni(Wi) {
    var Yi = Wi._readableState;
    Yi.readableListening = Wi.listenerCount("readable") > 0, Yi.resumeScheduled && !Yi.paused ? Yi.flowing = !0 : Wi.listenerCount("data") > 0 && Wi.resume();
  }
  function Vi(Wi) {
    je("readable nexttick read 0"), Wi.read(0);
  }
  ji.prototype.resume = function() {
    var Wi = this._readableState;
    return Wi.flowing || (je("resume"), Wi.flowing = !Wi.readableListening, is(this, Wi)), Wi.paused = !1, this;
  };
  function is(Wi, Yi) {
    Yi.resumeScheduled || (Yi.resumeScheduled = !0, process$1$1.nextTick(Ki, Wi, Yi));
  }
  function Ki(Wi, Yi) {
    je("resume", Yi.reading), Yi.reading || Wi.read(0), Yi.resumeScheduled = !1, Wi.emit("resume"), ts(Wi), Yi.flowing && !Yi.reading && Wi.read(0);
  }
  ji.prototype.pause = function() {
    return je("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (je("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function ts(Wi) {
    var Yi = Wi._readableState;
    for (je("flow", Yi.flowing); Yi.flowing && Wi.read() !== null; ) ;
  }
  ji.prototype.wrap = function(Wi) {
    var Yi = this, Qi = this._readableState, ns = !1;
    Wi.on("end", function() {
      if (je("wrapped end"), Qi.decoder && !Qi.ended) {
        var Ds = Qi.decoder.end();
        Ds && Ds.length && Yi.push(Ds);
      }
      Yi.push(null);
    }), Wi.on("data", function(Ds) {
      if (je("wrapped data"), Qi.decoder && (Ds = Qi.decoder.write(Ds)), !(Qi.objectMode && Ds == null) && !(!Qi.objectMode && (!Ds || !Ds.length))) {
        var Eo = Yi.push(Ds);
        Eo || (ns = !0, Wi.pause());
      }
    });
    for (var us in Wi)
      this[us] === void 0 && typeof Wi[us] == "function" && (this[us] = /* @__PURE__ */ function(Eo) {
        return function() {
          return Wi[Eo].apply(Wi, arguments);
        };
      }(us));
    for (var ps = 0; ps < Ui.length; ps++)
      Wi.on(Ui[ps], this.emit.bind(this, Ui[ps]));
    return this._read = function(Ds) {
      je("wrapped _read", Ds), ns && (ns = !1, Wi.resume());
    }, this;
  }, typeof Symbol == "function" && (ji.prototype[Symbol.asyncIterator] = function() {
    return Mi === void 0 && (Mi = requireAsync_iterator()), Mi(this);
  }), Object.defineProperty(ji.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(ji.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(ji.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(Yi) {
      this._readableState && (this._readableState.flowing = Yi);
    }
  }), ji._fromList = qi, Object.defineProperty(ji.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function qi(Wi, Yi) {
    if (Yi.length === 0) return null;
    var Qi;
    return Yi.objectMode ? Qi = Yi.buffer.shift() : !Wi || Wi >= Yi.length ? (Yi.decoder ? Qi = Yi.buffer.join("") : Yi.buffer.length === 1 ? Qi = Yi.buffer.first() : Qi = Yi.buffer.concat(Yi.length), Yi.buffer.clear()) : Qi = Yi.buffer.consume(Wi, Yi.decoder), Qi;
  }
  function Hi(Wi) {
    var Yi = Wi._readableState;
    je("endReadable", Yi.endEmitted), Yi.endEmitted || (Yi.ended = !0, process$1$1.nextTick(Xi, Yi, Wi));
  }
  function Xi(Wi, Yi) {
    if (je("endReadableNT", Wi.endEmitted, Wi.length), !Wi.endEmitted && Wi.length === 0 && (Wi.endEmitted = !0, Yi.readable = !1, Yi.emit("end"), Wi.autoDestroy)) {
      var Qi = Yi._writableState;
      (!Qi || Qi.autoDestroy && Qi.finished) && Yi.destroy();
    }
  }
  typeof Symbol == "function" && (ji.from = function(Wi, Yi) {
    return Oi === void 0 && (Oi = requireFromBrowser()), Oi(ji, Wi, Yi);
  });
  function ki(Wi, Yi) {
    for (var Qi = 0, ns = Wi.length; Qi < ns; Qi++)
      if (Wi[Qi] === Yi) return Qi;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1) return _stream_transform$1;
  hasRequired_stream_transform$1 = 1, _stream_transform$1 = Ue;
  var Ae = requireErrorsBrowser().codes, t = Ae.ERR_METHOD_NOT_IMPLEMENTED, Ie = Ae.ERR_MULTIPLE_CALLBACK, Be = Ae.ERR_TRANSFORM_ALREADY_TRANSFORMING, Pe = Ae.ERR_TRANSFORM_WITH_LENGTH_0, Te = require_stream_duplex$1();
  requireInherits_browser()(Ue, Te);
  function Me(Ve, vn) {
    var En = this._transformState;
    En.transforming = !1;
    var fi = En.writecb;
    if (fi === null)
      return this.emit("error", new Ie());
    En.writechunk = null, En.writecb = null, vn != null && this.push(vn), fi(Ve);
    var bi = this._readableState;
    bi.reading = !1, (bi.needReadable || bi.length < bi.highWaterMark) && this._read(bi.highWaterMark);
  }
  function Ue(Ve) {
    if (!(this instanceof Ue)) return new Ue(Ve);
    Te.call(this, Ve), this._transformState = {
      afterTransform: Me.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, Ve && (typeof Ve.transform == "function" && (this._transform = Ve.transform), typeof Ve.flush == "function" && (this._flush = Ve.flush)), this.on("prefinish", je);
  }
  function je() {
    var Ve = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(vn, En) {
      fn(Ve, vn, En);
    }) : fn(this, null, null);
  }
  Ue.prototype.push = function(Ve, vn) {
    return this._transformState.needTransform = !1, Te.prototype.push.call(this, Ve, vn);
  }, Ue.prototype._transform = function(Ve, vn, En) {
    En(new t("_transform()"));
  }, Ue.prototype._write = function(Ve, vn, En) {
    var fi = this._transformState;
    if (fi.writecb = En, fi.writechunk = Ve, fi.writeencoding = vn, !fi.transforming) {
      var bi = this._readableState;
      (fi.needTransform || bi.needReadable || bi.length < bi.highWaterMark) && this._read(bi.highWaterMark);
    }
  }, Ue.prototype._read = function(Ve) {
    var vn = this._transformState;
    vn.writechunk !== null && !vn.transforming ? (vn.transforming = !0, this._transform(vn.writechunk, vn.writeencoding, vn.afterTransform)) : vn.needTransform = !0;
  }, Ue.prototype._destroy = function(Ve, vn) {
    Te.prototype._destroy.call(this, Ve, function(En) {
      vn(En);
    });
  };
  function fn(Ve, vn, En) {
    if (vn) return Ve.emit("error", vn);
    if (En != null && Ve.push(En), Ve._writableState.length) throw new Pe();
    if (Ve._transformState.transforming) throw new Be();
    return Ve.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1, _stream_passthrough$1 = t;
  var Ae = require_stream_transform$1();
  requireInherits_browser()(t, Ae);
  function t(Ie) {
    if (!(this instanceof t)) return new t(Ie);
    Ae.call(this, Ie);
  }
  return t.prototype._transform = function(Ie, Be, Pe) {
    Pe(null, Ie);
  }, _stream_passthrough$1;
}
var pipeline_1$1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1$1;
  hasRequiredPipeline = 1;
  var Ae;
  function t(En) {
    var fi = !1;
    return function() {
      fi || (fi = !0, En.apply(void 0, arguments));
    };
  }
  var Ie = requireErrorsBrowser().codes, Be = Ie.ERR_MISSING_ARGS, Pe = Ie.ERR_STREAM_DESTROYED;
  function Te(En) {
    if (En) throw En;
  }
  function Me(En) {
    return En.setHeader && typeof En.abort == "function";
  }
  function Ue(En, fi, bi, mi) {
    mi = t(mi);
    var _i = !1;
    En.on("close", function() {
      _i = !0;
    }), Ae === void 0 && (Ae = requireEndOfStream()), Ae(En, {
      readable: fi,
      writable: bi
    }, function(Si) {
      if (Si) return mi(Si);
      _i = !0, mi();
    });
    var Ei = !1;
    return function(Si) {
      if (!_i && !Ei) {
        if (Ei = !0, Me(En)) return En.abort();
        if (typeof En.destroy == "function") return En.destroy();
        mi(Si || new Pe("pipe"));
      }
    };
  }
  function je(En) {
    En();
  }
  function fn(En, fi) {
    return En.pipe(fi);
  }
  function Ve(En) {
    return !En.length || typeof En[En.length - 1] != "function" ? Te : En.pop();
  }
  function vn() {
    for (var En = arguments.length, fi = new Array(En), bi = 0; bi < En; bi++)
      fi[bi] = arguments[bi];
    var mi = Ve(fi);
    if (Array.isArray(fi[0]) && (fi = fi[0]), fi.length < 2)
      throw new Be("streams");
    var _i, Ei = fi.map(function(Si, Mi) {
      var Oi = Mi < fi.length - 1, Fi = Mi > 0;
      return Ue(Si, Oi, Fi, function(Ui) {
        _i || (_i = Ui), Ui && Ei.forEach(je), !Oi && (Ei.forEach(je), mi(_i));
      });
    });
    return fi.reduce(fn);
  }
  return pipeline_1$1 = vn, pipeline_1$1;
}
var streamBrowserify, hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1, streamBrowserify = Ie;
  var Ae = eventsExports.EventEmitter, t = requireInherits_browser();
  t(Ie, Ae), Ie.Readable = require_stream_readable$1(), Ie.Writable = require_stream_writable$1(), Ie.Duplex = require_stream_duplex$1(), Ie.Transform = require_stream_transform$1(), Ie.PassThrough = require_stream_passthrough$1(), Ie.finished = requireEndOfStream(), Ie.pipeline = requirePipeline(), Ie.Stream = Ie;
  function Ie() {
    Ae.call(this);
  }
  return Ie.prototype.pipe = function(Be, Pe) {
    var Te = this;
    function Me(fi) {
      Be.writable && Be.write(fi) === !1 && Te.pause && Te.pause();
    }
    Te.on("data", Me);
    function Ue() {
      Te.readable && Te.resume && Te.resume();
    }
    Be.on("drain", Ue), !Be._isStdio && (!Pe || Pe.end !== !1) && (Te.on("end", fn), Te.on("close", Ve));
    var je = !1;
    function fn() {
      je || (je = !0, Be.end());
    }
    function Ve() {
      je || (je = !0, typeof Be.destroy == "function" && Be.destroy());
    }
    function vn(fi) {
      if (En(), Ae.listenerCount(this, "error") === 0)
        throw fi;
    }
    Te.on("error", vn), Be.on("error", vn);
    function En() {
      Te.removeListener("data", Me), Be.removeListener("drain", Ue), Te.removeListener("end", fn), Te.removeListener("close", Ve), Te.removeListener("error", vn), Be.removeListener("error", vn), Te.removeListener("end", En), Te.removeListener("close", En), Be.removeListener("close", En);
    }
    return Te.on("end", En), Te.on("close", En), Be.on("close", En), Be.emit("pipe", Te), Be;
  }, streamBrowserify;
}
var hashBase, hasRequiredHashBase;
function requireHashBase() {
  if (hasRequiredHashBase) return hashBase;
  hasRequiredHashBase = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requireStreamBrowserify().Transform, Ie = requireInherits_browser();
  function Be(Te, Me) {
    if (!Ae.isBuffer(Te) && typeof Te != "string")
      throw new TypeError(Me + " must be a string or a buffer");
  }
  function Pe(Te) {
    t.call(this), this._block = Ae.allocUnsafe(Te), this._blockSize = Te, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return Ie(Pe, t), Pe.prototype._transform = function(Te, Me, Ue) {
    var je = null;
    try {
      this.update(Te, Me);
    } catch (fn) {
      je = fn;
    }
    Ue(je);
  }, Pe.prototype._flush = function(Te) {
    var Me = null;
    try {
      this.push(this.digest());
    } catch (Ue) {
      Me = Ue;
    }
    Te(Me);
  }, Pe.prototype.update = function(Te, Me) {
    if (Be(Te, "Data"), this._finalized) throw new Error("Digest already called");
    Ae.isBuffer(Te) || (Te = Ae.from(Te, Me));
    for (var Ue = this._block, je = 0; this._blockOffset + Te.length - je >= this._blockSize; ) {
      for (var fn = this._blockOffset; fn < this._blockSize; ) Ue[fn++] = Te[je++];
      this._update(), this._blockOffset = 0;
    }
    for (; je < Te.length; ) Ue[this._blockOffset++] = Te[je++];
    for (var Ve = 0, vn = Te.length * 8; vn > 0; ++Ve)
      this._length[Ve] += vn, vn = this._length[Ve] / 4294967296 | 0, vn > 0 && (this._length[Ve] -= 4294967296 * vn);
    return this;
  }, Pe.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, Pe.prototype.digest = function(Te) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = !0;
    var Me = this._digest();
    Te !== void 0 && (Me = Me.toString(Te)), this._block.fill(0), this._blockOffset = 0;
    for (var Ue = 0; Ue < 4; ++Ue) this._length[Ue] = 0;
    return Me;
  }, Pe.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase = Pe, hashBase;
}
var md5_js, hasRequiredMd5_js;
function requireMd5_js() {
  if (hasRequiredMd5_js) return md5_js;
  hasRequiredMd5_js = 1;
  var Ae = requireInherits_browser(), t = requireHashBase(), Ie = requireSafeBuffer$1().Buffer, Be = new Array(16);
  function Pe() {
    t.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  Ae(Pe, t), Pe.prototype._update = function() {
    for (var Ve = Be, vn = 0; vn < 16; ++vn) Ve[vn] = this._block.readInt32LE(vn * 4);
    var En = this._a, fi = this._b, bi = this._c, mi = this._d;
    En = Me(En, fi, bi, mi, Ve[0], 3614090360, 7), mi = Me(mi, En, fi, bi, Ve[1], 3905402710, 12), bi = Me(bi, mi, En, fi, Ve[2], 606105819, 17), fi = Me(fi, bi, mi, En, Ve[3], 3250441966, 22), En = Me(En, fi, bi, mi, Ve[4], 4118548399, 7), mi = Me(mi, En, fi, bi, Ve[5], 1200080426, 12), bi = Me(bi, mi, En, fi, Ve[6], 2821735955, 17), fi = Me(fi, bi, mi, En, Ve[7], 4249261313, 22), En = Me(En, fi, bi, mi, Ve[8], 1770035416, 7), mi = Me(mi, En, fi, bi, Ve[9], 2336552879, 12), bi = Me(bi, mi, En, fi, Ve[10], 4294925233, 17), fi = Me(fi, bi, mi, En, Ve[11], 2304563134, 22), En = Me(En, fi, bi, mi, Ve[12], 1804603682, 7), mi = Me(mi, En, fi, bi, Ve[13], 4254626195, 12), bi = Me(bi, mi, En, fi, Ve[14], 2792965006, 17), fi = Me(fi, bi, mi, En, Ve[15], 1236535329, 22), En = Ue(En, fi, bi, mi, Ve[1], 4129170786, 5), mi = Ue(mi, En, fi, bi, Ve[6], 3225465664, 9), bi = Ue(bi, mi, En, fi, Ve[11], 643717713, 14), fi = Ue(fi, bi, mi, En, Ve[0], 3921069994, 20), En = Ue(En, fi, bi, mi, Ve[5], 3593408605, 5), mi = Ue(mi, En, fi, bi, Ve[10], 38016083, 9), bi = Ue(bi, mi, En, fi, Ve[15], 3634488961, 14), fi = Ue(fi, bi, mi, En, Ve[4], 3889429448, 20), En = Ue(En, fi, bi, mi, Ve[9], 568446438, 5), mi = Ue(mi, En, fi, bi, Ve[14], 3275163606, 9), bi = Ue(bi, mi, En, fi, Ve[3], 4107603335, 14), fi = Ue(fi, bi, mi, En, Ve[8], 1163531501, 20), En = Ue(En, fi, bi, mi, Ve[13], 2850285829, 5), mi = Ue(mi, En, fi, bi, Ve[2], 4243563512, 9), bi = Ue(bi, mi, En, fi, Ve[7], 1735328473, 14), fi = Ue(fi, bi, mi, En, Ve[12], 2368359562, 20), En = je(En, fi, bi, mi, Ve[5], 4294588738, 4), mi = je(mi, En, fi, bi, Ve[8], 2272392833, 11), bi = je(bi, mi, En, fi, Ve[11], 1839030562, 16), fi = je(fi, bi, mi, En, Ve[14], 4259657740, 23), En = je(En, fi, bi, mi, Ve[1], 2763975236, 4), mi = je(mi, En, fi, bi, Ve[4], 1272893353, 11), bi = je(bi, mi, En, fi, Ve[7], 4139469664, 16), fi = je(fi, bi, mi, En, Ve[10], 3200236656, 23), En = je(En, fi, bi, mi, Ve[13], 681279174, 4), mi = je(mi, En, fi, bi, Ve[0], 3936430074, 11), bi = je(bi, mi, En, fi, Ve[3], 3572445317, 16), fi = je(fi, bi, mi, En, Ve[6], 76029189, 23), En = je(En, fi, bi, mi, Ve[9], 3654602809, 4), mi = je(mi, En, fi, bi, Ve[12], 3873151461, 11), bi = je(bi, mi, En, fi, Ve[15], 530742520, 16), fi = je(fi, bi, mi, En, Ve[2], 3299628645, 23), En = fn(En, fi, bi, mi, Ve[0], 4096336452, 6), mi = fn(mi, En, fi, bi, Ve[7], 1126891415, 10), bi = fn(bi, mi, En, fi, Ve[14], 2878612391, 15), fi = fn(fi, bi, mi, En, Ve[5], 4237533241, 21), En = fn(En, fi, bi, mi, Ve[12], 1700485571, 6), mi = fn(mi, En, fi, bi, Ve[3], 2399980690, 10), bi = fn(bi, mi, En, fi, Ve[10], 4293915773, 15), fi = fn(fi, bi, mi, En, Ve[1], 2240044497, 21), En = fn(En, fi, bi, mi, Ve[8], 1873313359, 6), mi = fn(mi, En, fi, bi, Ve[15], 4264355552, 10), bi = fn(bi, mi, En, fi, Ve[6], 2734768916, 15), fi = fn(fi, bi, mi, En, Ve[13], 1309151649, 21), En = fn(En, fi, bi, mi, Ve[4], 4149444226, 6), mi = fn(mi, En, fi, bi, Ve[11], 3174756917, 10), bi = fn(bi, mi, En, fi, Ve[2], 718787259, 15), fi = fn(fi, bi, mi, En, Ve[9], 3951481745, 21), this._a = this._a + En | 0, this._b = this._b + fi | 0, this._c = this._c + bi | 0, this._d = this._d + mi | 0;
  }, Pe.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var Ve = Ie.allocUnsafe(16);
    return Ve.writeInt32LE(this._a, 0), Ve.writeInt32LE(this._b, 4), Ve.writeInt32LE(this._c, 8), Ve.writeInt32LE(this._d, 12), Ve;
  };
  function Te(Ve, vn) {
    return Ve << vn | Ve >>> 32 - vn;
  }
  function Me(Ve, vn, En, fi, bi, mi, _i) {
    return Te(Ve + (vn & En | ~vn & fi) + bi + mi | 0, _i) + vn | 0;
  }
  function Ue(Ve, vn, En, fi, bi, mi, _i) {
    return Te(Ve + (vn & fi | En & ~fi) + bi + mi | 0, _i) + vn | 0;
  }
  function je(Ve, vn, En, fi, bi, mi, _i) {
    return Te(Ve + (vn ^ En ^ fi) + bi + mi | 0, _i) + vn | 0;
  }
  function fn(Ve, vn, En, fi, bi, mi, _i) {
    return Te(Ve + (En ^ (vn | ~fi)) + bi + mi | 0, _i) + vn | 0;
  }
  return md5_js = Pe, md5_js;
}
var ripemd160, hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160;
  hasRequiredRipemd160 = 1;
  var Ae = require$$0$4.Buffer, t = requireInherits_browser(), Ie = requireHashBase(), Be = new Array(16), Pe = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], Te = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], Me = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], Ue = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], je = [0, 1518500249, 1859775393, 2400959708, 2840853838], fn = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function Ve() {
    Ie.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  t(Ve, Ie), Ve.prototype._update = function() {
    for (var Ei = Be, Si = 0; Si < 16; ++Si) Ei[Si] = this._block.readInt32LE(Si * 4);
    for (var Mi = this._a | 0, Oi = this._b | 0, Fi = this._c | 0, Ui = this._d | 0, Pi = this._e | 0, Bi = this._a | 0, ji = this._b | 0, Zi = this._c | 0, zi = this._d | 0, xi = this._e | 0, $i = 0; $i < 80; $i += 1) {
      var vi, wi;
      $i < 16 ? (vi = En(Mi, Oi, Fi, Ui, Pi, Ei[Pe[$i]], je[0], Me[$i]), wi = _i(Bi, ji, Zi, zi, xi, Ei[Te[$i]], fn[0], Ue[$i])) : $i < 32 ? (vi = fi(Mi, Oi, Fi, Ui, Pi, Ei[Pe[$i]], je[1], Me[$i]), wi = mi(Bi, ji, Zi, zi, xi, Ei[Te[$i]], fn[1], Ue[$i])) : $i < 48 ? (vi = bi(Mi, Oi, Fi, Ui, Pi, Ei[Pe[$i]], je[2], Me[$i]), wi = bi(Bi, ji, Zi, zi, xi, Ei[Te[$i]], fn[2], Ue[$i])) : $i < 64 ? (vi = mi(Mi, Oi, Fi, Ui, Pi, Ei[Pe[$i]], je[3], Me[$i]), wi = fi(Bi, ji, Zi, zi, xi, Ei[Te[$i]], fn[3], Ue[$i])) : (vi = _i(Mi, Oi, Fi, Ui, Pi, Ei[Pe[$i]], je[4], Me[$i]), wi = En(Bi, ji, Zi, zi, xi, Ei[Te[$i]], fn[4], Ue[$i])), Mi = Pi, Pi = Ui, Ui = vn(Fi, 10), Fi = Oi, Oi = vi, Bi = xi, xi = zi, zi = vn(Zi, 10), Zi = ji, ji = wi;
    }
    var Ai = this._b + Fi + zi | 0;
    this._b = this._c + Ui + xi | 0, this._c = this._d + Pi + Bi | 0, this._d = this._e + Mi + ji | 0, this._e = this._a + Oi + Zi | 0, this._a = Ai;
  }, Ve.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var Ei = Ae.alloc ? Ae.alloc(20) : new Ae(20);
    return Ei.writeInt32LE(this._a, 0), Ei.writeInt32LE(this._b, 4), Ei.writeInt32LE(this._c, 8), Ei.writeInt32LE(this._d, 12), Ei.writeInt32LE(this._e, 16), Ei;
  };
  function vn(Ei, Si) {
    return Ei << Si | Ei >>> 32 - Si;
  }
  function En(Ei, Si, Mi, Oi, Fi, Ui, Pi, Bi) {
    return vn(Ei + (Si ^ Mi ^ Oi) + Ui + Pi | 0, Bi) + Fi | 0;
  }
  function fi(Ei, Si, Mi, Oi, Fi, Ui, Pi, Bi) {
    return vn(Ei + (Si & Mi | ~Si & Oi) + Ui + Pi | 0, Bi) + Fi | 0;
  }
  function bi(Ei, Si, Mi, Oi, Fi, Ui, Pi, Bi) {
    return vn(Ei + ((Si | ~Mi) ^ Oi) + Ui + Pi | 0, Bi) + Fi | 0;
  }
  function mi(Ei, Si, Mi, Oi, Fi, Ui, Pi, Bi) {
    return vn(Ei + (Si & Oi | Mi & ~Oi) + Ui + Pi | 0, Bi) + Fi | 0;
  }
  function _i(Ei, Si, Mi, Oi, Fi, Ui, Pi, Bi) {
    return vn(Ei + (Si ^ (Mi | ~Oi)) + Ui + Pi | 0, Bi) + Fi | 0;
  }
  return ripemd160 = Ve, ripemd160;
}
var sha_js = { exports: {} }, hash$4, hasRequiredHash;
function requireHash() {
  if (hasRequiredHash) return hash$4;
  hasRequiredHash = 1;
  var Ae = requireSafeBuffer$1().Buffer;
  function t(Ie, Be) {
    this._block = Ae.alloc(Ie), this._finalSize = Be, this._blockSize = Ie, this._len = 0;
  }
  return t.prototype.update = function(Ie, Be) {
    typeof Ie == "string" && (Be = Be || "utf8", Ie = Ae.from(Ie, Be));
    for (var Pe = this._block, Te = this._blockSize, Me = Ie.length, Ue = this._len, je = 0; je < Me; ) {
      for (var fn = Ue % Te, Ve = Math.min(Me - je, Te - fn), vn = 0; vn < Ve; vn++)
        Pe[fn + vn] = Ie[je + vn];
      Ue += Ve, je += Ve, Ue % Te === 0 && this._update(Pe);
    }
    return this._len += Me, this;
  }, t.prototype.digest = function(Ie) {
    var Be = this._len % this._blockSize;
    this._block[Be] = 128, this._block.fill(0, Be + 1), Be >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var Pe = this._len * 8;
    if (Pe <= 4294967295)
      this._block.writeUInt32BE(Pe, this._blockSize - 4);
    else {
      var Te = (Pe & 4294967295) >>> 0, Me = (Pe - Te) / 4294967296;
      this._block.writeUInt32BE(Me, this._blockSize - 8), this._block.writeUInt32BE(Te, this._blockSize - 4);
    }
    this._update(this._block);
    var Ue = this._hash();
    return Ie ? Ue.toString(Ie) : Ue;
  }, t.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, hash$4 = t, hash$4;
}
var sha, hasRequiredSha;
function requireSha() {
  if (hasRequiredSha) return sha;
  hasRequiredSha = 1;
  var Ae = requireInherits_browser(), t = requireHash(), Ie = requireSafeBuffer$1().Buffer, Be = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], Pe = new Array(80);
  function Te() {
    this.init(), this._w = Pe, t.call(this, 64, 56);
  }
  Ae(Te, t), Te.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function Me(fn) {
    return fn << 5 | fn >>> 27;
  }
  function Ue(fn) {
    return fn << 30 | fn >>> 2;
  }
  function je(fn, Ve, vn, En) {
    return fn === 0 ? Ve & vn | ~Ve & En : fn === 2 ? Ve & vn | Ve & En | vn & En : Ve ^ vn ^ En;
  }
  return Te.prototype._update = function(fn) {
    for (var Ve = this._w, vn = this._a | 0, En = this._b | 0, fi = this._c | 0, bi = this._d | 0, mi = this._e | 0, _i = 0; _i < 16; ++_i) Ve[_i] = fn.readInt32BE(_i * 4);
    for (; _i < 80; ++_i) Ve[_i] = Ve[_i - 3] ^ Ve[_i - 8] ^ Ve[_i - 14] ^ Ve[_i - 16];
    for (var Ei = 0; Ei < 80; ++Ei) {
      var Si = ~~(Ei / 20), Mi = Me(vn) + je(Si, En, fi, bi) + mi + Ve[Ei] + Be[Si] | 0;
      mi = bi, bi = fi, fi = Ue(En), En = vn, vn = Mi;
    }
    this._a = vn + this._a | 0, this._b = En + this._b | 0, this._c = fi + this._c | 0, this._d = bi + this._d | 0, this._e = mi + this._e | 0;
  }, Te.prototype._hash = function() {
    var fn = Ie.allocUnsafe(20);
    return fn.writeInt32BE(this._a | 0, 0), fn.writeInt32BE(this._b | 0, 4), fn.writeInt32BE(this._c | 0, 8), fn.writeInt32BE(this._d | 0, 12), fn.writeInt32BE(this._e | 0, 16), fn;
  }, sha = Te, sha;
}
var sha1, hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1;
  hasRequiredSha1 = 1;
  var Ae = requireInherits_browser(), t = requireHash(), Ie = requireSafeBuffer$1().Buffer, Be = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], Pe = new Array(80);
  function Te() {
    this.init(), this._w = Pe, t.call(this, 64, 56);
  }
  Ae(Te, t), Te.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function Me(Ve) {
    return Ve << 1 | Ve >>> 31;
  }
  function Ue(Ve) {
    return Ve << 5 | Ve >>> 27;
  }
  function je(Ve) {
    return Ve << 30 | Ve >>> 2;
  }
  function fn(Ve, vn, En, fi) {
    return Ve === 0 ? vn & En | ~vn & fi : Ve === 2 ? vn & En | vn & fi | En & fi : vn ^ En ^ fi;
  }
  return Te.prototype._update = function(Ve) {
    for (var vn = this._w, En = this._a | 0, fi = this._b | 0, bi = this._c | 0, mi = this._d | 0, _i = this._e | 0, Ei = 0; Ei < 16; ++Ei) vn[Ei] = Ve.readInt32BE(Ei * 4);
    for (; Ei < 80; ++Ei) vn[Ei] = Me(vn[Ei - 3] ^ vn[Ei - 8] ^ vn[Ei - 14] ^ vn[Ei - 16]);
    for (var Si = 0; Si < 80; ++Si) {
      var Mi = ~~(Si / 20), Oi = Ue(En) + fn(Mi, fi, bi, mi) + _i + vn[Si] + Be[Mi] | 0;
      _i = mi, mi = bi, bi = je(fi), fi = En, En = Oi;
    }
    this._a = En + this._a | 0, this._b = fi + this._b | 0, this._c = bi + this._c | 0, this._d = mi + this._d | 0, this._e = _i + this._e | 0;
  }, Te.prototype._hash = function() {
    var Ve = Ie.allocUnsafe(20);
    return Ve.writeInt32BE(this._a | 0, 0), Ve.writeInt32BE(this._b | 0, 4), Ve.writeInt32BE(this._c | 0, 8), Ve.writeInt32BE(this._d | 0, 12), Ve.writeInt32BE(this._e | 0, 16), Ve;
  }, sha1 = Te, sha1;
}
var sha256$6, hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$6;
  hasRequiredSha256 = 1;
  var Ae = requireInherits_browser(), t = requireHash(), Ie = requireSafeBuffer$1().Buffer, Be = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], Pe = new Array(64);
  function Te() {
    this.init(), this._w = Pe, t.call(this, 64, 56);
  }
  Ae(Te, t), Te.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function Me(En, fi, bi) {
    return bi ^ En & (fi ^ bi);
  }
  function Ue(En, fi, bi) {
    return En & fi | bi & (En | fi);
  }
  function je(En) {
    return (En >>> 2 | En << 30) ^ (En >>> 13 | En << 19) ^ (En >>> 22 | En << 10);
  }
  function fn(En) {
    return (En >>> 6 | En << 26) ^ (En >>> 11 | En << 21) ^ (En >>> 25 | En << 7);
  }
  function Ve(En) {
    return (En >>> 7 | En << 25) ^ (En >>> 18 | En << 14) ^ En >>> 3;
  }
  function vn(En) {
    return (En >>> 17 | En << 15) ^ (En >>> 19 | En << 13) ^ En >>> 10;
  }
  return Te.prototype._update = function(En) {
    for (var fi = this._w, bi = this._a | 0, mi = this._b | 0, _i = this._c | 0, Ei = this._d | 0, Si = this._e | 0, Mi = this._f | 0, Oi = this._g | 0, Fi = this._h | 0, Ui = 0; Ui < 16; ++Ui) fi[Ui] = En.readInt32BE(Ui * 4);
    for (; Ui < 64; ++Ui) fi[Ui] = vn(fi[Ui - 2]) + fi[Ui - 7] + Ve(fi[Ui - 15]) + fi[Ui - 16] | 0;
    for (var Pi = 0; Pi < 64; ++Pi) {
      var Bi = Fi + fn(Si) + Me(Si, Mi, Oi) + Be[Pi] + fi[Pi] | 0, ji = je(bi) + Ue(bi, mi, _i) | 0;
      Fi = Oi, Oi = Mi, Mi = Si, Si = Ei + Bi | 0, Ei = _i, _i = mi, mi = bi, bi = Bi + ji | 0;
    }
    this._a = bi + this._a | 0, this._b = mi + this._b | 0, this._c = _i + this._c | 0, this._d = Ei + this._d | 0, this._e = Si + this._e | 0, this._f = Mi + this._f | 0, this._g = Oi + this._g | 0, this._h = Fi + this._h | 0;
  }, Te.prototype._hash = function() {
    var En = Ie.allocUnsafe(32);
    return En.writeInt32BE(this._a, 0), En.writeInt32BE(this._b, 4), En.writeInt32BE(this._c, 8), En.writeInt32BE(this._d, 12), En.writeInt32BE(this._e, 16), En.writeInt32BE(this._f, 20), En.writeInt32BE(this._g, 24), En.writeInt32BE(this._h, 28), En;
  }, sha256$6 = Te, sha256$6;
}
var sha224$1, hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha224$1;
  hasRequiredSha224 = 1;
  var Ae = requireInherits_browser(), t = requireSha256(), Ie = requireHash(), Be = requireSafeBuffer$1().Buffer, Pe = new Array(64);
  function Te() {
    this.init(), this._w = Pe, Ie.call(this, 64, 56);
  }
  return Ae(Te, t), Te.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, Te.prototype._hash = function() {
    var Me = Be.allocUnsafe(28);
    return Me.writeInt32BE(this._a, 0), Me.writeInt32BE(this._b, 4), Me.writeInt32BE(this._c, 8), Me.writeInt32BE(this._d, 12), Me.writeInt32BE(this._e, 16), Me.writeInt32BE(this._f, 20), Me.writeInt32BE(this._g, 24), Me;
  }, sha224$1 = Te, sha224$1;
}
var sha512$3, hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$3;
  hasRequiredSha512 = 1;
  var Ae = requireInherits_browser(), t = requireHash(), Ie = requireSafeBuffer$1().Buffer, Be = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], Pe = new Array(160);
  function Te() {
    this.init(), this._w = Pe, t.call(this, 128, 112);
  }
  Ae(Te, t), Te.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function Me(mi, _i, Ei) {
    return Ei ^ mi & (_i ^ Ei);
  }
  function Ue(mi, _i, Ei) {
    return mi & _i | Ei & (mi | _i);
  }
  function je(mi, _i) {
    return (mi >>> 28 | _i << 4) ^ (_i >>> 2 | mi << 30) ^ (_i >>> 7 | mi << 25);
  }
  function fn(mi, _i) {
    return (mi >>> 14 | _i << 18) ^ (mi >>> 18 | _i << 14) ^ (_i >>> 9 | mi << 23);
  }
  function Ve(mi, _i) {
    return (mi >>> 1 | _i << 31) ^ (mi >>> 8 | _i << 24) ^ mi >>> 7;
  }
  function vn(mi, _i) {
    return (mi >>> 1 | _i << 31) ^ (mi >>> 8 | _i << 24) ^ (mi >>> 7 | _i << 25);
  }
  function En(mi, _i) {
    return (mi >>> 19 | _i << 13) ^ (_i >>> 29 | mi << 3) ^ mi >>> 6;
  }
  function fi(mi, _i) {
    return (mi >>> 19 | _i << 13) ^ (_i >>> 29 | mi << 3) ^ (mi >>> 6 | _i << 26);
  }
  function bi(mi, _i) {
    return mi >>> 0 < _i >>> 0 ? 1 : 0;
  }
  return Te.prototype._update = function(mi) {
    for (var _i = this._w, Ei = this._ah | 0, Si = this._bh | 0, Mi = this._ch | 0, Oi = this._dh | 0, Fi = this._eh | 0, Ui = this._fh | 0, Pi = this._gh | 0, Bi = this._hh | 0, ji = this._al | 0, Zi = this._bl | 0, zi = this._cl | 0, xi = this._dl | 0, $i = this._el | 0, vi = this._fl | 0, wi = this._gl | 0, Ai = this._hl | 0, Ri = 0; Ri < 32; Ri += 2)
      _i[Ri] = mi.readInt32BE(Ri * 4), _i[Ri + 1] = mi.readInt32BE(Ri * 4 + 4);
    for (; Ri < 160; Ri += 2) {
      var Ti = _i[Ri - 30], Ci = _i[Ri - 15 * 2 + 1], Ii = Ve(Ti, Ci), Li = vn(Ci, Ti);
      Ti = _i[Ri - 2 * 2], Ci = _i[Ri - 2 * 2 + 1];
      var Ni = En(Ti, Ci), Vi = fi(Ci, Ti), is = _i[Ri - 7 * 2], Ki = _i[Ri - 7 * 2 + 1], ts = _i[Ri - 16 * 2], qi = _i[Ri - 16 * 2 + 1], Hi = Li + Ki | 0, Xi = Ii + is + bi(Hi, Li) | 0;
      Hi = Hi + Vi | 0, Xi = Xi + Ni + bi(Hi, Vi) | 0, Hi = Hi + qi | 0, Xi = Xi + ts + bi(Hi, qi) | 0, _i[Ri] = Xi, _i[Ri + 1] = Hi;
    }
    for (var ki = 0; ki < 160; ki += 2) {
      Xi = _i[ki], Hi = _i[ki + 1];
      var Wi = Ue(Ei, Si, Mi), Yi = Ue(ji, Zi, zi), Qi = je(Ei, ji), ns = je(ji, Ei), us = fn(Fi, $i), ps = fn($i, Fi), Ds = Be[ki], Eo = Be[ki + 1], hs = Me(Fi, Ui, Pi), So = Me($i, vi, wi), _o = Ai + ps | 0, vo = Bi + us + bi(_o, Ai) | 0;
      _o = _o + So | 0, vo = vo + hs + bi(_o, So) | 0, _o = _o + Eo | 0, vo = vo + Ds + bi(_o, Eo) | 0, _o = _o + Hi | 0, vo = vo + Xi + bi(_o, Hi) | 0;
      var Ro = ns + Yi | 0, $o = Qi + Wi + bi(Ro, ns) | 0;
      Bi = Pi, Ai = wi, Pi = Ui, wi = vi, Ui = Fi, vi = $i, $i = xi + _o | 0, Fi = Oi + vo + bi($i, xi) | 0, Oi = Mi, xi = zi, Mi = Si, zi = Zi, Si = Ei, Zi = ji, ji = _o + Ro | 0, Ei = vo + $o + bi(ji, _o) | 0;
    }
    this._al = this._al + ji | 0, this._bl = this._bl + Zi | 0, this._cl = this._cl + zi | 0, this._dl = this._dl + xi | 0, this._el = this._el + $i | 0, this._fl = this._fl + vi | 0, this._gl = this._gl + wi | 0, this._hl = this._hl + Ai | 0, this._ah = this._ah + Ei + bi(this._al, ji) | 0, this._bh = this._bh + Si + bi(this._bl, Zi) | 0, this._ch = this._ch + Mi + bi(this._cl, zi) | 0, this._dh = this._dh + Oi + bi(this._dl, xi) | 0, this._eh = this._eh + Fi + bi(this._el, $i) | 0, this._fh = this._fh + Ui + bi(this._fl, vi) | 0, this._gh = this._gh + Pi + bi(this._gl, wi) | 0, this._hh = this._hh + Bi + bi(this._hl, Ai) | 0;
  }, Te.prototype._hash = function() {
    var mi = Ie.allocUnsafe(64);
    function _i(Ei, Si, Mi) {
      mi.writeInt32BE(Ei, Mi), mi.writeInt32BE(Si, Mi + 4);
    }
    return _i(this._ah, this._al, 0), _i(this._bh, this._bl, 8), _i(this._ch, this._cl, 16), _i(this._dh, this._dl, 24), _i(this._eh, this._el, 32), _i(this._fh, this._fl, 40), _i(this._gh, this._gl, 48), _i(this._hh, this._hl, 56), mi;
  }, sha512$3 = Te, sha512$3;
}
var sha384$1, hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha384$1;
  hasRequiredSha384 = 1;
  var Ae = requireInherits_browser(), t = requireSha512(), Ie = requireHash(), Be = requireSafeBuffer$1().Buffer, Pe = new Array(160);
  function Te() {
    this.init(), this._w = Pe, Ie.call(this, 128, 112);
  }
  return Ae(Te, t), Te.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, Te.prototype._hash = function() {
    var Me = Be.allocUnsafe(48);
    function Ue(je, fn, Ve) {
      Me.writeInt32BE(je, Ve), Me.writeInt32BE(fn, Ve + 4);
    }
    return Ue(this._ah, this._al, 0), Ue(this._bh, this._bl, 8), Ue(this._ch, this._cl, 16), Ue(this._dh, this._dl, 24), Ue(this._eh, this._el, 32), Ue(this._fh, this._fl, 40), Me;
  }, sha384$1 = Te, sha384$1;
}
var hasRequiredSha_js;
function requireSha_js() {
  if (hasRequiredSha_js) return sha_js.exports;
  hasRequiredSha_js = 1;
  var Ae = sha_js.exports = function(Ie) {
    Ie = Ie.toLowerCase();
    var Be = Ae[Ie];
    if (!Be) throw new Error(Ie + " is not supported (we accept pull requests)");
    return new Be();
  };
  return Ae.sha = requireSha(), Ae.sha1 = requireSha1(), Ae.sha224 = requireSha224(), Ae.sha256 = requireSha256(), Ae.sha384 = requireSha384(), Ae.sha512 = requireSha512(), sha_js.exports;
}
var cipherBase, hasRequiredCipherBase;
function requireCipherBase() {
  if (hasRequiredCipherBase) return cipherBase;
  hasRequiredCipherBase = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requireStreamBrowserify().Transform, Ie = string_decoder.StringDecoder, Be = requireInherits_browser();
  function Pe(Te) {
    t.call(this), this.hashMode = typeof Te == "string", this.hashMode ? this[Te] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  return Be(Pe, t), Pe.prototype.update = function(Te, Me, Ue) {
    typeof Te == "string" && (Te = Ae.from(Te, Me));
    var je = this._update(Te);
    return this.hashMode ? this : (Ue && (je = this._toString(je, Ue)), je);
  }, Pe.prototype.setAutoPadding = function() {
  }, Pe.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, Pe.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, Pe.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, Pe.prototype._transform = function(Te, Me, Ue) {
    var je;
    try {
      this.hashMode ? this._update(Te) : this.push(this._update(Te));
    } catch (fn) {
      je = fn;
    } finally {
      Ue(je);
    }
  }, Pe.prototype._flush = function(Te) {
    var Me;
    try {
      this.push(this.__final());
    } catch (Ue) {
      Me = Ue;
    }
    Te(Me);
  }, Pe.prototype._finalOrDigest = function(Te) {
    var Me = this.__final() || Ae.alloc(0);
    return Te && (Me = this._toString(Me, Te, !0)), Me;
  }, Pe.prototype._toString = function(Te, Me, Ue) {
    if (this._decoder || (this._decoder = new Ie(Me), this._encoding = Me), this._encoding !== Me) throw new Error("can't switch encodings");
    var je = this._decoder.write(Te);
    return Ue && (je += this._decoder.end()), je;
  }, cipherBase = Pe, cipherBase;
}
var browser$e, hasRequiredBrowser$a;
function requireBrowser$a() {
  if (hasRequiredBrowser$a) return browser$e;
  hasRequiredBrowser$a = 1;
  var Ae = requireInherits_browser(), t = requireMd5_js(), Ie = requireRipemd160(), Be = requireSha_js(), Pe = requireCipherBase();
  function Te(Me) {
    Pe.call(this, "digest"), this._hash = Me;
  }
  return Ae(Te, Pe), Te.prototype._update = function(Me) {
    this._hash.update(Me);
  }, Te.prototype._final = function() {
    return this._hash.digest();
  }, browser$e = function(Ue) {
    return Ue = Ue.toLowerCase(), Ue === "md5" ? new t() : Ue === "rmd160" || Ue === "ripemd160" ? new Ie() : new Te(Be(Ue));
  }, browser$e;
}
var legacy$1, hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy$1;
  hasRequiredLegacy = 1;
  var Ae = requireInherits_browser(), t = requireSafeBuffer$1().Buffer, Ie = requireCipherBase(), Be = t.alloc(128), Pe = 64;
  function Te(Me, Ue) {
    Ie.call(this, "digest"), typeof Ue == "string" && (Ue = t.from(Ue)), this._alg = Me, this._key = Ue, Ue.length > Pe ? Ue = Me(Ue) : Ue.length < Pe && (Ue = t.concat([Ue, Be], Pe));
    for (var je = this._ipad = t.allocUnsafe(Pe), fn = this._opad = t.allocUnsafe(Pe), Ve = 0; Ve < Pe; Ve++)
      je[Ve] = Ue[Ve] ^ 54, fn[Ve] = Ue[Ve] ^ 92;
    this._hash = [je];
  }
  return Ae(Te, Ie), Te.prototype._update = function(Me) {
    this._hash.push(Me);
  }, Te.prototype._final = function() {
    var Me = this._alg(t.concat(this._hash));
    return this._alg(t.concat([this._opad, Me]));
  }, legacy$1 = Te, legacy$1;
}
var md5, hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  var Ae = requireMd5_js();
  return md5 = function(t) {
    return new Ae().update(t).digest();
  }, md5;
}
var browser$d, hasRequiredBrowser$9;
function requireBrowser$9() {
  if (hasRequiredBrowser$9) return browser$d;
  hasRequiredBrowser$9 = 1;
  var Ae = requireInherits_browser(), t = requireLegacy(), Ie = requireCipherBase(), Be = requireSafeBuffer$1().Buffer, Pe = requireMd5(), Te = requireRipemd160(), Me = requireSha_js(), Ue = Be.alloc(128);
  function je(fn, Ve) {
    Ie.call(this, "digest"), typeof Ve == "string" && (Ve = Be.from(Ve));
    var vn = fn === "sha512" || fn === "sha384" ? 128 : 64;
    if (this._alg = fn, this._key = Ve, Ve.length > vn) {
      var En = fn === "rmd160" ? new Te() : Me(fn);
      Ve = En.update(Ve).digest();
    } else Ve.length < vn && (Ve = Be.concat([Ve, Ue], vn));
    for (var fi = this._ipad = Be.allocUnsafe(vn), bi = this._opad = Be.allocUnsafe(vn), mi = 0; mi < vn; mi++)
      fi[mi] = Ve[mi] ^ 54, bi[mi] = Ve[mi] ^ 92;
    this._hash = fn === "rmd160" ? new Te() : Me(fn), this._hash.update(fi);
  }
  return Ae(je, Ie), je.prototype._update = function(fn) {
    this._hash.update(fn);
  }, je.prototype._final = function() {
    var fn = this._hash.digest(), Ve = this._alg === "rmd160" ? new Te() : Me(this._alg);
    return Ve.update(this._opad).update(fn).digest();
  }, browser$d = function(Ve, vn) {
    return Ve = Ve.toLowerCase(), Ve === "rmd160" || Ve === "ripemd160" ? new je("rmd160", vn) : Ve === "md5" ? new t(Pe, vn) : new je(Ve, vn);
  }, browser$d;
}
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$5 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512$2 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$5,
  sha224,
  sha384,
  sha512: sha512$2,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
  return hasRequiredAlgos || (hasRequiredAlgos = 1, algos = require$$6), algos;
}
var browser$c = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
  if (hasRequiredPrecondition) return precondition;
  hasRequiredPrecondition = 1;
  var Ae = Math.pow(2, 30) - 1;
  return precondition = function(t, Ie) {
    if (typeof t != "number")
      throw new TypeError("Iterations not a number");
    if (t < 0)
      throw new TypeError("Bad iterations");
    if (typeof Ie != "number")
      throw new TypeError("Key length not a number");
    if (Ie < 0 || Ie > Ae || Ie !== Ie)
      throw new TypeError("Bad key length");
  }, precondition;
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
  if (hasRequiredDefaultEncoding) return defaultEncoding_1;
  hasRequiredDefaultEncoding = 1;
  var Ae;
  if (commonjsGlobal.process && commonjsGlobal.process.browser)
    Ae = "utf-8";
  else if (commonjsGlobal.process && commonjsGlobal.process.version) {
    var t = parseInt(process$1$1.version.split(".")[0].slice(1), 10);
    Ae = t >= 6 ? "utf-8" : "binary";
  } else
    Ae = "utf-8";
  return defaultEncoding_1 = Ae, defaultEncoding_1;
}
var toBuffer$1, hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer) return toBuffer$1;
  hasRequiredToBuffer = 1;
  var Ae = requireSafeBuffer$1().Buffer;
  return toBuffer$1 = function(t, Ie, Be) {
    if (Ae.isBuffer(t))
      return t;
    if (typeof t == "string")
      return Ae.from(t, Ie);
    if (ArrayBuffer.isView(t))
      return Ae.from(t.buffer);
    throw new TypeError(Be + " must be a string, a Buffer, a typed array or a DataView");
  }, toBuffer$1;
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser) return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var Ae = requireMd5(), t = requireRipemd160(), Ie = requireSha_js(), Be = requireSafeBuffer$1().Buffer, Pe = requirePrecondition(), Te = requireDefaultEncoding(), Me = requireToBuffer(), Ue = Be.alloc(128), je = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function fn(En, fi, bi) {
    var mi = Ve(En), _i = En === "sha512" || En === "sha384" ? 128 : 64;
    fi.length > _i ? fi = mi(fi) : fi.length < _i && (fi = Be.concat([fi, Ue], _i));
    for (var Ei = Be.allocUnsafe(_i + je[En]), Si = Be.allocUnsafe(_i + je[En]), Mi = 0; Mi < _i; Mi++)
      Ei[Mi] = fi[Mi] ^ 54, Si[Mi] = fi[Mi] ^ 92;
    var Oi = Be.allocUnsafe(_i + bi + 4);
    Ei.copy(Oi, 0, 0, _i), this.ipad1 = Oi, this.ipad2 = Ei, this.opad = Si, this.alg = En, this.blocksize = _i, this.hash = mi, this.size = je[En];
  }
  fn.prototype.run = function(En, fi) {
    En.copy(fi, this.blocksize);
    var bi = this.hash(fi);
    return bi.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function Ve(En) {
    function fi(mi) {
      return Ie(En).update(mi).digest();
    }
    function bi(mi) {
      return new t().update(mi).digest();
    }
    return En === "rmd160" || En === "ripemd160" ? bi : En === "md5" ? Ae : fi;
  }
  function vn(En, fi, bi, mi, _i) {
    Pe(bi, mi), En = Me(En, Te, "Password"), fi = Me(fi, Te, "Salt"), _i = _i || "sha1";
    var Ei = new fn(_i, En, fi.length), Si = Be.allocUnsafe(mi), Mi = Be.allocUnsafe(fi.length + 4);
    fi.copy(Mi, 0, 0, fi.length);
    for (var Oi = 0, Fi = je[_i], Ui = Math.ceil(mi / Fi), Pi = 1; Pi <= Ui; Pi++) {
      Mi.writeUInt32BE(Pi, fi.length);
      for (var Bi = Ei.run(Mi, Ei.ipad1), ji = Bi, Zi = 1; Zi < bi; Zi++) {
        ji = Ei.run(ji, Ei.ipad2);
        for (var zi = 0; zi < Fi; zi++) Bi[zi] ^= ji[zi];
      }
      Bi.copy(Si, Oi), Oi += Fi;
    }
    return Si;
  }
  return syncBrowser = vn, syncBrowser;
}
var async, hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requirePrecondition(), Ie = requireDefaultEncoding(), Be = requireSyncBrowser(), Pe = requireToBuffer(), Te, Me = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, Ue = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, je = [];
  function fn(bi) {
    if (commonjsGlobal.process && !commonjsGlobal.process.browser || !Me || !Me.importKey || !Me.deriveBits)
      return Promise.resolve(!1);
    if (je[bi] !== void 0)
      return je[bi];
    Te = Te || Ae.alloc(8);
    var mi = En(Te, Te, 10, 128, bi).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return je[bi] = mi, mi;
  }
  var Ve;
  function vn() {
    return Ve || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? Ve = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? Ve = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? Ve = commonjsGlobal.setImmediate : Ve = commonjsGlobal.setTimeout, Ve);
  }
  function En(bi, mi, _i, Ei, Si) {
    return Me.importKey(
      "raw",
      bi,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(Mi) {
      return Me.deriveBits({
        name: "PBKDF2",
        salt: mi,
        iterations: _i,
        hash: {
          name: Si
        }
      }, Mi, Ei << 3);
    }).then(function(Mi) {
      return Ae.from(Mi);
    });
  }
  function fi(bi, mi) {
    bi.then(function(_i) {
      vn()(function() {
        mi(null, _i);
      });
    }, function(_i) {
      vn()(function() {
        mi(_i);
      });
    });
  }
  return async = function(bi, mi, _i, Ei, Si, Mi) {
    typeof Si == "function" && (Mi = Si, Si = void 0), Si = Si || "sha1";
    var Oi = Ue[Si.toLowerCase()];
    if (!Oi || typeof commonjsGlobal.Promise != "function") {
      vn()(function() {
        var Fi;
        try {
          Fi = Be(bi, mi, _i, Ei, Si);
        } catch (Ui) {
          return Mi(Ui);
        }
        Mi(null, Fi);
      });
      return;
    }
    if (t(_i, Ei), bi = Pe(bi, Ie, "Password"), mi = Pe(mi, Ie, "Salt"), typeof Mi != "function") throw new Error("No callback provided to pbkdf2");
    fi(fn(Oi).then(function(Fi) {
      return Fi ? En(bi, mi, _i, Ei, Oi) : Be(bi, mi, _i, Ei, Si);
    }), Mi);
  }, async;
}
var hasRequiredBrowser$8;
function requireBrowser$8() {
  return hasRequiredBrowser$8 || (hasRequiredBrowser$8 = 1, browser$c.pbkdf2 = requireAsync(), browser$c.pbkdf2Sync = requireSyncBrowser()), browser$c;
}
var browser$b = {}, des$1 = {}, utils$2 = {}, hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$2;
  hasRequiredUtils$1 = 1, utils$2.readUInt32BE = function(Pe, Te) {
    var Me = Pe[0 + Te] << 24 | Pe[1 + Te] << 16 | Pe[2 + Te] << 8 | Pe[3 + Te];
    return Me >>> 0;
  }, utils$2.writeUInt32BE = function(Pe, Te, Me) {
    Pe[0 + Me] = Te >>> 24, Pe[1 + Me] = Te >>> 16 & 255, Pe[2 + Me] = Te >>> 8 & 255, Pe[3 + Me] = Te & 255;
  }, utils$2.ip = function(Pe, Te, Me, Ue) {
    for (var je = 0, fn = 0, Ve = 6; Ve >= 0; Ve -= 2) {
      for (var vn = 0; vn <= 24; vn += 8)
        je <<= 1, je |= Te >>> vn + Ve & 1;
      for (var vn = 0; vn <= 24; vn += 8)
        je <<= 1, je |= Pe >>> vn + Ve & 1;
    }
    for (var Ve = 6; Ve >= 0; Ve -= 2) {
      for (var vn = 1; vn <= 25; vn += 8)
        fn <<= 1, fn |= Te >>> vn + Ve & 1;
      for (var vn = 1; vn <= 25; vn += 8)
        fn <<= 1, fn |= Pe >>> vn + Ve & 1;
    }
    Me[Ue + 0] = je >>> 0, Me[Ue + 1] = fn >>> 0;
  }, utils$2.rip = function(Pe, Te, Me, Ue) {
    for (var je = 0, fn = 0, Ve = 0; Ve < 4; Ve++)
      for (var vn = 24; vn >= 0; vn -= 8)
        je <<= 1, je |= Te >>> vn + Ve & 1, je <<= 1, je |= Pe >>> vn + Ve & 1;
    for (var Ve = 4; Ve < 8; Ve++)
      for (var vn = 24; vn >= 0; vn -= 8)
        fn <<= 1, fn |= Te >>> vn + Ve & 1, fn <<= 1, fn |= Pe >>> vn + Ve & 1;
    Me[Ue + 0] = je >>> 0, Me[Ue + 1] = fn >>> 0;
  }, utils$2.pc1 = function(Pe, Te, Me, Ue) {
    for (var je = 0, fn = 0, Ve = 7; Ve >= 5; Ve--) {
      for (var vn = 0; vn <= 24; vn += 8)
        je <<= 1, je |= Te >> vn + Ve & 1;
      for (var vn = 0; vn <= 24; vn += 8)
        je <<= 1, je |= Pe >> vn + Ve & 1;
    }
    for (var vn = 0; vn <= 24; vn += 8)
      je <<= 1, je |= Te >> vn + Ve & 1;
    for (var Ve = 1; Ve <= 3; Ve++) {
      for (var vn = 0; vn <= 24; vn += 8)
        fn <<= 1, fn |= Te >> vn + Ve & 1;
      for (var vn = 0; vn <= 24; vn += 8)
        fn <<= 1, fn |= Pe >> vn + Ve & 1;
    }
    for (var vn = 0; vn <= 24; vn += 8)
      fn <<= 1, fn |= Pe >> vn + Ve & 1;
    Me[Ue + 0] = je >>> 0, Me[Ue + 1] = fn >>> 0;
  }, utils$2.r28shl = function(Pe, Te) {
    return Pe << Te & 268435455 | Pe >>> 28 - Te;
  };
  var Ae = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$2.pc2 = function(Pe, Te, Me, Ue) {
    for (var je = 0, fn = 0, Ve = Ae.length >>> 1, vn = 0; vn < Ve; vn++)
      je <<= 1, je |= Pe >>> Ae[vn] & 1;
    for (var vn = Ve; vn < Ae.length; vn++)
      fn <<= 1, fn |= Te >>> Ae[vn] & 1;
    Me[Ue + 0] = je >>> 0, Me[Ue + 1] = fn >>> 0;
  }, utils$2.expand = function(Pe, Te, Me) {
    var Ue = 0, je = 0;
    Ue = (Pe & 1) << 5 | Pe >>> 27;
    for (var fn = 23; fn >= 15; fn -= 4)
      Ue <<= 6, Ue |= Pe >>> fn & 63;
    for (var fn = 11; fn >= 3; fn -= 4)
      je |= Pe >>> fn & 63, je <<= 6;
    je |= (Pe & 31) << 1 | Pe >>> 31, Te[Me + 0] = Ue >>> 0, Te[Me + 1] = je >>> 0;
  };
  var t = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$2.substitute = function(Pe, Te) {
    for (var Me = 0, Ue = 0; Ue < 4; Ue++) {
      var je = Pe >>> 18 - Ue * 6 & 63, fn = t[Ue * 64 + je];
      Me <<= 4, Me |= fn;
    }
    for (var Ue = 0; Ue < 4; Ue++) {
      var je = Te >>> 18 - Ue * 6 & 63, fn = t[4 * 64 + Ue * 64 + je];
      Me <<= 4, Me |= fn;
    }
    return Me >>> 0;
  };
  var Ie = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return utils$2.permute = function(Pe) {
    for (var Te = 0, Me = 0; Me < Ie.length; Me++)
      Te <<= 1, Te |= Pe >>> Ie[Me] & 1;
    return Te >>> 0;
  }, utils$2.padSplit = function(Pe, Te, Me) {
    for (var Ue = Pe.toString(2); Ue.length < Te; )
      Ue = "0" + Ue;
    for (var je = [], fn = 0; fn < Te; fn += Me)
      je.push(Ue.slice(fn, fn + Me));
    return je.join(" ");
  }, utils$2;
}
var cipher, hasRequiredCipher;
function requireCipher() {
  if (hasRequiredCipher) return cipher;
  hasRequiredCipher = 1;
  var Ae = minimalisticAssert$1;
  function t(Ie) {
    this.options = Ie, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = Ie.padding !== !1;
  }
  return cipher = t, t.prototype._init = function() {
  }, t.prototype.update = function(Be) {
    return Be.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(Be) : this._updateEncrypt(Be);
  }, t.prototype._buffer = function(Be, Pe) {
    for (var Te = Math.min(this.buffer.length - this.bufferOff, Be.length - Pe), Me = 0; Me < Te; Me++)
      this.buffer[this.bufferOff + Me] = Be[Pe + Me];
    return this.bufferOff += Te, Te;
  }, t.prototype._flushBuffer = function(Be, Pe) {
    return this._update(this.buffer, 0, Be, Pe), this.bufferOff = 0, this.blockSize;
  }, t.prototype._updateEncrypt = function(Be) {
    var Pe = 0, Te = 0, Me = (this.bufferOff + Be.length) / this.blockSize | 0, Ue = new Array(Me * this.blockSize);
    this.bufferOff !== 0 && (Pe += this._buffer(Be, Pe), this.bufferOff === this.buffer.length && (Te += this._flushBuffer(Ue, Te)));
    for (var je = Be.length - (Be.length - Pe) % this.blockSize; Pe < je; Pe += this.blockSize)
      this._update(Be, Pe, Ue, Te), Te += this.blockSize;
    for (; Pe < Be.length; Pe++, this.bufferOff++)
      this.buffer[this.bufferOff] = Be[Pe];
    return Ue;
  }, t.prototype._updateDecrypt = function(Be) {
    for (var Pe = 0, Te = 0, Me = Math.ceil((this.bufferOff + Be.length) / this.blockSize) - 1, Ue = new Array(Me * this.blockSize); Me > 0; Me--)
      Pe += this._buffer(Be, Pe), Te += this._flushBuffer(Ue, Te);
    return Pe += this._buffer(Be, Pe), Ue;
  }, t.prototype.final = function(Be) {
    var Pe;
    Be && (Pe = this.update(Be));
    var Te;
    return this.type === "encrypt" ? Te = this._finalEncrypt() : Te = this._finalDecrypt(), Pe ? Pe.concat(Te) : Te;
  }, t.prototype._pad = function(Be, Pe) {
    if (Pe === 0)
      return !1;
    for (; Pe < Be.length; )
      Be[Pe++] = 0;
    return !0;
  }, t.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var Be = new Array(this.blockSize);
    return this._update(this.buffer, 0, Be, 0), Be;
  }, t.prototype._unpad = function(Be) {
    return Be;
  }, t.prototype._finalDecrypt = function() {
    Ae.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var Be = new Array(this.blockSize);
    return this._flushBuffer(Be, 0), this._unpad(Be);
  }, cipher;
}
var des, hasRequiredDes$1;
function requireDes$1() {
  if (hasRequiredDes$1) return des;
  hasRequiredDes$1 = 1;
  var Ae = minimalisticAssert$1, t = requireInherits_browser(), Ie = requireUtils$1(), Be = requireCipher();
  function Pe() {
    this.tmp = new Array(2), this.keys = null;
  }
  function Te(Ue) {
    Be.call(this, Ue);
    var je = new Pe();
    this._desState = je, this.deriveKeys(je, Ue.key);
  }
  t(Te, Be), des = Te, Te.create = function(je) {
    return new Te(je);
  };
  var Me = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return Te.prototype.deriveKeys = function(je, fn) {
    je.keys = new Array(16 * 2), Ae.equal(fn.length, this.blockSize, "Invalid key length");
    var Ve = Ie.readUInt32BE(fn, 0), vn = Ie.readUInt32BE(fn, 4);
    Ie.pc1(Ve, vn, je.tmp, 0), Ve = je.tmp[0], vn = je.tmp[1];
    for (var En = 0; En < je.keys.length; En += 2) {
      var fi = Me[En >>> 1];
      Ve = Ie.r28shl(Ve, fi), vn = Ie.r28shl(vn, fi), Ie.pc2(Ve, vn, je.keys, En);
    }
  }, Te.prototype._update = function(je, fn, Ve, vn) {
    var En = this._desState, fi = Ie.readUInt32BE(je, fn), bi = Ie.readUInt32BE(je, fn + 4);
    Ie.ip(fi, bi, En.tmp, 0), fi = En.tmp[0], bi = En.tmp[1], this.type === "encrypt" ? this._encrypt(En, fi, bi, En.tmp, 0) : this._decrypt(En, fi, bi, En.tmp, 0), fi = En.tmp[0], bi = En.tmp[1], Ie.writeUInt32BE(Ve, fi, vn), Ie.writeUInt32BE(Ve, bi, vn + 4);
  }, Te.prototype._pad = function(je, fn) {
    if (this.padding === !1)
      return !1;
    for (var Ve = je.length - fn, vn = fn; vn < je.length; vn++)
      je[vn] = Ve;
    return !0;
  }, Te.prototype._unpad = function(je) {
    if (this.padding === !1)
      return je;
    for (var fn = je[je.length - 1], Ve = je.length - fn; Ve < je.length; Ve++)
      Ae.equal(je[Ve], fn);
    return je.slice(0, je.length - fn);
  }, Te.prototype._encrypt = function(je, fn, Ve, vn, En) {
    for (var fi = fn, bi = Ve, mi = 0; mi < je.keys.length; mi += 2) {
      var _i = je.keys[mi], Ei = je.keys[mi + 1];
      Ie.expand(bi, je.tmp, 0), _i ^= je.tmp[0], Ei ^= je.tmp[1];
      var Si = Ie.substitute(_i, Ei), Mi = Ie.permute(Si), Oi = bi;
      bi = (fi ^ Mi) >>> 0, fi = Oi;
    }
    Ie.rip(bi, fi, vn, En);
  }, Te.prototype._decrypt = function(je, fn, Ve, vn, En) {
    for (var fi = Ve, bi = fn, mi = je.keys.length - 2; mi >= 0; mi -= 2) {
      var _i = je.keys[mi], Ei = je.keys[mi + 1];
      Ie.expand(fi, je.tmp, 0), _i ^= je.tmp[0], Ei ^= je.tmp[1];
      var Si = Ie.substitute(_i, Ei), Mi = Ie.permute(Si), Oi = fi;
      fi = (bi ^ Mi) >>> 0, bi = Oi;
    }
    Ie.rip(fi, bi, vn, En);
  }, des;
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
  if (hasRequiredCbc$1) return cbc$1;
  hasRequiredCbc$1 = 1;
  var Ae = minimalisticAssert$1, t = requireInherits_browser(), Ie = {};
  function Be(Te) {
    Ae.equal(Te.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var Me = 0; Me < this.iv.length; Me++)
      this.iv[Me] = Te[Me];
  }
  function Pe(Te) {
    function Me(Ve) {
      Te.call(this, Ve), this._cbcInit();
    }
    t(Me, Te);
    for (var Ue = Object.keys(Ie), je = 0; je < Ue.length; je++) {
      var fn = Ue[je];
      Me.prototype[fn] = Ie[fn];
    }
    return Me.create = function(vn) {
      return new Me(vn);
    }, Me;
  }
  return cbc$1.instantiate = Pe, Ie._cbcInit = function() {
    var Me = new Be(this.options.iv);
    this._cbcState = Me;
  }, Ie._update = function(Me, Ue, je, fn) {
    var Ve = this._cbcState, vn = this.constructor.super_.prototype, En = Ve.iv;
    if (this.type === "encrypt") {
      for (var fi = 0; fi < this.blockSize; fi++)
        En[fi] ^= Me[Ue + fi];
      vn._update.call(this, En, 0, je, fn);
      for (var fi = 0; fi < this.blockSize; fi++)
        En[fi] = je[fn + fi];
    } else {
      vn._update.call(this, Me, Ue, je, fn);
      for (var fi = 0; fi < this.blockSize; fi++)
        je[fn + fi] ^= En[fi];
      for (var fi = 0; fi < this.blockSize; fi++)
        En[fi] = Me[Ue + fi];
    }
  }, cbc$1;
}
var ede, hasRequiredEde;
function requireEde() {
  if (hasRequiredEde) return ede;
  hasRequiredEde = 1;
  var Ae = minimalisticAssert$1, t = requireInherits_browser(), Ie = requireCipher(), Be = requireDes$1();
  function Pe(Me, Ue) {
    Ae.equal(Ue.length, 24, "Invalid key length");
    var je = Ue.slice(0, 8), fn = Ue.slice(8, 16), Ve = Ue.slice(16, 24);
    Me === "encrypt" ? this.ciphers = [
      Be.create({ type: "encrypt", key: je }),
      Be.create({ type: "decrypt", key: fn }),
      Be.create({ type: "encrypt", key: Ve })
    ] : this.ciphers = [
      Be.create({ type: "decrypt", key: Ve }),
      Be.create({ type: "encrypt", key: fn }),
      Be.create({ type: "decrypt", key: je })
    ];
  }
  function Te(Me) {
    Ie.call(this, Me);
    var Ue = new Pe(this.type, this.options.key);
    this._edeState = Ue;
  }
  return t(Te, Ie), ede = Te, Te.create = function(Ue) {
    return new Te(Ue);
  }, Te.prototype._update = function(Ue, je, fn, Ve) {
    var vn = this._edeState;
    vn.ciphers[0]._update(Ue, je, fn, Ve), vn.ciphers[1]._update(fn, Ve, fn, Ve), vn.ciphers[2]._update(fn, Ve, fn, Ve);
  }, Te.prototype._pad = Be.prototype._pad, Te.prototype._unpad = Be.prototype._unpad, ede;
}
var hasRequiredDes;
function requireDes() {
  return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils$1(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1;
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes) return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var Ae = requireCipherBase(), t = requireDes(), Ie = requireInherits_browser(), Be = requireSafeBuffer$1().Buffer, Pe = {
    "des-ede3-cbc": t.CBC.instantiate(t.EDE),
    "des-ede3": t.EDE,
    "des-ede-cbc": t.CBC.instantiate(t.EDE),
    "des-ede": t.EDE,
    "des-cbc": t.CBC.instantiate(t.DES),
    "des-ecb": t.DES
  };
  Pe.des = Pe["des-cbc"], Pe.des3 = Pe["des-ede3-cbc"], browserifyDes = Te, Ie(Te, Ae);
  function Te(Me) {
    Ae.call(this);
    var Ue = Me.mode.toLowerCase(), je = Pe[Ue], fn;
    Me.decrypt ? fn = "decrypt" : fn = "encrypt";
    var Ve = Me.key;
    Be.isBuffer(Ve) || (Ve = Be.from(Ve)), (Ue === "des-ede" || Ue === "des-ede-cbc") && (Ve = Be.concat([Ve, Ve.slice(0, 8)]));
    var vn = Me.iv;
    Be.isBuffer(vn) || (vn = Be.from(vn)), this._des = je.create({
      key: Ve,
      iv: vn,
      type: fn
    });
  }
  return Te.prototype._update = function(Me) {
    return Be.from(this._des.update(Me));
  }, Te.prototype._final = function() {
    return Be.from(this._des.final());
  }, browserifyDes;
}
var browser$a = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
  return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function(Ae, t) {
    return Ae._cipher.encryptBlock(t);
  }, ecb.decrypt = function(Ae, t) {
    return Ae._cipher.decryptBlock(t);
  }), ecb;
}
var cbc = {}, bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
  return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function(t, Ie) {
    for (var Be = Math.min(t.length, Ie.length), Pe = new Buffer$3(Be), Te = 0; Te < Be; ++Te)
      Pe[Te] = t[Te] ^ Ie[Te];
    return Pe;
  }), bufferXor;
}
var hasRequiredCbc;
function requireCbc() {
  if (hasRequiredCbc) return cbc;
  hasRequiredCbc = 1;
  var Ae = requireBufferXor();
  return cbc.encrypt = function(t, Ie) {
    var Be = Ae(Ie, t._prev);
    return t._prev = t._cipher.encryptBlock(Be), t._prev;
  }, cbc.decrypt = function(t, Ie) {
    var Be = t._prev;
    t._prev = Ie;
    var Pe = t._cipher.decryptBlock(Ie);
    return Ae(Pe, Be);
  }, cbc;
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb) return cfb;
  hasRequiredCfb = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requireBufferXor();
  function Ie(Be, Pe, Te) {
    var Me = Pe.length, Ue = t(Pe, Be._cache);
    return Be._cache = Be._cache.slice(Me), Be._prev = Ae.concat([Be._prev, Te ? Pe : Ue]), Ue;
  }
  return cfb.encrypt = function(Be, Pe, Te) {
    for (var Me = Ae.allocUnsafe(0), Ue; Pe.length; )
      if (Be._cache.length === 0 && (Be._cache = Be._cipher.encryptBlock(Be._prev), Be._prev = Ae.allocUnsafe(0)), Be._cache.length <= Pe.length)
        Ue = Be._cache.length, Me = Ae.concat([Me, Ie(Be, Pe.slice(0, Ue), Te)]), Pe = Pe.slice(Ue);
      else {
        Me = Ae.concat([Me, Ie(Be, Pe, Te)]);
        break;
      }
    return Me;
  }, cfb;
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8) return cfb8;
  hasRequiredCfb8 = 1;
  var Ae = requireSafeBuffer$1().Buffer;
  function t(Ie, Be, Pe) {
    var Te = Ie._cipher.encryptBlock(Ie._prev), Me = Te[0] ^ Be;
    return Ie._prev = Ae.concat([
      Ie._prev.slice(1),
      Ae.from([Pe ? Be : Me])
    ]), Me;
  }
  return cfb8.encrypt = function(Ie, Be, Pe) {
    for (var Te = Be.length, Me = Ae.allocUnsafe(Te), Ue = -1; ++Ue < Te; )
      Me[Ue] = t(Ie, Be[Ue], Pe);
    return Me;
  }, cfb8;
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1) return cfb1;
  hasRequiredCfb1 = 1;
  var Ae = requireSafeBuffer$1().Buffer;
  function t(Be, Pe, Te) {
    for (var Me, Ue = -1, je = 8, fn = 0, Ve, vn; ++Ue < je; )
      Me = Be._cipher.encryptBlock(Be._prev), Ve = Pe & 1 << 7 - Ue ? 128 : 0, vn = Me[0] ^ Ve, fn += (vn & 128) >> Ue % 8, Be._prev = Ie(Be._prev, Te ? Ve : vn);
    return fn;
  }
  function Ie(Be, Pe) {
    var Te = Be.length, Me = -1, Ue = Ae.allocUnsafe(Be.length);
    for (Be = Ae.concat([Be, Ae.from([Pe])]); ++Me < Te; )
      Ue[Me] = Be[Me] << 1 | Be[Me + 1] >> 7;
    return Ue;
  }
  return cfb1.encrypt = function(Be, Pe, Te) {
    for (var Me = Pe.length, Ue = Ae.allocUnsafe(Me), je = -1; ++je < Me; )
      Ue[je] = t(Be, Pe[je], Te);
    return Ue;
  }, cfb1;
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb) return ofb;
  hasRequiredOfb = 1;
  var Ae = requireBufferXor();
  function t(Ie) {
    return Ie._prev = Ie._cipher.encryptBlock(Ie._prev), Ie._prev;
  }
  return ofb.encrypt = function(Ie, Be) {
    for (; Ie._cache.length < Be.length; )
      Ie._cache = Buffer$3.concat([Ie._cache, t(Ie)]);
    var Pe = Ie._cache.slice(0, Be.length);
    return Ie._cache = Ie._cache.slice(Be.length), Ae(Be, Pe);
  }, ofb;
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
  if (hasRequiredIncr32) return incr32_1;
  hasRequiredIncr32 = 1;
  function Ae(t) {
    for (var Ie = t.length, Be; Ie--; )
      if (Be = t.readUInt8(Ie), Be === 255)
        t.writeUInt8(0, Ie);
      else {
        Be++, t.writeUInt8(Be, Ie);
        break;
      }
  }
  return incr32_1 = Ae, incr32_1;
}
var hasRequiredCtr;
function requireCtr() {
  if (hasRequiredCtr) return ctr;
  hasRequiredCtr = 1;
  var Ae = requireBufferXor(), t = requireSafeBuffer$1().Buffer, Ie = requireIncr32();
  function Be(Te) {
    var Me = Te._cipher.encryptBlockRaw(Te._prev);
    return Ie(Te._prev), Me;
  }
  var Pe = 16;
  return ctr.encrypt = function(Te, Me) {
    var Ue = Math.ceil(Me.length / Pe), je = Te._cache.length;
    Te._cache = t.concat([
      Te._cache,
      t.allocUnsafe(Ue * Pe)
    ]);
    for (var fn = 0; fn < Ue; fn++) {
      var Ve = Be(Te), vn = je + fn * Pe;
      Te._cache.writeUInt32BE(Ve[0], vn + 0), Te._cache.writeUInt32BE(Ve[1], vn + 4), Te._cache.writeUInt32BE(Ve[2], vn + 8), Te._cache.writeUInt32BE(Ve[3], vn + 12);
    }
    var En = Te._cache.slice(0, Me.length);
    return Te._cache = Te._cache.slice(Me.length), Ae(Me, En);
  }, ctr;
}
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1) return modes_1;
  hasRequiredModes$1 = 1;
  var Ae = {
    ECB: requireEcb(),
    CBC: requireCbc(),
    CFB: requireCfb(),
    CFB8: requireCfb8(),
    CFB1: requireCfb1(),
    OFB: requireOfb(),
    CTR: requireCtr(),
    GCM: requireCtr()
  }, t = require$$2;
  for (var Ie in t)
    t[Ie].module = Ae[t[Ie].mode];
  return modes_1 = t, modes_1;
}
var aes = {}, hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes;
  hasRequiredAes = 1;
  var Ae = requireSafeBuffer$1().Buffer;
  function t(Ue) {
    Ae.isBuffer(Ue) || (Ue = Ae.from(Ue));
    for (var je = Ue.length / 4 | 0, fn = new Array(je), Ve = 0; Ve < je; Ve++)
      fn[Ve] = Ue.readUInt32BE(Ve * 4);
    return fn;
  }
  function Ie(Ue) {
    for (var je = 0; je < Ue.length; Ue++)
      Ue[je] = 0;
  }
  function Be(Ue, je, fn, Ve, vn) {
    for (var En = fn[0], fi = fn[1], bi = fn[2], mi = fn[3], _i = Ue[0] ^ je[0], Ei = Ue[1] ^ je[1], Si = Ue[2] ^ je[2], Mi = Ue[3] ^ je[3], Oi, Fi, Ui, Pi, Bi = 4, ji = 1; ji < vn; ji++)
      Oi = En[_i >>> 24] ^ fi[Ei >>> 16 & 255] ^ bi[Si >>> 8 & 255] ^ mi[Mi & 255] ^ je[Bi++], Fi = En[Ei >>> 24] ^ fi[Si >>> 16 & 255] ^ bi[Mi >>> 8 & 255] ^ mi[_i & 255] ^ je[Bi++], Ui = En[Si >>> 24] ^ fi[Mi >>> 16 & 255] ^ bi[_i >>> 8 & 255] ^ mi[Ei & 255] ^ je[Bi++], Pi = En[Mi >>> 24] ^ fi[_i >>> 16 & 255] ^ bi[Ei >>> 8 & 255] ^ mi[Si & 255] ^ je[Bi++], _i = Oi, Ei = Fi, Si = Ui, Mi = Pi;
    return Oi = (Ve[_i >>> 24] << 24 | Ve[Ei >>> 16 & 255] << 16 | Ve[Si >>> 8 & 255] << 8 | Ve[Mi & 255]) ^ je[Bi++], Fi = (Ve[Ei >>> 24] << 24 | Ve[Si >>> 16 & 255] << 16 | Ve[Mi >>> 8 & 255] << 8 | Ve[_i & 255]) ^ je[Bi++], Ui = (Ve[Si >>> 24] << 24 | Ve[Mi >>> 16 & 255] << 16 | Ve[_i >>> 8 & 255] << 8 | Ve[Ei & 255]) ^ je[Bi++], Pi = (Ve[Mi >>> 24] << 24 | Ve[_i >>> 16 & 255] << 16 | Ve[Ei >>> 8 & 255] << 8 | Ve[Si & 255]) ^ je[Bi++], Oi = Oi >>> 0, Fi = Fi >>> 0, Ui = Ui >>> 0, Pi = Pi >>> 0, [Oi, Fi, Ui, Pi];
  }
  var Pe = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], Te = function() {
    for (var Ue = new Array(256), je = 0; je < 256; je++)
      je < 128 ? Ue[je] = je << 1 : Ue[je] = je << 1 ^ 283;
    for (var fn = [], Ve = [], vn = [[], [], [], []], En = [[], [], [], []], fi = 0, bi = 0, mi = 0; mi < 256; ++mi) {
      var _i = bi ^ bi << 1 ^ bi << 2 ^ bi << 3 ^ bi << 4;
      _i = _i >>> 8 ^ _i & 255 ^ 99, fn[fi] = _i, Ve[_i] = fi;
      var Ei = Ue[fi], Si = Ue[Ei], Mi = Ue[Si], Oi = Ue[_i] * 257 ^ _i * 16843008;
      vn[0][fi] = Oi << 24 | Oi >>> 8, vn[1][fi] = Oi << 16 | Oi >>> 16, vn[2][fi] = Oi << 8 | Oi >>> 24, vn[3][fi] = Oi, Oi = Mi * 16843009 ^ Si * 65537 ^ Ei * 257 ^ fi * 16843008, En[0][_i] = Oi << 24 | Oi >>> 8, En[1][_i] = Oi << 16 | Oi >>> 16, En[2][_i] = Oi << 8 | Oi >>> 24, En[3][_i] = Oi, fi === 0 ? fi = bi = 1 : (fi = Ei ^ Ue[Ue[Ue[Mi ^ Ei]]], bi ^= Ue[Ue[bi]]);
    }
    return {
      SBOX: fn,
      INV_SBOX: Ve,
      SUB_MIX: vn,
      INV_SUB_MIX: En
    };
  }();
  function Me(Ue) {
    this._key = t(Ue), this._reset();
  }
  return Me.blockSize = 4 * 4, Me.keySize = 256 / 8, Me.prototype.blockSize = Me.blockSize, Me.prototype.keySize = Me.keySize, Me.prototype._reset = function() {
    for (var Ue = this._key, je = Ue.length, fn = je + 6, Ve = (fn + 1) * 4, vn = [], En = 0; En < je; En++)
      vn[En] = Ue[En];
    for (En = je; En < Ve; En++) {
      var fi = vn[En - 1];
      En % je === 0 ? (fi = fi << 8 | fi >>> 24, fi = Te.SBOX[fi >>> 24] << 24 | Te.SBOX[fi >>> 16 & 255] << 16 | Te.SBOX[fi >>> 8 & 255] << 8 | Te.SBOX[fi & 255], fi ^= Pe[En / je | 0] << 24) : je > 6 && En % je === 4 && (fi = Te.SBOX[fi >>> 24] << 24 | Te.SBOX[fi >>> 16 & 255] << 16 | Te.SBOX[fi >>> 8 & 255] << 8 | Te.SBOX[fi & 255]), vn[En] = vn[En - je] ^ fi;
    }
    for (var bi = [], mi = 0; mi < Ve; mi++) {
      var _i = Ve - mi, Ei = vn[_i - (mi % 4 ? 0 : 4)];
      mi < 4 || _i <= 4 ? bi[mi] = Ei : bi[mi] = Te.INV_SUB_MIX[0][Te.SBOX[Ei >>> 24]] ^ Te.INV_SUB_MIX[1][Te.SBOX[Ei >>> 16 & 255]] ^ Te.INV_SUB_MIX[2][Te.SBOX[Ei >>> 8 & 255]] ^ Te.INV_SUB_MIX[3][Te.SBOX[Ei & 255]];
    }
    this._nRounds = fn, this._keySchedule = vn, this._invKeySchedule = bi;
  }, Me.prototype.encryptBlockRaw = function(Ue) {
    return Ue = t(Ue), Be(Ue, this._keySchedule, Te.SUB_MIX, Te.SBOX, this._nRounds);
  }, Me.prototype.encryptBlock = function(Ue) {
    var je = this.encryptBlockRaw(Ue), fn = Ae.allocUnsafe(16);
    return fn.writeUInt32BE(je[0], 0), fn.writeUInt32BE(je[1], 4), fn.writeUInt32BE(je[2], 8), fn.writeUInt32BE(je[3], 12), fn;
  }, Me.prototype.decryptBlock = function(Ue) {
    Ue = t(Ue);
    var je = Ue[1];
    Ue[1] = Ue[3], Ue[3] = je;
    var fn = Be(Ue, this._invKeySchedule, Te.INV_SUB_MIX, Te.INV_SBOX, this._nRounds), Ve = Ae.allocUnsafe(16);
    return Ve.writeUInt32BE(fn[0], 0), Ve.writeUInt32BE(fn[3], 4), Ve.writeUInt32BE(fn[2], 8), Ve.writeUInt32BE(fn[1], 12), Ve;
  }, Me.prototype.scrub = function() {
    Ie(this._keySchedule), Ie(this._invKeySchedule), Ie(this._key);
  }, aes.AES = Me, aes;
}
var ghash, hasRequiredGhash;
function requireGhash() {
  if (hasRequiredGhash) return ghash;
  hasRequiredGhash = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = Ae.alloc(16, 0);
  function Ie(Te) {
    return [
      Te.readUInt32BE(0),
      Te.readUInt32BE(4),
      Te.readUInt32BE(8),
      Te.readUInt32BE(12)
    ];
  }
  function Be(Te) {
    var Me = Ae.allocUnsafe(16);
    return Me.writeUInt32BE(Te[0] >>> 0, 0), Me.writeUInt32BE(Te[1] >>> 0, 4), Me.writeUInt32BE(Te[2] >>> 0, 8), Me.writeUInt32BE(Te[3] >>> 0, 12), Me;
  }
  function Pe(Te) {
    this.h = Te, this.state = Ae.alloc(16, 0), this.cache = Ae.allocUnsafe(0);
  }
  return Pe.prototype.ghash = function(Te) {
    for (var Me = -1; ++Me < Te.length; )
      this.state[Me] ^= Te[Me];
    this._multiply();
  }, Pe.prototype._multiply = function() {
    for (var Te = Ie(this.h), Me = [0, 0, 0, 0], Ue, je, fn, Ve = -1; ++Ve < 128; ) {
      for (je = (this.state[~~(Ve / 8)] & 1 << 7 - Ve % 8) !== 0, je && (Me[0] ^= Te[0], Me[1] ^= Te[1], Me[2] ^= Te[2], Me[3] ^= Te[3]), fn = (Te[3] & 1) !== 0, Ue = 3; Ue > 0; Ue--)
        Te[Ue] = Te[Ue] >>> 1 | (Te[Ue - 1] & 1) << 31;
      Te[0] = Te[0] >>> 1, fn && (Te[0] = Te[0] ^ 225 << 24);
    }
    this.state = Be(Me);
  }, Pe.prototype.update = function(Te) {
    this.cache = Ae.concat([this.cache, Te]);
    for (var Me; this.cache.length >= 16; )
      Me = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(Me);
  }, Pe.prototype.final = function(Te, Me) {
    return this.cache.length && this.ghash(Ae.concat([this.cache, t], 16)), this.ghash(Be([0, Te, 0, Me])), this.state;
  }, ghash = Pe, ghash;
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
  if (hasRequiredAuthCipher) return authCipher;
  hasRequiredAuthCipher = 1;
  var Ae = requireAes(), t = requireSafeBuffer$1().Buffer, Ie = requireCipherBase(), Be = requireInherits_browser(), Pe = requireGhash(), Te = requireBufferXor(), Me = requireIncr32();
  function Ue(Ve, vn) {
    var En = 0;
    Ve.length !== vn.length && En++;
    for (var fi = Math.min(Ve.length, vn.length), bi = 0; bi < fi; ++bi)
      En += Ve[bi] ^ vn[bi];
    return En;
  }
  function je(Ve, vn, En) {
    if (vn.length === 12)
      return Ve._finID = t.concat([vn, t.from([0, 0, 0, 1])]), t.concat([vn, t.from([0, 0, 0, 2])]);
    var fi = new Pe(En), bi = vn.length, mi = bi % 16;
    fi.update(vn), mi && (mi = 16 - mi, fi.update(t.alloc(mi, 0))), fi.update(t.alloc(8, 0));
    var _i = bi * 8, Ei = t.alloc(8);
    Ei.writeUIntBE(_i, 0, 8), fi.update(Ei), Ve._finID = fi.state;
    var Si = t.from(Ve._finID);
    return Me(Si), Si;
  }
  function fn(Ve, vn, En, fi) {
    Ie.call(this);
    var bi = t.alloc(4, 0);
    this._cipher = new Ae.AES(vn);
    var mi = this._cipher.encryptBlock(bi);
    this._ghash = new Pe(mi), En = je(this, En, mi), this._prev = t.from(En), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = fi, this._alen = 0, this._len = 0, this._mode = Ve, this._authTag = null, this._called = !1;
  }
  return Be(fn, Ie), fn.prototype._update = function(Ve) {
    if (!this._called && this._alen) {
      var vn = 16 - this._alen % 16;
      vn < 16 && (vn = t.alloc(vn, 0), this._ghash.update(vn));
    }
    this._called = !0;
    var En = this._mode.encrypt(this, Ve);
    return this._decrypt ? this._ghash.update(Ve) : this._ghash.update(En), this._len += Ve.length, En;
  }, fn.prototype._final = function() {
    if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var Ve = Te(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && Ue(Ve, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = Ve, this._cipher.scrub();
  }, fn.prototype.getAuthTag = function() {
    if (this._decrypt || !t.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, fn.prototype.setAuthTag = function(vn) {
    if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = vn;
  }, fn.prototype.setAAD = function(vn) {
    if (this._called) throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(vn), this._alen += vn.length;
  }, authCipher = fn, authCipher;
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
  if (hasRequiredStreamCipher) return streamCipher;
  hasRequiredStreamCipher = 1;
  var Ae = requireAes(), t = requireSafeBuffer$1().Buffer, Ie = requireCipherBase(), Be = requireInherits_browser();
  function Pe(Te, Me, Ue, je) {
    Ie.call(this), this._cipher = new Ae.AES(Me), this._prev = t.from(Ue), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = je, this._mode = Te;
  }
  return Be(Pe, Ie), Pe.prototype._update = function(Te) {
    return this._mode.encrypt(this, Te, this._decrypt);
  }, Pe.prototype._final = function() {
    this._cipher.scrub();
  }, streamCipher = Pe, streamCipher;
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey) return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requireMd5_js();
  function Ie(Be, Pe, Te, Me) {
    if (Ae.isBuffer(Be) || (Be = Ae.from(Be, "binary")), Pe && (Ae.isBuffer(Pe) || (Pe = Ae.from(Pe, "binary")), Pe.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var Ue = Te / 8, je = Ae.alloc(Ue), fn = Ae.alloc(Me || 0), Ve = Ae.alloc(0); Ue > 0 || Me > 0; ) {
      var vn = new t();
      vn.update(Ve), vn.update(Be), Pe && vn.update(Pe), Ve = vn.digest();
      var En = 0;
      if (Ue > 0) {
        var fi = je.length - Ue;
        En = Math.min(Ue, Ve.length), Ve.copy(je, fi, 0, En), Ue -= En;
      }
      if (En < Ve.length && Me > 0) {
        var bi = fn.length - Me, mi = Math.min(Me, Ve.length - En);
        Ve.copy(fn, bi, En, En + mi), Me -= mi;
      }
    }
    return Ve.fill(0), { key: je, iv: fn };
  }
  return evp_bytestokey = Ie, evp_bytestokey;
}
var hasRequiredEncrypter;
function requireEncrypter() {
  if (hasRequiredEncrypter) return encrypter;
  hasRequiredEncrypter = 1;
  var Ae = requireModes$1(), t = requireAuthCipher(), Ie = requireSafeBuffer$1().Buffer, Be = requireStreamCipher(), Pe = requireCipherBase(), Te = requireAes(), Me = requireEvp_bytestokey(), Ue = requireInherits_browser();
  function je(fi, bi, mi) {
    Pe.call(this), this._cache = new Ve(), this._cipher = new Te.AES(bi), this._prev = Ie.from(mi), this._mode = fi, this._autopadding = !0;
  }
  Ue(je, Pe), je.prototype._update = function(fi) {
    this._cache.add(fi);
    for (var bi, mi, _i = []; bi = this._cache.get(); )
      mi = this._mode.encrypt(this, bi), _i.push(mi);
    return Ie.concat(_i);
  };
  var fn = Ie.alloc(16, 16);
  je.prototype._final = function() {
    var fi = this._cache.flush();
    if (this._autopadding)
      return fi = this._mode.encrypt(this, fi), this._cipher.scrub(), fi;
    if (!fi.equals(fn))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, je.prototype.setAutoPadding = function(fi) {
    return this._autopadding = !!fi, this;
  };
  function Ve() {
    this.cache = Ie.allocUnsafe(0);
  }
  Ve.prototype.add = function(fi) {
    this.cache = Ie.concat([this.cache, fi]);
  }, Ve.prototype.get = function() {
    if (this.cache.length > 15) {
      var fi = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), fi;
    }
    return null;
  }, Ve.prototype.flush = function() {
    for (var fi = 16 - this.cache.length, bi = Ie.allocUnsafe(fi), mi = -1; ++mi < fi; )
      bi.writeUInt8(fi, mi);
    return Ie.concat([this.cache, bi]);
  };
  function vn(fi, bi, mi) {
    var _i = Ae[fi.toLowerCase()];
    if (!_i) throw new TypeError("invalid suite type");
    if (typeof bi == "string" && (bi = Ie.from(bi)), bi.length !== _i.key / 8) throw new TypeError("invalid key length " + bi.length);
    if (typeof mi == "string" && (mi = Ie.from(mi)), _i.mode !== "GCM" && mi.length !== _i.iv) throw new TypeError("invalid iv length " + mi.length);
    return _i.type === "stream" ? new Be(_i.module, bi, mi) : _i.type === "auth" ? new t(_i.module, bi, mi) : new je(_i.module, bi, mi);
  }
  function En(fi, bi) {
    var mi = Ae[fi.toLowerCase()];
    if (!mi) throw new TypeError("invalid suite type");
    var _i = Me(bi, !1, mi.key, mi.iv);
    return vn(fi, _i.key, _i.iv);
  }
  return encrypter.createCipheriv = vn, encrypter.createCipher = En, encrypter;
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
  if (hasRequiredDecrypter) return decrypter;
  hasRequiredDecrypter = 1;
  var Ae = requireAuthCipher(), t = requireSafeBuffer$1().Buffer, Ie = requireModes$1(), Be = requireStreamCipher(), Pe = requireCipherBase(), Te = requireAes(), Me = requireEvp_bytestokey(), Ue = requireInherits_browser();
  function je(fi, bi, mi) {
    Pe.call(this), this._cache = new fn(), this._last = void 0, this._cipher = new Te.AES(bi), this._prev = t.from(mi), this._mode = fi, this._autopadding = !0;
  }
  Ue(je, Pe), je.prototype._update = function(fi) {
    this._cache.add(fi);
    for (var bi, mi, _i = []; bi = this._cache.get(this._autopadding); )
      mi = this._mode.decrypt(this, bi), _i.push(mi);
    return t.concat(_i);
  }, je.prototype._final = function() {
    var fi = this._cache.flush();
    if (this._autopadding)
      return Ve(this._mode.decrypt(this, fi));
    if (fi)
      throw new Error("data not multiple of block length");
  }, je.prototype.setAutoPadding = function(fi) {
    return this._autopadding = !!fi, this;
  };
  function fn() {
    this.cache = t.allocUnsafe(0);
  }
  fn.prototype.add = function(fi) {
    this.cache = t.concat([this.cache, fi]);
  }, fn.prototype.get = function(fi) {
    var bi;
    if (fi) {
      if (this.cache.length > 16)
        return bi = this.cache.slice(0, 16), this.cache = this.cache.slice(16), bi;
    } else if (this.cache.length >= 16)
      return bi = this.cache.slice(0, 16), this.cache = this.cache.slice(16), bi;
    return null;
  }, fn.prototype.flush = function() {
    if (this.cache.length) return this.cache;
  };
  function Ve(fi) {
    var bi = fi[15];
    if (bi < 1 || bi > 16)
      throw new Error("unable to decrypt data");
    for (var mi = -1; ++mi < bi; )
      if (fi[mi + (16 - bi)] !== bi)
        throw new Error("unable to decrypt data");
    if (bi !== 16)
      return fi.slice(0, 16 - bi);
  }
  function vn(fi, bi, mi) {
    var _i = Ie[fi.toLowerCase()];
    if (!_i) throw new TypeError("invalid suite type");
    if (typeof mi == "string" && (mi = t.from(mi)), _i.mode !== "GCM" && mi.length !== _i.iv) throw new TypeError("invalid iv length " + mi.length);
    if (typeof bi == "string" && (bi = t.from(bi)), bi.length !== _i.key / 8) throw new TypeError("invalid key length " + bi.length);
    return _i.type === "stream" ? new Be(_i.module, bi, mi, !0) : _i.type === "auth" ? new Ae(_i.module, bi, mi, !0) : new je(_i.module, bi, mi);
  }
  function En(fi, bi) {
    var mi = Ie[fi.toLowerCase()];
    if (!mi) throw new TypeError("invalid suite type");
    var _i = Me(bi, !1, mi.key, mi.iv);
    return vn(fi, _i.key, _i.iv);
  }
  return decrypter.createDecipher = En, decrypter.createDecipheriv = vn, decrypter;
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
  if (hasRequiredBrowser$7) return browser$a;
  hasRequiredBrowser$7 = 1;
  var Ae = requireEncrypter(), t = requireDecrypter(), Ie = require$$2;
  function Be() {
    return Object.keys(Ie);
  }
  return browser$a.createCipher = browser$a.Cipher = Ae.createCipher, browser$a.createCipheriv = browser$a.Cipheriv = Ae.createCipheriv, browser$a.createDecipher = browser$a.Decipher = t.createDecipher, browser$a.createDecipheriv = browser$a.Decipheriv = t.createDecipheriv, browser$a.listCiphers = browser$a.getCiphers = Be, browser$a;
}
var modes = {}, hasRequiredModes;
function requireModes() {
  return hasRequiredModes || (hasRequiredModes = 1, function(Ae) {
    Ae["des-ecb"] = {
      key: 8,
      iv: 0
    }, Ae["des-cbc"] = Ae.des = {
      key: 8,
      iv: 8
    }, Ae["des-ede3-cbc"] = Ae.des3 = {
      key: 24,
      iv: 8
    }, Ae["des-ede3"] = {
      key: 24,
      iv: 0
    }, Ae["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, Ae["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(modes)), modes;
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
  if (hasRequiredBrowser$6) return browser$b;
  hasRequiredBrowser$6 = 1;
  var Ae = requireBrowserifyDes(), t = requireBrowser$7(), Ie = requireModes$1(), Be = requireModes(), Pe = requireEvp_bytestokey();
  function Te(Ve, vn) {
    Ve = Ve.toLowerCase();
    var En, fi;
    if (Ie[Ve])
      En = Ie[Ve].key, fi = Ie[Ve].iv;
    else if (Be[Ve])
      En = Be[Ve].key * 8, fi = Be[Ve].iv;
    else
      throw new TypeError("invalid suite type");
    var bi = Pe(vn, !1, En, fi);
    return Ue(Ve, bi.key, bi.iv);
  }
  function Me(Ve, vn) {
    Ve = Ve.toLowerCase();
    var En, fi;
    if (Ie[Ve])
      En = Ie[Ve].key, fi = Ie[Ve].iv;
    else if (Be[Ve])
      En = Be[Ve].key * 8, fi = Be[Ve].iv;
    else
      throw new TypeError("invalid suite type");
    var bi = Pe(vn, !1, En, fi);
    return je(Ve, bi.key, bi.iv);
  }
  function Ue(Ve, vn, En) {
    if (Ve = Ve.toLowerCase(), Ie[Ve]) return t.createCipheriv(Ve, vn, En);
    if (Be[Ve]) return new Ae({ key: vn, iv: En, mode: Ve });
    throw new TypeError("invalid suite type");
  }
  function je(Ve, vn, En) {
    if (Ve = Ve.toLowerCase(), Ie[Ve]) return t.createDecipheriv(Ve, vn, En);
    if (Be[Ve]) return new Ae({ key: vn, iv: En, mode: Ve, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function fn() {
    return Object.keys(Be).concat(t.getCiphers());
  }
  return browser$b.createCipher = browser$b.Cipher = Te, browser$b.createCipheriv = browser$b.Cipheriv = Ue, browser$b.createDecipher = browser$b.Decipher = Me, browser$b.createDecipheriv = browser$b.Decipheriv = je, browser$b.listCiphers = browser$b.getCiphers = fn, browser$b;
}
var browser$9 = {}, mr$3, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr$3;
  hasRequiredMr = 1;
  var Ae = requireBn(), t = requireBrorand();
  function Ie(Be) {
    this.rand = Be || new t.Rand();
  }
  return mr$3 = Ie, Ie.create = function(Pe) {
    return new Ie(Pe);
  }, Ie.prototype._randbelow = function(Pe) {
    var Te = Pe.bitLength(), Me = Math.ceil(Te / 8);
    do
      var Ue = new Ae(this.rand.generate(Me));
    while (Ue.cmp(Pe) >= 0);
    return Ue;
  }, Ie.prototype._randrange = function(Pe, Te) {
    var Me = Te.sub(Pe);
    return Pe.add(this._randbelow(Me));
  }, Ie.prototype.test = function(Pe, Te, Me) {
    var Ue = Pe.bitLength(), je = Ae.mont(Pe), fn = new Ae(1).toRed(je);
    Te || (Te = Math.max(1, Ue / 48 | 0));
    for (var Ve = Pe.subn(1), vn = 0; !Ve.testn(vn); vn++)
      ;
    for (var En = Pe.shrn(vn), fi = Ve.toRed(je), bi = !0; Te > 0; Te--) {
      var mi = this._randrange(new Ae(2), Ve);
      Me && Me(mi);
      var _i = mi.toRed(je).redPow(En);
      if (!(_i.cmp(fn) === 0 || _i.cmp(fi) === 0)) {
        for (var Ei = 1; Ei < vn; Ei++) {
          if (_i = _i.redSqr(), _i.cmp(fn) === 0)
            return !1;
          if (_i.cmp(fi) === 0)
            break;
        }
        if (Ei === vn)
          return !1;
      }
    }
    return bi;
  }, Ie.prototype.getDivisor = function(Pe, Te) {
    var Me = Pe.bitLength(), Ue = Ae.mont(Pe), je = new Ae(1).toRed(Ue);
    Te || (Te = Math.max(1, Me / 48 | 0));
    for (var fn = Pe.subn(1), Ve = 0; !fn.testn(Ve); Ve++)
      ;
    for (var vn = Pe.shrn(Ve), En = fn.toRed(Ue); Te > 0; Te--) {
      var fi = this._randrange(new Ae(2), fn), bi = Pe.gcd(fi);
      if (bi.cmpn(1) !== 0)
        return bi;
      var mi = fi.toRed(Ue).redPow(vn);
      if (!(mi.cmp(je) === 0 || mi.cmp(En) === 0)) {
        for (var _i = 1; _i < Ve; _i++) {
          if (mi = mi.redSqr(), mi.cmp(je) === 0)
            return mi.fromRed().subn(1).gcd(Pe);
          if (mi.cmp(En) === 0)
            break;
        }
        if (_i === Ve)
          return mi = mi.redSqr(), mi.fromRed().subn(1).gcd(Pe);
      }
    }
    return !1;
  }, mr$3;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var Ae = requireBrowser$c();
  generatePrime = _i, _i.simpleSieve = bi, _i.fermatTest = mi;
  var t = requireBn(), Ie = new t(24), Be = requireMr(), Pe = new Be(), Te = new t(1), Me = new t(2), Ue = new t(5);
  new t(16), new t(8);
  var je = new t(10), fn = new t(3);
  new t(7);
  var Ve = new t(11), vn = new t(4);
  new t(12);
  var En = null;
  function fi() {
    if (En !== null)
      return En;
    var Ei = 1048576, Si = [];
    Si[0] = 2;
    for (var Mi = 1, Oi = 3; Oi < Ei; Oi += 2) {
      for (var Fi = Math.ceil(Math.sqrt(Oi)), Ui = 0; Ui < Mi && Si[Ui] <= Fi && Oi % Si[Ui] !== 0; Ui++)
        ;
      Mi !== Ui && Si[Ui] <= Fi || (Si[Mi++] = Oi);
    }
    return En = Si, Si;
  }
  function bi(Ei) {
    for (var Si = fi(), Mi = 0; Mi < Si.length; Mi++)
      if (Ei.modn(Si[Mi]) === 0)
        return Ei.cmpn(Si[Mi]) === 0;
    return !0;
  }
  function mi(Ei) {
    var Si = t.mont(Ei);
    return Me.toRed(Si).redPow(Ei.subn(1)).fromRed().cmpn(1) === 0;
  }
  function _i(Ei, Si) {
    if (Ei < 16)
      return Si === 2 || Si === 5 ? new t([140, 123]) : new t([140, 39]);
    Si = new t(Si);
    for (var Mi, Oi; ; ) {
      for (Mi = new t(Ae(Math.ceil(Ei / 8))); Mi.bitLength() > Ei; )
        Mi.ishrn(1);
      if (Mi.isEven() && Mi.iadd(Te), Mi.testn(1) || Mi.iadd(Me), Si.cmp(Me)) {
        if (!Si.cmp(Ue))
          for (; Mi.mod(je).cmp(fn); )
            Mi.iadd(vn);
      } else for (; Mi.mod(Ie).cmp(Ve); )
        Mi.iadd(vn);
      if (Oi = Mi.shrn(1), bi(Oi) && bi(Mi) && mi(Oi) && mi(Mi) && Pe.test(Oi) && Pe.test(Mi))
        return Mi;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var Ae = requireBn(), t = requireMr(), Ie = new t(), Be = new Ae(24), Pe = new Ae(11), Te = new Ae(10), Me = new Ae(3), Ue = new Ae(7), je = requireGeneratePrime(), fn = requireBrowser$c();
  dh = bi;
  function Ve(_i, Ei) {
    return Ei = Ei || "utf8", Buffer$3.isBuffer(_i) || (_i = new Buffer$3(_i, Ei)), this._pub = new Ae(_i), this;
  }
  function vn(_i, Ei) {
    return Ei = Ei || "utf8", Buffer$3.isBuffer(_i) || (_i = new Buffer$3(_i, Ei)), this._priv = new Ae(_i), this;
  }
  var En = {};
  function fi(_i, Ei) {
    var Si = Ei.toString("hex"), Mi = [Si, _i.toString(16)].join("_");
    if (Mi in En)
      return En[Mi];
    var Oi = 0;
    if (_i.isEven() || !je.simpleSieve || !je.fermatTest(_i) || !Ie.test(_i))
      return Oi += 1, Si === "02" || Si === "05" ? Oi += 8 : Oi += 4, En[Mi] = Oi, Oi;
    Ie.test(_i.shrn(1)) || (Oi += 2);
    var Fi;
    switch (Si) {
      case "02":
        _i.mod(Be).cmp(Pe) && (Oi += 8);
        break;
      case "05":
        Fi = _i.mod(Te), Fi.cmp(Me) && Fi.cmp(Ue) && (Oi += 8);
        break;
      default:
        Oi += 4;
    }
    return En[Mi] = Oi, Oi;
  }
  function bi(_i, Ei, Si) {
    this.setGenerator(Ei), this.__prime = new Ae(_i), this._prime = Ae.mont(this.__prime), this._primeLen = _i.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, Si ? (this.setPublicKey = Ve, this.setPrivateKey = vn) : this._primeCode = 8;
  }
  Object.defineProperty(bi.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = fi(this.__prime, this.__gen)), this._primeCode;
    }
  }), bi.prototype.generateKeys = function() {
    return this._priv || (this._priv = new Ae(fn(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, bi.prototype.computeSecret = function(_i) {
    _i = new Ae(_i), _i = _i.toRed(this._prime);
    var Ei = _i.redPow(this._priv).fromRed(), Si = new Buffer$3(Ei.toArray()), Mi = this.getPrime();
    if (Si.length < Mi.length) {
      var Oi = new Buffer$3(Mi.length - Si.length);
      Oi.fill(0), Si = Buffer$3.concat([Oi, Si]);
    }
    return Si;
  }, bi.prototype.getPublicKey = function(Ei) {
    return mi(this._pub, Ei);
  }, bi.prototype.getPrivateKey = function(Ei) {
    return mi(this._priv, Ei);
  }, bi.prototype.getPrime = function(_i) {
    return mi(this.__prime, _i);
  }, bi.prototype.getGenerator = function(_i) {
    return mi(this._gen, _i);
  }, bi.prototype.setGenerator = function(_i, Ei) {
    return Ei = Ei || "utf8", Buffer$3.isBuffer(_i) || (_i = new Buffer$3(_i, Ei)), this.__gen = _i, this._gen = new Ae(_i), this;
  };
  function mi(_i, Ei) {
    var Si = new Buffer$3(_i.toArray());
    return Ei ? Si.toString(Ei) : Si;
  }
  return dh;
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
  if (hasRequiredBrowser$5) return browser$9;
  hasRequiredBrowser$5 = 1;
  var Ae = requireGeneratePrime(), t = require$$1$1, Ie = requireDh();
  function Be(Me) {
    var Ue = new Buffer$3(t[Me].prime, "hex"), je = new Buffer$3(t[Me].gen, "hex");
    return new Ie(Ue, je);
  }
  var Pe = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function Te(Me, Ue, je, fn) {
    return Buffer$3.isBuffer(Ue) || Pe[Ue] === void 0 ? Te(Me, "binary", Ue, je) : (Ue = Ue || "binary", fn = fn || "binary", je = je || new Buffer$3([2]), Buffer$3.isBuffer(je) || (je = new Buffer$3(je, fn)), typeof Me == "number" ? new Ie(Ae(Me, je), je, !0) : (Buffer$3.isBuffer(Me) || (Me = new Buffer$3(Me, Ue)), new Ie(Me, je, !0)));
  }
  return browser$9.DiffieHellmanGroup = browser$9.createDiffieHellmanGroup = browser$9.getDiffieHellman = Be, browser$9.createDiffieHellman = browser$9.DiffieHellman = Te, browser$9;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} }, hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1, typeof process$1$1 > "u" || !process$1$1.version || process$1$1.version.indexOf("v0.") === 0 || process$1$1.version.indexOf("v1.") === 0 && process$1$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick: Ae } : processNextickArgs.exports = process$1$1;
  function Ae(t, Ie, Be, Pe) {
    if (typeof t != "function")
      throw new TypeError('"callback" argument must be a function');
    var Te = arguments.length, Me, Ue;
    switch (Te) {
      case 0:
      case 1:
        return process$1$1.nextTick(t);
      case 2:
        return process$1$1.nextTick(function() {
          t.call(null, Ie);
        });
      case 3:
        return process$1$1.nextTick(function() {
          t.call(null, Ie, Be);
        });
      case 4:
        return process$1$1.nextTick(function() {
          t.call(null, Ie, Be, Pe);
        });
      default:
        for (Me = new Array(Te - 1), Ue = 0; Ue < Me.length; )
          Me[Ue++] = arguments[Ue];
        return process$1$1.nextTick(function() {
          t.apply(null, Me);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray$1, hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray$1;
  hasRequiredIsarray = 1;
  var Ae = {}.toString;
  return isarray$1 = Array.isArray || function(t) {
    return Ae.call(t) == "[object Array]";
  }, isarray$1;
}
var streamBrowser, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser = eventsExports.EventEmitter), streamBrowser;
}
var safeBuffer = { exports: {} }, hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(Ae, t) {
    var Ie = require$$0$4, Be = Ie.Buffer;
    function Pe(Me, Ue) {
      for (var je in Me)
        Ue[je] = Me[je];
    }
    Be.from && Be.alloc && Be.allocUnsafe && Be.allocUnsafeSlow ? Ae.exports = Ie : (Pe(Ie, t), t.Buffer = Te);
    function Te(Me, Ue, je) {
      return Be(Me, Ue, je);
    }
    Pe(Be, Te), Te.from = function(Me, Ue, je) {
      if (typeof Me == "number")
        throw new TypeError("Argument must not be a number");
      return Be(Me, Ue, je);
    }, Te.alloc = function(Me, Ue, je) {
      if (typeof Me != "number")
        throw new TypeError("Argument must be a number");
      var fn = Be(Me);
      return Ue !== void 0 ? typeof je == "string" ? fn.fill(Ue, je) : fn.fill(Ue) : fn.fill(0), fn;
    }, Te.allocUnsafe = function(Me) {
      if (typeof Me != "number")
        throw new TypeError("Argument must be a number");
      return Be(Me);
    }, Te.allocUnsafeSlow = function(Me) {
      if (typeof Me != "number")
        throw new TypeError("Argument must be a number");
      return Ie.SlowBuffer(Me);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var util$1 = {}, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util$1;
  hasRequiredUtil = 1;
  function Ae(mi) {
    return Array.isArray ? Array.isArray(mi) : bi(mi) === "[object Array]";
  }
  util$1.isArray = Ae;
  function t(mi) {
    return typeof mi == "boolean";
  }
  util$1.isBoolean = t;
  function Ie(mi) {
    return mi === null;
  }
  util$1.isNull = Ie;
  function Be(mi) {
    return mi == null;
  }
  util$1.isNullOrUndefined = Be;
  function Pe(mi) {
    return typeof mi == "number";
  }
  util$1.isNumber = Pe;
  function Te(mi) {
    return typeof mi == "string";
  }
  util$1.isString = Te;
  function Me(mi) {
    return typeof mi == "symbol";
  }
  util$1.isSymbol = Me;
  function Ue(mi) {
    return mi === void 0;
  }
  util$1.isUndefined = Ue;
  function je(mi) {
    return bi(mi) === "[object RegExp]";
  }
  util$1.isRegExp = je;
  function fn(mi) {
    return typeof mi == "object" && mi !== null;
  }
  util$1.isObject = fn;
  function Ve(mi) {
    return bi(mi) === "[object Date]";
  }
  util$1.isDate = Ve;
  function vn(mi) {
    return bi(mi) === "[object Error]" || mi instanceof Error;
  }
  util$1.isError = vn;
  function En(mi) {
    return typeof mi == "function";
  }
  util$1.isFunction = En;
  function fi(mi) {
    return mi === null || typeof mi == "boolean" || typeof mi == "number" || typeof mi == "string" || typeof mi == "symbol" || // ES6 symbol
    typeof mi > "u";
  }
  util$1.isPrimitive = fi, util$1.isBuffer = require$$0$4.Buffer.isBuffer;
  function bi(mi) {
    return Object.prototype.toString.call(mi);
  }
  return util$1;
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(Ae) {
    function t(Te, Me) {
      if (!(Te instanceof Me))
        throw new TypeError("Cannot call a class as a function");
    }
    var Ie = requireSafeBuffer().Buffer, Be = util$2;
    function Pe(Te, Me, Ue) {
      Te.copy(Me, Ue);
    }
    Ae.exports = function() {
      function Te() {
        t(this, Te), this.head = null, this.tail = null, this.length = 0;
      }
      return Te.prototype.push = function(Ue) {
        var je = { data: Ue, next: null };
        this.length > 0 ? this.tail.next = je : this.head = je, this.tail = je, ++this.length;
      }, Te.prototype.unshift = function(Ue) {
        var je = { data: Ue, next: this.head };
        this.length === 0 && (this.tail = je), this.head = je, ++this.length;
      }, Te.prototype.shift = function() {
        if (this.length !== 0) {
          var Ue = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Ue;
        }
      }, Te.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, Te.prototype.join = function(Ue) {
        if (this.length === 0) return "";
        for (var je = this.head, fn = "" + je.data; je = je.next; )
          fn += Ue + je.data;
        return fn;
      }, Te.prototype.concat = function(Ue) {
        if (this.length === 0) return Ie.alloc(0);
        for (var je = Ie.allocUnsafe(Ue >>> 0), fn = this.head, Ve = 0; fn; )
          Pe(fn.data, je, Ve), Ve += fn.data.length, fn = fn.next;
        return je;
      }, Te;
    }(), Be && Be.inspect && Be.inspect.custom && (Ae.exports.prototype[Be.inspect.custom] = function() {
      var Te = Be.inspect({ length: this.length });
      return this.constructor.name + " " + Te;
    });
  }(BufferList)), BufferList.exports;
}
var destroy_1$1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1$1;
  hasRequiredDestroy = 1;
  var Ae = requireProcessNextickArgs();
  function t(Pe, Te) {
    var Me = this, Ue = this._readableState && this._readableState.destroyed, je = this._writableState && this._writableState.destroyed;
    return Ue || je ? (Te ? Te(Pe) : Pe && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, Ae.nextTick(Be, this, Pe)) : Ae.nextTick(Be, this, Pe)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(Pe || null, function(fn) {
      !Te && fn ? Me._writableState ? Me._writableState.errorEmitted || (Me._writableState.errorEmitted = !0, Ae.nextTick(Be, Me, fn)) : Ae.nextTick(Be, Me, fn) : Te && Te(fn);
    }), this);
  }
  function Ie() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function Be(Pe, Te) {
    Pe.emit("error", Te);
  }
  return destroy_1$1 = {
    destroy: t,
    undestroy: Ie
  }, destroy_1$1;
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var Ae = requireProcessNextickArgs();
  _stream_writable = mi;
  function t(Ri) {
    var Ti = this;
    this.next = null, this.entry = null, this.finish = function() {
      Ai(Ti, Ri);
    };
  }
  var Ie = !process$1$1.browser && ["v0.10", "v0.9."].indexOf(process$1$1.version.slice(0, 5)) > -1 ? setImmediate : Ae.nextTick, Be;
  mi.WritableState = fi;
  var Pe = Object.create(requireUtil());
  Pe.inherits = requireInherits_browser();
  var Te = {
    deprecate: requireBrowser$b()
  }, Me = requireStreamBrowser(), Ue = requireSafeBuffer().Buffer, je = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function fn(Ri) {
    return Ue.from(Ri);
  }
  function Ve(Ri) {
    return Ue.isBuffer(Ri) || Ri instanceof je;
  }
  var vn = requireDestroy();
  Pe.inherits(mi, Me);
  function En() {
  }
  function fi(Ri, Ti) {
    Be = Be || require_stream_duplex(), Ri = Ri || {};
    var Ci = Ti instanceof Be;
    this.objectMode = !!Ri.objectMode, Ci && (this.objectMode = this.objectMode || !!Ri.writableObjectMode);
    var Ii = Ri.highWaterMark, Li = Ri.writableHighWaterMark, Ni = this.objectMode ? 16 : 16 * 1024;
    Ii || Ii === 0 ? this.highWaterMark = Ii : Ci && (Li || Li === 0) ? this.highWaterMark = Li : this.highWaterMark = Ni, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Vi = Ri.decodeStrings === !1;
    this.decodeStrings = !Vi, this.defaultEncoding = Ri.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(is) {
      Pi(Ti, is);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  fi.prototype.getBuffer = function() {
    for (var Ti = this.bufferedRequest, Ci = []; Ti; )
      Ci.push(Ti), Ti = Ti.next;
    return Ci;
  }, function() {
    try {
      Object.defineProperty(fi.prototype, "buffer", {
        get: Te.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var bi;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (bi = Function.prototype[Symbol.hasInstance], Object.defineProperty(mi, Symbol.hasInstance, {
    value: function(Ri) {
      return bi.call(this, Ri) ? !0 : this !== mi ? !1 : Ri && Ri._writableState instanceof fi;
    }
  })) : bi = function(Ri) {
    return Ri instanceof this;
  };
  function mi(Ri) {
    if (Be = Be || require_stream_duplex(), !bi.call(mi, this) && !(this instanceof Be))
      return new mi(Ri);
    this._writableState = new fi(Ri, this), this.writable = !0, Ri && (typeof Ri.write == "function" && (this._write = Ri.write), typeof Ri.writev == "function" && (this._writev = Ri.writev), typeof Ri.destroy == "function" && (this._destroy = Ri.destroy), typeof Ri.final == "function" && (this._final = Ri.final)), Me.call(this);
  }
  mi.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function _i(Ri, Ti) {
    var Ci = new Error("write after end");
    Ri.emit("error", Ci), Ae.nextTick(Ti, Ci);
  }
  function Ei(Ri, Ti, Ci, Ii) {
    var Li = !0, Ni = !1;
    return Ci === null ? Ni = new TypeError("May not write null values to stream") : typeof Ci != "string" && Ci !== void 0 && !Ti.objectMode && (Ni = new TypeError("Invalid non-string/buffer chunk")), Ni && (Ri.emit("error", Ni), Ae.nextTick(Ii, Ni), Li = !1), Li;
  }
  mi.prototype.write = function(Ri, Ti, Ci) {
    var Ii = this._writableState, Li = !1, Ni = !Ii.objectMode && Ve(Ri);
    return Ni && !Ue.isBuffer(Ri) && (Ri = fn(Ri)), typeof Ti == "function" && (Ci = Ti, Ti = null), Ni ? Ti = "buffer" : Ti || (Ti = Ii.defaultEncoding), typeof Ci != "function" && (Ci = En), Ii.ended ? _i(this, Ci) : (Ni || Ei(this, Ii, Ri, Ci)) && (Ii.pendingcb++, Li = Mi(this, Ii, Ni, Ri, Ti, Ci)), Li;
  }, mi.prototype.cork = function() {
    var Ri = this._writableState;
    Ri.corked++;
  }, mi.prototype.uncork = function() {
    var Ri = this._writableState;
    Ri.corked && (Ri.corked--, !Ri.writing && !Ri.corked && !Ri.bufferProcessing && Ri.bufferedRequest && Zi(this, Ri));
  }, mi.prototype.setDefaultEncoding = function(Ti) {
    if (typeof Ti == "string" && (Ti = Ti.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Ti + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + Ti);
    return this._writableState.defaultEncoding = Ti, this;
  };
  function Si(Ri, Ti, Ci) {
    return !Ri.objectMode && Ri.decodeStrings !== !1 && typeof Ti == "string" && (Ti = Ue.from(Ti, Ci)), Ti;
  }
  Object.defineProperty(mi.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Mi(Ri, Ti, Ci, Ii, Li, Ni) {
    if (!Ci) {
      var Vi = Si(Ti, Ii, Li);
      Ii !== Vi && (Ci = !0, Li = "buffer", Ii = Vi);
    }
    var is = Ti.objectMode ? 1 : Ii.length;
    Ti.length += is;
    var Ki = Ti.length < Ti.highWaterMark;
    if (Ki || (Ti.needDrain = !0), Ti.writing || Ti.corked) {
      var ts = Ti.lastBufferedRequest;
      Ti.lastBufferedRequest = {
        chunk: Ii,
        encoding: Li,
        isBuf: Ci,
        callback: Ni,
        next: null
      }, ts ? ts.next = Ti.lastBufferedRequest : Ti.bufferedRequest = Ti.lastBufferedRequest, Ti.bufferedRequestCount += 1;
    } else
      Oi(Ri, Ti, !1, is, Ii, Li, Ni);
    return Ki;
  }
  function Oi(Ri, Ti, Ci, Ii, Li, Ni, Vi) {
    Ti.writelen = Ii, Ti.writecb = Vi, Ti.writing = !0, Ti.sync = !0, Ci ? Ri._writev(Li, Ti.onwrite) : Ri._write(Li, Ni, Ti.onwrite), Ti.sync = !1;
  }
  function Fi(Ri, Ti, Ci, Ii, Li) {
    --Ti.pendingcb, Ci ? (Ae.nextTick(Li, Ii), Ae.nextTick(vi, Ri, Ti), Ri._writableState.errorEmitted = !0, Ri.emit("error", Ii)) : (Li(Ii), Ri._writableState.errorEmitted = !0, Ri.emit("error", Ii), vi(Ri, Ti));
  }
  function Ui(Ri) {
    Ri.writing = !1, Ri.writecb = null, Ri.length -= Ri.writelen, Ri.writelen = 0;
  }
  function Pi(Ri, Ti) {
    var Ci = Ri._writableState, Ii = Ci.sync, Li = Ci.writecb;
    if (Ui(Ci), Ti) Fi(Ri, Ci, Ii, Ti, Li);
    else {
      var Ni = zi(Ci);
      !Ni && !Ci.corked && !Ci.bufferProcessing && Ci.bufferedRequest && Zi(Ri, Ci), Ii ? Ie(Bi, Ri, Ci, Ni, Li) : Bi(Ri, Ci, Ni, Li);
    }
  }
  function Bi(Ri, Ti, Ci, Ii) {
    Ci || ji(Ri, Ti), Ti.pendingcb--, Ii(), vi(Ri, Ti);
  }
  function ji(Ri, Ti) {
    Ti.length === 0 && Ti.needDrain && (Ti.needDrain = !1, Ri.emit("drain"));
  }
  function Zi(Ri, Ti) {
    Ti.bufferProcessing = !0;
    var Ci = Ti.bufferedRequest;
    if (Ri._writev && Ci && Ci.next) {
      var Ii = Ti.bufferedRequestCount, Li = new Array(Ii), Ni = Ti.corkedRequestsFree;
      Ni.entry = Ci;
      for (var Vi = 0, is = !0; Ci; )
        Li[Vi] = Ci, Ci.isBuf || (is = !1), Ci = Ci.next, Vi += 1;
      Li.allBuffers = is, Oi(Ri, Ti, !0, Ti.length, Li, "", Ni.finish), Ti.pendingcb++, Ti.lastBufferedRequest = null, Ni.next ? (Ti.corkedRequestsFree = Ni.next, Ni.next = null) : Ti.corkedRequestsFree = new t(Ti), Ti.bufferedRequestCount = 0;
    } else {
      for (; Ci; ) {
        var Ki = Ci.chunk, ts = Ci.encoding, qi = Ci.callback, Hi = Ti.objectMode ? 1 : Ki.length;
        if (Oi(Ri, Ti, !1, Hi, Ki, ts, qi), Ci = Ci.next, Ti.bufferedRequestCount--, Ti.writing)
          break;
      }
      Ci === null && (Ti.lastBufferedRequest = null);
    }
    Ti.bufferedRequest = Ci, Ti.bufferProcessing = !1;
  }
  mi.prototype._write = function(Ri, Ti, Ci) {
    Ci(new Error("_write() is not implemented"));
  }, mi.prototype._writev = null, mi.prototype.end = function(Ri, Ti, Ci) {
    var Ii = this._writableState;
    typeof Ri == "function" ? (Ci = Ri, Ri = null, Ti = null) : typeof Ti == "function" && (Ci = Ti, Ti = null), Ri != null && this.write(Ri, Ti), Ii.corked && (Ii.corked = 1, this.uncork()), Ii.ending || wi(this, Ii, Ci);
  };
  function zi(Ri) {
    return Ri.ending && Ri.length === 0 && Ri.bufferedRequest === null && !Ri.finished && !Ri.writing;
  }
  function xi(Ri, Ti) {
    Ri._final(function(Ci) {
      Ti.pendingcb--, Ci && Ri.emit("error", Ci), Ti.prefinished = !0, Ri.emit("prefinish"), vi(Ri, Ti);
    });
  }
  function $i(Ri, Ti) {
    !Ti.prefinished && !Ti.finalCalled && (typeof Ri._final == "function" ? (Ti.pendingcb++, Ti.finalCalled = !0, Ae.nextTick(xi, Ri, Ti)) : (Ti.prefinished = !0, Ri.emit("prefinish")));
  }
  function vi(Ri, Ti) {
    var Ci = zi(Ti);
    return Ci && ($i(Ri, Ti), Ti.pendingcb === 0 && (Ti.finished = !0, Ri.emit("finish"))), Ci;
  }
  function wi(Ri, Ti, Ci) {
    Ti.ending = !0, vi(Ri, Ti), Ci && (Ti.finished ? Ae.nextTick(Ci) : Ri.once("finish", Ci)), Ti.ended = !0, Ri.writable = !1;
  }
  function Ai(Ri, Ti, Ci) {
    var Ii = Ri.entry;
    for (Ri.entry = null; Ii; ) {
      var Li = Ii.callback;
      Ti.pendingcb--, Li(Ci), Ii = Ii.next;
    }
    Ti.corkedRequestsFree.next = Ri;
  }
  return Object.defineProperty(mi.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Ri) {
      this._writableState && (this._writableState.destroyed = Ri);
    }
  }), mi.prototype.destroy = vn.destroy, mi.prototype._undestroy = vn.undestroy, mi.prototype._destroy = function(Ri, Ti) {
    this.end(), Ti(Ri);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var Ae = requireProcessNextickArgs(), t = Object.keys || function(vn) {
    var En = [];
    for (var fi in vn)
      En.push(fi);
    return En;
  };
  _stream_duplex = je;
  var Ie = Object.create(requireUtil());
  Ie.inherits = requireInherits_browser();
  var Be = require_stream_readable(), Pe = require_stream_writable();
  Ie.inherits(je, Be);
  for (var Te = t(Pe.prototype), Me = 0; Me < Te.length; Me++) {
    var Ue = Te[Me];
    je.prototype[Ue] || (je.prototype[Ue] = Pe.prototype[Ue]);
  }
  function je(vn) {
    if (!(this instanceof je)) return new je(vn);
    Be.call(this, vn), Pe.call(this, vn), vn && vn.readable === !1 && (this.readable = !1), vn && vn.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, vn && vn.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", fn);
  }
  Object.defineProperty(je.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function fn() {
    this.allowHalfOpen || this._writableState.ended || Ae.nextTick(Ve, this);
  }
  function Ve(vn) {
    vn.end();
  }
  return Object.defineProperty(je.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(vn) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = vn, this._writableState.destroyed = vn);
    }
  }), je.prototype._destroy = function(vn, En) {
    this.push(null), this.end(), Ae.nextTick(En, vn);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var Ae = requireProcessNextickArgs();
  _stream_readable = Si;
  var t = requireIsarray(), Ie;
  Si.ReadableState = Ei, eventsExports.EventEmitter;
  var Be = function(qi, Hi) {
    return qi.listeners(Hi).length;
  }, Pe = requireStreamBrowser(), Te = requireSafeBuffer().Buffer, Me = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function Ue(qi) {
    return Te.from(qi);
  }
  function je(qi) {
    return Te.isBuffer(qi) || qi instanceof Me;
  }
  var fn = Object.create(requireUtil());
  fn.inherits = requireInherits_browser();
  var Ve = util$2, vn = void 0;
  Ve && Ve.debuglog ? vn = Ve.debuglog("stream") : vn = function() {
  };
  var En = requireBufferList(), fi = requireDestroy(), bi;
  fn.inherits(Si, Pe);
  var mi = ["error", "close", "destroy", "pause", "resume"];
  function _i(qi, Hi, Xi) {
    if (typeof qi.prependListener == "function") return qi.prependListener(Hi, Xi);
    !qi._events || !qi._events[Hi] ? qi.on(Hi, Xi) : t(qi._events[Hi]) ? qi._events[Hi].unshift(Xi) : qi._events[Hi] = [Xi, qi._events[Hi]];
  }
  function Ei(qi, Hi) {
    Ie = Ie || require_stream_duplex(), qi = qi || {};
    var Xi = Hi instanceof Ie;
    this.objectMode = !!qi.objectMode, Xi && (this.objectMode = this.objectMode || !!qi.readableObjectMode);
    var ki = qi.highWaterMark, Wi = qi.readableHighWaterMark, Yi = this.objectMode ? 16 : 16 * 1024;
    ki || ki === 0 ? this.highWaterMark = ki : Xi && (Wi || Wi === 0) ? this.highWaterMark = Wi : this.highWaterMark = Yi, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new En(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = qi.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, qi.encoding && (bi || (bi = string_decoder.StringDecoder), this.decoder = new bi(qi.encoding), this.encoding = qi.encoding);
  }
  function Si(qi) {
    if (Ie = Ie || require_stream_duplex(), !(this instanceof Si)) return new Si(qi);
    this._readableState = new Ei(qi, this), this.readable = !0, qi && (typeof qi.read == "function" && (this._read = qi.read), typeof qi.destroy == "function" && (this._destroy = qi.destroy)), Pe.call(this);
  }
  Object.defineProperty(Si.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(qi) {
      this._readableState && (this._readableState.destroyed = qi);
    }
  }), Si.prototype.destroy = fi.destroy, Si.prototype._undestroy = fi.undestroy, Si.prototype._destroy = function(qi, Hi) {
    this.push(null), Hi(qi);
  }, Si.prototype.push = function(qi, Hi) {
    var Xi = this._readableState, ki;
    return Xi.objectMode ? ki = !0 : typeof qi == "string" && (Hi = Hi || Xi.defaultEncoding, Hi !== Xi.encoding && (qi = Te.from(qi, Hi), Hi = ""), ki = !0), Mi(this, qi, Hi, !1, ki);
  }, Si.prototype.unshift = function(qi) {
    return Mi(this, qi, null, !0, !1);
  };
  function Mi(qi, Hi, Xi, ki, Wi) {
    var Yi = qi._readableState;
    if (Hi === null)
      Yi.reading = !1, Zi(qi, Yi);
    else {
      var Qi;
      Wi || (Qi = Fi(Yi, Hi)), Qi ? qi.emit("error", Qi) : Yi.objectMode || Hi && Hi.length > 0 ? (typeof Hi != "string" && !Yi.objectMode && Object.getPrototypeOf(Hi) !== Te.prototype && (Hi = Ue(Hi)), ki ? Yi.endEmitted ? qi.emit("error", new Error("stream.unshift() after end event")) : Oi(qi, Yi, Hi, !0) : Yi.ended ? qi.emit("error", new Error("stream.push() after EOF")) : (Yi.reading = !1, Yi.decoder && !Xi ? (Hi = Yi.decoder.write(Hi), Yi.objectMode || Hi.length !== 0 ? Oi(qi, Yi, Hi, !1) : $i(qi, Yi)) : Oi(qi, Yi, Hi, !1))) : ki || (Yi.reading = !1);
    }
    return Ui(Yi);
  }
  function Oi(qi, Hi, Xi, ki) {
    Hi.flowing && Hi.length === 0 && !Hi.sync ? (qi.emit("data", Xi), qi.read(0)) : (Hi.length += Hi.objectMode ? 1 : Xi.length, ki ? Hi.buffer.unshift(Xi) : Hi.buffer.push(Xi), Hi.needReadable && zi(qi)), $i(qi, Hi);
  }
  function Fi(qi, Hi) {
    var Xi;
    return !je(Hi) && typeof Hi != "string" && Hi !== void 0 && !qi.objectMode && (Xi = new TypeError("Invalid non-string/buffer chunk")), Xi;
  }
  function Ui(qi) {
    return !qi.ended && (qi.needReadable || qi.length < qi.highWaterMark || qi.length === 0);
  }
  Si.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Si.prototype.setEncoding = function(qi) {
    return bi || (bi = string_decoder.StringDecoder), this._readableState.decoder = new bi(qi), this._readableState.encoding = qi, this;
  };
  var Pi = 8388608;
  function Bi(qi) {
    return qi >= Pi ? qi = Pi : (qi--, qi |= qi >>> 1, qi |= qi >>> 2, qi |= qi >>> 4, qi |= qi >>> 8, qi |= qi >>> 16, qi++), qi;
  }
  function ji(qi, Hi) {
    return qi <= 0 || Hi.length === 0 && Hi.ended ? 0 : Hi.objectMode ? 1 : qi !== qi ? Hi.flowing && Hi.length ? Hi.buffer.head.data.length : Hi.length : (qi > Hi.highWaterMark && (Hi.highWaterMark = Bi(qi)), qi <= Hi.length ? qi : Hi.ended ? Hi.length : (Hi.needReadable = !0, 0));
  }
  Si.prototype.read = function(qi) {
    vn("read", qi), qi = parseInt(qi, 10);
    var Hi = this._readableState, Xi = qi;
    if (qi !== 0 && (Hi.emittedReadable = !1), qi === 0 && Hi.needReadable && (Hi.length >= Hi.highWaterMark || Hi.ended))
      return vn("read: emitReadable", Hi.length, Hi.ended), Hi.length === 0 && Hi.ended ? is(this) : zi(this), null;
    if (qi = ji(qi, Hi), qi === 0 && Hi.ended)
      return Hi.length === 0 && is(this), null;
    var ki = Hi.needReadable;
    vn("need readable", ki), (Hi.length === 0 || Hi.length - qi < Hi.highWaterMark) && (ki = !0, vn("length less than watermark", ki)), Hi.ended || Hi.reading ? (ki = !1, vn("reading or ended", ki)) : ki && (vn("do read"), Hi.reading = !0, Hi.sync = !0, Hi.length === 0 && (Hi.needReadable = !0), this._read(Hi.highWaterMark), Hi.sync = !1, Hi.reading || (qi = ji(Xi, Hi)));
    var Wi;
    return qi > 0 ? Wi = Ii(qi, Hi) : Wi = null, Wi === null ? (Hi.needReadable = !0, qi = 0) : Hi.length -= qi, Hi.length === 0 && (Hi.ended || (Hi.needReadable = !0), Xi !== qi && Hi.ended && is(this)), Wi !== null && this.emit("data", Wi), Wi;
  };
  function Zi(qi, Hi) {
    if (!Hi.ended) {
      if (Hi.decoder) {
        var Xi = Hi.decoder.end();
        Xi && Xi.length && (Hi.buffer.push(Xi), Hi.length += Hi.objectMode ? 1 : Xi.length);
      }
      Hi.ended = !0, zi(qi);
    }
  }
  function zi(qi) {
    var Hi = qi._readableState;
    Hi.needReadable = !1, Hi.emittedReadable || (vn("emitReadable", Hi.flowing), Hi.emittedReadable = !0, Hi.sync ? Ae.nextTick(xi, qi) : xi(qi));
  }
  function xi(qi) {
    vn("emit readable"), qi.emit("readable"), Ci(qi);
  }
  function $i(qi, Hi) {
    Hi.readingMore || (Hi.readingMore = !0, Ae.nextTick(vi, qi, Hi));
  }
  function vi(qi, Hi) {
    for (var Xi = Hi.length; !Hi.reading && !Hi.flowing && !Hi.ended && Hi.length < Hi.highWaterMark && (vn("maybeReadMore read 0"), qi.read(0), Xi !== Hi.length); )
      Xi = Hi.length;
    Hi.readingMore = !1;
  }
  Si.prototype._read = function(qi) {
    this.emit("error", new Error("_read() is not implemented"));
  }, Si.prototype.pipe = function(qi, Hi) {
    var Xi = this, ki = this._readableState;
    switch (ki.pipesCount) {
      case 0:
        ki.pipes = qi;
        break;
      case 1:
        ki.pipes = [ki.pipes, qi];
        break;
      default:
        ki.pipes.push(qi);
        break;
    }
    ki.pipesCount += 1, vn("pipe count=%d opts=%j", ki.pipesCount, Hi);
    var Wi = (!Hi || Hi.end !== !1) && qi !== process$1$1.stdout && qi !== process$1$1.stderr, Yi = Wi ? ns : Ro;
    ki.endEmitted ? Ae.nextTick(Yi) : Xi.once("end", Yi), qi.on("unpipe", Qi);
    function Qi($o, Io) {
      vn("onunpipe"), $o === Xi && Io && Io.hasUnpiped === !1 && (Io.hasUnpiped = !0, Ds());
    }
    function ns() {
      vn("onend"), qi.end();
    }
    var us = wi(Xi);
    qi.on("drain", us);
    var ps = !1;
    function Ds() {
      vn("cleanup"), qi.removeListener("close", _o), qi.removeListener("finish", vo), qi.removeListener("drain", us), qi.removeListener("error", So), qi.removeListener("unpipe", Qi), Xi.removeListener("end", ns), Xi.removeListener("end", Ro), Xi.removeListener("data", hs), ps = !0, ki.awaitDrain && (!qi._writableState || qi._writableState.needDrain) && us();
    }
    var Eo = !1;
    Xi.on("data", hs);
    function hs($o) {
      vn("ondata"), Eo = !1;
      var Io = qi.write($o);
      Io === !1 && !Eo && ((ki.pipesCount === 1 && ki.pipes === qi || ki.pipesCount > 1 && ts(ki.pipes, qi) !== -1) && !ps && (vn("false write response, pause", ki.awaitDrain), ki.awaitDrain++, Eo = !0), Xi.pause());
    }
    function So($o) {
      vn("onerror", $o), Ro(), qi.removeListener("error", So), Be(qi, "error") === 0 && qi.emit("error", $o);
    }
    _i(qi, "error", So);
    function _o() {
      qi.removeListener("finish", vo), Ro();
    }
    qi.once("close", _o);
    function vo() {
      vn("onfinish"), qi.removeListener("close", _o), Ro();
    }
    qi.once("finish", vo);
    function Ro() {
      vn("unpipe"), Xi.unpipe(qi);
    }
    return qi.emit("pipe", Xi), ki.flowing || (vn("pipe resume"), Xi.resume()), qi;
  };
  function wi(qi) {
    return function() {
      var Hi = qi._readableState;
      vn("pipeOnDrain", Hi.awaitDrain), Hi.awaitDrain && Hi.awaitDrain--, Hi.awaitDrain === 0 && Be(qi, "data") && (Hi.flowing = !0, Ci(qi));
    };
  }
  Si.prototype.unpipe = function(qi) {
    var Hi = this._readableState, Xi = { hasUnpiped: !1 };
    if (Hi.pipesCount === 0) return this;
    if (Hi.pipesCount === 1)
      return qi && qi !== Hi.pipes ? this : (qi || (qi = Hi.pipes), Hi.pipes = null, Hi.pipesCount = 0, Hi.flowing = !1, qi && qi.emit("unpipe", this, Xi), this);
    if (!qi) {
      var ki = Hi.pipes, Wi = Hi.pipesCount;
      Hi.pipes = null, Hi.pipesCount = 0, Hi.flowing = !1;
      for (var Yi = 0; Yi < Wi; Yi++)
        ki[Yi].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var Qi = ts(Hi.pipes, qi);
    return Qi === -1 ? this : (Hi.pipes.splice(Qi, 1), Hi.pipesCount -= 1, Hi.pipesCount === 1 && (Hi.pipes = Hi.pipes[0]), qi.emit("unpipe", this, Xi), this);
  }, Si.prototype.on = function(qi, Hi) {
    var Xi = Pe.prototype.on.call(this, qi, Hi);
    if (qi === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (qi === "readable") {
      var ki = this._readableState;
      !ki.endEmitted && !ki.readableListening && (ki.readableListening = ki.needReadable = !0, ki.emittedReadable = !1, ki.reading ? ki.length && zi(this) : Ae.nextTick(Ai, this));
    }
    return Xi;
  }, Si.prototype.addListener = Si.prototype.on;
  function Ai(qi) {
    vn("readable nexttick read 0"), qi.read(0);
  }
  Si.prototype.resume = function() {
    var qi = this._readableState;
    return qi.flowing || (vn("resume"), qi.flowing = !0, Ri(this, qi)), this;
  };
  function Ri(qi, Hi) {
    Hi.resumeScheduled || (Hi.resumeScheduled = !0, Ae.nextTick(Ti, qi, Hi));
  }
  function Ti(qi, Hi) {
    Hi.reading || (vn("resume read 0"), qi.read(0)), Hi.resumeScheduled = !1, Hi.awaitDrain = 0, qi.emit("resume"), Ci(qi), Hi.flowing && !Hi.reading && qi.read(0);
  }
  Si.prototype.pause = function() {
    return vn("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (vn("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function Ci(qi) {
    var Hi = qi._readableState;
    for (vn("flow", Hi.flowing); Hi.flowing && qi.read() !== null; )
      ;
  }
  Si.prototype.wrap = function(qi) {
    var Hi = this, Xi = this._readableState, ki = !1;
    qi.on("end", function() {
      if (vn("wrapped end"), Xi.decoder && !Xi.ended) {
        var Qi = Xi.decoder.end();
        Qi && Qi.length && Hi.push(Qi);
      }
      Hi.push(null);
    }), qi.on("data", function(Qi) {
      if (vn("wrapped data"), Xi.decoder && (Qi = Xi.decoder.write(Qi)), !(Xi.objectMode && Qi == null) && !(!Xi.objectMode && (!Qi || !Qi.length))) {
        var ns = Hi.push(Qi);
        ns || (ki = !0, qi.pause());
      }
    });
    for (var Wi in qi)
      this[Wi] === void 0 && typeof qi[Wi] == "function" && (this[Wi] = /* @__PURE__ */ function(Qi) {
        return function() {
          return qi[Qi].apply(qi, arguments);
        };
      }(Wi));
    for (var Yi = 0; Yi < mi.length; Yi++)
      qi.on(mi[Yi], this.emit.bind(this, mi[Yi]));
    return this._read = function(Qi) {
      vn("wrapped _read", Qi), ki && (ki = !1, qi.resume());
    }, this;
  }, Object.defineProperty(Si.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Si._fromList = Ii;
  function Ii(qi, Hi) {
    if (Hi.length === 0) return null;
    var Xi;
    return Hi.objectMode ? Xi = Hi.buffer.shift() : !qi || qi >= Hi.length ? (Hi.decoder ? Xi = Hi.buffer.join("") : Hi.buffer.length === 1 ? Xi = Hi.buffer.head.data : Xi = Hi.buffer.concat(Hi.length), Hi.buffer.clear()) : Xi = Li(qi, Hi.buffer, Hi.decoder), Xi;
  }
  function Li(qi, Hi, Xi) {
    var ki;
    return qi < Hi.head.data.length ? (ki = Hi.head.data.slice(0, qi), Hi.head.data = Hi.head.data.slice(qi)) : qi === Hi.head.data.length ? ki = Hi.shift() : ki = Xi ? Ni(qi, Hi) : Vi(qi, Hi), ki;
  }
  function Ni(qi, Hi) {
    var Xi = Hi.head, ki = 1, Wi = Xi.data;
    for (qi -= Wi.length; Xi = Xi.next; ) {
      var Yi = Xi.data, Qi = qi > Yi.length ? Yi.length : qi;
      if (Qi === Yi.length ? Wi += Yi : Wi += Yi.slice(0, qi), qi -= Qi, qi === 0) {
        Qi === Yi.length ? (++ki, Xi.next ? Hi.head = Xi.next : Hi.head = Hi.tail = null) : (Hi.head = Xi, Xi.data = Yi.slice(Qi));
        break;
      }
      ++ki;
    }
    return Hi.length -= ki, Wi;
  }
  function Vi(qi, Hi) {
    var Xi = Te.allocUnsafe(qi), ki = Hi.head, Wi = 1;
    for (ki.data.copy(Xi), qi -= ki.data.length; ki = ki.next; ) {
      var Yi = ki.data, Qi = qi > Yi.length ? Yi.length : qi;
      if (Yi.copy(Xi, Xi.length - qi, 0, Qi), qi -= Qi, qi === 0) {
        Qi === Yi.length ? (++Wi, ki.next ? Hi.head = ki.next : Hi.head = Hi.tail = null) : (Hi.head = ki, ki.data = Yi.slice(Qi));
        break;
      }
      ++Wi;
    }
    return Hi.length -= Wi, Xi;
  }
  function is(qi) {
    var Hi = qi._readableState;
    if (Hi.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    Hi.endEmitted || (Hi.ended = !0, Ae.nextTick(Ki, Hi, qi));
  }
  function Ki(qi, Hi) {
    !qi.endEmitted && qi.length === 0 && (qi.endEmitted = !0, Hi.readable = !1, Hi.emit("end"));
  }
  function ts(qi, Hi) {
    for (var Xi = 0, ki = qi.length; Xi < ki; Xi++)
      if (qi[Xi] === Hi) return Xi;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1, _stream_transform = Be;
  var Ae = require_stream_duplex(), t = Object.create(requireUtil());
  t.inherits = requireInherits_browser(), t.inherits(Be, Ae);
  function Ie(Me, Ue) {
    var je = this._transformState;
    je.transforming = !1;
    var fn = je.writecb;
    if (!fn)
      return this.emit("error", new Error("write callback called multiple times"));
    je.writechunk = null, je.writecb = null, Ue != null && this.push(Ue), fn(Me);
    var Ve = this._readableState;
    Ve.reading = !1, (Ve.needReadable || Ve.length < Ve.highWaterMark) && this._read(Ve.highWaterMark);
  }
  function Be(Me) {
    if (!(this instanceof Be)) return new Be(Me);
    Ae.call(this, Me), this._transformState = {
      afterTransform: Ie.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, Me && (typeof Me.transform == "function" && (this._transform = Me.transform), typeof Me.flush == "function" && (this._flush = Me.flush)), this.on("prefinish", Pe);
  }
  function Pe() {
    var Me = this;
    typeof this._flush == "function" ? this._flush(function(Ue, je) {
      Te(Me, Ue, je);
    }) : Te(this, null, null);
  }
  Be.prototype.push = function(Me, Ue) {
    return this._transformState.needTransform = !1, Ae.prototype.push.call(this, Me, Ue);
  }, Be.prototype._transform = function(Me, Ue, je) {
    throw new Error("_transform() is not implemented");
  }, Be.prototype._write = function(Me, Ue, je) {
    var fn = this._transformState;
    if (fn.writecb = je, fn.writechunk = Me, fn.writeencoding = Ue, !fn.transforming) {
      var Ve = this._readableState;
      (fn.needTransform || Ve.needReadable || Ve.length < Ve.highWaterMark) && this._read(Ve.highWaterMark);
    }
  }, Be.prototype._read = function(Me) {
    var Ue = this._transformState;
    Ue.writechunk !== null && Ue.writecb && !Ue.transforming ? (Ue.transforming = !0, this._transform(Ue.writechunk, Ue.writeencoding, Ue.afterTransform)) : Ue.needTransform = !0;
  }, Be.prototype._destroy = function(Me, Ue) {
    var je = this;
    Ae.prototype._destroy.call(this, Me, function(fn) {
      Ue(fn), je.emit("close");
    });
  };
  function Te(Me, Ue, je) {
    if (Ue) return Me.emit("error", Ue);
    if (je != null && Me.push(je), Me._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (Me._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return Me.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1, _stream_passthrough = Ie;
  var Ae = require_stream_transform(), t = Object.create(requireUtil());
  t.inherits = requireInherits_browser(), t.inherits(Ie, Ae);
  function Ie(Be) {
    if (!(this instanceof Ie)) return new Ie(Be);
    Ae.call(this, Be);
  }
  return Ie.prototype._transform = function(Be, Pe, Te) {
    Te(null, Be);
  }, _stream_passthrough;
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
  return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1, function(Ae, t) {
    t = Ae.exports = require_stream_readable(), t.Stream = t, t.Readable = t, t.Writable = require_stream_writable(), t.Duplex = require_stream_duplex(), t.Transform = require_stream_transform(), t.PassThrough = require_stream_passthrough();
  }(readableBrowser, readableBrowser.exports)), readableBrowser.exports;
}
var sign = { exports: {} }, browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa) return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var Ae = bnExports, t = requireBrowser$c(), Ie = requireSafeBuffer$1().Buffer;
  function Be(Me) {
    var Ue = Me.modulus.byteLength(), je;
    do
      je = new Ae(t(Ue));
    while (je.cmp(Me.modulus) >= 0 || !je.umod(Me.prime1) || !je.umod(Me.prime2));
    return je;
  }
  function Pe(Me) {
    var Ue = Be(Me), je = Ue.toRed(Ae.mont(Me.modulus)).redPow(new Ae(Me.publicExponent)).fromRed();
    return { blinder: je, unblinder: Ue.invm(Me.modulus) };
  }
  function Te(Me, Ue) {
    var je = Pe(Ue), fn = Ue.modulus.byteLength(), Ve = new Ae(Me).mul(je.blinder).umod(Ue.modulus), vn = Ve.toRed(Ae.mont(Ue.prime1)), En = Ve.toRed(Ae.mont(Ue.prime2)), fi = Ue.coefficient, bi = Ue.prime1, mi = Ue.prime2, _i = vn.redPow(Ue.exponent1).fromRed(), Ei = En.redPow(Ue.exponent2).fromRed(), Si = _i.isub(Ei).imul(fi).umod(bi).imul(mi);
    return Ei.iadd(Si).imul(je.unblinder).umod(Ue.modulus).toArrayLike(Ie, "be", fn);
  }
  return Te.getr = Be, browserifyRsa = Te, browserifyRsa;
}
var asn1$1 = {}, asn1 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(Ae, t) {
      if (Ae.indexOf) return Ae.indexOf(t);
      for (var Ie = 0; Ie < Ae.length; Ie++)
        if (Ae[Ie] === t) return Ie;
      return -1;
    }, Object_keys = function(Ae) {
      if (Object.keys) return Object.keys(Ae);
      var t = [];
      for (var Ie in Ae) t.push(Ie);
      return t;
    }, forEach = function(Ae, t) {
      if (Ae.forEach) return Ae.forEach(t);
      for (var Ie = 0; Ie < Ae.length; Ie++)
        t(Ae[Ie], Ie, Ae);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(Ae, t, Ie) {
          Object.defineProperty(Ae, t, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: Ie
          });
        };
      } catch {
        return function(t, Ie, Be) {
          t[Ie] = Be;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(t) {
      if (!(this instanceof Script)) return new Script(t);
      this.code = t;
    };
    Script.prototype.runInContext = function(Ae) {
      if (!(Ae instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var t = document.createElement("iframe");
      t.style || (t.style = {}), t.style.display = "none", document.body.appendChild(t);
      var Ie = t.contentWindow, Be = Ie.eval, Pe = Ie.execScript;
      !Be && Pe && (Pe.call(Ie, "null"), Be = Ie.eval), forEach(Object_keys(Ae), function(Ue) {
        Ie[Ue] = Ae[Ue];
      }), forEach(globals, function(Ue) {
        Ae[Ue] && (Ie[Ue] = Ae[Ue]);
      });
      var Te = Object_keys(Ie), Me = Be.call(Ie, this.code);
      return forEach(Object_keys(Ie), function(Ue) {
        (Ue in Ae || indexOf(Te, Ue) === -1) && (Ae[Ue] = Ie[Ue]);
      }), forEach(globals, function(Ue) {
        Ue in Ae || defineProp(Ae, Ue, Ie[Ue]);
      }), document.body.removeChild(t), Me;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(Ae) {
      var t = Script.createContext(Ae), Ie = this.runInContext(t);
      return Ae && forEach(Object_keys(t), function(Be) {
        Ae[Be] = t[Be];
      }), Ie;
    }, forEach(Object_keys(Script.prototype), function(Ae) {
      exports[Ae] = Script[Ae] = function(t) {
        var Ie = Script(t);
        return Ie[Ae].apply(Ie, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(Ae) {
      return Ae instanceof Context;
    }, exports.createScript = function(Ae) {
      return exports.Script(Ae);
    }, exports.createContext = Script.createContext = function(Ae) {
      var t = new Context();
      return typeof Ae == "object" && forEach(Object_keys(Ae), function(Ie) {
        t[Ie] = Ae[Ie];
      }), t;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(Ae) {
    var t = requireAsn1$1(), Ie = requireInherits_browser(), Be = Ae;
    Be.define = function(Me, Ue) {
      return new Pe(Me, Ue);
    };
    function Pe(Te, Me) {
      this.name = Te, this.body = Me, this.decoders = {}, this.encoders = {};
    }
    Pe.prototype._createNamed = function(Me) {
      var Ue;
      try {
        Ue = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        Ue = function(fn) {
          this._initNamed(fn);
        };
      }
      return Ie(Ue, Me), Ue.prototype._initNamed = function(fn) {
        Me.call(this, fn);
      }, new Ue(this);
    }, Pe.prototype._getDecoder = function(Me) {
      return Me = Me || "der", this.decoders.hasOwnProperty(Me) || (this.decoders[Me] = this._createNamed(t.decoders[Me])), this.decoders[Me];
    }, Pe.prototype.decode = function(Me, Ue, je) {
      return this._getDecoder(Ue).decode(Me, je);
    }, Pe.prototype._getEncoder = function(Me) {
      return Me = Me || "der", this.encoders.hasOwnProperty(Me) || (this.encoders[Me] = this._createNamed(t.encoders[Me])), this.encoders[Me];
    }, Pe.prototype.encode = function(Me, Ue, je) {
      return this._getEncoder(Ue).encode(Me, je);
    };
  }(api)), api;
}
var base$3 = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter) return reporter;
  hasRequiredReporter = 1;
  var Ae = requireInherits_browser();
  function t(Be) {
    this._reporterState = {
      obj: null,
      path: [],
      options: Be || {},
      errors: []
    };
  }
  reporter.Reporter = t, t.prototype.isError = function(Pe) {
    return Pe instanceof Ie;
  }, t.prototype.save = function() {
    var Pe = this._reporterState;
    return { obj: Pe.obj, pathLen: Pe.path.length };
  }, t.prototype.restore = function(Pe) {
    var Te = this._reporterState;
    Te.obj = Pe.obj, Te.path = Te.path.slice(0, Pe.pathLen);
  }, t.prototype.enterKey = function(Pe) {
    return this._reporterState.path.push(Pe);
  }, t.prototype.exitKey = function(Pe) {
    var Te = this._reporterState;
    Te.path = Te.path.slice(0, Pe - 1);
  }, t.prototype.leaveKey = function(Pe, Te, Me) {
    var Ue = this._reporterState;
    this.exitKey(Pe), Ue.obj !== null && (Ue.obj[Te] = Me);
  }, t.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, t.prototype.enterObject = function() {
    var Pe = this._reporterState, Te = Pe.obj;
    return Pe.obj = {}, Te;
  }, t.prototype.leaveObject = function(Pe) {
    var Te = this._reporterState, Me = Te.obj;
    return Te.obj = Pe, Me;
  }, t.prototype.error = function(Pe) {
    var Te, Me = this._reporterState, Ue = Pe instanceof Ie;
    if (Ue ? Te = Pe : Te = new Ie(Me.path.map(function(je) {
      return "[" + JSON.stringify(je) + "]";
    }).join(""), Pe.message || Pe, Pe.stack), !Me.options.partial)
      throw Te;
    return Ue || Me.errors.push(Te), Te;
  }, t.prototype.wrapResult = function(Pe) {
    var Te = this._reporterState;
    return Te.options.partial ? {
      result: this.isError(Pe) ? null : Pe,
      errors: Te.errors
    } : Pe;
  };
  function Ie(Be, Pe) {
    this.path = Be, this.rethrow(Pe);
  }
  return Ae(Ie, Error), Ie.prototype.rethrow = function(Pe) {
    if (this.message = Pe + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, Ie), !this.stack)
      try {
        throw new Error(this.message);
      } catch (Te) {
        this.stack = Te.stack;
      }
    return this;
  }, reporter;
}
var buffer$1 = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer$1;
  hasRequiredBuffer = 1;
  var Ae = requireInherits_browser(), t = requireBase$1().Reporter, Ie = require$$0$4.Buffer;
  function Be(Te, Me) {
    if (t.call(this, Me), !Ie.isBuffer(Te)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = Te, this.offset = 0, this.length = Te.length;
  }
  Ae(Be, t), buffer$1.DecoderBuffer = Be, Be.prototype.save = function() {
    return { offset: this.offset, reporter: t.prototype.save.call(this) };
  }, Be.prototype.restore = function(Me) {
    var Ue = new Be(this.base);
    return Ue.offset = Me.offset, Ue.length = this.offset, this.offset = Me.offset, t.prototype.restore.call(this, Me.reporter), Ue;
  }, Be.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, Be.prototype.readUInt8 = function(Me) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(Me || "DecoderBuffer overrun");
  }, Be.prototype.skip = function(Me, Ue) {
    if (!(this.offset + Me <= this.length))
      return this.error(Ue || "DecoderBuffer overrun");
    var je = new Be(this.base);
    return je._reporterState = this._reporterState, je.offset = this.offset, je.length = this.offset + Me, this.offset += Me, je;
  }, Be.prototype.raw = function(Me) {
    return this.base.slice(Me ? Me.offset : this.offset, this.length);
  };
  function Pe(Te, Me) {
    if (Array.isArray(Te))
      this.length = 0, this.value = Te.map(function(Ue) {
        return Ue instanceof Pe || (Ue = new Pe(Ue, Me)), this.length += Ue.length, Ue;
      }, this);
    else if (typeof Te == "number") {
      if (!(0 <= Te && Te <= 255))
        return Me.error("non-byte EncoderBuffer value");
      this.value = Te, this.length = 1;
    } else if (typeof Te == "string")
      this.value = Te, this.length = Ie.byteLength(Te);
    else if (Ie.isBuffer(Te))
      this.value = Te, this.length = Te.length;
    else
      return Me.error("Unsupported type: " + typeof Te);
  }
  return buffer$1.EncoderBuffer = Pe, Pe.prototype.join = function(Me, Ue) {
    return Me || (Me = new Ie(this.length)), Ue || (Ue = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(je) {
      je.join(Me, Ue), Ue += je.length;
    }) : (typeof this.value == "number" ? Me[Ue] = this.value : typeof this.value == "string" ? Me.write(this.value, Ue) : Ie.isBuffer(this.value) && this.value.copy(Me, Ue), Ue += this.length)), Me;
  }, buffer$1;
}
var node$1, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node$1;
  hasRequiredNode = 1;
  var Ae = requireBase$1().Reporter, t = requireBase$1().EncoderBuffer, Ie = requireBase$1().DecoderBuffer, Be = minimalisticAssert$1, Pe = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], Te = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(Pe), Me = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function Ue(fn, Ve) {
    var vn = {};
    this._baseState = vn, vn.enc = fn, vn.parent = Ve || null, vn.children = null, vn.tag = null, vn.args = null, vn.reverseArgs = null, vn.choice = null, vn.optional = !1, vn.any = !1, vn.obj = !1, vn.use = null, vn.useDecoder = null, vn.key = null, vn.default = null, vn.explicit = null, vn.implicit = null, vn.contains = null, vn.parent || (vn.children = [], this._wrap());
  }
  node$1 = Ue;
  var je = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return Ue.prototype.clone = function() {
    var Ve = this._baseState, vn = {};
    je.forEach(function(fi) {
      vn[fi] = Ve[fi];
    });
    var En = new this.constructor(vn.parent);
    return En._baseState = vn, En;
  }, Ue.prototype._wrap = function() {
    var Ve = this._baseState;
    Te.forEach(function(vn) {
      this[vn] = function() {
        var fi = new this.constructor(this);
        return Ve.children.push(fi), fi[vn].apply(fi, arguments);
      };
    }, this);
  }, Ue.prototype._init = function(Ve) {
    var vn = this._baseState;
    Be(vn.parent === null), Ve.call(this), vn.children = vn.children.filter(function(En) {
      return En._baseState.parent === this;
    }, this), Be.equal(vn.children.length, 1, "Root node can have only one child");
  }, Ue.prototype._useArgs = function(Ve) {
    var vn = this._baseState, En = Ve.filter(function(fi) {
      return fi instanceof this.constructor;
    }, this);
    Ve = Ve.filter(function(fi) {
      return !(fi instanceof this.constructor);
    }, this), En.length !== 0 && (Be(vn.children === null), vn.children = En, En.forEach(function(fi) {
      fi._baseState.parent = this;
    }, this)), Ve.length !== 0 && (Be(vn.args === null), vn.args = Ve, vn.reverseArgs = Ve.map(function(fi) {
      if (typeof fi != "object" || fi.constructor !== Object)
        return fi;
      var bi = {};
      return Object.keys(fi).forEach(function(mi) {
        mi == (mi | 0) && (mi |= 0);
        var _i = fi[mi];
        bi[_i] = mi;
      }), bi;
    }));
  }, Me.forEach(function(fn) {
    Ue.prototype[fn] = function() {
      var vn = this._baseState;
      throw new Error(fn + " not implemented for encoding: " + vn.enc);
    };
  }), Pe.forEach(function(fn) {
    Ue.prototype[fn] = function() {
      var vn = this._baseState, En = Array.prototype.slice.call(arguments);
      return Be(vn.tag === null), vn.tag = fn, this._useArgs(En), this;
    };
  }), Ue.prototype.use = function(Ve) {
    Be(Ve);
    var vn = this._baseState;
    return Be(vn.use === null), vn.use = Ve, this;
  }, Ue.prototype.optional = function() {
    var Ve = this._baseState;
    return Ve.optional = !0, this;
  }, Ue.prototype.def = function(Ve) {
    var vn = this._baseState;
    return Be(vn.default === null), vn.default = Ve, vn.optional = !0, this;
  }, Ue.prototype.explicit = function(Ve) {
    var vn = this._baseState;
    return Be(vn.explicit === null && vn.implicit === null), vn.explicit = Ve, this;
  }, Ue.prototype.implicit = function(Ve) {
    var vn = this._baseState;
    return Be(vn.explicit === null && vn.implicit === null), vn.implicit = Ve, this;
  }, Ue.prototype.obj = function() {
    var Ve = this._baseState, vn = Array.prototype.slice.call(arguments);
    return Ve.obj = !0, vn.length !== 0 && this._useArgs(vn), this;
  }, Ue.prototype.key = function(Ve) {
    var vn = this._baseState;
    return Be(vn.key === null), vn.key = Ve, this;
  }, Ue.prototype.any = function() {
    var Ve = this._baseState;
    return Ve.any = !0, this;
  }, Ue.prototype.choice = function(Ve) {
    var vn = this._baseState;
    return Be(vn.choice === null), vn.choice = Ve, this._useArgs(Object.keys(Ve).map(function(En) {
      return Ve[En];
    })), this;
  }, Ue.prototype.contains = function(Ve) {
    var vn = this._baseState;
    return Be(vn.use === null), vn.contains = Ve, this;
  }, Ue.prototype._decode = function(Ve, vn) {
    var En = this._baseState;
    if (En.parent === null)
      return Ve.wrapResult(En.children[0]._decode(Ve, vn));
    var fi = En.default, bi = !0, mi = null;
    if (En.key !== null && (mi = Ve.enterKey(En.key)), En.optional) {
      var _i = null;
      if (En.explicit !== null ? _i = En.explicit : En.implicit !== null ? _i = En.implicit : En.tag !== null && (_i = En.tag), _i === null && !En.any) {
        var Ei = Ve.save();
        try {
          En.choice === null ? this._decodeGeneric(En.tag, Ve, vn) : this._decodeChoice(Ve, vn), bi = !0;
        } catch {
          bi = !1;
        }
        Ve.restore(Ei);
      } else if (bi = this._peekTag(Ve, _i, En.any), Ve.isError(bi))
        return bi;
    }
    var Si;
    if (En.obj && bi && (Si = Ve.enterObject()), bi) {
      if (En.explicit !== null) {
        var Mi = this._decodeTag(Ve, En.explicit);
        if (Ve.isError(Mi))
          return Mi;
        Ve = Mi;
      }
      var Oi = Ve.offset;
      if (En.use === null && En.choice === null) {
        if (En.any)
          var Ei = Ve.save();
        var Fi = this._decodeTag(
          Ve,
          En.implicit !== null ? En.implicit : En.tag,
          En.any
        );
        if (Ve.isError(Fi))
          return Fi;
        En.any ? fi = Ve.raw(Ei) : Ve = Fi;
      }
      if (vn && vn.track && En.tag !== null && vn.track(Ve.path(), Oi, Ve.length, "tagged"), vn && vn.track && En.tag !== null && vn.track(Ve.path(), Ve.offset, Ve.length, "content"), En.any ? fi = fi : En.choice === null ? fi = this._decodeGeneric(En.tag, Ve, vn) : fi = this._decodeChoice(Ve, vn), Ve.isError(fi))
        return fi;
      if (!En.any && En.choice === null && En.children !== null && En.children.forEach(function(Bi) {
        Bi._decode(Ve, vn);
      }), En.contains && (En.tag === "octstr" || En.tag === "bitstr")) {
        var Ui = new Ie(fi);
        fi = this._getUse(En.contains, Ve._reporterState.obj)._decode(Ui, vn);
      }
    }
    return En.obj && bi && (fi = Ve.leaveObject(Si)), En.key !== null && (fi !== null || bi === !0) ? Ve.leaveKey(mi, En.key, fi) : mi !== null && Ve.exitKey(mi), fi;
  }, Ue.prototype._decodeGeneric = function(Ve, vn, En) {
    var fi = this._baseState;
    return Ve === "seq" || Ve === "set" ? null : Ve === "seqof" || Ve === "setof" ? this._decodeList(vn, Ve, fi.args[0], En) : /str$/.test(Ve) ? this._decodeStr(vn, Ve, En) : Ve === "objid" && fi.args ? this._decodeObjid(vn, fi.args[0], fi.args[1], En) : Ve === "objid" ? this._decodeObjid(vn, null, null, En) : Ve === "gentime" || Ve === "utctime" ? this._decodeTime(vn, Ve, En) : Ve === "null_" ? this._decodeNull(vn, En) : Ve === "bool" ? this._decodeBool(vn, En) : Ve === "objDesc" ? this._decodeStr(vn, Ve, En) : Ve === "int" || Ve === "enum" ? this._decodeInt(vn, fi.args && fi.args[0], En) : fi.use !== null ? this._getUse(fi.use, vn._reporterState.obj)._decode(vn, En) : vn.error("unknown tag: " + Ve);
  }, Ue.prototype._getUse = function(Ve, vn) {
    var En = this._baseState;
    return En.useDecoder = this._use(Ve, vn), Be(En.useDecoder._baseState.parent === null), En.useDecoder = En.useDecoder._baseState.children[0], En.implicit !== En.useDecoder._baseState.implicit && (En.useDecoder = En.useDecoder.clone(), En.useDecoder._baseState.implicit = En.implicit), En.useDecoder;
  }, Ue.prototype._decodeChoice = function(Ve, vn) {
    var En = this._baseState, fi = null, bi = !1;
    return Object.keys(En.choice).some(function(mi) {
      var _i = Ve.save(), Ei = En.choice[mi];
      try {
        var Si = Ei._decode(Ve, vn);
        if (Ve.isError(Si))
          return !1;
        fi = { type: mi, value: Si }, bi = !0;
      } catch {
        return Ve.restore(_i), !1;
      }
      return !0;
    }, this), bi ? fi : Ve.error("Choice not matched");
  }, Ue.prototype._createEncoderBuffer = function(Ve) {
    return new t(Ve, this.reporter);
  }, Ue.prototype._encode = function(Ve, vn, En) {
    var fi = this._baseState;
    if (!(fi.default !== null && fi.default === Ve)) {
      var bi = this._encodeValue(Ve, vn, En);
      if (bi !== void 0 && !this._skipDefault(bi, vn, En))
        return bi;
    }
  }, Ue.prototype._encodeValue = function(Ve, vn, En) {
    var fi = this._baseState;
    if (fi.parent === null)
      return fi.children[0]._encode(Ve, vn || new Ae());
    var Ei = null;
    if (this.reporter = vn, fi.optional && Ve === void 0)
      if (fi.default !== null)
        Ve = fi.default;
      else
        return;
    var bi = null, mi = !1;
    if (fi.any)
      Ei = this._createEncoderBuffer(Ve);
    else if (fi.choice)
      Ei = this._encodeChoice(Ve, vn);
    else if (fi.contains)
      bi = this._getUse(fi.contains, En)._encode(Ve, vn), mi = !0;
    else if (fi.children)
      bi = fi.children.map(function(Oi) {
        if (Oi._baseState.tag === "null_")
          return Oi._encode(null, vn, Ve);
        if (Oi._baseState.key === null)
          return vn.error("Child should have a key");
        var Fi = vn.enterKey(Oi._baseState.key);
        if (typeof Ve != "object")
          return vn.error("Child expected, but input is not object");
        var Ui = Oi._encode(Ve[Oi._baseState.key], vn, Ve);
        return vn.leaveKey(Fi), Ui;
      }, this).filter(function(Oi) {
        return Oi;
      }), bi = this._createEncoderBuffer(bi);
    else if (fi.tag === "seqof" || fi.tag === "setof") {
      if (!(fi.args && fi.args.length === 1))
        return vn.error("Too many args for : " + fi.tag);
      if (!Array.isArray(Ve))
        return vn.error("seqof/setof, but data is not Array");
      var _i = this.clone();
      _i._baseState.implicit = null, bi = this._createEncoderBuffer(Ve.map(function(Oi) {
        var Fi = this._baseState;
        return this._getUse(Fi.args[0], Ve)._encode(Oi, vn);
      }, _i));
    } else fi.use !== null ? Ei = this._getUse(fi.use, En)._encode(Ve, vn) : (bi = this._encodePrimitive(fi.tag, Ve), mi = !0);
    var Ei;
    if (!fi.any && fi.choice === null) {
      var Si = fi.implicit !== null ? fi.implicit : fi.tag, Mi = fi.implicit === null ? "universal" : "context";
      Si === null ? fi.use === null && vn.error("Tag could be omitted only for .use()") : fi.use === null && (Ei = this._encodeComposite(Si, mi, Mi, bi));
    }
    return fi.explicit !== null && (Ei = this._encodeComposite(fi.explicit, !1, "context", Ei)), Ei;
  }, Ue.prototype._encodeChoice = function(Ve, vn) {
    var En = this._baseState, fi = En.choice[Ve.type];
    return fi || Be(
      !1,
      Ve.type + " not found in " + JSON.stringify(Object.keys(En.choice))
    ), fi._encode(Ve.value, vn);
  }, Ue.prototype._encodePrimitive = function(Ve, vn) {
    var En = this._baseState;
    if (/str$/.test(Ve))
      return this._encodeStr(vn, Ve);
    if (Ve === "objid" && En.args)
      return this._encodeObjid(vn, En.reverseArgs[0], En.args[1]);
    if (Ve === "objid")
      return this._encodeObjid(vn, null, null);
    if (Ve === "gentime" || Ve === "utctime")
      return this._encodeTime(vn, Ve);
    if (Ve === "null_")
      return this._encodeNull();
    if (Ve === "int" || Ve === "enum")
      return this._encodeInt(vn, En.args && En.reverseArgs[0]);
    if (Ve === "bool")
      return this._encodeBool(vn);
    if (Ve === "objDesc")
      return this._encodeStr(vn, Ve);
    throw new Error("Unsupported tag: " + Ve);
  }, Ue.prototype._isNumstr = function(Ve) {
    return /^[0-9 ]*$/.test(Ve);
  }, Ue.prototype._isPrintstr = function(Ve) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(Ve);
  }, node$1;
}
var hasRequiredBase$1;
function requireBase$1() {
  return hasRequiredBase$1 || (hasRequiredBase$1 = 1, function(Ae) {
    var t = Ae;
    t.Reporter = requireReporter().Reporter, t.DecoderBuffer = requireBuffer().DecoderBuffer, t.EncoderBuffer = requireBuffer().EncoderBuffer, t.Node = requireNode();
  }(base$3)), base$3;
}
var constants$1 = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(Ae) {
    var t = requireConstants$1();
    Ae.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, Ae.tagClassByName = t._reverse(Ae.tagClass), Ae.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, Ae.tagByName = t._reverse(Ae.tag);
  }(der)), der;
}
var hasRequiredConstants$1;
function requireConstants$1() {
  return hasRequiredConstants$1 || (hasRequiredConstants$1 = 1, function(Ae) {
    var t = Ae;
    t._reverse = function(Be) {
      var Pe = {};
      return Object.keys(Be).forEach(function(Te) {
        (Te | 0) == Te && (Te = Te | 0);
        var Me = Be[Te];
        Pe[Me] = Te;
      }), Pe;
    }, t.der = requireDer$2();
  }(constants$1)), constants$1;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var Ae = requireInherits_browser(), t = requireAsn1$1(), Ie = t.base, Be = t.bignum, Pe = t.constants.der;
  function Te(fn) {
    this.enc = "der", this.name = fn.name, this.entity = fn, this.tree = new Me(), this.tree._init(fn.body);
  }
  der_1$1 = Te, Te.prototype.decode = function(Ve, vn) {
    return Ve instanceof Ie.DecoderBuffer || (Ve = new Ie.DecoderBuffer(Ve, vn)), this.tree._decode(Ve, vn);
  };
  function Me(fn) {
    Ie.Node.call(this, "der", fn);
  }
  Ae(Me, Ie.Node), Me.prototype._peekTag = function(Ve, vn, En) {
    if (Ve.isEmpty())
      return !1;
    var fi = Ve.save(), bi = Ue(Ve, 'Failed to peek tag: "' + vn + '"');
    return Ve.isError(bi) ? bi : (Ve.restore(fi), bi.tag === vn || bi.tagStr === vn || bi.tagStr + "of" === vn || En);
  }, Me.prototype._decodeTag = function(Ve, vn, En) {
    var fi = Ue(
      Ve,
      'Failed to decode tag of "' + vn + '"'
    );
    if (Ve.isError(fi))
      return fi;
    var bi = je(
      Ve,
      fi.primitive,
      'Failed to get length of "' + vn + '"'
    );
    if (Ve.isError(bi))
      return bi;
    if (!En && fi.tag !== vn && fi.tagStr !== vn && fi.tagStr + "of" !== vn)
      return Ve.error('Failed to match tag: "' + vn + '"');
    if (fi.primitive || bi !== null)
      return Ve.skip(bi, 'Failed to match body of: "' + vn + '"');
    var mi = Ve.save(), _i = this._skipUntilEnd(
      Ve,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return Ve.isError(_i) ? _i : (bi = Ve.offset - mi.offset, Ve.restore(mi), Ve.skip(bi, 'Failed to match body of: "' + vn + '"'));
  }, Me.prototype._skipUntilEnd = function(Ve, vn) {
    for (; ; ) {
      var En = Ue(Ve, vn);
      if (Ve.isError(En))
        return En;
      var fi = je(Ve, En.primitive, vn);
      if (Ve.isError(fi))
        return fi;
      var bi;
      if (En.primitive || fi !== null ? bi = Ve.skip(fi) : bi = this._skipUntilEnd(Ve, vn), Ve.isError(bi))
        return bi;
      if (En.tagStr === "end")
        break;
    }
  }, Me.prototype._decodeList = function(Ve, vn, En, fi) {
    for (var bi = []; !Ve.isEmpty(); ) {
      var mi = this._peekTag(Ve, "end");
      if (Ve.isError(mi))
        return mi;
      var _i = En.decode(Ve, "der", fi);
      if (Ve.isError(_i) && mi)
        break;
      bi.push(_i);
    }
    return bi;
  }, Me.prototype._decodeStr = function(Ve, vn) {
    if (vn === "bitstr") {
      var En = Ve.readUInt8();
      return Ve.isError(En) ? En : { unused: En, data: Ve.raw() };
    } else if (vn === "bmpstr") {
      var fi = Ve.raw();
      if (fi.length % 2 === 1)
        return Ve.error("Decoding of string type: bmpstr length mismatch");
      for (var bi = "", mi = 0; mi < fi.length / 2; mi++)
        bi += String.fromCharCode(fi.readUInt16BE(mi * 2));
      return bi;
    } else if (vn === "numstr") {
      var _i = Ve.raw().toString("ascii");
      return this._isNumstr(_i) ? _i : Ve.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (vn === "octstr")
        return Ve.raw();
      if (vn === "objDesc")
        return Ve.raw();
      if (vn === "printstr") {
        var Ei = Ve.raw().toString("ascii");
        return this._isPrintstr(Ei) ? Ei : Ve.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(vn) ? Ve.raw().toString() : Ve.error("Decoding of string type: " + vn + " unsupported");
    }
  }, Me.prototype._decodeObjid = function(Ve, vn, En) {
    for (var fi, bi = [], mi = 0; !Ve.isEmpty(); ) {
      var _i = Ve.readUInt8();
      mi <<= 7, mi |= _i & 127, _i & 128 || (bi.push(mi), mi = 0);
    }
    _i & 128 && bi.push(mi);
    var Ei = bi[0] / 40 | 0, Si = bi[0] % 40;
    if (En ? fi = bi : fi = [Ei, Si].concat(bi.slice(1)), vn) {
      var Mi = vn[fi.join(" ")];
      Mi === void 0 && (Mi = vn[fi.join(".")]), Mi !== void 0 && (fi = Mi);
    }
    return fi;
  }, Me.prototype._decodeTime = function(Ve, vn) {
    var En = Ve.raw().toString();
    if (vn === "gentime")
      var fi = En.slice(0, 4) | 0, bi = En.slice(4, 6) | 0, mi = En.slice(6, 8) | 0, _i = En.slice(8, 10) | 0, Ei = En.slice(10, 12) | 0, Si = En.slice(12, 14) | 0;
    else if (vn === "utctime") {
      var fi = En.slice(0, 2) | 0, bi = En.slice(2, 4) | 0, mi = En.slice(4, 6) | 0, _i = En.slice(6, 8) | 0, Ei = En.slice(8, 10) | 0, Si = En.slice(10, 12) | 0;
      fi < 70 ? fi = 2e3 + fi : fi = 1900 + fi;
    } else
      return Ve.error("Decoding " + vn + " time is not supported yet");
    return Date.UTC(fi, bi - 1, mi, _i, Ei, Si, 0);
  }, Me.prototype._decodeNull = function(Ve) {
    return null;
  }, Me.prototype._decodeBool = function(Ve) {
    var vn = Ve.readUInt8();
    return Ve.isError(vn) ? vn : vn !== 0;
  }, Me.prototype._decodeInt = function(Ve, vn) {
    var En = Ve.raw(), fi = new Be(En);
    return vn && (fi = vn[fi.toString(10)] || fi), fi;
  }, Me.prototype._use = function(Ve, vn) {
    return typeof Ve == "function" && (Ve = Ve(vn)), Ve._getDecoder("der").tree;
  };
  function Ue(fn, Ve) {
    var vn = fn.readUInt8(Ve);
    if (fn.isError(vn))
      return vn;
    var En = Pe.tagClass[vn >> 6], fi = (vn & 32) === 0;
    if ((vn & 31) === 31) {
      var bi = vn;
      for (vn = 0; (bi & 128) === 128; ) {
        if (bi = fn.readUInt8(Ve), fn.isError(bi))
          return bi;
        vn <<= 7, vn |= bi & 127;
      }
    } else
      vn &= 31;
    var mi = Pe.tag[vn];
    return {
      cls: En,
      primitive: fi,
      tag: vn,
      tagStr: mi
    };
  }
  function je(fn, Ve, vn) {
    var En = fn.readUInt8(vn);
    if (fn.isError(En))
      return En;
    if (!Ve && En === 128)
      return null;
    if (!(En & 128))
      return En;
    var fi = En & 127;
    if (fi > 4)
      return fn.error("length octect is too long");
    En = 0;
    for (var bi = 0; bi < fi; bi++) {
      En <<= 8;
      var mi = fn.readUInt8(vn);
      if (fn.isError(mi))
        return mi;
      En |= mi;
    }
    return En;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var Ae = requireInherits_browser(), t = require$$0$4.Buffer, Ie = requireDer$1();
  function Be(Pe) {
    Ie.call(this, Pe), this.enc = "pem";
  }
  return Ae(Be, Ie), pem$1 = Be, Be.prototype.decode = function(Te, Me) {
    for (var Ue = Te.toString().split(/[\r\n]+/g), je = Me.label.toUpperCase(), fn = /^-----(BEGIN|END) ([^-]+)-----$/, Ve = -1, vn = -1, En = 0; En < Ue.length; En++) {
      var fi = Ue[En].match(fn);
      if (fi !== null && fi[2] === je)
        if (Ve === -1) {
          if (fi[1] !== "BEGIN")
            break;
          Ve = En;
        } else {
          if (fi[1] !== "END")
            break;
          vn = En;
          break;
        }
    }
    if (Ve === -1 || vn === -1)
      throw new Error("PEM section not found for: " + je);
    var bi = Ue.slice(Ve + 1, vn).join("");
    bi.replace(/[^a-z0-9\+\/=]+/gi, "");
    var mi = new t(bi, "base64");
    return Ie.prototype.decode.call(this, mi, Me);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(Ae) {
    var t = Ae;
    t.der = requireDer$1(), t.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var Ae = requireInherits_browser(), t = require$$0$4.Buffer, Ie = requireAsn1$1(), Be = Ie.base, Pe = Ie.constants.der;
  function Te(fn) {
    this.enc = "der", this.name = fn.name, this.entity = fn, this.tree = new Me(), this.tree._init(fn.body);
  }
  der_1 = Te, Te.prototype.encode = function(Ve, vn) {
    return this.tree._encode(Ve, vn).join();
  };
  function Me(fn) {
    Be.Node.call(this, "der", fn);
  }
  Ae(Me, Be.Node), Me.prototype._encodeComposite = function(Ve, vn, En, fi) {
    var bi = je(Ve, vn, En, this.reporter);
    if (fi.length < 128) {
      var Ei = new t(2);
      return Ei[0] = bi, Ei[1] = fi.length, this._createEncoderBuffer([Ei, fi]);
    }
    for (var mi = 1, _i = fi.length; _i >= 256; _i >>= 8)
      mi++;
    var Ei = new t(2 + mi);
    Ei[0] = bi, Ei[1] = 128 | mi;
    for (var _i = 1 + mi, Si = fi.length; Si > 0; _i--, Si >>= 8)
      Ei[_i] = Si & 255;
    return this._createEncoderBuffer([Ei, fi]);
  }, Me.prototype._encodeStr = function(Ve, vn) {
    if (vn === "bitstr")
      return this._createEncoderBuffer([Ve.unused | 0, Ve.data]);
    if (vn === "bmpstr") {
      for (var En = new t(Ve.length * 2), fi = 0; fi < Ve.length; fi++)
        En.writeUInt16BE(Ve.charCodeAt(fi), fi * 2);
      return this._createEncoderBuffer(En);
    } else return vn === "numstr" ? this._isNumstr(Ve) ? this._createEncoderBuffer(Ve) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : vn === "printstr" ? this._isPrintstr(Ve) ? this._createEncoderBuffer(Ve) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(vn) ? this._createEncoderBuffer(Ve) : vn === "objDesc" ? this._createEncoderBuffer(Ve) : this.reporter.error("Encoding of string type: " + vn + " unsupported");
  }, Me.prototype._encodeObjid = function(Ve, vn, En) {
    if (typeof Ve == "string") {
      if (!vn)
        return this.reporter.error("string objid given, but no values map found");
      if (!vn.hasOwnProperty(Ve))
        return this.reporter.error("objid not found in values map");
      Ve = vn[Ve].split(/[\s\.]+/g);
      for (var fi = 0; fi < Ve.length; fi++)
        Ve[fi] |= 0;
    } else if (Array.isArray(Ve)) {
      Ve = Ve.slice();
      for (var fi = 0; fi < Ve.length; fi++)
        Ve[fi] |= 0;
    }
    if (!Array.isArray(Ve))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(Ve));
    if (!En) {
      if (Ve[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      Ve.splice(0, 2, Ve[0] * 40 + Ve[1]);
    }
    for (var bi = 0, fi = 0; fi < Ve.length; fi++) {
      var mi = Ve[fi];
      for (bi++; mi >= 128; mi >>= 7)
        bi++;
    }
    for (var _i = new t(bi), Ei = _i.length - 1, fi = Ve.length - 1; fi >= 0; fi--) {
      var mi = Ve[fi];
      for (_i[Ei--] = mi & 127; (mi >>= 7) > 0; )
        _i[Ei--] = 128 | mi & 127;
    }
    return this._createEncoderBuffer(_i);
  };
  function Ue(fn) {
    return fn < 10 ? "0" + fn : fn;
  }
  Me.prototype._encodeTime = function(Ve, vn) {
    var En, fi = new Date(Ve);
    return vn === "gentime" ? En = [
      Ue(fi.getFullYear()),
      Ue(fi.getUTCMonth() + 1),
      Ue(fi.getUTCDate()),
      Ue(fi.getUTCHours()),
      Ue(fi.getUTCMinutes()),
      Ue(fi.getUTCSeconds()),
      "Z"
    ].join("") : vn === "utctime" ? En = [
      Ue(fi.getFullYear() % 100),
      Ue(fi.getUTCMonth() + 1),
      Ue(fi.getUTCDate()),
      Ue(fi.getUTCHours()),
      Ue(fi.getUTCMinutes()),
      Ue(fi.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + vn + " time is not supported yet"), this._encodeStr(En, "octstr");
  }, Me.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, Me.prototype._encodeInt = function(Ve, vn) {
    if (typeof Ve == "string") {
      if (!vn)
        return this.reporter.error("String int or enum given, but no values map");
      if (!vn.hasOwnProperty(Ve))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(Ve));
      Ve = vn[Ve];
    }
    if (typeof Ve != "number" && !t.isBuffer(Ve)) {
      var En = Ve.toArray();
      !Ve.sign && En[0] & 128 && En.unshift(0), Ve = new t(En);
    }
    if (t.isBuffer(Ve)) {
      var fi = Ve.length;
      Ve.length === 0 && fi++;
      var mi = new t(fi);
      return Ve.copy(mi), Ve.length === 0 && (mi[0] = 0), this._createEncoderBuffer(mi);
    }
    if (Ve < 128)
      return this._createEncoderBuffer(Ve);
    if (Ve < 256)
      return this._createEncoderBuffer([0, Ve]);
    for (var fi = 1, bi = Ve; bi >= 256; bi >>= 8)
      fi++;
    for (var mi = new Array(fi), bi = mi.length - 1; bi >= 0; bi--)
      mi[bi] = Ve & 255, Ve >>= 8;
    return mi[0] & 128 && mi.unshift(0), this._createEncoderBuffer(new t(mi));
  }, Me.prototype._encodeBool = function(Ve) {
    return this._createEncoderBuffer(Ve ? 255 : 0);
  }, Me.prototype._use = function(Ve, vn) {
    return typeof Ve == "function" && (Ve = Ve(vn)), Ve._getEncoder("der").tree;
  }, Me.prototype._skipDefault = function(Ve, vn, En) {
    var fi = this._baseState, bi;
    if (fi.default === null)
      return !1;
    var mi = Ve.join();
    if (fi.defaultBuffer === void 0 && (fi.defaultBuffer = this._encodeValue(fi.default, vn, En).join()), mi.length !== fi.defaultBuffer.length)
      return !1;
    for (bi = 0; bi < mi.length; bi++)
      if (mi[bi] !== fi.defaultBuffer[bi])
        return !1;
    return !0;
  };
  function je(fn, Ve, vn, En) {
    var fi;
    if (fn === "seqof" ? fn = "seq" : fn === "setof" && (fn = "set"), Pe.tagByName.hasOwnProperty(fn))
      fi = Pe.tagByName[fn];
    else if (typeof fn == "number" && (fn | 0) === fn)
      fi = fn;
    else
      return En.error("Unknown tag: " + fn);
    return fi >= 31 ? En.error("Multi-octet tag encoding unsupported") : (Ve || (fi |= 32), fi |= Pe.tagClassByName[vn || "universal"] << 6, fi);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var Ae = requireInherits_browser(), t = requireDer();
  function Ie(Be) {
    t.call(this, Be), this.enc = "pem";
  }
  return Ae(Ie, t), pem = Ie, Ie.prototype.encode = function(Pe, Te) {
    for (var Me = t.prototype.encode.call(this, Pe), Ue = Me.toString("base64"), je = ["-----BEGIN " + Te.label + "-----"], fn = 0; fn < Ue.length; fn += 64)
      je.push(Ue.slice(fn, fn + 64));
    return je.push("-----END " + Te.label + "-----"), je.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(Ae) {
    var t = Ae;
    t.der = requireDer(), t.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
  return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, function(Ae) {
    var t = Ae;
    t.bignum = requireBn(), t.define = requireApi().define, t.base = requireBase$1(), t.constants = requireConstants$1(), t.decoders = requireDecoders(), t.encoders = requireEncoders();
  }(asn1)), asn1;
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate) return certificate;
  hasRequiredCertificate = 1;
  var Ae = requireAsn1$1(), t = Ae.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), Ie = Ae.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), Be = Ae.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), Pe = Ae.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(Be),
      this.key("subjectPublicKey").bitstr()
    );
  }), Te = Ae.define("RelativeDistinguishedName", function() {
    this.setof(Ie);
  }), Me = Ae.define("RDNSequence", function() {
    this.seqof(Te);
  }), Ue = Ae.define("Name", function() {
    this.choice({
      rdnSequence: this.use(Me)
    });
  }), je = Ae.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(t),
      this.key("notAfter").use(t)
    );
  }), fn = Ae.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), Ve = Ae.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(Be),
      this.key("issuer").use(Ue),
      this.key("validity").use(je),
      this.key("subject").use(Ue),
      this.key("subjectPublicKeyInfo").use(Pe),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(fn).optional()
    );
  }), vn = Ae.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(Ve),
      this.key("signatureAlgorithm").use(Be),
      this.key("signatureValue").bitstr()
    );
  });
  return certificate = vn, certificate;
}
var hasRequiredAsn1;
function requireAsn1() {
  if (hasRequiredAsn1) return asn1$1;
  hasRequiredAsn1 = 1;
  var Ae = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var t = Ae.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  asn1$1.RSAPrivateKey = t;
  var Ie = Ae.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  asn1$1.RSAPublicKey = Ie;
  var Be = Ae.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), Pe = Ae.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(Be),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1.PublicKey = Pe;
  var Te = Ae.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(Be),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.PrivateKey = Te;
  var Me = Ae.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.EncryptedPrivateKey = Me;
  var Ue = Ae.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  asn1$1.DSAPrivateKey = Ue, asn1$1.DSAparam = Ae.define("DSAparam", function() {
    this.int();
  });
  var je = Ae.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  }), fn = Ae.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(je),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  return asn1$1.ECPrivateKey = fn, asn1$1.signature = Ae.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), asn1$1;
}
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
  if (hasRequiredFixProc) return fixProc;
  hasRequiredFixProc = 1;
  var Ae = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, t = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, Ie = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, Be = requireEvp_bytestokey(), Pe = requireBrowser$7(), Te = requireSafeBuffer$1().Buffer;
  return fixProc = function(Me, Ue) {
    var je = Me.toString(), fn = je.match(Ae), Ve;
    if (fn) {
      var En = "aes" + fn[1], fi = Te.from(fn[2], "hex"), bi = Te.from(fn[3].replace(/[\r\n]/g, ""), "base64"), mi = Be(Ue, fi.slice(0, 8), parseInt(fn[1], 10)).key, _i = [], Ei = Pe.createDecipheriv(En, mi, fi);
      _i.push(Ei.update(bi)), _i.push(Ei.final()), Ve = Te.concat(_i);
    } else {
      var vn = je.match(Ie);
      Ve = Te.from(vn[2].replace(/[\r\n]/g, ""), "base64");
    }
    var Si = je.match(t)[1];
    return {
      tag: Si,
      data: Ve
    };
  }, fixProc;
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
  if (hasRequiredParseAsn1) return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var Ae = requireAsn1(), t = require$$1, Ie = requireFixProc(), Be = requireBrowser$7(), Pe = requireBrowser$8(), Te = requireSafeBuffer$1().Buffer;
  function Me(je, fn) {
    var Ve = je.algorithm.decrypt.kde.kdeparams.salt, vn = parseInt(je.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), En = t[je.algorithm.decrypt.cipher.algo.join(".")], fi = je.algorithm.decrypt.cipher.iv, bi = je.subjectPrivateKey, mi = parseInt(En.split("-")[1], 10) / 8, _i = Pe.pbkdf2Sync(fn, Ve, vn, mi, "sha1"), Ei = Be.createDecipheriv(En, _i, fi), Si = [];
    return Si.push(Ei.update(bi)), Si.push(Ei.final()), Te.concat(Si);
  }
  function Ue(je) {
    var fn;
    typeof je == "object" && !Te.isBuffer(je) && (fn = je.passphrase, je = je.key), typeof je == "string" && (je = Te.from(je));
    var Ve = Ie(je, fn), vn = Ve.tag, En = Ve.data, fi, bi;
    switch (vn) {
      case "CERTIFICATE":
        bi = Ae.certificate.decode(En, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (bi || (bi = Ae.PublicKey.decode(En, "der")), fi = bi.algorithm.algorithm.join("."), fi) {
          case "1.2.840.113549.1.1.1":
            return Ae.RSAPublicKey.decode(bi.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return bi.subjectPrivateKey = bi.subjectPublicKey, {
              type: "ec",
              data: bi
            };
          case "1.2.840.10040.4.1":
            return bi.algorithm.params.pub_key = Ae.DSAparam.decode(bi.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: bi.algorithm.params
            };
          default:
            throw new Error("unknown key id " + fi);
        }
      case "ENCRYPTED PRIVATE KEY":
        En = Ae.EncryptedPrivateKey.decode(En, "der"), En = Me(En, fn);
      case "PRIVATE KEY":
        switch (bi = Ae.PrivateKey.decode(En, "der"), fi = bi.algorithm.algorithm.join("."), fi) {
          case "1.2.840.113549.1.1.1":
            return Ae.RSAPrivateKey.decode(bi.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: bi.algorithm.curve,
              privateKey: Ae.ECPrivateKey.decode(bi.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return bi.algorithm.params.priv_key = Ae.DSAparam.decode(bi.subjectPrivateKey, "der"), {
              type: "dsa",
              params: bi.algorithm.params
            };
          default:
            throw new Error("unknown key id " + fi);
        }
      case "RSA PUBLIC KEY":
        return Ae.RSAPublicKey.decode(En, "der");
      case "RSA PRIVATE KEY":
        return Ae.RSAPrivateKey.decode(En, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: Ae.DSAPrivateKey.decode(En, "der")
        };
      case "EC PRIVATE KEY":
        return En = Ae.ECPrivateKey.decode(En, "der"), {
          curve: En.parameters.value,
          privateKey: En.privateKey
        };
      default:
        throw new Error("unknown key type " + vn);
    }
  }
  return Ue.signature = Ae.signature, parseAsn1 = Ue, parseAsn1;
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requireBrowser$9(), Ie = requireBrowserifyRsa(), Be = requireElliptic().ec, Pe = bnExports, Te = requireParseAsn1(), Me = require$$4, Ue = 1;
  function je(Ei, Si, Mi, Oi, Fi) {
    var Ui = Te(Si);
    if (Ui.curve) {
      if (Oi !== "ecdsa" && Oi !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return fn(Ei, Ui);
    } else if (Ui.type === "dsa") {
      if (Oi !== "dsa")
        throw new Error("wrong private key type");
      return Ve(Ei, Ui, Mi);
    }
    if (Oi !== "rsa" && Oi !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (Si.padding !== void 0 && Si.padding !== Ue)
      throw new Error("illegal or unsupported padding mode");
    Ei = Ae.concat([Fi, Ei]);
    for (var Pi = Ui.modulus.byteLength(), Bi = [0, 1]; Ei.length + Bi.length + 1 < Pi; )
      Bi.push(255);
    Bi.push(0);
    for (var ji = -1; ++ji < Ei.length; )
      Bi.push(Ei[ji]);
    var Zi = Ie(Bi, Ui);
    return Zi;
  }
  function fn(Ei, Si) {
    var Mi = Me[Si.curve.join(".")];
    if (!Mi)
      throw new Error("unknown curve " + Si.curve.join("."));
    var Oi = new Be(Mi), Fi = Oi.keyFromPrivate(Si.privateKey), Ui = Fi.sign(Ei);
    return Ae.from(Ui.toDER());
  }
  function Ve(Ei, Si, Mi) {
    for (var Oi = Si.params.priv_key, Fi = Si.params.p, Ui = Si.params.q, Pi = Si.params.g, Bi = new Pe(0), ji, Zi = fi(Ei, Ui).mod(Ui), zi = !1, xi = En(Oi, Ui, Ei, Mi); zi === !1; )
      ji = mi(Ui, xi, Mi), Bi = _i(Pi, ji, Fi, Ui), zi = ji.invm(Ui).imul(Zi.add(Oi.mul(Bi))).mod(Ui), zi.cmpn(0) === 0 && (zi = !1, Bi = new Pe(0));
    return vn(Bi, zi);
  }
  function vn(Ei, Si) {
    Ei = Ei.toArray(), Si = Si.toArray(), Ei[0] & 128 && (Ei = [0].concat(Ei)), Si[0] & 128 && (Si = [0].concat(Si));
    var Mi = Ei.length + Si.length + 4, Oi = [
      48,
      Mi,
      2,
      Ei.length
    ];
    return Oi = Oi.concat(Ei, [2, Si.length], Si), Ae.from(Oi);
  }
  function En(Ei, Si, Mi, Oi) {
    if (Ei = Ae.from(Ei.toArray()), Ei.length < Si.byteLength()) {
      var Fi = Ae.alloc(Si.byteLength() - Ei.length);
      Ei = Ae.concat([Fi, Ei]);
    }
    var Ui = Mi.length, Pi = bi(Mi, Si), Bi = Ae.alloc(Ui);
    Bi.fill(1);
    var ji = Ae.alloc(Ui);
    return ji = t(Oi, ji).update(Bi).update(Ae.from([0])).update(Ei).update(Pi).digest(), Bi = t(Oi, ji).update(Bi).digest(), ji = t(Oi, ji).update(Bi).update(Ae.from([1])).update(Ei).update(Pi).digest(), Bi = t(Oi, ji).update(Bi).digest(), { k: ji, v: Bi };
  }
  function fi(Ei, Si) {
    var Mi = new Pe(Ei), Oi = (Ei.length << 3) - Si.bitLength();
    return Oi > 0 && Mi.ishrn(Oi), Mi;
  }
  function bi(Ei, Si) {
    Ei = fi(Ei, Si), Ei = Ei.mod(Si);
    var Mi = Ae.from(Ei.toArray());
    if (Mi.length < Si.byteLength()) {
      var Oi = Ae.alloc(Si.byteLength() - Mi.length);
      Mi = Ae.concat([Oi, Mi]);
    }
    return Mi;
  }
  function mi(Ei, Si, Mi) {
    var Oi, Fi;
    do {
      for (Oi = Ae.alloc(0); Oi.length * 8 < Ei.bitLength(); )
        Si.v = t(Mi, Si.k).update(Si.v).digest(), Oi = Ae.concat([Oi, Si.v]);
      Fi = fi(Oi, Ei), Si.k = t(Mi, Si.k).update(Si.v).update(Ae.from([0])).digest(), Si.v = t(Mi, Si.k).update(Si.v).digest();
    } while (Fi.cmp(Ei) !== -1);
    return Fi;
  }
  function _i(Ei, Si, Mi, Oi) {
    return Ei.toRed(Pe.mont(Mi)).redPow(Si).fromRed().mod(Oi);
  }
  return sign.exports = je, sign.exports.getKey = En, sign.exports.makeKey = mi, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = bnExports, Ie = requireElliptic().ec, Be = requireParseAsn1(), Pe = require$$4;
  function Te(fn, Ve, vn, En, fi) {
    var bi = Be(vn);
    if (bi.type === "ec") {
      if (En !== "ecdsa" && En !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return Me(fn, Ve, bi);
    } else if (bi.type === "dsa") {
      if (En !== "dsa")
        throw new Error("wrong public key type");
      return Ue(fn, Ve, bi);
    }
    if (En !== "rsa" && En !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    Ve = Ae.concat([fi, Ve]);
    for (var mi = bi.modulus.byteLength(), _i = [1], Ei = 0; Ve.length + _i.length + 2 < mi; )
      _i.push(255), Ei += 1;
    _i.push(0);
    for (var Si = -1; ++Si < Ve.length; )
      _i.push(Ve[Si]);
    _i = Ae.from(_i);
    var Mi = t.mont(bi.modulus);
    fn = new t(fn).toRed(Mi), fn = fn.redPow(new t(bi.publicExponent)), fn = Ae.from(fn.fromRed().toArray());
    var Oi = Ei < 8 ? 1 : 0;
    for (mi = Math.min(fn.length, _i.length), fn.length !== _i.length && (Oi = 1), Si = -1; ++Si < mi; )
      Oi |= fn[Si] ^ _i[Si];
    return Oi === 0;
  }
  function Me(fn, Ve, vn) {
    var En = Pe[vn.data.algorithm.curve.join(".")];
    if (!En)
      throw new Error("unknown curve " + vn.data.algorithm.curve.join("."));
    var fi = new Ie(En), bi = vn.data.subjectPrivateKey.data;
    return fi.verify(Ve, fn, bi);
  }
  function Ue(fn, Ve, vn) {
    var En = vn.data.p, fi = vn.data.q, bi = vn.data.g, mi = vn.data.pub_key, _i = Be.signature.decode(fn, "der"), Ei = _i.s, Si = _i.r;
    je(Ei, fi), je(Si, fi);
    var Mi = t.mont(En), Oi = Ei.invm(fi), Fi = bi.toRed(Mi).redPow(new t(Ve).mul(Oi).mod(fi)).fromRed().mul(mi.toRed(Mi).redPow(Si.mul(Oi).mod(fi)).fromRed()).mod(En).mod(fi);
    return Fi.cmp(Si) === 0;
  }
  function je(fn, Ve) {
    if (fn.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (fn.cmp(Ve) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = Te, verify_1;
}
var browser$8, hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4) return browser$8;
  hasRequiredBrowser$4 = 1;
  var Ae = requireSafeBuffer$1().Buffer, t = requireBrowser$a(), Ie = requireReadableBrowser(), Be = requireInherits_browser(), Pe = requireSign(), Te = requireVerify(), Me = require$$6;
  Object.keys(Me).forEach(function(vn) {
    Me[vn].id = Ae.from(Me[vn].id, "hex"), Me[vn.toLowerCase()] = Me[vn];
  });
  function Ue(vn) {
    Ie.Writable.call(this);
    var En = Me[vn];
    if (!En)
      throw new Error("Unknown message digest");
    this._hashType = En.hash, this._hash = t(En.hash), this._tag = En.id, this._signType = En.sign;
  }
  Be(Ue, Ie.Writable), Ue.prototype._write = function(En, fi, bi) {
    this._hash.update(En), bi();
  }, Ue.prototype.update = function(En, fi) {
    return this._hash.update(typeof En == "string" ? Ae.from(En, fi) : En), this;
  }, Ue.prototype.sign = function(En, fi) {
    this.end();
    var bi = this._hash.digest(), mi = Pe(bi, En, this._hashType, this._signType, this._tag);
    return fi ? mi.toString(fi) : mi;
  };
  function je(vn) {
    Ie.Writable.call(this);
    var En = Me[vn];
    if (!En)
      throw new Error("Unknown message digest");
    this._hash = t(En.hash), this._tag = En.id, this._signType = En.sign;
  }
  Be(je, Ie.Writable), je.prototype._write = function(En, fi, bi) {
    this._hash.update(En), bi();
  }, je.prototype.update = function(En, fi) {
    return this._hash.update(typeof En == "string" ? Ae.from(En, fi) : En), this;
  }, je.prototype.verify = function(En, fi, bi) {
    var mi = typeof fi == "string" ? Ae.from(fi, bi) : fi;
    this.end();
    var _i = this._hash.digest();
    return Te(mi, _i, En, this._signType, this._tag);
  };
  function fn(vn) {
    return new Ue(vn);
  }
  function Ve(vn) {
    return new je(vn);
  }
  return browser$8 = {
    Sign: fn,
    Verify: Ve,
    createSign: fn,
    createVerify: Ve
  }, browser$8;
}
var browser$7, hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3) return browser$7;
  hasRequiredBrowser$3 = 1;
  var Ae = requireElliptic(), t = requireBn();
  browser$7 = function(Me) {
    return new Be(Me);
  };
  var Ie = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  Ie.p224 = Ie.secp224r1, Ie.p256 = Ie.secp256r1 = Ie.prime256v1, Ie.p192 = Ie.secp192r1 = Ie.prime192v1, Ie.p384 = Ie.secp384r1, Ie.p521 = Ie.secp521r1;
  function Be(Te) {
    this.curveType = Ie[Te], this.curveType || (this.curveType = {
      name: Te
    }), this.curve = new Ae.ec(this.curveType.name), this.keys = void 0;
  }
  Be.prototype.generateKeys = function(Te, Me) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(Te, Me);
  }, Be.prototype.computeSecret = function(Te, Me, Ue) {
    Me = Me || "utf8", Buffer$3.isBuffer(Te) || (Te = new Buffer$3(Te, Me));
    var je = this.curve.keyFromPublic(Te).getPublic(), fn = je.mul(this.keys.getPrivate()).getX();
    return Pe(fn, Ue, this.curveType.byteLength);
  }, Be.prototype.getPublicKey = function(Te, Me) {
    var Ue = this.keys.getPublic(Me === "compressed", !0);
    return Me === "hybrid" && (Ue[Ue.length - 1] % 2 ? Ue[0] = 7 : Ue[0] = 6), Pe(Ue, Te);
  }, Be.prototype.getPrivateKey = function(Te) {
    return Pe(this.keys.getPrivate(), Te);
  }, Be.prototype.setPublicKey = function(Te, Me) {
    return Me = Me || "utf8", Buffer$3.isBuffer(Te) || (Te = new Buffer$3(Te, Me)), this.keys._importPublic(Te), this;
  }, Be.prototype.setPrivateKey = function(Te, Me) {
    Me = Me || "utf8", Buffer$3.isBuffer(Te) || (Te = new Buffer$3(Te, Me));
    var Ue = new t(Te);
    return Ue = Ue.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(Ue), this;
  };
  function Pe(Te, Me, Ue) {
    Array.isArray(Te) || (Te = Te.toArray());
    var je = new Buffer$3(Te);
    if (Ue && je.length < Ue) {
      var fn = new Buffer$3(Ue - je.length);
      fn.fill(0), je = Buffer$3.concat([fn, je]);
    }
    return Me ? je.toString(Me) : je;
  }
  return browser$7;
}
var browser$6 = {}, mgf, hasRequiredMgf;
function requireMgf() {
  if (hasRequiredMgf) return mgf;
  hasRequiredMgf = 1;
  var Ae = requireBrowser$a(), t = requireSafeBuffer$1().Buffer;
  mgf = function(Be, Pe) {
    for (var Te = t.alloc(0), Me = 0, Ue; Te.length < Pe; )
      Ue = Ie(Me++), Te = t.concat([Te, Ae("sha1").update(Be).update(Ue).digest()]);
    return Te.slice(0, Pe);
  };
  function Ie(Be) {
    var Pe = t.allocUnsafe(4);
    return Pe.writeUInt32BE(Be, 0), Pe;
  }
  return mgf;
}
var xor, hasRequiredXor;
function requireXor() {
  return hasRequiredXor || (hasRequiredXor = 1, xor = function(t, Ie) {
    for (var Be = t.length, Pe = -1; ++Pe < Be; )
      t[Pe] ^= Ie[Pe];
    return t;
  }), xor;
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
  if (hasRequiredWithPublic) return withPublic_1;
  hasRequiredWithPublic = 1;
  var Ae = requireBn(), t = requireSafeBuffer$1().Buffer;
  function Ie(Be, Pe) {
    return t.from(Be.toRed(Ae.mont(Pe.modulus)).redPow(new Ae(Pe.publicExponent)).fromRed().toArray());
  }
  return withPublic_1 = Ie, withPublic_1;
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt) return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var Ae = requireParseAsn1(), t = requireBrowser$c(), Ie = requireBrowser$a(), Be = requireMgf(), Pe = requireXor(), Te = requireBn(), Me = requireWithPublic(), Ue = requireBrowserifyRsa(), je = requireSafeBuffer$1().Buffer;
  publicEncrypt = function(fi, bi, mi) {
    var _i;
    fi.padding ? _i = fi.padding : mi ? _i = 1 : _i = 4;
    var Ei = Ae(fi), Si;
    if (_i === 4)
      Si = fn(Ei, bi);
    else if (_i === 1)
      Si = Ve(Ei, bi, mi);
    else if (_i === 3) {
      if (Si = new Te(bi), Si.cmp(Ei.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return mi ? Ue(Si, Ei) : Me(Si, Ei);
  };
  function fn(En, fi) {
    var bi = En.modulus.byteLength(), mi = fi.length, _i = Ie("sha1").update(je.alloc(0)).digest(), Ei = _i.length, Si = 2 * Ei;
    if (mi > bi - Si - 2)
      throw new Error("message too long");
    var Mi = je.alloc(bi - mi - Si - 2), Oi = bi - Ei - 1, Fi = t(Ei), Ui = Pe(je.concat([_i, Mi, je.alloc(1, 1), fi], Oi), Be(Fi, Oi)), Pi = Pe(Fi, Be(Ui, Ei));
    return new Te(je.concat([je.alloc(1), Pi, Ui], bi));
  }
  function Ve(En, fi, bi) {
    var mi = fi.length, _i = En.modulus.byteLength();
    if (mi > _i - 11)
      throw new Error("message too long");
    var Ei;
    return bi ? Ei = je.alloc(_i - mi - 3, 255) : Ei = vn(_i - mi - 3), new Te(je.concat([je.from([0, bi ? 1 : 2]), Ei, je.alloc(1), fi], _i));
  }
  function vn(En) {
    for (var fi = je.allocUnsafe(En), bi = 0, mi = t(En * 2), _i = 0, Ei; bi < En; )
      _i === mi.length && (mi = t(En * 2), _i = 0), Ei = mi[_i++], Ei && (fi[bi++] = Ei);
    return fi;
  }
  return publicEncrypt;
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt) return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var Ae = requireParseAsn1(), t = requireMgf(), Ie = requireXor(), Be = requireBn(), Pe = requireBrowserifyRsa(), Te = requireBrowser$a(), Me = requireWithPublic(), Ue = requireSafeBuffer$1().Buffer;
  privateDecrypt = function(En, fi, bi) {
    var mi;
    En.padding ? mi = En.padding : bi ? mi = 1 : mi = 4;
    var _i = Ae(En), Ei = _i.modulus.byteLength();
    if (fi.length > Ei || new Be(fi).cmp(_i.modulus) >= 0)
      throw new Error("decryption error");
    var Si;
    bi ? Si = Me(new Be(fi), _i) : Si = Pe(fi, _i);
    var Mi = Ue.alloc(Ei - Si.length);
    if (Si = Ue.concat([Mi, Si], Ei), mi === 4)
      return je(_i, Si);
    if (mi === 1)
      return fn(_i, Si, bi);
    if (mi === 3)
      return Si;
    throw new Error("unknown padding");
  };
  function je(vn, En) {
    var fi = vn.modulus.byteLength(), bi = Te("sha1").update(Ue.alloc(0)).digest(), mi = bi.length;
    if (En[0] !== 0)
      throw new Error("decryption error");
    var _i = En.slice(1, mi + 1), Ei = En.slice(mi + 1), Si = Ie(_i, t(Ei, mi)), Mi = Ie(Ei, t(Si, fi - mi - 1));
    if (Ve(bi, Mi.slice(0, mi)))
      throw new Error("decryption error");
    for (var Oi = mi; Mi[Oi] === 0; )
      Oi++;
    if (Mi[Oi++] !== 1)
      throw new Error("decryption error");
    return Mi.slice(Oi);
  }
  function fn(vn, En, fi) {
    for (var bi = En.slice(0, 2), mi = 2, _i = 0; En[mi++] !== 0; )
      if (mi >= En.length) {
        _i++;
        break;
      }
    var Ei = En.slice(2, mi - 1);
    if ((bi.toString("hex") !== "0002" && !fi || bi.toString("hex") !== "0001" && fi) && _i++, Ei.length < 8 && _i++, _i)
      throw new Error("decryption error");
    return En.slice(mi);
  }
  function Ve(vn, En) {
    vn = Ue.from(vn), En = Ue.from(En);
    var fi = 0, bi = vn.length;
    vn.length !== En.length && (fi++, bi = Math.min(vn.length, En.length));
    for (var mi = -1; ++mi < bi; )
      fi += vn[mi] ^ En[mi];
    return fi;
  }
  return privateDecrypt;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  return hasRequiredBrowser$2 || (hasRequiredBrowser$2 = 1, function(Ae) {
    Ae.publicEncrypt = requirePublicEncrypt(), Ae.privateDecrypt = requirePrivateDecrypt(), Ae.privateEncrypt = function(Ie, Be) {
      return Ae.publicEncrypt(Ie, Be, !0);
    }, Ae.publicDecrypt = function(Ie, Be) {
      return Ae.privateDecrypt(Ie, Be, !0);
    };
  }(browser$6)), browser$6;
}
var browser$5 = {}, hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$5;
  hasRequiredBrowser$1 = 1;
  function Ae() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var t = requireSafeBuffer$1(), Ie = requireBrowser$c(), Be = t.Buffer, Pe = t.kMaxLength, Te = commonjsGlobal.crypto || commonjsGlobal.msCrypto, Me = Math.pow(2, 32) - 1;
  function Ue(En, fi) {
    if (typeof En != "number" || En !== En)
      throw new TypeError("offset must be a number");
    if (En > Me || En < 0)
      throw new TypeError("offset must be a uint32");
    if (En > Pe || En > fi)
      throw new RangeError("offset out of range");
  }
  function je(En, fi, bi) {
    if (typeof En != "number" || En !== En)
      throw new TypeError("size must be a number");
    if (En > Me || En < 0)
      throw new TypeError("size must be a uint32");
    if (En + fi > bi || En > Pe)
      throw new RangeError("buffer too small");
  }
  Te && Te.getRandomValues || !process$1$1.browser ? (browser$5.randomFill = fn, browser$5.randomFillSync = vn) : (browser$5.randomFill = Ae, browser$5.randomFillSync = Ae);
  function fn(En, fi, bi, mi) {
    if (!Be.isBuffer(En) && !(En instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof fi == "function")
      mi = fi, fi = 0, bi = En.length;
    else if (typeof bi == "function")
      mi = bi, bi = En.length - fi;
    else if (typeof mi != "function")
      throw new TypeError('"cb" argument must be a function');
    return Ue(fi, En.length), je(bi, fi, En.length), Ve(En, fi, bi, mi);
  }
  function Ve(En, fi, bi, mi) {
    if (process$1$1.browser) {
      var _i = En.buffer, Ei = new Uint8Array(_i, fi, bi);
      if (Te.getRandomValues(Ei), mi) {
        process$1$1.nextTick(function() {
          mi(null, En);
        });
        return;
      }
      return En;
    }
    if (mi) {
      Ie(bi, function(Mi, Oi) {
        if (Mi)
          return mi(Mi);
        Oi.copy(En, fi), mi(null, En);
      });
      return;
    }
    var Si = Ie(bi);
    return Si.copy(En, fi), En;
  }
  function vn(En, fi, bi) {
    if (typeof fi > "u" && (fi = 0), !Be.isBuffer(En) && !(En instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return Ue(fi, En.length), bi === void 0 && (bi = En.length - fi), je(bi, fi, En.length), Ve(En, fi, bi);
  }
  return browser$5;
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$c(), cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$a(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$9();
  var Ae = requireAlgos(), t = Object.keys(Ae), Ie = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(t);
  cryptoBrowserify.getHashes = function() {
    return Ie;
  };
  var Be = requireBrowser$8();
  cryptoBrowserify.pbkdf2 = Be.pbkdf2, cryptoBrowserify.pbkdf2Sync = Be.pbkdf2Sync;
  var Pe = requireBrowser$6();
  cryptoBrowserify.Cipher = Pe.Cipher, cryptoBrowserify.createCipher = Pe.createCipher, cryptoBrowserify.Cipheriv = Pe.Cipheriv, cryptoBrowserify.createCipheriv = Pe.createCipheriv, cryptoBrowserify.Decipher = Pe.Decipher, cryptoBrowserify.createDecipher = Pe.createDecipher, cryptoBrowserify.Decipheriv = Pe.Decipheriv, cryptoBrowserify.createDecipheriv = Pe.createDecipheriv, cryptoBrowserify.getCiphers = Pe.getCiphers, cryptoBrowserify.listCiphers = Pe.listCiphers;
  var Te = requireBrowser$5();
  cryptoBrowserify.DiffieHellmanGroup = Te.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = Te.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = Te.getDiffieHellman, cryptoBrowserify.createDiffieHellman = Te.createDiffieHellman, cryptoBrowserify.DiffieHellman = Te.DiffieHellman;
  var Me = requireBrowser$4();
  cryptoBrowserify.createSign = Me.createSign, cryptoBrowserify.Sign = Me.Sign, cryptoBrowserify.createVerify = Me.createVerify, cryptoBrowserify.Verify = Me.Verify, cryptoBrowserify.createECDH = requireBrowser$3();
  var Ue = requireBrowser$2();
  cryptoBrowserify.publicEncrypt = Ue.publicEncrypt, cryptoBrowserify.privateEncrypt = Ue.privateEncrypt, cryptoBrowserify.publicDecrypt = Ue.publicDecrypt, cryptoBrowserify.privateDecrypt = Ue.privateDecrypt;
  var je = requireBrowser$1();
  return cryptoBrowserify.randomFill = je.randomFill, cryptoBrowserify.randomFillSync = je.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
var hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var Ae;
  brorand.exports = function(Pe) {
    return Ae || (Ae = new t(null)), Ae.generate(Pe);
  };
  function t(Be) {
    this.rand = Be;
  }
  if (brorand.exports.Rand = t, t.prototype.generate = function(Pe) {
    return this._rand(Pe);
  }, t.prototype._rand = function(Pe) {
    if (this.rand.getBytes)
      return this.rand.getBytes(Pe);
    for (var Te = new Uint8Array(Pe), Me = 0; Me < Te.length; Me++)
      Te[Me] = this.rand.getByte();
    return Te;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? t.prototype._rand = function(Pe) {
      var Te = new Uint8Array(Pe);
      return self.crypto.getRandomValues(Te), Te;
    } : self.msCrypto && self.msCrypto.getRandomValues ? t.prototype._rand = function(Pe) {
      var Te = new Uint8Array(Pe);
      return self.msCrypto.getRandomValues(Te), Te;
    } : typeof window == "object" && (t.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var Ie = requireCryptoBrowserify();
      if (typeof Ie.randomBytes != "function")
        throw new Error("Not supported");
      t.prototype._rand = function(Pe) {
        return Ie.randomBytes(Pe);
      };
    } catch {
    }
  return brorand.exports;
}
var curve = {}, base$2, hasRequiredBase;
function requireBase() {
  if (hasRequiredBase) return base$2;
  hasRequiredBase = 1;
  var Ae = requireBn(), t = requireUtils$2(), Ie = t.getNAF, Be = t.getJSF, Pe = t.assert;
  function Te(Ue, je) {
    this.type = Ue, this.p = new Ae(je.p, 16), this.red = je.prime ? Ae.red(je.prime) : Ae.mont(this.p), this.zero = new Ae(0).toRed(this.red), this.one = new Ae(1).toRed(this.red), this.two = new Ae(2).toRed(this.red), this.n = je.n && new Ae(je.n, 16), this.g = je.g && this.pointFromJSON(je.g, je.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var fn = this.n && this.p.div(this.n);
    !fn || fn.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  base$2 = Te, Te.prototype.point = function() {
    throw new Error("Not implemented");
  }, Te.prototype.validate = function() {
    throw new Error("Not implemented");
  }, Te.prototype._fixedNafMul = function(je, fn) {
    Pe(je.precomputed);
    var Ve = je._getDoubles(), vn = Ie(fn, 1, this._bitLength), En = (1 << Ve.step + 1) - (Ve.step % 2 === 0 ? 2 : 1);
    En /= 3;
    var fi = [], bi, mi;
    for (bi = 0; bi < vn.length; bi += Ve.step) {
      mi = 0;
      for (var _i = bi + Ve.step - 1; _i >= bi; _i--)
        mi = (mi << 1) + vn[_i];
      fi.push(mi);
    }
    for (var Ei = this.jpoint(null, null, null), Si = this.jpoint(null, null, null), Mi = En; Mi > 0; Mi--) {
      for (bi = 0; bi < fi.length; bi++)
        mi = fi[bi], mi === Mi ? Si = Si.mixedAdd(Ve.points[bi]) : mi === -Mi && (Si = Si.mixedAdd(Ve.points[bi].neg()));
      Ei = Ei.add(Si);
    }
    return Ei.toP();
  }, Te.prototype._wnafMul = function(je, fn) {
    var Ve = 4, vn = je._getNAFPoints(Ve);
    Ve = vn.wnd;
    for (var En = vn.points, fi = Ie(fn, Ve, this._bitLength), bi = this.jpoint(null, null, null), mi = fi.length - 1; mi >= 0; mi--) {
      for (var _i = 0; mi >= 0 && fi[mi] === 0; mi--)
        _i++;
      if (mi >= 0 && _i++, bi = bi.dblp(_i), mi < 0)
        break;
      var Ei = fi[mi];
      Pe(Ei !== 0), je.type === "affine" ? Ei > 0 ? bi = bi.mixedAdd(En[Ei - 1 >> 1]) : bi = bi.mixedAdd(En[-Ei - 1 >> 1].neg()) : Ei > 0 ? bi = bi.add(En[Ei - 1 >> 1]) : bi = bi.add(En[-Ei - 1 >> 1].neg());
    }
    return je.type === "affine" ? bi.toP() : bi;
  }, Te.prototype._wnafMulAdd = function(je, fn, Ve, vn, En) {
    var fi = this._wnafT1, bi = this._wnafT2, mi = this._wnafT3, _i = 0, Ei, Si, Mi;
    for (Ei = 0; Ei < vn; Ei++) {
      Mi = fn[Ei];
      var Oi = Mi._getNAFPoints(je);
      fi[Ei] = Oi.wnd, bi[Ei] = Oi.points;
    }
    for (Ei = vn - 1; Ei >= 1; Ei -= 2) {
      var Fi = Ei - 1, Ui = Ei;
      if (fi[Fi] !== 1 || fi[Ui] !== 1) {
        mi[Fi] = Ie(Ve[Fi], fi[Fi], this._bitLength), mi[Ui] = Ie(Ve[Ui], fi[Ui], this._bitLength), _i = Math.max(mi[Fi].length, _i), _i = Math.max(mi[Ui].length, _i);
        continue;
      }
      var Pi = [
        fn[Fi],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        fn[Ui]
        /* 7 */
      ];
      fn[Fi].y.cmp(fn[Ui].y) === 0 ? (Pi[1] = fn[Fi].add(fn[Ui]), Pi[2] = fn[Fi].toJ().mixedAdd(fn[Ui].neg())) : fn[Fi].y.cmp(fn[Ui].y.redNeg()) === 0 ? (Pi[1] = fn[Fi].toJ().mixedAdd(fn[Ui]), Pi[2] = fn[Fi].add(fn[Ui].neg())) : (Pi[1] = fn[Fi].toJ().mixedAdd(fn[Ui]), Pi[2] = fn[Fi].toJ().mixedAdd(fn[Ui].neg()));
      var Bi = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], ji = Be(Ve[Fi], Ve[Ui]);
      for (_i = Math.max(ji[0].length, _i), mi[Fi] = new Array(_i), mi[Ui] = new Array(_i), Si = 0; Si < _i; Si++) {
        var Zi = ji[0][Si] | 0, zi = ji[1][Si] | 0;
        mi[Fi][Si] = Bi[(Zi + 1) * 3 + (zi + 1)], mi[Ui][Si] = 0, bi[Fi] = Pi;
      }
    }
    var xi = this.jpoint(null, null, null), $i = this._wnafT4;
    for (Ei = _i; Ei >= 0; Ei--) {
      for (var vi = 0; Ei >= 0; ) {
        var wi = !0;
        for (Si = 0; Si < vn; Si++)
          $i[Si] = mi[Si][Ei] | 0, $i[Si] !== 0 && (wi = !1);
        if (!wi)
          break;
        vi++, Ei--;
      }
      if (Ei >= 0 && vi++, xi = xi.dblp(vi), Ei < 0)
        break;
      for (Si = 0; Si < vn; Si++) {
        var Ai = $i[Si];
        Ai !== 0 && (Ai > 0 ? Mi = bi[Si][Ai - 1 >> 1] : Ai < 0 && (Mi = bi[Si][-Ai - 1 >> 1].neg()), Mi.type === "affine" ? xi = xi.mixedAdd(Mi) : xi = xi.add(Mi));
      }
    }
    for (Ei = 0; Ei < vn; Ei++)
      bi[Ei] = null;
    return En ? xi : xi.toP();
  };
  function Me(Ue, je) {
    this.curve = Ue, this.type = je, this.precomputed = null;
  }
  return Te.BasePoint = Me, Me.prototype.eq = function() {
    throw new Error("Not implemented");
  }, Me.prototype.validate = function() {
    return this.curve.validate(this);
  }, Te.prototype.decodePoint = function(je, fn) {
    je = t.toArray(je, fn);
    var Ve = this.p.byteLength();
    if ((je[0] === 4 || je[0] === 6 || je[0] === 7) && je.length - 1 === 2 * Ve) {
      je[0] === 6 ? Pe(je[je.length - 1] % 2 === 0) : je[0] === 7 && Pe(je[je.length - 1] % 2 === 1);
      var vn = this.point(
        je.slice(1, 1 + Ve),
        je.slice(1 + Ve, 1 + 2 * Ve)
      );
      return vn;
    } else if ((je[0] === 2 || je[0] === 3) && je.length - 1 === Ve)
      return this.pointFromX(je.slice(1, 1 + Ve), je[0] === 3);
    throw new Error("Unknown point format");
  }, Me.prototype.encodeCompressed = function(je) {
    return this.encode(je, !0);
  }, Me.prototype._encode = function(je) {
    var fn = this.curve.p.byteLength(), Ve = this.getX().toArray("be", fn);
    return je ? [this.getY().isEven() ? 2 : 3].concat(Ve) : [4].concat(Ve, this.getY().toArray("be", fn));
  }, Me.prototype.encode = function(je, fn) {
    return t.encode(this._encode(fn), je);
  }, Me.prototype.precompute = function(je) {
    if (this.precomputed)
      return this;
    var fn = {
      doubles: null,
      naf: null,
      beta: null
    };
    return fn.naf = this._getNAFPoints(8), fn.doubles = this._getDoubles(4, je), fn.beta = this._getBeta(), this.precomputed = fn, this;
  }, Me.prototype._hasDoubles = function(je) {
    if (!this.precomputed)
      return !1;
    var fn = this.precomputed.doubles;
    return fn ? fn.points.length >= Math.ceil((je.bitLength() + 1) / fn.step) : !1;
  }, Me.prototype._getDoubles = function(je, fn) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var Ve = [this], vn = this, En = 0; En < fn; En += je) {
      for (var fi = 0; fi < je; fi++)
        vn = vn.dbl();
      Ve.push(vn);
    }
    return {
      step: je,
      points: Ve
    };
  }, Me.prototype._getNAFPoints = function(je) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var fn = [this], Ve = (1 << je) - 1, vn = Ve === 1 ? null : this.dbl(), En = 1; En < Ve; En++)
      fn[En] = fn[En - 1].add(vn);
    return {
      wnd: je,
      points: fn
    };
  }, Me.prototype._getBeta = function() {
    return null;
  }, Me.prototype.dblp = function(je) {
    for (var fn = this, Ve = 0; Ve < je; Ve++)
      fn = fn.dbl();
    return fn;
  }, base$2;
}
var short, hasRequiredShort;
function requireShort() {
  if (hasRequiredShort) return short;
  hasRequiredShort = 1;
  var Ae = requireUtils$2(), t = requireBn(), Ie = requireInherits_browser(), Be = requireBase(), Pe = Ae.assert;
  function Te(je) {
    Be.call(this, "short", je), this.a = new t(je.a, 16).toRed(this.red), this.b = new t(je.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(je), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  Ie(Te, Be), short = Te, Te.prototype._getEndomorphism = function(fn) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var Ve, vn;
      if (fn.beta)
        Ve = new t(fn.beta, 16).toRed(this.red);
      else {
        var En = this._getEndoRoots(this.p);
        Ve = En[0].cmp(En[1]) < 0 ? En[0] : En[1], Ve = Ve.toRed(this.red);
      }
      if (fn.lambda)
        vn = new t(fn.lambda, 16);
      else {
        var fi = this._getEndoRoots(this.n);
        this.g.mul(fi[0]).x.cmp(this.g.x.redMul(Ve)) === 0 ? vn = fi[0] : (vn = fi[1], Pe(this.g.mul(vn).x.cmp(this.g.x.redMul(Ve)) === 0));
      }
      var bi;
      return fn.basis ? bi = fn.basis.map(function(mi) {
        return {
          a: new t(mi.a, 16),
          b: new t(mi.b, 16)
        };
      }) : bi = this._getEndoBasis(vn), {
        beta: Ve,
        lambda: vn,
        basis: bi
      };
    }
  }, Te.prototype._getEndoRoots = function(fn) {
    var Ve = fn === this.p ? this.red : t.mont(fn), vn = new t(2).toRed(Ve).redInvm(), En = vn.redNeg(), fi = new t(3).toRed(Ve).redNeg().redSqrt().redMul(vn), bi = En.redAdd(fi).fromRed(), mi = En.redSub(fi).fromRed();
    return [bi, mi];
  }, Te.prototype._getEndoBasis = function(fn) {
    for (var Ve = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), vn = fn, En = this.n.clone(), fi = new t(1), bi = new t(0), mi = new t(0), _i = new t(1), Ei, Si, Mi, Oi, Fi, Ui, Pi, Bi = 0, ji, Zi; vn.cmpn(0) !== 0; ) {
      var zi = En.div(vn);
      ji = En.sub(zi.mul(vn)), Zi = mi.sub(zi.mul(fi));
      var xi = _i.sub(zi.mul(bi));
      if (!Mi && ji.cmp(Ve) < 0)
        Ei = Pi.neg(), Si = fi, Mi = ji.neg(), Oi = Zi;
      else if (Mi && ++Bi === 2)
        break;
      Pi = ji, En = vn, vn = ji, mi = fi, fi = Zi, _i = bi, bi = xi;
    }
    Fi = ji.neg(), Ui = Zi;
    var $i = Mi.sqr().add(Oi.sqr()), vi = Fi.sqr().add(Ui.sqr());
    return vi.cmp($i) >= 0 && (Fi = Ei, Ui = Si), Mi.negative && (Mi = Mi.neg(), Oi = Oi.neg()), Fi.negative && (Fi = Fi.neg(), Ui = Ui.neg()), [
      { a: Mi, b: Oi },
      { a: Fi, b: Ui }
    ];
  }, Te.prototype._endoSplit = function(fn) {
    var Ve = this.endo.basis, vn = Ve[0], En = Ve[1], fi = En.b.mul(fn).divRound(this.n), bi = vn.b.neg().mul(fn).divRound(this.n), mi = fi.mul(vn.a), _i = bi.mul(En.a), Ei = fi.mul(vn.b), Si = bi.mul(En.b), Mi = fn.sub(mi).sub(_i), Oi = Ei.add(Si).neg();
    return { k1: Mi, k2: Oi };
  }, Te.prototype.pointFromX = function(fn, Ve) {
    fn = new t(fn, 16), fn.red || (fn = fn.toRed(this.red));
    var vn = fn.redSqr().redMul(fn).redIAdd(fn.redMul(this.a)).redIAdd(this.b), En = vn.redSqrt();
    if (En.redSqr().redSub(vn).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var fi = En.fromRed().isOdd();
    return (Ve && !fi || !Ve && fi) && (En = En.redNeg()), this.point(fn, En);
  }, Te.prototype.validate = function(fn) {
    if (fn.inf)
      return !0;
    var Ve = fn.x, vn = fn.y, En = this.a.redMul(Ve), fi = Ve.redSqr().redMul(Ve).redIAdd(En).redIAdd(this.b);
    return vn.redSqr().redISub(fi).cmpn(0) === 0;
  }, Te.prototype._endoWnafMulAdd = function(fn, Ve, vn) {
    for (var En = this._endoWnafT1, fi = this._endoWnafT2, bi = 0; bi < fn.length; bi++) {
      var mi = this._endoSplit(Ve[bi]), _i = fn[bi], Ei = _i._getBeta();
      mi.k1.negative && (mi.k1.ineg(), _i = _i.neg(!0)), mi.k2.negative && (mi.k2.ineg(), Ei = Ei.neg(!0)), En[bi * 2] = _i, En[bi * 2 + 1] = Ei, fi[bi * 2] = mi.k1, fi[bi * 2 + 1] = mi.k2;
    }
    for (var Si = this._wnafMulAdd(1, En, fi, bi * 2, vn), Mi = 0; Mi < bi * 2; Mi++)
      En[Mi] = null, fi[Mi] = null;
    return Si;
  };
  function Me(je, fn, Ve, vn) {
    Be.BasePoint.call(this, je, "affine"), fn === null && Ve === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new t(fn, 16), this.y = new t(Ve, 16), vn && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  Ie(Me, Be.BasePoint), Te.prototype.point = function(fn, Ve, vn) {
    return new Me(this, fn, Ve, vn);
  }, Te.prototype.pointFromJSON = function(fn, Ve) {
    return Me.fromJSON(this, fn, Ve);
  }, Me.prototype._getBeta = function() {
    if (this.curve.endo) {
      var fn = this.precomputed;
      if (fn && fn.beta)
        return fn.beta;
      var Ve = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (fn) {
        var vn = this.curve, En = function(fi) {
          return vn.point(fi.x.redMul(vn.endo.beta), fi.y);
        };
        fn.beta = Ve, Ve.precomputed = {
          beta: null,
          naf: fn.naf && {
            wnd: fn.naf.wnd,
            points: fn.naf.points.map(En)
          },
          doubles: fn.doubles && {
            step: fn.doubles.step,
            points: fn.doubles.points.map(En)
          }
        };
      }
      return Ve;
    }
  }, Me.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, Me.fromJSON = function(fn, Ve, vn) {
    typeof Ve == "string" && (Ve = JSON.parse(Ve));
    var En = fn.point(Ve[0], Ve[1], vn);
    if (!Ve[2])
      return En;
    function fi(mi) {
      return fn.point(mi[0], mi[1], vn);
    }
    var bi = Ve[2];
    return En.precomputed = {
      beta: null,
      doubles: bi.doubles && {
        step: bi.doubles.step,
        points: [En].concat(bi.doubles.points.map(fi))
      },
      naf: bi.naf && {
        wnd: bi.naf.wnd,
        points: [En].concat(bi.naf.points.map(fi))
      }
    }, En;
  }, Me.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, Me.prototype.isInfinity = function() {
    return this.inf;
  }, Me.prototype.add = function(fn) {
    if (this.inf)
      return fn;
    if (fn.inf)
      return this;
    if (this.eq(fn))
      return this.dbl();
    if (this.neg().eq(fn))
      return this.curve.point(null, null);
    if (this.x.cmp(fn.x) === 0)
      return this.curve.point(null, null);
    var Ve = this.y.redSub(fn.y);
    Ve.cmpn(0) !== 0 && (Ve = Ve.redMul(this.x.redSub(fn.x).redInvm()));
    var vn = Ve.redSqr().redISub(this.x).redISub(fn.x), En = Ve.redMul(this.x.redSub(vn)).redISub(this.y);
    return this.curve.point(vn, En);
  }, Me.prototype.dbl = function() {
    if (this.inf)
      return this;
    var fn = this.y.redAdd(this.y);
    if (fn.cmpn(0) === 0)
      return this.curve.point(null, null);
    var Ve = this.curve.a, vn = this.x.redSqr(), En = fn.redInvm(), fi = vn.redAdd(vn).redIAdd(vn).redIAdd(Ve).redMul(En), bi = fi.redSqr().redISub(this.x.redAdd(this.x)), mi = fi.redMul(this.x.redSub(bi)).redISub(this.y);
    return this.curve.point(bi, mi);
  }, Me.prototype.getX = function() {
    return this.x.fromRed();
  }, Me.prototype.getY = function() {
    return this.y.fromRed();
  }, Me.prototype.mul = function(fn) {
    return fn = new t(fn, 16), this.isInfinity() ? this : this._hasDoubles(fn) ? this.curve._fixedNafMul(this, fn) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [fn]) : this.curve._wnafMul(this, fn);
  }, Me.prototype.mulAdd = function(fn, Ve, vn) {
    var En = [this, Ve], fi = [fn, vn];
    return this.curve.endo ? this.curve._endoWnafMulAdd(En, fi) : this.curve._wnafMulAdd(1, En, fi, 2);
  }, Me.prototype.jmulAdd = function(fn, Ve, vn) {
    var En = [this, Ve], fi = [fn, vn];
    return this.curve.endo ? this.curve._endoWnafMulAdd(En, fi, !0) : this.curve._wnafMulAdd(1, En, fi, 2, !0);
  }, Me.prototype.eq = function(fn) {
    return this === fn || this.inf === fn.inf && (this.inf || this.x.cmp(fn.x) === 0 && this.y.cmp(fn.y) === 0);
  }, Me.prototype.neg = function(fn) {
    if (this.inf)
      return this;
    var Ve = this.curve.point(this.x, this.y.redNeg());
    if (fn && this.precomputed) {
      var vn = this.precomputed, En = function(fi) {
        return fi.neg();
      };
      Ve.precomputed = {
        naf: vn.naf && {
          wnd: vn.naf.wnd,
          points: vn.naf.points.map(En)
        },
        doubles: vn.doubles && {
          step: vn.doubles.step,
          points: vn.doubles.points.map(En)
        }
      };
    }
    return Ve;
  }, Me.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var fn = this.curve.jpoint(this.x, this.y, this.curve.one);
    return fn;
  };
  function Ue(je, fn, Ve, vn) {
    Be.BasePoint.call(this, je, "jacobian"), fn === null && Ve === null && vn === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new t(0)) : (this.x = new t(fn, 16), this.y = new t(Ve, 16), this.z = new t(vn, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return Ie(Ue, Be.BasePoint), Te.prototype.jpoint = function(fn, Ve, vn) {
    return new Ue(this, fn, Ve, vn);
  }, Ue.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var fn = this.z.redInvm(), Ve = fn.redSqr(), vn = this.x.redMul(Ve), En = this.y.redMul(Ve).redMul(fn);
    return this.curve.point(vn, En);
  }, Ue.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, Ue.prototype.add = function(fn) {
    if (this.isInfinity())
      return fn;
    if (fn.isInfinity())
      return this;
    var Ve = fn.z.redSqr(), vn = this.z.redSqr(), En = this.x.redMul(Ve), fi = fn.x.redMul(vn), bi = this.y.redMul(Ve.redMul(fn.z)), mi = fn.y.redMul(vn.redMul(this.z)), _i = En.redSub(fi), Ei = bi.redSub(mi);
    if (_i.cmpn(0) === 0)
      return Ei.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var Si = _i.redSqr(), Mi = Si.redMul(_i), Oi = En.redMul(Si), Fi = Ei.redSqr().redIAdd(Mi).redISub(Oi).redISub(Oi), Ui = Ei.redMul(Oi.redISub(Fi)).redISub(bi.redMul(Mi)), Pi = this.z.redMul(fn.z).redMul(_i);
    return this.curve.jpoint(Fi, Ui, Pi);
  }, Ue.prototype.mixedAdd = function(fn) {
    if (this.isInfinity())
      return fn.toJ();
    if (fn.isInfinity())
      return this;
    var Ve = this.z.redSqr(), vn = this.x, En = fn.x.redMul(Ve), fi = this.y, bi = fn.y.redMul(Ve).redMul(this.z), mi = vn.redSub(En), _i = fi.redSub(bi);
    if (mi.cmpn(0) === 0)
      return _i.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var Ei = mi.redSqr(), Si = Ei.redMul(mi), Mi = vn.redMul(Ei), Oi = _i.redSqr().redIAdd(Si).redISub(Mi).redISub(Mi), Fi = _i.redMul(Mi.redISub(Oi)).redISub(fi.redMul(Si)), Ui = this.z.redMul(mi);
    return this.curve.jpoint(Oi, Fi, Ui);
  }, Ue.prototype.dblp = function(fn) {
    if (fn === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!fn)
      return this.dbl();
    var Ve;
    if (this.curve.zeroA || this.curve.threeA) {
      var vn = this;
      for (Ve = 0; Ve < fn; Ve++)
        vn = vn.dbl();
      return vn;
    }
    var En = this.curve.a, fi = this.curve.tinv, bi = this.x, mi = this.y, _i = this.z, Ei = _i.redSqr().redSqr(), Si = mi.redAdd(mi);
    for (Ve = 0; Ve < fn; Ve++) {
      var Mi = bi.redSqr(), Oi = Si.redSqr(), Fi = Oi.redSqr(), Ui = Mi.redAdd(Mi).redIAdd(Mi).redIAdd(En.redMul(Ei)), Pi = bi.redMul(Oi), Bi = Ui.redSqr().redISub(Pi.redAdd(Pi)), ji = Pi.redISub(Bi), Zi = Ui.redMul(ji);
      Zi = Zi.redIAdd(Zi).redISub(Fi);
      var zi = Si.redMul(_i);
      Ve + 1 < fn && (Ei = Ei.redMul(Fi)), bi = Bi, _i = zi, Si = Zi;
    }
    return this.curve.jpoint(bi, Si.redMul(fi), _i);
  }, Ue.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, Ue.prototype._zeroDbl = function() {
    var fn, Ve, vn;
    if (this.zOne) {
      var En = this.x.redSqr(), fi = this.y.redSqr(), bi = fi.redSqr(), mi = this.x.redAdd(fi).redSqr().redISub(En).redISub(bi);
      mi = mi.redIAdd(mi);
      var _i = En.redAdd(En).redIAdd(En), Ei = _i.redSqr().redISub(mi).redISub(mi), Si = bi.redIAdd(bi);
      Si = Si.redIAdd(Si), Si = Si.redIAdd(Si), fn = Ei, Ve = _i.redMul(mi.redISub(Ei)).redISub(Si), vn = this.y.redAdd(this.y);
    } else {
      var Mi = this.x.redSqr(), Oi = this.y.redSqr(), Fi = Oi.redSqr(), Ui = this.x.redAdd(Oi).redSqr().redISub(Mi).redISub(Fi);
      Ui = Ui.redIAdd(Ui);
      var Pi = Mi.redAdd(Mi).redIAdd(Mi), Bi = Pi.redSqr(), ji = Fi.redIAdd(Fi);
      ji = ji.redIAdd(ji), ji = ji.redIAdd(ji), fn = Bi.redISub(Ui).redISub(Ui), Ve = Pi.redMul(Ui.redISub(fn)).redISub(ji), vn = this.y.redMul(this.z), vn = vn.redIAdd(vn);
    }
    return this.curve.jpoint(fn, Ve, vn);
  }, Ue.prototype._threeDbl = function() {
    var fn, Ve, vn;
    if (this.zOne) {
      var En = this.x.redSqr(), fi = this.y.redSqr(), bi = fi.redSqr(), mi = this.x.redAdd(fi).redSqr().redISub(En).redISub(bi);
      mi = mi.redIAdd(mi);
      var _i = En.redAdd(En).redIAdd(En).redIAdd(this.curve.a), Ei = _i.redSqr().redISub(mi).redISub(mi);
      fn = Ei;
      var Si = bi.redIAdd(bi);
      Si = Si.redIAdd(Si), Si = Si.redIAdd(Si), Ve = _i.redMul(mi.redISub(Ei)).redISub(Si), vn = this.y.redAdd(this.y);
    } else {
      var Mi = this.z.redSqr(), Oi = this.y.redSqr(), Fi = this.x.redMul(Oi), Ui = this.x.redSub(Mi).redMul(this.x.redAdd(Mi));
      Ui = Ui.redAdd(Ui).redIAdd(Ui);
      var Pi = Fi.redIAdd(Fi);
      Pi = Pi.redIAdd(Pi);
      var Bi = Pi.redAdd(Pi);
      fn = Ui.redSqr().redISub(Bi), vn = this.y.redAdd(this.z).redSqr().redISub(Oi).redISub(Mi);
      var ji = Oi.redSqr();
      ji = ji.redIAdd(ji), ji = ji.redIAdd(ji), ji = ji.redIAdd(ji), Ve = Ui.redMul(Pi.redISub(fn)).redISub(ji);
    }
    return this.curve.jpoint(fn, Ve, vn);
  }, Ue.prototype._dbl = function() {
    var fn = this.curve.a, Ve = this.x, vn = this.y, En = this.z, fi = En.redSqr().redSqr(), bi = Ve.redSqr(), mi = vn.redSqr(), _i = bi.redAdd(bi).redIAdd(bi).redIAdd(fn.redMul(fi)), Ei = Ve.redAdd(Ve);
    Ei = Ei.redIAdd(Ei);
    var Si = Ei.redMul(mi), Mi = _i.redSqr().redISub(Si.redAdd(Si)), Oi = Si.redISub(Mi), Fi = mi.redSqr();
    Fi = Fi.redIAdd(Fi), Fi = Fi.redIAdd(Fi), Fi = Fi.redIAdd(Fi);
    var Ui = _i.redMul(Oi).redISub(Fi), Pi = vn.redAdd(vn).redMul(En);
    return this.curve.jpoint(Mi, Ui, Pi);
  }, Ue.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var fn = this.x.redSqr(), Ve = this.y.redSqr(), vn = this.z.redSqr(), En = Ve.redSqr(), fi = fn.redAdd(fn).redIAdd(fn), bi = fi.redSqr(), mi = this.x.redAdd(Ve).redSqr().redISub(fn).redISub(En);
    mi = mi.redIAdd(mi), mi = mi.redAdd(mi).redIAdd(mi), mi = mi.redISub(bi);
    var _i = mi.redSqr(), Ei = En.redIAdd(En);
    Ei = Ei.redIAdd(Ei), Ei = Ei.redIAdd(Ei), Ei = Ei.redIAdd(Ei);
    var Si = fi.redIAdd(mi).redSqr().redISub(bi).redISub(_i).redISub(Ei), Mi = Ve.redMul(Si);
    Mi = Mi.redIAdd(Mi), Mi = Mi.redIAdd(Mi);
    var Oi = this.x.redMul(_i).redISub(Mi);
    Oi = Oi.redIAdd(Oi), Oi = Oi.redIAdd(Oi);
    var Fi = this.y.redMul(Si.redMul(Ei.redISub(Si)).redISub(mi.redMul(_i)));
    Fi = Fi.redIAdd(Fi), Fi = Fi.redIAdd(Fi), Fi = Fi.redIAdd(Fi);
    var Ui = this.z.redAdd(mi).redSqr().redISub(vn).redISub(_i);
    return this.curve.jpoint(Oi, Fi, Ui);
  }, Ue.prototype.mul = function(fn, Ve) {
    return fn = new t(fn, Ve), this.curve._wnafMul(this, fn);
  }, Ue.prototype.eq = function(fn) {
    if (fn.type === "affine")
      return this.eq(fn.toJ());
    if (this === fn)
      return !0;
    var Ve = this.z.redSqr(), vn = fn.z.redSqr();
    if (this.x.redMul(vn).redISub(fn.x.redMul(Ve)).cmpn(0) !== 0)
      return !1;
    var En = Ve.redMul(this.z), fi = vn.redMul(fn.z);
    return this.y.redMul(fi).redISub(fn.y.redMul(En)).cmpn(0) === 0;
  }, Ue.prototype.eqXToP = function(fn) {
    var Ve = this.z.redSqr(), vn = fn.toRed(this.curve.red).redMul(Ve);
    if (this.x.cmp(vn) === 0)
      return !0;
    for (var En = fn.clone(), fi = this.curve.redN.redMul(Ve); ; ) {
      if (En.iadd(this.curve.n), En.cmp(this.curve.p) >= 0)
        return !1;
      if (vn.redIAdd(fi), this.x.cmp(vn) === 0)
        return !0;
    }
  }, Ue.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, Ue.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, short;
}
var mont, hasRequiredMont;
function requireMont() {
  if (hasRequiredMont) return mont;
  hasRequiredMont = 1;
  var Ae = requireBn(), t = requireInherits_browser(), Ie = requireBase(), Be = requireUtils$2();
  function Pe(Me) {
    Ie.call(this, "mont", Me), this.a = new Ae(Me.a, 16).toRed(this.red), this.b = new Ae(Me.b, 16).toRed(this.red), this.i4 = new Ae(4).toRed(this.red).redInvm(), this.two = new Ae(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  t(Pe, Ie), mont = Pe, Pe.prototype.validate = function(Ue) {
    var je = Ue.normalize().x, fn = je.redSqr(), Ve = fn.redMul(je).redAdd(fn.redMul(this.a)).redAdd(je), vn = Ve.redSqrt();
    return vn.redSqr().cmp(Ve) === 0;
  };
  function Te(Me, Ue, je) {
    Ie.BasePoint.call(this, Me, "projective"), Ue === null && je === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new Ae(Ue, 16), this.z = new Ae(je, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return t(Te, Ie.BasePoint), Pe.prototype.decodePoint = function(Ue, je) {
    return this.point(Be.toArray(Ue, je), 1);
  }, Pe.prototype.point = function(Ue, je) {
    return new Te(this, Ue, je);
  }, Pe.prototype.pointFromJSON = function(Ue) {
    return Te.fromJSON(this, Ue);
  }, Te.prototype.precompute = function() {
  }, Te.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, Te.fromJSON = function(Ue, je) {
    return new Te(Ue, je[0], je[1] || Ue.one);
  }, Te.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, Te.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, Te.prototype.dbl = function() {
    var Ue = this.x.redAdd(this.z), je = Ue.redSqr(), fn = this.x.redSub(this.z), Ve = fn.redSqr(), vn = je.redSub(Ve), En = je.redMul(Ve), fi = vn.redMul(Ve.redAdd(this.curve.a24.redMul(vn)));
    return this.curve.point(En, fi);
  }, Te.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, Te.prototype.diffAdd = function(Ue, je) {
    var fn = this.x.redAdd(this.z), Ve = this.x.redSub(this.z), vn = Ue.x.redAdd(Ue.z), En = Ue.x.redSub(Ue.z), fi = En.redMul(fn), bi = vn.redMul(Ve), mi = je.z.redMul(fi.redAdd(bi).redSqr()), _i = je.x.redMul(fi.redISub(bi).redSqr());
    return this.curve.point(mi, _i);
  }, Te.prototype.mul = function(Ue) {
    for (var je = Ue.clone(), fn = this, Ve = this.curve.point(null, null), vn = this, En = []; je.cmpn(0) !== 0; je.iushrn(1))
      En.push(je.andln(1));
    for (var fi = En.length - 1; fi >= 0; fi--)
      En[fi] === 0 ? (fn = fn.diffAdd(Ve, vn), Ve = Ve.dbl()) : (Ve = fn.diffAdd(Ve, vn), fn = fn.dbl());
    return Ve;
  }, Te.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, Te.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, Te.prototype.eq = function(Ue) {
    return this.getX().cmp(Ue.getX()) === 0;
  }, Te.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, Te.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, mont;
}
var edwards, hasRequiredEdwards;
function requireEdwards() {
  if (hasRequiredEdwards) return edwards;
  hasRequiredEdwards = 1;
  var Ae = requireUtils$2(), t = requireBn(), Ie = requireInherits_browser(), Be = requireBase(), Pe = Ae.assert;
  function Te(Ue) {
    this.twisted = (Ue.a | 0) !== 1, this.mOneA = this.twisted && (Ue.a | 0) === -1, this.extended = this.mOneA, Be.call(this, "edwards", Ue), this.a = new t(Ue.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new t(Ue.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new t(Ue.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), Pe(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (Ue.c | 0) === 1;
  }
  Ie(Te, Be), edwards = Te, Te.prototype._mulA = function(je) {
    return this.mOneA ? je.redNeg() : this.a.redMul(je);
  }, Te.prototype._mulC = function(je) {
    return this.oneC ? je : this.c.redMul(je);
  }, Te.prototype.jpoint = function(je, fn, Ve, vn) {
    return this.point(je, fn, Ve, vn);
  }, Te.prototype.pointFromX = function(je, fn) {
    je = new t(je, 16), je.red || (je = je.toRed(this.red));
    var Ve = je.redSqr(), vn = this.c2.redSub(this.a.redMul(Ve)), En = this.one.redSub(this.c2.redMul(this.d).redMul(Ve)), fi = vn.redMul(En.redInvm()), bi = fi.redSqrt();
    if (bi.redSqr().redSub(fi).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var mi = bi.fromRed().isOdd();
    return (fn && !mi || !fn && mi) && (bi = bi.redNeg()), this.point(je, bi);
  }, Te.prototype.pointFromY = function(je, fn) {
    je = new t(je, 16), je.red || (je = je.toRed(this.red));
    var Ve = je.redSqr(), vn = Ve.redSub(this.c2), En = Ve.redMul(this.d).redMul(this.c2).redSub(this.a), fi = vn.redMul(En.redInvm());
    if (fi.cmp(this.zero) === 0) {
      if (fn)
        throw new Error("invalid point");
      return this.point(this.zero, je);
    }
    var bi = fi.redSqrt();
    if (bi.redSqr().redSub(fi).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return bi.fromRed().isOdd() !== fn && (bi = bi.redNeg()), this.point(bi, je);
  }, Te.prototype.validate = function(je) {
    if (je.isInfinity())
      return !0;
    je.normalize();
    var fn = je.x.redSqr(), Ve = je.y.redSqr(), vn = fn.redMul(this.a).redAdd(Ve), En = this.c2.redMul(this.one.redAdd(this.d.redMul(fn).redMul(Ve)));
    return vn.cmp(En) === 0;
  };
  function Me(Ue, je, fn, Ve, vn) {
    Be.BasePoint.call(this, Ue, "projective"), je === null && fn === null && Ve === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new t(je, 16), this.y = new t(fn, 16), this.z = Ve ? new t(Ve, 16) : this.curve.one, this.t = vn && new t(vn, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return Ie(Me, Be.BasePoint), Te.prototype.pointFromJSON = function(je) {
    return Me.fromJSON(this, je);
  }, Te.prototype.point = function(je, fn, Ve, vn) {
    return new Me(this, je, fn, Ve, vn);
  }, Me.fromJSON = function(je, fn) {
    return new Me(je, fn[0], fn[1], fn[2]);
  }, Me.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, Me.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, Me.prototype._extDbl = function() {
    var je = this.x.redSqr(), fn = this.y.redSqr(), Ve = this.z.redSqr();
    Ve = Ve.redIAdd(Ve);
    var vn = this.curve._mulA(je), En = this.x.redAdd(this.y).redSqr().redISub(je).redISub(fn), fi = vn.redAdd(fn), bi = fi.redSub(Ve), mi = vn.redSub(fn), _i = En.redMul(bi), Ei = fi.redMul(mi), Si = En.redMul(mi), Mi = bi.redMul(fi);
    return this.curve.point(_i, Ei, Mi, Si);
  }, Me.prototype._projDbl = function() {
    var je = this.x.redAdd(this.y).redSqr(), fn = this.x.redSqr(), Ve = this.y.redSqr(), vn, En, fi, bi, mi, _i;
    if (this.curve.twisted) {
      bi = this.curve._mulA(fn);
      var Ei = bi.redAdd(Ve);
      this.zOne ? (vn = je.redSub(fn).redSub(Ve).redMul(Ei.redSub(this.curve.two)), En = Ei.redMul(bi.redSub(Ve)), fi = Ei.redSqr().redSub(Ei).redSub(Ei)) : (mi = this.z.redSqr(), _i = Ei.redSub(mi).redISub(mi), vn = je.redSub(fn).redISub(Ve).redMul(_i), En = Ei.redMul(bi.redSub(Ve)), fi = Ei.redMul(_i));
    } else
      bi = fn.redAdd(Ve), mi = this.curve._mulC(this.z).redSqr(), _i = bi.redSub(mi).redSub(mi), vn = this.curve._mulC(je.redISub(bi)).redMul(_i), En = this.curve._mulC(bi).redMul(fn.redISub(Ve)), fi = bi.redMul(_i);
    return this.curve.point(vn, En, fi);
  }, Me.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, Me.prototype._extAdd = function(je) {
    var fn = this.y.redSub(this.x).redMul(je.y.redSub(je.x)), Ve = this.y.redAdd(this.x).redMul(je.y.redAdd(je.x)), vn = this.t.redMul(this.curve.dd).redMul(je.t), En = this.z.redMul(je.z.redAdd(je.z)), fi = Ve.redSub(fn), bi = En.redSub(vn), mi = En.redAdd(vn), _i = Ve.redAdd(fn), Ei = fi.redMul(bi), Si = mi.redMul(_i), Mi = fi.redMul(_i), Oi = bi.redMul(mi);
    return this.curve.point(Ei, Si, Oi, Mi);
  }, Me.prototype._projAdd = function(je) {
    var fn = this.z.redMul(je.z), Ve = fn.redSqr(), vn = this.x.redMul(je.x), En = this.y.redMul(je.y), fi = this.curve.d.redMul(vn).redMul(En), bi = Ve.redSub(fi), mi = Ve.redAdd(fi), _i = this.x.redAdd(this.y).redMul(je.x.redAdd(je.y)).redISub(vn).redISub(En), Ei = fn.redMul(bi).redMul(_i), Si, Mi;
    return this.curve.twisted ? (Si = fn.redMul(mi).redMul(En.redSub(this.curve._mulA(vn))), Mi = bi.redMul(mi)) : (Si = fn.redMul(mi).redMul(En.redSub(vn)), Mi = this.curve._mulC(bi).redMul(mi)), this.curve.point(Ei, Si, Mi);
  }, Me.prototype.add = function(je) {
    return this.isInfinity() ? je : je.isInfinity() ? this : this.curve.extended ? this._extAdd(je) : this._projAdd(je);
  }, Me.prototype.mul = function(je) {
    return this._hasDoubles(je) ? this.curve._fixedNafMul(this, je) : this.curve._wnafMul(this, je);
  }, Me.prototype.mulAdd = function(je, fn, Ve) {
    return this.curve._wnafMulAdd(1, [this, fn], [je, Ve], 2, !1);
  }, Me.prototype.jmulAdd = function(je, fn, Ve) {
    return this.curve._wnafMulAdd(1, [this, fn], [je, Ve], 2, !0);
  }, Me.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var je = this.z.redInvm();
    return this.x = this.x.redMul(je), this.y = this.y.redMul(je), this.t && (this.t = this.t.redMul(je)), this.z = this.curve.one, this.zOne = !0, this;
  }, Me.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, Me.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, Me.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, Me.prototype.eq = function(je) {
    return this === je || this.getX().cmp(je.getX()) === 0 && this.getY().cmp(je.getY()) === 0;
  }, Me.prototype.eqXToP = function(je) {
    var fn = je.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(fn) === 0)
      return !0;
    for (var Ve = je.clone(), vn = this.curve.redN.redMul(this.z); ; ) {
      if (Ve.iadd(this.curve.n), Ve.cmp(this.curve.p) >= 0)
        return !1;
      if (fn.redIAdd(vn), this.x.cmp(fn) === 0)
        return !0;
    }
  }, Me.prototype.toP = Me.prototype.normalize, Me.prototype.mixedAdd = Me.prototype.add, edwards;
}
var hasRequiredCurve;
function requireCurve() {
  return hasRequiredCurve || (hasRequiredCurve = 1, function(Ae) {
    var t = Ae;
    t.base = requireBase(), t.short = requireShort(), t.mont = requireMont(), t.edwards = requireEdwards();
  }(curve)), curve;
}
var curves = {}, secp256k1$4, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1$4 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1$4;
}
var hasRequiredCurves;
function requireCurves() {
  return hasRequiredCurves || (hasRequiredCurves = 1, function(Ae) {
    var t = Ae, Ie = hash$6, Be = requireCurve(), Pe = requireUtils$2(), Te = Pe.assert;
    function Me(fn) {
      fn.type === "short" ? this.curve = new Be.short(fn) : fn.type === "edwards" ? this.curve = new Be.edwards(fn) : this.curve = new Be.mont(fn), this.g = this.curve.g, this.n = this.curve.n, this.hash = fn.hash, Te(this.g.validate(), "Invalid curve"), Te(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    t.PresetCurve = Me;
    function Ue(fn, Ve) {
      Object.defineProperty(t, fn, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var vn = new Me(Ve);
          return Object.defineProperty(t, fn, {
            configurable: !0,
            enumerable: !0,
            value: vn
          }), vn;
        }
      });
    }
    Ue("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: Ie.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), Ue("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: Ie.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), Ue("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: Ie.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), Ue("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: Ie.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), Ue("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: Ie.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), Ue("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: Ie.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), Ue("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: Ie.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var je;
    try {
      je = requireSecp256k1();
    } catch {
      je = void 0;
    }
    Ue("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: Ie.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        je
      ]
    });
  }(curves)), curves;
}
var hmacDrbg$1, hasRequiredHmacDrbg;
function requireHmacDrbg() {
  if (hasRequiredHmacDrbg) return hmacDrbg$1;
  hasRequiredHmacDrbg = 1;
  var Ae = hash$6, t = requireUtils$3(), Ie = minimalisticAssert$1;
  function Be(Pe) {
    if (!(this instanceof Be))
      return new Be(Pe);
    this.hash = Pe.hash, this.predResist = !!Pe.predResist, this.outLen = this.hash.outSize, this.minEntropy = Pe.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var Te = t.toArray(Pe.entropy, Pe.entropyEnc || "hex"), Me = t.toArray(Pe.nonce, Pe.nonceEnc || "hex"), Ue = t.toArray(Pe.pers, Pe.persEnc || "hex");
    Ie(
      Te.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(Te, Me, Ue);
  }
  return hmacDrbg$1 = Be, Be.prototype._init = function(Te, Me, Ue) {
    var je = Te.concat(Me).concat(Ue);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var fn = 0; fn < this.V.length; fn++)
      this.K[fn] = 0, this.V[fn] = 1;
    this._update(je), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, Be.prototype._hmac = function() {
    return new Ae.hmac(this.hash, this.K);
  }, Be.prototype._update = function(Te) {
    var Me = this._hmac().update(this.V).update([0]);
    Te && (Me = Me.update(Te)), this.K = Me.digest(), this.V = this._hmac().update(this.V).digest(), Te && (this.K = this._hmac().update(this.V).update([1]).update(Te).digest(), this.V = this._hmac().update(this.V).digest());
  }, Be.prototype.reseed = function(Te, Me, Ue, je) {
    typeof Me != "string" && (je = Ue, Ue = Me, Me = null), Te = t.toArray(Te, Me), Ue = t.toArray(Ue, je), Ie(
      Te.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(Te.concat(Ue || [])), this._reseed = 1;
  }, Be.prototype.generate = function(Te, Me, Ue, je) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof Me != "string" && (je = Ue, Ue = Me, Me = null), Ue && (Ue = t.toArray(Ue, je || "hex"), this._update(Ue));
    for (var fn = []; fn.length < Te; )
      this.V = this._hmac().update(this.V).digest(), fn = fn.concat(this.V);
    var Ve = fn.slice(0, Te);
    return this._update(Ue), this._reseed++, t.encode(Ve, Me);
  }, hmacDrbg$1;
}
var key$2, hasRequiredKey$1;
function requireKey$1() {
  if (hasRequiredKey$1) return key$2;
  hasRequiredKey$1 = 1;
  var Ae = requireBn(), t = requireUtils$2(), Ie = t.assert;
  function Be(Pe, Te) {
    this.ec = Pe, this.priv = null, this.pub = null, Te.priv && this._importPrivate(Te.priv, Te.privEnc), Te.pub && this._importPublic(Te.pub, Te.pubEnc);
  }
  return key$2 = Be, Be.fromPublic = function(Te, Me, Ue) {
    return Me instanceof Be ? Me : new Be(Te, {
      pub: Me,
      pubEnc: Ue
    });
  }, Be.fromPrivate = function(Te, Me, Ue) {
    return Me instanceof Be ? Me : new Be(Te, {
      priv: Me,
      privEnc: Ue
    });
  }, Be.prototype.validate = function() {
    var Te = this.getPublic();
    return Te.isInfinity() ? { result: !1, reason: "Invalid public key" } : Te.validate() ? Te.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, Be.prototype.getPublic = function(Te, Me) {
    return typeof Te == "string" && (Me = Te, Te = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), Me ? this.pub.encode(Me, Te) : this.pub;
  }, Be.prototype.getPrivate = function(Te) {
    return Te === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, Be.prototype._importPrivate = function(Te, Me) {
    this.priv = new Ae(Te, Me || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, Be.prototype._importPublic = function(Te, Me) {
    if (Te.x || Te.y) {
      this.ec.curve.type === "mont" ? Ie(Te.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && Ie(Te.x && Te.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(Te.x, Te.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(Te, Me);
  }, Be.prototype.derive = function(Te) {
    return Te.validate() || Ie(Te.validate(), "public point not validated"), Te.mul(this.priv).getX();
  }, Be.prototype.sign = function(Te, Me, Ue) {
    return this.ec.sign(Te, this, Me, Ue);
  }, Be.prototype.verify = function(Te, Me) {
    return this.ec.verify(Te, Me, this);
  }, Be.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, key$2;
}
var signature$2, hasRequiredSignature$1;
function requireSignature$1() {
  if (hasRequiredSignature$1) return signature$2;
  hasRequiredSignature$1 = 1;
  var Ae = requireBn(), t = requireUtils$2(), Ie = t.assert;
  function Be(je, fn) {
    if (je instanceof Be)
      return je;
    this._importDER(je, fn) || (Ie(je.r && je.s, "Signature without r or s"), this.r = new Ae(je.r, 16), this.s = new Ae(je.s, 16), je.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = je.recoveryParam);
  }
  signature$2 = Be;
  function Pe() {
    this.place = 0;
  }
  function Te(je, fn) {
    var Ve = je[fn.place++];
    if (!(Ve & 128))
      return Ve;
    var vn = Ve & 15;
    if (vn === 0 || vn > 4 || je[fn.place] === 0)
      return !1;
    for (var En = 0, fi = 0, bi = fn.place; fi < vn; fi++, bi++)
      En <<= 8, En |= je[bi], En >>>= 0;
    return En <= 127 ? !1 : (fn.place = bi, En);
  }
  function Me(je) {
    for (var fn = 0, Ve = je.length - 1; !je[fn] && !(je[fn + 1] & 128) && fn < Ve; )
      fn++;
    return fn === 0 ? je : je.slice(fn);
  }
  Be.prototype._importDER = function(fn, Ve) {
    fn = t.toArray(fn, Ve);
    var vn = new Pe();
    if (fn[vn.place++] !== 48)
      return !1;
    var En = Te(fn, vn);
    if (En === !1 || En + vn.place !== fn.length || fn[vn.place++] !== 2)
      return !1;
    var fi = Te(fn, vn);
    if (fi === !1 || fn[vn.place] & 128)
      return !1;
    var bi = fn.slice(vn.place, fi + vn.place);
    if (vn.place += fi, fn[vn.place++] !== 2)
      return !1;
    var mi = Te(fn, vn);
    if (mi === !1 || fn.length !== mi + vn.place || fn[vn.place] & 128)
      return !1;
    var _i = fn.slice(vn.place, mi + vn.place);
    if (bi[0] === 0)
      if (bi[1] & 128)
        bi = bi.slice(1);
      else
        return !1;
    if (_i[0] === 0)
      if (_i[1] & 128)
        _i = _i.slice(1);
      else
        return !1;
    return this.r = new Ae(bi), this.s = new Ae(_i), this.recoveryParam = null, !0;
  };
  function Ue(je, fn) {
    if (fn < 128) {
      je.push(fn);
      return;
    }
    var Ve = 1 + (Math.log(fn) / Math.LN2 >>> 3);
    for (je.push(Ve | 128); --Ve; )
      je.push(fn >>> (Ve << 3) & 255);
    je.push(fn);
  }
  return Be.prototype.toDER = function(fn) {
    var Ve = this.r.toArray(), vn = this.s.toArray();
    for (Ve[0] & 128 && (Ve = [0].concat(Ve)), vn[0] & 128 && (vn = [0].concat(vn)), Ve = Me(Ve), vn = Me(vn); !vn[0] && !(vn[1] & 128); )
      vn = vn.slice(1);
    var En = [2];
    Ue(En, Ve.length), En = En.concat(Ve), En.push(2), Ue(En, vn.length);
    var fi = En.concat(vn), bi = [48];
    return Ue(bi, fi.length), bi = bi.concat(fi), t.encode(bi, fn);
  }, signature$2;
}
var ec$1, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec$1;
  hasRequiredEc = 1;
  var Ae = requireBn(), t = requireHmacDrbg(), Ie = requireUtils$2(), Be = requireCurves(), Pe = requireBrorand(), Te = Ie.assert, Me = requireKey$1(), Ue = requireSignature$1();
  function je(fn) {
    if (!(this instanceof je))
      return new je(fn);
    typeof fn == "string" && (Te(
      Object.prototype.hasOwnProperty.call(Be, fn),
      "Unknown curve " + fn
    ), fn = Be[fn]), fn instanceof Be.PresetCurve && (fn = { curve: fn }), this.curve = fn.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = fn.curve.g, this.g.precompute(fn.curve.n.bitLength() + 1), this.hash = fn.hash || fn.curve.hash;
  }
  return ec$1 = je, je.prototype.keyPair = function(Ve) {
    return new Me(this, Ve);
  }, je.prototype.keyFromPrivate = function(Ve, vn) {
    return Me.fromPrivate(this, Ve, vn);
  }, je.prototype.keyFromPublic = function(Ve, vn) {
    return Me.fromPublic(this, Ve, vn);
  }, je.prototype.genKeyPair = function(Ve) {
    Ve || (Ve = {});
    for (var vn = new t({
      hash: this.hash,
      pers: Ve.pers,
      persEnc: Ve.persEnc || "utf8",
      entropy: Ve.entropy || Pe(this.hash.hmacStrength),
      entropyEnc: Ve.entropy && Ve.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), En = this.n.byteLength(), fi = this.n.sub(new Ae(2)); ; ) {
      var bi = new Ae(vn.generate(En));
      if (!(bi.cmp(fi) > 0))
        return bi.iaddn(1), this.keyFromPrivate(bi);
    }
  }, je.prototype._truncateToN = function(Ve, vn) {
    var En = Ve.byteLength() * 8 - this.n.bitLength();
    return En > 0 && (Ve = Ve.ushrn(En)), !vn && Ve.cmp(this.n) >= 0 ? Ve.sub(this.n) : Ve;
  }, je.prototype.sign = function(Ve, vn, En, fi) {
    typeof En == "object" && (fi = En, En = null), fi || (fi = {}), vn = this.keyFromPrivate(vn, En), Ve = this._truncateToN(new Ae(Ve, 16));
    for (var bi = this.n.byteLength(), mi = vn.getPrivate().toArray("be", bi), _i = Ve.toArray("be", bi), Ei = new t({
      hash: this.hash,
      entropy: mi,
      nonce: _i,
      pers: fi.pers,
      persEnc: fi.persEnc || "utf8"
    }), Si = this.n.sub(new Ae(1)), Mi = 0; ; Mi++) {
      var Oi = fi.k ? fi.k(Mi) : new Ae(Ei.generate(this.n.byteLength()));
      if (Oi = this._truncateToN(Oi, !0), !(Oi.cmpn(1) <= 0 || Oi.cmp(Si) >= 0)) {
        var Fi = this.g.mul(Oi);
        if (!Fi.isInfinity()) {
          var Ui = Fi.getX(), Pi = Ui.umod(this.n);
          if (Pi.cmpn(0) !== 0) {
            var Bi = Oi.invm(this.n).mul(Pi.mul(vn.getPrivate()).iadd(Ve));
            if (Bi = Bi.umod(this.n), Bi.cmpn(0) !== 0) {
              var ji = (Fi.getY().isOdd() ? 1 : 0) | (Ui.cmp(Pi) !== 0 ? 2 : 0);
              return fi.canonical && Bi.cmp(this.nh) > 0 && (Bi = this.n.sub(Bi), ji ^= 1), new Ue({ r: Pi, s: Bi, recoveryParam: ji });
            }
          }
        }
      }
    }
  }, je.prototype.verify = function(Ve, vn, En, fi) {
    Ve = this._truncateToN(new Ae(Ve, 16)), En = this.keyFromPublic(En, fi), vn = new Ue(vn, "hex");
    var bi = vn.r, mi = vn.s;
    if (bi.cmpn(1) < 0 || bi.cmp(this.n) >= 0 || mi.cmpn(1) < 0 || mi.cmp(this.n) >= 0)
      return !1;
    var _i = mi.invm(this.n), Ei = _i.mul(Ve).umod(this.n), Si = _i.mul(bi).umod(this.n), Mi;
    return this.curve._maxwellTrick ? (Mi = this.g.jmulAdd(Ei, En.getPublic(), Si), Mi.isInfinity() ? !1 : Mi.eqXToP(bi)) : (Mi = this.g.mulAdd(Ei, En.getPublic(), Si), Mi.isInfinity() ? !1 : Mi.getX().umod(this.n).cmp(bi) === 0);
  }, je.prototype.recoverPubKey = function(fn, Ve, vn, En) {
    Te((3 & vn) === vn, "The recovery param is more than two bits"), Ve = new Ue(Ve, En);
    var fi = this.n, bi = new Ae(fn), mi = Ve.r, _i = Ve.s, Ei = vn & 1, Si = vn >> 1;
    if (mi.cmp(this.curve.p.umod(this.curve.n)) >= 0 && Si)
      throw new Error("Unable to find sencond key candinate");
    Si ? mi = this.curve.pointFromX(mi.add(this.curve.n), Ei) : mi = this.curve.pointFromX(mi, Ei);
    var Mi = Ve.r.invm(fi), Oi = fi.sub(bi).mul(Mi).umod(fi), Fi = _i.mul(Mi).umod(fi);
    return this.g.mulAdd(Oi, mi, Fi);
  }, je.prototype.getKeyRecoveryParam = function(fn, Ve, vn, En) {
    if (Ve = new Ue(Ve, En), Ve.recoveryParam !== null)
      return Ve.recoveryParam;
    for (var fi = 0; fi < 4; fi++) {
      var bi;
      try {
        bi = this.recoverPubKey(fn, Ve, fi);
      } catch {
        continue;
      }
      if (bi.eq(vn))
        return fi;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec$1;
}
var key$1, hasRequiredKey;
function requireKey() {
  if (hasRequiredKey) return key$1;
  hasRequiredKey = 1;
  var Ae = requireUtils$2(), t = Ae.assert, Ie = Ae.parseBytes, Be = Ae.cachedProperty;
  function Pe(Te, Me) {
    this.eddsa = Te, this._secret = Ie(Me.secret), Te.isPoint(Me.pub) ? this._pub = Me.pub : this._pubBytes = Ie(Me.pub);
  }
  return Pe.fromPublic = function(Me, Ue) {
    return Ue instanceof Pe ? Ue : new Pe(Me, { pub: Ue });
  }, Pe.fromSecret = function(Me, Ue) {
    return Ue instanceof Pe ? Ue : new Pe(Me, { secret: Ue });
  }, Pe.prototype.secret = function() {
    return this._secret;
  }, Be(Pe, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), Be(Pe, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), Be(Pe, "privBytes", function() {
    var Me = this.eddsa, Ue = this.hash(), je = Me.encodingLength - 1, fn = Ue.slice(0, Me.encodingLength);
    return fn[0] &= 248, fn[je] &= 127, fn[je] |= 64, fn;
  }), Be(Pe, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), Be(Pe, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), Be(Pe, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), Pe.prototype.sign = function(Me) {
    return t(this._secret, "KeyPair can only verify"), this.eddsa.sign(Me, this);
  }, Pe.prototype.verify = function(Me, Ue) {
    return this.eddsa.verify(Me, Ue, this);
  }, Pe.prototype.getSecret = function(Me) {
    return t(this._secret, "KeyPair is public only"), Ae.encode(this.secret(), Me);
  }, Pe.prototype.getPublic = function(Me) {
    return Ae.encode(this.pubBytes(), Me);
  }, key$1 = Pe, key$1;
}
var signature$1, hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature) return signature$1;
  hasRequiredSignature = 1;
  var Ae = requireBn(), t = requireUtils$2(), Ie = t.assert, Be = t.cachedProperty, Pe = t.parseBytes;
  function Te(Me, Ue) {
    this.eddsa = Me, typeof Ue != "object" && (Ue = Pe(Ue)), Array.isArray(Ue) && (Ie(Ue.length === Me.encodingLength * 2, "Signature has invalid size"), Ue = {
      R: Ue.slice(0, Me.encodingLength),
      S: Ue.slice(Me.encodingLength)
    }), Ie(Ue.R && Ue.S, "Signature without R or S"), Me.isPoint(Ue.R) && (this._R = Ue.R), Ue.S instanceof Ae && (this._S = Ue.S), this._Rencoded = Array.isArray(Ue.R) ? Ue.R : Ue.Rencoded, this._Sencoded = Array.isArray(Ue.S) ? Ue.S : Ue.Sencoded;
  }
  return Be(Te, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), Be(Te, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), Be(Te, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), Be(Te, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), Te.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, Te.prototype.toHex = function() {
    return t.encode(this.toBytes(), "hex").toUpperCase();
  }, signature$1 = Te, signature$1;
}
var eddsa, hasRequiredEddsa;
function requireEddsa() {
  if (hasRequiredEddsa) return eddsa;
  hasRequiredEddsa = 1;
  var Ae = hash$6, t = requireCurves(), Ie = requireUtils$2(), Be = Ie.assert, Pe = Ie.parseBytes, Te = requireKey(), Me = requireSignature();
  function Ue(je) {
    if (Be(je === "ed25519", "only tested with ed25519 so far"), !(this instanceof Ue))
      return new Ue(je);
    je = t[je].curve, this.curve = je, this.g = je.g, this.g.precompute(je.n.bitLength() + 1), this.pointClass = je.point().constructor, this.encodingLength = Math.ceil(je.n.bitLength() / 8), this.hash = Ae.sha512;
  }
  return eddsa = Ue, Ue.prototype.sign = function(fn, Ve) {
    fn = Pe(fn);
    var vn = this.keyFromSecret(Ve), En = this.hashInt(vn.messagePrefix(), fn), fi = this.g.mul(En), bi = this.encodePoint(fi), mi = this.hashInt(bi, vn.pubBytes(), fn).mul(vn.priv()), _i = En.add(mi).umod(this.curve.n);
    return this.makeSignature({ R: fi, S: _i, Rencoded: bi });
  }, Ue.prototype.verify = function(fn, Ve, vn) {
    if (fn = Pe(fn), Ve = this.makeSignature(Ve), Ve.S().gte(Ve.eddsa.curve.n) || Ve.S().isNeg())
      return !1;
    var En = this.keyFromPublic(vn), fi = this.hashInt(Ve.Rencoded(), En.pubBytes(), fn), bi = this.g.mul(Ve.S()), mi = Ve.R().add(En.pub().mul(fi));
    return mi.eq(bi);
  }, Ue.prototype.hashInt = function() {
    for (var fn = this.hash(), Ve = 0; Ve < arguments.length; Ve++)
      fn.update(arguments[Ve]);
    return Ie.intFromLE(fn.digest()).umod(this.curve.n);
  }, Ue.prototype.keyFromPublic = function(fn) {
    return Te.fromPublic(this, fn);
  }, Ue.prototype.keyFromSecret = function(fn) {
    return Te.fromSecret(this, fn);
  }, Ue.prototype.makeSignature = function(fn) {
    return fn instanceof Me ? fn : new Me(this, fn);
  }, Ue.prototype.encodePoint = function(fn) {
    var Ve = fn.getY().toArray("le", this.encodingLength);
    return Ve[this.encodingLength - 1] |= fn.getX().isOdd() ? 128 : 0, Ve;
  }, Ue.prototype.decodePoint = function(fn) {
    fn = Ie.parseBytes(fn);
    var Ve = fn.length - 1, vn = fn.slice(0, Ve).concat(fn[Ve] & -129), En = (fn[Ve] & 128) !== 0, fi = Ie.intFromLE(vn);
    return this.curve.pointFromY(fi, En);
  }, Ue.prototype.encodeInt = function(fn) {
    return fn.toArray("le", this.encodingLength);
  }, Ue.prototype.decodeInt = function(fn) {
    return Ie.intFromLE(fn);
  }, Ue.prototype.isPoint = function(fn) {
    return fn instanceof this.pointClass;
  }, eddsa;
}
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(Ae) {
    var t = Ae;
    t.version = require$$0$3.version, t.utils = requireUtils$2(), t.rand = requireBrorand(), t.curve = requireCurve(), t.curves = requireCurves(), t.ec = requireEc(), t.eddsa = requireEddsa();
  }(elliptic)), elliptic;
}
var ellipticExports = requireElliptic();
const EC$2 = /* @__PURE__ */ getDefaultExportFromCjs(ellipticExports);
var isMergeableObject = function Ae(t) {
  return isNonNullObject(t) && !isSpecial(t);
};
function isNonNullObject(Ae) {
  return !!Ae && typeof Ae == "object";
}
function isSpecial(Ae) {
  var t = Object.prototype.toString.call(Ae);
  return t === "[object RegExp]" || t === "[object Date]" || isReactElement(Ae);
}
var canUseSymbol = typeof Symbol == "function" && Symbol.for, REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(Ae) {
  return Ae.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(Ae) {
  return Array.isArray(Ae) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(Ae, t) {
  return t.clone !== !1 && t.isMergeableObject(Ae) ? deepmerge(emptyTarget(Ae), Ae, t) : Ae;
}
function defaultArrayMerge(Ae, t, Ie) {
  return Ae.concat(t).map(function(Be) {
    return cloneUnlessOtherwiseSpecified(Be, Ie);
  });
}
function getMergeFunction(Ae, t) {
  if (!t.customMerge)
    return deepmerge;
  var Ie = t.customMerge(Ae);
  return typeof Ie == "function" ? Ie : deepmerge;
}
function getEnumerableOwnPropertySymbols(Ae) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(Ae).filter(function(t) {
    return Object.propertyIsEnumerable.call(Ae, t);
  }) : [];
}
function getKeys(Ae) {
  return Object.keys(Ae).concat(getEnumerableOwnPropertySymbols(Ae));
}
function propertyIsOnObject(Ae, t) {
  try {
    return t in Ae;
  } catch {
    return !1;
  }
}
function propertyIsUnsafe(Ae, t) {
  return propertyIsOnObject(Ae, t) && !(Object.hasOwnProperty.call(Ae, t) && Object.propertyIsEnumerable.call(Ae, t));
}
function mergeObject(Ae, t, Ie) {
  var Be = {};
  return Ie.isMergeableObject(Ae) && getKeys(Ae).forEach(function(Pe) {
    Be[Pe] = cloneUnlessOtherwiseSpecified(Ae[Pe], Ie);
  }), getKeys(t).forEach(function(Pe) {
    propertyIsUnsafe(Ae, Pe) || (propertyIsOnObject(Ae, Pe) && Ie.isMergeableObject(t[Pe]) ? Be[Pe] = getMergeFunction(Pe, Ie)(Ae[Pe], t[Pe], Ie) : Be[Pe] = cloneUnlessOtherwiseSpecified(t[Pe], Ie));
  }), Be;
}
function deepmerge(Ae, t, Ie) {
  Ie = Ie || {}, Ie.arrayMerge = Ie.arrayMerge || defaultArrayMerge, Ie.isMergeableObject = Ie.isMergeableObject || isMergeableObject, Ie.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
  var Be = Array.isArray(t), Pe = Array.isArray(Ae), Te = Be === Pe;
  return Te ? Be ? Ie.arrayMerge(Ae, t, Ie) : mergeObject(Ae, t, Ie) : cloneUnlessOtherwiseSpecified(t, Ie);
}
deepmerge.all = function Ae(t, Ie) {
  if (!Array.isArray(t))
    throw new Error("first argument should be an array");
  return t.reduce(function(Be, Pe) {
    return deepmerge(Be, Pe, Ie);
  }, {});
};
var deepmerge_1 = deepmerge, cjs$4 = deepmerge_1;
const deepmerge$1 = /* @__PURE__ */ getDefaultExportFromCjs(cjs$4), log$1 = loglevel$1.getLogger("http-helpers");
log$1.setLevel(loglevelExports.levels.INFO);
let apiKey = "torus-default";
const gatewayAuthHeader = "x-api-key";
async function fetchAndTrace(Ae, t) {
  let Ie = null;
  try {
    Ie = new URL(Ae);
  } catch {
  }
  return fetch(Ae, t);
}
function getApiKeyHeaders() {
  const Ae = {};
  return Ae[gatewayAuthHeader] = apiKey, Ae;
}
function debugLogResponse(Ae) {
  log$1.info(`Response: ${Ae.status} ${Ae.statusText}`), log$1.info(`Url: ${Ae.url}`);
}
const get$1 = async (Ae, t = {}, Ie = {}) => {
  const Be = {
    mode: "cors",
    headers: {}
  };
  Ie.useAPIKey && (Be.headers = _objectSpread2(_objectSpread2({}, Be.headers), getApiKeyHeaders())), t.method = "GET";
  const Pe = deepmerge$1(Be, t), Te = await fetchAndTrace(Ae, Pe);
  if (Te.ok) {
    const Me = Te.headers.get("content-type");
    return Me != null && Me.includes("application/json") ? Te.json() : Te.text();
  }
  throw debugLogResponse(Te), Te;
};
var jsonify = {}, parse$1, hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse$1;
  hasRequiredParse = 1;
  var Ae, t, Ie = {
    '"': '"',
    "\\": "\\",
    "/": "/",
    b: "\b",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "	"
  }, Be;
  function Pe(fi) {
    throw {
      name: "SyntaxError",
      message: fi,
      at: Ae,
      text: Be
    };
  }
  function Te(fi) {
    return fi && fi !== t && Pe("Expected '" + fi + "' instead of '" + t + "'"), t = Be.charAt(Ae), Ae += 1, t;
  }
  function Me() {
    var fi, bi = "";
    for (t === "-" && (bi = "-", Te("-")); t >= "0" && t <= "9"; )
      bi += t, Te();
    if (t === ".")
      for (bi += "."; Te() && t >= "0" && t <= "9"; )
        bi += t;
    if (t === "e" || t === "E")
      for (bi += t, Te(), (t === "-" || t === "+") && (bi += t, Te()); t >= "0" && t <= "9"; )
        bi += t, Te();
    return fi = Number(bi), isFinite(fi) || Pe("Bad number"), fi;
  }
  function Ue() {
    var fi, bi, mi = "", _i;
    if (t === '"')
      for (; Te(); ) {
        if (t === '"')
          return Te(), mi;
        if (t === "\\")
          if (Te(), t === "u") {
            for (_i = 0, bi = 0; bi < 4 && (fi = parseInt(Te(), 16), !!isFinite(fi)); bi += 1)
              _i = _i * 16 + fi;
            mi += String.fromCharCode(_i);
          } else if (typeof Ie[t] == "string")
            mi += Ie[t];
          else
            break;
        else
          mi += t;
      }
    Pe("Bad string");
  }
  function je() {
    for (; t && t <= " "; )
      Te();
  }
  function fn() {
    switch (t) {
      case "t":
        return Te("t"), Te("r"), Te("u"), Te("e"), !0;
      case "f":
        return Te("f"), Te("a"), Te("l"), Te("s"), Te("e"), !1;
      case "n":
        return Te("n"), Te("u"), Te("l"), Te("l"), null;
      default:
        Pe("Unexpected '" + t + "'");
    }
  }
  function Ve() {
    var fi = [];
    if (t === "[") {
      if (Te("["), je(), t === "]")
        return Te("]"), fi;
      for (; t; ) {
        if (fi.push(En()), je(), t === "]")
          return Te("]"), fi;
        Te(","), je();
      }
    }
    Pe("Bad array");
  }
  function vn() {
    var fi, bi = {};
    if (t === "{") {
      if (Te("{"), je(), t === "}")
        return Te("}"), bi;
      for (; t; ) {
        if (fi = Ue(), je(), Te(":"), Object.prototype.hasOwnProperty.call(bi, fi) && Pe('Duplicate key "' + fi + '"'), bi[fi] = En(), je(), t === "}")
          return Te("}"), bi;
        Te(","), je();
      }
    }
    Pe("Bad object");
  }
  function En() {
    switch (je(), t) {
      case "{":
        return vn();
      case "[":
        return Ve();
      case '"':
        return Ue();
      case "-":
        return Me();
      default:
        return t >= "0" && t <= "9" ? Me() : fn();
    }
  }
  return parse$1 = function(fi, bi) {
    var mi;
    return Be = fi, Ae = 0, t = " ", mi = En(), je(), t && Pe("Syntax error"), typeof bi == "function" ? function _i(Ei, Si) {
      var Mi, Oi, Fi = Ei[Si];
      if (Fi && typeof Fi == "object")
        for (Mi in En)
          Object.prototype.hasOwnProperty.call(Fi, Mi) && (Oi = _i(Fi, Mi), typeof Oi > "u" ? delete Fi[Mi] : Fi[Mi] = Oi);
      return bi.call(Ei, Si, Fi);
    }({ "": mi }, "") : mi;
  }, parse$1;
}
var stringify$4, hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify$4;
  hasRequiredStringify = 1;
  var Ae = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, t, Ie, Be = {
    // table of character substitutions
    "\b": "\\b",
    "	": "\\t",
    "\n": "\\n",
    "\f": "\\f",
    "\r": "\\r",
    '"': '\\"',
    "\\": "\\\\"
  }, Pe;
  function Te(Ue) {
    return Ae.lastIndex = 0, Ae.test(Ue) ? '"' + Ue.replace(Ae, function(je) {
      var fn = Be[je];
      return typeof fn == "string" ? fn : "\\u" + ("0000" + je.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + Ue + '"';
  }
  function Me(Ue, je) {
    var fn, Ve, vn, En, fi = t, bi, mi = je[Ue];
    switch (mi && typeof mi == "object" && typeof mi.toJSON == "function" && (mi = mi.toJSON(Ue)), typeof Pe == "function" && (mi = Pe.call(je, Ue, mi)), typeof mi) {
      case "string":
        return Te(mi);
      case "number":
        return isFinite(mi) ? String(mi) : "null";
      case "boolean":
      case "null":
        return String(mi);
      case "object":
        if (!mi)
          return "null";
        if (t += Ie, bi = [], Object.prototype.toString.apply(mi) === "[object Array]") {
          for (En = mi.length, fn = 0; fn < En; fn += 1)
            bi[fn] = Me(fn, mi) || "null";
          return vn = bi.length === 0 ? "[]" : t ? `[
` + t + bi.join(`,
` + t) + `
` + fi + "]" : "[" + bi.join(",") + "]", t = fi, vn;
        }
        if (Pe && typeof Pe == "object")
          for (En = Pe.length, fn = 0; fn < En; fn += 1)
            Ve = Pe[fn], typeof Ve == "string" && (vn = Me(Ve, mi), vn && bi.push(Te(Ve) + (t ? ": " : ":") + vn));
        else
          for (Ve in mi)
            Object.prototype.hasOwnProperty.call(mi, Ve) && (vn = Me(Ve, mi), vn && bi.push(Te(Ve) + (t ? ": " : ":") + vn));
        return vn = bi.length === 0 ? "{}" : t ? `{
` + t + bi.join(`,
` + t) + `
` + fi + "}" : "{" + bi.join(",") + "}", t = fi, vn;
    }
  }
  return stringify$4 = function(Ue, je, fn) {
    var Ve;
    if (t = "", Ie = "", typeof fn == "number")
      for (Ve = 0; Ve < fn; Ve += 1)
        Ie += " ";
    else typeof fn == "string" && (Ie = fn);
    if (Pe = je, je && typeof je != "function" && (typeof je != "object" || typeof je.length != "number"))
      throw new Error("JSON.stringify");
    return Me("", { "": Ue });
  }, stringify$4;
}
var hasRequiredJsonify;
function requireJsonify() {
  return hasRequiredJsonify || (hasRequiredJsonify = 1, jsonify.parse = requireParse(), jsonify.stringify = requireStringify()), jsonify;
}
var toString$3 = {}.toString, isarray = Array.isArray || function(Ae) {
  return toString$3.call(Ae) == "[object Array]";
}, jsonStringify = (typeof JSON < "u" ? JSON : requireJsonify()).stringify, isArray = isarray, objectKeys = objectKeys$1, callBind = callBindExports, callBound = callBound$3, $join = callBound("Array.prototype.join"), $push = callBound("Array.prototype.push"), strRepeat = function Ae(t, Ie) {
  for (var Be = "", Pe = 0; Pe < t; Pe += 1)
    Be += Ie;
  return Be;
}, defaultReplacer = function(Ae, t, Ie) {
  return Ie;
}, jsonStableStringify = function Ae(t) {
  var Ie = arguments.length > 1 ? arguments[1] : void 0, Be = Ie && Ie.space || "";
  typeof Be == "number" && (Be = strRepeat(Be, " "));
  var Pe = !!Ie && typeof Ie.cycles == "boolean" && Ie.cycles, Te = Ie && Ie.replacer ? callBind(Ie.replacer) : defaultReplacer, Me = typeof Ie == "function" ? Ie : Ie && Ie.cmp, Ue = Me && function(fn) {
    var Ve = Me.length > 2 && function(En) {
      return fn[En];
    };
    return function(vn, En) {
      return Me(
        { key: vn, value: fn[vn] },
        { key: En, value: fn[En] },
        Ve ? { __proto__: null, get: Ve } : void 0
      );
    };
  }, je = [];
  return function fn(Ve, vn, En, fi) {
    var bi = Be ? `
` + strRepeat(fi, Be) : "", mi = Be ? ": " : ":";
    if (En && En.toJSON && typeof En.toJSON == "function" && (En = En.toJSON()), En = Te(Ve, vn, En), En !== void 0) {
      if (typeof En != "object" || En === null)
        return jsonStringify(En);
      if (isArray(En)) {
        for (var Mi = [], _i = 0; _i < En.length; _i++) {
          var Ei = fn(En, _i, En[_i], fi + 1) || jsonStringify(null);
          $push(Mi, bi + Be + Ei);
        }
        return "[" + $join(Mi, ",") + bi + "]";
      }
      if (je.indexOf(En) !== -1) {
        if (Pe)
          return jsonStringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      } else
        $push(je, En);
      for (var Si = objectKeys(En).sort(Ue && Ue(En)), Mi = [], _i = 0; _i < Si.length; _i++) {
        var vn = Si[_i], Oi = fn(En, vn, En[vn], fi + 1);
        if (Oi) {
          var Fi = jsonStringify(vn) + mi + Oi;
          $push(Mi, bi + Be + Fi);
        }
      }
      return je.splice(je.indexOf(En), 1), "{" + $join(Mi, ",") + bi + "}";
    }
  }({ "": t }, "", t, 0);
};
const stringify$3 = /* @__PURE__ */ getDefaultExportFromCjs(jsonStableStringify), SHA3_PI$2 = [], SHA3_ROTL$2 = [], _SHA3_IOTA$2 = [], _0n$a = /* @__PURE__ */ BigInt(0), _1n$c = /* @__PURE__ */ BigInt(1), _2n$8 = /* @__PURE__ */ BigInt(2), _7n$2 = /* @__PURE__ */ BigInt(7), _256n$2 = /* @__PURE__ */ BigInt(256), _0x71n$2 = /* @__PURE__ */ BigInt(113);
for (let Ae = 0, t = _1n$c, Ie = 1, Be = 0; Ae < 24; Ae++) {
  [Ie, Be] = [Be, (2 * Ie + 3 * Be) % 5], SHA3_PI$2.push(2 * (5 * Be + Ie)), SHA3_ROTL$2.push((Ae + 1) * (Ae + 2) / 2 % 64);
  let Pe = _0n$a;
  for (let Te = 0; Te < 7; Te++)
    t = (t << _1n$c ^ (t >> _7n$2) * _0x71n$2) % _256n$2, t & _2n$8 && (Pe ^= _1n$c << (_1n$c << /* @__PURE__ */ BigInt(Te)) - _1n$c);
  _SHA3_IOTA$2.push(Pe);
}
const [SHA3_IOTA_H$2, SHA3_IOTA_L$2] = /* @__PURE__ */ split$2(_SHA3_IOTA$2, !0), rotlH$2 = (Ae, t, Ie) => Ie > 32 ? rotlBH$2(Ae, t, Ie) : rotlSH$2(Ae, t, Ie), rotlL$2 = (Ae, t, Ie) => Ie > 32 ? rotlBL$2(Ae, t, Ie) : rotlSL$2(Ae, t, Ie);
function keccakP$2(Ae, t = 24) {
  const Ie = new Uint32Array(10);
  for (let Be = 24 - t; Be < 24; Be++) {
    for (let Me = 0; Me < 10; Me++)
      Ie[Me] = Ae[Me] ^ Ae[Me + 10] ^ Ae[Me + 20] ^ Ae[Me + 30] ^ Ae[Me + 40];
    for (let Me = 0; Me < 10; Me += 2) {
      const Ue = (Me + 8) % 10, je = (Me + 2) % 10, fn = Ie[je], Ve = Ie[je + 1], vn = rotlH$2(fn, Ve, 1) ^ Ie[Ue], En = rotlL$2(fn, Ve, 1) ^ Ie[Ue + 1];
      for (let fi = 0; fi < 50; fi += 10)
        Ae[Me + fi] ^= vn, Ae[Me + fi + 1] ^= En;
    }
    let Pe = Ae[2], Te = Ae[3];
    for (let Me = 0; Me < 24; Me++) {
      const Ue = SHA3_ROTL$2[Me], je = rotlH$2(Pe, Te, Ue), fn = rotlL$2(Pe, Te, Ue), Ve = SHA3_PI$2[Me];
      Pe = Ae[Ve], Te = Ae[Ve + 1], Ae[Ve] = je, Ae[Ve + 1] = fn;
    }
    for (let Me = 0; Me < 50; Me += 10) {
      for (let Ue = 0; Ue < 10; Ue++)
        Ie[Ue] = Ae[Me + Ue];
      for (let Ue = 0; Ue < 10; Ue++)
        Ae[Me + Ue] ^= ~Ie[(Ue + 2) % 10] & Ie[(Ue + 4) % 10];
    }
    Ae[0] ^= SHA3_IOTA_H$2[Be], Ae[1] ^= SHA3_IOTA_L$2[Be];
  }
  Ie.fill(0);
}
let Keccak$2 = class Hc extends Hash$2 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, Ie, Be, Pe = !1, Te = 24) {
    if (super(), this.blockLen = t, this.suffix = Ie, this.outputLen = Be, this.enableXOF = Pe, this.rounds = Te, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, number$2(Be), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = u32$2(this.state);
  }
  keccak() {
    isLE$2 || byteSwap32$1(this.state32), keccakP$2(this.state32, this.rounds), isLE$2 || byteSwap32$1(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    exists$2(this);
    const { blockLen: Ie, state: Be } = this;
    t = toBytes$4(t);
    const Pe = t.length;
    for (let Te = 0; Te < Pe; ) {
      const Me = Math.min(Ie - this.pos, Pe - Te);
      for (let Ue = 0; Ue < Me; Ue++)
        Be[this.pos++] ^= t[Te++];
      this.pos === Ie && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: Ie, pos: Be, blockLen: Pe } = this;
    t[Be] ^= Ie, Ie & 128 && Be === Pe - 1 && this.keccak(), t[Pe - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    exists$2(this, !1), bytes$2(t), this.finish();
    const Ie = this.state, { blockLen: Be } = this;
    for (let Pe = 0, Te = t.length; Pe < Te; ) {
      this.posOut >= Be && this.keccak();
      const Me = Math.min(Be - this.posOut, Te - Pe);
      t.set(Ie.subarray(this.posOut, this.posOut + Me), Pe), this.posOut += Me, Pe += Me;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return number$2(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (output$2(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: Ie, suffix: Be, outputLen: Pe, rounds: Te, enableXOF: Me } = this;
    return t || (t = new Hc(Ie, Be, Pe, Me, Te)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = Te, t.suffix = Be, t.outputLen = Pe, t.enableXOF = Me, t.destroyed = this.destroyed, t;
  }
};
const gen$2 = (Ae, t, Ie) => wrapConstructor$2(() => new Keccak$2(t, Ae, Ie)), keccak_256$2 = /* @__PURE__ */ gen$2(1, 136, 256 / 8);
function wrapHash(Ae) {
  return (t) => (assert$e.bytes(t), Ae(t));
}
(() => {
  const Ae = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0, t = typeof module < "u" && typeof module.require == "function" && module.require.bind(module);
  return {
    node: t && !Ae ? t("crypto") : void 0,
    web: Ae
  };
})();
const keccak256$3 = (() => {
  const Ae = wrapHash(keccak_256$2);
  return Ae.create = keccak_256$2.create, Ae;
})(), PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES.open = "0";
PACKET_TYPES.close = "1";
PACKET_TYPES.ping = "2";
PACKET_TYPES.pong = "3";
PACKET_TYPES.message = "4";
PACKET_TYPES.upgrade = "5";
PACKET_TYPES.noop = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((Ae) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[Ae]] = Ae;
});
const ERROR_PACKET = { type: "error", data: "parser error" }, withNativeBlob$1 = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", withNativeArrayBuffer$2 = typeof ArrayBuffer == "function", isView$1 = (Ae) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(Ae) : Ae && Ae.buffer instanceof ArrayBuffer, encodePacket = ({ type: Ae, data: t }, Ie, Be) => withNativeBlob$1 && t instanceof Blob ? Ie ? Be(t) : encodeBlobAsBase64(t, Be) : withNativeArrayBuffer$2 && (t instanceof ArrayBuffer || isView$1(t)) ? Ie ? Be(t) : encodeBlobAsBase64(new Blob([t]), Be) : Be(PACKET_TYPES[Ae] + (t || "")), encodeBlobAsBase64 = (Ae, t) => {
  const Ie = new FileReader();
  return Ie.onload = function() {
    const Be = Ie.result.split(",")[1];
    t("b" + (Be || ""));
  }, Ie.readAsDataURL(Ae);
};
function toArray$1(Ae) {
  return Ae instanceof Uint8Array ? Ae : Ae instanceof ArrayBuffer ? new Uint8Array(Ae) : new Uint8Array(Ae.buffer, Ae.byteOffset, Ae.byteLength);
}
let TEXT_ENCODER;
function encodePacketToBinary(Ae, t) {
  if (withNativeBlob$1 && Ae.data instanceof Blob)
    return Ae.data.arrayBuffer().then(toArray$1).then(t);
  if (withNativeArrayBuffer$2 && (Ae.data instanceof ArrayBuffer || isView$1(Ae.data)))
    return t(toArray$1(Ae.data));
  encodePacket(Ae, !1, (Ie) => {
    TEXT_ENCODER || (TEXT_ENCODER = new TextEncoder()), t(TEXT_ENCODER.encode(Ie));
  });
}
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lookup$1 = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let Ae = 0; Ae < chars.length; Ae++)
  lookup$1[chars.charCodeAt(Ae)] = Ae;
const decode$5 = (Ae) => {
  let t = Ae.length * 0.75, Ie = Ae.length, Be, Pe = 0, Te, Me, Ue, je;
  Ae[Ae.length - 1] === "=" && (t--, Ae[Ae.length - 2] === "=" && t--);
  const fn = new ArrayBuffer(t), Ve = new Uint8Array(fn);
  for (Be = 0; Be < Ie; Be += 4)
    Te = lookup$1[Ae.charCodeAt(Be)], Me = lookup$1[Ae.charCodeAt(Be + 1)], Ue = lookup$1[Ae.charCodeAt(Be + 2)], je = lookup$1[Ae.charCodeAt(Be + 3)], Ve[Pe++] = Te << 2 | Me >> 4, Ve[Pe++] = (Me & 15) << 4 | Ue >> 2, Ve[Pe++] = (Ue & 3) << 6 | je & 63;
  return fn;
}, withNativeArrayBuffer$1 = typeof ArrayBuffer == "function", decodePacket = (Ae, t) => {
  if (typeof Ae != "string")
    return {
      type: "message",
      data: mapBinary(Ae, t)
    };
  const Ie = Ae.charAt(0);
  return Ie === "b" ? {
    type: "message",
    data: decodeBase64Packet(Ae.substring(1), t)
  } : PACKET_TYPES_REVERSE[Ie] ? Ae.length > 1 ? {
    type: PACKET_TYPES_REVERSE[Ie],
    data: Ae.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[Ie]
  } : ERROR_PACKET;
}, decodeBase64Packet = (Ae, t) => {
  if (withNativeArrayBuffer$1) {
    const Ie = decode$5(Ae);
    return mapBinary(Ie, t);
  } else
    return { base64: !0, data: Ae };
}, mapBinary = (Ae, t) => {
  switch (t) {
    case "blob":
      return Ae instanceof Blob ? Ae : new Blob([Ae]);
    case "arraybuffer":
    default:
      return Ae instanceof ArrayBuffer ? Ae : Ae.buffer;
  }
}, SEPARATOR = "", encodePayload = (Ae, t) => {
  const Ie = Ae.length, Be = new Array(Ie);
  let Pe = 0;
  Ae.forEach((Te, Me) => {
    encodePacket(Te, !1, (Ue) => {
      Be[Me] = Ue, ++Pe === Ie && t(Be.join(SEPARATOR));
    });
  });
}, decodePayload = (Ae, t) => {
  const Ie = Ae.split(SEPARATOR), Be = [];
  for (let Pe = 0; Pe < Ie.length; Pe++) {
    const Te = decodePacket(Ie[Pe], t);
    if (Be.push(Te), Te.type === "error")
      break;
  }
  return Be;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(Ae, t) {
      encodePacketToBinary(Ae, (Ie) => {
        const Be = Ie.length;
        let Pe;
        if (Be < 126)
          Pe = new Uint8Array(1), new DataView(Pe.buffer).setUint8(0, Be);
        else if (Be < 65536) {
          Pe = new Uint8Array(3);
          const Te = new DataView(Pe.buffer);
          Te.setUint8(0, 126), Te.setUint16(1, Be);
        } else {
          Pe = new Uint8Array(9);
          const Te = new DataView(Pe.buffer);
          Te.setUint8(0, 127), Te.setBigUint64(1, BigInt(Be));
        }
        Ae.data && typeof Ae.data != "string" && (Pe[0] |= 128), t.enqueue(Pe), t.enqueue(Ie);
      });
    }
  });
}
let TEXT_DECODER;
function totalLength(Ae) {
  return Ae.reduce((t, Ie) => t + Ie.length, 0);
}
function concatChunks(Ae, t) {
  if (Ae[0].length === t)
    return Ae.shift();
  const Ie = new Uint8Array(t);
  let Be = 0;
  for (let Pe = 0; Pe < t; Pe++)
    Ie[Pe] = Ae[0][Be++], Be === Ae[0].length && (Ae.shift(), Be = 0);
  return Ae.length && Be < Ae[0].length && (Ae[0] = Ae[0].slice(Be)), Ie;
}
function createPacketDecoderStream(Ae, t) {
  TEXT_DECODER || (TEXT_DECODER = new TextDecoder());
  const Ie = [];
  let Be = 0, Pe = -1, Te = !1;
  return new TransformStream({
    transform(Me, Ue) {
      for (Ie.push(Me); ; ) {
        if (Be === 0) {
          if (totalLength(Ie) < 1)
            break;
          const je = concatChunks(Ie, 1);
          Te = (je[0] & 128) === 128, Pe = je[0] & 127, Pe < 126 ? Be = 3 : Pe === 126 ? Be = 1 : Be = 2;
        } else if (Be === 1) {
          if (totalLength(Ie) < 2)
            break;
          const je = concatChunks(Ie, 2);
          Pe = new DataView(je.buffer, je.byteOffset, je.length).getUint16(0), Be = 3;
        } else if (Be === 2) {
          if (totalLength(Ie) < 8)
            break;
          const je = concatChunks(Ie, 8), fn = new DataView(je.buffer, je.byteOffset, je.length), Ve = fn.getUint32(0);
          if (Ve > Math.pow(2, 21) - 1) {
            Ue.enqueue(ERROR_PACKET);
            break;
          }
          Pe = Ve * Math.pow(2, 32) + fn.getUint32(4), Be = 3;
        } else {
          if (totalLength(Ie) < Pe)
            break;
          const je = concatChunks(Ie, Pe);
          Ue.enqueue(decodePacket(Te ? je : TEXT_DECODER.decode(je), t)), Be = 0;
        }
        if (Pe === 0 || Pe > Ae) {
          Ue.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
const protocol$1 = 4;
function Emitter(Ae) {
  if (Ae) return mixin(Ae);
}
function mixin(Ae) {
  for (var t in Emitter.prototype)
    Ae[t] = Emitter.prototype[t];
  return Ae;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(Ae, t) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + Ae] = this._callbacks["$" + Ae] || []).push(t), this;
};
Emitter.prototype.once = function(Ae, t) {
  function Ie() {
    this.off(Ae, Ie), t.apply(this, arguments);
  }
  return Ie.fn = t, this.on(Ae, Ie), this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(Ae, t) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var Ie = this._callbacks["$" + Ae];
  if (!Ie) return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + Ae], this;
  for (var Be, Pe = 0; Pe < Ie.length; Pe++)
    if (Be = Ie[Pe], Be === t || Be.fn === t) {
      Ie.splice(Pe, 1);
      break;
    }
  return Ie.length === 0 && delete this._callbacks["$" + Ae], this;
};
Emitter.prototype.emit = function(Ae) {
  this._callbacks = this._callbacks || {};
  for (var t = new Array(arguments.length - 1), Ie = this._callbacks["$" + Ae], Be = 1; Be < arguments.length; Be++)
    t[Be - 1] = arguments[Be];
  if (Ie) {
    Ie = Ie.slice(0);
    for (var Be = 0, Pe = Ie.length; Be < Pe; ++Be)
      Ie[Be].apply(this, t);
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(Ae) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + Ae] || [];
};
Emitter.prototype.hasListeners = function(Ae) {
  return !!this.listeners(Ae).length;
};
const nextTick = typeof Promise == "function" && typeof Promise.resolve == "function" ? (t) => Promise.resolve().then(t) : (t, Ie) => Ie(t, 0), globalThisShim = typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")(), defaultBinaryType = "arraybuffer";
function createCookieJar() {
}
function pick(Ae, ...t) {
  return t.reduce((Ie, Be) => (Ae.hasOwnProperty(Be) && (Ie[Be] = Ae[Be]), Ie), {});
}
const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout, NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(Ae, t) {
  t.useNativeTimers ? (Ae.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim), Ae.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim)) : (Ae.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim), Ae.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim));
}
const BASE64_OVERHEAD = 1.33;
function byteLength(Ae) {
  return typeof Ae == "string" ? utf8Length(Ae) : Math.ceil((Ae.byteLength || Ae.size) * BASE64_OVERHEAD);
}
function utf8Length(Ae) {
  let t = 0, Ie = 0;
  for (let Be = 0, Pe = Ae.length; Be < Pe; Be++)
    t = Ae.charCodeAt(Be), t < 128 ? Ie += 1 : t < 2048 ? Ie += 2 : t < 55296 || t >= 57344 ? Ie += 3 : (Be++, Ie += 4);
  return Ie;
}
function randomString() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function encode$3(Ae) {
  let t = "";
  for (let Ie in Ae)
    Ae.hasOwnProperty(Ie) && (t.length && (t += "&"), t += encodeURIComponent(Ie) + "=" + encodeURIComponent(Ae[Ie]));
  return t;
}
function decode$4(Ae) {
  let t = {}, Ie = Ae.split("&");
  for (let Be = 0, Pe = Ie.length; Be < Pe; Be++) {
    let Te = Ie[Be].split("=");
    t[decodeURIComponent(Te[0])] = decodeURIComponent(Te[1]);
  }
  return t;
}
class TransportError extends Error {
  constructor(t, Ie, Be) {
    super(t), this.description = Ie, this.context = Be, this.type = "TransportError";
  }
}
class Transport extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(t) {
    super(), this.writable = !1, installTimerFunctions(this, t), this.opts = t, this.query = t.query, this.socket = t.socket, this.supportsBinary = !t.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(t, Ie, Be) {
    return super.emitReserved("error", new TransportError(t, Ie, Be)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(t) {
    this.readyState === "open" && this.write(t);
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(t) {
    const Ie = decodePacket(t, this.socket.binaryType);
    this.onPacket(Ie);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(t) {
    super.emitReserved("packet", t);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(t) {
    this.readyState = "closed", super.emitReserved("close", t);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(t) {
  }
  createUri(t, Ie = {}) {
    return t + "://" + this._hostname() + this._port() + this.opts.path + this._query(Ie);
  }
  _hostname() {
    const t = this.opts.hostname;
    return t.indexOf(":") === -1 ? t : "[" + t + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(t) {
    const Ie = encode$3(t);
    return Ie.length ? "?" + Ie : "";
  }
}
class Polling extends Transport {
  constructor() {
    super(...arguments), this._polling = !1;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(t) {
    this.readyState = "pausing";
    const Ie = () => {
      this.readyState = "paused", t();
    };
    if (this._polling || !this.writable) {
      let Be = 0;
      this._polling && (Be++, this.once("pollComplete", function() {
        --Be || Ie();
      })), this.writable || (Be++, this.once("drain", function() {
        --Be || Ie();
      }));
    } else
      Ie();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(t) {
    const Ie = (Be) => {
      if (this.readyState === "opening" && Be.type === "open" && this.onOpen(), Be.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(Be);
    };
    decodePayload(t, this.socket.binaryType).forEach(Ie), this.readyState !== "closed" && (this._polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this._poll());
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const t = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? t() : this.once("open", t);
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(t) {
    this.writable = !1, encodePayload(t, (Ie) => {
      this.doWrite(Ie, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const t = this.opts.secure ? "https" : "http", Ie = this.query || {};
    return this.opts.timestampRequests !== !1 && (Ie[this.opts.timestampParam] = randomString()), !this.supportsBinary && !Ie.sid && (Ie.b64 = 1), this.createUri(t, Ie);
  }
}
let value = !1;
try {
  value = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch (Ae) {
}
const hasCORS = value;
function empty() {
}
class BaseXHR extends Polling {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(t) {
    if (super(t), typeof location < "u") {
      const Ie = location.protocol === "https:";
      let Be = location.port;
      Be || (Be = Ie ? "443" : "80"), this.xd = typeof location < "u" && t.hostname !== location.hostname || Be !== t.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(t, Ie) {
    const Be = this.request({
      method: "POST",
      data: t
    });
    Be.on("success", Ie), Be.on("error", (Pe, Te) => {
      this.onError("xhr post error", Pe, Te);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const t = this.request();
    t.on("data", this.onData.bind(this)), t.on("error", (Ie, Be) => {
      this.onError("xhr poll error", Ie, Be);
    }), this.pollXhr = t;
  }
}
let Request$1 = class xc extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(t, Ie, Be) {
    super(), this.createRequest = t, installTimerFunctions(this, Be), this._opts = Be, this._method = Be.method || "GET", this._uri = Ie, this._data = Be.data !== void 0 ? Be.data : null, this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var t;
    const Ie = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    Ie.xdomain = !!this._opts.xd;
    const Be = this._xhr = this.createRequest(Ie);
    try {
      Be.open(this._method, this._uri, !0);
      try {
        if (this._opts.extraHeaders) {
          Be.setDisableHeaderCheck && Be.setDisableHeaderCheck(!0);
          for (let Pe in this._opts.extraHeaders)
            this._opts.extraHeaders.hasOwnProperty(Pe) && Be.setRequestHeader(Pe, this._opts.extraHeaders[Pe]);
        }
      } catch {
      }
      if (this._method === "POST")
        try {
          Be.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        Be.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (t = this._opts.cookieJar) === null || t === void 0 || t.addCookies(Be), "withCredentials" in Be && (Be.withCredentials = this._opts.withCredentials), this._opts.requestTimeout && (Be.timeout = this._opts.requestTimeout), Be.onreadystatechange = () => {
        var Pe;
        Be.readyState === 3 && ((Pe = this._opts.cookieJar) === null || Pe === void 0 || Pe.parseCookies(
          // @ts-ignore
          Be.getResponseHeader("set-cookie")
        )), Be.readyState === 4 && (Be.status === 200 || Be.status === 1223 ? this._onLoad() : this.setTimeoutFn(() => {
          this._onError(typeof Be.status == "number" ? Be.status : 0);
        }, 0));
      }, Be.send(this._data);
    } catch (Pe) {
      this.setTimeoutFn(() => {
        this._onError(Pe);
      }, 0);
      return;
    }
    typeof document < "u" && (this._index = xc.requestsCount++, xc.requests[this._index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(t) {
    this.emitReserved("error", t, this._xhr), this._cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(t) {
    if (!(typeof this._xhr > "u" || this._xhr === null)) {
      if (this._xhr.onreadystatechange = empty, t)
        try {
          this._xhr.abort();
        } catch {
        }
      typeof document < "u" && delete xc.requests[this._index], this._xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const t = this._xhr.responseText;
    t !== null && (this.emitReserved("data", t), this.emitReserved("success"), this._cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
};
Request$1.requestsCount = 0;
Request$1.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", unloadHandler);
  else if (typeof addEventListener == "function") {
    const Ae = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(Ae, unloadHandler, !1);
  }
}
function unloadHandler() {
  for (let Ae in Request$1.requests)
    Request$1.requests.hasOwnProperty(Ae) && Request$1.requests[Ae].abort();
}
const hasXHR2 = function() {
  const Ae = newRequest({
    xdomain: !1
  });
  return Ae && Ae.responseType !== null;
}();
class XHR extends BaseXHR {
  constructor(t) {
    super(t);
    const Ie = t && t.forceBase64;
    this.supportsBinary = hasXHR2 && !Ie;
  }
  request(t = {}) {
    return Object.assign(t, { xd: this.xd }, this.opts), new Request$1(newRequest, this.uri(), t);
  }
}
function newRequest(Ae) {
  const t = Ae.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!t || hasCORS))
      return new XMLHttpRequest();
  } catch {
  }
  if (!t)
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
const isReactNative = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class BaseWS extends Transport {
  get name() {
    return "websocket";
  }
  doOpen() {
    const t = this.uri(), Ie = this.opts.protocols, Be = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (Be.headers = this.opts.extraHeaders);
    try {
      this.ws = this.createSocket(t, Ie, Be);
    } catch (Pe) {
      return this.emitReserved("error", Pe);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (t) => this.onClose({
      description: "websocket connection closed",
      context: t
    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError("websocket error", t);
  }
  write(t) {
    this.writable = !1;
    for (let Ie = 0; Ie < t.length; Ie++) {
      const Be = t[Ie], Pe = Ie === t.length - 1;
      encodePacket(Be, this.supportsBinary, (Te) => {
        try {
          this.doWrite(Be, Te);
        } catch {
        }
        Pe && nextTick(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const t = this.opts.secure ? "wss" : "ws", Ie = this.query || {};
    return this.opts.timestampRequests && (Ie[this.opts.timestampParam] = randomString()), this.supportsBinary || (Ie.b64 = 1), this.createUri(t, Ie);
  }
}
const WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
class WS extends BaseWS {
  createSocket(t, Ie, Be) {
    return isReactNative ? new WebSocketCtor(t, Ie, Be) : Ie ? new WebSocketCtor(t, Ie) : new WebSocketCtor(t);
  }
  doWrite(t, Ie) {
    this.ws.send(Ie);
  }
}
class WT extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (t) {
      return this.emitReserved("error", t);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((t) => {
      this.onError("webtransport error", t);
    }), this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((t) => {
        const Ie = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType), Be = t.readable.pipeThrough(Ie).getReader(), Pe = createPacketEncoderStream();
        Pe.readable.pipeTo(t.writable), this._writer = Pe.writable.getWriter();
        const Te = () => {
          Be.read().then(({ done: Ue, value: je }) => {
            Ue || (this.onPacket(je), Te());
          }).catch((Ue) => {
          });
        };
        Te();
        const Me = { type: "open" };
        this.query.sid && (Me.data = `{"sid":"${this.query.sid}"}`), this._writer.write(Me).then(() => this.onOpen());
      });
    });
  }
  write(t) {
    this.writable = !1;
    for (let Ie = 0; Ie < t.length; Ie++) {
      const Be = t[Ie], Pe = Ie === t.length - 1;
      this._writer.write(Be).then(() => {
        Pe && nextTick(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var t;
    (t = this._transport) === null || t === void 0 || t.close();
  }
}
const transports = {
  websocket: WS,
  webtransport: WT,
  polling: XHR
}, re$3 = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse(Ae) {
  if (Ae.length > 8e3)
    throw "URI too long";
  const t = Ae, Ie = Ae.indexOf("["), Be = Ae.indexOf("]");
  Ie != -1 && Be != -1 && (Ae = Ae.substring(0, Ie) + Ae.substring(Ie, Be).replace(/:/g, ";") + Ae.substring(Be, Ae.length));
  let Pe = re$3.exec(Ae || ""), Te = {}, Me = 14;
  for (; Me--; )
    Te[parts[Me]] = Pe[Me] || "";
  return Ie != -1 && Be != -1 && (Te.source = t, Te.host = Te.host.substring(1, Te.host.length - 1).replace(/;/g, ":"), Te.authority = Te.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), Te.ipv6uri = !0), Te.pathNames = pathNames(Te, Te.path), Te.queryKey = queryKey(Te, Te.query), Te;
}
function pathNames(Ae, t) {
  const Ie = /\/{2,9}/g, Be = t.replace(Ie, "/").split("/");
  return (t.slice(0, 1) == "/" || t.length === 0) && Be.splice(0, 1), t.slice(-1) == "/" && Be.splice(Be.length - 1, 1), Be;
}
function queryKey(Ae, t) {
  const Ie = {};
  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(Be, Pe, Te) {
    Pe && (Ie[Pe] = Te);
  }), Ie;
}
const withEventListeners = typeof addEventListener == "function" && typeof removeEventListener == "function", OFFLINE_EVENT_LISTENERS = [];
withEventListeners && addEventListener("offline", () => {
  OFFLINE_EVENT_LISTENERS.forEach((Ae) => Ae());
}, !1);
class SocketWithoutUpgrade extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(t, Ie) {
    if (super(), this.binaryType = defaultBinaryType, this.writeBuffer = [], this._prevBufferLen = 0, this._pingInterval = -1, this._pingTimeout = -1, this._maxPayload = -1, this._pingTimeoutTime = 1 / 0, t && typeof t == "object" && (Ie = t, t = null), t) {
      const Be = parse(t);
      Ie.hostname = Be.host, Ie.secure = Be.protocol === "https" || Be.protocol === "wss", Ie.port = Be.port, Be.query && (Ie.query = Be.query);
    } else Ie.host && (Ie.hostname = parse(Ie.host).host);
    installTimerFunctions(this, Ie), this.secure = Ie.secure != null ? Ie.secure : typeof location < "u" && location.protocol === "https:", Ie.hostname && !Ie.port && (Ie.port = this.secure ? "443" : "80"), this.hostname = Ie.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = Ie.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = [], this._transportsByName = {}, Ie.transports.forEach((Be) => {
      const Pe = Be.prototype.name;
      this.transports.push(Pe), this._transportsByName[Pe] = Be;
    }), this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !1
    }, Ie), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = decode$4(this.opts.query)), withEventListeners && (this.opts.closeOnBeforeunload && (this._beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this._beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this._offlineEventListener = () => {
      this._onClose("transport close", {
        description: "network connection lost"
      });
    }, OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener))), this.opts.withCredentials && (this._cookieJar = void 0), this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(t) {
    const Ie = Object.assign({}, this.opts.query);
    Ie.EIO = protocol$1, Ie.transport = t, this.id && (Ie.sid = this.id);
    const Be = Object.assign({}, this.opts, {
      query: Ie,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[t]);
    return new this._transportsByName[t](Be);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const t = this.opts.rememberUpgrade && SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const Ie = this.createTransport(t);
    Ie.open(), this.setTransport(Ie);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(t) {
    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (Ie) => this._onClose("transport close", Ie));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open", SocketWithoutUpgrade.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(t) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", t), this.emitReserved("heartbeat"), t.type) {
        case "open":
          this.onHandshake(JSON.parse(t.data));
          break;
        case "ping":
          this._sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"), this._resetPingTimeout();
          break;
        case "error":
          const Ie = new Error("server error");
          Ie.code = t.data, this._onError(Ie);
          break;
        case "message":
          this.emitReserved("data", t.data), this.emitReserved("message", t.data);
          break;
      }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(t) {
    this.emitReserved("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this._pingInterval = t.pingInterval, this._pingTimeout = t.pingTimeout, this._maxPayload = t.maxPayload, this.onOpen(), this.readyState !== "closed" && this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const t = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + t, this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, t), this.opts.autoUnref && this._pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen), this._prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const t = this._getWritablePackets();
      this.transport.send(t), this._prevBufferLen = t.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    if (!(this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let Ie = 1;
    for (let Be = 0; Be < this.writeBuffer.length; Be++) {
      const Pe = this.writeBuffer[Be].data;
      if (Pe && (Ie += byteLength(Pe)), Be > 0 && Ie > this._maxPayload)
        return this.writeBuffer.slice(0, Be);
      Ie += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return !0;
    const t = Date.now() > this._pingTimeoutTime;
    return t && (this._pingTimeoutTime = 0, nextTick(() => {
      this._onClose("ping timeout");
    }, this.setTimeoutFn)), t;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(t, Ie, Be) {
    return this._sendPacket("message", t, Ie, Be), this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(t, Ie, Be) {
    return this._sendPacket("message", t, Ie, Be), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(t, Ie, Be, Pe) {
    if (typeof Ie == "function" && (Pe = Ie, Ie = void 0), typeof Be == "function" && (Pe = Be, Be = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    Be = Be || {}, Be.compress = Be.compress !== !1;
    const Te = {
      type: t,
      data: Ie,
      options: Be
    };
    this.emitReserved("packetCreate", Te), this.writeBuffer.push(Te), Pe && this.once("flush", Pe), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const t = () => {
      this._onClose("forced close"), this.transport.close();
    }, Ie = () => {
      this.off("upgrade", Ie), this.off("upgradeError", Ie), t();
    }, Be = () => {
      this.once("upgrade", Ie), this.once("upgradeError", Ie);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? Be() : t();
    }) : this.upgrading ? Be() : t()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(t) {
    if (SocketWithoutUpgrade.priorWebsocketSuccess = !1, this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening")
      return this.transports.shift(), this._open();
    this.emitReserved("error", t), this._onClose("transport error", t);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(t, Ie) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      if (this.clearTimeoutFn(this._pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), withEventListeners && (this._beforeunloadEventListener && removeEventListener("beforeunload", this._beforeunloadEventListener, !1), this._offlineEventListener)) {
        const Be = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
        Be !== -1 && OFFLINE_EVENT_LISTENERS.splice(Be, 1);
      }
      this.readyState = "closed", this.id = null, this.emitReserved("close", t, Ie), this.writeBuffer = [], this._prevBufferLen = 0;
    }
  }
}
SocketWithoutUpgrade.protocol = protocol$1;
class SocketWithUpgrade extends SocketWithoutUpgrade {
  constructor() {
    super(...arguments), this._upgrades = [];
  }
  onOpen() {
    if (super.onOpen(), this.readyState === "open" && this.opts.upgrade)
      for (let t = 0; t < this._upgrades.length; t++)
        this._probe(this._upgrades[t]);
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(t) {
    let Ie = this.createTransport(t), Be = !1;
    SocketWithoutUpgrade.priorWebsocketSuccess = !1;
    const Pe = () => {
      Be || (Ie.send([{ type: "ping", data: "probe" }]), Ie.once("packet", (vn) => {
        if (!Be)
          if (vn.type === "pong" && vn.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", Ie), !Ie)
              return;
            SocketWithoutUpgrade.priorWebsocketSuccess = Ie.name === "websocket", this.transport.pause(() => {
              Be || this.readyState !== "closed" && (Ve(), this.setTransport(Ie), Ie.send([{ type: "upgrade" }]), this.emitReserved("upgrade", Ie), Ie = null, this.upgrading = !1, this.flush());
            });
          } else {
            const En = new Error("probe error");
            En.transport = Ie.name, this.emitReserved("upgradeError", En);
          }
      }));
    };
    function Te() {
      Be || (Be = !0, Ve(), Ie.close(), Ie = null);
    }
    const Me = (vn) => {
      const En = new Error("probe error: " + vn);
      En.transport = Ie.name, Te(), this.emitReserved("upgradeError", En);
    };
    function Ue() {
      Me("transport closed");
    }
    function je() {
      Me("socket closed");
    }
    function fn(vn) {
      Ie && vn.name !== Ie.name && Te();
    }
    const Ve = () => {
      Ie.removeListener("open", Pe), Ie.removeListener("error", Me), Ie.removeListener("close", Ue), this.off("close", je), this.off("upgrading", fn);
    };
    Ie.once("open", Pe), Ie.once("error", Me), Ie.once("close", Ue), this.once("close", je), this.once("upgrading", fn), this._upgrades.indexOf("webtransport") !== -1 && t !== "webtransport" ? this.setTimeoutFn(() => {
      Be || Ie.open();
    }, 200) : Ie.open();
  }
  onHandshake(t) {
    this._upgrades = this._filterUpgrades(t.upgrades), super.onHandshake(t);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(t) {
    const Ie = [];
    for (let Be = 0; Be < t.length; Be++)
      ~this.transports.indexOf(t[Be]) && Ie.push(t[Be]);
    return Ie;
  }
}
let Socket$1 = class extends SocketWithUpgrade {
  constructor(t, Ie = {}) {
    const Be = typeof t == "object" ? t : Ie;
    (!Be.transports || Be.transports && typeof Be.transports[0] == "string") && (Be.transports = (Be.transports || ["polling", "websocket", "webtransport"]).map((Pe) => transports[Pe]).filter((Pe) => !!Pe)), super(t, Be);
  }
};
function url(Ae, t = "", Ie) {
  let Be = Ae;
  Ie = Ie || typeof location < "u" && location, Ae == null && (Ae = Ie.protocol + "//" + Ie.host), typeof Ae == "string" && (Ae.charAt(0) === "/" && (Ae.charAt(1) === "/" ? Ae = Ie.protocol + Ae : Ae = Ie.host + Ae), /^(https?|wss?):\/\//.test(Ae) || (typeof Ie < "u" ? Ae = Ie.protocol + "//" + Ae : Ae = "https://" + Ae), Be = parse(Ae)), Be.port || (/^(http|ws)$/.test(Be.protocol) ? Be.port = "80" : /^(http|ws)s$/.test(Be.protocol) && (Be.port = "443")), Be.path = Be.path || "/";
  const Te = Be.host.indexOf(":") !== -1 ? "[" + Be.host + "]" : Be.host;
  return Be.id = Be.protocol + "://" + Te + ":" + Be.port + t, Be.href = Be.protocol + "://" + Te + (Ie && Ie.port === Be.port ? "" : ":" + Be.port), Be;
}
const withNativeArrayBuffer = typeof ArrayBuffer == "function", isView = (Ae) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(Ae) : Ae.buffer instanceof ArrayBuffer, toString$2 = Object.prototype.toString, withNativeBlob = typeof Blob == "function" || typeof Blob < "u" && toString$2.call(Blob) === "[object BlobConstructor]", withNativeFile = typeof File == "function" || typeof File < "u" && toString$2.call(File) === "[object FileConstructor]";
function isBinary(Ae) {
  return withNativeArrayBuffer && (Ae instanceof ArrayBuffer || isView(Ae)) || withNativeBlob && Ae instanceof Blob || withNativeFile && Ae instanceof File;
}
function hasBinary(Ae, t) {
  if (!Ae || typeof Ae != "object")
    return !1;
  if (Array.isArray(Ae)) {
    for (let Ie = 0, Be = Ae.length; Ie < Be; Ie++)
      if (hasBinary(Ae[Ie]))
        return !0;
    return !1;
  }
  if (isBinary(Ae))
    return !0;
  if (Ae.toJSON && typeof Ae.toJSON == "function" && arguments.length === 1)
    return hasBinary(Ae.toJSON(), !0);
  for (const Ie in Ae)
    if (Object.prototype.hasOwnProperty.call(Ae, Ie) && hasBinary(Ae[Ie]))
      return !0;
  return !1;
}
function deconstructPacket(Ae) {
  const t = [], Ie = Ae.data, Be = Ae;
  return Be.data = _deconstructPacket(Ie, t), Be.attachments = t.length, { packet: Be, buffers: t };
}
function _deconstructPacket(Ae, t) {
  if (!Ae)
    return Ae;
  if (isBinary(Ae)) {
    const Ie = { _placeholder: !0, num: t.length };
    return t.push(Ae), Ie;
  } else if (Array.isArray(Ae)) {
    const Ie = new Array(Ae.length);
    for (let Be = 0; Be < Ae.length; Be++)
      Ie[Be] = _deconstructPacket(Ae[Be], t);
    return Ie;
  } else if (typeof Ae == "object" && !(Ae instanceof Date)) {
    const Ie = {};
    for (const Be in Ae)
      Object.prototype.hasOwnProperty.call(Ae, Be) && (Ie[Be] = _deconstructPacket(Ae[Be], t));
    return Ie;
  }
  return Ae;
}
function reconstructPacket(Ae, t) {
  return Ae.data = _reconstructPacket(Ae.data, t), delete Ae.attachments, Ae;
}
function _reconstructPacket(Ae, t) {
  if (!Ae)
    return Ae;
  if (Ae && Ae._placeholder === !0) {
    if (typeof Ae.num == "number" && Ae.num >= 0 && Ae.num < t.length)
      return t[Ae.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(Ae))
    for (let Ie = 0; Ie < Ae.length; Ie++)
      Ae[Ie] = _reconstructPacket(Ae[Ie], t);
  else if (typeof Ae == "object")
    for (const Ie in Ae)
      Object.prototype.hasOwnProperty.call(Ae, Ie) && (Ae[Ie] = _reconstructPacket(Ae[Ie], t));
  return Ae;
}
const RESERVED_EVENTS$1 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
], protocol = 5;
var PacketType;
(function(Ae) {
  Ae[Ae.CONNECT = 0] = "CONNECT", Ae[Ae.DISCONNECT = 1] = "DISCONNECT", Ae[Ae.EVENT = 2] = "EVENT", Ae[Ae.ACK = 3] = "ACK", Ae[Ae.CONNECT_ERROR = 4] = "CONNECT_ERROR", Ae[Ae.BINARY_EVENT = 5] = "BINARY_EVENT", Ae[Ae.BINARY_ACK = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
let Encoder$1 = class {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(t) {
    this.replacer = t;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(t) {
    return (t.type === PacketType.EVENT || t.type === PacketType.ACK) && hasBinary(t) ? this.encodeAsBinary({
      type: t.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
      nsp: t.nsp,
      data: t.data,
      id: t.id
    }) : [this.encodeAsString(t)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(t) {
    let Ie = "" + t.type;
    return (t.type === PacketType.BINARY_EVENT || t.type === PacketType.BINARY_ACK) && (Ie += t.attachments + "-"), t.nsp && t.nsp !== "/" && (Ie += t.nsp + ","), t.id != null && (Ie += t.id), t.data != null && (Ie += JSON.stringify(t.data, this.replacer)), Ie;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(t) {
    const Ie = deconstructPacket(t), Be = this.encodeAsString(Ie.packet), Pe = Ie.buffers;
    return Pe.unshift(Be), Pe;
  }
};
function isObject$1(Ae) {
  return Object.prototype.toString.call(Ae) === "[object Object]";
}
let Decoder$1 = class zc extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(t) {
    super(), this.reviver = t;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(t) {
    let Ie;
    if (typeof t == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      Ie = this.decodeString(t);
      const Be = Ie.type === PacketType.BINARY_EVENT;
      Be || Ie.type === PacketType.BINARY_ACK ? (Ie.type = Be ? PacketType.EVENT : PacketType.ACK, this.reconstructor = new BinaryReconstructor(Ie), Ie.attachments === 0 && super.emitReserved("decoded", Ie)) : super.emitReserved("decoded", Ie);
    } else if (isBinary(t) || t.base64)
      if (this.reconstructor)
        Ie = this.reconstructor.takeBinaryData(t), Ie && (this.reconstructor = null, super.emitReserved("decoded", Ie));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + t);
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(t) {
    let Ie = 0;
    const Be = {
      type: Number(t.charAt(0))
    };
    if (PacketType[Be.type] === void 0)
      throw new Error("unknown packet type " + Be.type);
    if (Be.type === PacketType.BINARY_EVENT || Be.type === PacketType.BINARY_ACK) {
      const Te = Ie + 1;
      for (; t.charAt(++Ie) !== "-" && Ie != t.length; )
        ;
      const Me = t.substring(Te, Ie);
      if (Me != Number(Me) || t.charAt(Ie) !== "-")
        throw new Error("Illegal attachments");
      Be.attachments = Number(Me);
    }
    if (t.charAt(Ie + 1) === "/") {
      const Te = Ie + 1;
      for (; ++Ie && !(t.charAt(Ie) === "," || Ie === t.length); )
        ;
      Be.nsp = t.substring(Te, Ie);
    } else
      Be.nsp = "/";
    const Pe = t.charAt(Ie + 1);
    if (Pe !== "" && Number(Pe) == Pe) {
      const Te = Ie + 1;
      for (; ++Ie; ) {
        const Me = t.charAt(Ie);
        if (Me == null || Number(Me) != Me) {
          --Ie;
          break;
        }
        if (Ie === t.length)
          break;
      }
      Be.id = Number(t.substring(Te, Ie + 1));
    }
    if (t.charAt(++Ie)) {
      const Te = this.tryParse(t.substr(Ie));
      if (zc.isPayloadValid(Be.type, Te))
        Be.data = Te;
      else
        throw new Error("invalid payload");
    }
    return Be;
  }
  tryParse(t) {
    try {
      return JSON.parse(t, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(t, Ie) {
    switch (t) {
      case PacketType.CONNECT:
        return isObject$1(Ie);
      case PacketType.DISCONNECT:
        return Ie === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof Ie == "string" || isObject$1(Ie);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(Ie) && (typeof Ie[0] == "number" || typeof Ie[0] == "string" && RESERVED_EVENTS$1.indexOf(Ie[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(Ie);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
};
class BinaryReconstructor {
  constructor(t) {
    this.packet = t, this.buffers = [], this.reconPack = t;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(t) {
    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {
      const Ie = reconstructPacket(this.reconPack, this.buffers);
      return this.finishedReconstruction(), Ie;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder: Decoder$1,
  Encoder: Encoder$1,
  get PacketType() {
    return PacketType;
  },
  protocol
}, Symbol.toStringTag, { value: "Module" }));
function on$2(Ae, t, Ie) {
  return Ae.on(t, Ie), function() {
    Ae.off(t, Ie);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Socket extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(t, Ie, Be) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = Ie, Be && Be.auth && (this.auth = Be.auth), this._opts = Object.assign({}, Be), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const t = this.io;
    this.subs = [
      on$2(t, "open", this.onopen.bind(this)),
      on$2(t, "packet", this.onpacket.bind(this)),
      on$2(t, "error", this.onerror.bind(this)),
      on$2(t, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...t) {
    return t.unshift("message"), this.emit.apply(this, t), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(t, ...Ie) {
    var Be, Pe, Te;
    if (RESERVED_EVENTS.hasOwnProperty(t))
      throw new Error('"' + t.toString() + '" is a reserved event name');
    if (Ie.unshift(t), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(Ie), this;
    const Me = {
      type: PacketType.EVENT,
      data: Ie
    };
    if (Me.options = {}, Me.options.compress = this.flags.compress !== !1, typeof Ie[Ie.length - 1] == "function") {
      const Ve = this.ids++, vn = Ie.pop();
      this._registerAckCallback(Ve, vn), Me.id = Ve;
    }
    const Ue = (Pe = (Be = this.io.engine) === null || Be === void 0 ? void 0 : Be.transport) === null || Pe === void 0 ? void 0 : Pe.writable, je = this.connected && !(!((Te = this.io.engine) === null || Te === void 0) && Te._hasPingExpired());
    return this.flags.volatile && !Ue || (je ? (this.notifyOutgoingListeners(Me), this.packet(Me)) : this.sendBuffer.push(Me)), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(t, Ie) {
    var Be;
    const Pe = (Be = this.flags.timeout) !== null && Be !== void 0 ? Be : this._opts.ackTimeout;
    if (Pe === void 0) {
      this.acks[t] = Ie;
      return;
    }
    const Te = this.io.setTimeoutFn(() => {
      delete this.acks[t];
      for (let Ue = 0; Ue < this.sendBuffer.length; Ue++)
        this.sendBuffer[Ue].id === t && this.sendBuffer.splice(Ue, 1);
      Ie.call(this, new Error("operation has timed out"));
    }, Pe), Me = (...Ue) => {
      this.io.clearTimeoutFn(Te), Ie.apply(this, Ue);
    };
    Me.withError = !0, this.acks[t] = Me;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(t, ...Ie) {
    return new Promise((Be, Pe) => {
      const Te = (Me, Ue) => Me ? Pe(Me) : Be(Ue);
      Te.withError = !0, Ie.push(Te), this.emit(t, ...Ie);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(t) {
    let Ie;
    typeof t[t.length - 1] == "function" && (Ie = t.pop());
    const Be = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: t,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    t.push((Pe, ...Te) => Be !== this._queue[0] ? void 0 : (Pe !== null ? Be.tryCount > this._opts.retries && (this._queue.shift(), Ie && Ie(Pe)) : (this._queue.shift(), Ie && Ie(null, ...Te)), Be.pending = !1, this._drainQueue())), this._queue.push(Be), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(t = !1) {
    if (!this.connected || this._queue.length === 0)
      return;
    const Ie = this._queue[0];
    Ie.pending && !t || (Ie.pending = !0, Ie.tryCount++, this.flags = Ie.flags, this.emit.apply(this, Ie.args));
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(t) {
    t.nsp = this.nsp, this.io._packet(t);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    typeof this.auth == "function" ? this.auth((t) => {
      this._sendConnectPacket(t);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(t) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, t) : t
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(t) {
    this.connected || this.emitReserved("connect_error", t);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(t, Ie) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", t, Ie), this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((t) => {
      if (!this.sendBuffer.some((Be) => String(Be.id) === t)) {
        const Be = this.acks[t];
        delete this.acks[t], Be.withError && Be.call(this, new Error("socket has been disconnected"));
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(t) {
    if (t.nsp === this.nsp)
      switch (t.type) {
        case PacketType.CONNECT:
          t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          this.onevent(t);
          break;
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          this.onack(t);
          break;
        case PacketType.DISCONNECT:
          this.ondisconnect();
          break;
        case PacketType.CONNECT_ERROR:
          this.destroy();
          const Be = new Error(t.data.message);
          Be.data = t.data.data, this.emitReserved("connect_error", Be);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(t) {
    const Ie = t.data || [];
    t.id != null && Ie.push(this.ack(t.id)), this.connected ? this.emitEvent(Ie) : this.receiveBuffer.push(Object.freeze(Ie));
  }
  emitEvent(t) {
    if (this._anyListeners && this._anyListeners.length) {
      const Ie = this._anyListeners.slice();
      for (const Be of Ie)
        Be.apply(this, t);
    }
    super.emit.apply(this, t), this._pid && t.length && typeof t[t.length - 1] == "string" && (this._lastOffset = t[t.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(t) {
    const Ie = this;
    let Be = !1;
    return function(...Pe) {
      Be || (Be = !0, Ie.packet({
        type: PacketType.ACK,
        id: t,
        data: Pe
      }));
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(t) {
    const Ie = this.acks[t.id];
    typeof Ie == "function" && (delete this.acks[t.id], Ie.withError && t.data.unshift(null), Ie.apply(this, t.data));
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(t, Ie) {
    this.id = t, this.recovered = Ie && this._pid === Ie, this._pid = Ie, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {
      this.notifyOutgoingListeners(t), this.packet(t);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && this.packet({ type: PacketType.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(t) {
    return this.flags.compress = t, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(t) {
    return this.flags.timeout = t, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(t) {
    if (!this._anyListeners)
      return this;
    if (t) {
      const Ie = this._anyListeners;
      for (let Be = 0; Be < Ie.length; Be++)
        if (t === Ie[Be])
          return Ie.splice(Be, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(t) {
    if (!this._anyOutgoingListeners)
      return this;
    if (t) {
      const Ie = this._anyOutgoingListeners;
      for (let Be = 0; Be < Ie.length; Be++)
        if (t === Ie[Be])
          return Ie.splice(Be, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(t) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const Ie = this._anyOutgoingListeners.slice();
      for (const Be of Ie)
        Be.apply(this, t.data);
    }
  }
}
function Backoff(Ae) {
  Ae = Ae || {}, this.ms = Ae.min || 100, this.max = Ae.max || 1e4, this.factor = Ae.factor || 2, this.jitter = Ae.jitter > 0 && Ae.jitter <= 1 ? Ae.jitter : 0, this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var Ae = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var t = Math.random(), Ie = Math.floor(t * this.jitter * Ae);
    Ae = Math.floor(t * 10) & 1 ? Ae + Ie : Ae - Ie;
  }
  return Math.min(Ae, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(Ae) {
  this.ms = Ae;
};
Backoff.prototype.setMax = function(Ae) {
  this.max = Ae;
};
Backoff.prototype.setJitter = function(Ae) {
  this.jitter = Ae;
};
class Manager extends Emitter {
  constructor(t, Ie) {
    var Be;
    super(), this.nsps = {}, this.subs = [], t && typeof t == "object" && (Ie = t, t = void 0), Ie = Ie || {}, Ie.path = Ie.path || "/socket.io", this.opts = Ie, installTimerFunctions(this, Ie), this.reconnection(Ie.reconnection !== !1), this.reconnectionAttempts(Ie.reconnectionAttempts || 1 / 0), this.reconnectionDelay(Ie.reconnectionDelay || 1e3), this.reconnectionDelayMax(Ie.reconnectionDelayMax || 5e3), this.randomizationFactor((Be = Ie.randomizationFactor) !== null && Be !== void 0 ? Be : 0.5), this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(Ie.timeout == null ? 2e4 : Ie.timeout), this._readyState = "closed", this.uri = t;
    const Pe = Ie.parser || parser;
    this.encoder = new Pe.Encoder(), this.decoder = new Pe.Decoder(), this._autoConnect = Ie.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(t) {
    return arguments.length ? (this._reconnection = !!t, t || (this.skipReconnect = !0), this) : this._reconnection;
  }
  reconnectionAttempts(t) {
    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);
  }
  reconnectionDelay(t) {
    var Ie;
    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (Ie = this.backoff) === null || Ie === void 0 || Ie.setMin(t), this);
  }
  randomizationFactor(t) {
    var Ie;
    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (Ie = this.backoff) === null || Ie === void 0 || Ie.setJitter(t), this);
  }
  reconnectionDelayMax(t) {
    var Ie;
    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (Ie = this.backoff) === null || Ie === void 0 || Ie.setMax(t), this);
  }
  timeout(t) {
    return arguments.length ? (this._timeout = t, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(t) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const Ie = this.engine, Be = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const Pe = on$2(Ie, "open", function() {
      Be.onopen(), t && t();
    }), Te = (Ue) => {
      this.cleanup(), this._readyState = "closed", this.emitReserved("error", Ue), t ? t(Ue) : this.maybeReconnectOnOpen();
    }, Me = on$2(Ie, "error", Te);
    if (this._timeout !== !1) {
      const Ue = this._timeout, je = this.setTimeoutFn(() => {
        Pe(), Te(new Error("timeout")), Ie.close();
      }, Ue);
      this.opts.autoUnref && je.unref(), this.subs.push(() => {
        this.clearTimeoutFn(je);
      });
    }
    return this.subs.push(Pe), this.subs.push(Me), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(t) {
    return this.open(t);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const t = this.engine;
    this.subs.push(
      on$2(t, "ping", this.onping.bind(this)),
      on$2(t, "data", this.ondata.bind(this)),
      on$2(t, "error", this.onerror.bind(this)),
      on$2(t, "close", this.onclose.bind(this)),
      // @ts-ignore
      on$2(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(t) {
    try {
      this.decoder.add(t);
    } catch (Ie) {
      this.onclose("parse error", Ie);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(t) {
    nextTick(() => {
      this.emitReserved("packet", t);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(t) {
    this.emitReserved("error", t);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(t, Ie) {
    let Be = this.nsps[t];
    return Be ? this._autoConnect && !Be.active && Be.connect() : (Be = new Socket(this, t, Ie), this.nsps[t] = Be), Be;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(t) {
    const Ie = Object.keys(this.nsps);
    for (const Be of Ie)
      if (this.nsps[Be].active)
        return;
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(t) {
    const Ie = this.encoder.encode(t);
    for (let Be = 0; Be < Ie.length; Be++)
      this.engine.write(Ie[Be], t.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(t, Ie) {
    var Be;
    this.cleanup(), (Be = this.engine) === null || Be === void 0 || Be.close(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", t, Ie), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const t = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const Ie = this.backoff.duration();
      this._reconnecting = !0;
      const Be = this.setTimeoutFn(() => {
        t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts), !t.skipReconnect && t.open((Pe) => {
          Pe ? (t._reconnecting = !1, t.reconnect(), this.emitReserved("reconnect_error", Pe)) : t.onreconnect();
        }));
      }, Ie);
      this.opts.autoUnref && Be.unref(), this.subs.push(() => {
        this.clearTimeoutFn(Be);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const t = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", t);
  }
}
const cache = {};
function lookup(Ae, t) {
  typeof Ae == "object" && (t = Ae, Ae = void 0), t = t || {};
  const Ie = url(Ae, t.path || "/socket.io"), Be = Ie.source, Pe = Ie.id, Te = Ie.path, Me = cache[Pe] && Te in cache[Pe].nsps, Ue = t.forceNew || t["force new connection"] || t.multiplex === !1 || Me;
  let je;
  return Ue ? je = new Manager(Be, t) : (cache[Pe] || (cache[Pe] = new Manager(Be, t)), je = cache[Pe]), Ie.query && !t.query && (t.query = Ie.queryKey), je.socket(Ie.path, t);
}
Object.assign(lookup, {
  Manager,
  Socket,
  io: lookup,
  connect: lookup
});
var base64url$3 = { exports: {} }, base64url$2 = {}, padString$1 = {};
Object.defineProperty(padString$1, "__esModule", { value: !0 });
function padString(Ae) {
  var t = 4, Ie = Ae.length, Be = Ie % t;
  if (!Be)
    return Ae;
  var Pe = Ie, Te = t - Be, Me = Ie + Te, Ue = Buffer$3.alloc(Me);
  for (Ue.write(Ae); Te--; )
    Ue.write("=", Pe++);
  return Ue.toString();
}
padString$1.default = padString;
Object.defineProperty(base64url$2, "__esModule", { value: !0 });
var pad_string_1 = padString$1;
function encode$2(Ae, t) {
  return t === void 0 && (t = "utf8"), Buffer$3.isBuffer(Ae) ? fromBase64(Ae.toString("base64")) : fromBase64(Buffer$3.from(Ae, t).toString("base64"));
}
function decode$3(Ae, t) {
  return t === void 0 && (t = "utf8"), Buffer$3.from(toBase64(Ae), "base64").toString(t);
}
function toBase64(Ae) {
  return Ae = Ae.toString(), pad_string_1.default(Ae).replace(/\-/g, "+").replace(/_/g, "/");
}
function fromBase64(Ae) {
  return Ae.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function toBuffer(Ae) {
  return Buffer$3.from(toBase64(Ae), "base64");
}
var base64url$1 = encode$2;
base64url$1.encode = encode$2;
base64url$1.decode = decode$3;
base64url$1.toBase64 = toBase64;
base64url$1.fromBase64 = fromBase64;
base64url$1.toBuffer = toBuffer;
base64url$2.default = base64url$1;
(function(Ae) {
  Ae.exports = base64url$2.default, Ae.exports.default = Ae.exports;
})(base64url$3);
function commonjsRequire$1(Ae) {
  throw new Error('Could not dynamically require "' + Ae + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var browser$4 = { exports: {} }, stream$1 = { exports: {} }, primordials = {
  ArrayIsArray(Ae) {
    return Array.isArray(Ae);
  },
  ArrayPrototypeIncludes(Ae, t) {
    return Ae.includes(t);
  },
  ArrayPrototypeIndexOf(Ae, t) {
    return Ae.indexOf(t);
  },
  ArrayPrototypeJoin(Ae, t) {
    return Ae.join(t);
  },
  ArrayPrototypeMap(Ae, t) {
    return Ae.map(t);
  },
  ArrayPrototypePop(Ae, t) {
    return Ae.pop(t);
  },
  ArrayPrototypePush(Ae, t) {
    return Ae.push(t);
  },
  ArrayPrototypeSlice(Ae, t, Ie) {
    return Ae.slice(t, Ie);
  },
  Error,
  FunctionPrototypeCall(Ae, t, ...Ie) {
    return Ae.call(t, ...Ie);
  },
  FunctionPrototypeSymbolHasInstance(Ae, t) {
    return Function.prototype[Symbol.hasInstance].call(Ae, t);
  },
  MathFloor: Math.floor,
  Number,
  NumberIsInteger: Number.isInteger,
  NumberIsNaN: Number.isNaN,
  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
  NumberParseInt: Number.parseInt,
  ObjectDefineProperties(Ae, t) {
    return Object.defineProperties(Ae, t);
  },
  ObjectDefineProperty(Ae, t, Ie) {
    return Object.defineProperty(Ae, t, Ie);
  },
  ObjectGetOwnPropertyDescriptor(Ae, t) {
    return Object.getOwnPropertyDescriptor(Ae, t);
  },
  ObjectKeys(Ae) {
    return Object.keys(Ae);
  },
  ObjectSetPrototypeOf(Ae, t) {
    return Object.setPrototypeOf(Ae, t);
  },
  Promise,
  PromisePrototypeCatch(Ae, t) {
    return Ae.catch(t);
  },
  PromisePrototypeThen(Ae, t, Ie) {
    return Ae.then(t, Ie);
  },
  PromiseReject(Ae) {
    return Promise.reject(Ae);
  },
  PromiseResolve(Ae) {
    return Promise.resolve(Ae);
  },
  ReflectApply: Reflect.apply,
  RegExpPrototypeTest(Ae, t) {
    return Ae.test(t);
  },
  SafeSet: Set,
  String,
  StringPrototypeSlice(Ae, t, Ie) {
    return Ae.slice(t, Ie);
  },
  StringPrototypeToLowerCase(Ae) {
    return Ae.toLowerCase();
  },
  StringPrototypeToUpperCase(Ae) {
    return Ae.toUpperCase();
  },
  StringPrototypeTrim(Ae) {
    return Ae.trim();
  },
  Symbol,
  SymbolFor: Symbol.for,
  SymbolAsyncIterator: Symbol.asyncIterator,
  SymbolHasInstance: Symbol.hasInstance,
  SymbolIterator: Symbol.iterator,
  SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
  SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
  TypedArrayPrototypeSet(Ae, t, Ie) {
    return Ae.set(t, Ie);
  },
  Boolean,
  Uint8Array
}, util = { exports: {} }, browser$3 = { exports: {} }, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser$3.exports;
  hasRequiredBrowser = 1;
  const { AbortController: Ae, AbortSignal: t } = typeof self < "u" ? self : typeof window < "u" ? window : (
    /* otherwise */
    void 0
  );
  return browser$3.exports = Ae, browser$3.exports.AbortSignal = t, browser$3.exports.default = Ae, browser$3.exports;
}
(function(Ae) {
  const t = require$$0$4, { kResistStopPropagation: Ie, SymbolDispose: Be } = primordials, Pe = globalThis.AbortSignal || requireBrowser().AbortSignal, Te = globalThis.AbortController || requireBrowser().AbortController, Me = Object.getPrototypeOf(async function() {
  }).constructor, Ue = globalThis.Blob || t.Blob, je = typeof Ue < "u" ? function(fi) {
    return fi instanceof Ue;
  } : function(fi) {
    return !1;
  }, fn = (En, fi) => {
    if (En !== void 0 && (En === null || typeof En != "object" || !("aborted" in En)))
      throw new ERR_INVALID_ARG_TYPE(fi, "AbortSignal", En);
  }, Ve = (En, fi) => {
    if (typeof En != "function") throw new ERR_INVALID_ARG_TYPE(fi, "Function", En);
  };
  class vn extends Error {
    constructor(fi) {
      if (!Array.isArray(fi))
        throw new TypeError(`Expected input to be an Array, got ${typeof fi}`);
      let bi = "";
      for (let mi = 0; mi < fi.length; mi++)
        bi += `    ${fi[mi].stack}
`;
      super(bi), this.name = "AggregateError", this.errors = fi;
    }
  }
  Ae.exports = {
    AggregateError: vn,
    kEmptyObject: Object.freeze({}),
    once(En) {
      let fi = !1;
      return function(...bi) {
        fi || (fi = !0, En.apply(this, bi));
      };
    },
    createDeferredPromise: function() {
      let En, fi;
      return {
        promise: new Promise((mi, _i) => {
          En = mi, fi = _i;
        }),
        resolve: En,
        reject: fi
      };
    },
    promisify(En) {
      return new Promise((fi, bi) => {
        En((mi, ..._i) => mi ? bi(mi) : fi(..._i));
      });
    },
    debuglog() {
      return function() {
      };
    },
    format(En, ...fi) {
      return En.replace(/%([sdifj])/g, function(...[bi, mi]) {
        const _i = fi.shift();
        return mi === "f" ? _i.toFixed(6) : mi === "j" ? JSON.stringify(_i) : mi === "s" && typeof _i == "object" ? `${_i.constructor !== Object ? _i.constructor.name : ""} {}`.trim() : _i.toString();
      });
    },
    inspect(En) {
      switch (typeof En) {
        case "string":
          if (En.includes("'"))
            if (En.includes('"')) {
              if (!En.includes("`") && !En.includes("${"))
                return `\`${En}\``;
            } else return `"${En}"`;
          return `'${En}'`;
        case "number":
          return isNaN(En) ? "NaN" : Object.is(En, -0) ? String(En) : En;
        case "bigint":
          return `${String(En)}n`;
        case "boolean":
        case "undefined":
          return String(En);
        case "object":
          return "{}";
      }
    },
    types: {
      isAsyncFunction(En) {
        return En instanceof Me;
      },
      isArrayBufferView(En) {
        return ArrayBuffer.isView(En);
      }
    },
    isBlob: je,
    deprecate(En, fi) {
      return En;
    },
    addAbortListener: eventsExports.addAbortListener || function(fi, bi) {
      if (fi === void 0)
        throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", fi);
      fn(fi, "signal"), Ve(bi, "listener");
      let mi;
      return fi.aborted ? queueMicrotask(() => bi()) : (fi.addEventListener("abort", bi, {
        __proto__: null,
        once: !0,
        [Ie]: !0
      }), mi = () => {
        fi.removeEventListener("abort", bi);
      }), {
        __proto__: null,
        [Be]() {
          var _i;
          (_i = mi) === null || _i === void 0 || _i();
        }
      };
    },
    AbortSignalAny: Pe.any || function(fi) {
      if (fi.length === 1)
        return fi[0];
      const bi = new Te(), mi = () => bi.abort();
      return fi.forEach((_i) => {
        fn(_i, "signals"), _i.addEventListener("abort", mi, {
          once: !0
        });
      }), bi.signal.addEventListener(
        "abort",
        () => {
          fi.forEach((_i) => _i.removeEventListener("abort", mi));
        },
        {
          once: !0
        }
      ), bi.signal;
    }
  }, Ae.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
})(util);
var utilExports = util.exports, operators = {};
const { format: format$2, inspect: inspect$1, AggregateError: CustomAggregateError } = utilExports, AggregateError$1 = globalThis.AggregateError || CustomAggregateError, kIsNodeError = Symbol("kIsNodeError"), kTypes = [
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
], classRegExp = /^([A-Z][a-z0-9]*)+$/, nodeInternalPrefix = "__node_internal_", codes$1 = {};
function assert$7(Ae, t) {
  if (!Ae)
    throw new codes$1.ERR_INTERNAL_ASSERTION(t);
}
function addNumericalSeparator(Ae) {
  let t = "", Ie = Ae.length;
  const Be = Ae[0] === "-" ? 1 : 0;
  for (; Ie >= Be + 4; Ie -= 3)
    t = `_${Ae.slice(Ie - 3, Ie)}${t}`;
  return `${Ae.slice(0, Ie)}${t}`;
}
function getMessage(Ae, t, Ie) {
  if (typeof t == "function")
    return assert$7(
      t.length <= Ie.length,
      // Default options do not count.
      `Code: ${Ae}; The provided arguments length (${Ie.length}) does not match the required ones (${t.length}).`
    ), t(...Ie);
  const Be = (t.match(/%[dfijoOs]/g) || []).length;
  return assert$7(
    Be === Ie.length,
    `Code: ${Ae}; The provided arguments length (${Ie.length}) does not match the required ones (${Be}).`
  ), Ie.length === 0 ? t : format$2(t, ...Ie);
}
function E$3(Ae, t, Ie) {
  Ie || (Ie = Error);
  class Be extends Ie {
    constructor(...Te) {
      super(getMessage(Ae, t, Te));
    }
    toString() {
      return `${this.name} [${Ae}]: ${this.message}`;
    }
  }
  Object.defineProperties(Be.prototype, {
    name: {
      value: Ie.name,
      writable: !0,
      enumerable: !1,
      configurable: !0
    },
    toString: {
      value() {
        return `${this.name} [${Ae}]: ${this.message}`;
      },
      writable: !0,
      enumerable: !1,
      configurable: !0
    }
  }), Be.prototype.code = Ae, Be.prototype[kIsNodeError] = !0, codes$1[Ae] = Be;
}
function hideStackFrames$1(Ae) {
  const t = nodeInternalPrefix + Ae.name;
  return Object.defineProperty(Ae, "name", {
    value: t
  }), Ae;
}
function aggregateTwoErrors$2(Ae, t) {
  if (Ae && t && Ae !== t) {
    if (Array.isArray(t.errors))
      return t.errors.push(Ae), t;
    const Ie = new AggregateError$1([t, Ae], t.message);
    return Ie.code = t.code, Ie;
  }
  return Ae || t;
}
let AbortError$5 = class extends Error {
  constructor(t = "The operation was aborted", Ie = void 0) {
    if (Ie !== void 0 && typeof Ie != "object")
      throw new codes$1.ERR_INVALID_ARG_TYPE("options", "Object", Ie);
    super(t, Ie), this.code = "ABORT_ERR", this.name = "AbortError";
  }
};
E$3("ERR_ASSERTION", "%s", Error);
E$3(
  "ERR_INVALID_ARG_TYPE",
  (Ae, t, Ie) => {
    assert$7(typeof Ae == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
    let Be = "The ";
    Ae.endsWith(" argument") ? Be += `${Ae} ` : Be += `"${Ae}" ${Ae.includes(".") ? "property" : "argument"} `, Be += "must be ";
    const Pe = [], Te = [], Me = [];
    for (const je of t)
      assert$7(typeof je == "string", "All expected entries have to be of type string"), kTypes.includes(je) ? Pe.push(je.toLowerCase()) : classRegExp.test(je) ? Te.push(je) : (assert$7(je !== "object", 'The value "object" should be written as "Object"'), Me.push(je));
    if (Te.length > 0) {
      const je = Pe.indexOf("object");
      je !== -1 && (Pe.splice(Pe, je, 1), Te.push("Object"));
    }
    if (Pe.length > 0) {
      switch (Pe.length) {
        case 1:
          Be += `of type ${Pe[0]}`;
          break;
        case 2:
          Be += `one of type ${Pe[0]} or ${Pe[1]}`;
          break;
        default: {
          const je = Pe.pop();
          Be += `one of type ${Pe.join(", ")}, or ${je}`;
        }
      }
      (Te.length > 0 || Me.length > 0) && (Be += " or ");
    }
    if (Te.length > 0) {
      switch (Te.length) {
        case 1:
          Be += `an instance of ${Te[0]}`;
          break;
        case 2:
          Be += `an instance of ${Te[0]} or ${Te[1]}`;
          break;
        default: {
          const je = Te.pop();
          Be += `an instance of ${Te.join(", ")}, or ${je}`;
        }
      }
      Me.length > 0 && (Be += " or ");
    }
    switch (Me.length) {
      case 0:
        break;
      case 1:
        Me[0].toLowerCase() !== Me[0] && (Be += "an "), Be += `${Me[0]}`;
        break;
      case 2:
        Be += `one of ${Me[0]} or ${Me[1]}`;
        break;
      default: {
        const je = Me.pop();
        Be += `one of ${Me.join(", ")}, or ${je}`;
      }
    }
    if (Ie == null)
      Be += `. Received ${Ie}`;
    else if (typeof Ie == "function" && Ie.name)
      Be += `. Received function ${Ie.name}`;
    else if (typeof Ie == "object") {
      var Ue;
      if ((Ue = Ie.constructor) !== null && Ue !== void 0 && Ue.name)
        Be += `. Received an instance of ${Ie.constructor.name}`;
      else {
        const je = inspect$1(Ie, {
          depth: -1
        });
        Be += `. Received ${je}`;
      }
    } else {
      let je = inspect$1(Ie, {
        colors: !1
      });
      je.length > 25 && (je = `${je.slice(0, 25)}...`), Be += `. Received type ${typeof Ie} (${je})`;
    }
    return Be;
  },
  TypeError
);
E$3(
  "ERR_INVALID_ARG_VALUE",
  (Ae, t, Ie = "is invalid") => {
    let Be = inspect$1(t);
    return Be.length > 128 && (Be = Be.slice(0, 128) + "..."), `The ${Ae.includes(".") ? "property" : "argument"} '${Ae}' ${Ie}. Received ${Be}`;
  },
  TypeError
);
E$3(
  "ERR_INVALID_RETURN_VALUE",
  (Ae, t, Ie) => {
    var Be;
    const Pe = Ie != null && (Be = Ie.constructor) !== null && Be !== void 0 && Be.name ? `instance of ${Ie.constructor.name}` : `type ${typeof Ie}`;
    return `Expected ${Ae} to be returned from the "${t}" function but got ${Pe}.`;
  },
  TypeError
);
E$3(
  "ERR_MISSING_ARGS",
  (...Ae) => {
    assert$7(Ae.length > 0, "At least one arg needs to be specified");
    let t;
    const Ie = Ae.length;
    switch (Ae = (Array.isArray(Ae) ? Ae : [Ae]).map((Be) => `"${Be}"`).join(" or "), Ie) {
      case 1:
        t += `The ${Ae[0]} argument`;
        break;
      case 2:
        t += `The ${Ae[0]} and ${Ae[1]} arguments`;
        break;
      default:
        {
          const Be = Ae.pop();
          t += `The ${Ae.join(", ")}, and ${Be} arguments`;
        }
        break;
    }
    return `${t} must be specified`;
  },
  TypeError
);
E$3(
  "ERR_OUT_OF_RANGE",
  (Ae, t, Ie) => {
    assert$7(t, 'Missing "range" argument');
    let Be;
    return Number.isInteger(Ie) && Math.abs(Ie) > 2 ** 32 ? Be = addNumericalSeparator(String(Ie)) : typeof Ie == "bigint" ? (Be = String(Ie), (Ie > 2n ** 32n || Ie < -(2n ** 32n)) && (Be = addNumericalSeparator(Be)), Be += "n") : Be = inspect$1(Ie), `The value of "${Ae}" is out of range. It must be ${t}. Received ${Be}`;
  },
  RangeError
);
E$3("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
E$3("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
E$3("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
E$3("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
E$3("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
E$3("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
E$3("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
E$3("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
E$3("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
E$3("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
E$3("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
var errors = {
  AbortError: AbortError$5,
  aggregateTwoErrors: hideStackFrames$1(aggregateTwoErrors$2),
  hideStackFrames: hideStackFrames$1,
  codes: codes$1
};
const {
  ArrayIsArray: ArrayIsArray$2,
  ArrayPrototypeIncludes,
  ArrayPrototypeJoin,
  ArrayPrototypeMap,
  NumberIsInteger: NumberIsInteger$1,
  NumberIsNaN: NumberIsNaN$1,
  NumberMAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER,
  NumberParseInt,
  ObjectPrototypeHasOwnProperty,
  RegExpPrototypeExec,
  String: String$1,
  StringPrototypeToUpperCase,
  StringPrototypeTrim
} = primordials, {
  hideStackFrames,
  codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE$5, ERR_INVALID_ARG_VALUE: ERR_INVALID_ARG_VALUE$3, ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE$1, ERR_UNKNOWN_SIGNAL }
} = errors, { normalizeEncoding } = utilExports, { isAsyncFunction, isArrayBufferView } = utilExports.types, signals = {};
function isInt32(Ae) {
  return Ae === (Ae | 0);
}
function isUint32(Ae) {
  return Ae === Ae >>> 0;
}
const octalReg = /^[0-7]+$/, modeDesc = "must be a 32-bit unsigned integer or an octal string";
function parseFileMode(Ae, t, Ie) {
  if (typeof Ae > "u" && (Ae = Ie), typeof Ae == "string") {
    if (RegExpPrototypeExec(octalReg, Ae) === null)
      throw new ERR_INVALID_ARG_VALUE$3(t, Ae, modeDesc);
    Ae = NumberParseInt(Ae, 8);
  }
  return validateUint32(Ae, t), Ae;
}
const validateInteger$2 = hideStackFrames((Ae, t, Ie = NumberMIN_SAFE_INTEGER, Be = NumberMAX_SAFE_INTEGER) => {
  if (typeof Ae != "number") throw new ERR_INVALID_ARG_TYPE$5(t, "number", Ae);
  if (!NumberIsInteger$1(Ae)) throw new ERR_OUT_OF_RANGE$1(t, "an integer", Ae);
  if (Ae < Ie || Ae > Be) throw new ERR_OUT_OF_RANGE$1(t, `>= ${Ie} && <= ${Be}`, Ae);
}), validateInt32 = hideStackFrames((Ae, t, Ie = -2147483648, Be = 2147483647) => {
  if (typeof Ae != "number")
    throw new ERR_INVALID_ARG_TYPE$5(t, "number", Ae);
  if (!NumberIsInteger$1(Ae))
    throw new ERR_OUT_OF_RANGE$1(t, "an integer", Ae);
  if (Ae < Ie || Ae > Be)
    throw new ERR_OUT_OF_RANGE$1(t, `>= ${Ie} && <= ${Be}`, Ae);
}), validateUint32 = hideStackFrames((Ae, t, Ie = !1) => {
  if (typeof Ae != "number")
    throw new ERR_INVALID_ARG_TYPE$5(t, "number", Ae);
  if (!NumberIsInteger$1(Ae))
    throw new ERR_OUT_OF_RANGE$1(t, "an integer", Ae);
  const Be = Ie ? 1 : 0, Pe = 4294967295;
  if (Ae < Be || Ae > Pe)
    throw new ERR_OUT_OF_RANGE$1(t, `>= ${Be} && <= ${Pe}`, Ae);
});
function validateString(Ae, t) {
  if (typeof Ae != "string") throw new ERR_INVALID_ARG_TYPE$5(t, "string", Ae);
}
function validateNumber(Ae, t, Ie = void 0, Be) {
  if (typeof Ae != "number") throw new ERR_INVALID_ARG_TYPE$5(t, "number", Ae);
  if (Ie != null && Ae < Ie || Be != null && Ae > Be || (Ie != null || Be != null) && NumberIsNaN$1(Ae))
    throw new ERR_OUT_OF_RANGE$1(
      t,
      `${Ie != null ? `>= ${Ie}` : ""}${Ie != null && Be != null ? " && " : ""}${Be != null ? `<= ${Be}` : ""}`,
      Ae
    );
}
const validateOneOf = hideStackFrames((Ae, t, Ie) => {
  if (!ArrayPrototypeIncludes(Ie, Ae)) {
    const Pe = "must be one of: " + ArrayPrototypeJoin(
      ArrayPrototypeMap(Ie, (Te) => typeof Te == "string" ? `'${Te}'` : String$1(Te)),
      ", "
    );
    throw new ERR_INVALID_ARG_VALUE$3(t, Ae, Pe);
  }
});
function validateBoolean$1(Ae, t) {
  if (typeof Ae != "boolean") throw new ERR_INVALID_ARG_TYPE$5(t, "boolean", Ae);
}
function getOwnPropertyValueOrDefault(Ae, t, Ie) {
  return Ae == null || !ObjectPrototypeHasOwnProperty(Ae, t) ? Ie : Ae[t];
}
const validateObject$4 = hideStackFrames((Ae, t, Ie = null) => {
  const Be = getOwnPropertyValueOrDefault(Ie, "allowArray", !1), Pe = getOwnPropertyValueOrDefault(Ie, "allowFunction", !1);
  if (!getOwnPropertyValueOrDefault(Ie, "nullable", !1) && Ae === null || !Be && ArrayIsArray$2(Ae) || typeof Ae != "object" && (!Pe || typeof Ae != "function"))
    throw new ERR_INVALID_ARG_TYPE$5(t, "Object", Ae);
}), validateDictionary = hideStackFrames((Ae, t) => {
  if (Ae != null && typeof Ae != "object" && typeof Ae != "function")
    throw new ERR_INVALID_ARG_TYPE$5(t, "a dictionary", Ae);
}), validateArray = hideStackFrames((Ae, t, Ie = 0) => {
  if (!ArrayIsArray$2(Ae))
    throw new ERR_INVALID_ARG_TYPE$5(t, "Array", Ae);
  if (Ae.length < Ie) {
    const Be = `must be longer than ${Ie}`;
    throw new ERR_INVALID_ARG_VALUE$3(t, Ae, Be);
  }
});
function validateStringArray(Ae, t) {
  validateArray(Ae, t);
  for (let Ie = 0; Ie < Ae.length; Ie++)
    validateString(Ae[Ie], `${t}[${Ie}]`);
}
function validateBooleanArray(Ae, t) {
  validateArray(Ae, t);
  for (let Ie = 0; Ie < Ae.length; Ie++)
    validateBoolean$1(Ae[Ie], `${t}[${Ie}]`);
}
function validateAbortSignalArray(Ae, t) {
  validateArray(Ae, t);
  for (let Ie = 0; Ie < Ae.length; Ie++) {
    const Be = Ae[Ie], Pe = `${t}[${Ie}]`;
    if (Be == null)
      throw new ERR_INVALID_ARG_TYPE$5(Pe, "AbortSignal", Be);
    validateAbortSignal$3(Be, Pe);
  }
}
function validateSignalName(Ae, t = "signal") {
  if (validateString(Ae, t), signals[Ae] === void 0)
    throw signals[StringPrototypeToUpperCase(Ae)] !== void 0 ? new ERR_UNKNOWN_SIGNAL(Ae + " (signals must use all capital letters)") : new ERR_UNKNOWN_SIGNAL(Ae);
}
const validateBuffer = hideStackFrames((Ae, t = "buffer") => {
  if (!isArrayBufferView(Ae))
    throw new ERR_INVALID_ARG_TYPE$5(t, ["Buffer", "TypedArray", "DataView"], Ae);
});
function validateEncoding(Ae, t) {
  const Ie = normalizeEncoding(t), Be = Ae.length;
  if (Ie === "hex" && Be % 2 !== 0)
    throw new ERR_INVALID_ARG_VALUE$3("encoding", t, `is invalid for data of length ${Be}`);
}
function validatePort(Ae, t = "Port", Ie = !0) {
  if (typeof Ae != "number" && typeof Ae != "string" || typeof Ae == "string" && StringPrototypeTrim(Ae).length === 0 || +Ae !== +Ae >>> 0 || Ae > 65535 || Ae === 0 && !Ie)
    throw new ERR_SOCKET_BAD_PORT(t, Ae, Ie);
  return Ae | 0;
}
const validateAbortSignal$3 = hideStackFrames((Ae, t) => {
  if (Ae !== void 0 && (Ae === null || typeof Ae != "object" || !("aborted" in Ae)))
    throw new ERR_INVALID_ARG_TYPE$5(t, "AbortSignal", Ae);
}), validateFunction$2 = hideStackFrames((Ae, t) => {
  if (typeof Ae != "function") throw new ERR_INVALID_ARG_TYPE$5(t, "Function", Ae);
}), validatePlainFunction = hideStackFrames((Ae, t) => {
  if (typeof Ae != "function" || isAsyncFunction(Ae)) throw new ERR_INVALID_ARG_TYPE$5(t, "Function", Ae);
}), validateUndefined = hideStackFrames((Ae, t) => {
  if (Ae !== void 0) throw new ERR_INVALID_ARG_TYPE$5(t, "undefined", Ae);
});
function validateUnion(Ae, t, Ie) {
  if (!ArrayPrototypeIncludes(Ie, Ae))
    throw new ERR_INVALID_ARG_TYPE$5(t, `('${ArrayPrototypeJoin(Ie, "|")}')`, Ae);
}
const linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
function validateLinkHeaderFormat(Ae, t) {
  if (typeof Ae > "u" || !RegExpPrototypeExec(linkValueRegExp, Ae))
    throw new ERR_INVALID_ARG_VALUE$3(
      t,
      Ae,
      'must be an array or string of format "</styles.css>; rel=preload; as=style"'
    );
}
function validateLinkHeaderValue(Ae) {
  if (typeof Ae == "string")
    return validateLinkHeaderFormat(Ae, "hints"), Ae;
  if (ArrayIsArray$2(Ae)) {
    const t = Ae.length;
    let Ie = "";
    if (t === 0)
      return Ie;
    for (let Be = 0; Be < t; Be++) {
      const Pe = Ae[Be];
      validateLinkHeaderFormat(Pe, "hints"), Ie += Pe, Be !== t - 1 && (Ie += ", ");
    }
    return Ie;
  }
  throw new ERR_INVALID_ARG_VALUE$3(
    "hints",
    Ae,
    'must be an array or string of format "</styles.css>; rel=preload; as=style"'
  );
}
var validators = {
  isInt32,
  isUint32,
  parseFileMode,
  validateArray,
  validateStringArray,
  validateBooleanArray,
  validateAbortSignalArray,
  validateBoolean: validateBoolean$1,
  validateBuffer,
  validateDictionary,
  validateEncoding,
  validateFunction: validateFunction$2,
  validateInt32,
  validateInteger: validateInteger$2,
  validateNumber,
  validateObject: validateObject$4,
  validateOneOf,
  validatePlainFunction,
  validatePort,
  validateSignalName,
  validateString,
  validateUint32,
  validateUndefined,
  validateUnion,
  validateAbortSignal: validateAbortSignal$3,
  validateLinkHeaderValue
}, endOfStream = { exports: {} }, dist = {};
(function(Ae) {
  Object.defineProperties(Ae, { __esModule: { value: !0 }, [Symbol.toStringTag]: { value: "Module" } });
  function t(Oi) {
    return Oi && Oi.__esModule && Object.prototype.hasOwnProperty.call(Oi, "default") ? Oi.default : Oi;
  }
  var Ie = { exports: {} }, Be = Ie.exports = {}, Pe, Te;
  function Me() {
    throw new Error("setTimeout has not been defined");
  }
  function Ue() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      typeof setTimeout == "function" ? Pe = setTimeout : Pe = Me;
    } catch {
      Pe = Me;
    }
    try {
      typeof clearTimeout == "function" ? Te = clearTimeout : Te = Ue;
    } catch {
      Te = Ue;
    }
  })();
  function je(Oi) {
    if (Pe === setTimeout)
      return setTimeout(Oi, 0);
    if ((Pe === Me || !Pe) && setTimeout)
      return Pe = setTimeout, setTimeout(Oi, 0);
    try {
      return Pe(Oi, 0);
    } catch {
      try {
        return Pe.call(null, Oi, 0);
      } catch {
        return Pe.call(this, Oi, 0);
      }
    }
  }
  function fn(Oi) {
    if (Te === clearTimeout)
      return clearTimeout(Oi);
    if ((Te === Ue || !Te) && clearTimeout)
      return Te = clearTimeout, clearTimeout(Oi);
    try {
      return Te(Oi);
    } catch {
      try {
        return Te.call(null, Oi);
      } catch {
        return Te.call(this, Oi);
      }
    }
  }
  var Ve = [], vn = !1, En, fi = -1;
  function bi() {
    !vn || !En || (vn = !1, En.length ? Ve = En.concat(Ve) : fi = -1, Ve.length && mi());
  }
  function mi() {
    if (!vn) {
      var Oi = je(bi);
      vn = !0;
      for (var Fi = Ve.length; Fi; ) {
        for (En = Ve, Ve = []; ++fi < Fi; )
          En && En[fi].run();
        fi = -1, Fi = Ve.length;
      }
      En = null, vn = !1, fn(Oi);
    }
  }
  Be.nextTick = function(Oi) {
    var Fi = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var Ui = 1; Ui < arguments.length; Ui++)
        Fi[Ui - 1] = arguments[Ui];
    Ve.push(new _i(Oi, Fi)), Ve.length === 1 && !vn && je(mi);
  };
  function _i(Oi, Fi) {
    this.fun = Oi, this.array = Fi;
  }
  _i.prototype.run = function() {
    this.fun.apply(null, this.array);
  }, Be.title = "browser", Be.browser = !0, Be.env = {}, Be.argv = [], Be.version = "", Be.versions = {};
  function Ei() {
  }
  Be.on = Ei, Be.addListener = Ei, Be.once = Ei, Be.off = Ei, Be.removeListener = Ei, Be.removeAllListeners = Ei, Be.emit = Ei, Be.prependListener = Ei, Be.prependOnceListener = Ei, Be.listeners = function(Oi) {
    return [];
  }, Be.binding = function(Oi) {
    throw new Error("process.binding is not supported");
  }, Be.cwd = function() {
    return "/";
  }, Be.chdir = function(Oi) {
    throw new Error("process.chdir is not supported");
  }, Be.umask = function() {
    return 0;
  };
  var Si = Ie.exports;
  const Mi = /* @__PURE__ */ t(Si);
  Ae.default = Mi, Ae.process = Mi;
})(dist);
const { SymbolAsyncIterator: SymbolAsyncIterator$2, SymbolIterator: SymbolIterator$2, SymbolFor } = primordials, kIsDestroyed$1 = SymbolFor("nodejs.stream.destroyed"), kIsErrored = SymbolFor("nodejs.stream.errored"), kIsReadable = SymbolFor("nodejs.stream.readable"), kIsWritable = SymbolFor("nodejs.stream.writable"), kIsDisturbed = SymbolFor("nodejs.stream.disturbed"), kIsClosedPromise$1 = SymbolFor("nodejs.webstream.isClosedPromise"), kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
function isReadableNodeStream$2(Ae, t = !1) {
  var Ie;
  return !!(Ae && typeof Ae.pipe == "function" && typeof Ae.on == "function" && (!t || typeof Ae.pause == "function" && typeof Ae.resume == "function") && (!Ae._writableState || ((Ie = Ae._readableState) === null || Ie === void 0 ? void 0 : Ie.readable) !== !1) && // Duplex
  (!Ae._writableState || Ae._readableState));
}
function isWritableNodeStream$1(Ae) {
  var t;
  return !!(Ae && typeof Ae.write == "function" && typeof Ae.on == "function" && (!Ae._readableState || ((t = Ae._writableState) === null || t === void 0 ? void 0 : t.writable) !== !1));
}
function isDuplexNodeStream(Ae) {
  return !!(Ae && typeof Ae.pipe == "function" && Ae._readableState && typeof Ae.on == "function" && typeof Ae.write == "function");
}
function isNodeStream$4(Ae) {
  return Ae && (Ae._readableState || Ae._writableState || typeof Ae.write == "function" && typeof Ae.on == "function" || typeof Ae.pipe == "function" && typeof Ae.on == "function");
}
function isReadableStream$3(Ae) {
  return !!(Ae && !isNodeStream$4(Ae) && typeof Ae.pipeThrough == "function" && typeof Ae.getReader == "function" && typeof Ae.cancel == "function");
}
function isWritableStream$2(Ae) {
  return !!(Ae && !isNodeStream$4(Ae) && typeof Ae.getWriter == "function" && typeof Ae.abort == "function");
}
function isTransformStream$2(Ae) {
  return !!(Ae && !isNodeStream$4(Ae) && typeof Ae.readable == "object" && typeof Ae.writable == "object");
}
function isWebStream$2(Ae) {
  return isReadableStream$3(Ae) || isWritableStream$2(Ae) || isTransformStream$2(Ae);
}
function isIterable$1(Ae, t) {
  return Ae == null ? !1 : t === !0 ? typeof Ae[SymbolAsyncIterator$2] == "function" : t === !1 ? typeof Ae[SymbolIterator$2] == "function" : typeof Ae[SymbolAsyncIterator$2] == "function" || typeof Ae[SymbolIterator$2] == "function";
}
function isDestroyed$1(Ae) {
  if (!isNodeStream$4(Ae)) return null;
  const t = Ae._writableState, Ie = Ae._readableState, Be = t || Ie;
  return !!(Ae.destroyed || Ae[kIsDestroyed$1] || Be != null && Be.destroyed);
}
function isWritableEnded(Ae) {
  if (!isWritableNodeStream$1(Ae)) return null;
  if (Ae.writableEnded === !0) return !0;
  const t = Ae._writableState;
  return t != null && t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function isWritableFinished$1(Ae, t) {
  if (!isWritableNodeStream$1(Ae)) return null;
  if (Ae.writableFinished === !0) return !0;
  const Ie = Ae._writableState;
  return Ie != null && Ie.errored ? !1 : typeof (Ie == null ? void 0 : Ie.finished) != "boolean" ? null : !!(Ie.finished || t === !1 && Ie.ended === !0 && Ie.length === 0);
}
function isReadableEnded(Ae) {
  if (!isReadableNodeStream$2(Ae)) return null;
  if (Ae.readableEnded === !0) return !0;
  const t = Ae._readableState;
  return !t || t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function isReadableFinished$2(Ae, t) {
  if (!isReadableNodeStream$2(Ae)) return null;
  const Ie = Ae._readableState;
  return Ie != null && Ie.errored ? !1 : typeof (Ie == null ? void 0 : Ie.endEmitted) != "boolean" ? null : !!(Ie.endEmitted || t === !1 && Ie.ended === !0 && Ie.length === 0);
}
function isReadable$3(Ae) {
  return Ae && Ae[kIsReadable] != null ? Ae[kIsReadable] : typeof (Ae == null ? void 0 : Ae.readable) != "boolean" ? null : isDestroyed$1(Ae) ? !1 : isReadableNodeStream$2(Ae) && Ae.readable && !isReadableFinished$2(Ae);
}
function isWritable$3(Ae) {
  return Ae && Ae[kIsWritable] != null ? Ae[kIsWritable] : typeof (Ae == null ? void 0 : Ae.writable) != "boolean" ? null : isDestroyed$1(Ae) ? !1 : isWritableNodeStream$1(Ae) && Ae.writable && !isWritableEnded(Ae);
}
function isFinished$1(Ae, t) {
  return isNodeStream$4(Ae) ? isDestroyed$1(Ae) ? !0 : !((t == null ? void 0 : t.readable) !== !1 && isReadable$3(Ae) || (t == null ? void 0 : t.writable) !== !1 && isWritable$3(Ae)) : null;
}
function isWritableErrored$1(Ae) {
  var t, Ie;
  return isNodeStream$4(Ae) ? Ae.writableErrored ? Ae.writableErrored : (t = (Ie = Ae._writableState) === null || Ie === void 0 ? void 0 : Ie.errored) !== null && t !== void 0 ? t : null : null;
}
function isReadableErrored$1(Ae) {
  var t, Ie;
  return isNodeStream$4(Ae) ? Ae.readableErrored ? Ae.readableErrored : (t = (Ie = Ae._readableState) === null || Ie === void 0 ? void 0 : Ie.errored) !== null && t !== void 0 ? t : null : null;
}
function isClosed$1(Ae) {
  if (!isNodeStream$4(Ae))
    return null;
  if (typeof Ae.closed == "boolean")
    return Ae.closed;
  const t = Ae._writableState, Ie = Ae._readableState;
  return typeof (t == null ? void 0 : t.closed) == "boolean" || typeof (Ie == null ? void 0 : Ie.closed) == "boolean" ? (t == null ? void 0 : t.closed) || (Ie == null ? void 0 : Ie.closed) : typeof Ae._closed == "boolean" && isOutgoingMessage(Ae) ? Ae._closed : null;
}
function isOutgoingMessage(Ae) {
  return typeof Ae._closed == "boolean" && typeof Ae._defaultKeepAlive == "boolean" && typeof Ae._removedConnection == "boolean" && typeof Ae._removedContLen == "boolean";
}
function isServerResponse(Ae) {
  return typeof Ae._sent100 == "boolean" && isOutgoingMessage(Ae);
}
function isServerRequest$1(Ae) {
  var t;
  return typeof Ae._consuming == "boolean" && typeof Ae._dumped == "boolean" && ((t = Ae.req) === null || t === void 0 ? void 0 : t.upgradeOrConnect) === void 0;
}
function willEmitClose(Ae) {
  if (!isNodeStream$4(Ae)) return null;
  const t = Ae._writableState, Ie = Ae._readableState, Be = t || Ie;
  return !Be && isServerResponse(Ae) || !!(Be && Be.autoDestroy && Be.emitClose && Be.closed === !1);
}
function isDisturbed(Ae) {
  var t;
  return !!(Ae && ((t = Ae[kIsDisturbed]) !== null && t !== void 0 ? t : Ae.readableDidRead || Ae.readableAborted));
}
function isErrored(Ae) {
  var t, Ie, Be, Pe, Te, Me, Ue, je, fn, Ve;
  return !!(Ae && ((t = (Ie = (Be = (Pe = (Te = (Me = Ae[kIsErrored]) !== null && Me !== void 0 ? Me : Ae.readableErrored) !== null && Te !== void 0 ? Te : Ae.writableErrored) !== null && Pe !== void 0 ? Pe : (Ue = Ae._readableState) === null || Ue === void 0 ? void 0 : Ue.errorEmitted) !== null && Be !== void 0 ? Be : (je = Ae._writableState) === null || je === void 0 ? void 0 : je.errorEmitted) !== null && Ie !== void 0 ? Ie : (fn = Ae._readableState) === null || fn === void 0 ? void 0 : fn.errored) !== null && t !== void 0 ? t : !((Ve = Ae._writableState) === null || Ve === void 0) && Ve.errored));
}
var utils$1 = {
  isDestroyed: isDestroyed$1,
  kIsDestroyed: kIsDestroyed$1,
  isDisturbed,
  kIsDisturbed,
  isErrored,
  kIsErrored,
  isReadable: isReadable$3,
  kIsReadable,
  kIsClosedPromise: kIsClosedPromise$1,
  kControllerErrorFunction,
  kIsWritable,
  isClosed: isClosed$1,
  isDuplexNodeStream,
  isFinished: isFinished$1,
  isIterable: isIterable$1,
  isReadableNodeStream: isReadableNodeStream$2,
  isReadableStream: isReadableStream$3,
  isReadableEnded,
  isReadableFinished: isReadableFinished$2,
  isReadableErrored: isReadableErrored$1,
  isNodeStream: isNodeStream$4,
  isWebStream: isWebStream$2,
  isWritable: isWritable$3,
  isWritableNodeStream: isWritableNodeStream$1,
  isWritableStream: isWritableStream$2,
  isWritableEnded,
  isWritableFinished: isWritableFinished$1,
  isWritableErrored: isWritableErrored$1,
  isServerRequest: isServerRequest$1,
  isServerResponse,
  willEmitClose,
  isTransformStream: isTransformStream$2
};
const process$3 = dist, { AbortError: AbortError$4, codes } = errors, { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE$4, ERR_STREAM_PREMATURE_CLOSE: ERR_STREAM_PREMATURE_CLOSE$1 } = codes, { kEmptyObject, once: once$1 } = utilExports, { validateAbortSignal: validateAbortSignal$2, validateFunction: validateFunction$1, validateObject: validateObject$3, validateBoolean } = validators, { Promise: Promise$3, PromisePrototypeThen: PromisePrototypeThen$2, SymbolDispose: SymbolDispose$1 } = primordials, {
  isClosed,
  isReadable: isReadable$2,
  isReadableNodeStream: isReadableNodeStream$1,
  isReadableStream: isReadableStream$2,
  isReadableFinished: isReadableFinished$1,
  isReadableErrored,
  isWritable: isWritable$2,
  isWritableNodeStream,
  isWritableStream: isWritableStream$1,
  isWritableFinished,
  isWritableErrored,
  isNodeStream: isNodeStream$3,
  willEmitClose: _willEmitClose,
  kIsClosedPromise
} = utils$1;
let addAbortListener$1;
function isRequest$1(Ae) {
  return Ae.setHeader && typeof Ae.abort == "function";
}
const nop = () => {
};
function eos$2(Ae, t, Ie) {
  var Be, Pe;
  if (arguments.length === 2 ? (Ie = t, t = kEmptyObject) : t == null ? t = kEmptyObject : validateObject$3(t, "options"), validateFunction$1(Ie, "callback"), validateAbortSignal$2(t.signal, "options.signal"), Ie = once$1(Ie), isReadableStream$2(Ae) || isWritableStream$1(Ae))
    return eosWeb(Ae, t, Ie);
  if (!isNodeStream$3(Ae))
    throw new ERR_INVALID_ARG_TYPE$4("stream", ["ReadableStream", "WritableStream", "Stream"], Ae);
  const Te = (Be = t.readable) !== null && Be !== void 0 ? Be : isReadableNodeStream$1(Ae), Me = (Pe = t.writable) !== null && Pe !== void 0 ? Pe : isWritableNodeStream(Ae), Ue = Ae._writableState, je = Ae._readableState, fn = () => {
    Ae.writable || En();
  };
  let Ve = _willEmitClose(Ae) && isReadableNodeStream$1(Ae) === Te && isWritableNodeStream(Ae) === Me, vn = isWritableFinished(Ae, !1);
  const En = () => {
    vn = !0, Ae.destroyed && (Ve = !1), !(Ve && (!Ae.readable || Te)) && (!Te || fi) && Ie.call(Ae);
  };
  let fi = isReadableFinished$1(Ae, !1);
  const bi = () => {
    fi = !0, Ae.destroyed && (Ve = !1), !(Ve && (!Ae.writable || Me)) && (!Me || vn) && Ie.call(Ae);
  }, mi = (Fi) => {
    Ie.call(Ae, Fi);
  };
  let _i = isClosed(Ae);
  const Ei = () => {
    _i = !0;
    const Fi = isWritableErrored(Ae) || isReadableErrored(Ae);
    if (Fi && typeof Fi != "boolean")
      return Ie.call(Ae, Fi);
    if (Te && !fi && isReadableNodeStream$1(Ae, !0) && !isReadableFinished$1(Ae, !1))
      return Ie.call(Ae, new ERR_STREAM_PREMATURE_CLOSE$1());
    if (Me && !vn && !isWritableFinished(Ae, !1))
      return Ie.call(Ae, new ERR_STREAM_PREMATURE_CLOSE$1());
    Ie.call(Ae);
  }, Si = () => {
    _i = !0;
    const Fi = isWritableErrored(Ae) || isReadableErrored(Ae);
    if (Fi && typeof Fi != "boolean")
      return Ie.call(Ae, Fi);
    Ie.call(Ae);
  }, Mi = () => {
    Ae.req.on("finish", En);
  };
  isRequest$1(Ae) ? (Ae.on("complete", En), Ve || Ae.on("abort", Ei), Ae.req ? Mi() : Ae.on("request", Mi)) : Me && !Ue && (Ae.on("end", fn), Ae.on("close", fn)), !Ve && typeof Ae.aborted == "boolean" && Ae.on("aborted", Ei), Ae.on("end", bi), Ae.on("finish", En), t.error !== !1 && Ae.on("error", mi), Ae.on("close", Ei), _i ? process$3.nextTick(Ei) : Ue != null && Ue.errorEmitted || je != null && je.errorEmitted ? Ve || process$3.nextTick(Si) : (!Te && (!Ve || isReadable$2(Ae)) && (vn || isWritable$2(Ae) === !1) || !Me && (!Ve || isWritable$2(Ae)) && (fi || isReadable$2(Ae) === !1) || je && Ae.req && Ae.aborted) && process$3.nextTick(Si);
  const Oi = () => {
    Ie = nop, Ae.removeListener("aborted", Ei), Ae.removeListener("complete", En), Ae.removeListener("abort", Ei), Ae.removeListener("request", Mi), Ae.req && Ae.req.removeListener("finish", En), Ae.removeListener("end", fn), Ae.removeListener("close", fn), Ae.removeListener("finish", En), Ae.removeListener("end", bi), Ae.removeListener("error", mi), Ae.removeListener("close", Ei);
  };
  if (t.signal && !_i) {
    const Fi = () => {
      const Ui = Ie;
      Oi(), Ui.call(
        Ae,
        new AbortError$4(void 0, {
          cause: t.signal.reason
        })
      );
    };
    if (t.signal.aborted)
      process$3.nextTick(Fi);
    else {
      addAbortListener$1 = addAbortListener$1 || utilExports.addAbortListener;
      const Ui = addAbortListener$1(t.signal, Fi), Pi = Ie;
      Ie = once$1((...Bi) => {
        Ui[SymbolDispose$1](), Pi.apply(Ae, Bi);
      });
    }
  }
  return Oi;
}
function eosWeb(Ae, t, Ie) {
  let Be = !1, Pe = nop;
  if (t.signal)
    if (Pe = () => {
      Be = !0, Ie.call(
        Ae,
        new AbortError$4(void 0, {
          cause: t.signal.reason
        })
      );
    }, t.signal.aborted)
      process$3.nextTick(Pe);
    else {
      addAbortListener$1 = addAbortListener$1 || utilExports.addAbortListener;
      const Me = addAbortListener$1(t.signal, Pe), Ue = Ie;
      Ie = once$1((...je) => {
        Me[SymbolDispose$1](), Ue.apply(Ae, je);
      });
    }
  const Te = (...Me) => {
    Be || process$3.nextTick(() => Ie.apply(Ae, Me));
  };
  return PromisePrototypeThen$2(Ae[kIsClosedPromise].promise, Te, Te), nop;
}
function finished$1(Ae, t) {
  var Ie;
  let Be = !1;
  return t === null && (t = kEmptyObject), (Ie = t) !== null && Ie !== void 0 && Ie.cleanup && (validateBoolean(t.cleanup, "cleanup"), Be = t.cleanup), new Promise$3((Pe, Te) => {
    const Me = eos$2(Ae, t, (Ue) => {
      Be && Me(), Ue ? Te(Ue) : Pe();
    });
  });
}
endOfStream.exports = eos$2;
endOfStream.exports.finished = finished$1;
var endOfStreamExports = endOfStream.exports;
const process$2 = dist, {
  aggregateTwoErrors: aggregateTwoErrors$1,
  codes: { ERR_MULTIPLE_CALLBACK },
  AbortError: AbortError$3
} = errors, { Symbol: Symbol$3 } = primordials, { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = utils$1, kDestroy = Symbol$3("kDestroy"), kConstruct = Symbol$3("kConstruct");
function checkError(Ae, t, Ie) {
  Ae && (Ae.stack, t && !t.errored && (t.errored = Ae), Ie && !Ie.errored && (Ie.errored = Ae));
}
function destroy(Ae, t) {
  const Ie = this._readableState, Be = this._writableState, Pe = Be || Ie;
  return Be != null && Be.destroyed || Ie != null && Ie.destroyed ? (typeof t == "function" && t(), this) : (checkError(Ae, Be, Ie), Be && (Be.destroyed = !0), Ie && (Ie.destroyed = !0), Pe.constructed ? _destroy(this, Ae, t) : this.once(kDestroy, function(Te) {
    _destroy(this, aggregateTwoErrors$1(Te, Ae), t);
  }), this);
}
function _destroy(Ae, t, Ie) {
  let Be = !1;
  function Pe(Te) {
    if (Be)
      return;
    Be = !0;
    const Me = Ae._readableState, Ue = Ae._writableState;
    checkError(Te, Ue, Me), Ue && (Ue.closed = !0), Me && (Me.closed = !0), typeof Ie == "function" && Ie(Te), Te ? process$2.nextTick(emitErrorCloseNT, Ae, Te) : process$2.nextTick(emitCloseNT, Ae);
  }
  try {
    Ae._destroy(t || null, Pe);
  } catch (Te) {
    Pe(Te);
  }
}
function emitErrorCloseNT(Ae, t) {
  emitErrorNT(Ae, t), emitCloseNT(Ae);
}
function emitCloseNT(Ae) {
  const t = Ae._readableState, Ie = Ae._writableState;
  Ie && (Ie.closeEmitted = !0), t && (t.closeEmitted = !0), (Ie != null && Ie.emitClose || t != null && t.emitClose) && Ae.emit("close");
}
function emitErrorNT(Ae, t) {
  const Ie = Ae._readableState, Be = Ae._writableState;
  Be != null && Be.errorEmitted || Ie != null && Ie.errorEmitted || (Be && (Be.errorEmitted = !0), Ie && (Ie.errorEmitted = !0), Ae.emit("error", t));
}
function undestroy() {
  const Ae = this._readableState, t = this._writableState;
  Ae && (Ae.constructed = !0, Ae.closed = !1, Ae.closeEmitted = !1, Ae.destroyed = !1, Ae.errored = null, Ae.errorEmitted = !1, Ae.reading = !1, Ae.ended = Ae.readable === !1, Ae.endEmitted = Ae.readable === !1), t && (t.constructed = !0, t.destroyed = !1, t.closed = !1, t.closeEmitted = !1, t.errored = null, t.errorEmitted = !1, t.finalCalled = !1, t.prefinished = !1, t.ended = t.writable === !1, t.ending = t.writable === !1, t.finished = t.writable === !1);
}
function errorOrDestroy(Ae, t, Ie) {
  const Be = Ae._readableState, Pe = Ae._writableState;
  if (Pe != null && Pe.destroyed || Be != null && Be.destroyed)
    return this;
  Be != null && Be.autoDestroy || Pe != null && Pe.autoDestroy ? Ae.destroy(t) : t && (t.stack, Pe && !Pe.errored && (Pe.errored = t), Be && !Be.errored && (Be.errored = t), Ie ? process$2.nextTick(emitErrorNT, Ae, t) : emitErrorNT(Ae, t));
}
function construct(Ae, t) {
  if (typeof Ae._construct != "function")
    return;
  const Ie = Ae._readableState, Be = Ae._writableState;
  Ie && (Ie.constructed = !1), Be && (Be.constructed = !1), Ae.once(kConstruct, t), !(Ae.listenerCount(kConstruct) > 1) && process$2.nextTick(constructNT, Ae);
}
function constructNT(Ae) {
  let t = !1;
  function Ie(Be) {
    if (t) {
      errorOrDestroy(Ae, Be ?? new ERR_MULTIPLE_CALLBACK());
      return;
    }
    t = !0;
    const Pe = Ae._readableState, Te = Ae._writableState, Me = Te || Pe;
    Pe && (Pe.constructed = !0), Te && (Te.constructed = !0), Me.destroyed ? Ae.emit(kDestroy, Be) : Be ? errorOrDestroy(Ae, Be, !0) : process$2.nextTick(emitConstructNT, Ae);
  }
  try {
    Ae._construct((Be) => {
      process$2.nextTick(Ie, Be);
    });
  } catch (Be) {
    process$2.nextTick(Ie, Be);
  }
}
function emitConstructNT(Ae) {
  Ae.emit(kConstruct);
}
function isRequest(Ae) {
  return (Ae == null ? void 0 : Ae.setHeader) && typeof Ae.abort == "function";
}
function emitCloseLegacy(Ae) {
  Ae.emit("close");
}
function emitErrorCloseLegacy(Ae, t) {
  Ae.emit("error", t), process$2.nextTick(emitCloseLegacy, Ae);
}
function destroyer$2(Ae, t) {
  !Ae || isDestroyed(Ae) || (!t && !isFinished(Ae) && (t = new AbortError$3()), isServerRequest(Ae) ? (Ae.socket = null, Ae.destroy(t)) : isRequest(Ae) ? Ae.abort() : isRequest(Ae.req) ? Ae.req.abort() : typeof Ae.destroy == "function" ? Ae.destroy(t) : typeof Ae.close == "function" ? Ae.close() : t ? process$2.nextTick(emitErrorCloseLegacy, Ae, t) : process$2.nextTick(emitCloseLegacy, Ae), Ae.destroyed || (Ae[kIsDestroyed] = !0));
}
var destroy_1 = {
  construct,
  destroyer: destroyer$2,
  destroy,
  undestroy,
  errorOrDestroy
};
const { ArrayIsArray: ArrayIsArray$1, ObjectSetPrototypeOf: ObjectSetPrototypeOf$2 } = primordials, { EventEmitter: EE } = eventsExports;
function Stream(Ae) {
  EE.call(this, Ae);
}
ObjectSetPrototypeOf$2(Stream.prototype, EE.prototype);
ObjectSetPrototypeOf$2(Stream, EE);
Stream.prototype.pipe = function(Ae, t) {
  const Ie = this;
  function Be(Ve) {
    Ae.writable && Ae.write(Ve) === !1 && Ie.pause && Ie.pause();
  }
  Ie.on("data", Be);
  function Pe() {
    Ie.readable && Ie.resume && Ie.resume();
  }
  Ae.on("drain", Pe), !Ae._isStdio && (!t || t.end !== !1) && (Ie.on("end", Me), Ie.on("close", Ue));
  let Te = !1;
  function Me() {
    Te || (Te = !0, Ae.end());
  }
  function Ue() {
    Te || (Te = !0, typeof Ae.destroy == "function" && Ae.destroy());
  }
  function je(Ve) {
    fn(), EE.listenerCount(this, "error") === 0 && this.emit("error", Ve);
  }
  prependListener(Ie, "error", je), prependListener(Ae, "error", je);
  function fn() {
    Ie.removeListener("data", Be), Ae.removeListener("drain", Pe), Ie.removeListener("end", Me), Ie.removeListener("close", Ue), Ie.removeListener("error", je), Ae.removeListener("error", je), Ie.removeListener("end", fn), Ie.removeListener("close", fn), Ae.removeListener("close", fn);
  }
  return Ie.on("end", fn), Ie.on("close", fn), Ae.on("close", fn), Ae.emit("pipe", Ie), Ae;
};
function prependListener(Ae, t, Ie) {
  if (typeof Ae.prependListener == "function") return Ae.prependListener(t, Ie);
  !Ae._events || !Ae._events[t] ? Ae.on(t, Ie) : ArrayIsArray$1(Ae._events[t]) ? Ae._events[t].unshift(Ie) : Ae._events[t] = [Ie, Ae._events[t]];
}
var legacy = {
  Stream,
  prependListener
}, addAbortSignal = { exports: {} };
(function(Ae) {
  const { SymbolDispose: t } = primordials, { AbortError: Ie, codes: Be } = errors, { isNodeStream: Pe, isWebStream: Te, kControllerErrorFunction: Me } = utils$1, Ue = endOfStreamExports, { ERR_INVALID_ARG_TYPE: je } = Be;
  let fn;
  const Ve = (vn, En) => {
    if (typeof vn != "object" || !("aborted" in vn))
      throw new je(En, "AbortSignal", vn);
  };
  Ae.exports.addAbortSignal = function(En, fi) {
    if (Ve(En, "signal"), !Pe(fi) && !Te(fi))
      throw new je("stream", ["ReadableStream", "WritableStream", "Stream"], fi);
    return Ae.exports.addAbortSignalNoValidate(En, fi);
  }, Ae.exports.addAbortSignalNoValidate = function(vn, En) {
    if (typeof vn != "object" || !("aborted" in vn))
      return En;
    const fi = Pe(En) ? () => {
      En.destroy(
        new Ie(void 0, {
          cause: vn.reason
        })
      );
    } : () => {
      En[Me](
        new Ie(void 0, {
          cause: vn.reason
        })
      );
    };
    if (vn.aborted)
      fi();
    else {
      fn = fn || utilExports.addAbortListener;
      const bi = fn(vn, fi);
      Ue(En, bi[t]);
    }
    return En;
  };
})(addAbortSignal);
var addAbortSignalExports = addAbortSignal.exports;
const { StringPrototypeSlice, SymbolIterator: SymbolIterator$1, TypedArrayPrototypeSet, Uint8Array: Uint8Array$1 } = primordials, { Buffer: Buffer$1 } = require$$0$4, { inspect } = utilExports;
var buffer_list = class {
  constructor() {
    this.head = null, this.tail = null, this.length = 0;
  }
  push(t) {
    const Ie = {
      data: t,
      next: null
    };
    this.length > 0 ? this.tail.next = Ie : this.head = Ie, this.tail = Ie, ++this.length;
  }
  unshift(t) {
    const Ie = {
      data: t,
      next: this.head
    };
    this.length === 0 && (this.tail = Ie), this.head = Ie, ++this.length;
  }
  shift() {
    if (this.length === 0) return;
    const t = this.head.data;
    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
  }
  clear() {
    this.head = this.tail = null, this.length = 0;
  }
  join(t) {
    if (this.length === 0) return "";
    let Ie = this.head, Be = "" + Ie.data;
    for (; (Ie = Ie.next) !== null; ) Be += t + Ie.data;
    return Be;
  }
  concat(t) {
    if (this.length === 0) return Buffer$1.alloc(0);
    const Ie = Buffer$1.allocUnsafe(t >>> 0);
    let Be = this.head, Pe = 0;
    for (; Be; )
      TypedArrayPrototypeSet(Ie, Be.data, Pe), Pe += Be.data.length, Be = Be.next;
    return Ie;
  }
  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(t, Ie) {
    const Be = this.head.data;
    if (t < Be.length) {
      const Pe = Be.slice(0, t);
      return this.head.data = Be.slice(t), Pe;
    }
    return t === Be.length ? this.shift() : Ie ? this._getString(t) : this._getBuffer(t);
  }
  first() {
    return this.head.data;
  }
  *[SymbolIterator$1]() {
    for (let t = this.head; t; t = t.next)
      yield t.data;
  }
  // Consumes a specified amount of characters from the buffered data.
  _getString(t) {
    let Ie = "", Be = this.head, Pe = 0;
    do {
      const Te = Be.data;
      if (t > Te.length)
        Ie += Te, t -= Te.length;
      else {
        t === Te.length ? (Ie += Te, ++Pe, Be.next ? this.head = Be.next : this.head = this.tail = null) : (Ie += StringPrototypeSlice(Te, 0, t), this.head = Be, Be.data = StringPrototypeSlice(Te, t));
        break;
      }
      ++Pe;
    } while ((Be = Be.next) !== null);
    return this.length -= Pe, Ie;
  }
  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(t) {
    const Ie = Buffer$1.allocUnsafe(t), Be = t;
    let Pe = this.head, Te = 0;
    do {
      const Me = Pe.data;
      if (t > Me.length)
        TypedArrayPrototypeSet(Ie, Me, Be - t), t -= Me.length;
      else {
        t === Me.length ? (TypedArrayPrototypeSet(Ie, Me, Be - t), ++Te, Pe.next ? this.head = Pe.next : this.head = this.tail = null) : (TypedArrayPrototypeSet(Ie, new Uint8Array$1(Me.buffer, Me.byteOffset, t), Be - t), this.head = Pe, Pe.data = Me.slice(t));
        break;
      }
      ++Te;
    } while ((Pe = Pe.next) !== null);
    return this.length -= Te, Ie;
  }
  // Make sure the linked list only shows the minimal necessary information.
  [Symbol.for("nodejs.util.inspect.custom")](t, Ie) {
    return inspect(this, {
      ...Ie,
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: !1
    });
  }
};
const { MathFloor: MathFloor$1, NumberIsInteger } = primordials, { validateInteger: validateInteger$1 } = validators, { ERR_INVALID_ARG_VALUE: ERR_INVALID_ARG_VALUE$2 } = errors.codes;
let defaultHighWaterMarkBytes = 16 * 1024, defaultHighWaterMarkObjectMode = 16;
function highWaterMarkFrom(Ae, t, Ie) {
  return Ae.highWaterMark != null ? Ae.highWaterMark : t ? Ae[Ie] : null;
}
function getDefaultHighWaterMark(Ae) {
  return Ae ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
}
function setDefaultHighWaterMark(Ae, t) {
  validateInteger$1(t, "value", 0), Ae ? defaultHighWaterMarkObjectMode = t : defaultHighWaterMarkBytes = t;
}
function getHighWaterMark$1(Ae, t, Ie, Be) {
  const Pe = highWaterMarkFrom(t, Be, Ie);
  if (Pe != null) {
    if (!NumberIsInteger(Pe) || Pe < 0) {
      const Te = Be ? `options.${Ie}` : "options.highWaterMark";
      throw new ERR_INVALID_ARG_VALUE$2(Te, Pe);
    }
    return MathFloor$1(Pe);
  }
  return getDefaultHighWaterMark(Ae.objectMode);
}
var state = {
  getHighWaterMark: getHighWaterMark$1,
  getDefaultHighWaterMark,
  setDefaultHighWaterMark
};
const process$1 = dist, { PromisePrototypeThen: PromisePrototypeThen$1, SymbolAsyncIterator: SymbolAsyncIterator$1, SymbolIterator } = primordials, { Buffer } = require$$0$4, { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE$3, ERR_STREAM_NULL_VALUES } = errors.codes;
function from$1(Ae, t, Ie) {
  let Be;
  if (typeof t == "string" || t instanceof Buffer)
    return new Ae({
      objectMode: !0,
      ...Ie,
      read() {
        this.push(t), this.push(null);
      }
    });
  let Pe;
  if (t && t[SymbolAsyncIterator$1])
    Pe = !0, Be = t[SymbolAsyncIterator$1]();
  else if (t && t[SymbolIterator])
    Pe = !1, Be = t[SymbolIterator]();
  else
    throw new ERR_INVALID_ARG_TYPE$3("iterable", ["Iterable"], t);
  const Te = new Ae({
    objectMode: !0,
    highWaterMark: 1,
    // TODO(ronag): What options should be allowed?
    ...Ie
  });
  let Me = !1;
  Te._read = function() {
    Me || (Me = !0, je());
  }, Te._destroy = function(fn, Ve) {
    PromisePrototypeThen$1(
      Ue(fn),
      () => process$1.nextTick(Ve, fn),
      // nextTick is here in case cb throws
      (vn) => process$1.nextTick(Ve, vn || fn)
    );
  };
  async function Ue(fn) {
    const Ve = fn != null, vn = typeof Be.throw == "function";
    if (Ve && vn) {
      const { value: En, done: fi } = await Be.throw(fn);
      if (await En, fi)
        return;
    }
    if (typeof Be.return == "function") {
      const { value: En } = await Be.return();
      await En;
    }
  }
  async function je() {
    for (; ; ) {
      try {
        const { value: fn, done: Ve } = Pe ? await Be.next() : Be.next();
        if (Ve)
          Te.push(null);
        else {
          const vn = fn && typeof fn.then == "function" ? await fn : fn;
          if (vn === null)
            throw Me = !1, new ERR_STREAM_NULL_VALUES();
          if (Te.push(vn))
            continue;
          Me = !1;
        }
      } catch (fn) {
        Te.destroy(fn);
      }
      break;
    }
  }
  return Te;
}
var from_1 = from$1, readable, hasRequiredReadable;
function requireReadable() {
  if (hasRequiredReadable) return readable;
  hasRequiredReadable = 1;
  const Ae = dist, {
    ArrayPrototypeIndexOf: t,
    NumberIsInteger: Ie,
    NumberIsNaN: Be,
    NumberParseInt: Pe,
    ObjectDefineProperties: Te,
    ObjectKeys: Me,
    ObjectSetPrototypeOf: Ue,
    Promise: je,
    SafeSet: fn,
    SymbolAsyncDispose: Ve,
    SymbolAsyncIterator: vn,
    Symbol: En
  } = primordials;
  readable = vo, vo.ReadableState = _o;
  const { EventEmitter: fi } = eventsExports, { Stream: bi, prependListener: mi } = legacy, { Buffer: _i } = require$$0$4, { addAbortSignal: Ei } = addAbortSignalExports, Si = endOfStreamExports;
  let Mi = utilExports.debuglog("stream", (os) => {
    Mi = os;
  });
  const Oi = buffer_list, Fi = destroy_1, { getHighWaterMark: Ui, getDefaultHighWaterMark: Pi } = state, {
    aggregateTwoErrors: Bi,
    codes: {
      ERR_INVALID_ARG_TYPE: ji,
      ERR_METHOD_NOT_IMPLEMENTED: Zi,
      ERR_OUT_OF_RANGE: zi,
      ERR_STREAM_PUSH_AFTER_EOF: xi,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT: $i
    },
    AbortError: vi
  } = errors, { validateObject: wi } = validators, Ai = En("kPaused"), { StringDecoder: Ri } = string_decoder, Ti = from_1;
  Ue(vo.prototype, bi.prototype), Ue(vo, bi);
  const Ci = () => {
  }, { errorOrDestroy: Ii } = Fi, Li = 1, Ni = 2, Vi = 4, is = 8, Ki = 16, ts = 32, qi = 64, Hi = 128, Xi = 256, ki = 512, Wi = 1024, Yi = 2048, Qi = 4096, ns = 8192, us = 16384, ps = 32768, Ds = 65536, Eo = 1 << 17, hs = 1 << 18;
  function So(os) {
    return {
      enumerable: !1,
      get() {
        return (this.state & os) !== 0;
      },
      set(as) {
        as ? this.state |= os : this.state &= ~os;
      }
    };
  }
  Te(_o.prototype, {
    objectMode: So(Li),
    ended: So(Ni),
    endEmitted: So(Vi),
    reading: So(is),
    // Stream is still being constructed and cannot be
    // destroyed until construction finished or failed.
    // Async construction is opt in, therefore we start as
    // constructed.
    constructed: So(Ki),
    // A flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    sync: So(ts),
    // Whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    needReadable: So(qi),
    emittedReadable: So(Hi),
    readableListening: So(Xi),
    resumeScheduled: So(ki),
    // True if the error was already emitted and should not be thrown again.
    errorEmitted: So(Wi),
    emitClose: So(Yi),
    autoDestroy: So(Qi),
    // Has it been destroyed.
    destroyed: So(ns),
    // Indicates whether the stream has finished destroying.
    closed: So(us),
    // True if close has been emitted or would have been emitted
    // depending on emitClose.
    closeEmitted: So(ps),
    multiAwaitDrain: So(Ds),
    // If true, a maybeReadMore has been scheduled.
    readingMore: So(Eo),
    dataEmitted: So(hs)
  });
  function _o(os, as, go) {
    typeof go != "boolean" && (go = as instanceof requireDuplex()), this.state = Yi | Qi | Ki | ts, os && os.objectMode && (this.state |= Li), go && os && os.readableObjectMode && (this.state |= Li), this.highWaterMark = os ? Ui(this, os, "readableHighWaterMark", go) : Pi(!1), this.buffer = new Oi(), this.length = 0, this.pipes = [], this.flowing = null, this[Ai] = null, os && os.emitClose === !1 && (this.state &= ~Yi), os && os.autoDestroy === !1 && (this.state &= ~Qi), this.errored = null, this.defaultEncoding = os && os.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, os && os.encoding && (this.decoder = new Ri(os.encoding), this.encoding = os.encoding);
  }
  function vo(os) {
    if (!(this instanceof vo)) return new vo(os);
    const as = this instanceof requireDuplex();
    this._readableState = new _o(os, this, as), os && (typeof os.read == "function" && (this._read = os.read), typeof os.destroy == "function" && (this._destroy = os.destroy), typeof os.construct == "function" && (this._construct = os.construct), os.signal && !as && Ei(os.signal, this)), bi.call(this, os), Fi.construct(this, () => {
      this._readableState.needReadable && Gi(this, this._readableState);
    });
  }
  vo.prototype.destroy = Fi.destroy, vo.prototype._undestroy = Fi.undestroy, vo.prototype._destroy = function(os, as) {
    as(os);
  }, vo.prototype[fi.captureRejectionSymbol] = function(os) {
    this.destroy(os);
  }, vo.prototype[Ve] = function() {
    let os;
    return this.destroyed || (os = this.readableEnded ? null : new vi(), this.destroy(os)), new je((as, go) => Si(this, (bo) => bo && bo !== os ? go(bo) : as(null)));
  }, vo.prototype.push = function(os, as) {
    return Ro(this, os, as, !1);
  }, vo.prototype.unshift = function(os, as) {
    return Ro(this, os, as, !0);
  };
  function Ro(os, as, go, bo) {
    Mi("readableAddChunk", as);
    const wo = os._readableState;
    let qo;
    if (wo.state & Li || (typeof as == "string" ? (go = go || wo.defaultEncoding, wo.encoding !== go && (bo && wo.encoding ? as = _i.from(as, go).toString(wo.encoding) : (as = _i.from(as, go), go = ""))) : as instanceof _i ? go = "" : bi._isUint8Array(as) ? (as = bi._uint8ArrayToBuffer(as), go = "") : as != null && (qo = new ji("chunk", ["string", "Buffer", "Uint8Array"], as))), qo)
      Ii(os, qo);
    else if (as === null)
      wo.state &= ~is, Po(os, wo);
    else if (wo.state & Li || as && as.length > 0)
      if (bo)
        if (wo.state & Vi) Ii(os, new $i());
        else {
          if (wo.destroyed || wo.errored) return !1;
          $o(os, wo, as, !0);
        }
      else if (wo.ended)
        Ii(os, new xi());
      else {
        if (wo.destroyed || wo.errored)
          return !1;
        wo.state &= ~is, wo.decoder && !go ? (as = wo.decoder.write(as), wo.objectMode || as.length !== 0 ? $o(os, wo, as, !1) : Gi(os, wo)) : $o(os, wo, as, !1);
      }
    else bo || (wo.state &= ~is, Gi(os, wo));
    return !wo.ended && (wo.length < wo.highWaterMark || wo.length === 0);
  }
  function $o(os, as, go, bo) {
    as.flowing && as.length === 0 && !as.sync && os.listenerCount("data") > 0 ? (as.state & Ds ? as.awaitDrainWriters.clear() : as.awaitDrainWriters = null, as.dataEmitted = !0, os.emit("data", go)) : (as.length += as.objectMode ? 1 : go.length, bo ? as.buffer.unshift(go) : as.buffer.push(go), as.state & qi && Co(os)), Gi(os, as);
  }
  vo.prototype.isPaused = function() {
    const os = this._readableState;
    return os[Ai] === !0 || os.flowing === !1;
  }, vo.prototype.setEncoding = function(os) {
    const as = new Ri(os);
    this._readableState.decoder = as, this._readableState.encoding = this._readableState.decoder.encoding;
    const go = this._readableState.buffer;
    let bo = "";
    for (const wo of go)
      bo += as.write(wo);
    return go.clear(), bo !== "" && go.push(bo), this._readableState.length = bo.length, this;
  };
  const Io = 1073741824;
  function To(os) {
    if (os > Io)
      throw new zi("size", "<= 1GiB", os);
    return os--, os |= os >>> 1, os |= os >>> 2, os |= os >>> 4, os |= os >>> 8, os |= os >>> 16, os++, os;
  }
  function Ao(os, as) {
    return os <= 0 || as.length === 0 && as.ended ? 0 : as.state & Li ? 1 : Be(os) ? as.flowing && as.length ? as.buffer.first().length : as.length : os <= as.length ? os : as.ended ? as.length : 0;
  }
  vo.prototype.read = function(os) {
    Mi("read", os), os === void 0 ? os = NaN : Ie(os) || (os = Pe(os, 10));
    const as = this._readableState, go = os;
    if (os > as.highWaterMark && (as.highWaterMark = To(os)), os !== 0 && (as.state &= ~Hi), os === 0 && as.needReadable && ((as.highWaterMark !== 0 ? as.length >= as.highWaterMark : as.length > 0) || as.ended))
      return Mi("read: emitReadable", as.length, as.ended), as.length === 0 && as.ended ? Go(this) : Co(this), null;
    if (os = Ao(os, as), os === 0 && as.ended)
      return as.length === 0 && Go(this), null;
    let bo = (as.state & qi) !== 0;
    if (Mi("need readable", bo), (as.length === 0 || as.length - os < as.highWaterMark) && (bo = !0, Mi("length less than watermark", bo)), as.ended || as.reading || as.destroyed || as.errored || !as.constructed)
      bo = !1, Mi("reading, ended or constructing", bo);
    else if (bo) {
      Mi("do read"), as.state |= is | ts, as.length === 0 && (as.state |= qi);
      try {
        this._read(as.highWaterMark);
      } catch (qo) {
        Ii(this, qo);
      }
      as.state &= ~ts, as.reading || (os = Ao(go, as));
    }
    let wo;
    return os > 0 ? wo = Lo(os, as) : wo = null, wo === null ? (as.needReadable = as.length <= as.highWaterMark, os = 0) : (as.length -= os, as.multiAwaitDrain ? as.awaitDrainWriters.clear() : as.awaitDrainWriters = null), as.length === 0 && (as.ended || (as.needReadable = !0), go !== os && as.ended && Go(this)), wo !== null && !as.errorEmitted && !as.closeEmitted && (as.dataEmitted = !0, this.emit("data", wo)), wo;
  };
  function Po(os, as) {
    if (Mi("onEofChunk"), !as.ended) {
      if (as.decoder) {
        const go = as.decoder.end();
        go && go.length && (as.buffer.push(go), as.length += as.objectMode ? 1 : go.length);
      }
      as.ended = !0, as.sync ? Co(os) : (as.needReadable = !1, as.emittedReadable = !0, rs(os));
    }
  }
  function Co(os) {
    const as = os._readableState;
    Mi("emitReadable", as.needReadable, as.emittedReadable), as.needReadable = !1, as.emittedReadable || (Mi("emitReadable", as.flowing), as.emittedReadable = !0, Ae.nextTick(rs, os));
  }
  function rs(os) {
    const as = os._readableState;
    Mi("emitReadable_", as.destroyed, as.length, as.ended), !as.destroyed && !as.errored && (as.length || as.ended) && (os.emit("readable"), as.emittedReadable = !1), as.needReadable = !as.flowing && !as.ended && as.length <= as.highWaterMark, Fo(os);
  }
  function Gi(os, as) {
    !as.readingMore && as.constructed && (as.readingMore = !0, Ae.nextTick(Ji, os, as));
  }
  function Ji(os, as) {
    for (; !as.reading && !as.ended && (as.length < as.highWaterMark || as.flowing && as.length === 0); ) {
      const go = as.length;
      if (Mi("maybeReadMore read 0"), os.read(0), go === as.length)
        break;
    }
    as.readingMore = !1;
  }
  vo.prototype._read = function(os) {
    throw new Zi("_read()");
  }, vo.prototype.pipe = function(os, as) {
    const go = this, bo = this._readableState;
    bo.pipes.length === 1 && (bo.multiAwaitDrain || (bo.multiAwaitDrain = !0, bo.awaitDrainWriters = new fn(bo.awaitDrainWriters ? [bo.awaitDrainWriters] : []))), bo.pipes.push(os), Mi("pipe count=%d opts=%j", bo.pipes.length, as);
    const qo = (!as || as.end !== !1) && os !== Ae.stdout && os !== Ae.stderr ? Oo : ta;
    bo.endEmitted ? Ae.nextTick(qo) : go.once("end", qo), os.on("unpipe", jo);
    function jo(ca, oa) {
      Mi("onunpipe"), ca === go && oa && oa.hasUnpiped === !1 && (oa.hasUnpiped = !0, Do());
    }
    function Oo() {
      Mi("onend"), os.end();
    }
    let Ho, zo = !1;
    function Do() {
      Mi("cleanup"), os.removeListener("close", ra), os.removeListener("finish", Zo), Ho && os.removeListener("drain", Ho), os.removeListener("error", Vo), os.removeListener("unpipe", jo), go.removeListener("end", Oo), go.removeListener("end", ta), go.removeListener("data", na), zo = !0, Ho && bo.awaitDrainWriters && (!os._writableState || os._writableState.needDrain) && Ho();
    }
    function Xo() {
      zo || (bo.pipes.length === 1 && bo.pipes[0] === os ? (Mi("false write response, pause", 0), bo.awaitDrainWriters = os, bo.multiAwaitDrain = !1) : bo.pipes.length > 1 && bo.pipes.includes(os) && (Mi("false write response, pause", bo.awaitDrainWriters.size), bo.awaitDrainWriters.add(os)), go.pause()), Ho || (Ho = ss(go, os), os.on("drain", Ho));
    }
    go.on("data", na);
    function na(ca) {
      Mi("ondata");
      const oa = os.write(ca);
      Mi("dest.write", oa), oa === !1 && Xo();
    }
    function Vo(ca) {
      if (Mi("onerror", ca), ta(), os.removeListener("error", Vo), os.listenerCount("error") === 0) {
        const oa = os._writableState || os._readableState;
        oa && !oa.errorEmitted ? Ii(os, ca) : os.emit("error", ca);
      }
    }
    mi(os, "error", Vo);
    function ra() {
      os.removeListener("finish", Zo), ta();
    }
    os.once("close", ra);
    function Zo() {
      Mi("onfinish"), os.removeListener("close", ra), ta();
    }
    os.once("finish", Zo);
    function ta() {
      Mi("unpipe"), go.unpipe(os);
    }
    return os.emit("pipe", go), os.writableNeedDrain === !0 ? Xo() : bo.flowing || (Mi("pipe resume"), go.resume()), os;
  };
  function ss(os, as) {
    return function() {
      const bo = os._readableState;
      bo.awaitDrainWriters === as ? (Mi("pipeOnDrain", 1), bo.awaitDrainWriters = null) : bo.multiAwaitDrain && (Mi("pipeOnDrain", bo.awaitDrainWriters.size), bo.awaitDrainWriters.delete(as)), (!bo.awaitDrainWriters || bo.awaitDrainWriters.size === 0) && os.listenerCount("data") && os.resume();
    };
  }
  vo.prototype.unpipe = function(os) {
    const as = this._readableState, go = {
      hasUnpiped: !1
    };
    if (as.pipes.length === 0) return this;
    if (!os) {
      const wo = as.pipes;
      as.pipes = [], this.pause();
      for (let qo = 0; qo < wo.length; qo++)
        wo[qo].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    const bo = t(as.pipes, os);
    return bo === -1 ? this : (as.pipes.splice(bo, 1), as.pipes.length === 0 && this.pause(), os.emit("unpipe", this, go), this);
  }, vo.prototype.on = function(os, as) {
    const go = bi.prototype.on.call(this, os, as), bo = this._readableState;
    return os === "data" ? (bo.readableListening = this.listenerCount("readable") > 0, bo.flowing !== !1 && this.resume()) : os === "readable" && !bo.endEmitted && !bo.readableListening && (bo.readableListening = bo.needReadable = !0, bo.flowing = !1, bo.emittedReadable = !1, Mi("on readable", bo.length, bo.reading), bo.length ? Co(this) : bo.reading || Ae.nextTick(ds, this)), go;
  }, vo.prototype.addListener = vo.prototype.on, vo.prototype.removeListener = function(os, as) {
    const go = bi.prototype.removeListener.call(this, os, as);
    return os === "readable" && Ae.nextTick(ls, this), go;
  }, vo.prototype.off = vo.prototype.removeListener, vo.prototype.removeAllListeners = function(os) {
    const as = bi.prototype.removeAllListeners.apply(this, arguments);
    return (os === "readable" || os === void 0) && Ae.nextTick(ls, this), as;
  };
  function ls(os) {
    const as = os._readableState;
    as.readableListening = os.listenerCount("readable") > 0, as.resumeScheduled && as[Ai] === !1 ? as.flowing = !0 : os.listenerCount("data") > 0 ? os.resume() : as.readableListening || (as.flowing = null);
  }
  function ds(os) {
    Mi("readable nexttick read 0"), os.read(0);
  }
  vo.prototype.resume = function() {
    const os = this._readableState;
    return os.flowing || (Mi("resume"), os.flowing = !os.readableListening, bs(this, os)), os[Ai] = !1, this;
  };
  function bs(os, as) {
    as.resumeScheduled || (as.resumeScheduled = !0, Ae.nextTick(Mo, os, as));
  }
  function Mo(os, as) {
    Mi("resume", as.reading), as.reading || os.read(0), as.resumeScheduled = !1, os.emit("resume"), Fo(os), as.flowing && !as.reading && os.read(0);
  }
  vo.prototype.pause = function() {
    return Mi("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (Mi("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState[Ai] = !0, this;
  };
  function Fo(os) {
    const as = os._readableState;
    for (Mi("flow", as.flowing); as.flowing && os.read() !== null; ) ;
  }
  vo.prototype.wrap = function(os) {
    let as = !1;
    os.on("data", (bo) => {
      !this.push(bo) && os.pause && (as = !0, os.pause());
    }), os.on("end", () => {
      this.push(null);
    }), os.on("error", (bo) => {
      Ii(this, bo);
    }), os.on("close", () => {
      this.destroy();
    }), os.on("destroy", () => {
      this.destroy();
    }), this._read = () => {
      as && os.resume && (as = !1, os.resume());
    };
    const go = Me(os);
    for (let bo = 1; bo < go.length; bo++) {
      const wo = go[bo];
      this[wo] === void 0 && typeof os[wo] == "function" && (this[wo] = os[wo].bind(os));
    }
    return this;
  }, vo.prototype[vn] = function() {
    return Bo(this);
  }, vo.prototype.iterator = function(os) {
    return os !== void 0 && wi(os, "options"), Bo(this, os);
  };
  function Bo(os, as) {
    typeof os.read != "function" && (os = vo.wrap(os, {
      objectMode: !0
    }));
    const go = Uo(os, as);
    return go.stream = os, go;
  }
  async function* Uo(os, as) {
    let go = Ci;
    function bo(jo) {
      this === os ? (go(), go = Ci) : go = jo;
    }
    os.on("readable", bo);
    let wo;
    const qo = Si(
      os,
      {
        writable: !1
      },
      (jo) => {
        wo = jo ? Bi(wo, jo) : null, go(), go = Ci;
      }
    );
    try {
      for (; ; ) {
        const jo = os.destroyed ? null : os.read();
        if (jo !== null)
          yield jo;
        else {
          if (wo)
            throw wo;
          if (wo === null)
            return;
          await new je(bo);
        }
      }
    } catch (jo) {
      throw wo = Bi(wo, jo), wo;
    } finally {
      (wo || (as == null ? void 0 : as.destroyOnReturn) !== !1) && (wo === void 0 || os._readableState.autoDestroy) ? Fi.destroyer(os, null) : (os.off("readable", bo), qo());
    }
  }
  Te(vo.prototype, {
    readable: {
      __proto__: null,
      get() {
        const os = this._readableState;
        return !!os && os.readable !== !1 && !os.destroyed && !os.errorEmitted && !os.endEmitted;
      },
      set(os) {
        this._readableState && (this._readableState.readable = !!os);
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(os) {
        this._readableState && (this._readableState.flowing = os);
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.objectMode : !1;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.destroyed : !1;
      },
      set(os) {
        this._readableState && (this._readableState.destroyed = os);
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.endEmitted : !1;
      }
    }
  }), Te(_o.prototype, {
    // Legacy getter for `pipesCount`.
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    // Legacy property for `paused`.
    paused: {
      __proto__: null,
      get() {
        return this[Ai] !== !1;
      },
      set(os) {
        this[Ai] = !!os;
      }
    }
  }), vo._fromList = Lo;
  function Lo(os, as) {
    if (as.length === 0) return null;
    let go;
    return as.objectMode ? go = as.buffer.shift() : !os || os >= as.length ? (as.decoder ? go = as.buffer.join("") : as.buffer.length === 1 ? go = as.buffer.first() : go = as.buffer.concat(as.length), as.buffer.clear()) : go = as.buffer.consume(os, as.decoder), go;
  }
  function Go(os) {
    const as = os._readableState;
    Mi("endReadable", as.endEmitted), as.endEmitted || (as.ended = !0, Ae.nextTick(Yo, as, os));
  }
  function Yo(os, as) {
    if (Mi("endReadableNT", os.endEmitted, os.length), !os.errored && !os.closeEmitted && !os.endEmitted && os.length === 0) {
      if (os.endEmitted = !0, as.emit("end"), as.writable && as.allowHalfOpen === !1)
        Ae.nextTick(Ko, as);
      else if (os.autoDestroy) {
        const go = as._writableState;
        (!go || go.autoDestroy && // We don't expect the writable to ever 'finish'
        // if writable is explicitly set to false.
        (go.finished || go.writable === !1)) && as.destroy();
      }
    }
  }
  function Ko(os) {
    os.writable && !os.writableEnded && !os.destroyed && os.end();
  }
  vo.from = function(os, as) {
    return Ti(vo, os, as);
  };
  let No;
  function Wo() {
    return No === void 0 && (No = {}), No;
  }
  return vo.fromWeb = function(os, as) {
    return Wo().newStreamReadableFromReadableStream(os, as);
  }, vo.toWeb = function(os, as) {
    return Wo().newReadableStreamFromStreamReadable(os, as);
  }, vo.wrap = function(os, as) {
    var go, bo;
    return new vo({
      objectMode: (go = (bo = os.readableObjectMode) !== null && bo !== void 0 ? bo : os.objectMode) !== null && go !== void 0 ? go : !0,
      ...as,
      destroy(wo, qo) {
        Fi.destroyer(os, wo), qo(wo);
      }
    }).wrap(os);
  }, readable;
}
var writable, hasRequiredWritable;
function requireWritable() {
  if (hasRequiredWritable) return writable;
  hasRequiredWritable = 1;
  const Ae = dist, {
    ArrayPrototypeSlice: t,
    Error: Ie,
    FunctionPrototypeSymbolHasInstance: Be,
    ObjectDefineProperty: Pe,
    ObjectDefineProperties: Te,
    ObjectSetPrototypeOf: Me,
    StringPrototypeToLowerCase: Ue,
    Symbol: je,
    SymbolHasInstance: fn
  } = primordials;
  writable = wi, wi.WritableState = $i;
  const { EventEmitter: Ve } = eventsExports, vn = legacy.Stream, { Buffer: En } = require$$0$4, fi = destroy_1, { addAbortSignal: bi } = addAbortSignalExports, { getHighWaterMark: mi, getDefaultHighWaterMark: _i } = state, {
    ERR_INVALID_ARG_TYPE: Ei,
    ERR_METHOD_NOT_IMPLEMENTED: Si,
    ERR_MULTIPLE_CALLBACK: Mi,
    ERR_STREAM_CANNOT_PIPE: Oi,
    ERR_STREAM_DESTROYED: Fi,
    ERR_STREAM_ALREADY_FINISHED: Ui,
    ERR_STREAM_NULL_VALUES: Pi,
    ERR_STREAM_WRITE_AFTER_END: Bi,
    ERR_UNKNOWN_ENCODING: ji
  } = errors.codes, { errorOrDestroy: Zi } = fi;
  Me(wi.prototype, vn.prototype), Me(wi, vn);
  function zi() {
  }
  const xi = je("kOnFinished");
  function $i(Qi, ns, us) {
    typeof us != "boolean" && (us = ns instanceof requireDuplex()), this.objectMode = !!(Qi && Qi.objectMode), us && (this.objectMode = this.objectMode || !!(Qi && Qi.writableObjectMode)), this.highWaterMark = Qi ? mi(this, Qi, "writableHighWaterMark", us) : _i(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    const ps = !!(Qi && Qi.decodeStrings === !1);
    this.decodeStrings = !ps, this.defaultEncoding = Qi && Qi.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = Ii.bind(void 0, ns), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, vi(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !Qi || Qi.emitClose !== !1, this.autoDestroy = !Qi || Qi.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[xi] = [];
  }
  function vi(Qi) {
    Qi.buffered = [], Qi.bufferedIndex = 0, Qi.allBuffers = !0, Qi.allNoop = !0;
  }
  $i.prototype.getBuffer = function() {
    return t(this.buffered, this.bufferedIndex);
  }, Pe($i.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function wi(Qi) {
    const ns = this instanceof requireDuplex();
    if (!ns && !Be(wi, this)) return new wi(Qi);
    this._writableState = new $i(Qi, this, ns), Qi && (typeof Qi.write == "function" && (this._write = Qi.write), typeof Qi.writev == "function" && (this._writev = Qi.writev), typeof Qi.destroy == "function" && (this._destroy = Qi.destroy), typeof Qi.final == "function" && (this._final = Qi.final), typeof Qi.construct == "function" && (this._construct = Qi.construct), Qi.signal && bi(Qi.signal, this)), vn.call(this, Qi), fi.construct(this, () => {
      const us = this._writableState;
      us.writing || is(this, us), Hi(this, us);
    });
  }
  Pe(wi, fn, {
    __proto__: null,
    value: function(Qi) {
      return Be(this, Qi) ? !0 : this !== wi ? !1 : Qi && Qi._writableState instanceof $i;
    }
  }), wi.prototype.pipe = function() {
    Zi(this, new Oi());
  };
  function Ai(Qi, ns, us, ps) {
    const Ds = Qi._writableState;
    if (typeof us == "function")
      ps = us, us = Ds.defaultEncoding;
    else {
      if (!us) us = Ds.defaultEncoding;
      else if (us !== "buffer" && !En.isEncoding(us)) throw new ji(us);
      typeof ps != "function" && (ps = zi);
    }
    if (ns === null)
      throw new Pi();
    if (!Ds.objectMode)
      if (typeof ns == "string")
        Ds.decodeStrings !== !1 && (ns = En.from(ns, us), us = "buffer");
      else if (ns instanceof En)
        us = "buffer";
      else if (vn._isUint8Array(ns))
        ns = vn._uint8ArrayToBuffer(ns), us = "buffer";
      else
        throw new Ei("chunk", ["string", "Buffer", "Uint8Array"], ns);
    let Eo;
    return Ds.ending ? Eo = new Bi() : Ds.destroyed && (Eo = new Fi("write")), Eo ? (Ae.nextTick(ps, Eo), Zi(Qi, Eo, !0), Eo) : (Ds.pendingcb++, Ri(Qi, Ds, ns, us, ps));
  }
  wi.prototype.write = function(Qi, ns, us) {
    return Ai(this, Qi, ns, us) === !0;
  }, wi.prototype.cork = function() {
    this._writableState.corked++;
  }, wi.prototype.uncork = function() {
    const Qi = this._writableState;
    Qi.corked && (Qi.corked--, Qi.writing || is(this, Qi));
  }, wi.prototype.setDefaultEncoding = function(ns) {
    if (typeof ns == "string" && (ns = Ue(ns)), !En.isEncoding(ns)) throw new ji(ns);
    return this._writableState.defaultEncoding = ns, this;
  };
  function Ri(Qi, ns, us, ps, Ds) {
    const Eo = ns.objectMode ? 1 : us.length;
    ns.length += Eo;
    const hs = ns.length < ns.highWaterMark;
    return hs || (ns.needDrain = !0), ns.writing || ns.corked || ns.errored || !ns.constructed ? (ns.buffered.push({
      chunk: us,
      encoding: ps,
      callback: Ds
    }), ns.allBuffers && ps !== "buffer" && (ns.allBuffers = !1), ns.allNoop && Ds !== zi && (ns.allNoop = !1)) : (ns.writelen = Eo, ns.writecb = Ds, ns.writing = !0, ns.sync = !0, Qi._write(us, ps, ns.onwrite), ns.sync = !1), hs && !ns.errored && !ns.destroyed;
  }
  function Ti(Qi, ns, us, ps, Ds, Eo, hs) {
    ns.writelen = ps, ns.writecb = hs, ns.writing = !0, ns.sync = !0, ns.destroyed ? ns.onwrite(new Fi("write")) : us ? Qi._writev(Ds, ns.onwrite) : Qi._write(Ds, Eo, ns.onwrite), ns.sync = !1;
  }
  function Ci(Qi, ns, us, ps) {
    --ns.pendingcb, ps(us), Vi(ns), Zi(Qi, us);
  }
  function Ii(Qi, ns) {
    const us = Qi._writableState, ps = us.sync, Ds = us.writecb;
    if (typeof Ds != "function") {
      Zi(Qi, new Mi());
      return;
    }
    us.writing = !1, us.writecb = null, us.length -= us.writelen, us.writelen = 0, ns ? (ns.stack, us.errored || (us.errored = ns), Qi._readableState && !Qi._readableState.errored && (Qi._readableState.errored = ns), ps ? Ae.nextTick(Ci, Qi, us, ns, Ds) : Ci(Qi, us, ns, Ds)) : (us.buffered.length > us.bufferedIndex && is(Qi, us), ps ? us.afterWriteTickInfo !== null && us.afterWriteTickInfo.cb === Ds ? us.afterWriteTickInfo.count++ : (us.afterWriteTickInfo = {
      count: 1,
      cb: Ds,
      stream: Qi,
      state: us
    }, Ae.nextTick(Li, us.afterWriteTickInfo)) : Ni(Qi, us, 1, Ds));
  }
  function Li({ stream: Qi, state: ns, count: us, cb: ps }) {
    return ns.afterWriteTickInfo = null, Ni(Qi, ns, us, ps);
  }
  function Ni(Qi, ns, us, ps) {
    for (!ns.ending && !Qi.destroyed && ns.length === 0 && ns.needDrain && (ns.needDrain = !1, Qi.emit("drain")); us-- > 0; )
      ns.pendingcb--, ps();
    ns.destroyed && Vi(ns), Hi(Qi, ns);
  }
  function Vi(Qi) {
    if (Qi.writing)
      return;
    for (let Ds = Qi.bufferedIndex; Ds < Qi.buffered.length; ++Ds) {
      var ns;
      const { chunk: Eo, callback: hs } = Qi.buffered[Ds], So = Qi.objectMode ? 1 : Eo.length;
      Qi.length -= So, hs(
        (ns = Qi.errored) !== null && ns !== void 0 ? ns : new Fi("write")
      );
    }
    const us = Qi[xi].splice(0);
    for (let Ds = 0; Ds < us.length; Ds++) {
      var ps;
      us[Ds](
        (ps = Qi.errored) !== null && ps !== void 0 ? ps : new Fi("end")
      );
    }
    vi(Qi);
  }
  function is(Qi, ns) {
    if (ns.corked || ns.bufferProcessing || ns.destroyed || !ns.constructed)
      return;
    const { buffered: us, bufferedIndex: ps, objectMode: Ds } = ns, Eo = us.length - ps;
    if (!Eo)
      return;
    let hs = ps;
    if (ns.bufferProcessing = !0, Eo > 1 && Qi._writev) {
      ns.pendingcb -= Eo - 1;
      const So = ns.allNoop ? zi : (vo) => {
        for (let Ro = hs; Ro < us.length; ++Ro)
          us[Ro].callback(vo);
      }, _o = ns.allNoop && hs === 0 ? us : t(us, hs);
      _o.allBuffers = ns.allBuffers, Ti(Qi, ns, !0, ns.length, _o, "", So), vi(ns);
    } else {
      do {
        const { chunk: So, encoding: _o, callback: vo } = us[hs];
        us[hs++] = null;
        const Ro = Ds ? 1 : So.length;
        Ti(Qi, ns, !1, Ro, So, _o, vo);
      } while (hs < us.length && !ns.writing);
      hs === us.length ? vi(ns) : hs > 256 ? (us.splice(0, hs), ns.bufferedIndex = 0) : ns.bufferedIndex = hs;
    }
    ns.bufferProcessing = !1;
  }
  wi.prototype._write = function(Qi, ns, us) {
    if (this._writev)
      this._writev(
        [
          {
            chunk: Qi,
            encoding: ns
          }
        ],
        us
      );
    else
      throw new Si("_write()");
  }, wi.prototype._writev = null, wi.prototype.end = function(Qi, ns, us) {
    const ps = this._writableState;
    typeof Qi == "function" ? (us = Qi, Qi = null, ns = null) : typeof ns == "function" && (us = ns, ns = null);
    let Ds;
    if (Qi != null) {
      const Eo = Ai(this, Qi, ns);
      Eo instanceof Ie && (Ds = Eo);
    }
    return ps.corked && (ps.corked = 1, this.uncork()), Ds || (!ps.errored && !ps.ending ? (ps.ending = !0, Hi(this, ps, !0), ps.ended = !0) : ps.finished ? Ds = new Ui("end") : ps.destroyed && (Ds = new Fi("end"))), typeof us == "function" && (Ds || ps.finished ? Ae.nextTick(us, Ds) : ps[xi].push(us)), this;
  };
  function Ki(Qi) {
    return Qi.ending && !Qi.destroyed && Qi.constructed && Qi.length === 0 && !Qi.errored && Qi.buffered.length === 0 && !Qi.finished && !Qi.writing && !Qi.errorEmitted && !Qi.closeEmitted;
  }
  function ts(Qi, ns) {
    let us = !1;
    function ps(Ds) {
      if (us) {
        Zi(Qi, Ds ?? Mi());
        return;
      }
      if (us = !0, ns.pendingcb--, Ds) {
        const Eo = ns[xi].splice(0);
        for (let hs = 0; hs < Eo.length; hs++)
          Eo[hs](Ds);
        Zi(Qi, Ds, ns.sync);
      } else Ki(ns) && (ns.prefinished = !0, Qi.emit("prefinish"), ns.pendingcb++, Ae.nextTick(Xi, Qi, ns));
    }
    ns.sync = !0, ns.pendingcb++;
    try {
      Qi._final(ps);
    } catch (Ds) {
      ps(Ds);
    }
    ns.sync = !1;
  }
  function qi(Qi, ns) {
    !ns.prefinished && !ns.finalCalled && (typeof Qi._final == "function" && !ns.destroyed ? (ns.finalCalled = !0, ts(Qi, ns)) : (ns.prefinished = !0, Qi.emit("prefinish")));
  }
  function Hi(Qi, ns, us) {
    Ki(ns) && (qi(Qi, ns), ns.pendingcb === 0 && (us ? (ns.pendingcb++, Ae.nextTick(
      (ps, Ds) => {
        Ki(Ds) ? Xi(ps, Ds) : Ds.pendingcb--;
      },
      Qi,
      ns
    )) : Ki(ns) && (ns.pendingcb++, Xi(Qi, ns))));
  }
  function Xi(Qi, ns) {
    ns.pendingcb--, ns.finished = !0;
    const us = ns[xi].splice(0);
    for (let ps = 0; ps < us.length; ps++)
      us[ps]();
    if (Qi.emit("finish"), ns.autoDestroy) {
      const ps = Qi._readableState;
      (!ps || ps.autoDestroy && // We don't expect the readable to ever 'end'
      // if readable is explicitly set to false.
      (ps.endEmitted || ps.readable === !1)) && Qi.destroy();
    }
  }
  Te(wi.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : !1;
      },
      set(Qi) {
        this._writableState && (this._writableState.destroyed = Qi);
      }
    },
    writable: {
      __proto__: null,
      get() {
        const Qi = this._writableState;
        return !!Qi && Qi.writable !== !1 && !Qi.destroyed && !Qi.errored && !Qi.ending && !Qi.ended;
      },
      set(Qi) {
        this._writableState && (this._writableState.writable = !!Qi);
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : !1;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : !1;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : !1;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const Qi = this._writableState;
        return Qi ? !Qi.destroyed && !Qi.ending && Qi.needDrain : !1;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  const ki = fi.destroy;
  wi.prototype.destroy = function(Qi, ns) {
    const us = this._writableState;
    return !us.destroyed && (us.bufferedIndex < us.buffered.length || us[xi].length) && Ae.nextTick(Vi, us), ki.call(this, Qi, ns), this;
  }, wi.prototype._undestroy = fi.undestroy, wi.prototype._destroy = function(Qi, ns) {
    ns(Qi);
  }, wi.prototype[Ve.captureRejectionSymbol] = function(Qi) {
    this.destroy(Qi);
  };
  let Wi;
  function Yi() {
    return Wi === void 0 && (Wi = {}), Wi;
  }
  return wi.fromWeb = function(Qi, ns) {
    return Yi().newStreamWritableFromWritableStream(Qi, ns);
  }, wi.toWeb = function(Qi) {
    return Yi().newWritableStreamFromStreamWritable(Qi);
  }, writable;
}
var duplexify, hasRequiredDuplexify;
function requireDuplexify() {
  if (hasRequiredDuplexify) return duplexify;
  hasRequiredDuplexify = 1;
  const Ae = dist, t = require$$0$4, {
    isReadable: Ie,
    isWritable: Be,
    isIterable: Pe,
    isNodeStream: Te,
    isReadableNodeStream: Me,
    isWritableNodeStream: Ue,
    isDuplexNodeStream: je,
    isReadableStream: fn,
    isWritableStream: Ve
  } = utils$1, vn = endOfStreamExports, {
    AbortError: En,
    codes: { ERR_INVALID_ARG_TYPE: fi, ERR_INVALID_RETURN_VALUE: bi }
  } = errors, { destroyer: mi } = destroy_1, _i = requireDuplex(), Ei = requireReadable(), Si = requireWritable(), { createDeferredPromise: Mi } = utilExports, Oi = from_1, Fi = globalThis.Blob || t.Blob, Ui = typeof Fi < "u" ? function($i) {
    return $i instanceof Fi;
  } : function($i) {
    return !1;
  }, Pi = globalThis.AbortController || requireBrowser().AbortController, { FunctionPrototypeCall: Bi } = primordials;
  class ji extends _i {
    constructor($i) {
      super($i), ($i == null ? void 0 : $i.readable) === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), ($i == null ? void 0 : $i.writable) === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0);
    }
  }
  duplexify = function xi($i, vi) {
    if (je($i))
      return $i;
    if (Me($i))
      return zi({
        readable: $i
      });
    if (Ue($i))
      return zi({
        writable: $i
      });
    if (Te($i))
      return zi({
        writable: !1,
        readable: !1
      });
    if (fn($i))
      return zi({
        readable: Ei.fromWeb($i)
      });
    if (Ve($i))
      return zi({
        writable: Si.fromWeb($i)
      });
    if (typeof $i == "function") {
      const { value: Ai, write: Ri, final: Ti, destroy: Ci } = Zi($i);
      if (Pe(Ai))
        return Oi(ji, Ai, {
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          write: Ri,
          final: Ti,
          destroy: Ci
        });
      const Ii = Ai == null ? void 0 : Ai.then;
      if (typeof Ii == "function") {
        let Li;
        const Ni = Bi(
          Ii,
          Ai,
          (Vi) => {
            if (Vi != null)
              throw new bi("nully", "body", Vi);
          },
          (Vi) => {
            mi(Li, Vi);
          }
        );
        return Li = new ji({
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          readable: !1,
          write: Ri,
          final(Vi) {
            Ti(async () => {
              try {
                await Ni, Ae.nextTick(Vi, null);
              } catch (is) {
                Ae.nextTick(Vi, is);
              }
            });
          },
          destroy: Ci
        });
      }
      throw new bi("Iterable, AsyncIterable or AsyncFunction", vi, Ai);
    }
    if (Ui($i))
      return xi($i.arrayBuffer());
    if (Pe($i))
      return Oi(ji, $i, {
        // TODO (ronag): highWaterMark?
        objectMode: !0,
        writable: !1
      });
    if (fn($i == null ? void 0 : $i.readable) && Ve($i == null ? void 0 : $i.writable))
      return ji.fromWeb($i);
    if (typeof ($i == null ? void 0 : $i.writable) == "object" || typeof ($i == null ? void 0 : $i.readable) == "object") {
      const Ai = $i != null && $i.readable ? Me($i == null ? void 0 : $i.readable) ? $i == null ? void 0 : $i.readable : xi($i.readable) : void 0, Ri = $i != null && $i.writable ? Ue($i == null ? void 0 : $i.writable) ? $i == null ? void 0 : $i.writable : xi($i.writable) : void 0;
      return zi({
        readable: Ai,
        writable: Ri
      });
    }
    const wi = $i == null ? void 0 : $i.then;
    if (typeof wi == "function") {
      let Ai;
      return Bi(
        wi,
        $i,
        (Ri) => {
          Ri != null && Ai.push(Ri), Ai.push(null);
        },
        (Ri) => {
          mi(Ai, Ri);
        }
      ), Ai = new ji({
        objectMode: !0,
        writable: !1,
        read() {
        }
      });
    }
    throw new fi(
      vi,
      [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise"
      ],
      $i
    );
  };
  function Zi(xi) {
    let { promise: $i, resolve: vi } = Mi();
    const wi = new Pi(), Ai = wi.signal;
    return {
      value: xi(
        async function* () {
          for (; ; ) {
            const Ti = $i;
            $i = null;
            const { chunk: Ci, done: Ii, cb: Li } = await Ti;
            if (Ae.nextTick(Li), Ii) return;
            if (Ai.aborted)
              throw new En(void 0, {
                cause: Ai.reason
              });
            ({ promise: $i, resolve: vi } = Mi()), yield Ci;
          }
        }(),
        {
          signal: Ai
        }
      ),
      write(Ti, Ci, Ii) {
        const Li = vi;
        vi = null, Li({
          chunk: Ti,
          done: !1,
          cb: Ii
        });
      },
      final(Ti) {
        const Ci = vi;
        vi = null, Ci({
          done: !0,
          cb: Ti
        });
      },
      destroy(Ti, Ci) {
        wi.abort(), Ci(Ti);
      }
    };
  }
  function zi(xi) {
    const $i = xi.readable && typeof xi.readable.read != "function" ? Ei.wrap(xi.readable) : xi.readable, vi = xi.writable;
    let wi = !!Ie($i), Ai = !!Be(vi), Ri, Ti, Ci, Ii, Li;
    function Ni(Vi) {
      const is = Ii;
      Ii = null, is ? is(Vi) : Vi && Li.destroy(Vi);
    }
    return Li = new ji({
      // TODO (ronag): highWaterMark?
      readableObjectMode: !!($i != null && $i.readableObjectMode),
      writableObjectMode: !!(vi != null && vi.writableObjectMode),
      readable: wi,
      writable: Ai
    }), Ai && (vn(vi, (Vi) => {
      Ai = !1, Vi && mi($i, Vi), Ni(Vi);
    }), Li._write = function(Vi, is, Ki) {
      vi.write(Vi, is) ? Ki() : Ri = Ki;
    }, Li._final = function(Vi) {
      vi.end(), Ti = Vi;
    }, vi.on("drain", function() {
      if (Ri) {
        const Vi = Ri;
        Ri = null, Vi();
      }
    }), vi.on("finish", function() {
      if (Ti) {
        const Vi = Ti;
        Ti = null, Vi();
      }
    })), wi && (vn($i, (Vi) => {
      wi = !1, Vi && mi($i, Vi), Ni(Vi);
    }), $i.on("readable", function() {
      if (Ci) {
        const Vi = Ci;
        Ci = null, Vi();
      }
    }), $i.on("end", function() {
      Li.push(null);
    }), Li._read = function() {
      for (; ; ) {
        const Vi = $i.read();
        if (Vi === null) {
          Ci = Li._read;
          return;
        }
        if (!Li.push(Vi))
          return;
      }
    }), Li._destroy = function(Vi, is) {
      !Vi && Ii !== null && (Vi = new En()), Ci = null, Ri = null, Ti = null, Ii === null ? is(Vi) : (Ii = is, mi(vi, Vi), mi($i, Vi));
    }, Li;
  }
  return duplexify;
}
var duplex, hasRequiredDuplex;
function requireDuplex() {
  if (hasRequiredDuplex) return duplex;
  hasRequiredDuplex = 1;
  const {
    ObjectDefineProperties: Ae,
    ObjectGetOwnPropertyDescriptor: t,
    ObjectKeys: Ie,
    ObjectSetPrototypeOf: Be
  } = primordials;
  duplex = Me;
  const Pe = requireReadable(), Te = requireWritable();
  Be(Me.prototype, Pe.prototype), Be(Me, Pe);
  {
    const Ve = Ie(Te.prototype);
    for (let vn = 0; vn < Ve.length; vn++) {
      const En = Ve[vn];
      Me.prototype[En] || (Me.prototype[En] = Te.prototype[En]);
    }
  }
  function Me(Ve) {
    if (!(this instanceof Me)) return new Me(Ve);
    Pe.call(this, Ve), Te.call(this, Ve), Ve ? (this.allowHalfOpen = Ve.allowHalfOpen !== !1, Ve.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), Ve.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0)) : this.allowHalfOpen = !0;
  }
  Ae(Me.prototype, {
    writable: {
      __proto__: null,
      ...t(Te.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...t(Te.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...t(Te.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...t(Te.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...t(Te.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...t(Te.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...t(Te.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...t(Te.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...t(Te.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
      },
      set(Ve) {
        this._readableState && this._writableState && (this._readableState.destroyed = Ve, this._writableState.destroyed = Ve);
      }
    }
  });
  let Ue;
  function je() {
    return Ue === void 0 && (Ue = {}), Ue;
  }
  Me.fromWeb = function(Ve, vn) {
    return je().newStreamDuplexFromReadableWritablePair(Ve, vn);
  }, Me.toWeb = function(Ve) {
    return je().newReadableWritablePairFromDuplex(Ve);
  };
  let fn;
  return Me.from = function(Ve) {
    return fn || (fn = requireDuplexify()), fn(Ve, "body");
  }, duplex;
}
const { ObjectSetPrototypeOf: ObjectSetPrototypeOf$1, Symbol: Symbol$2 } = primordials;
var transform = Transform$1;
const { ERR_METHOD_NOT_IMPLEMENTED } = errors.codes, Duplex$2 = requireDuplex(), { getHighWaterMark } = state;
ObjectSetPrototypeOf$1(Transform$1.prototype, Duplex$2.prototype);
ObjectSetPrototypeOf$1(Transform$1, Duplex$2);
const kCallback = Symbol$2("kCallback");
function Transform$1(Ae) {
  if (!(this instanceof Transform$1)) return new Transform$1(Ae);
  const t = Ae ? getHighWaterMark(this, Ae, "readableHighWaterMark", !0) : null;
  t === 0 && (Ae = {
    ...Ae,
    highWaterMark: null,
    readableHighWaterMark: t,
    // TODO (ronag): 0 is not optimal since we have
    // a "bug" where we check needDrain before calling _write and not after.
    // Refs: https://github.com/nodejs/node/pull/32887
    // Refs: https://github.com/nodejs/node/pull/35941
    writableHighWaterMark: Ae.writableHighWaterMark || 0
  }), Duplex$2.call(this, Ae), this._readableState.sync = !1, this[kCallback] = null, Ae && (typeof Ae.transform == "function" && (this._transform = Ae.transform), typeof Ae.flush == "function" && (this._flush = Ae.flush)), this.on("prefinish", prefinish);
}
function final(Ae) {
  typeof this._flush == "function" && !this.destroyed ? this._flush((t, Ie) => {
    if (t) {
      Ae ? Ae(t) : this.destroy(t);
      return;
    }
    Ie != null && this.push(Ie), this.push(null), Ae && Ae();
  }) : (this.push(null), Ae && Ae());
}
function prefinish() {
  this._final !== final && final.call(this);
}
Transform$1.prototype._final = final;
Transform$1.prototype._transform = function(Ae, t, Ie) {
  throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
};
Transform$1.prototype._write = function(Ae, t, Ie) {
  const Be = this._readableState, Pe = this._writableState, Te = Be.length;
  this._transform(Ae, t, (Me, Ue) => {
    if (Me) {
      Ie(Me);
      return;
    }
    Ue != null && this.push(Ue), Pe.ended || // Backwards compat.
    Te === Be.length || // Backwards compat.
    Be.length < Be.highWaterMark ? Ie() : this[kCallback] = Ie;
  });
};
Transform$1.prototype._read = function() {
  if (this[kCallback]) {
    const Ae = this[kCallback];
    this[kCallback] = null, Ae();
  }
};
const { ObjectSetPrototypeOf } = primordials;
var passthrough$1 = PassThrough$1;
const Transform = transform;
ObjectSetPrototypeOf(PassThrough$1.prototype, Transform.prototype);
ObjectSetPrototypeOf(PassThrough$1, Transform);
function PassThrough$1(Ae) {
  if (!(this instanceof PassThrough$1)) return new PassThrough$1(Ae);
  Transform.call(this, Ae);
}
PassThrough$1.prototype._transform = function(Ae, t, Ie) {
  Ie(null, Ae);
};
const process = dist, { ArrayIsArray, Promise: Promise$2, SymbolAsyncIterator, SymbolDispose } = primordials, eos$1 = endOfStreamExports, { once } = utilExports, destroyImpl = destroy_1, Duplex$1 = requireDuplex(), {
  aggregateTwoErrors,
  codes: {
    ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE$2,
    ERR_INVALID_RETURN_VALUE,
    ERR_MISSING_ARGS: ERR_MISSING_ARGS$2,
    ERR_STREAM_DESTROYED,
    ERR_STREAM_PREMATURE_CLOSE
  },
  AbortError: AbortError$2
} = errors, { validateFunction, validateAbortSignal: validateAbortSignal$1 } = validators, {
  isIterable,
  isReadable: isReadable$1,
  isReadableNodeStream,
  isNodeStream: isNodeStream$2,
  isTransformStream: isTransformStream$1,
  isWebStream: isWebStream$1,
  isReadableStream: isReadableStream$1,
  isReadableFinished
} = utils$1, AbortController$2 = globalThis.AbortController || requireBrowser().AbortController;
let PassThrough, Readable, addAbortListener;
function destroyer$1(Ae, t, Ie) {
  let Be = !1;
  Ae.on("close", () => {
    Be = !0;
  });
  const Pe = eos$1(
    Ae,
    {
      readable: t,
      writable: Ie
    },
    (Te) => {
      Be = !Te;
    }
  );
  return {
    destroy: (Te) => {
      Be || (Be = !0, destroyImpl.destroyer(Ae, Te || new ERR_STREAM_DESTROYED("pipe")));
    },
    cleanup: Pe
  };
}
function popCallback(Ae) {
  return validateFunction(Ae[Ae.length - 1], "streams[stream.length - 1]"), Ae.pop();
}
function makeAsyncIterable(Ae) {
  if (isIterable(Ae))
    return Ae;
  if (isReadableNodeStream(Ae))
    return fromReadable(Ae);
  throw new ERR_INVALID_ARG_TYPE$2("val", ["Readable", "Iterable", "AsyncIterable"], Ae);
}
async function* fromReadable(Ae) {
  Readable || (Readable = requireReadable()), yield* Readable.prototype[SymbolAsyncIterator].call(Ae);
}
async function pumpToNode(Ae, t, Ie, { end: Be }) {
  let Pe, Te = null;
  const Me = (fn) => {
    if (fn && (Pe = fn), Te) {
      const Ve = Te;
      Te = null, Ve();
    }
  }, Ue = () => new Promise$2((fn, Ve) => {
    Pe ? Ve(Pe) : Te = () => {
      Pe ? Ve(Pe) : fn();
    };
  });
  t.on("drain", Me);
  const je = eos$1(
    t,
    {
      readable: !1
    },
    Me
  );
  try {
    t.writableNeedDrain && await Ue();
    for await (const fn of Ae)
      t.write(fn) || await Ue();
    Be && (t.end(), await Ue()), Ie();
  } catch (fn) {
    Ie(Pe !== fn ? aggregateTwoErrors(Pe, fn) : fn);
  } finally {
    je(), t.off("drain", Me);
  }
}
async function pumpToWeb(Ae, t, Ie, { end: Be }) {
  isTransformStream$1(t) && (t = t.writable);
  const Pe = t.getWriter();
  try {
    for await (const Te of Ae)
      await Pe.ready, Pe.write(Te).catch(() => {
      });
    await Pe.ready, Be && await Pe.close(), Ie();
  } catch (Te) {
    try {
      await Pe.abort(Te), Ie(Te);
    } catch (Me) {
      Ie(Me);
    }
  }
}
function pipeline$1(...Ae) {
  return pipelineImpl(Ae, once(popCallback(Ae)));
}
function pipelineImpl(Ae, t, Ie) {
  if (Ae.length === 1 && ArrayIsArray(Ae[0]) && (Ae = Ae[0]), Ae.length < 2)
    throw new ERR_MISSING_ARGS$2("streams");
  const Be = new AbortController$2(), Pe = Be.signal, Te = Ie == null ? void 0 : Ie.signal, Me = [];
  validateAbortSignal$1(Te, "options.signal");
  function Ue() {
    bi(new AbortError$2());
  }
  addAbortListener = addAbortListener || utilExports.addAbortListener;
  let je;
  Te && (je = addAbortListener(Te, Ue));
  let fn, Ve;
  const vn = [];
  let En = 0;
  function fi(Si) {
    bi(Si, --En === 0);
  }
  function bi(Si, Mi) {
    var Oi;
    if (Si && (!fn || fn.code === "ERR_STREAM_PREMATURE_CLOSE") && (fn = Si), !(!fn && !Mi)) {
      for (; vn.length; )
        vn.shift()(fn);
      (Oi = je) === null || Oi === void 0 || Oi[SymbolDispose](), Be.abort(), Mi && (fn || Me.forEach((Fi) => Fi()), process.nextTick(t, fn, Ve));
    }
  }
  let mi;
  for (let Si = 0; Si < Ae.length; Si++) {
    const Mi = Ae[Si], Oi = Si < Ae.length - 1, Fi = Si > 0, Ui = Oi || (Ie == null ? void 0 : Ie.end) !== !1, Pi = Si === Ae.length - 1;
    if (isNodeStream$2(Mi)) {
      let Bi = function(ji) {
        ji && ji.name !== "AbortError" && ji.code !== "ERR_STREAM_PREMATURE_CLOSE" && fi(ji);
      };
      if (Ui) {
        const { destroy: ji, cleanup: Zi } = destroyer$1(Mi, Oi, Fi);
        vn.push(ji), isReadable$1(Mi) && Pi && Me.push(Zi);
      }
      Mi.on("error", Bi), isReadable$1(Mi) && Pi && Me.push(() => {
        Mi.removeListener("error", Bi);
      });
    }
    if (Si === 0)
      if (typeof Mi == "function") {
        if (mi = Mi({
          signal: Pe
        }), !isIterable(mi))
          throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", mi);
      } else isIterable(Mi) || isReadableNodeStream(Mi) || isTransformStream$1(Mi) ? mi = Mi : mi = Duplex$1.from(Mi);
    else if (typeof Mi == "function") {
      if (isTransformStream$1(mi)) {
        var _i;
        mi = makeAsyncIterable((_i = mi) === null || _i === void 0 ? void 0 : _i.readable);
      } else
        mi = makeAsyncIterable(mi);
      if (mi = Mi(mi, {
        signal: Pe
      }), Oi) {
        if (!isIterable(mi, !0))
          throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${Si - 1}]`, mi);
      } else {
        var Ei;
        PassThrough || (PassThrough = passthrough$1);
        const Bi = new PassThrough({
          objectMode: !0
        }), ji = (Ei = mi) === null || Ei === void 0 ? void 0 : Ei.then;
        if (typeof ji == "function")
          En++, ji.call(
            mi,
            (xi) => {
              Ve = xi, xi != null && Bi.write(xi), Ui && Bi.end(), process.nextTick(fi);
            },
            (xi) => {
              Bi.destroy(xi), process.nextTick(fi, xi);
            }
          );
        else if (isIterable(mi, !0))
          En++, pumpToNode(mi, Bi, fi, {
            end: Ui
          });
        else if (isReadableStream$1(mi) || isTransformStream$1(mi)) {
          const xi = mi.readable || mi;
          En++, pumpToNode(xi, Bi, fi, {
            end: Ui
          });
        } else
          throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", mi);
        mi = Bi;
        const { destroy: Zi, cleanup: zi } = destroyer$1(mi, !1, !0);
        vn.push(Zi), Pi && Me.push(zi);
      }
    } else if (isNodeStream$2(Mi)) {
      if (isReadableNodeStream(mi)) {
        En += 2;
        const Bi = pipe(mi, Mi, fi, {
          end: Ui
        });
        isReadable$1(Mi) && Pi && Me.push(Bi);
      } else if (isTransformStream$1(mi) || isReadableStream$1(mi)) {
        const Bi = mi.readable || mi;
        En++, pumpToNode(Bi, Mi, fi, {
          end: Ui
        });
      } else if (isIterable(mi))
        En++, pumpToNode(mi, Mi, fi, {
          end: Ui
        });
      else
        throw new ERR_INVALID_ARG_TYPE$2(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          mi
        );
      mi = Mi;
    } else if (isWebStream$1(Mi)) {
      if (isReadableNodeStream(mi))
        En++, pumpToWeb(makeAsyncIterable(mi), Mi, fi, {
          end: Ui
        });
      else if (isReadableStream$1(mi) || isIterable(mi))
        En++, pumpToWeb(mi, Mi, fi, {
          end: Ui
        });
      else if (isTransformStream$1(mi))
        En++, pumpToWeb(mi.readable, Mi, fi, {
          end: Ui
        });
      else
        throw new ERR_INVALID_ARG_TYPE$2(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          mi
        );
      mi = Mi;
    } else
      mi = Duplex$1.from(Mi);
  }
  return (Pe != null && Pe.aborted || Te != null && Te.aborted) && process.nextTick(Ue), mi;
}
function pipe(Ae, t, Ie, { end: Be }) {
  let Pe = !1;
  if (t.on("close", () => {
    Pe || Ie(new ERR_STREAM_PREMATURE_CLOSE());
  }), Ae.pipe(t, {
    end: !1
  }), Be) {
    let Te = function() {
      Pe = !0, t.end();
    };
    isReadableFinished(Ae) ? process.nextTick(Te) : Ae.once("end", Te);
  } else
    Ie();
  return eos$1(
    Ae,
    {
      readable: !0,
      writable: !1
    },
    (Te) => {
      const Me = Ae._readableState;
      Te && Te.code === "ERR_STREAM_PREMATURE_CLOSE" && Me && Me.ended && !Me.errored && !Me.errorEmitted ? Ae.once("end", Ie).once("error", Ie) : Ie(Te);
    }
  ), eos$1(
    t,
    {
      readable: !1,
      writable: !0
    },
    Ie
  );
}
var pipeline_1 = {
  pipelineImpl,
  pipeline: pipeline$1
};
const { pipeline } = pipeline_1, Duplex = requireDuplex(), { destroyer } = destroy_1, {
  isNodeStream: isNodeStream$1,
  isReadable,
  isWritable: isWritable$1,
  isWebStream,
  isTransformStream,
  isWritableStream,
  isReadableStream
} = utils$1, {
  AbortError: AbortError$1,
  codes: { ERR_INVALID_ARG_VALUE: ERR_INVALID_ARG_VALUE$1, ERR_MISSING_ARGS: ERR_MISSING_ARGS$1 }
} = errors, eos = endOfStreamExports;
var compose$1 = function Ae(...t) {
  if (t.length === 0)
    throw new ERR_MISSING_ARGS$1("streams");
  if (t.length === 1)
    return Duplex.from(t[0]);
  const Ie = [...t];
  if (typeof t[0] == "function" && (t[0] = Duplex.from(t[0])), typeof t[t.length - 1] == "function") {
    const fi = t.length - 1;
    t[fi] = Duplex.from(t[fi]);
  }
  for (let fi = 0; fi < t.length; ++fi)
    if (!(!isNodeStream$1(t[fi]) && !isWebStream(t[fi]))) {
      if (fi < t.length - 1 && !(isReadable(t[fi]) || isReadableStream(t[fi]) || isTransformStream(t[fi])))
        throw new ERR_INVALID_ARG_VALUE$1(`streams[${fi}]`, Ie[fi], "must be readable");
      if (fi > 0 && !(isWritable$1(t[fi]) || isWritableStream(t[fi]) || isTransformStream(t[fi])))
        throw new ERR_INVALID_ARG_VALUE$1(`streams[${fi}]`, Ie[fi], "must be writable");
    }
  let Be, Pe, Te, Me, Ue;
  function je(fi) {
    const bi = Me;
    Me = null, bi ? bi(fi) : fi ? Ue.destroy(fi) : !En && !vn && Ue.destroy();
  }
  const fn = t[0], Ve = pipeline(t, je), vn = !!(isWritable$1(fn) || isWritableStream(fn) || isTransformStream(fn)), En = !!(isReadable(Ve) || isReadableStream(Ve) || isTransformStream(Ve));
  if (Ue = new Duplex({
    // TODO (ronag): highWaterMark?
    writableObjectMode: !!(fn != null && fn.writableObjectMode),
    readableObjectMode: !!(Ve != null && Ve.readableObjectMode),
    writable: vn,
    readable: En
  }), vn) {
    if (isNodeStream$1(fn))
      Ue._write = function(bi, mi, _i) {
        fn.write(bi, mi) ? _i() : Be = _i;
      }, Ue._final = function(bi) {
        fn.end(), Pe = bi;
      }, fn.on("drain", function() {
        if (Be) {
          const bi = Be;
          Be = null, bi();
        }
      });
    else if (isWebStream(fn)) {
      const mi = (isTransformStream(fn) ? fn.writable : fn).getWriter();
      Ue._write = async function(_i, Ei, Si) {
        try {
          await mi.ready, mi.write(_i).catch(() => {
          }), Si();
        } catch (Mi) {
          Si(Mi);
        }
      }, Ue._final = async function(_i) {
        try {
          await mi.ready, mi.close().catch(() => {
          }), Pe = _i;
        } catch (Ei) {
          _i(Ei);
        }
      };
    }
    const fi = isTransformStream(Ve) ? Ve.readable : Ve;
    eos(fi, () => {
      if (Pe) {
        const bi = Pe;
        Pe = null, bi();
      }
    });
  }
  if (En) {
    if (isNodeStream$1(Ve))
      Ve.on("readable", function() {
        if (Te) {
          const fi = Te;
          Te = null, fi();
        }
      }), Ve.on("end", function() {
        Ue.push(null);
      }), Ue._read = function() {
        for (; ; ) {
          const fi = Ve.read();
          if (fi === null) {
            Te = Ue._read;
            return;
          }
          if (!Ue.push(fi))
            return;
        }
      };
    else if (isWebStream(Ve)) {
      const bi = (isTransformStream(Ve) ? Ve.readable : Ve).getReader();
      Ue._read = async function() {
        for (; ; )
          try {
            const { value: mi, done: _i } = await bi.read();
            if (!Ue.push(mi))
              return;
            if (_i) {
              Ue.push(null);
              return;
            }
          } catch {
            return;
          }
      };
    }
  }
  return Ue._destroy = function(fi, bi) {
    !fi && Me !== null && (fi = new AbortError$1()), Te = null, Be = null, Pe = null, Me === null ? bi(fi) : (Me = bi, isNodeStream$1(Ve) && destroyer(Ve, fi));
  }, Ue;
};
const AbortController$1 = globalThis.AbortController || requireBrowser().AbortController, {
  codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE$1, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
  AbortError
} = errors, { validateAbortSignal, validateInteger, validateObject: validateObject$2 } = validators, kWeakHandler = primordials.Symbol("kWeak"), kResistStopPropagation = primordials.Symbol("kResistStopPropagation"), { finished } = endOfStreamExports, staticCompose = compose$1, { addAbortSignalNoValidate } = addAbortSignalExports, { isWritable, isNodeStream } = utils$1, { deprecate } = utilExports, {
  ArrayPrototypePush,
  Boolean: Boolean$1,
  MathFloor,
  Number: Number$1,
  NumberIsNaN,
  Promise: Promise$1,
  PromiseReject,
  PromiseResolve,
  PromisePrototypeThen,
  Symbol: Symbol$1
} = primordials, kEmpty = Symbol$1("kEmpty"), kEof = Symbol$1("kEof");
function compose(Ae, t) {
  if (t != null && validateObject$2(t, "options"), (t == null ? void 0 : t.signal) != null && validateAbortSignal(t.signal, "options.signal"), isNodeStream(Ae) && !isWritable(Ae))
    throw new ERR_INVALID_ARG_VALUE("stream", Ae, "must be writable");
  const Ie = staticCompose(this, Ae);
  return t != null && t.signal && addAbortSignalNoValidate(t.signal, Ie), Ie;
}
function map(Ae, t) {
  if (typeof Ae != "function")
    throw new ERR_INVALID_ARG_TYPE$1("fn", ["Function", "AsyncFunction"], Ae);
  t != null && validateObject$2(t, "options"), (t == null ? void 0 : t.signal) != null && validateAbortSignal(t.signal, "options.signal");
  let Ie = 1;
  (t == null ? void 0 : t.concurrency) != null && (Ie = MathFloor(t.concurrency));
  let Be = Ie - 1;
  return (t == null ? void 0 : t.highWaterMark) != null && (Be = MathFloor(t.highWaterMark)), validateInteger(Ie, "options.concurrency", 1), validateInteger(Be, "options.highWaterMark", 0), Be += Ie, (async function* () {
    const Te = utilExports.AbortSignalAny(
      [t == null ? void 0 : t.signal].filter(Boolean$1)
    ), Me = this, Ue = [], je = {
      signal: Te
    };
    let fn, Ve, vn = !1, En = 0;
    function fi() {
      vn = !0, bi();
    }
    function bi() {
      En -= 1, mi();
    }
    function mi() {
      Ve && !vn && En < Ie && Ue.length < Be && (Ve(), Ve = null);
    }
    async function _i() {
      try {
        for await (let Ei of Me) {
          if (vn)
            return;
          if (Te.aborted)
            throw new AbortError();
          try {
            if (Ei = Ae(Ei, je), Ei === kEmpty)
              continue;
            Ei = PromiseResolve(Ei);
          } catch (Si) {
            Ei = PromiseReject(Si);
          }
          En += 1, PromisePrototypeThen(Ei, bi, fi), Ue.push(Ei), fn && (fn(), fn = null), !vn && (Ue.length >= Be || En >= Ie) && await new Promise$1((Si) => {
            Ve = Si;
          });
        }
        Ue.push(kEof);
      } catch (Ei) {
        const Si = PromiseReject(Ei);
        PromisePrototypeThen(Si, bi, fi), Ue.push(Si);
      } finally {
        vn = !0, fn && (fn(), fn = null);
      }
    }
    _i();
    try {
      for (; ; ) {
        for (; Ue.length > 0; ) {
          const Ei = await Ue[0];
          if (Ei === kEof)
            return;
          if (Te.aborted)
            throw new AbortError();
          Ei !== kEmpty && (yield Ei), Ue.shift(), mi();
        }
        await new Promise$1((Ei) => {
          fn = Ei;
        });
      }
    } finally {
      vn = !0, Ve && (Ve(), Ve = null);
    }
  }).call(this);
}
function asIndexedPairs(Ae = void 0) {
  return Ae != null && validateObject$2(Ae, "options"), (Ae == null ? void 0 : Ae.signal) != null && validateAbortSignal(Ae.signal, "options.signal"), (async function* () {
    let Ie = 0;
    for await (const Pe of this) {
      var Be;
      if (Ae != null && (Be = Ae.signal) !== null && Be !== void 0 && Be.aborted)
        throw new AbortError({
          cause: Ae.signal.reason
        });
      yield [Ie++, Pe];
    }
  }).call(this);
}
async function some(Ae, t = void 0) {
  for await (const Ie of filter.call(this, Ae, t))
    return !0;
  return !1;
}
async function every(Ae, t = void 0) {
  if (typeof Ae != "function")
    throw new ERR_INVALID_ARG_TYPE$1("fn", ["Function", "AsyncFunction"], Ae);
  return !await some.call(
    this,
    async (...Ie) => !await Ae(...Ie),
    t
  );
}
async function find(Ae, t) {
  for await (const Ie of filter.call(this, Ae, t))
    return Ie;
}
async function forEach(Ae, t) {
  if (typeof Ae != "function")
    throw new ERR_INVALID_ARG_TYPE$1("fn", ["Function", "AsyncFunction"], Ae);
  async function Ie(Be, Pe) {
    return await Ae(Be, Pe), kEmpty;
  }
  for await (const Be of map.call(this, Ie, t)) ;
}
function filter(Ae, t) {
  if (typeof Ae != "function")
    throw new ERR_INVALID_ARG_TYPE$1("fn", ["Function", "AsyncFunction"], Ae);
  async function Ie(Be, Pe) {
    return await Ae(Be, Pe) ? Be : kEmpty;
  }
  return map.call(this, Ie, t);
}
class ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
  constructor() {
    super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
  }
}
async function reduce(Ae, t, Ie) {
  var Be;
  if (typeof Ae != "function")
    throw new ERR_INVALID_ARG_TYPE$1("reducer", ["Function", "AsyncFunction"], Ae);
  Ie != null && validateObject$2(Ie, "options"), (Ie == null ? void 0 : Ie.signal) != null && validateAbortSignal(Ie.signal, "options.signal");
  let Pe = arguments.length > 1;
  if (Ie != null && (Be = Ie.signal) !== null && Be !== void 0 && Be.aborted) {
    const fn = new AbortError(void 0, {
      cause: Ie.signal.reason
    });
    throw this.once("error", () => {
    }), await finished(this.destroy(fn)), fn;
  }
  const Te = new AbortController$1(), Me = Te.signal;
  if (Ie != null && Ie.signal) {
    const fn = {
      once: !0,
      [kWeakHandler]: this,
      [kResistStopPropagation]: !0
    };
    Ie.signal.addEventListener("abort", () => Te.abort(), fn);
  }
  let Ue = !1;
  try {
    for await (const fn of this) {
      var je;
      if (Ue = !0, Ie != null && (je = Ie.signal) !== null && je !== void 0 && je.aborted)
        throw new AbortError();
      Pe ? t = await Ae(t, fn, {
        signal: Me
      }) : (t = fn, Pe = !0);
    }
    if (!Ue && !Pe)
      throw new ReduceAwareErrMissingArgs();
  } finally {
    Te.abort();
  }
  return t;
}
async function toArray(Ae) {
  Ae != null && validateObject$2(Ae, "options"), (Ae == null ? void 0 : Ae.signal) != null && validateAbortSignal(Ae.signal, "options.signal");
  const t = [];
  for await (const Be of this) {
    var Ie;
    if (Ae != null && (Ie = Ae.signal) !== null && Ie !== void 0 && Ie.aborted)
      throw new AbortError(void 0, {
        cause: Ae.signal.reason
      });
    ArrayPrototypePush(t, Be);
  }
  return t;
}
function flatMap(Ae, t) {
  const Ie = map.call(this, Ae, t);
  return (async function* () {
    for await (const Pe of Ie)
      yield* Pe;
  }).call(this);
}
function toIntegerOrInfinity(Ae) {
  if (Ae = Number$1(Ae), NumberIsNaN(Ae))
    return 0;
  if (Ae < 0)
    throw new ERR_OUT_OF_RANGE("number", ">= 0", Ae);
  return Ae;
}
function drop(Ae, t = void 0) {
  return t != null && validateObject$2(t, "options"), (t == null ? void 0 : t.signal) != null && validateAbortSignal(t.signal, "options.signal"), Ae = toIntegerOrInfinity(Ae), (async function* () {
    var Be;
    if (t != null && (Be = t.signal) !== null && Be !== void 0 && Be.aborted)
      throw new AbortError();
    for await (const Te of this) {
      var Pe;
      if (t != null && (Pe = t.signal) !== null && Pe !== void 0 && Pe.aborted)
        throw new AbortError();
      Ae-- <= 0 && (yield Te);
    }
  }).call(this);
}
function take(Ae, t = void 0) {
  return t != null && validateObject$2(t, "options"), (t == null ? void 0 : t.signal) != null && validateAbortSignal(t.signal, "options.signal"), Ae = toIntegerOrInfinity(Ae), (async function* () {
    var Be;
    if (t != null && (Be = t.signal) !== null && Be !== void 0 && Be.aborted)
      throw new AbortError();
    for await (const Te of this) {
      var Pe;
      if (t != null && (Pe = t.signal) !== null && Pe !== void 0 && Pe.aborted)
        throw new AbortError();
      if (Ae-- > 0 && (yield Te), Ae <= 0)
        return;
    }
  }).call(this);
}
operators.streamReturningOperators = {
  asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
  drop,
  filter,
  flatMap,
  map,
  take,
  compose
};
operators.promiseReturningOperators = {
  every,
  forEach,
  reduce,
  toArray,
  some,
  find
};
var promises, hasRequiredPromises;
function requirePromises() {
  if (hasRequiredPromises) return promises;
  hasRequiredPromises = 1;
  const { ArrayPrototypePop: Ae, Promise: t } = primordials, { isIterable: Ie, isNodeStream: Be, isWebStream: Pe } = utils$1, { pipelineImpl: Te } = pipeline_1, { finished: Me } = endOfStreamExports;
  requireStream();
  function Ue(...je) {
    return new t((fn, Ve) => {
      let vn, En;
      const fi = je[je.length - 1];
      if (fi && typeof fi == "object" && !Be(fi) && !Ie(fi) && !Pe(fi)) {
        const bi = Ae(je);
        vn = bi.signal, En = bi.end;
      }
      Te(
        je,
        (bi, mi) => {
          bi ? Ve(bi) : fn(mi);
        },
        {
          signal: vn,
          end: En
        }
      );
    });
  }
  return promises = {
    finished: Me,
    pipeline: Ue
  }, promises;
}
var hasRequiredStream;
function requireStream() {
  if (hasRequiredStream) return stream$1.exports;
  hasRequiredStream = 1;
  const { Buffer: Ae } = require$$0$4, { ObjectDefineProperty: t, ObjectKeys: Ie, ReflectApply: Be } = primordials, {
    promisify: { custom: Pe }
  } = utilExports, { streamReturningOperators: Te, promiseReturningOperators: Me } = operators, {
    codes: { ERR_ILLEGAL_CONSTRUCTOR: Ue }
  } = errors, je = compose$1, { setDefaultHighWaterMark: fn, getDefaultHighWaterMark: Ve } = state, { pipeline: vn } = pipeline_1, { destroyer: En } = destroy_1, fi = endOfStreamExports, bi = requirePromises(), mi = utils$1, _i = stream$1.exports = legacy.Stream;
  _i.isDestroyed = mi.isDestroyed, _i.isDisturbed = mi.isDisturbed, _i.isErrored = mi.isErrored, _i.isReadable = mi.isReadable, _i.isWritable = mi.isWritable, _i.Readable = requireReadable();
  for (const Si of Ie(Te)) {
    let Oi = function(...Fi) {
      if (new.target)
        throw Ue();
      return _i.Readable.from(Be(Mi, this, Fi));
    };
    const Mi = Te[Si];
    t(Oi, "name", {
      __proto__: null,
      value: Mi.name
    }), t(Oi, "length", {
      __proto__: null,
      value: Mi.length
    }), t(_i.Readable.prototype, Si, {
      __proto__: null,
      value: Oi,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  for (const Si of Ie(Me)) {
    let Oi = function(...Fi) {
      if (new.target)
        throw Ue();
      return Be(Mi, this, Fi);
    };
    const Mi = Me[Si];
    t(Oi, "name", {
      __proto__: null,
      value: Mi.name
    }), t(Oi, "length", {
      __proto__: null,
      value: Mi.length
    }), t(_i.Readable.prototype, Si, {
      __proto__: null,
      value: Oi,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  _i.Writable = requireWritable(), _i.Duplex = requireDuplex(), _i.Transform = transform, _i.PassThrough = passthrough$1, _i.pipeline = vn;
  const { addAbortSignal: Ei } = addAbortSignalExports;
  return _i.addAbortSignal = Ei, _i.finished = fi, _i.destroy = En, _i.compose = je, _i.setDefaultHighWaterMark = fn, _i.getDefaultHighWaterMark = Ve, t(_i, "promises", {
    __proto__: null,
    configurable: !0,
    enumerable: !0,
    get() {
      return bi;
    }
  }), t(vn, Pe, {
    __proto__: null,
    enumerable: !0,
    get() {
      return bi.pipeline;
    }
  }), t(fi, Pe, {
    __proto__: null,
    enumerable: !0,
    get() {
      return bi.finished;
    }
  }), _i.Stream = _i, _i._isUint8Array = function(Mi) {
    return Mi instanceof Uint8Array;
  }, _i._uint8ArrayToBuffer = function(Mi) {
    return Ae.from(Mi.buffer, Mi.byteOffset, Mi.byteLength);
  }, stream$1.exports;
}
(function(Ae) {
  const t = requireStream(), Ie = requirePromises(), Be = t.Readable.destroy;
  Ae.exports = t.Readable, Ae.exports._uint8ArrayToBuffer = t._uint8ArrayToBuffer, Ae.exports._isUint8Array = t._isUint8Array, Ae.exports.isDisturbed = t.isDisturbed, Ae.exports.isErrored = t.isErrored, Ae.exports.isReadable = t.isReadable, Ae.exports.Readable = t.Readable, Ae.exports.Writable = t.Writable, Ae.exports.Duplex = t.Duplex, Ae.exports.Transform = t.Transform, Ae.exports.PassThrough = t.PassThrough, Ae.exports.addAbortSignal = t.addAbortSignal, Ae.exports.finished = t.finished, Ae.exports.destroy = t.destroy, Ae.exports.destroy = Be, Ae.exports.pipeline = t.pipeline, Ae.exports.compose = t.compose, Object.defineProperty(t, "promises", {
    configurable: !0,
    enumerable: !0,
    get() {
      return Ie;
    }
  }), Ae.exports.Stream = t.Stream, Ae.exports.default = Ae.exports;
})(browser$4);
function safeApply(Ae, t, Ie) {
  try {
    Reflect.apply(Ae, t, Ie);
  } catch (Be) {
    setTimeout(() => {
      throw Be;
    });
  }
}
function arrayClone(Ae) {
  const t = Ae.length, Ie = new Array(t);
  for (let Be = 0; Be < t; Be += 1)
    Ie[Be] = Ae[Be];
  return Ie;
}
class SafeEventEmitter extends eventsExports.EventEmitter {
  emit(t, ...Ie) {
    let Be = t === "error";
    const Pe = this._events;
    if (Pe !== void 0)
      Be = Be && Pe.error === void 0;
    else if (!Be)
      return !1;
    if (Be) {
      let Me;
      if (Ie.length > 0 && ([Me] = Ie), Me instanceof Error)
        throw Me;
      const Ue = new Error(`Unhandled error.${Me ? ` (${Me.message})` : ""}`);
      throw Ue.context = Me, Ue;
    }
    const Te = Pe[t];
    if (Te === void 0)
      return !1;
    if (typeof Te == "function")
      safeApply(Te, this, Ie);
    else {
      const Me = Te.length, Ue = arrayClone(Te);
      for (let je = 0; je < Me; je += 1)
        safeApply(Ue[je], this, Ie);
    }
    return !0;
  }
}
class SerializableError extends Error {
  constructor({
    code: t,
    message: Ie,
    data: Be
  }) {
    if (!Number.isInteger(t))
      throw new Error("code must be an integer");
    if (!Ie || typeof Ie != "string")
      throw new Error("message must be string");
    super(Ie), _defineProperty(this, "code", void 0), _defineProperty(this, "data", void 0), this.code = t, Be !== void 0 && (this.data = Be);
  }
  toString() {
    return stringify$3({
      code: this.code,
      message: this.message,
      data: this.data,
      stack: this.stack
    });
  }
}
const errorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901
  }
}, errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  4001: {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  4100: {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  4200: {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  4900: {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  4901: {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  }
}, FALLBACK_ERROR_CODE = errorCodes.rpc.internal, FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.", JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
function isValidCode(Ae) {
  return Number.isInteger(Ae);
}
function isValidString(Ae) {
  return typeof Ae == "string" && Ae.length > 0;
}
function isObject(Ae) {
  return !!Ae && typeof Ae == "object" && !Array.isArray(Ae);
}
function isPlainObject(Ae) {
  if (typeof Ae != "object" || Ae === null)
    return !1;
  try {
    let t = Ae;
    for (; Object.getPrototypeOf(t) !== null; )
      t = Object.getPrototypeOf(t);
    return Object.getPrototypeOf(Ae) === t;
  } catch {
    return !1;
  }
}
function isJsonRpcServerError(Ae) {
  return Ae >= -32099 && Ae <= -32e3;
}
function isJsonRpcError$1(Ae) {
  const t = Ae;
  return !(!t || !isValidCode(t.code) || !isValidString(t.message) || t.stack && !isValidString(t.stack));
}
function getMessageFromCode(Ae, t = FALLBACK_MESSAGE) {
  if (isValidCode(Ae)) {
    const Ie = Ae.toString();
    if (Object.hasOwn(errorValues, Ie))
      return errorValues[Ie].message;
    if (isJsonRpcServerError(Ae))
      return JSON_RPC_SERVER_ERROR_MESSAGE;
  }
  return t;
}
const FALLBACK_ERROR = {
  code: FALLBACK_ERROR_CODE,
  message: getMessageFromCode(FALLBACK_ERROR_CODE)
};
function isValidJson(Ae) {
  try {
    JSON.parse(JSON.stringify(Ae, (t, Ie) => {
      if (t === "__proto__" || t === "constructor")
        throw new Error("Not valid json");
      if (typeof Ie == "function" || typeof Ie == "symbol")
        throw new Error("Not valid json");
      return Ie;
    }), (t, Ie) => {
      if (!(t === "__proto__" || t === "constructor"))
        return Ie;
    });
  } catch {
    return !1;
  }
  return !0;
}
function serializeObject(Ae) {
  return Object.getOwnPropertyNames(Ae).reduce((t, Ie) => {
    const Be = Ae[Ie];
    return isValidJson(Be) && (t[Ie] = Be), t;
  }, {});
}
function serializeCause(Ae) {
  return Array.isArray(Ae) ? Ae.map((t) => isValidJson(t) ? t : isObject(t) ? serializeObject(t) : null) : isObject(Ae) ? serializeObject(Ae) : isValidJson(Ae) ? Ae : null;
}
function buildError(Ae, t) {
  if (Ae && typeof Ae == "object" && "serialize" in Ae && typeof Ae.serialize == "function")
    return Ae.serialize();
  if (isJsonRpcError$1(Ae))
    return Ae;
  const Ie = serializeCause(Ae);
  return _objectSpread2(_objectSpread2({}, t), {}, {
    data: {
      cause: Ie
    }
  });
}
function serializeError(Ae, {
  fallbackError: t = FALLBACK_ERROR,
  shouldIncludeStack: Ie = !0
} = {}) {
  if (!isJsonRpcError$1(t))
    throw new Error("Must provide fallback error with integer number code and string message.");
  const Be = buildError(Ae, t);
  return Ie || delete Be.stack, Be;
}
function dataHasCause(Ae) {
  return isObject(Ae) && Object.hasOwn(Ae, "cause") && isObject(Ae.cause);
}
function isValidEthProviderCode(Ae) {
  return Number.isInteger(Ae) && Ae >= 1e3 && Ae <= 4999;
}
function stringifyReplacer(Ae, t) {
  if (t !== "[Circular]")
    return t;
}
class JsonRpcError extends Error {
  constructor(t, Ie, Be) {
    if (!Number.isInteger(t))
      throw new Error('"code" must be an integer.');
    if (!Ie || typeof Ie != "string")
      throw new Error('"message" must be a non-empty string.');
    dataHasCause(Be) ? (super(Ie, {
      cause: Be.cause
    }), _defineProperty(this, "cause", void 0), _defineProperty(this, "code", void 0), _defineProperty(this, "data", void 0), Object.hasOwn(this, "cause") || Object.assign(this, {
      cause: Be.cause
    })) : (super(Ie), _defineProperty(this, "cause", void 0), _defineProperty(this, "code", void 0), _defineProperty(this, "data", void 0)), Be !== void 0 && (this.data = Be), this.code = t, this.cause = Be == null ? void 0 : Be.cause;
  }
  /**
   * Get the error as JSON-serializable object.
   *
   * @returns A plain object with all public class properties.
   */
  serialize() {
    const t = {
      code: this.code,
      message: this.message
    };
    return this.data !== void 0 && (t.data = this.data, isPlainObject(this.data) && (t.data.cause = serializeCause(this.data.cause))), this.stack && (t.stack = this.stack), t;
  }
  /**
   * Get a string representation of the serialized error, omitting any circular
   * references.
   *
   * @returns A string representation of the serialized error.
   */
  toString() {
    return stringify$3(this.serialize(), {
      replacer: stringifyReplacer,
      space: 2
    });
  }
}
class EthereumProviderError extends JsonRpcError {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   *
   * @param code - The JSON-RPC error code. Must be an integer in the
   * `1000 <= n <= 4999` range.
   * @param message - The JSON-RPC error message.
   * @param data - Optional data to include in the error.
   */
  constructor(t, Ie, Be) {
    if (!isValidEthProviderCode(t))
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(t, Ie, Be);
  }
}
function parseOpts(Ae) {
  if (Ae) {
    if (typeof Ae == "string")
      return [Ae];
    if (typeof Ae == "object" && !Array.isArray(Ae)) {
      const {
        message: t,
        data: Ie
      } = Ae;
      if (t && typeof t != "string")
        throw new Error("Must specify string message.");
      return [t ?? void 0, Ie];
    }
  }
  return [];
}
function getJsonRpcError(Ae, t) {
  const [Ie, Be] = parseOpts(t);
  return new JsonRpcError(Ae, Ie ?? getMessageFromCode(Ae), Be);
}
function getEthProviderError(Ae, t) {
  const [Ie, Be] = parseOpts(t);
  return new EthereumProviderError(Ae, Ie ?? getMessageFromCode(Ae), Be);
}
const rpcErrors = {
  /**
   * Get a JSON RPC 2.0 Parse (-32700) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  parse: (Ae) => getJsonRpcError(errorCodes.rpc.parse, Ae),
  /**
   * Get a JSON RPC 2.0 Invalid Request (-32600) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  invalidRequest: (Ae) => getJsonRpcError(errorCodes.rpc.invalidRequest, Ae),
  /**
   * Get a JSON RPC 2.0 Invalid Params (-32602) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  invalidParams: (Ae) => getJsonRpcError(errorCodes.rpc.invalidParams, Ae),
  /**
   * Get a JSON RPC 2.0 Method Not Found (-32601) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  methodNotFound: (Ae) => getJsonRpcError(errorCodes.rpc.methodNotFound, Ae),
  /**
   * Get a JSON RPC 2.0 Internal (-32603) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  internal: (Ae) => getJsonRpcError(errorCodes.rpc.internal, Ae),
  /**
   * Get a JSON RPC 2.0 Server error.
   * Permits integer error codes in the [ -32099 <= -32005 ] range.
   * Codes -32000 through -32004 are reserved by EIP-1474.
   *
   * @param opts - The error options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  server: (Ae) => {
    if (!Ae || typeof Ae != "object" || Array.isArray(Ae))
      throw new Error("Ethereum RPC Server errors must provide single object argument.");
    const {
      code: t
    } = Ae;
    if (!Number.isInteger(t) || t > -32005 || t < -32099)
      throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
    return getJsonRpcError(t, Ae);
  },
  /**
   * Get an Ethereum JSON RPC Invalid Input (-32000) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  invalidInput: (Ae) => getJsonRpcError(errorCodes.rpc.invalidInput, Ae),
  /**
   * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  resourceNotFound: (Ae) => getJsonRpcError(errorCodes.rpc.resourceNotFound, Ae),
  /**
   * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  resourceUnavailable: (Ae) => getJsonRpcError(errorCodes.rpc.resourceUnavailable, Ae),
  /**
   * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  transactionRejected: (Ae) => getJsonRpcError(errorCodes.rpc.transactionRejected, Ae),
  /**
   * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  methodNotSupported: (Ae) => getJsonRpcError(errorCodes.rpc.methodNotSupported, Ae),
  /**
   * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */
  limitExceeded: (Ae) => getJsonRpcError(errorCodes.rpc.limitExceeded, Ae)
}, providerErrors = {
  /**
   * Get an Ethereum Provider User Rejected Request (4001) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link EthereumProviderError} class.
   */
  userRejectedRequest: (Ae) => getEthProviderError(errorCodes.provider.userRejectedRequest, Ae),
  /**
   * Get an Ethereum Provider Unauthorized (4100) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link EthereumProviderError} class.
   */
  unauthorized: (Ae) => getEthProviderError(errorCodes.provider.unauthorized, Ae),
  /**
   * Get an Ethereum Provider Unsupported Method (4200) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link EthereumProviderError} class.
   */
  unsupportedMethod: (Ae) => getEthProviderError(errorCodes.provider.unsupportedMethod, Ae),
  /**
   * Get an Ethereum Provider Not Connected (4900) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link EthereumProviderError} class.
   */
  disconnected: (Ae) => getEthProviderError(errorCodes.provider.disconnected, Ae),
  /**
   * Get an Ethereum Provider Chain Not Connected (4901) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link EthereumProviderError} class.
   */
  chainDisconnected: (Ae) => getEthProviderError(errorCodes.provider.chainDisconnected, Ae),
  /**
   * Get a custom Ethereum Provider error.
   *
   * @param opts - The error options bag.
   * @returns An instance of the {@link EthereumProviderError} class.
   */
  custom: (Ae) => {
    if (!Ae || typeof Ae != "object" || Array.isArray(Ae))
      throw new Error("Ethereum Provider custom errors must provide single object argument.");
    const {
      code: t,
      message: Ie,
      data: Be
    } = Ae;
    if (!Ie || typeof Ie != "string")
      throw new Error('"message" must be a nonempty string');
    return new EthereumProviderError(t, Ie, Be);
  }
};
function createScaffoldMiddleware(Ae) {
  return (t, Ie, Be, Pe) => {
    const Te = Ae[t.method];
    return Te === void 0 ? Be() : typeof Te == "function" ? Te(t, Ie, Be, Pe) : (Ie.result = Te, Pe());
  };
}
function createAsyncMiddleware(Ae) {
  return async (t, Ie, Be, Pe) => {
    let Te;
    const Me = new Promise((Ve) => {
      Te = Ve;
    });
    let Ue = null, je = !1;
    const fn = async () => {
      je = !0, Be((Ve) => {
        Ue = Ve, Te();
      }), await Me;
    };
    try {
      await Ae(t, Ie, fn), je ? (await Me, Ue(null)) : Pe(null);
    } catch (Ve) {
      const vn = Ve;
      Ue ? Ue(vn) : Pe(vn);
    }
  };
}
class JRPCEngine extends SafeEventEmitter {
  constructor() {
    super(), _defineProperty(this, "_middleware", void 0), this._middleware = [];
  }
  /**
   * Serially executes the given stack of middleware.
   *
   * @returns An array of any error encountered during middleware execution,
   * a boolean indicating whether the request was completed, and an array of
   * middleware-defined return handlers.
   */
  static async _runAllMiddleware(t, Ie, Be) {
    const Pe = [];
    let Te = null, Me = !1;
    for (const Ue of Be)
      if ([Te, Me] = await JRPCEngine._runMiddleware(t, Ie, Ue, Pe), Me)
        break;
    return [Te, Me, Pe.reverse()];
  }
  /**
   * Runs an individual middleware.
   *
   * @returns An array of any error encountered during middleware execution,
   * and a boolean indicating whether the request should end.
   */
  static _runMiddleware(t, Ie, Be, Pe) {
    return new Promise((Te) => {
      const Me = (je) => {
        const fn = je || Ie.error;
        fn && (typeof fn == "object" && Object.keys(fn).includes("stack") === !1 && (fn.stack = "Stack trace is not available."), Ie.error = serializeError(fn, {
          shouldIncludeStack: !0,
          fallbackError: {
            message: (fn == null ? void 0 : fn.message) || (fn == null ? void 0 : fn.toString()),
            code: (fn == null ? void 0 : fn.code) || -32603,
            stack: (fn == null ? void 0 : fn.stack) || "Stack trace is not available.",
            data: (fn == null ? void 0 : fn.data) || (fn == null ? void 0 : fn.message) || (fn == null ? void 0 : fn.toString())
          }
        })), Te([fn, !0]);
      }, Ue = (je) => {
        Ie.error ? Me(Ie.error) : (je && (typeof je != "function" && Me(new SerializableError({
          code: -32603,
          message: "JRPCEngine: 'next' return handlers must be functions"
        })), Pe.push(je)), Te([null, !1]));
      };
      try {
        Be(t, Ie, Ue, Me);
      } catch (je) {
        Me(je);
      }
    });
  }
  /**
   * Serially executes array of return handlers. The request and response are
   * assumed to be in their scope.
   */
  static async _runReturnHandlers(t) {
    for (const Ie of t)
      await new Promise((Be, Pe) => {
        Ie((Te) => Te ? Pe(Te) : Be());
      });
  }
  /**
   * Throws an error if the response has neither a result nor an error, or if
   * the "isComplete" flag is falsy.
   */
  static _checkForCompletion(t, Ie, Be) {
    if (!("result" in Ie) && !("error" in Ie))
      throw new SerializableError({
        code: -32603,
        message: "Response has no error or result for request"
      });
    if (!Be)
      throw new SerializableError({
        code: -32603,
        message: "Nothing ended request"
      });
  }
  /**
   * Add a middleware function to the engine's middleware stack.
   *
   * @param middleware - The middleware function to add.
   */
  push(t) {
    this._middleware.push(t);
  }
  /**
   * Handle a JSON-RPC request, and return a response.
   *
   * @param request - The request to handle.
   * @param callback - An error-first callback that will receive the response.
   */
  /**
   * Handle an array of JSON-RPC requests, and return an array of responses.
   *
   * @param request - The requests to handle.
   * @param callback - An error-first callback that will receive the array of
   * responses.
   */
  /**
   * Handle a JSON-RPC request, and return a response.
   *
   * @param request - The request to handle.
   * @returns A promise that resolves with the response, or rejects with an
   * error.
   */
  /**
   * Handle an array of JSON-RPC requests, and return an array of responses.
   *
   * @param request - The requests to handle.
   * @returns A promise that resolves with the array of responses, or rejects
   * with an error.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  handle(t, Ie) {
    if (Ie && typeof Ie != "function")
      throw new Error('"callback" must be a function if provided.');
    return Array.isArray(t) ? Ie ? this._handleBatch(t, Ie) : this._handleBatch(t) : Ie ? this._handle(t, Ie) : this._promiseHandle(t);
  }
  /**
   * Returns this engine as a middleware function that can be pushed to other
   * engines.
   *
   * @returns This engine as a middleware function.
   */
  asMiddleware() {
    return async (t, Ie, Be, Pe) => {
      try {
        const [Te, Me, Ue] = await JRPCEngine._runAllMiddleware(t, Ie, this._middleware);
        return Me ? (await JRPCEngine._runReturnHandlers(Ue), Pe(Te)) : Be(async (je) => {
          try {
            await JRPCEngine._runReturnHandlers(Ue);
          } catch (fn) {
            return je(fn);
          }
          return je();
        });
      } catch (Te) {
        return Pe(Te);
      }
    };
  }
  /**
   * Like _handle, but for batch requests.
   */
  /**
   * Like _handle, but for batch requests.
   */
  async _handleBatch(t, Ie) {
    try {
      const Be = await Promise.all(
        // 1. Begin executing each request in the order received
        t.map(this._promiseHandle.bind(this))
      );
      return Ie ? Ie(null, Be) : Be;
    } catch (Be) {
      if (Ie)
        return Ie(Be);
      throw Be;
    }
  }
  /**
   * A promise-wrapped _handle.
   */
  _promiseHandle(t) {
    return new Promise((Ie, Be) => {
      this._handle(t, (Pe, Te) => {
        Pe && Te === void 0 ? Be(Pe) : Ie(Te);
      }).catch(Be);
    });
  }
  /**
   * Ensures that the request object is valid, processes it, and passes any
   * error and the response object to the given callback.
   *
   * Does not reject.
   */
  async _handle(t, Ie) {
    if (!t || Array.isArray(t) || typeof t != "object") {
      const fi = new SerializableError({
        code: -32603,
        message: "request must be plain object"
      });
      return Ie(fi, {
        id: void 0,
        jsonrpc: "2.0",
        error: fi
      });
    }
    if (typeof t.method != "string") {
      const fi = new SerializableError({
        code: -32603,
        message: "method must be string"
      });
      return Ie(fi, {
        id: t.id,
        jsonrpc: "2.0",
        error: fi
      });
    }
    const Be = _objectSpread2({}, t), Pe = {
      id: Be.id,
      jsonrpc: Be.jsonrpc
    };
    let Te = null;
    try {
      await this._processRequest(Be, Pe);
    } catch (fi) {
      Te = fi;
    }
    if (Te && (delete Pe.result, !Pe.error)) {
      var Me, Ue, je, fn, Ve, vn, En;
      typeof Te == "object" && Object.keys(Te).includes("stack") === !1 && (Te.stack = "Stack trace is not available."), Pe.error = serializeError(Te, {
        shouldIncludeStack: !0,
        fallbackError: {
          message: ((Me = Te) === null || Me === void 0 ? void 0 : Me.message) || ((Ue = Te) === null || Ue === void 0 ? void 0 : Ue.toString()),
          code: ((je = Te) === null || je === void 0 ? void 0 : je.code) || -32603,
          stack: ((fn = Te) === null || fn === void 0 ? void 0 : fn.stack) || "Stack trace is not available.",
          data: ((Ve = Te) === null || Ve === void 0 ? void 0 : Ve.data) || ((vn = Te) === null || vn === void 0 ? void 0 : vn.message) || ((En = Te) === null || En === void 0 ? void 0 : En.toString())
        }
      });
    }
    return Ie(Te, Pe);
  }
  /**
   * For the given request and response, runs all middleware and their return
   * handlers, if any, and ensures that internal request processing semantics
   * are satisfied.
   */
  async _processRequest(t, Ie) {
    const [Be, Pe, Te] = await JRPCEngine._runAllMiddleware(t, Ie, this._middleware);
    if (JRPCEngine._checkForCompletion(t, Ie, Pe), await JRPCEngine._runReturnHandlers(Te), Be)
      throw Be;
  }
}
function mergeMiddleware(Ae) {
  const t = new JRPCEngine();
  return Ae.forEach((Ie) => {
    t.push(Ie);
  }), t.asMiddleware();
}
function providerFromEngine(Ae) {
  const t = new SafeEventEmitter();
  return t.sendAsync = async (Ie) => {
    const Be = await Ae.handle(Ie);
    if (Be.error) {
      var Pe, Te, Me, Ue, je, fn, Ve;
      typeof Be.error == "object" && Object.keys(Be.error).includes("stack") === !1 && (Be.error.stack = "Stack trace is not available.");
      const vn = serializeError(Be.error, {
        fallbackError: {
          message: ((Pe = Be.error) === null || Pe === void 0 ? void 0 : Pe.message) || ((Te = Be.error) === null || Te === void 0 ? void 0 : Te.toString()),
          code: ((Me = Be.error) === null || Me === void 0 ? void 0 : Me.code) || -32603,
          stack: ((Ue = Be.error) === null || Ue === void 0 ? void 0 : Ue.stack) || "Stack trace is not available.",
          data: ((je = Be.error) === null || je === void 0 ? void 0 : je.data) || ((fn = Be.error) === null || fn === void 0 ? void 0 : fn.message) || ((Ve = Be.error) === null || Ve === void 0 ? void 0 : Ve.toString())
        },
        shouldIncludeStack: !0
      });
      throw rpcErrors.internal(vn);
    }
    return Be.result;
  }, t.send = (Ie, Be) => {
    if (typeof Be != "function")
      throw new Error('Must provide callback to "send" method.');
    Ae.handle(Ie, Be);
  }, Ae.on && Ae.on("notification", (Ie) => {
    t.emit("data", null, Ie);
  }), t.request = async (Ie) => {
    const Be = _objectSpread2(_objectSpread2({}, Ie), {}, {
      id: Math.random().toString(36).slice(2),
      jsonrpc: "2.0"
    });
    return await t.sendAsync(Be);
  }, t;
}
function isHexString$2(Ae, t) {
  return !(typeof Ae != "string" || !Ae.match(/^0x[0-9A-Fa-f]*$/));
}
const stripHexPrefix = (Ae) => {
  if (typeof Ae != "string")
    throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof Ae}`);
  return isHexString$2(Ae) ? Ae.slice(2) : Ae;
};
function padToEven(Ae) {
  let t = Ae;
  if (typeof t != "string")
    throw new Error(`[padToEven] value must be type 'string', received ${typeof t}`);
  return t.length % 2 && (t = `0${t}`), t;
}
const assertIsBytes = function(Ae) {
  if (!(Ae instanceof Uint8Array)) {
    const t = `This method only supports Uint8Array but input was: ${Ae}`;
    throw new Error(t);
  }
}, assertIsString = function(Ae) {
  if (typeof Ae != "string") {
    const t = `This method only supports strings but input was: ${Ae}`;
    throw new Error(t);
  }
}, BIGINT_0 = BigInt(0), hexToBytesMapFirstKey = {}, hexToBytesMapSecondKey = {};
for (let Ae = 0; Ae < 16; Ae++) {
  const t = Ae, Ie = Ae * 16, Be = Ae.toString(16).toLowerCase();
  hexToBytesMapSecondKey[Be] = t, hexToBytesMapSecondKey[Be.toUpperCase()] = t, hexToBytesMapFirstKey[Be] = Ie, hexToBytesMapFirstKey[Be.toUpperCase()] = Ie;
}
function _unprefixedHexToBytes(Ae) {
  const t = Ae.length, Ie = new Uint8Array(t / 2);
  for (let Be = 0; Be < t; Be += 2)
    Ie[Be / 2] = hexToBytesMapFirstKey[Ae[Be]] + hexToBytesMapSecondKey[Ae[Be + 1]];
  return Ie;
}
const unprefixedHexToBytes = (Ae) => {
  if (Ae.slice(0, 2) === "0x")
    throw new Error("hex string is prefixed with 0x, should be unprefixed");
  return _unprefixedHexToBytes(padToEven(Ae));
}, hexByByte = Array.from({ length: 256 }, (Ae, t) => t.toString(16).padStart(2, "0")), bytesToHex$3 = (Ae) => {
  let t = "0x";
  if (Ae === void 0 || Ae.length === 0)
    return t;
  for (const Ie of Ae)
    t = `${t}${hexByByte[Ie]}`;
  return t;
}, BIGINT_CACHE = [];
for (let Ae = 0; Ae <= 256 * 256 - 1; Ae++)
  BIGINT_CACHE[Ae] = BigInt(Ae);
const bytesToBigInt$1 = (Ae, t = !1) => {
  t && Ae.reverse();
  const Ie = bytesToHex$3(Ae);
  return Ie === "0x" ? BIGINT_0 : Ie.length === 4 ? BIGINT_CACHE[Ae[0]] : Ie.length === 6 ? BIGINT_CACHE[Ae[0] * 256 + Ae[1]] : BigInt(Ie);
}, hexToBytes$3 = (Ae) => {
  if (typeof Ae != "string")
    throw new Error(`hex argument type ${typeof Ae} must be of type string`);
  if (!/^0x[0-9a-fA-F]*$/.test(Ae))
    throw new Error(`Input must be a 0x-prefixed hexadecimal string, got ${Ae}`);
  const t = Ae.slice(2);
  return _unprefixedHexToBytes(t.length % 2 === 0 ? t : padToEven(t));
}, intToHex = (Ae) => {
  if (!Number.isSafeInteger(Ae) || Ae < 0)
    throw new Error(`Received an invalid integer type: ${Ae}`);
  return `0x${Ae.toString(16)}`;
}, intToBytes = (Ae) => {
  const t = intToHex(Ae);
  return hexToBytes$3(t);
}, bigIntToBytes = (Ae, t = !1) => {
  const Ie = toBytes$3(`0x${padToEven(Ae.toString(16))}`);
  return t ? Ie.reverse() : Ie;
}, toBytes$3 = (Ae) => {
  if (Ae == null)
    return new Uint8Array();
  if (Array.isArray(Ae) || Ae instanceof Uint8Array)
    return Uint8Array.from(Ae);
  if (typeof Ae == "string") {
    if (!isHexString$2(Ae))
      throw new Error(`Cannot convert string to Uint8Array. toBytes only supports 0x-prefixed hex strings and this string was given: ${Ae}`);
    return hexToBytes$3(Ae);
  }
  if (typeof Ae == "number")
    return intToBytes(Ae);
  if (typeof Ae == "bigint") {
    if (Ae < BIGINT_0)
      throw new Error(`Cannot convert negative bigint to Uint8Array. Given: ${Ae}`);
    let t = Ae.toString(16);
    return t.length % 2 && (t = "0" + t), unprefixedHexToBytes(t);
  }
  if (Ae.toBytes !== void 0)
    return Ae.toBytes();
  throw new Error("invalid type");
}, fromSigned = (Ae) => BigInt.asIntN(256, bytesToBigInt$1(Ae)), toUnsigned = (Ae) => bigIntToBytes(BigInt.asUintN(256, Ae)), addHexPrefix = (Ae) => typeof Ae != "string" || isHexString$2(Ae) ? Ae : `0x${Ae}`, bigIntToHex = (Ae) => `0x${Ae.toString(16)}`;
BigInt("0xffffffffffffffff");
BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935");
secp256k1$5.CURVE.n;
secp256k1$5.CURVE.n / BigInt(2);
BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
const KECCAK256_NULL_S = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
hexToBytes$3(KECCAK256_NULL_S);
const KECCAK256_RLP_ARRAY_S = "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
hexToBytes$3(KECCAK256_RLP_ARRAY_S);
const KECCAK256_RLP_S = "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
hexToBytes$3(KECCAK256_RLP_S);
Uint8Array.from([128]);
BigInt(-1);
BigInt(0);
BigInt(1);
BigInt(2);
BigInt(3);
BigInt(7);
BigInt(8);
BigInt(27);
BigInt(28);
BigInt(31);
BigInt(32);
BigInt(64);
BigInt(128);
BigInt(255);
BigInt(256);
BigInt(96);
BigInt(100);
BigInt(160);
BigInt(224);
BigInt(7922816251426434e13);
BigInt(1461501637330903e33);
BigInt(2695994666715064e52);
BigInt(1e9);
Array.from({ length: 256 }, (Ae, t) => t.toString(16).padStart(2, "0"));
const isValidAddress = function(Ae) {
  try {
    assertIsString(Ae);
  } catch {
    return !1;
  }
  return /^0x[0-9a-fA-F]{40}$/.test(Ae);
}, pubToAddress = function(Ae, t = !1) {
  if (assertIsBytes(Ae), t && Ae.length !== 64 && (Ae = secp256k1$5.ProjectivePoint.fromHex(Ae).toRawBytes(!1).slice(1)), Ae.length !== 64)
    throw new Error("Expected pubKey to be of length 64");
  return keccak256$3(Ae).subarray(-20);
}, publicToAddress = pubToAddress;
var KeyEncoding;
(function(Ae) {
  Ae.String = "string", Ae.Bytes = "view", Ae.Number = "number";
})(KeyEncoding || (KeyEncoding = {}));
var ValueEncoding;
(function(Ae) {
  Ae.String = "string", Ae.Bytes = "view", Ae.JSON = "json";
})(ValueEncoding || (ValueEncoding = {}));
var TypeOutput;
(function(Ae) {
  Ae[Ae.Number = 0] = "Number", Ae[Ae.BigInt = 1] = "BigInt", Ae[Ae.Uint8Array = 2] = "Uint8Array", Ae[Ae.PrefixedHexString = 3] = "PrefixedHexString";
})(TypeOutput || (TypeOutput = {}));
var CLRequestType;
(function(Ae) {
  Ae[Ae.Deposit = 0] = "Deposit", Ae[Ae.Withdrawal = 1] = "Withdrawal", Ae[Ae.Consolidation = 2] = "Consolidation";
})(CLRequestType || (CLRequestType = {}));
var VerkleLeafType;
(function(Ae) {
  Ae[Ae.Version = 0] = "Version", Ae[Ae.Balance = 1] = "Balance", Ae[Ae.Nonce = 2] = "Nonce", Ae[Ae.CodeHash = 3] = "CodeHash", Ae[Ae.CodeSize = 4] = "CodeSize";
})(VerkleLeafType || (VerkleLeafType = {}));
intToBytes(VerkleLeafType.Version);
intToBytes(VerkleLeafType.Balance);
intToBytes(VerkleLeafType.Nonce);
intToBytes(VerkleLeafType.CodeHash);
intToBytes(VerkleLeafType.CodeSize);
BigInt(256) ** BigInt(31);
class BaseController extends SafeEventEmitter {
  /**
   * Creates a BaseController instance. Both initial state and initial
   * configuration options are merged with defaults upon initialization.
   *
   * @param config - Initial options used to configure this controller
   * @param state - Initial state to set on this controller
   */
  constructor({
    config: t = {},
    state: Ie = {}
  }) {
    super(), _defineProperty(this, "defaultConfig", {}), _defineProperty(this, "defaultState", {}), _defineProperty(this, "disabled", !1), _defineProperty(this, "name", "BaseController"), _defineProperty(this, "initialConfig", void 0), _defineProperty(this, "initialState", void 0), _defineProperty(this, "internalConfig", this.defaultConfig), _defineProperty(this, "internalState", this.defaultState), this.initialState = Ie, this.initialConfig = t;
  }
  /**
   * Retrieves current controller configuration options
   *
   * @returns - Current configuration
   */
  get config() {
    return this.internalConfig;
  }
  /**
   * Retrieves current controller state
   *
   * @returns - Current state
   */
  get state() {
    return this.internalState;
  }
  /**
   * Updates controller configuration
   *
   * @param config - New configuration options
   * @param overwrite - Overwrite config instead of merging
   * @param fullUpdate - Boolean that defines if the update is partial or not
   */
  configure(t, Ie = !1, Be = !0) {
    if (Be) {
      this.internalConfig = Ie ? t : Object.assign(this.internalConfig, t);
      for (const Pe in this.internalConfig)
        typeof this.internalConfig[Pe] < "u" && (this[Pe] = this.internalConfig[Pe]);
    } else
      for (const Pe in t)
        typeof this.internalConfig[Pe] < "u" && (this.internalConfig[Pe] = t[Pe], this[Pe] = t[Pe]);
  }
  /**
   * Updates controller state
   *
   * @param state - New state
   * @param overwrite - Overwrite state instead of merging
   */
  update(t, Ie = !1) {
    this.internalState = _objectSpread2(Ie ? {} : _objectSpread2({}, this.internalState), t), this.emit("store", this.internalState);
  }
  /**
   * Enables the controller. This sets each config option as a member
   * variable on this instance and triggers any defined setters. This
   * also sets initial state and triggers any listeners.
   *
   * @returns - This controller instance
   */
  initialize() {
    return this.internalState = this.defaultState, this.internalConfig = this.defaultConfig, this.configure(this.initialConfig), this.update(this.initialState), this;
  }
}
const filterNoop = () => !0, internalEvents = ["newListener", "removeListener"], externalEventFilter = (Ae) => !internalEvents.includes(Ae);
function getRawListeners(Ae, t) {
  return typeof Ae.rawListeners < "u" ? Ae.rawListeners(t) : Ae.listeners(t);
}
function createEventEmitterProxy(Ae, t) {
  let Be = {}.eventFilter || filterNoop;
  if (typeof Be == "string" && Be === "skipInternal" && (Be = externalEventFilter), typeof Be != "function") throw new Error("createEventEmitterProxy - Invalid eventFilter");
  let Pe = Ae, Te = (Ue) => {
    if (Pe === Ue) return;
    const je = Pe;
    Pe = Ue, je.eventNames().filter(Be).forEach((Ve) => {
      getRawListeners(je, Ve).forEach((vn) => {
        Ue.on(Ve, vn);
      });
    }), je.removeAllListeners();
  };
  return new Proxy({}, {
    get: (Ue, je) => je === "setTarget" ? Te : Pe[je],
    set: (Ue, je, fn) => je === "setTarget" ? (Te = fn, !0) : (Pe[je] = fn, !0)
  });
}
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER$1 = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(Ae) {
  var t, Ie, Be, Pe = Si.prototype = { constructor: Si, toString: null, valueOf: null }, Te = new Si(1), Me = 20, Ue = 4, je = -7, fn = 21, Ve = -1e7, vn = 1e7, En = !1, fi = 1, bi = 0, mi = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, _i = "0123456789abcdefghijklmnopqrstuvwxyz", Ei = !0;
  function Si(Bi, ji) {
    var Zi, zi, xi, $i, vi, wi, Ai, Ri, Ti = this;
    if (!(Ti instanceof Si)) return new Si(Bi, ji);
    if (ji == null) {
      if (Bi && Bi._isBigNumber === !0) {
        Ti.s = Bi.s, !Bi.c || Bi.e > vn ? Ti.c = Ti.e = null : Bi.e < Ve ? Ti.c = [Ti.e = 0] : (Ti.e = Bi.e, Ti.c = Bi.c.slice());
        return;
      }
      if ((wi = typeof Bi == "number") && Bi * 0 == 0) {
        if (Ti.s = 1 / Bi < 0 ? (Bi = -Bi, -1) : 1, Bi === ~~Bi) {
          for ($i = 0, vi = Bi; vi >= 10; vi /= 10, $i++) ;
          $i > vn ? Ti.c = Ti.e = null : (Ti.e = $i, Ti.c = [Bi]);
          return;
        }
        Ri = String(Bi);
      } else {
        if (!isNumeric.test(Ri = String(Bi))) return Be(Ti, Ri, wi);
        Ti.s = Ri.charCodeAt(0) == 45 ? (Ri = Ri.slice(1), -1) : 1;
      }
      ($i = Ri.indexOf(".")) > -1 && (Ri = Ri.replace(".", "")), (vi = Ri.search(/e/i)) > 0 ? ($i < 0 && ($i = vi), $i += +Ri.slice(vi + 1), Ri = Ri.substring(0, vi)) : $i < 0 && ($i = Ri.length);
    } else {
      if (intCheck(ji, 2, _i.length, "Base"), ji == 10 && Ei)
        return Ti = new Si(Bi), Ui(Ti, Me + Ti.e + 1, Ue);
      if (Ri = String(Bi), wi = typeof Bi == "number") {
        if (Bi * 0 != 0) return Be(Ti, Ri, wi, ji);
        if (Ti.s = 1 / Bi < 0 ? (Ri = Ri.slice(1), -1) : 1, Si.DEBUG && Ri.replace(/^0\.0*|\./, "").length > 15)
          throw Error(tooManyDigits + Bi);
      } else
        Ti.s = Ri.charCodeAt(0) === 45 ? (Ri = Ri.slice(1), -1) : 1;
      for (Zi = _i.slice(0, ji), $i = vi = 0, Ai = Ri.length; vi < Ai; vi++)
        if (Zi.indexOf(zi = Ri.charAt(vi)) < 0) {
          if (zi == ".") {
            if (vi > $i) {
              $i = Ai;
              continue;
            }
          } else if (!xi && (Ri == Ri.toUpperCase() && (Ri = Ri.toLowerCase()) || Ri == Ri.toLowerCase() && (Ri = Ri.toUpperCase()))) {
            xi = !0, vi = -1, $i = 0;
            continue;
          }
          return Be(Ti, String(Bi), wi, ji);
        }
      wi = !1, Ri = Ie(Ri, ji, 10, Ti.s), ($i = Ri.indexOf(".")) > -1 ? Ri = Ri.replace(".", "") : $i = Ri.length;
    }
    for (vi = 0; Ri.charCodeAt(vi) === 48; vi++) ;
    for (Ai = Ri.length; Ri.charCodeAt(--Ai) === 48; ) ;
    if (Ri = Ri.slice(vi, ++Ai)) {
      if (Ai -= vi, wi && Si.DEBUG && Ai > 15 && (Bi > MAX_SAFE_INTEGER$1 || Bi !== mathfloor(Bi)))
        throw Error(tooManyDigits + Ti.s * Bi);
      if (($i = $i - vi - 1) > vn)
        Ti.c = Ti.e = null;
      else if ($i < Ve)
        Ti.c = [Ti.e = 0];
      else {
        if (Ti.e = $i, Ti.c = [], vi = ($i + 1) % LOG_BASE, $i < 0 && (vi += LOG_BASE), vi < Ai) {
          for (vi && Ti.c.push(+Ri.slice(0, vi)), Ai -= LOG_BASE; vi < Ai; )
            Ti.c.push(+Ri.slice(vi, vi += LOG_BASE));
          vi = LOG_BASE - (Ri = Ri.slice(vi)).length;
        } else
          vi -= Ai;
        for (; vi--; Ri += "0") ;
        Ti.c.push(+Ri);
      }
    } else
      Ti.c = [Ti.e = 0];
  }
  Si.clone = clone, Si.ROUND_UP = 0, Si.ROUND_DOWN = 1, Si.ROUND_CEIL = 2, Si.ROUND_FLOOR = 3, Si.ROUND_HALF_UP = 4, Si.ROUND_HALF_DOWN = 5, Si.ROUND_HALF_EVEN = 6, Si.ROUND_HALF_CEIL = 7, Si.ROUND_HALF_FLOOR = 8, Si.EUCLID = 9, Si.config = Si.set = function(Bi) {
    var ji, Zi;
    if (Bi != null)
      if (typeof Bi == "object") {
        if (Bi.hasOwnProperty(ji = "DECIMAL_PLACES") && (Zi = Bi[ji], intCheck(Zi, 0, MAX, ji), Me = Zi), Bi.hasOwnProperty(ji = "ROUNDING_MODE") && (Zi = Bi[ji], intCheck(Zi, 0, 8, ji), Ue = Zi), Bi.hasOwnProperty(ji = "EXPONENTIAL_AT") && (Zi = Bi[ji], Zi && Zi.pop ? (intCheck(Zi[0], -MAX, 0, ji), intCheck(Zi[1], 0, MAX, ji), je = Zi[0], fn = Zi[1]) : (intCheck(Zi, -MAX, MAX, ji), je = -(fn = Zi < 0 ? -Zi : Zi))), Bi.hasOwnProperty(ji = "RANGE"))
          if (Zi = Bi[ji], Zi && Zi.pop)
            intCheck(Zi[0], -MAX, -1, ji), intCheck(Zi[1], 1, MAX, ji), Ve = Zi[0], vn = Zi[1];
          else if (intCheck(Zi, -MAX, MAX, ji), Zi)
            Ve = -(vn = Zi < 0 ? -Zi : Zi);
          else
            throw Error(bignumberError + ji + " cannot be zero: " + Zi);
        if (Bi.hasOwnProperty(ji = "CRYPTO"))
          if (Zi = Bi[ji], Zi === !!Zi)
            if (Zi)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                En = Zi;
              else
                throw En = !Zi, Error(bignumberError + "crypto unavailable");
            else
              En = Zi;
          else
            throw Error(bignumberError + ji + " not true or false: " + Zi);
        if (Bi.hasOwnProperty(ji = "MODULO_MODE") && (Zi = Bi[ji], intCheck(Zi, 0, 9, ji), fi = Zi), Bi.hasOwnProperty(ji = "POW_PRECISION") && (Zi = Bi[ji], intCheck(Zi, 0, MAX, ji), bi = Zi), Bi.hasOwnProperty(ji = "FORMAT"))
          if (Zi = Bi[ji], typeof Zi == "object") mi = Zi;
          else throw Error(bignumberError + ji + " not an object: " + Zi);
        if (Bi.hasOwnProperty(ji = "ALPHABET"))
          if (Zi = Bi[ji], typeof Zi == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(Zi))
            Ei = Zi.slice(0, 10) == "0123456789", _i = Zi;
          else
            throw Error(bignumberError + ji + " invalid: " + Zi);
      } else
        throw Error(bignumberError + "Object expected: " + Bi);
    return {
      DECIMAL_PLACES: Me,
      ROUNDING_MODE: Ue,
      EXPONENTIAL_AT: [je, fn],
      RANGE: [Ve, vn],
      CRYPTO: En,
      MODULO_MODE: fi,
      POW_PRECISION: bi,
      FORMAT: mi,
      ALPHABET: _i
    };
  }, Si.isBigNumber = function(Bi) {
    if (!Bi || Bi._isBigNumber !== !0) return !1;
    if (!Si.DEBUG) return !0;
    var ji, Zi, zi = Bi.c, xi = Bi.e, $i = Bi.s;
    e: if ({}.toString.call(zi) == "[object Array]") {
      if (($i === 1 || $i === -1) && xi >= -MAX && xi <= MAX && xi === mathfloor(xi)) {
        if (zi[0] === 0) {
          if (xi === 0 && zi.length === 1) return !0;
          break e;
        }
        if (ji = (xi + 1) % LOG_BASE, ji < 1 && (ji += LOG_BASE), String(zi[0]).length == ji) {
          for (ji = 0; ji < zi.length; ji++)
            if (Zi = zi[ji], Zi < 0 || Zi >= BASE || Zi !== mathfloor(Zi)) break e;
          if (Zi !== 0) return !0;
        }
      }
    } else if (zi === null && xi === null && ($i === null || $i === 1 || $i === -1))
      return !0;
    throw Error(bignumberError + "Invalid BigNumber: " + Bi);
  }, Si.maximum = Si.max = function() {
    return Oi(arguments, -1);
  }, Si.minimum = Si.min = function() {
    return Oi(arguments, 1);
  }, Si.random = function() {
    var Bi = 9007199254740992, ji = Math.random() * Bi & 2097151 ? function() {
      return mathfloor(Math.random() * Bi);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(Zi) {
      var zi, xi, $i, vi, wi, Ai = 0, Ri = [], Ti = new Si(Te);
      if (Zi == null ? Zi = Me : intCheck(Zi, 0, MAX), vi = mathceil(Zi / LOG_BASE), En)
        if (crypto.getRandomValues) {
          for (zi = crypto.getRandomValues(new Uint32Array(vi *= 2)); Ai < vi; )
            wi = zi[Ai] * 131072 + (zi[Ai + 1] >>> 11), wi >= 9e15 ? (xi = crypto.getRandomValues(new Uint32Array(2)), zi[Ai] = xi[0], zi[Ai + 1] = xi[1]) : (Ri.push(wi % 1e14), Ai += 2);
          Ai = vi / 2;
        } else if (crypto.randomBytes) {
          for (zi = crypto.randomBytes(vi *= 7); Ai < vi; )
            wi = (zi[Ai] & 31) * 281474976710656 + zi[Ai + 1] * 1099511627776 + zi[Ai + 2] * 4294967296 + zi[Ai + 3] * 16777216 + (zi[Ai + 4] << 16) + (zi[Ai + 5] << 8) + zi[Ai + 6], wi >= 9e15 ? crypto.randomBytes(7).copy(zi, Ai) : (Ri.push(wi % 1e14), Ai += 7);
          Ai = vi / 7;
        } else
          throw En = !1, Error(bignumberError + "crypto unavailable");
      if (!En)
        for (; Ai < vi; )
          wi = ji(), wi < 9e15 && (Ri[Ai++] = wi % 1e14);
      for (vi = Ri[--Ai], Zi %= LOG_BASE, vi && Zi && (wi = POWS_TEN[LOG_BASE - Zi], Ri[Ai] = mathfloor(vi / wi) * wi); Ri[Ai] === 0; Ri.pop(), Ai--) ;
      if (Ai < 0)
        Ri = [$i = 0];
      else {
        for ($i = -1; Ri[0] === 0; Ri.splice(0, 1), $i -= LOG_BASE) ;
        for (Ai = 1, wi = Ri[0]; wi >= 10; wi /= 10, Ai++) ;
        Ai < LOG_BASE && ($i -= LOG_BASE - Ai);
      }
      return Ti.e = $i, Ti.c = Ri, Ti;
    };
  }(), Si.sum = function() {
    for (var Bi = 1, ji = arguments, Zi = new Si(ji[0]); Bi < ji.length; ) Zi = Zi.plus(ji[Bi++]);
    return Zi;
  }, Ie = /* @__PURE__ */ function() {
    var Bi = "0123456789";
    function ji(Zi, zi, xi, $i) {
      for (var vi, wi = [0], Ai, Ri = 0, Ti = Zi.length; Ri < Ti; ) {
        for (Ai = wi.length; Ai--; wi[Ai] *= zi) ;
        for (wi[0] += $i.indexOf(Zi.charAt(Ri++)), vi = 0; vi < wi.length; vi++)
          wi[vi] > xi - 1 && (wi[vi + 1] == null && (wi[vi + 1] = 0), wi[vi + 1] += wi[vi] / xi | 0, wi[vi] %= xi);
      }
      return wi.reverse();
    }
    return function(Zi, zi, xi, $i, vi) {
      var wi, Ai, Ri, Ti, Ci, Ii, Li, Ni, Vi = Zi.indexOf("."), is = Me, Ki = Ue;
      for (Vi >= 0 && (Ti = bi, bi = 0, Zi = Zi.replace(".", ""), Ni = new Si(zi), Ii = Ni.pow(Zi.length - Vi), bi = Ti, Ni.c = ji(
        toFixedPoint(coeffToString(Ii.c), Ii.e, "0"),
        10,
        xi,
        Bi
      ), Ni.e = Ni.c.length), Li = ji(Zi, zi, xi, vi ? (wi = _i, Bi) : (wi = Bi, _i)), Ri = Ti = Li.length; Li[--Ti] == 0; Li.pop()) ;
      if (!Li[0]) return wi.charAt(0);
      if (Vi < 0 ? --Ri : (Ii.c = Li, Ii.e = Ri, Ii.s = $i, Ii = t(Ii, Ni, is, Ki, xi), Li = Ii.c, Ci = Ii.r, Ri = Ii.e), Ai = Ri + is + 1, Vi = Li[Ai], Ti = xi / 2, Ci = Ci || Ai < 0 || Li[Ai + 1] != null, Ci = Ki < 4 ? (Vi != null || Ci) && (Ki == 0 || Ki == (Ii.s < 0 ? 3 : 2)) : Vi > Ti || Vi == Ti && (Ki == 4 || Ci || Ki == 6 && Li[Ai - 1] & 1 || Ki == (Ii.s < 0 ? 8 : 7)), Ai < 1 || !Li[0])
        Zi = Ci ? toFixedPoint(wi.charAt(1), -is, wi.charAt(0)) : wi.charAt(0);
      else {
        if (Li.length = Ai, Ci)
          for (--xi; ++Li[--Ai] > xi; )
            Li[Ai] = 0, Ai || (++Ri, Li = [1].concat(Li));
        for (Ti = Li.length; !Li[--Ti]; ) ;
        for (Vi = 0, Zi = ""; Vi <= Ti; Zi += wi.charAt(Li[Vi++])) ;
        Zi = toFixedPoint(Zi, Ri, wi.charAt(0));
      }
      return Zi;
    };
  }(), t = /* @__PURE__ */ function() {
    function Bi(zi, xi, $i) {
      var vi, wi, Ai, Ri, Ti = 0, Ci = zi.length, Ii = xi % SQRT_BASE, Li = xi / SQRT_BASE | 0;
      for (zi = zi.slice(); Ci--; )
        Ai = zi[Ci] % SQRT_BASE, Ri = zi[Ci] / SQRT_BASE | 0, vi = Li * Ai + Ri * Ii, wi = Ii * Ai + vi % SQRT_BASE * SQRT_BASE + Ti, Ti = (wi / $i | 0) + (vi / SQRT_BASE | 0) + Li * Ri, zi[Ci] = wi % $i;
      return Ti && (zi = [Ti].concat(zi)), zi;
    }
    function ji(zi, xi, $i, vi) {
      var wi, Ai;
      if ($i != vi)
        Ai = $i > vi ? 1 : -1;
      else
        for (wi = Ai = 0; wi < $i; wi++)
          if (zi[wi] != xi[wi]) {
            Ai = zi[wi] > xi[wi] ? 1 : -1;
            break;
          }
      return Ai;
    }
    function Zi(zi, xi, $i, vi) {
      for (var wi = 0; $i--; )
        zi[$i] -= wi, wi = zi[$i] < xi[$i] ? 1 : 0, zi[$i] = wi * vi + zi[$i] - xi[$i];
      for (; !zi[0] && zi.length > 1; zi.splice(0, 1)) ;
    }
    return function(zi, xi, $i, vi, wi) {
      var Ai, Ri, Ti, Ci, Ii, Li, Ni, Vi, is, Ki, ts, qi, Hi, Xi, ki, Wi, Yi, Qi = zi.s == xi.s ? 1 : -1, ns = zi.c, us = xi.c;
      if (!ns || !ns[0] || !us || !us[0])
        return new Si(
          // Return NaN if either NaN, or both Infinity or 0.
          !zi.s || !xi.s || (ns ? us && ns[0] == us[0] : !us) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            ns && ns[0] == 0 || !us ? Qi * 0 : Qi / 0
          )
        );
      for (Vi = new Si(Qi), is = Vi.c = [], Ri = zi.e - xi.e, Qi = $i + Ri + 1, wi || (wi = BASE, Ri = bitFloor(zi.e / LOG_BASE) - bitFloor(xi.e / LOG_BASE), Qi = Qi / LOG_BASE | 0), Ti = 0; us[Ti] == (ns[Ti] || 0); Ti++) ;
      if (us[Ti] > (ns[Ti] || 0) && Ri--, Qi < 0)
        is.push(1), Ci = !0;
      else {
        for (Xi = ns.length, Wi = us.length, Ti = 0, Qi += 2, Ii = mathfloor(wi / (us[0] + 1)), Ii > 1 && (us = Bi(us, Ii, wi), ns = Bi(ns, Ii, wi), Wi = us.length, Xi = ns.length), Hi = Wi, Ki = ns.slice(0, Wi), ts = Ki.length; ts < Wi; Ki[ts++] = 0) ;
        Yi = us.slice(), Yi = [0].concat(Yi), ki = us[0], us[1] >= wi / 2 && ki++;
        do {
          if (Ii = 0, Ai = ji(us, Ki, Wi, ts), Ai < 0) {
            if (qi = Ki[0], Wi != ts && (qi = qi * wi + (Ki[1] || 0)), Ii = mathfloor(qi / ki), Ii > 1)
              for (Ii >= wi && (Ii = wi - 1), Li = Bi(us, Ii, wi), Ni = Li.length, ts = Ki.length; ji(Li, Ki, Ni, ts) == 1; )
                Ii--, Zi(Li, Wi < Ni ? Yi : us, Ni, wi), Ni = Li.length, Ai = 1;
            else
              Ii == 0 && (Ai = Ii = 1), Li = us.slice(), Ni = Li.length;
            if (Ni < ts && (Li = [0].concat(Li)), Zi(Ki, Li, ts, wi), ts = Ki.length, Ai == -1)
              for (; ji(us, Ki, Wi, ts) < 1; )
                Ii++, Zi(Ki, Wi < ts ? Yi : us, ts, wi), ts = Ki.length;
          } else Ai === 0 && (Ii++, Ki = [0]);
          is[Ti++] = Ii, Ki[0] ? Ki[ts++] = ns[Hi] || 0 : (Ki = [ns[Hi]], ts = 1);
        } while ((Hi++ < Xi || Ki[0] != null) && Qi--);
        Ci = Ki[0] != null, is[0] || is.splice(0, 1);
      }
      if (wi == BASE) {
        for (Ti = 1, Qi = is[0]; Qi >= 10; Qi /= 10, Ti++) ;
        Ui(Vi, $i + (Vi.e = Ti + Ri * LOG_BASE - 1) + 1, vi, Ci);
      } else
        Vi.e = Ri, Vi.r = +Ci;
      return Vi;
    };
  }();
  function Mi(Bi, ji, Zi, zi) {
    var xi, $i, vi, wi, Ai;
    if (Zi == null ? Zi = Ue : intCheck(Zi, 0, 8), !Bi.c) return Bi.toString();
    if (xi = Bi.c[0], vi = Bi.e, ji == null)
      Ai = coeffToString(Bi.c), Ai = zi == 1 || zi == 2 && (vi <= je || vi >= fn) ? toExponential(Ai, vi) : toFixedPoint(Ai, vi, "0");
    else if (Bi = Ui(new Si(Bi), ji, Zi), $i = Bi.e, Ai = coeffToString(Bi.c), wi = Ai.length, zi == 1 || zi == 2 && (ji <= $i || $i <= je)) {
      for (; wi < ji; Ai += "0", wi++) ;
      Ai = toExponential(Ai, $i);
    } else if (ji -= vi, Ai = toFixedPoint(Ai, $i, "0"), $i + 1 > wi) {
      if (--ji > 0) for (Ai += "."; ji--; Ai += "0") ;
    } else if (ji += $i - wi, ji > 0)
      for ($i + 1 == wi && (Ai += "."); ji--; Ai += "0") ;
    return Bi.s < 0 && xi ? "-" + Ai : Ai;
  }
  function Oi(Bi, ji) {
    for (var Zi, zi, xi = 1, $i = new Si(Bi[0]); xi < Bi.length; xi++)
      zi = new Si(Bi[xi]), (!zi.s || (Zi = compare$1($i, zi)) === ji || Zi === 0 && $i.s === ji) && ($i = zi);
    return $i;
  }
  function Fi(Bi, ji, Zi) {
    for (var zi = 1, xi = ji.length; !ji[--xi]; ji.pop()) ;
    for (xi = ji[0]; xi >= 10; xi /= 10, zi++) ;
    return (Zi = zi + Zi * LOG_BASE - 1) > vn ? Bi.c = Bi.e = null : Zi < Ve ? Bi.c = [Bi.e = 0] : (Bi.e = Zi, Bi.c = ji), Bi;
  }
  Be = /* @__PURE__ */ function() {
    var Bi = /^(-?)0([xbo])(?=\w[\w.]*$)/i, ji = /^([^.]+)\.$/, Zi = /^\.([^.]+)$/, zi = /^-?(Infinity|NaN)$/, xi = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function($i, vi, wi, Ai) {
      var Ri, Ti = wi ? vi : vi.replace(xi, "");
      if (zi.test(Ti))
        $i.s = isNaN(Ti) ? null : Ti < 0 ? -1 : 1;
      else {
        if (!wi && (Ti = Ti.replace(Bi, function(Ci, Ii, Li) {
          return Ri = (Li = Li.toLowerCase()) == "x" ? 16 : Li == "b" ? 2 : 8, !Ai || Ai == Ri ? Ii : Ci;
        }), Ai && (Ri = Ai, Ti = Ti.replace(ji, "$1").replace(Zi, "0.$1")), vi != Ti))
          return new Si(Ti, Ri);
        if (Si.DEBUG)
          throw Error(bignumberError + "Not a" + (Ai ? " base " + Ai : "") + " number: " + vi);
        $i.s = null;
      }
      $i.c = $i.e = null;
    };
  }();
  function Ui(Bi, ji, Zi, zi) {
    var xi, $i, vi, wi, Ai, Ri, Ti, Ci = Bi.c, Ii = POWS_TEN;
    if (Ci) {
      e: {
        for (xi = 1, wi = Ci[0]; wi >= 10; wi /= 10, xi++) ;
        if ($i = ji - xi, $i < 0)
          $i += LOG_BASE, vi = ji, Ai = Ci[Ri = 0], Ti = mathfloor(Ai / Ii[xi - vi - 1] % 10);
        else if (Ri = mathceil(($i + 1) / LOG_BASE), Ri >= Ci.length)
          if (zi) {
            for (; Ci.length <= Ri; Ci.push(0)) ;
            Ai = Ti = 0, xi = 1, $i %= LOG_BASE, vi = $i - LOG_BASE + 1;
          } else
            break e;
        else {
          for (Ai = wi = Ci[Ri], xi = 1; wi >= 10; wi /= 10, xi++) ;
          $i %= LOG_BASE, vi = $i - LOG_BASE + xi, Ti = vi < 0 ? 0 : mathfloor(Ai / Ii[xi - vi - 1] % 10);
        }
        if (zi = zi || ji < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        Ci[Ri + 1] != null || (vi < 0 ? Ai : Ai % Ii[xi - vi - 1]), zi = Zi < 4 ? (Ti || zi) && (Zi == 0 || Zi == (Bi.s < 0 ? 3 : 2)) : Ti > 5 || Ti == 5 && (Zi == 4 || zi || Zi == 6 && // Check whether the digit to the left of the rounding digit is odd.
        ($i > 0 ? vi > 0 ? Ai / Ii[xi - vi] : 0 : Ci[Ri - 1]) % 10 & 1 || Zi == (Bi.s < 0 ? 8 : 7)), ji < 1 || !Ci[0])
          return Ci.length = 0, zi ? (ji -= Bi.e + 1, Ci[0] = Ii[(LOG_BASE - ji % LOG_BASE) % LOG_BASE], Bi.e = -ji || 0) : Ci[0] = Bi.e = 0, Bi;
        if ($i == 0 ? (Ci.length = Ri, wi = 1, Ri--) : (Ci.length = Ri + 1, wi = Ii[LOG_BASE - $i], Ci[Ri] = vi > 0 ? mathfloor(Ai / Ii[xi - vi] % Ii[vi]) * wi : 0), zi)
          for (; ; )
            if (Ri == 0) {
              for ($i = 1, vi = Ci[0]; vi >= 10; vi /= 10, $i++) ;
              for (vi = Ci[0] += wi, wi = 1; vi >= 10; vi /= 10, wi++) ;
              $i != wi && (Bi.e++, Ci[0] == BASE && (Ci[0] = 1));
              break;
            } else {
              if (Ci[Ri] += wi, Ci[Ri] != BASE) break;
              Ci[Ri--] = 0, wi = 1;
            }
        for ($i = Ci.length; Ci[--$i] === 0; Ci.pop()) ;
      }
      Bi.e > vn ? Bi.c = Bi.e = null : Bi.e < Ve && (Bi.c = [Bi.e = 0]);
    }
    return Bi;
  }
  function Pi(Bi) {
    var ji, Zi = Bi.e;
    return Zi === null ? Bi.toString() : (ji = coeffToString(Bi.c), ji = Zi <= je || Zi >= fn ? toExponential(ji, Zi) : toFixedPoint(ji, Zi, "0"), Bi.s < 0 ? "-" + ji : ji);
  }
  return Pe.absoluteValue = Pe.abs = function() {
    var Bi = new Si(this);
    return Bi.s < 0 && (Bi.s = 1), Bi;
  }, Pe.comparedTo = function(Bi, ji) {
    return compare$1(this, new Si(Bi, ji));
  }, Pe.decimalPlaces = Pe.dp = function(Bi, ji) {
    var Zi, zi, xi, $i = this;
    if (Bi != null)
      return intCheck(Bi, 0, MAX), ji == null ? ji = Ue : intCheck(ji, 0, 8), Ui(new Si($i), Bi + $i.e + 1, ji);
    if (!(Zi = $i.c)) return null;
    if (zi = ((xi = Zi.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE, xi = Zi[xi]) for (; xi % 10 == 0; xi /= 10, zi--) ;
    return zi < 0 && (zi = 0), zi;
  }, Pe.dividedBy = Pe.div = function(Bi, ji) {
    return t(this, new Si(Bi, ji), Me, Ue);
  }, Pe.dividedToIntegerBy = Pe.idiv = function(Bi, ji) {
    return t(this, new Si(Bi, ji), 0, 1);
  }, Pe.exponentiatedBy = Pe.pow = function(Bi, ji) {
    var Zi, zi, xi, $i, vi, wi, Ai, Ri, Ti, Ci = this;
    if (Bi = new Si(Bi), Bi.c && !Bi.isInteger())
      throw Error(bignumberError + "Exponent not an integer: " + Pi(Bi));
    if (ji != null && (ji = new Si(ji)), wi = Bi.e > 14, !Ci.c || !Ci.c[0] || Ci.c[0] == 1 && !Ci.e && Ci.c.length == 1 || !Bi.c || !Bi.c[0])
      return Ti = new Si(Math.pow(+Pi(Ci), wi ? Bi.s * (2 - isOdd(Bi)) : +Pi(Bi))), ji ? Ti.mod(ji) : Ti;
    if (Ai = Bi.s < 0, ji) {
      if (ji.c ? !ji.c[0] : !ji.s) return new Si(NaN);
      zi = !Ai && Ci.isInteger() && ji.isInteger(), zi && (Ci = Ci.mod(ji));
    } else {
      if (Bi.e > 9 && (Ci.e > 0 || Ci.e < -1 || (Ci.e == 0 ? Ci.c[0] > 1 || wi && Ci.c[1] >= 24e7 : Ci.c[0] < 8e13 || wi && Ci.c[0] <= 9999975e7)))
        return $i = Ci.s < 0 && isOdd(Bi) ? -0 : 0, Ci.e > -1 && ($i = 1 / $i), new Si(Ai ? 1 / $i : $i);
      bi && ($i = mathceil(bi / LOG_BASE + 2));
    }
    for (wi ? (Zi = new Si(0.5), Ai && (Bi.s = 1), Ri = isOdd(Bi)) : (xi = Math.abs(+Pi(Bi)), Ri = xi % 2), Ti = new Si(Te); ; ) {
      if (Ri) {
        if (Ti = Ti.times(Ci), !Ti.c) break;
        $i ? Ti.c.length > $i && (Ti.c.length = $i) : zi && (Ti = Ti.mod(ji));
      }
      if (xi) {
        if (xi = mathfloor(xi / 2), xi === 0) break;
        Ri = xi % 2;
      } else if (Bi = Bi.times(Zi), Ui(Bi, Bi.e + 1, 1), Bi.e > 14)
        Ri = isOdd(Bi);
      else {
        if (xi = +Pi(Bi), xi === 0) break;
        Ri = xi % 2;
      }
      Ci = Ci.times(Ci), $i ? Ci.c && Ci.c.length > $i && (Ci.c.length = $i) : zi && (Ci = Ci.mod(ji));
    }
    return zi ? Ti : (Ai && (Ti = Te.div(Ti)), ji ? Ti.mod(ji) : $i ? Ui(Ti, bi, Ue, vi) : Ti);
  }, Pe.integerValue = function(Bi) {
    var ji = new Si(this);
    return Bi == null ? Bi = Ue : intCheck(Bi, 0, 8), Ui(ji, ji.e + 1, Bi);
  }, Pe.isEqualTo = Pe.eq = function(Bi, ji) {
    return compare$1(this, new Si(Bi, ji)) === 0;
  }, Pe.isFinite = function() {
    return !!this.c;
  }, Pe.isGreaterThan = Pe.gt = function(Bi, ji) {
    return compare$1(this, new Si(Bi, ji)) > 0;
  }, Pe.isGreaterThanOrEqualTo = Pe.gte = function(Bi, ji) {
    return (ji = compare$1(this, new Si(Bi, ji))) === 1 || ji === 0;
  }, Pe.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  }, Pe.isLessThan = Pe.lt = function(Bi, ji) {
    return compare$1(this, new Si(Bi, ji)) < 0;
  }, Pe.isLessThanOrEqualTo = Pe.lte = function(Bi, ji) {
    return (ji = compare$1(this, new Si(Bi, ji))) === -1 || ji === 0;
  }, Pe.isNaN = function() {
    return !this.s;
  }, Pe.isNegative = function() {
    return this.s < 0;
  }, Pe.isPositive = function() {
    return this.s > 0;
  }, Pe.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, Pe.minus = function(Bi, ji) {
    var Zi, zi, xi, $i, vi = this, wi = vi.s;
    if (Bi = new Si(Bi, ji), ji = Bi.s, !wi || !ji) return new Si(NaN);
    if (wi != ji)
      return Bi.s = -ji, vi.plus(Bi);
    var Ai = vi.e / LOG_BASE, Ri = Bi.e / LOG_BASE, Ti = vi.c, Ci = Bi.c;
    if (!Ai || !Ri) {
      if (!Ti || !Ci) return Ti ? (Bi.s = -ji, Bi) : new Si(Ci ? vi : NaN);
      if (!Ti[0] || !Ci[0])
        return Ci[0] ? (Bi.s = -ji, Bi) : new Si(Ti[0] ? vi : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          Ue == 3 ? -0 : 0
        ));
    }
    if (Ai = bitFloor(Ai), Ri = bitFloor(Ri), Ti = Ti.slice(), wi = Ai - Ri) {
      for (($i = wi < 0) ? (wi = -wi, xi = Ti) : (Ri = Ai, xi = Ci), xi.reverse(), ji = wi; ji--; xi.push(0)) ;
      xi.reverse();
    } else
      for (zi = ($i = (wi = Ti.length) < (ji = Ci.length)) ? wi : ji, wi = ji = 0; ji < zi; ji++)
        if (Ti[ji] != Ci[ji]) {
          $i = Ti[ji] < Ci[ji];
          break;
        }
    if ($i && (xi = Ti, Ti = Ci, Ci = xi, Bi.s = -Bi.s), ji = (zi = Ci.length) - (Zi = Ti.length), ji > 0) for (; ji--; Ti[Zi++] = 0) ;
    for (ji = BASE - 1; zi > wi; ) {
      if (Ti[--zi] < Ci[zi]) {
        for (Zi = zi; Zi && !Ti[--Zi]; Ti[Zi] = ji) ;
        --Ti[Zi], Ti[zi] += BASE;
      }
      Ti[zi] -= Ci[zi];
    }
    for (; Ti[0] == 0; Ti.splice(0, 1), --Ri) ;
    return Ti[0] ? Fi(Bi, Ti, Ri) : (Bi.s = Ue == 3 ? -1 : 1, Bi.c = [Bi.e = 0], Bi);
  }, Pe.modulo = Pe.mod = function(Bi, ji) {
    var Zi, zi, xi = this;
    return Bi = new Si(Bi, ji), !xi.c || !Bi.s || Bi.c && !Bi.c[0] ? new Si(NaN) : !Bi.c || xi.c && !xi.c[0] ? new Si(xi) : (fi == 9 ? (zi = Bi.s, Bi.s = 1, Zi = t(xi, Bi, 0, 3), Bi.s = zi, Zi.s *= zi) : Zi = t(xi, Bi, 0, fi), Bi = xi.minus(Zi.times(Bi)), !Bi.c[0] && fi == 1 && (Bi.s = xi.s), Bi);
  }, Pe.multipliedBy = Pe.times = function(Bi, ji) {
    var Zi, zi, xi, $i, vi, wi, Ai, Ri, Ti, Ci, Ii, Li, Ni, Vi, is, Ki = this, ts = Ki.c, qi = (Bi = new Si(Bi, ji)).c;
    if (!ts || !qi || !ts[0] || !qi[0])
      return !Ki.s || !Bi.s || ts && !ts[0] && !qi || qi && !qi[0] && !ts ? Bi.c = Bi.e = Bi.s = null : (Bi.s *= Ki.s, !ts || !qi ? Bi.c = Bi.e = null : (Bi.c = [0], Bi.e = 0)), Bi;
    for (zi = bitFloor(Ki.e / LOG_BASE) + bitFloor(Bi.e / LOG_BASE), Bi.s *= Ki.s, Ai = ts.length, Ci = qi.length, Ai < Ci && (Ni = ts, ts = qi, qi = Ni, xi = Ai, Ai = Ci, Ci = xi), xi = Ai + Ci, Ni = []; xi--; Ni.push(0)) ;
    for (Vi = BASE, is = SQRT_BASE, xi = Ci; --xi >= 0; ) {
      for (Zi = 0, Ii = qi[xi] % is, Li = qi[xi] / is | 0, vi = Ai, $i = xi + vi; $i > xi; )
        Ri = ts[--vi] % is, Ti = ts[vi] / is | 0, wi = Li * Ri + Ti * Ii, Ri = Ii * Ri + wi % is * is + Ni[$i] + Zi, Zi = (Ri / Vi | 0) + (wi / is | 0) + Li * Ti, Ni[$i--] = Ri % Vi;
      Ni[$i] = Zi;
    }
    return Zi ? ++zi : Ni.splice(0, 1), Fi(Bi, Ni, zi);
  }, Pe.negated = function() {
    var Bi = new Si(this);
    return Bi.s = -Bi.s || null, Bi;
  }, Pe.plus = function(Bi, ji) {
    var Zi, zi = this, xi = zi.s;
    if (Bi = new Si(Bi, ji), ji = Bi.s, !xi || !ji) return new Si(NaN);
    if (xi != ji)
      return Bi.s = -ji, zi.minus(Bi);
    var $i = zi.e / LOG_BASE, vi = Bi.e / LOG_BASE, wi = zi.c, Ai = Bi.c;
    if (!$i || !vi) {
      if (!wi || !Ai) return new Si(xi / 0);
      if (!wi[0] || !Ai[0]) return Ai[0] ? Bi : new Si(wi[0] ? zi : xi * 0);
    }
    if ($i = bitFloor($i), vi = bitFloor(vi), wi = wi.slice(), xi = $i - vi) {
      for (xi > 0 ? (vi = $i, Zi = Ai) : (xi = -xi, Zi = wi), Zi.reverse(); xi--; Zi.push(0)) ;
      Zi.reverse();
    }
    for (xi = wi.length, ji = Ai.length, xi - ji < 0 && (Zi = Ai, Ai = wi, wi = Zi, ji = xi), xi = 0; ji; )
      xi = (wi[--ji] = wi[ji] + Ai[ji] + xi) / BASE | 0, wi[ji] = BASE === wi[ji] ? 0 : wi[ji] % BASE;
    return xi && (wi = [xi].concat(wi), ++vi), Fi(Bi, wi, vi);
  }, Pe.precision = Pe.sd = function(Bi, ji) {
    var Zi, zi, xi, $i = this;
    if (Bi != null && Bi !== !!Bi)
      return intCheck(Bi, 1, MAX), ji == null ? ji = Ue : intCheck(ji, 0, 8), Ui(new Si($i), Bi, ji);
    if (!(Zi = $i.c)) return null;
    if (xi = Zi.length - 1, zi = xi * LOG_BASE + 1, xi = Zi[xi]) {
      for (; xi % 10 == 0; xi /= 10, zi--) ;
      for (xi = Zi[0]; xi >= 10; xi /= 10, zi++) ;
    }
    return Bi && $i.e + 1 > zi && (zi = $i.e + 1), zi;
  }, Pe.shiftedBy = function(Bi) {
    return intCheck(Bi, -MAX_SAFE_INTEGER$1, MAX_SAFE_INTEGER$1), this.times("1e" + Bi);
  }, Pe.squareRoot = Pe.sqrt = function() {
    var Bi, ji, Zi, zi, xi, $i = this, vi = $i.c, wi = $i.s, Ai = $i.e, Ri = Me + 4, Ti = new Si("0.5");
    if (wi !== 1 || !vi || !vi[0])
      return new Si(!wi || wi < 0 && (!vi || vi[0]) ? NaN : vi ? $i : 1 / 0);
    if (wi = Math.sqrt(+Pi($i)), wi == 0 || wi == 1 / 0 ? (ji = coeffToString(vi), (ji.length + Ai) % 2 == 0 && (ji += "0"), wi = Math.sqrt(+ji), Ai = bitFloor((Ai + 1) / 2) - (Ai < 0 || Ai % 2), wi == 1 / 0 ? ji = "5e" + Ai : (ji = wi.toExponential(), ji = ji.slice(0, ji.indexOf("e") + 1) + Ai), Zi = new Si(ji)) : Zi = new Si(wi + ""), Zi.c[0]) {
      for (Ai = Zi.e, wi = Ai + Ri, wi < 3 && (wi = 0); ; )
        if (xi = Zi, Zi = Ti.times(xi.plus(t($i, xi, Ri, 1))), coeffToString(xi.c).slice(0, wi) === (ji = coeffToString(Zi.c)).slice(0, wi))
          if (Zi.e < Ai && --wi, ji = ji.slice(wi - 3, wi + 1), ji == "9999" || !zi && ji == "4999") {
            if (!zi && (Ui(xi, xi.e + Me + 2, 0), xi.times(xi).eq($i))) {
              Zi = xi;
              break;
            }
            Ri += 4, wi += 4, zi = 1;
          } else {
            (!+ji || !+ji.slice(1) && ji.charAt(0) == "5") && (Ui(Zi, Zi.e + Me + 2, 1), Bi = !Zi.times(Zi).eq($i));
            break;
          }
    }
    return Ui(Zi, Zi.e + Me + 1, Ue, Bi);
  }, Pe.toExponential = function(Bi, ji) {
    return Bi != null && (intCheck(Bi, 0, MAX), Bi++), Mi(this, Bi, ji, 1);
  }, Pe.toFixed = function(Bi, ji) {
    return Bi != null && (intCheck(Bi, 0, MAX), Bi = Bi + this.e + 1), Mi(this, Bi, ji);
  }, Pe.toFormat = function(Bi, ji, Zi) {
    var zi, xi = this;
    if (Zi == null)
      Bi != null && ji && typeof ji == "object" ? (Zi = ji, ji = null) : Bi && typeof Bi == "object" ? (Zi = Bi, Bi = ji = null) : Zi = mi;
    else if (typeof Zi != "object")
      throw Error(bignumberError + "Argument not an object: " + Zi);
    if (zi = xi.toFixed(Bi, ji), xi.c) {
      var $i, vi = zi.split("."), wi = +Zi.groupSize, Ai = +Zi.secondaryGroupSize, Ri = Zi.groupSeparator || "", Ti = vi[0], Ci = vi[1], Ii = xi.s < 0, Li = Ii ? Ti.slice(1) : Ti, Ni = Li.length;
      if (Ai && ($i = wi, wi = Ai, Ai = $i, Ni -= $i), wi > 0 && Ni > 0) {
        for ($i = Ni % wi || wi, Ti = Li.substr(0, $i); $i < Ni; $i += wi) Ti += Ri + Li.substr($i, wi);
        Ai > 0 && (Ti += Ri + Li.slice($i)), Ii && (Ti = "-" + Ti);
      }
      zi = Ci ? Ti + (Zi.decimalSeparator || "") + ((Ai = +Zi.fractionGroupSize) ? Ci.replace(
        new RegExp("\\d{" + Ai + "}\\B", "g"),
        "$&" + (Zi.fractionGroupSeparator || "")
      ) : Ci) : Ti;
    }
    return (Zi.prefix || "") + zi + (Zi.suffix || "");
  }, Pe.toFraction = function(Bi) {
    var ji, Zi, zi, xi, $i, vi, wi, Ai, Ri, Ti, Ci, Ii, Li = this, Ni = Li.c;
    if (Bi != null && (wi = new Si(Bi), !wi.isInteger() && (wi.c || wi.s !== 1) || wi.lt(Te)))
      throw Error(bignumberError + "Argument " + (wi.isInteger() ? "out of range: " : "not an integer: ") + Pi(wi));
    if (!Ni) return new Si(Li);
    for (ji = new Si(Te), Ri = Zi = new Si(Te), zi = Ai = new Si(Te), Ii = coeffToString(Ni), $i = ji.e = Ii.length - Li.e - 1, ji.c[0] = POWS_TEN[(vi = $i % LOG_BASE) < 0 ? LOG_BASE + vi : vi], Bi = !Bi || wi.comparedTo(ji) > 0 ? $i > 0 ? ji : Ri : wi, vi = vn, vn = 1 / 0, wi = new Si(Ii), Ai.c[0] = 0; Ti = t(wi, ji, 0, 1), xi = Zi.plus(Ti.times(zi)), xi.comparedTo(Bi) != 1; )
      Zi = zi, zi = xi, Ri = Ai.plus(Ti.times(xi = Ri)), Ai = xi, ji = wi.minus(Ti.times(xi = ji)), wi = xi;
    return xi = t(Bi.minus(Zi), zi, 0, 1), Ai = Ai.plus(xi.times(Ri)), Zi = Zi.plus(xi.times(zi)), Ai.s = Ri.s = Li.s, $i = $i * 2, Ci = t(Ri, zi, $i, Ue).minus(Li).abs().comparedTo(
      t(Ai, Zi, $i, Ue).minus(Li).abs()
    ) < 1 ? [Ri, zi] : [Ai, Zi], vn = vi, Ci;
  }, Pe.toNumber = function() {
    return +Pi(this);
  }, Pe.toPrecision = function(Bi, ji) {
    return Bi != null && intCheck(Bi, 1, MAX), Mi(this, Bi, ji, 2);
  }, Pe.toString = function(Bi) {
    var ji, Zi = this, zi = Zi.s, xi = Zi.e;
    return xi === null ? zi ? (ji = "Infinity", zi < 0 && (ji = "-" + ji)) : ji = "NaN" : (Bi == null ? ji = xi <= je || xi >= fn ? toExponential(coeffToString(Zi.c), xi) : toFixedPoint(coeffToString(Zi.c), xi, "0") : Bi === 10 && Ei ? (Zi = Ui(new Si(Zi), Me + xi + 1, Ue), ji = toFixedPoint(coeffToString(Zi.c), Zi.e, "0")) : (intCheck(Bi, 2, _i.length, "Base"), ji = Ie(toFixedPoint(coeffToString(Zi.c), xi, "0"), 10, Bi, zi, !0)), zi < 0 && Zi.c[0] && (ji = "-" + ji)), ji;
  }, Pe.valueOf = Pe.toJSON = function() {
    return Pi(this);
  }, Pe._isBigNumber = !0, Pe[Symbol.toStringTag] = "BigNumber", Pe[Symbol.for("nodejs.util.inspect.custom")] = Pe.valueOf, Ae != null && Si.set(Ae), Si;
}
function bitFloor(Ae) {
  var t = Ae | 0;
  return Ae > 0 || Ae === t ? t : t - 1;
}
function coeffToString(Ae) {
  for (var t, Ie, Be = 1, Pe = Ae.length, Te = Ae[0] + ""; Be < Pe; ) {
    for (t = Ae[Be++] + "", Ie = LOG_BASE - t.length; Ie--; t = "0" + t) ;
    Te += t;
  }
  for (Pe = Te.length; Te.charCodeAt(--Pe) === 48; ) ;
  return Te.slice(0, Pe + 1 || 1);
}
function compare$1(Ae, t) {
  var Ie, Be, Pe = Ae.c, Te = t.c, Me = Ae.s, Ue = t.s, je = Ae.e, fn = t.e;
  if (!Me || !Ue) return null;
  if (Ie = Pe && !Pe[0], Be = Te && !Te[0], Ie || Be) return Ie ? Be ? 0 : -Ue : Me;
  if (Me != Ue) return Me;
  if (Ie = Me < 0, Be = je == fn, !Pe || !Te) return Be ? 0 : !Pe ^ Ie ? 1 : -1;
  if (!Be) return je > fn ^ Ie ? 1 : -1;
  for (Ue = (je = Pe.length) < (fn = Te.length) ? je : fn, Me = 0; Me < Ue; Me++) if (Pe[Me] != Te[Me]) return Pe[Me] > Te[Me] ^ Ie ? 1 : -1;
  return je == fn ? 0 : je > fn ^ Ie ? 1 : -1;
}
function intCheck(Ae, t, Ie, Be) {
  if (Ae < t || Ae > Ie || Ae !== mathfloor(Ae))
    throw Error(bignumberError + (Be || "Argument") + (typeof Ae == "number" ? Ae < t || Ae > Ie ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(Ae));
}
function isOdd(Ae) {
  var t = Ae.c.length - 1;
  return bitFloor(Ae.e / LOG_BASE) == t && Ae.c[t] % 2 != 0;
}
function toExponential(Ae, t) {
  return (Ae.length > 1 ? Ae.charAt(0) + "." + Ae.slice(1) : Ae) + (t < 0 ? "e" : "e+") + t;
}
function toFixedPoint(Ae, t, Ie) {
  var Be, Pe;
  if (t < 0) {
    for (Pe = Ie + "."; ++t; Pe += Ie) ;
    Ae = Pe + Ae;
  } else if (Be = Ae.length, ++t > Be) {
    for (Pe = Ie, t -= Be; --t; Pe += Ie) ;
    Ae += Pe;
  } else t < Be && (Ae = Ae.slice(0, t) + "." + Ae.slice(t));
  return Ae;
}
var BigNumber = clone();
function padWithZeroes(Ae, t) {
  if (Ae !== "" && !/^[a-f0-9]+$/iu.test(Ae))
    throw new Error(`Expected an unprefixed hex string. Received: ${Ae}`);
  return String.prototype.padStart.call(Ae, t, "0");
}
function concatSig(Ae, t, Ie) {
  const Be = fromSigned(t), Pe = fromSigned(Ie), Te = bytesToBigInt$1(Ae), Me = padWithZeroes(Buffer$3.from(toUnsigned(Be)).toString("hex"), 64), Ue = padWithZeroes(Buffer$3.from(toUnsigned(Pe)).toString("hex"), 64), je = stripHexPrefix(bigIntToHex(Te));
  return addHexPrefix(Me.concat(Ue, je));
}
const RETRIABLE_ERRORS = [
  // ignore server overload errors
  "Gateway timeout",
  "ETIMEDOUT",
  // ignore server sent html error pages
  // or truncated json responses
  "failed to parse response body",
  // ignore errors where http req failed to establish
  "Failed to fetch"
];
function checkForHttpErrors(Ae) {
  switch (Ae.status) {
    case 405:
      throw rpcErrors.methodNotFound();
    case 418:
      throw rpcErrors.internal({
        message: "Request is being rate limited.",
        data: {
          cause: Ae
        }
      });
    case 503:
    case 504:
      throw rpcErrors.internal({
        message: "Gateway timeout. The request took too long to process.This can happen when querying over too wide a block range.",
        data: {
          cause: Ae
        }
      });
  }
}
function timeout(Ae) {
  return new Promise((t) => {
    setTimeout(t, Ae);
  });
}
function parseResponse(Ae, t) {
  if (Ae.status !== 200)
    throw rpcErrors.internal({
      message: `Non-200 status code: '${Ae.status}'`,
      data: t
    });
  if (t.error) {
    var Ie;
    throw rpcErrors.internal({
      data: t.error,
      message: (Ie = t.error) === null || Ie === void 0 ? void 0 : Ie.message
    });
  }
  return t.result;
}
function createFetchConfigFromReq({
  req: Ae,
  rpcTarget: t,
  originHttpHeaderKey: Ie
}) {
  const Be = new URL(t), Pe = {
    id: Ae.id,
    jsonrpc: Ae.jsonrpc,
    method: Ae.method,
    params: Ae.params
  }, Te = Ae.origin, Me = JSON.stringify(Pe), Ue = {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json"
    },
    body: Me
  };
  return Ie && Te && (Ue.headers[Ie] = Te), {
    fetchUrl: Be.href,
    fetchParams: Ue
  };
}
function createFetchMiddleware({
  rpcTarget: Ae,
  originHttpHeaderKey: t
}) {
  return createAsyncMiddleware(async (Ie, Be, Pe) => {
    const {
      fetchUrl: Te,
      fetchParams: Me
    } = createFetchConfigFromReq({
      req: Ie,
      rpcTarget: Ae,
      originHttpHeaderKey: t
    }), Ue = 5, je = 1e3;
    for (let fn = 0; fn < Ue; fn++) {
      try {
        const Ve = await fetch(Te, Me);
        checkForHttpErrors(Ve);
        const vn = await Ve.json(), En = parseResponse(Ve, vn);
        Be.result = En;
        return;
      } catch (Ve) {
        const vn = (Ve.message || Ve).toString();
        if (!RETRIABLE_ERRORS.some((fi) => vn.includes(fi)))
          throw Ve;
      }
      await timeout(je);
    }
  });
}
function defineChain(Ae) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...Ae
  };
}
const version$7 = "2.21.32";
let errorConfig = {
  getDocsUrl: ({ docsBaseUrl: Ae, docsPath: t = "", docsSlug: Ie }) => t ? `${Ae ?? "https://viem.sh"}${t}${Ie ? `#${Ie}` : ""}` : void 0,
  version: `viem@${version$7}`
}, BaseError$1 = class Pc extends Error {
  constructor(t, Ie = {}) {
    var Ue;
    const Be = (() => {
      var je;
      return Ie.cause instanceof Pc ? Ie.cause.details : (je = Ie.cause) != null && je.message ? Ie.cause.message : Ie.details;
    })(), Pe = Ie.cause instanceof Pc && Ie.cause.docsPath || Ie.docsPath, Te = (Ue = errorConfig.getDocsUrl) == null ? void 0 : Ue.call(errorConfig, { ...Ie, docsPath: Pe }), Me = [
      t || "An error occurred.",
      "",
      ...Ie.metaMessages ? [...Ie.metaMessages, ""] : [],
      ...Te ? [`Docs: ${Te}`] : [],
      ...Be ? [`Details: ${Be}`] : [],
      ...errorConfig.version ? [`Version: ${errorConfig.version}`] : []
    ].join(`
`);
    super(Me, Ie.cause ? { cause: Ie.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = Be, this.docsPath = Pe, this.metaMessages = Ie.metaMessages, this.name = Ie.name ?? this.name, this.shortMessage = t, this.version = version$7;
  }
  walk(t) {
    return walk(this, t);
  }
};
function walk(Ae, t) {
  return t != null && t(Ae) ? Ae : Ae && typeof Ae == "object" && "cause" in Ae ? walk(Ae.cause, t) : t ? null : Ae;
}
class IntegerOutOfRangeError extends BaseError$1 {
  constructor({ max: t, min: Ie, signed: Be, size: Pe, value: Te }) {
    super(`Number "${Te}" is not in safe ${Pe ? `${Pe * 8}-bit ${Be ? "signed" : "unsigned"} ` : ""}integer range ${t ? `(${Ie} to ${t})` : `(above ${Ie})`}`, { name: "IntegerOutOfRangeError" });
  }
}
class InvalidBytesBooleanError extends BaseError$1 {
  constructor(t) {
    super(`Bytes value "${t}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
      name: "InvalidBytesBooleanError"
    });
  }
}
class InvalidHexBooleanError extends BaseError$1 {
  constructor(t) {
    super(`Hex value "${t}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`, { name: "InvalidHexBooleanError" });
  }
}
class SizeOverflowError extends BaseError$1 {
  constructor({ givenSize: t, maxSize: Ie }) {
    super(`Size cannot exceed ${Ie} bytes. Given size: ${t} bytes.`, { name: "SizeOverflowError" });
  }
}
function isHex(Ae, { strict: t = !0 } = {}) {
  return !Ae || typeof Ae != "string" ? !1 : t ? /^0x[0-9a-fA-F]*$/.test(Ae) : Ae.startsWith("0x");
}
function size$1(Ae) {
  return isHex(Ae, { strict: !1 }) ? Math.ceil((Ae.length - 2) / 2) : Ae.length;
}
function trim(Ae, { dir: t = "left" } = {}) {
  let Ie = typeof Ae == "string" ? Ae.replace("0x", "") : Ae, Be = 0;
  for (let Pe = 0; Pe < Ie.length - 1 && Ie[t === "left" ? Pe : Ie.length - Pe - 1].toString() === "0"; Pe++)
    Be++;
  return Ie = t === "left" ? Ie.slice(Be) : Ie.slice(0, Ie.length - Be), typeof Ae == "string" ? (Ie.length === 1 && t === "right" && (Ie = `${Ie}0`), `0x${Ie.length % 2 === 1 ? `0${Ie}` : Ie}`) : Ie;
}
class SliceOffsetOutOfBoundsError extends BaseError$1 {
  constructor({ offset: t, position: Ie, size: Be }) {
    super(`Slice ${Ie === "start" ? "starting" : "ending"} at offset "${t}" is out-of-bounds (size: ${Be}).`, { name: "SliceOffsetOutOfBoundsError" });
  }
}
class SizeExceedsPaddingSizeError extends BaseError$1 {
  constructor({ size: t, targetSize: Ie, type: Be }) {
    super(`${Be.charAt(0).toUpperCase()}${Be.slice(1).toLowerCase()} size (${t}) exceeds padding size (${Ie}).`, { name: "SizeExceedsPaddingSizeError" });
  }
}
class InvalidBytesLengthError extends BaseError$1 {
  constructor({ size: t, targetSize: Ie, type: Be }) {
    super(`${Be.charAt(0).toUpperCase()}${Be.slice(1).toLowerCase()} is expected to be ${Ie} ${Be} long, but is ${t} ${Be} long.`, { name: "InvalidBytesLengthError" });
  }
}
function pad(Ae, { dir: t, size: Ie = 32 } = {}) {
  return typeof Ae == "string" ? padHex(Ae, { dir: t, size: Ie }) : padBytes(Ae, { dir: t, size: Ie });
}
function padHex(Ae, { dir: t, size: Ie = 32 } = {}) {
  if (Ie === null)
    return Ae;
  const Be = Ae.replace("0x", "");
  if (Be.length > Ie * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(Be.length / 2),
      targetSize: Ie,
      type: "hex"
    });
  return `0x${Be[t === "right" ? "padEnd" : "padStart"](Ie * 2, "0")}`;
}
function padBytes(Ae, { dir: t, size: Ie = 32 } = {}) {
  if (Ie === null)
    return Ae;
  if (Ae.length > Ie)
    throw new SizeExceedsPaddingSizeError({
      size: Ae.length,
      targetSize: Ie,
      type: "bytes"
    });
  const Be = new Uint8Array(Ie);
  for (let Pe = 0; Pe < Ie; Pe++) {
    const Te = t === "right";
    Be[Te ? Pe : Ie - Pe - 1] = Ae[Te ? Pe : Ae.length - Pe - 1];
  }
  return Be;
}
const hexes$2 = /* @__PURE__ */ Array.from({ length: 256 }, (Ae, t) => t.toString(16).padStart(2, "0"));
function toHex(Ae, t = {}) {
  return typeof Ae == "number" || typeof Ae == "bigint" ? numberToHex(Ae, t) : typeof Ae == "string" ? stringToHex(Ae, t) : typeof Ae == "boolean" ? boolToHex(Ae, t) : bytesToHex$2(Ae, t);
}
function boolToHex(Ae, t = {}) {
  const Ie = `0x${Number(Ae)}`;
  return typeof t.size == "number" ? (assertSize(Ie, { size: t.size }), pad(Ie, { size: t.size })) : Ie;
}
function bytesToHex$2(Ae, t = {}) {
  let Ie = "";
  for (let Pe = 0; Pe < Ae.length; Pe++)
    Ie += hexes$2[Ae[Pe]];
  const Be = `0x${Ie}`;
  return typeof t.size == "number" ? (assertSize(Be, { size: t.size }), pad(Be, { dir: "right", size: t.size })) : Be;
}
function numberToHex(Ae, t = {}) {
  const { signed: Ie, size: Be } = t, Pe = BigInt(Ae);
  let Te;
  Be ? Ie ? Te = (1n << BigInt(Be) * 8n - 1n) - 1n : Te = 2n ** (BigInt(Be) * 8n) - 1n : typeof Ae == "number" && (Te = BigInt(Number.MAX_SAFE_INTEGER));
  const Me = typeof Te == "bigint" && Ie ? -Te - 1n : 0;
  if (Te && Pe > Te || Pe < Me) {
    const je = typeof Ae == "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: Te ? `${Te}${je}` : void 0,
      min: `${Me}${je}`,
      signed: Ie,
      size: Be,
      value: `${Ae}${je}`
    });
  }
  const Ue = `0x${(Ie && Pe < 0 ? (1n << BigInt(Be * 8)) + BigInt(Pe) : Pe).toString(16)}`;
  return Be ? pad(Ue, { size: Be }) : Ue;
}
const encoder$1 = /* @__PURE__ */ new TextEncoder();
function stringToHex(Ae, t = {}) {
  const Ie = encoder$1.encode(Ae);
  return bytesToHex$2(Ie, t);
}
const encoder = /* @__PURE__ */ new TextEncoder();
function toBytes$2(Ae, t = {}) {
  return typeof Ae == "number" || typeof Ae == "bigint" ? numberToBytes(Ae, t) : typeof Ae == "boolean" ? boolToBytes(Ae, t) : isHex(Ae) ? hexToBytes$2(Ae, t) : stringToBytes(Ae, t);
}
function boolToBytes(Ae, t = {}) {
  const Ie = new Uint8Array(1);
  return Ie[0] = Number(Ae), typeof t.size == "number" ? (assertSize(Ie, { size: t.size }), pad(Ie, { size: t.size })) : Ie;
}
const charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(Ae) {
  if (Ae >= charCodeMap.zero && Ae <= charCodeMap.nine)
    return Ae - charCodeMap.zero;
  if (Ae >= charCodeMap.A && Ae <= charCodeMap.F)
    return Ae - (charCodeMap.A - 10);
  if (Ae >= charCodeMap.a && Ae <= charCodeMap.f)
    return Ae - (charCodeMap.a - 10);
}
function hexToBytes$2(Ae, t = {}) {
  let Ie = Ae;
  t.size && (assertSize(Ie, { size: t.size }), Ie = pad(Ie, { dir: "right", size: t.size }));
  let Be = Ie.slice(2);
  Be.length % 2 && (Be = `0${Be}`);
  const Pe = Be.length / 2, Te = new Uint8Array(Pe);
  for (let Me = 0, Ue = 0; Me < Pe; Me++) {
    const je = charCodeToBase16(Be.charCodeAt(Ue++)), fn = charCodeToBase16(Be.charCodeAt(Ue++));
    if (je === void 0 || fn === void 0)
      throw new BaseError$1(`Invalid byte sequence ("${Be[Ue - 2]}${Be[Ue - 1]}" in "${Be}").`);
    Te[Me] = je * 16 + fn;
  }
  return Te;
}
function numberToBytes(Ae, t) {
  const Ie = numberToHex(Ae, t);
  return hexToBytes$2(Ie);
}
function stringToBytes(Ae, t = {}) {
  const Ie = encoder.encode(Ae);
  return typeof t.size == "number" ? (assertSize(Ie, { size: t.size }), pad(Ie, { dir: "right", size: t.size })) : Ie;
}
function assertSize(Ae, { size: t }) {
  if (size$1(Ae) > t)
    throw new SizeOverflowError({
      givenSize: size$1(Ae),
      maxSize: t
    });
}
function hexToBigInt(Ae, t = {}) {
  const { signed: Ie } = t;
  t.size && assertSize(Ae, { size: t.size });
  const Be = BigInt(Ae);
  if (!Ie)
    return Be;
  const Pe = (Ae.length - 2) / 2, Te = (1n << BigInt(Pe) * 8n - 1n) - 1n;
  return Be <= Te ? Be : Be - BigInt(`0x${"f".padStart(Pe * 2, "f")}`) - 1n;
}
function hexToBool(Ae, t = {}) {
  let Ie = Ae;
  if (t.size && (assertSize(Ie, { size: t.size }), Ie = trim(Ie)), trim(Ie) === "0x00")
    return !1;
  if (trim(Ie) === "0x01")
    return !0;
  throw new InvalidHexBooleanError(Ie);
}
function hexToNumber$2(Ae, t = {}) {
  return Number(hexToBigInt(Ae, t));
}
const transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(Ae) {
  const t = {
    ...Ae,
    blockHash: Ae.blockHash ? Ae.blockHash : null,
    blockNumber: Ae.blockNumber ? BigInt(Ae.blockNumber) : null,
    chainId: Ae.chainId ? hexToNumber$2(Ae.chainId) : void 0,
    gas: Ae.gas ? BigInt(Ae.gas) : void 0,
    gasPrice: Ae.gasPrice ? BigInt(Ae.gasPrice) : void 0,
    maxFeePerBlobGas: Ae.maxFeePerBlobGas ? BigInt(Ae.maxFeePerBlobGas) : void 0,
    maxFeePerGas: Ae.maxFeePerGas ? BigInt(Ae.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: Ae.maxPriorityFeePerGas ? BigInt(Ae.maxPriorityFeePerGas) : void 0,
    nonce: Ae.nonce ? hexToNumber$2(Ae.nonce) : void 0,
    to: Ae.to ? Ae.to : null,
    transactionIndex: Ae.transactionIndex ? Number(Ae.transactionIndex) : null,
    type: Ae.type ? transactionType[Ae.type] : void 0,
    typeHex: Ae.type ? Ae.type : void 0,
    value: Ae.value ? BigInt(Ae.value) : void 0,
    v: Ae.v ? BigInt(Ae.v) : void 0
  };
  return Ae.authorizationList && (t.authorizationList = formatAuthorizationList$1(Ae.authorizationList)), t.yParity = (() => {
    if (Ae.yParity)
      return Number(Ae.yParity);
    if (typeof t.v == "bigint") {
      if (t.v === 0n || t.v === 27n)
        return 0;
      if (t.v === 1n || t.v === 28n)
        return 1;
      if (t.v >= 35n)
        return t.v % 2n === 0n ? 1 : 0;
    }
  })(), t.type === "legacy" && (delete t.accessList, delete t.maxFeePerBlobGas, delete t.maxFeePerGas, delete t.maxPriorityFeePerGas, delete t.yParity), t.type === "eip2930" && (delete t.maxFeePerBlobGas, delete t.maxFeePerGas, delete t.maxPriorityFeePerGas), t.type === "eip1559" && delete t.maxFeePerBlobGas, t;
}
function formatAuthorizationList$1(Ae) {
  return Ae.map((t) => ({
    contractAddress: t.address,
    chainId: Number(t.chainId),
    nonce: Number(t.nonce),
    r: t.r,
    s: t.s,
    yParity: Number(t.yParity)
  }));
}
function formatBlock(Ae) {
  var Ie;
  const t = (Ie = Ae.transactions) == null ? void 0 : Ie.map((Be) => typeof Be == "string" ? Be : formatTransaction(Be));
  return {
    ...Ae,
    baseFeePerGas: Ae.baseFeePerGas ? BigInt(Ae.baseFeePerGas) : null,
    blobGasUsed: Ae.blobGasUsed ? BigInt(Ae.blobGasUsed) : void 0,
    difficulty: Ae.difficulty ? BigInt(Ae.difficulty) : void 0,
    excessBlobGas: Ae.excessBlobGas ? BigInt(Ae.excessBlobGas) : void 0,
    gasLimit: Ae.gasLimit ? BigInt(Ae.gasLimit) : void 0,
    gasUsed: Ae.gasUsed ? BigInt(Ae.gasUsed) : void 0,
    hash: Ae.hash ? Ae.hash : null,
    logsBloom: Ae.logsBloom ? Ae.logsBloom : null,
    nonce: Ae.nonce ? Ae.nonce : null,
    number: Ae.number ? BigInt(Ae.number) : null,
    size: Ae.size ? BigInt(Ae.size) : void 0,
    timestamp: Ae.timestamp ? BigInt(Ae.timestamp) : void 0,
    transactions: t,
    totalDifficulty: Ae.totalDifficulty ? BigInt(Ae.totalDifficulty) : null
  };
}
function formatLog(Ae, { args: t, eventName: Ie } = {}) {
  return {
    ...Ae,
    blockHash: Ae.blockHash ? Ae.blockHash : null,
    blockNumber: Ae.blockNumber ? BigInt(Ae.blockNumber) : null,
    logIndex: Ae.logIndex ? Number(Ae.logIndex) : null,
    transactionHash: Ae.transactionHash ? Ae.transactionHash : null,
    transactionIndex: Ae.transactionIndex ? Number(Ae.transactionIndex) : null,
    ...Ie ? { args: t, eventName: Ie } : {}
  };
}
const receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(Ae) {
  const t = {
    ...Ae,
    blockNumber: Ae.blockNumber ? BigInt(Ae.blockNumber) : null,
    contractAddress: Ae.contractAddress ? Ae.contractAddress : null,
    cumulativeGasUsed: Ae.cumulativeGasUsed ? BigInt(Ae.cumulativeGasUsed) : null,
    effectiveGasPrice: Ae.effectiveGasPrice ? BigInt(Ae.effectiveGasPrice) : null,
    gasUsed: Ae.gasUsed ? BigInt(Ae.gasUsed) : null,
    logs: Ae.logs ? Ae.logs.map((Ie) => formatLog(Ie)) : null,
    to: Ae.to ? Ae.to : null,
    transactionIndex: Ae.transactionIndex ? hexToNumber$2(Ae.transactionIndex) : null,
    status: Ae.status ? receiptStatuses[Ae.status] : null,
    type: Ae.type ? transactionType[Ae.type] || Ae.type : null
  };
  return Ae.blobGasPrice && (t.blobGasPrice = BigInt(Ae.blobGasPrice)), Ae.blobGasUsed && (t.blobGasUsed = BigInt(Ae.blobGasUsed)), t;
}
const rpcTransactionType = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
function formatTransactionRequest(Ae) {
  const t = {};
  return typeof Ae.authorizationList < "u" && (t.authorizationList = formatAuthorizationList(Ae.authorizationList)), typeof Ae.accessList < "u" && (t.accessList = Ae.accessList), typeof Ae.blobVersionedHashes < "u" && (t.blobVersionedHashes = Ae.blobVersionedHashes), typeof Ae.blobs < "u" && (typeof Ae.blobs[0] != "string" ? t.blobs = Ae.blobs.map((Ie) => bytesToHex$2(Ie)) : t.blobs = Ae.blobs), typeof Ae.data < "u" && (t.data = Ae.data), typeof Ae.from < "u" && (t.from = Ae.from), typeof Ae.gas < "u" && (t.gas = numberToHex(Ae.gas)), typeof Ae.gasPrice < "u" && (t.gasPrice = numberToHex(Ae.gasPrice)), typeof Ae.maxFeePerBlobGas < "u" && (t.maxFeePerBlobGas = numberToHex(Ae.maxFeePerBlobGas)), typeof Ae.maxFeePerGas < "u" && (t.maxFeePerGas = numberToHex(Ae.maxFeePerGas)), typeof Ae.maxPriorityFeePerGas < "u" && (t.maxPriorityFeePerGas = numberToHex(Ae.maxPriorityFeePerGas)), typeof Ae.nonce < "u" && (t.nonce = numberToHex(Ae.nonce)), typeof Ae.to < "u" && (t.to = Ae.to), typeof Ae.type < "u" && (t.type = rpcTransactionType[Ae.type]), typeof Ae.value < "u" && (t.value = numberToHex(Ae.value)), t;
}
function formatAuthorizationList(Ae) {
  return Ae.map((t) => ({
    address: t.contractAddress,
    r: t.r,
    s: t.s,
    chainId: numberToHex(t.chainId),
    nonce: numberToHex(t.nonce),
    ...typeof t.yParity < "u" ? { yParity: numberToHex(t.yParity) } : {},
    ...typeof t.v < "u" && typeof t.yParity > "u" ? { v: numberToHex(t.v) } : {}
  }));
}
const maxUint256 = 2n ** 256n - 1n;
function concat$3(Ae) {
  return typeof Ae[0] == "string" ? concatHex(Ae) : concatBytes$4(Ae);
}
function concatBytes$4(Ae) {
  let t = 0;
  for (const Pe of Ae)
    t += Pe.length;
  const Ie = new Uint8Array(t);
  let Be = 0;
  for (const Pe of Ae)
    Ie.set(Pe, Be), Be += Pe.length;
  return Ie;
}
function concatHex(Ae) {
  return `0x${Ae.reduce((t, Ie) => t + Ie.replace("0x", ""), "")}`;
}
class NegativeOffsetError extends BaseError$1 {
  constructor({ offset: t }) {
    super(`Offset \`${t}\` cannot be negative.`, {
      name: "NegativeOffsetError"
    });
  }
}
class PositionOutOfBoundsError extends BaseError$1 {
  constructor({ length: t, position: Ie }) {
    super(`Position \`${Ie}\` is out of bounds (\`0 < position < ${t}\`).`, { name: "PositionOutOfBoundsError" });
  }
}
class RecursiveReadLimitExceededError extends BaseError$1 {
  constructor({ count: t, limit: Ie }) {
    super(`Recursive read limit of \`${Ie}\` exceeded (recursive read count: \`${t}\`).`, { name: "RecursiveReadLimitExceededError" });
  }
}
const staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(Ae) {
    if (Ae < 0 || Ae > this.bytes.length - 1)
      throw new PositionOutOfBoundsError({
        length: this.bytes.length,
        position: Ae
      });
  },
  decrementPosition(Ae) {
    if (Ae < 0)
      throw new NegativeOffsetError({ offset: Ae });
    const t = this.position - Ae;
    this.assertPosition(t), this.position = t;
  },
  getReadCount(Ae) {
    return this.positionReadCount.get(Ae || this.position) || 0;
  },
  incrementPosition(Ae) {
    if (Ae < 0)
      throw new NegativeOffsetError({ offset: Ae });
    const t = this.position + Ae;
    this.assertPosition(t), this.position = t;
  },
  inspectByte(Ae) {
    const t = Ae ?? this.position;
    return this.assertPosition(t), this.bytes[t];
  },
  inspectBytes(Ae, t) {
    const Ie = t ?? this.position;
    return this.assertPosition(Ie + Ae - 1), this.bytes.subarray(Ie, Ie + Ae);
  },
  inspectUint8(Ae) {
    const t = Ae ?? this.position;
    return this.assertPosition(t), this.bytes[t];
  },
  inspectUint16(Ae) {
    const t = Ae ?? this.position;
    return this.assertPosition(t + 1), this.dataView.getUint16(t);
  },
  inspectUint24(Ae) {
    const t = Ae ?? this.position;
    return this.assertPosition(t + 2), (this.dataView.getUint16(t) << 8) + this.dataView.getUint8(t + 2);
  },
  inspectUint32(Ae) {
    const t = Ae ?? this.position;
    return this.assertPosition(t + 3), this.dataView.getUint32(t);
  },
  pushByte(Ae) {
    this.assertPosition(this.position), this.bytes[this.position] = Ae, this.position++;
  },
  pushBytes(Ae) {
    this.assertPosition(this.position + Ae.length - 1), this.bytes.set(Ae, this.position), this.position += Ae.length;
  },
  pushUint8(Ae) {
    this.assertPosition(this.position), this.bytes[this.position] = Ae, this.position++;
  },
  pushUint16(Ae) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, Ae), this.position += 2;
  },
  pushUint24(Ae) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, Ae >> 8), this.dataView.setUint8(this.position + 2, Ae & 255), this.position += 3;
  },
  pushUint32(Ae) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, Ae), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const Ae = this.inspectByte();
    return this.position++, Ae;
  },
  readBytes(Ae, t) {
    this.assertReadLimit(), this._touch();
    const Ie = this.inspectBytes(Ae);
    return this.position += t ?? Ae, Ie;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const Ae = this.inspectUint8();
    return this.position += 1, Ae;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const Ae = this.inspectUint16();
    return this.position += 2, Ae;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const Ae = this.inspectUint24();
    return this.position += 3, Ae;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const Ae = this.inspectUint32();
    return this.position += 4, Ae;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(Ae) {
    const t = this.position;
    return this.assertPosition(Ae), this.position = Ae, () => this.position = t;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const Ae = this.getReadCount();
    this.positionReadCount.set(this.position, Ae + 1), Ae > 0 && this.recursiveReadCount++;
  }
};
function createCursor(Ae, { recursiveReadLimit: t = 8192 } = {}) {
  const Ie = Object.create(staticCursor);
  return Ie.bytes = Ae, Ie.dataView = new DataView(Ae.buffer, Ae.byteOffset, Ae.byteLength), Ie.positionReadCount = /* @__PURE__ */ new Map(), Ie.recursiveReadLimit = t, Ie;
}
function toRlp(Ae, t = "hex") {
  const Ie = getEncodable(Ae), Be = createCursor(new Uint8Array(Ie.length));
  return Ie.encode(Be), t === "hex" ? bytesToHex$2(Be.bytes) : Be.bytes;
}
function getEncodable(Ae) {
  return Array.isArray(Ae) ? getEncodableList(Ae.map((t) => getEncodable(t))) : getEncodableBytes(Ae);
}
function getEncodableList(Ae) {
  const t = Ae.reduce((Pe, Te) => Pe + Te.length, 0), Ie = getSizeOfLength(t);
  return {
    length: t <= 55 ? 1 + t : 1 + Ie + t,
    encode(Pe) {
      t <= 55 ? Pe.pushByte(192 + t) : (Pe.pushByte(247 + Ie), Ie === 1 ? Pe.pushUint8(t) : Ie === 2 ? Pe.pushUint16(t) : Ie === 3 ? Pe.pushUint24(t) : Pe.pushUint32(t));
      for (const { encode: Te } of Ae)
        Te(Pe);
    }
  };
}
function getEncodableBytes(Ae) {
  const t = typeof Ae == "string" ? hexToBytes$2(Ae) : Ae, Ie = getSizeOfLength(t.length);
  return {
    length: t.length === 1 && t[0] < 128 ? 1 : t.length <= 55 ? 1 + t.length : 1 + Ie + t.length,
    encode(Pe) {
      t.length === 1 && t[0] < 128 ? Pe.pushBytes(t) : t.length <= 55 ? (Pe.pushByte(128 + t.length), Pe.pushBytes(t)) : (Pe.pushByte(183 + Ie), Ie === 1 ? Pe.pushUint8(t.length) : Ie === 2 ? Pe.pushUint16(t.length) : Ie === 3 ? Pe.pushUint24(t.length) : Pe.pushUint32(t.length), Pe.pushBytes(t));
    }
  };
}
function getSizeOfLength(Ae) {
  if (Ae < 2 ** 8)
    return 1;
  if (Ae < 2 ** 16)
    return 2;
  if (Ae < 2 ** 24)
    return 3;
  if (Ae < 2 ** 32)
    return 4;
  throw new BaseError$1("Length is too large.");
}
const etherUnits = {
  gwei: 9,
  wei: 18
}, gweiUnits = {
  ether: -9,
  wei: 9
};
function formatUnits(Ae, t) {
  let Ie = Ae.toString();
  const Be = Ie.startsWith("-");
  Be && (Ie = Ie.slice(1)), Ie = Ie.padStart(t, "0");
  let [Pe, Te] = [
    Ie.slice(0, Ie.length - t),
    Ie.slice(Ie.length - t)
  ];
  return Te = Te.replace(/(0+)$/, ""), `${Be ? "-" : ""}${Pe || "0"}${Te ? `.${Te}` : ""}`;
}
function formatEther(Ae, t = "wei") {
  return formatUnits(Ae, etherUnits[t]);
}
function formatGwei(Ae, t = "wei") {
  return formatUnits(Ae, gweiUnits[t]);
}
function prettyPrint(Ae) {
  const t = Object.entries(Ae).map(([Be, Pe]) => Pe === void 0 || Pe === !1 ? null : [Be, Pe]).filter(Boolean), Ie = t.reduce((Be, [Pe]) => Math.max(Be, Pe.length), 0);
  return t.map(([Be, Pe]) => `  ${`${Be}:`.padEnd(Ie + 1)}  ${Pe}`).join(`
`);
}
class FeeConflictError extends BaseError$1 {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join(`
`), { name: "FeeConflictError" });
  }
}
class InvalidSerializableTransactionError extends BaseError$1 {
  constructor({ transaction: t }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        prettyPrint(t),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- an EIP-7702 Transaction with `authorizationList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ],
      name: "InvalidSerializableTransactionError"
    });
  }
}
class TransactionExecutionError extends BaseError$1 {
  constructor(t, { account: Ie, docsPath: Be, chain: Pe, data: Te, gas: Me, gasPrice: Ue, maxFeePerGas: je, maxPriorityFeePerGas: fn, nonce: Ve, to: vn, value: En }) {
    var bi;
    const fi = prettyPrint({
      chain: Pe && `${Pe == null ? void 0 : Pe.name} (id: ${Pe == null ? void 0 : Pe.id})`,
      from: Ie == null ? void 0 : Ie.address,
      to: vn,
      value: typeof En < "u" && `${formatEther(En)} ${((bi = Pe == null ? void 0 : Pe.nativeCurrency) == null ? void 0 : bi.symbol) || "ETH"}`,
      data: Te,
      gas: Me,
      gasPrice: typeof Ue < "u" && `${formatGwei(Ue)} gwei`,
      maxFeePerGas: typeof je < "u" && `${formatGwei(je)} gwei`,
      maxPriorityFeePerGas: typeof fn < "u" && `${formatGwei(fn)} gwei`,
      nonce: Ve
    });
    super(t.shortMessage, {
      cause: t,
      docsPath: Be,
      metaMessages: [
        ...t.metaMessages ? [...t.metaMessages, " "] : [],
        "Request Arguments:",
        fi
      ].filter(Boolean),
      name: "TransactionExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = t;
  }
}
class TransactionNotFoundError extends BaseError$1 {
  constructor({ blockHash: t, blockNumber: Ie, blockTag: Be, hash: Pe, index: Te }) {
    let Me = "Transaction";
    Be && Te !== void 0 && (Me = `Transaction at block time "${Be}" at index "${Te}"`), t && Te !== void 0 && (Me = `Transaction at block hash "${t}" at index "${Te}"`), Ie && Te !== void 0 && (Me = `Transaction at block number "${Ie}" at index "${Te}"`), Pe && (Me = `Transaction with hash "${Pe}"`), super(`${Me} could not be found.`, {
      name: "TransactionNotFoundError"
    });
  }
}
class TransactionReceiptNotFoundError extends BaseError$1 {
  constructor({ hash: t }) {
    super(`Transaction receipt with hash "${t}" could not be found. The Transaction may not be processed on a block yet.`, {
      name: "TransactionReceiptNotFoundError"
    });
  }
}
class WaitForTransactionReceiptTimeoutError extends BaseError$1 {
  constructor({ hash: t }) {
    super(`Timed out while waiting for transaction with hash "${t}" to be confirmed.`, { name: "WaitForTransactionReceiptTimeoutError" });
  }
}
function blobsToCommitments(Ae) {
  const { kzg: t } = Ae, Ie = Ae.to ?? (typeof Ae.blobs[0] == "string" ? "hex" : "bytes"), Be = typeof Ae.blobs[0] == "string" ? Ae.blobs.map((Te) => hexToBytes$2(Te)) : Ae.blobs, Pe = [];
  for (const Te of Be)
    Pe.push(Uint8Array.from(t.blobToKzgCommitment(Te)));
  return Ie === "bytes" ? Pe : Pe.map((Te) => bytesToHex$2(Te));
}
function blobsToProofs(Ae) {
  const { kzg: t } = Ae, Ie = Ae.to ?? (typeof Ae.blobs[0] == "string" ? "hex" : "bytes"), Be = typeof Ae.blobs[0] == "string" ? Ae.blobs.map((Me) => hexToBytes$2(Me)) : Ae.blobs, Pe = typeof Ae.commitments[0] == "string" ? Ae.commitments.map((Me) => hexToBytes$2(Me)) : Ae.commitments, Te = [];
  for (let Me = 0; Me < Be.length; Me++) {
    const Ue = Be[Me], je = Pe[Me];
    Te.push(Uint8Array.from(t.computeBlobKzgProof(Ue, je)));
  }
  return Ie === "bytes" ? Te : Te.map((Me) => bytesToHex$2(Me));
}
function number$1(Ae) {
  if (!Number.isSafeInteger(Ae) || Ae < 0)
    throw new Error(`positive integer expected, not ${Ae}`);
}
function isBytes$2(Ae) {
  return Ae instanceof Uint8Array || Ae != null && typeof Ae == "object" && Ae.constructor.name === "Uint8Array";
}
function bytes$1(Ae, ...t) {
  if (!isBytes$2(Ae))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(Ae.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${Ae.length}`);
}
function hash$3(Ae) {
  if (typeof Ae != "function" || typeof Ae.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$1(Ae.outputLen), number$1(Ae.blockLen);
}
function exists$1(Ae, t = !0) {
  if (Ae.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && Ae.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$1(Ae, t) {
  bytes$1(Ae);
  const Ie = t.outputLen;
  if (Ae.length < Ie)
    throw new Error(`digestInto() expects output buffer of length at least ${Ie}`);
}
const crypto$3 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u32$1 = (Ae) => new Uint32Array(Ae.buffer, Ae.byteOffset, Math.floor(Ae.byteLength / 4)), createView$1 = (Ae) => new DataView(Ae.buffer, Ae.byteOffset, Ae.byteLength), rotr$1 = (Ae, t) => Ae << 32 - t | Ae >>> t, isLE$1 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, byteSwap = (Ae) => Ae << 24 & 4278190080 | Ae << 8 & 16711680 | Ae >>> 8 & 65280 | Ae >>> 24 & 255;
function byteSwap32(Ae) {
  for (let t = 0; t < Ae.length; t++)
    Ae[t] = byteSwap(Ae[t]);
}
function utf8ToBytes$3(Ae) {
  if (typeof Ae != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof Ae}`);
  return new Uint8Array(new TextEncoder().encode(Ae));
}
function toBytes$1(Ae) {
  return typeof Ae == "string" && (Ae = utf8ToBytes$3(Ae)), bytes$1(Ae), Ae;
}
function concatBytes$3(...Ae) {
  let t = 0;
  for (let Be = 0; Be < Ae.length; Be++) {
    const Pe = Ae[Be];
    bytes$1(Pe), t += Pe.length;
  }
  const Ie = new Uint8Array(t);
  for (let Be = 0, Pe = 0; Be < Ae.length; Be++) {
    const Te = Ae[Be];
    Ie.set(Te, Pe), Pe += Te.length;
  }
  return Ie;
}
let Hash$1 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$1(Ae) {
  const t = (Be) => Ae().update(toBytes$1(Be)).digest(), Ie = Ae();
  return t.outputLen = Ie.outputLen, t.blockLen = Ie.blockLen, t.create = () => Ae(), t;
}
function randomBytes$1(Ae = 32) {
  if (crypto$3 && typeof crypto$3.getRandomValues == "function")
    return crypto$3.getRandomValues(new Uint8Array(Ae));
  if (crypto$3 && typeof crypto$3.randomBytes == "function")
    return crypto$3.randomBytes(Ae);
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint64$1(Ae, t, Ie, Be) {
  if (typeof Ae.setBigUint64 == "function")
    return Ae.setBigUint64(t, Ie, Be);
  const Pe = BigInt(32), Te = BigInt(4294967295), Me = Number(Ie >> Pe & Te), Ue = Number(Ie & Te), je = Be ? 4 : 0, fn = Be ? 0 : 4;
  Ae.setUint32(t + je, Me, Be), Ae.setUint32(t + fn, Ue, Be);
}
const Chi$1 = (Ae, t, Ie) => Ae & t ^ ~Ae & Ie, Maj$1 = (Ae, t, Ie) => Ae & t ^ Ae & Ie ^ t & Ie;
class HashMD extends Hash$1 {
  constructor(t, Ie, Be, Pe) {
    super(), this.blockLen = t, this.outputLen = Ie, this.padOffset = Be, this.isLE = Pe, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = createView$1(this.buffer);
  }
  update(t) {
    exists$1(this);
    const { view: Ie, buffer: Be, blockLen: Pe } = this;
    t = toBytes$1(t);
    const Te = t.length;
    for (let Me = 0; Me < Te; ) {
      const Ue = Math.min(Pe - this.pos, Te - Me);
      if (Ue === Pe) {
        const je = createView$1(t);
        for (; Pe <= Te - Me; Me += Pe)
          this.process(je, Me);
        continue;
      }
      Be.set(t.subarray(Me, Me + Ue), this.pos), this.pos += Ue, Me += Ue, this.pos === Pe && (this.process(Ie, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    exists$1(this), output$1(t, this), this.finished = !0;
    const { buffer: Ie, view: Be, blockLen: Pe, isLE: Te } = this;
    let { pos: Me } = this;
    Ie[Me++] = 128, this.buffer.subarray(Me).fill(0), this.padOffset > Pe - Me && (this.process(Be, 0), Me = 0);
    for (let vn = Me; vn < Pe; vn++)
      Ie[vn] = 0;
    setBigUint64$1(Be, Pe - 8, BigInt(this.length * 8), Te), this.process(Be, 0);
    const Ue = createView$1(t), je = this.outputLen;
    if (je % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const fn = je / 4, Ve = this.get();
    if (fn > Ve.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let vn = 0; vn < fn; vn++)
      Ue.setUint32(4 * vn, Ve[vn], Te);
  }
  digest() {
    const { buffer: t, outputLen: Ie } = this;
    this.digestInto(t);
    const Be = t.slice(0, Ie);
    return this.destroy(), Be;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: Ie, buffer: Be, length: Pe, finished: Te, destroyed: Me, pos: Ue } = this;
    return t.length = Pe, t.pos = Ue, t.finished = Te, t.destroyed = Me, Pe % Ie && t.buffer.set(Be), t;
  }
}
const SHA256_K$1 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W$1 = /* @__PURE__ */ new Uint32Array(64);
let SHA256$1 = class extends HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = SHA256_IV[0] | 0, this.B = SHA256_IV[1] | 0, this.C = SHA256_IV[2] | 0, this.D = SHA256_IV[3] | 0, this.E = SHA256_IV[4] | 0, this.F = SHA256_IV[5] | 0, this.G = SHA256_IV[6] | 0, this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: t, B: Ie, C: Be, D: Pe, E: Te, F: Me, G: Ue, H: je } = this;
    return [t, Ie, Be, Pe, Te, Me, Ue, je];
  }
  // prettier-ignore
  set(t, Ie, Be, Pe, Te, Me, Ue, je) {
    this.A = t | 0, this.B = Ie | 0, this.C = Be | 0, this.D = Pe | 0, this.E = Te | 0, this.F = Me | 0, this.G = Ue | 0, this.H = je | 0;
  }
  process(t, Ie) {
    for (let vn = 0; vn < 16; vn++, Ie += 4)
      SHA256_W$1[vn] = t.getUint32(Ie, !1);
    for (let vn = 16; vn < 64; vn++) {
      const En = SHA256_W$1[vn - 15], fi = SHA256_W$1[vn - 2], bi = rotr$1(En, 7) ^ rotr$1(En, 18) ^ En >>> 3, mi = rotr$1(fi, 17) ^ rotr$1(fi, 19) ^ fi >>> 10;
      SHA256_W$1[vn] = mi + SHA256_W$1[vn - 7] + bi + SHA256_W$1[vn - 16] | 0;
    }
    let { A: Be, B: Pe, C: Te, D: Me, E: Ue, F: je, G: fn, H: Ve } = this;
    for (let vn = 0; vn < 64; vn++) {
      const En = rotr$1(Ue, 6) ^ rotr$1(Ue, 11) ^ rotr$1(Ue, 25), fi = Ve + En + Chi$1(Ue, je, fn) + SHA256_K$1[vn] + SHA256_W$1[vn] | 0, mi = (rotr$1(Be, 2) ^ rotr$1(Be, 13) ^ rotr$1(Be, 22)) + Maj$1(Be, Pe, Te) | 0;
      Ve = fn, fn = je, je = Ue, Ue = Me + fi | 0, Me = Te, Te = Pe, Pe = Be, Be = fi + mi | 0;
    }
    Be = Be + this.A | 0, Pe = Pe + this.B | 0, Te = Te + this.C | 0, Me = Me + this.D | 0, Ue = Ue + this.E | 0, je = je + this.F | 0, fn = fn + this.G | 0, Ve = Ve + this.H | 0, this.set(Be, Pe, Te, Me, Ue, je, fn, Ve);
  }
  roundClean() {
    SHA256_W$1.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const sha256$4 = /* @__PURE__ */ wrapConstructor$1(() => new SHA256$1());
function sha256$3(Ae, t) {
  return sha256$4(isHex(Ae, { strict: !1 }) ? toBytes$2(Ae) : Ae);
}
function commitmentToVersionedHash(Ae) {
  const { commitment: t, version: Ie = 1 } = Ae, Be = Ae.to ?? (typeof t == "string" ? "hex" : "bytes"), Pe = sha256$3(t);
  return Pe.set([Ie], 0), Be === "bytes" ? Pe : bytesToHex$2(Pe);
}
function commitmentsToVersionedHashes(Ae) {
  const { commitments: t, version: Ie } = Ae, Be = Ae.to ?? (typeof t[0] == "string" ? "hex" : "bytes"), Pe = [];
  for (const Te of t)
    Pe.push(commitmentToVersionedHash({
      commitment: Te,
      to: Be,
      version: Ie
    }));
  return Pe;
}
const blobsPerTransaction = 6, bytesPerFieldElement = 32, fieldElementsPerBlob = 4096, bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob, maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;
class BlobSizeTooLargeError extends BaseError$1 {
  constructor({ maxSize: t, size: Ie }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${t} bytes`, `Given: ${Ie} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
}
class EmptyBlobError extends BaseError$1 {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}
function toBlobs(Ae) {
  const t = Ae.to ?? (typeof Ae.data == "string" ? "hex" : "bytes"), Ie = typeof Ae.data == "string" ? hexToBytes$2(Ae.data) : Ae.data, Be = size$1(Ie);
  if (!Be)
    throw new EmptyBlobError();
  if (Be > maxBytesPerTransaction)
    throw new BlobSizeTooLargeError({
      maxSize: maxBytesPerTransaction,
      size: Be
    });
  const Pe = [];
  let Te = !0, Me = 0;
  for (; Te; ) {
    const Ue = createCursor(new Uint8Array(bytesPerBlob));
    let je = 0;
    for (; je < fieldElementsPerBlob; ) {
      const fn = Ie.slice(Me, Me + (bytesPerFieldElement - 1));
      if (Ue.pushByte(0), Ue.pushBytes(fn), fn.length < 31) {
        Ue.pushByte(128), Te = !1;
        break;
      }
      je++, Me += 31;
    }
    Pe.push(Ue);
  }
  return t === "bytes" ? Pe.map((Ue) => Ue.bytes) : Pe.map((Ue) => bytesToHex$2(Ue.bytes));
}
function toBlobSidecars(Ae) {
  const { data: t, kzg: Ie, to: Be } = Ae, Pe = Ae.blobs ?? toBlobs({ data: t, to: Be }), Te = Ae.commitments ?? blobsToCommitments({ blobs: Pe, kzg: Ie, to: Be }), Me = Ae.proofs ?? blobsToProofs({ blobs: Pe, commitments: Te, kzg: Ie, to: Be }), Ue = [];
  for (let je = 0; je < Pe.length; je++)
    Ue.push({
      blob: Pe[je],
      commitment: Te[je],
      proof: Me[je]
    });
  return Ue;
}
class InvalidAddressError extends BaseError$1 {
  constructor({ address: t }) {
    super(`Address "${t}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
}
class ChainDoesNotSupportContract extends BaseError$1 {
  constructor({ blockNumber: t, chain: Ie, contract: Be }) {
    super(`Chain "${Ie.name}" does not support contract "${Be.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...t && Be.blockCreated && Be.blockCreated > t ? [
          `- The contract "${Be.name}" was not deployed until block ${Be.blockCreated} (current block ${t}).`
        ] : [
          `- The chain does not have the contract "${Be.name}" configured.`
        ]
      ],
      name: "ChainDoesNotSupportContract"
    });
  }
}
class ChainMismatchError extends BaseError$1 {
  constructor({ chain: t, currentChainId: Ie }) {
    super(`The current chain of the wallet (id: ${Ie}) does not match the target chain for the transaction (id: ${t.id}  ${t.name}).`, {
      metaMessages: [
        `Current Chain ID:  ${Ie}`,
        `Expected Chain ID: ${t.id}  ${t.name}`
      ],
      name: "ChainMismatchError"
    });
  }
}
class ChainNotFoundError extends BaseError$1 {
  constructor() {
    super([
      "No chain was provided to the request.",
      "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
    ].join(`
`), {
      name: "ChainNotFoundError"
    });
  }
}
class ClientChainNotConfiguredError extends BaseError$1 {
  constructor() {
    super("No chain was provided to the Client.", {
      name: "ClientChainNotConfiguredError"
    });
  }
}
class ExecutionRevertedError extends BaseError$1 {
  constructor({ cause: t, message: Ie } = {}) {
    var Pe;
    const Be = (Pe = Ie == null ? void 0 : Ie.replace("execution reverted: ", "")) == null ? void 0 : Pe.replace("execution reverted", "");
    super(`Execution reverted ${Be ? `with reason: ${Be}` : "for an unknown reason"}.`, {
      cause: t,
      name: "ExecutionRevertedError"
    });
  }
}
Object.defineProperty(ExecutionRevertedError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3
});
Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class FeeCapTooHighError extends BaseError$1 {
  constructor({ cause: t, maxFeePerGas: Ie } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${Ie ? ` = ${formatGwei(Ie)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: t,
      name: "FeeCapTooHighError"
    });
  }
}
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class FeeCapTooLowError extends BaseError$1 {
  constructor({ cause: t, maxFeePerGas: Ie } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${Ie ? ` = ${formatGwei(Ie)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause: t,
      name: "FeeCapTooLowError"
    });
  }
}
Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class NonceTooHighError extends BaseError$1 {
  constructor({ cause: t, nonce: Ie } = {}) {
    super(`Nonce provided for the transaction ${Ie ? `(${Ie}) ` : ""}is higher than the next one expected.`, { cause: t, name: "NonceTooHighError" });
  }
}
Object.defineProperty(NonceTooHighError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/
});
class NonceTooLowError extends BaseError$1 {
  constructor({ cause: t, nonce: Ie } = {}) {
    super([
      `Nonce provided for the transaction ${Ie ? `(${Ie}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join(`
`), { cause: t, name: "NonceTooLowError" });
  }
}
Object.defineProperty(NonceTooLowError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/
});
class NonceMaxValueError extends BaseError$1 {
  constructor({ cause: t, nonce: Ie } = {}) {
    super(`Nonce provided for the transaction ${Ie ? `(${Ie}) ` : ""}exceeds the maximum allowed nonce.`, { cause: t, name: "NonceMaxValueError" });
  }
}
Object.defineProperty(NonceMaxValueError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/
});
class InsufficientFundsError extends BaseError$1 {
  constructor({ cause: t } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join(`
`), {
      cause: t,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ],
      name: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(InsufficientFundsError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds|exceeds transaction sender account balance/
});
class IntrinsicGasTooHighError extends BaseError$1 {
  constructor({ cause: t, gas: Ie } = {}) {
    super(`The amount of gas ${Ie ? `(${Ie}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause: t,
      name: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/
});
class IntrinsicGasTooLowError extends BaseError$1 {
  constructor({ cause: t, gas: Ie } = {}) {
    super(`The amount of gas ${Ie ? `(${Ie}) ` : ""}provided for the transaction is too low.`, {
      cause: t,
      name: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/
});
class TransactionTypeNotSupportedError extends BaseError$1 {
  constructor({ cause: t }) {
    super("The transaction type is not supported for this chain.", {
      cause: t,
      name: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/
});
class TipAboveFeeCapError extends BaseError$1 {
  constructor({ cause: t, maxPriorityFeePerGas: Ie, maxFeePerGas: Be } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${Ie ? ` = ${formatGwei(Ie)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${Be ? ` = ${formatGwei(Be)} gwei` : ""}).`
    ].join(`
`), {
      cause: t,
      name: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class UnknownNodeError extends BaseError$1 {
  constructor({ cause: t }) {
    super(`An error occurred while executing: ${t == null ? void 0 : t.shortMessage}`, {
      cause: t,
      name: "UnknownNodeError"
    });
  }
}
class LruMap extends Map {
  constructor(t) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = t;
  }
  get(t) {
    const Ie = super.get(t);
    return super.has(t) && Ie !== void 0 && (this.delete(t), super.set(t, Ie)), Ie;
  }
  set(t, Ie) {
    if (super.set(t, Ie), this.maxSize && this.size > this.maxSize) {
      const Be = this.keys().next().value;
      Be && this.delete(Be);
    }
    return this;
  }
}
const U32_MASK64$1 = /* @__PURE__ */ BigInt(2 ** 32 - 1), _32n$1 = /* @__PURE__ */ BigInt(32);
function fromBig$1(Ae, t = !1) {
  return t ? { h: Number(Ae & U32_MASK64$1), l: Number(Ae >> _32n$1 & U32_MASK64$1) } : { h: Number(Ae >> _32n$1 & U32_MASK64$1) | 0, l: Number(Ae & U32_MASK64$1) | 0 };
}
function split$1(Ae, t = !1) {
  let Ie = new Uint32Array(Ae.length), Be = new Uint32Array(Ae.length);
  for (let Pe = 0; Pe < Ae.length; Pe++) {
    const { h: Te, l: Me } = fromBig$1(Ae[Pe], t);
    [Ie[Pe], Be[Pe]] = [Te, Me];
  }
  return [Ie, Be];
}
const rotlSH$1 = (Ae, t, Ie) => Ae << Ie | t >>> 32 - Ie, rotlSL$1 = (Ae, t, Ie) => t << Ie | Ae >>> 32 - Ie, rotlBH$1 = (Ae, t, Ie) => t << Ie - 32 | Ae >>> 64 - Ie, rotlBL$1 = (Ae, t, Ie) => Ae << Ie - 32 | t >>> 64 - Ie, SHA3_PI$1 = [], SHA3_ROTL$1 = [], _SHA3_IOTA$1 = [], _0n$9 = /* @__PURE__ */ BigInt(0), _1n$b = /* @__PURE__ */ BigInt(1), _2n$7 = /* @__PURE__ */ BigInt(2), _7n$1 = /* @__PURE__ */ BigInt(7), _256n$1 = /* @__PURE__ */ BigInt(256), _0x71n$1 = /* @__PURE__ */ BigInt(113);
for (let Ae = 0, t = _1n$b, Ie = 1, Be = 0; Ae < 24; Ae++) {
  [Ie, Be] = [Be, (2 * Ie + 3 * Be) % 5], SHA3_PI$1.push(2 * (5 * Be + Ie)), SHA3_ROTL$1.push((Ae + 1) * (Ae + 2) / 2 % 64);
  let Pe = _0n$9;
  for (let Te = 0; Te < 7; Te++)
    t = (t << _1n$b ^ (t >> _7n$1) * _0x71n$1) % _256n$1, t & _2n$7 && (Pe ^= _1n$b << (_1n$b << /* @__PURE__ */ BigInt(Te)) - _1n$b);
  _SHA3_IOTA$1.push(Pe);
}
const [SHA3_IOTA_H$1, SHA3_IOTA_L$1] = /* @__PURE__ */ split$1(_SHA3_IOTA$1, !0), rotlH$1 = (Ae, t, Ie) => Ie > 32 ? rotlBH$1(Ae, t, Ie) : rotlSH$1(Ae, t, Ie), rotlL$1 = (Ae, t, Ie) => Ie > 32 ? rotlBL$1(Ae, t, Ie) : rotlSL$1(Ae, t, Ie);
function keccakP$1(Ae, t = 24) {
  const Ie = new Uint32Array(10);
  for (let Be = 24 - t; Be < 24; Be++) {
    for (let Me = 0; Me < 10; Me++)
      Ie[Me] = Ae[Me] ^ Ae[Me + 10] ^ Ae[Me + 20] ^ Ae[Me + 30] ^ Ae[Me + 40];
    for (let Me = 0; Me < 10; Me += 2) {
      const Ue = (Me + 8) % 10, je = (Me + 2) % 10, fn = Ie[je], Ve = Ie[je + 1], vn = rotlH$1(fn, Ve, 1) ^ Ie[Ue], En = rotlL$1(fn, Ve, 1) ^ Ie[Ue + 1];
      for (let fi = 0; fi < 50; fi += 10)
        Ae[Me + fi] ^= vn, Ae[Me + fi + 1] ^= En;
    }
    let Pe = Ae[2], Te = Ae[3];
    for (let Me = 0; Me < 24; Me++) {
      const Ue = SHA3_ROTL$1[Me], je = rotlH$1(Pe, Te, Ue), fn = rotlL$1(Pe, Te, Ue), Ve = SHA3_PI$1[Me];
      Pe = Ae[Ve], Te = Ae[Ve + 1], Ae[Ve] = je, Ae[Ve + 1] = fn;
    }
    for (let Me = 0; Me < 50; Me += 10) {
      for (let Ue = 0; Ue < 10; Ue++)
        Ie[Ue] = Ae[Me + Ue];
      for (let Ue = 0; Ue < 10; Ue++)
        Ae[Me + Ue] ^= ~Ie[(Ue + 2) % 10] & Ie[(Ue + 4) % 10];
    }
    Ae[0] ^= SHA3_IOTA_H$1[Be], Ae[1] ^= SHA3_IOTA_L$1[Be];
  }
  Ie.fill(0);
}
let Keccak$1 = class Gc extends Hash$1 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, Ie, Be, Pe = !1, Te = 24) {
    if (super(), this.blockLen = t, this.suffix = Ie, this.outputLen = Be, this.enableXOF = Pe, this.rounds = Te, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, number$1(Be), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = u32$1(this.state);
  }
  keccak() {
    isLE$1 || byteSwap32(this.state32), keccakP$1(this.state32, this.rounds), isLE$1 || byteSwap32(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    exists$1(this);
    const { blockLen: Ie, state: Be } = this;
    t = toBytes$1(t);
    const Pe = t.length;
    for (let Te = 0; Te < Pe; ) {
      const Me = Math.min(Ie - this.pos, Pe - Te);
      for (let Ue = 0; Ue < Me; Ue++)
        Be[this.pos++] ^= t[Te++];
      this.pos === Ie && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: Ie, pos: Be, blockLen: Pe } = this;
    t[Be] ^= Ie, Ie & 128 && Be === Pe - 1 && this.keccak(), t[Pe - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    exists$1(this, !1), bytes$1(t), this.finish();
    const Ie = this.state, { blockLen: Be } = this;
    for (let Pe = 0, Te = t.length; Pe < Te; ) {
      this.posOut >= Be && this.keccak();
      const Me = Math.min(Be - this.posOut, Te - Pe);
      t.set(Ie.subarray(this.posOut, this.posOut + Me), Pe), this.posOut += Me, Pe += Me;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return number$1(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (output$1(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: Ie, suffix: Be, outputLen: Pe, rounds: Te, enableXOF: Me } = this;
    return t || (t = new Gc(Ie, Be, Pe, Me, Te)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = Te, t.suffix = Be, t.outputLen = Pe, t.enableXOF = Me, t.destroyed = this.destroyed, t;
  }
};
const gen$1 = (Ae, t, Ie) => wrapConstructor$1(() => new Keccak$1(t, Ae, Ie)), keccak_256$1 = /* @__PURE__ */ gen$1(1, 136, 256 / 8);
function keccak256$2(Ae, t) {
  const Ie = t || "hex", Be = keccak_256$1(isHex(Ae, { strict: !1 }) ? toBytes$2(Ae) : Ae);
  return Ie === "bytes" ? Be : toHex(Be);
}
const checksumAddressCache = /* @__PURE__ */ new LruMap(8192);
function checksumAddress(Ae, t) {
  if (checksumAddressCache.has(`${Ae}.${t}`))
    return checksumAddressCache.get(`${Ae}.${t}`);
  const Ie = Ae.substring(2).toLowerCase(), Be = keccak256$2(stringToBytes(Ie), "bytes"), Pe = Ie.split("");
  for (let Me = 0; Me < 40; Me += 2)
    Be[Me >> 1] >> 4 >= 8 && Pe[Me] && (Pe[Me] = Pe[Me].toUpperCase()), (Be[Me >> 1] & 15) >= 8 && Pe[Me + 1] && (Pe[Me + 1] = Pe[Me + 1].toUpperCase());
  const Te = `0x${Pe.join("")}`;
  return checksumAddressCache.set(`${Ae}.${t}`, Te), Te;
}
function getAddress$2(Ae, t) {
  if (!isAddress(Ae, { strict: !1 }))
    throw new InvalidAddressError({ address: Ae });
  return checksumAddress(Ae, t);
}
const addressRegex = /^0x[a-fA-F0-9]{40}$/, isAddressCache = /* @__PURE__ */ new LruMap(8192);
function isAddress(Ae, t) {
  const { strict: Ie = !0 } = t ?? {}, Be = `${Ae}.${Ie}`;
  if (isAddressCache.has(Be))
    return isAddressCache.get(Be);
  const Pe = addressRegex.test(Ae) ? Ae.toLowerCase() === Ae ? !0 : Ie ? checksumAddress(Ae) === Ae : !0 : !1;
  return isAddressCache.set(Be, Pe), Pe;
}
function slice(Ae, t, Ie, { strict: Be } = {}) {
  return isHex(Ae, { strict: !1 }) ? sliceHex(Ae, t, Ie, {
    strict: Be
  }) : sliceBytes(Ae, t, Ie, {
    strict: Be
  });
}
function assertStartOffset(Ae, t) {
  if (typeof t == "number" && t > 0 && t > size$1(Ae) - 1)
    throw new SliceOffsetOutOfBoundsError({
      offset: t,
      position: "start",
      size: size$1(Ae)
    });
}
function assertEndOffset(Ae, t, Ie) {
  if (typeof t == "number" && typeof Ie == "number" && size$1(Ae) !== Ie - t)
    throw new SliceOffsetOutOfBoundsError({
      offset: Ie,
      position: "end",
      size: size$1(Ae)
    });
}
function sliceBytes(Ae, t, Ie, { strict: Be } = {}) {
  assertStartOffset(Ae, t);
  const Pe = Ae.slice(t, Ie);
  return Be && assertEndOffset(Pe, t, Ie), Pe;
}
function sliceHex(Ae, t, Ie, { strict: Be } = {}) {
  assertStartOffset(Ae, t);
  const Pe = `0x${Ae.replace("0x", "").slice((t ?? 0) * 2, (Ie ?? Ae.length) * 2)}`;
  return Be && assertEndOffset(Pe, t, Ie), Pe;
}
function getTransactionType(Ae) {
  if (Ae.type)
    return Ae.type;
  if (typeof Ae.authorizationList < "u")
    return "eip7702";
  if (typeof Ae.blobs < "u" || typeof Ae.blobVersionedHashes < "u" || typeof Ae.maxFeePerBlobGas < "u" || typeof Ae.sidecars < "u")
    return "eip4844";
  if (typeof Ae.maxFeePerGas < "u" || typeof Ae.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof Ae.gasPrice < "u")
    return typeof Ae.accessList < "u" ? "eip2930" : "legacy";
  throw new InvalidSerializableTransactionError({ transaction: Ae });
}
function assertCurrentChain({ chain: Ae, currentChainId: t }) {
  if (!Ae)
    throw new ChainNotFoundError();
  if (t !== Ae.id)
    throw new ChainMismatchError({ chain: Ae, currentChainId: t });
}
function getChainContractAddress({ blockNumber: Ae, chain: t, contract: Ie }) {
  var Pe;
  const Be = (Pe = t == null ? void 0 : t.contracts) == null ? void 0 : Pe[Ie];
  if (!Be)
    throw new ChainDoesNotSupportContract({
      chain: t,
      contract: { name: Ie }
    });
  if (Ae && Be.blockCreated && Be.blockCreated > Ae)
    throw new ChainDoesNotSupportContract({
      blockNumber: Ae,
      chain: t,
      contract: {
        name: Ie,
        blockCreated: Be.blockCreated
      }
    });
  return Be.address;
}
function parseAccount(Ae) {
  return typeof Ae == "string" ? { address: Ae, type: "json-rpc" } : Ae;
}
class BaseFeeScalarError extends BaseError$1 {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError"
    });
  }
}
class Eip1559FeesNotSupportedError extends BaseError$1 {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError"
    });
  }
}
class MaxFeePerGasTooLowError extends BaseError$1 {
  constructor({ maxPriorityFeePerGas: t }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(t)} gwei).`, { name: "MaxFeePerGasTooLowError" });
  }
}
function getAction(Ae, t, Ie) {
  const Be = Ae[t.name];
  if (typeof Be == "function")
    return Be;
  const Pe = Ae[Ie];
  return typeof Pe == "function" ? Pe : (Te) => t(Ae, Te);
}
class BlockNotFoundError extends BaseError$1 {
  constructor({ blockHash: t, blockNumber: Ie }) {
    let Be = "Block";
    t && (Be = `Block at hash "${t}"`), Ie && (Be = `Block at number "${Ie}"`), super(`${Be} could not be found.`, { name: "BlockNotFoundError" });
  }
}
async function getBlock(Ae, { blockHash: t, blockNumber: Ie, blockTag: Be, includeTransactions: Pe } = {}) {
  var Ve, vn, En;
  const Te = Be ?? "latest", Me = Pe ?? !1, Ue = Ie !== void 0 ? numberToHex(Ie) : void 0;
  let je = null;
  if (t ? je = await Ae.request({
    method: "eth_getBlockByHash",
    params: [t, Me]
  }, { dedupe: !0 }) : je = await Ae.request({
    method: "eth_getBlockByNumber",
    params: [Ue || Te, Me]
  }, { dedupe: !!Ue }), !je)
    throw new BlockNotFoundError({ blockHash: t, blockNumber: Ie });
  return (((En = (vn = (Ve = Ae.chain) == null ? void 0 : Ve.formatters) == null ? void 0 : vn.block) == null ? void 0 : En.format) || formatBlock)(je);
}
async function getGasPrice(Ae) {
  const t = await Ae.request({
    method: "eth_gasPrice"
  });
  return BigInt(t);
}
async function estimateMaxPriorityFeePerGas(Ae, t) {
  return internal_estimateMaxPriorityFeePerGas(Ae, t);
}
async function internal_estimateMaxPriorityFeePerGas(Ae, t) {
  var Te, Me;
  const { block: Ie, chain: Be = Ae.chain, request: Pe } = t || {};
  try {
    const Ue = ((Te = Be == null ? void 0 : Be.fees) == null ? void 0 : Te.maxPriorityFeePerGas) ?? ((Me = Be == null ? void 0 : Be.fees) == null ? void 0 : Me.defaultPriorityFee);
    if (typeof Ue == "function") {
      const fn = Ie || await getAction(Ae, getBlock, "getBlock")({}), Ve = await Ue({
        block: fn,
        client: Ae,
        request: Pe
      });
      if (Ve === null)
        throw new Error();
      return Ve;
    }
    if (typeof Ue < "u")
      return Ue;
    const je = await Ae.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return hexToBigInt(je);
  } catch {
    const [Ue, je] = await Promise.all([
      Ie ? Promise.resolve(Ie) : getAction(Ae, getBlock, "getBlock")({}),
      getAction(Ae, getGasPrice, "getGasPrice")({})
    ]);
    if (typeof Ue.baseFeePerGas != "bigint")
      throw new Eip1559FeesNotSupportedError();
    const fn = je - Ue.baseFeePerGas;
    return fn < 0n ? 0n : fn;
  }
}
async function estimateFeesPerGas(Ae, t) {
  return internal_estimateFeesPerGas(Ae, t);
}
async function internal_estimateFeesPerGas(Ae, t) {
  var En, fi;
  const { block: Ie, chain: Be = Ae.chain, request: Pe, type: Te = "eip1559" } = t || {}, Me = await (async () => {
    var bi, mi;
    return typeof ((bi = Be == null ? void 0 : Be.fees) == null ? void 0 : bi.baseFeeMultiplier) == "function" ? Be.fees.baseFeeMultiplier({
      block: Ie,
      client: Ae,
      request: Pe
    }) : ((mi = Be == null ? void 0 : Be.fees) == null ? void 0 : mi.baseFeeMultiplier) ?? 1.2;
  })();
  if (Me < 1)
    throw new BaseFeeScalarError();
  const je = 10 ** (((En = Me.toString().split(".")[1]) == null ? void 0 : En.length) ?? 0), fn = (bi) => bi * BigInt(Math.ceil(Me * je)) / BigInt(je), Ve = Ie || await getAction(Ae, getBlock, "getBlock")({});
  if (typeof ((fi = Be == null ? void 0 : Be.fees) == null ? void 0 : fi.estimateFeesPerGas) == "function") {
    const bi = await Be.fees.estimateFeesPerGas({
      block: Ie,
      client: Ae,
      multiply: fn,
      request: Pe,
      type: Te
    });
    if (bi !== null)
      return bi;
  }
  if (Te === "eip1559") {
    if (typeof Ve.baseFeePerGas != "bigint")
      throw new Eip1559FeesNotSupportedError();
    const bi = typeof (Pe == null ? void 0 : Pe.maxPriorityFeePerGas) == "bigint" ? Pe.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(Ae, {
      block: Ve,
      chain: Be,
      request: Pe
    }), mi = fn(Ve.baseFeePerGas);
    return {
      maxFeePerGas: (Pe == null ? void 0 : Pe.maxFeePerGas) ?? mi + bi,
      maxPriorityFeePerGas: bi
    };
  }
  return {
    gasPrice: (Pe == null ? void 0 : Pe.gasPrice) ?? fn(await getAction(Ae, getGasPrice, "getGasPrice")({}))
  };
}
function publicKeyToAddress(Ae) {
  const t = keccak256$2(`0x${Ae.substring(4)}`).substring(26);
  return checksumAddress(`0x${t}`);
}
async function recoverPublicKey$1({ hash: Ae, signature: t }) {
  const Ie = isHex(Ae) ? Ae : toHex(Ae), { secp256k1: Be } = await Promise.resolve().then(() => secp256k1$1);
  return `0x${(() => {
    if (typeof t == "object" && "r" in t && "s" in t) {
      const { r: fn, s: Ve, v: vn, yParity: En } = t, fi = Number(En ?? vn), bi = toRecoveryBit(fi);
      return new Be.Signature(hexToBigInt(fn), hexToBigInt(Ve)).addRecoveryBit(bi);
    }
    const Me = isHex(t) ? t : toHex(t), Ue = hexToNumber$2(`0x${Me.slice(130)}`), je = toRecoveryBit(Ue);
    return Be.Signature.fromCompact(Me.substring(2, 130)).addRecoveryBit(je);
  })().recoverPublicKey(Ie.substring(2)).toHex(!1)}`;
}
function toRecoveryBit(Ae) {
  if (Ae === 0 || Ae === 1)
    return Ae;
  if (Ae === 27)
    return 0;
  if (Ae === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}
async function recoverAddress$2({ hash: Ae, signature: t }) {
  return publicKeyToAddress(await recoverPublicKey$1({ hash: Ae, signature: t }));
}
function hashAuthorization(Ae) {
  const { chainId: t, contractAddress: Ie, nonce: Be, to: Pe } = Ae, Te = keccak256$2(concatHex([
    "0x05",
    toRlp([
      t ? numberToHex(t) : "0x",
      Ie,
      Be ? numberToHex(Be) : "0x"
    ])
  ]));
  return Pe === "bytes" ? hexToBytes$2(Te) : Te;
}
async function recoverAuthorizationAddress(Ae) {
  const { authorization: t, signature: Ie } = Ae;
  return recoverAddress$2({
    hash: hashAuthorization(t),
    signature: Ie ?? t
  });
}
class EstimateGasExecutionError extends BaseError$1 {
  constructor(t, { account: Ie, docsPath: Be, chain: Pe, data: Te, gas: Me, gasPrice: Ue, maxFeePerGas: je, maxPriorityFeePerGas: fn, nonce: Ve, to: vn, value: En }) {
    var bi;
    const fi = prettyPrint({
      from: Ie == null ? void 0 : Ie.address,
      to: vn,
      value: typeof En < "u" && `${formatEther(En)} ${((bi = Pe == null ? void 0 : Pe.nativeCurrency) == null ? void 0 : bi.symbol) || "ETH"}`,
      data: Te,
      gas: Me,
      gasPrice: typeof Ue < "u" && `${formatGwei(Ue)} gwei`,
      maxFeePerGas: typeof je < "u" && `${formatGwei(je)} gwei`,
      maxPriorityFeePerGas: typeof fn < "u" && `${formatGwei(fn)} gwei`,
      nonce: Ve
    });
    super(t.shortMessage, {
      cause: t,
      docsPath: Be,
      metaMessages: [
        ...t.metaMessages ? [...t.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        fi
      ].filter(Boolean),
      name: "EstimateGasExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = t;
  }
}
const stringify$2 = (Ae, t, Ie) => JSON.stringify(Ae, (Be, Pe) => typeof Pe == "bigint" ? Pe.toString() : Pe, Ie), getContractAddress = (Ae) => Ae, getUrl = (Ae) => Ae;
class HttpRequestError extends BaseError$1 {
  constructor({ body: t, cause: Ie, details: Be, headers: Pe, status: Te, url: Me }) {
    super("HTTP request failed.", {
      cause: Ie,
      details: Be,
      metaMessages: [
        Te && `Status: ${Te}`,
        `URL: ${getUrl(Me)}`,
        t && `Request body: ${stringify$2(t)}`
      ].filter(Boolean),
      name: "HttpRequestError"
    }), Object.defineProperty(this, "body", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "url", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.body = t, this.headers = Pe, this.status = Te, this.url = Me;
  }
}
class RpcRequestError extends BaseError$1 {
  constructor({ body: t, error: Ie, url: Be }) {
    super("RPC Request failed.", {
      cause: Ie,
      details: Ie.message,
      metaMessages: [`URL: ${getUrl(Be)}`, `Request body: ${stringify$2(t)}`],
      name: "RpcRequestError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.code = Ie.code;
  }
}
class TimeoutError extends BaseError$1 {
  constructor({ body: t, url: Ie }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${getUrl(Ie)}`, `Request body: ${stringify$2(t)}`],
      name: "TimeoutError"
    });
  }
}
const unknownErrorCode = -1;
class RpcError extends BaseError$1 {
  constructor(t, { code: Ie, docsPath: Be, metaMessages: Pe, name: Te, shortMessage: Me }) {
    super(Me, {
      cause: t,
      docsPath: Be,
      metaMessages: Pe || (t == null ? void 0 : t.metaMessages),
      name: Te || "RpcError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = Te || t.name, this.code = t instanceof RpcRequestError ? t.code : Ie ?? unknownErrorCode;
  }
}
class ProviderRpcError extends RpcError {
  constructor(t, Ie) {
    super(t, Ie), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = Ie.data;
  }
}
class ParseRpcError extends RpcError {
  constructor(t) {
    super(t, {
      code: ParseRpcError.code,
      name: "ParseRpcError",
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    });
  }
}
Object.defineProperty(ParseRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32700
});
class InvalidRequestRpcError extends RpcError {
  constructor(t) {
    super(t, {
      code: InvalidRequestRpcError.code,
      name: "InvalidRequestRpcError",
      shortMessage: "JSON is not a valid request object."
    });
  }
}
Object.defineProperty(InvalidRequestRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32600
});
class MethodNotFoundRpcError extends RpcError {
  constructor(t, { method: Ie } = {}) {
    super(t, {
      code: MethodNotFoundRpcError.code,
      name: "MethodNotFoundRpcError",
      shortMessage: `The method${Ie ? ` "${Ie}"` : ""} does not exist / is not available.`
    });
  }
}
Object.defineProperty(MethodNotFoundRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32601
});
class InvalidParamsRpcError extends RpcError {
  constructor(t) {
    super(t, {
      code: InvalidParamsRpcError.code,
      name: "InvalidParamsRpcError",
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    });
  }
}
Object.defineProperty(InvalidParamsRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602
});
class InternalRpcError extends RpcError {
  constructor(t) {
    super(t, {
      code: InternalRpcError.code,
      name: "InternalRpcError",
      shortMessage: "An internal error was received."
    });
  }
}
Object.defineProperty(InternalRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603
});
class InvalidInputRpcError extends RpcError {
  constructor(t) {
    super(t, {
      code: InvalidInputRpcError.code,
      name: "InvalidInputRpcError",
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    });
  }
}
Object.defineProperty(InvalidInputRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32e3
});
class ResourceNotFoundRpcError extends RpcError {
  constructor(t) {
    super(t, {
      code: ResourceNotFoundRpcError.code,
      name: "ResourceNotFoundRpcError",
      shortMessage: "Requested resource not found."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty(ResourceNotFoundRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32001
});
class ResourceUnavailableRpcError extends RpcError {
  constructor(t) {
    super(t, {
      code: ResourceUnavailableRpcError.code,
      name: "ResourceUnavailableRpcError",
      shortMessage: "Requested resource not available."
    });
  }
}
Object.defineProperty(ResourceUnavailableRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32002
});
class TransactionRejectedRpcError extends RpcError {
  constructor(t) {
    super(t, {
      code: TransactionRejectedRpcError.code,
      name: "TransactionRejectedRpcError",
      shortMessage: "Transaction creation failed."
    });
  }
}
Object.defineProperty(TransactionRejectedRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32003
});
class MethodNotSupportedRpcError extends RpcError {
  constructor(t, { method: Ie } = {}) {
    super(t, {
      code: MethodNotSupportedRpcError.code,
      name: "MethodNotSupportedRpcError",
      shortMessage: `Method${Ie ? ` "${Ie}"` : ""} is not implemented.`
    });
  }
}
Object.defineProperty(MethodNotSupportedRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32004
});
class LimitExceededRpcError extends RpcError {
  constructor(t) {
    super(t, {
      code: LimitExceededRpcError.code,
      name: "LimitExceededRpcError",
      shortMessage: "Request exceeds defined limit."
    });
  }
}
Object.defineProperty(LimitExceededRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32005
});
class JsonRpcVersionUnsupportedError extends RpcError {
  constructor(t) {
    super(t, {
      code: JsonRpcVersionUnsupportedError.code,
      name: "JsonRpcVersionUnsupportedError",
      shortMessage: "Version of JSON-RPC protocol is not supported."
    });
  }
}
Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32006
});
class UserRejectedRequestError extends ProviderRpcError {
  constructor(t) {
    super(t, {
      code: UserRejectedRequestError.code,
      name: "UserRejectedRequestError",
      shortMessage: "User rejected the request."
    });
  }
}
Object.defineProperty(UserRejectedRequestError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4001
});
class UnauthorizedProviderError extends ProviderRpcError {
  constructor(t) {
    super(t, {
      code: UnauthorizedProviderError.code,
      name: "UnauthorizedProviderError",
      shortMessage: "The requested method and/or account has not been authorized by the user."
    });
  }
}
Object.defineProperty(UnauthorizedProviderError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4100
});
class UnsupportedProviderMethodError extends ProviderRpcError {
  constructor(t, { method: Ie } = {}) {
    super(t, {
      code: UnsupportedProviderMethodError.code,
      name: "UnsupportedProviderMethodError",
      shortMessage: `The Provider does not support the requested method${Ie ? ` " ${Ie}"` : ""}.`
    });
  }
}
Object.defineProperty(UnsupportedProviderMethodError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4200
});
class ProviderDisconnectedError extends ProviderRpcError {
  constructor(t) {
    super(t, {
      code: ProviderDisconnectedError.code,
      name: "ProviderDisconnectedError",
      shortMessage: "The Provider is disconnected from all chains."
    });
  }
}
Object.defineProperty(ProviderDisconnectedError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4900
});
class ChainDisconnectedError extends ProviderRpcError {
  constructor(t) {
    super(t, {
      code: ChainDisconnectedError.code,
      name: "ChainDisconnectedError",
      shortMessage: "The Provider is not connected to the requested chain."
    });
  }
}
Object.defineProperty(ChainDisconnectedError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4901
});
class SwitchChainError extends ProviderRpcError {
  constructor(t) {
    super(t, {
      code: SwitchChainError.code,
      name: "SwitchChainError",
      shortMessage: "An error occurred when attempting to switch chain."
    });
  }
}
Object.defineProperty(SwitchChainError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4902
});
class UnknownRpcError extends RpcError {
  constructor(t) {
    super(t, {
      name: "UnknownRpcError",
      shortMessage: "An unknown RPC error occurred."
    });
  }
}
function getNodeError(Ae, t) {
  const Ie = (Ae.details || "").toLowerCase(), Be = Ae instanceof BaseError$1 ? Ae.walk((Pe) => (Pe == null ? void 0 : Pe.code) === ExecutionRevertedError.code) : Ae;
  return Be instanceof BaseError$1 ? new ExecutionRevertedError({
    cause: Ae,
    message: Be.details
  }) : ExecutionRevertedError.nodeMessage.test(Ie) ? new ExecutionRevertedError({
    cause: Ae,
    message: Ae.details
  }) : FeeCapTooHighError.nodeMessage.test(Ie) ? new FeeCapTooHighError({
    cause: Ae,
    maxFeePerGas: t == null ? void 0 : t.maxFeePerGas
  }) : FeeCapTooLowError.nodeMessage.test(Ie) ? new FeeCapTooLowError({
    cause: Ae,
    maxFeePerGas: t == null ? void 0 : t.maxFeePerGas
  }) : NonceTooHighError.nodeMessage.test(Ie) ? new NonceTooHighError({ cause: Ae, nonce: t == null ? void 0 : t.nonce }) : NonceTooLowError.nodeMessage.test(Ie) ? new NonceTooLowError({ cause: Ae, nonce: t == null ? void 0 : t.nonce }) : NonceMaxValueError.nodeMessage.test(Ie) ? new NonceMaxValueError({ cause: Ae, nonce: t == null ? void 0 : t.nonce }) : InsufficientFundsError.nodeMessage.test(Ie) ? new InsufficientFundsError({ cause: Ae }) : IntrinsicGasTooHighError.nodeMessage.test(Ie) ? new IntrinsicGasTooHighError({ cause: Ae, gas: t == null ? void 0 : t.gas }) : IntrinsicGasTooLowError.nodeMessage.test(Ie) ? new IntrinsicGasTooLowError({ cause: Ae, gas: t == null ? void 0 : t.gas }) : TransactionTypeNotSupportedError.nodeMessage.test(Ie) ? new TransactionTypeNotSupportedError({ cause: Ae }) : TipAboveFeeCapError.nodeMessage.test(Ie) ? new TipAboveFeeCapError({
    cause: Ae,
    maxFeePerGas: t == null ? void 0 : t.maxFeePerGas,
    maxPriorityFeePerGas: t == null ? void 0 : t.maxPriorityFeePerGas
  }) : new UnknownNodeError({
    cause: Ae
  });
}
function getEstimateGasError(Ae, { docsPath: t, ...Ie }) {
  const Be = (() => {
    const Pe = getNodeError(Ae, Ie);
    return Pe instanceof UnknownNodeError ? Ae : Pe;
  })();
  return new EstimateGasExecutionError(Be, {
    docsPath: t,
    ...Ie
  });
}
function extract(Ae, { format: t }) {
  if (!t)
    return {};
  const Ie = {};
  function Be(Te) {
    const Me = Object.keys(Te);
    for (const Ue of Me)
      Ue in Ae && (Ie[Ue] = Ae[Ue]), Te[Ue] && typeof Te[Ue] == "object" && !Array.isArray(Te[Ue]) && Be(Te[Ue]);
  }
  const Pe = t(Ae || {});
  return Be(Pe), Ie;
}
class AccountStateConflictError extends BaseError$1 {
  constructor({ address: t }) {
    super(`State for account "${t}" is set multiple times.`, {
      name: "AccountStateConflictError"
    });
  }
}
class StateAssignmentConflictError extends BaseError$1 {
  constructor() {
    super("state and stateDiff are set on the same account.", {
      name: "StateAssignmentConflictError"
    });
  }
}
function prettyStateMapping(Ae) {
  return Ae.reduce((t, { slot: Ie, value: Be }) => `${t}        ${Ie}: ${Be}
`, "");
}
function prettyStateOverride(Ae) {
  return Ae.reduce((t, { address: Ie, ...Be }) => {
    let Pe = `${t}    ${Ie}:
`;
    return Be.nonce && (Pe += `      nonce: ${Be.nonce}
`), Be.balance && (Pe += `      balance: ${Be.balance}
`), Be.code && (Pe += `      code: ${Be.code}
`), Be.state && (Pe += `      state:
`, Pe += prettyStateMapping(Be.state)), Be.stateDiff && (Pe += `      stateDiff:
`, Pe += prettyStateMapping(Be.stateDiff)), Pe;
  }, `  State Override:
`).slice(0, -1);
}
function serializeStateMapping(Ae) {
  if (!(!Ae || Ae.length === 0))
    return Ae.reduce((t, { slot: Ie, value: Be }) => {
      if (Ie.length !== 66)
        throw new InvalidBytesLengthError({
          size: Ie.length,
          targetSize: 66,
          type: "hex"
        });
      if (Be.length !== 66)
        throw new InvalidBytesLengthError({
          size: Be.length,
          targetSize: 66,
          type: "hex"
        });
      return t[Ie] = Be, t;
    }, {});
}
function serializeAccountStateOverride(Ae) {
  const { balance: t, nonce: Ie, state: Be, stateDiff: Pe, code: Te } = Ae, Me = {};
  if (Te !== void 0 && (Me.code = Te), t !== void 0 && (Me.balance = numberToHex(t)), Ie !== void 0 && (Me.nonce = numberToHex(Ie)), Be !== void 0 && (Me.state = serializeStateMapping(Be)), Pe !== void 0) {
    if (Me.state)
      throw new StateAssignmentConflictError();
    Me.stateDiff = serializeStateMapping(Pe);
  }
  return Me;
}
function serializeStateOverride(Ae) {
  if (!Ae)
    return;
  const t = {};
  for (const { address: Ie, ...Be } of Ae) {
    if (!isAddress(Ie, { strict: !1 }))
      throw new InvalidAddressError({ address: Ie });
    if (t[Ie])
      throw new AccountStateConflictError({ address: Ie });
    t[Ie] = serializeAccountStateOverride(Be);
  }
  return t;
}
function assertRequest(Ae) {
  const { account: t, gasPrice: Ie, maxFeePerGas: Be, maxPriorityFeePerGas: Pe, to: Te } = Ae, Me = t ? parseAccount(t) : void 0;
  if (Me && !isAddress(Me.address))
    throw new InvalidAddressError({ address: Me.address });
  if (Te && !isAddress(Te))
    throw new InvalidAddressError({ address: Te });
  if (typeof Ie < "u" && (typeof Be < "u" || typeof Pe < "u"))
    throw new FeeConflictError();
  if (Be && Be > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas: Be });
  if (Pe && Be && Pe > Be)
    throw new TipAboveFeeCapError({ maxFeePerGas: Be, maxPriorityFeePerGas: Pe });
}
async function getBalance(Ae, { address: t, blockNumber: Ie, blockTag: Be = "latest" }) {
  const Pe = Ie ? numberToHex(Ie) : void 0, Te = await Ae.request({
    method: "eth_getBalance",
    params: [t, Pe || Be]
  });
  return BigInt(Te);
}
async function estimateGas(Ae, t) {
  var Pe, Te, Me;
  const Ie = t.account ?? Ae.account, Be = Ie ? parseAccount(Ie) : void 0;
  try {
    let vi = function(Ai) {
      const { block: Ri, request: Ti, rpcStateOverride: Ci } = Ai;
      return Ae.request({
        method: "eth_estimateGas",
        params: Ci ? [Ti, Ri ?? "latest", Ci] : Ri ? [Ti, Ri] : [Ti]
      });
    };
    const { accessList: Ue, authorizationList: je, blobs: fn, blobVersionedHashes: Ve, blockNumber: vn, blockTag: En, data: fi, gas: bi, gasPrice: mi, maxFeePerBlobGas: _i, maxFeePerGas: Ei, maxPriorityFeePerGas: Si, nonce: Mi, value: Oi, stateOverride: Fi, ...Ui } = await prepareTransactionRequest(Ae, {
      ...t,
      parameters: (
        // Some RPC Providers do not compute versioned hashes from blobs. We will need
        // to compute them.
        (Be == null ? void 0 : Be.type) === "local" ? void 0 : ["blobVersionedHashes"]
      )
    }), Bi = (vn ? numberToHex(vn) : void 0) || En, ji = serializeStateOverride(Fi), Zi = await (async () => {
      if (Ui.to)
        return Ui.to;
      if (je && je.length > 0)
        return await recoverAuthorizationAddress({
          authorization: je[0]
        }).catch(() => {
          throw new BaseError$1("`to` is required. Could not infer from `authorizationList`");
        });
    })();
    assertRequest(t);
    const zi = (Me = (Te = (Pe = Ae.chain) == null ? void 0 : Pe.formatters) == null ? void 0 : Te.transactionRequest) == null ? void 0 : Me.format, $i = (zi || formatTransactionRequest)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(Ui, { format: zi }),
      from: Be == null ? void 0 : Be.address,
      accessList: Ue,
      authorizationList: je,
      blobs: fn,
      blobVersionedHashes: Ve,
      data: fi,
      gas: bi,
      gasPrice: mi,
      maxFeePerBlobGas: _i,
      maxFeePerGas: Ei,
      maxPriorityFeePerGas: Si,
      nonce: Mi,
      to: Zi,
      value: Oi
    });
    let wi = BigInt(await vi({ block: Bi, request: $i, rpcStateOverride: ji }));
    if (je) {
      const Ai = await getBalance(Ae, { address: $i.from }), Ri = await Promise.all(je.map(async (Ti) => {
        const { contractAddress: Ci } = Ti, Ii = await vi({
          block: Bi,
          request: {
            authorizationList: void 0,
            data: fi,
            from: Be == null ? void 0 : Be.address,
            to: Ci,
            value: numberToHex(Ai)
          },
          rpcStateOverride: ji
        }).catch(() => 100000n);
        return 2n * BigInt(Ii);
      }));
      wi += Ri.reduce((Ti, Ci) => Ti + Ci, 0n);
    }
    return wi;
  } catch (Ue) {
    throw getEstimateGasError(Ue, {
      ...t,
      account: Be,
      chain: Ae.chain
    });
  }
}
async function getTransactionCount(Ae, { address: t, blockTag: Ie = "latest", blockNumber: Be }) {
  const Pe = await Ae.request({
    method: "eth_getTransactionCount",
    params: [t, Be ? numberToHex(Be) : Ie]
  }, { dedupe: !!Be });
  return hexToNumber$2(Pe);
}
async function getChainId(Ae) {
  const t = await Ae.request({
    method: "eth_chainId"
  }, { dedupe: !0 });
  return hexToNumber$2(t);
}
const defaultParameters = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];
async function prepareTransactionRequest(Ae, t) {
  const { account: Ie = Ae.account, blobs: Be, chain: Pe, gas: Te, kzg: Me, nonce: Ue, nonceManager: je, parameters: fn = defaultParameters, type: Ve } = t, vn = Ie ? parseAccount(Ie) : void 0, En = { ...t, ...vn ? { from: vn == null ? void 0 : vn.address } : {} };
  let fi;
  async function bi() {
    return fi || (fi = await getAction(Ae, getBlock, "getBlock")({ blockTag: "latest" }), fi);
  }
  let mi;
  async function _i() {
    return mi || (Pe ? Pe.id : typeof t.chainId < "u" ? t.chainId : (mi = await getAction(Ae, getChainId, "getChainId")({}), mi));
  }
  if ((fn.includes("blobVersionedHashes") || fn.includes("sidecars")) && Be && Me) {
    const Ei = blobsToCommitments({ blobs: Be, kzg: Me });
    if (fn.includes("blobVersionedHashes")) {
      const Si = commitmentsToVersionedHashes({
        commitments: Ei,
        to: "hex"
      });
      En.blobVersionedHashes = Si;
    }
    if (fn.includes("sidecars")) {
      const Si = blobsToProofs({ blobs: Be, commitments: Ei, kzg: Me }), Mi = toBlobSidecars({
        blobs: Be,
        commitments: Ei,
        proofs: Si,
        to: "hex"
      });
      En.sidecars = Mi;
    }
  }
  if (fn.includes("chainId") && (En.chainId = await _i()), fn.includes("nonce") && typeof Ue > "u" && vn)
    if (je) {
      const Ei = await _i();
      En.nonce = await je.consume({
        address: vn.address,
        chainId: Ei,
        client: Ae
      });
    } else
      En.nonce = await getAction(Ae, getTransactionCount, "getTransactionCount")({
        address: vn.address,
        blockTag: "pending"
      });
  if ((fn.includes("fees") || fn.includes("type")) && typeof Ve > "u")
    try {
      En.type = getTransactionType(En);
    } catch {
      const Ei = await bi();
      En.type = typeof (Ei == null ? void 0 : Ei.baseFeePerGas) == "bigint" ? "eip1559" : "legacy";
    }
  if (fn.includes("fees"))
    if (En.type !== "legacy" && En.type !== "eip2930") {
      if (typeof En.maxFeePerGas > "u" || typeof En.maxPriorityFeePerGas > "u") {
        const Ei = await bi(), { maxFeePerGas: Si, maxPriorityFeePerGas: Mi } = await internal_estimateFeesPerGas(Ae, {
          block: Ei,
          chain: Pe,
          request: En
        });
        if (typeof t.maxPriorityFeePerGas > "u" && t.maxFeePerGas && t.maxFeePerGas < Mi)
          throw new MaxFeePerGasTooLowError({
            maxPriorityFeePerGas: Mi
          });
        En.maxPriorityFeePerGas = Mi, En.maxFeePerGas = Si;
      }
    } else {
      if (typeof t.maxFeePerGas < "u" || typeof t.maxPriorityFeePerGas < "u")
        throw new Eip1559FeesNotSupportedError();
      const Ei = await bi(), { gasPrice: Si } = await internal_estimateFeesPerGas(Ae, {
        block: Ei,
        chain: Pe,
        request: En,
        type: "legacy"
      });
      En.gasPrice = Si;
    }
  return fn.includes("gas") && typeof Te > "u" && (En.gas = await getAction(Ae, estimateGas, "estimateGas")({
    ...En,
    account: vn ? { address: vn.address, type: "json-rpc" } : void 0
  })), assertRequest(En), delete En.parameters, En;
}
class AccountNotFoundError extends BaseError$1 {
  constructor({ docsPath: t } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join(`
`), {
      docsPath: t,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
}
class AccountTypeNotSupportedError extends BaseError$1 {
  constructor({ docsPath: t, metaMessages: Ie, type: Be }) {
    super(`Account type "${Be}" is not supported.`, {
      docsPath: t,
      metaMessages: Ie,
      name: "AccountTypeNotSupportedError"
    });
  }
}
const panicReasons = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
}, solidityError = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
}, solidityPanic = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
function formatAbiItem$1(Ae, { includeName: t = !1 } = {}) {
  if (Ae.type !== "function" && Ae.type !== "event" && Ae.type !== "error")
    throw new InvalidDefinitionTypeError(Ae.type);
  return `${Ae.name}(${formatAbiParams(Ae.inputs, { includeName: t })})`;
}
function formatAbiParams(Ae, { includeName: t = !1 } = {}) {
  return Ae ? Ae.map((Ie) => formatAbiParam(Ie, { includeName: t })).join(t ? ", " : ",") : "";
}
function formatAbiParam(Ae, { includeName: t }) {
  return Ae.type.startsWith("tuple") ? `(${formatAbiParams(Ae.components, { includeName: t })})${Ae.type.slice(5)}` : Ae.type + (t && Ae.name ? ` ${Ae.name}` : "");
}
class AbiConstructorNotFoundError extends BaseError$1 {
  constructor({ docsPath: t }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join(`
`), {
      docsPath: t,
      name: "AbiConstructorNotFoundError"
    });
  }
}
class AbiConstructorParamsNotFoundError extends BaseError$1 {
  constructor({ docsPath: t }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join(`
`), {
      docsPath: t,
      name: "AbiConstructorParamsNotFoundError"
    });
  }
}
class AbiDecodingDataSizeTooSmallError extends BaseError$1 {
  constructor({ data: t, params: Ie, size: Be }) {
    super([`Data size of ${Be} bytes is too small for given parameters.`].join(`
`), {
      metaMessages: [
        `Params: (${formatAbiParams(Ie, { includeName: !0 })})`,
        `Data:   ${t} (${Be} bytes)`
      ],
      name: "AbiDecodingDataSizeTooSmallError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = t, this.params = Ie, this.size = Be;
  }
}
class AbiDecodingZeroDataError extends BaseError$1 {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.', {
      name: "AbiDecodingZeroDataError"
    });
  }
}
class AbiEncodingArrayLengthMismatchError extends BaseError$1 {
  constructor({ expectedLength: t, givenLength: Ie, type: Be }) {
    super([
      `ABI encoding array length mismatch for type ${Be}.`,
      `Expected length: ${t}`,
      `Given length: ${Ie}`
    ].join(`
`), { name: "AbiEncodingArrayLengthMismatchError" });
  }
}
class AbiEncodingBytesSizeMismatchError extends BaseError$1 {
  constructor({ expectedSize: t, value: Ie }) {
    super(`Size of bytes "${Ie}" (bytes${size$1(Ie)}) does not match expected size (bytes${t}).`, { name: "AbiEncodingBytesSizeMismatchError" });
  }
}
class AbiEncodingLengthMismatchError extends BaseError$1 {
  constructor({ expectedLength: t, givenLength: Ie }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${t}`,
      `Given length (values): ${Ie}`
    ].join(`
`), { name: "AbiEncodingLengthMismatchError" });
  }
}
class AbiErrorSignatureNotFoundError extends BaseError$1 {
  constructor(t, { docsPath: Ie }) {
    super([
      `Encoded error signature "${t}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${t}.`
    ].join(`
`), {
      docsPath: Ie,
      name: "AbiErrorSignatureNotFoundError"
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.signature = t;
  }
}
class AbiEventSignatureEmptyTopicsError extends BaseError$1 {
  constructor({ docsPath: t }) {
    super("Cannot extract event signature from empty topics.", {
      docsPath: t,
      name: "AbiEventSignatureEmptyTopicsError"
    });
  }
}
class AbiEventSignatureNotFoundError extends BaseError$1 {
  constructor(t, { docsPath: Ie }) {
    super([
      `Encoded event signature "${t}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${t}.`
    ].join(`
`), {
      docsPath: Ie,
      name: "AbiEventSignatureNotFoundError"
    });
  }
}
class AbiEventNotFoundError extends BaseError$1 {
  constructor(t, { docsPath: Ie } = {}) {
    super([
      `Event ${t ? `"${t}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it."
    ].join(`
`), {
      docsPath: Ie,
      name: "AbiEventNotFoundError"
    });
  }
}
class AbiFunctionNotFoundError extends BaseError$1 {
  constructor(t, { docsPath: Ie } = {}) {
    super([
      `Function ${t ? `"${t}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: Ie,
      name: "AbiFunctionNotFoundError"
    });
  }
}
class AbiFunctionOutputsNotFoundError extends BaseError$1 {
  constructor(t, { docsPath: Ie }) {
    super([
      `Function "${t}" does not contain any \`outputs\` on ABI.`,
      "Cannot decode function result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: Ie,
      name: "AbiFunctionOutputsNotFoundError"
    });
  }
}
class AbiItemAmbiguityError extends BaseError$1 {
  constructor(t, Ie) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${t.type}\` in \`${formatAbiItem$1(t.abiItem)}\`, and`,
        `\`${Ie.type}\` in \`${formatAbiItem$1(Ie.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ],
      name: "AbiItemAmbiguityError"
    });
  }
}
class BytesSizeMismatchError extends BaseError$1 {
  constructor({ expectedSize: t, givenSize: Ie }) {
    super(`Expected bytes${t}, got bytes${Ie}.`, {
      name: "BytesSizeMismatchError"
    });
  }
}
class DecodeLogDataMismatch extends BaseError$1 {
  constructor({ abiItem: t, data: Ie, params: Be, size: Pe }) {
    super([
      `Data size of ${Pe} bytes is too small for non-indexed event parameters.`
    ].join(`
`), {
      metaMessages: [
        `Params: (${formatAbiParams(Be, { includeName: !0 })})`,
        `Data:   ${Ie} (${Pe} bytes)`
      ],
      name: "DecodeLogDataMismatch"
    }), Object.defineProperty(this, "abiItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abiItem = t, this.data = Ie, this.params = Be, this.size = Pe;
  }
}
class DecodeLogTopicsMismatch extends BaseError$1 {
  constructor({ abiItem: t, param: Ie }) {
    super([
      `Expected a topic for indexed event parameter${Ie.name ? ` "${Ie.name}"` : ""} on event "${formatAbiItem$1(t, { includeName: !0 })}".`
    ].join(`
`), { name: "DecodeLogTopicsMismatch" }), Object.defineProperty(this, "abiItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abiItem = t;
  }
}
class InvalidAbiEncodingTypeError extends BaseError$1 {
  constructor(t, { docsPath: Ie }) {
    super([
      `Type "${t}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: Ie, name: "InvalidAbiEncodingType" });
  }
}
class InvalidAbiDecodingTypeError extends BaseError$1 {
  constructor(t, { docsPath: Ie }) {
    super([
      `Type "${t}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: Ie, name: "InvalidAbiDecodingType" });
  }
}
class InvalidArrayError extends BaseError$1 {
  constructor(t) {
    super([`Value "${t}" is not a valid array.`].join(`
`), {
      name: "InvalidArrayError"
    });
  }
}
class InvalidDefinitionTypeError extends BaseError$1 {
  constructor(t) {
    super([
      `"${t}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join(`
`), { name: "InvalidDefinitionTypeError" });
  }
}
const hash$2 = (Ae) => keccak256$2(toBytes$2(Ae));
function hashSignature(Ae) {
  return hash$2(Ae);
}
const version$6 = "1.0.6";
class BaseError extends Error {
  constructor(t, Ie = {}) {
    var Me;
    const Be = Ie.cause instanceof BaseError ? Ie.cause.details : (Me = Ie.cause) != null && Me.message ? Ie.cause.message : Ie.details, Pe = Ie.cause instanceof BaseError && Ie.cause.docsPath || Ie.docsPath, Te = [
      t || "An error occurred.",
      "",
      ...Ie.metaMessages ? [...Ie.metaMessages, ""] : [],
      ...Pe ? [`Docs: https://abitype.dev${Pe}`] : [],
      ...Be ? [`Details: ${Be}`] : [],
      `Version: abitype@${version$6}`
    ].join(`
`);
    super(Te), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiTypeError"
    }), Ie.cause && (this.cause = Ie.cause), this.details = Be, this.docsPath = Pe, this.metaMessages = Ie.metaMessages, this.shortMessage = t;
  }
}
function execTyped(Ae, t) {
  const Ie = Ae.exec(t);
  return Ie == null ? void 0 : Ie.groups;
}
const bytesRegex$1 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, integerRegex$1 = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/, isTupleRegex = /^\(.+?\).*?$/, tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
function formatAbiParameter(Ae) {
  let t = Ae.type;
  if (tupleRegex.test(Ae.type) && "components" in Ae) {
    t = "(";
    const Ie = Ae.components.length;
    for (let Pe = 0; Pe < Ie; Pe++) {
      const Te = Ae.components[Pe];
      t += formatAbiParameter(Te), Pe < Ie - 1 && (t += ", ");
    }
    const Be = execTyped(tupleRegex, Ae.type);
    return t += `)${(Be == null ? void 0 : Be.array) ?? ""}`, formatAbiParameter({
      ...Ae,
      type: t
    });
  }
  return "indexed" in Ae && Ae.indexed && (t = `${t} indexed`), Ae.name ? `${t} ${Ae.name}` : t;
}
function formatAbiParameters(Ae) {
  let t = "";
  const Ie = Ae.length;
  for (let Be = 0; Be < Ie; Be++) {
    const Pe = Ae[Be];
    t += formatAbiParameter(Pe), Be !== Ie - 1 && (t += ", ");
  }
  return t;
}
function formatAbiItem(Ae) {
  return Ae.type === "function" ? `function ${Ae.name}(${formatAbiParameters(Ae.inputs)})${Ae.stateMutability && Ae.stateMutability !== "nonpayable" ? ` ${Ae.stateMutability}` : ""}${Ae.outputs.length ? ` returns (${formatAbiParameters(Ae.outputs)})` : ""}` : Ae.type === "event" ? `event ${Ae.name}(${formatAbiParameters(Ae.inputs)})` : Ae.type === "error" ? `error ${Ae.name}(${formatAbiParameters(Ae.inputs)})` : Ae.type === "constructor" ? `constructor(${formatAbiParameters(Ae.inputs)})${Ae.stateMutability === "payable" ? " payable" : ""}` : Ae.type === "fallback" ? "fallback()" : "receive() external payable";
}
const errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isErrorSignature(Ae) {
  return errorSignatureRegex.test(Ae);
}
function execErrorSignature(Ae) {
  return execTyped(errorSignatureRegex, Ae);
}
const eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isEventSignature(Ae) {
  return eventSignatureRegex.test(Ae);
}
function execEventSignature(Ae) {
  return execTyped(eventSignatureRegex, Ae);
}
const functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function isFunctionSignature(Ae) {
  return functionSignatureRegex.test(Ae);
}
function execFunctionSignature(Ae) {
  return execTyped(functionSignatureRegex, Ae);
}
const structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function isStructSignature(Ae) {
  return structSignatureRegex.test(Ae);
}
function execStructSignature(Ae) {
  return execTyped(structSignatureRegex, Ae);
}
const constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function isConstructorSignature(Ae) {
  return constructorSignatureRegex.test(Ae);
}
function execConstructorSignature(Ae) {
  return execTyped(constructorSignatureRegex, Ae);
}
const fallbackSignatureRegex = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
function isFallbackSignature(Ae) {
  return fallbackSignatureRegex.test(Ae);
}
const receiveSignatureRegex = /^receive\(\) external payable$/;
function isReceiveSignature(Ae) {
  return receiveSignatureRegex.test(Ae);
}
const eventModifiers = /* @__PURE__ */ new Set(["indexed"]), functionModifiers = /* @__PURE__ */ new Set([
  "calldata",
  "memory",
  "storage"
]);
class UnknownTypeError extends BaseError {
  constructor({ type: t }) {
    super("Unknown type.", {
      metaMessages: [
        `Type "${t}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownTypeError"
    });
  }
}
class UnknownSolidityTypeError extends BaseError {
  constructor({ type: t }) {
    super("Unknown type.", {
      metaMessages: [`Type "${t}" is not a valid ABI type.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSolidityTypeError"
    });
  }
}
class InvalidParameterError extends BaseError {
  constructor({ param: t }) {
    super("Invalid ABI parameter.", {
      details: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParameterError"
    });
  }
}
class SolidityProtectedKeywordError extends BaseError {
  constructor({ param: t, name: Ie }) {
    super("Invalid ABI parameter.", {
      details: t,
      metaMessages: [
        `"${Ie}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SolidityProtectedKeywordError"
    });
  }
}
class InvalidModifierError extends BaseError {
  constructor({ param: t, type: Ie, modifier: Be }) {
    super("Invalid ABI parameter.", {
      details: t,
      metaMessages: [
        `Modifier "${Be}" not allowed${Ie ? ` in "${Ie}" type` : ""}.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidModifierError"
    });
  }
}
class InvalidFunctionModifierError extends BaseError {
  constructor({ param: t, type: Ie, modifier: Be }) {
    super("Invalid ABI parameter.", {
      details: t,
      metaMessages: [
        `Modifier "${Be}" not allowed${Ie ? ` in "${Ie}" type` : ""}.`,
        `Data location can only be specified for array, struct, or mapping types, but "${Be}" was given.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidFunctionModifierError"
    });
  }
}
class InvalidAbiTypeParameterError extends BaseError {
  constructor({ abiParameter: t }) {
    super("Invalid ABI parameter.", {
      details: JSON.stringify(t, null, 2),
      metaMessages: ["ABI parameter type is invalid."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiTypeParameterError"
    });
  }
}
class InvalidSignatureError extends BaseError {
  constructor({ signature: t, type: Ie }) {
    super(`Invalid ${Ie} signature.`, {
      details: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSignatureError"
    });
  }
}
class UnknownSignatureError extends BaseError {
  constructor({ signature: t }) {
    super("Unknown signature.", {
      details: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSignatureError"
    });
  }
}
class InvalidStructSignatureError extends BaseError {
  constructor({ signature: t }) {
    super("Invalid struct signature.", {
      details: t,
      metaMessages: ["No properties exist."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidStructSignatureError"
    });
  }
}
class CircularReferenceError extends BaseError {
  constructor({ type: t }) {
    super("Circular reference detected.", {
      metaMessages: [`Struct "${t}" is a circular reference.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "CircularReferenceError"
    });
  }
}
class InvalidParenthesisError extends BaseError {
  constructor({ current: t, depth: Ie }) {
    super("Unbalanced parentheses.", {
      metaMessages: [
        `"${t.trim()}" has too many ${Ie > 0 ? "opening" : "closing"} parentheses.`
      ],
      details: `Depth "${Ie}"`
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParenthesisError"
    });
  }
}
function getParameterCacheKey(Ae, t) {
  return t ? `${t}:${Ae}` : Ae;
}
const parameterCache = /* @__PURE__ */ new Map([
  // Unnamed
  ["address", { type: "address" }],
  ["bool", { type: "bool" }],
  ["bytes", { type: "bytes" }],
  ["bytes32", { type: "bytes32" }],
  ["int", { type: "int256" }],
  ["int256", { type: "int256" }],
  ["string", { type: "string" }],
  ["uint", { type: "uint256" }],
  ["uint8", { type: "uint8" }],
  ["uint16", { type: "uint16" }],
  ["uint24", { type: "uint24" }],
  ["uint32", { type: "uint32" }],
  ["uint64", { type: "uint64" }],
  ["uint96", { type: "uint96" }],
  ["uint112", { type: "uint112" }],
  ["uint160", { type: "uint160" }],
  ["uint192", { type: "uint192" }],
  ["uint256", { type: "uint256" }],
  // Named
  ["address owner", { type: "address", name: "owner" }],
  ["address to", { type: "address", name: "to" }],
  ["bool approved", { type: "bool", name: "approved" }],
  ["bytes _data", { type: "bytes", name: "_data" }],
  ["bytes data", { type: "bytes", name: "data" }],
  ["bytes signature", { type: "bytes", name: "signature" }],
  ["bytes32 hash", { type: "bytes32", name: "hash" }],
  ["bytes32 r", { type: "bytes32", name: "r" }],
  ["bytes32 root", { type: "bytes32", name: "root" }],
  ["bytes32 s", { type: "bytes32", name: "s" }],
  ["string name", { type: "string", name: "name" }],
  ["string symbol", { type: "string", name: "symbol" }],
  ["string tokenURI", { type: "string", name: "tokenURI" }],
  ["uint tokenId", { type: "uint256", name: "tokenId" }],
  ["uint8 v", { type: "uint8", name: "v" }],
  ["uint256 balance", { type: "uint256", name: "balance" }],
  ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
  ["uint256 value", { type: "uint256", name: "value" }],
  // Indexed
  [
    "event:address indexed from",
    { type: "address", name: "from", indexed: !0 }
  ],
  ["event:address indexed to", { type: "address", name: "to", indexed: !0 }],
  [
    "event:uint indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ],
  [
    "event:uint256 indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 }
  ]
]);
function parseSignature(Ae, t = {}) {
  if (isFunctionSignature(Ae)) {
    const Ie = execFunctionSignature(Ae);
    if (!Ie)
      throw new InvalidSignatureError({ signature: Ae, type: "function" });
    const Be = splitParameters(Ie.parameters), Pe = [], Te = Be.length;
    for (let Ue = 0; Ue < Te; Ue++)
      Pe.push(parseAbiParameter(Be[Ue], {
        modifiers: functionModifiers,
        structs: t,
        type: "function"
      }));
    const Me = [];
    if (Ie.returns) {
      const Ue = splitParameters(Ie.returns), je = Ue.length;
      for (let fn = 0; fn < je; fn++)
        Me.push(parseAbiParameter(Ue[fn], {
          modifiers: functionModifiers,
          structs: t,
          type: "function"
        }));
    }
    return {
      name: Ie.name,
      type: "function",
      stateMutability: Ie.stateMutability ?? "nonpayable",
      inputs: Pe,
      outputs: Me
    };
  }
  if (isEventSignature(Ae)) {
    const Ie = execEventSignature(Ae);
    if (!Ie)
      throw new InvalidSignatureError({ signature: Ae, type: "event" });
    const Be = splitParameters(Ie.parameters), Pe = [], Te = Be.length;
    for (let Me = 0; Me < Te; Me++)
      Pe.push(parseAbiParameter(Be[Me], {
        modifiers: eventModifiers,
        structs: t,
        type: "event"
      }));
    return { name: Ie.name, type: "event", inputs: Pe };
  }
  if (isErrorSignature(Ae)) {
    const Ie = execErrorSignature(Ae);
    if (!Ie)
      throw new InvalidSignatureError({ signature: Ae, type: "error" });
    const Be = splitParameters(Ie.parameters), Pe = [], Te = Be.length;
    for (let Me = 0; Me < Te; Me++)
      Pe.push(parseAbiParameter(Be[Me], { structs: t, type: "error" }));
    return { name: Ie.name, type: "error", inputs: Pe };
  }
  if (isConstructorSignature(Ae)) {
    const Ie = execConstructorSignature(Ae);
    if (!Ie)
      throw new InvalidSignatureError({ signature: Ae, type: "constructor" });
    const Be = splitParameters(Ie.parameters), Pe = [], Te = Be.length;
    for (let Me = 0; Me < Te; Me++)
      Pe.push(parseAbiParameter(Be[Me], { structs: t, type: "constructor" }));
    return {
      type: "constructor",
      stateMutability: Ie.stateMutability ?? "nonpayable",
      inputs: Pe
    };
  }
  if (isFallbackSignature(Ae))
    return { type: "fallback" };
  if (isReceiveSignature(Ae))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new UnknownSignatureError({ signature: Ae });
}
const abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/, dynamicIntegerRegex = /^u?int$/;
function parseAbiParameter(Ae, t) {
  var vn, En;
  const Ie = getParameterCacheKey(Ae, t == null ? void 0 : t.type);
  if (parameterCache.has(Ie))
    return parameterCache.get(Ie);
  const Be = isTupleRegex.test(Ae), Pe = execTyped(Be ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, Ae);
  if (!Pe)
    throw new InvalidParameterError({ param: Ae });
  if (Pe.name && isSolidityKeyword(Pe.name))
    throw new SolidityProtectedKeywordError({ param: Ae, name: Pe.name });
  const Te = Pe.name ? { name: Pe.name } : {}, Me = Pe.modifier === "indexed" ? { indexed: !0 } : {}, Ue = (t == null ? void 0 : t.structs) ?? {};
  let je, fn = {};
  if (Be) {
    je = "tuple";
    const fi = splitParameters(Pe.type), bi = [], mi = fi.length;
    for (let _i = 0; _i < mi; _i++)
      bi.push(parseAbiParameter(fi[_i], { structs: Ue }));
    fn = { components: bi };
  } else if (Pe.type in Ue)
    je = "tuple", fn = { components: Ue[Pe.type] };
  else if (dynamicIntegerRegex.test(Pe.type))
    je = `${Pe.type}256`;
  else if (je = Pe.type, (t == null ? void 0 : t.type) !== "struct" && !isSolidityType(je))
    throw new UnknownSolidityTypeError({ type: je });
  if (Pe.modifier) {
    if (!((En = (vn = t == null ? void 0 : t.modifiers) == null ? void 0 : vn.has) != null && En.call(vn, Pe.modifier)))
      throw new InvalidModifierError({
        param: Ae,
        type: t == null ? void 0 : t.type,
        modifier: Pe.modifier
      });
    if (functionModifiers.has(Pe.modifier) && !isValidDataLocation(je, !!Pe.array))
      throw new InvalidFunctionModifierError({
        param: Ae,
        type: t == null ? void 0 : t.type,
        modifier: Pe.modifier
      });
  }
  const Ve = {
    type: `${je}${Pe.array ?? ""}`,
    ...Te,
    ...Me,
    ...fn
  };
  return parameterCache.set(Ie, Ve), Ve;
}
function splitParameters(Ae, t = [], Ie = "", Be = 0) {
  const Pe = Ae.trim().length;
  for (let Te = 0; Te < Pe; Te++) {
    const Me = Ae[Te], Ue = Ae.slice(Te + 1);
    switch (Me) {
      case ",":
        return Be === 0 ? splitParameters(Ue, [...t, Ie.trim()]) : splitParameters(Ue, t, `${Ie}${Me}`, Be);
      case "(":
        return splitParameters(Ue, t, `${Ie}${Me}`, Be + 1);
      case ")":
        return splitParameters(Ue, t, `${Ie}${Me}`, Be - 1);
      default:
        return splitParameters(Ue, t, `${Ie}${Me}`, Be);
    }
  }
  if (Ie === "")
    return t;
  if (Be !== 0)
    throw new InvalidParenthesisError({ current: Ie, depth: Be });
  return t.push(Ie.trim()), t;
}
function isSolidityType(Ae) {
  return Ae === "address" || Ae === "bool" || Ae === "function" || Ae === "string" || bytesRegex$1.test(Ae) || integerRegex$1.test(Ae);
}
const protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function isSolidityKeyword(Ae) {
  return Ae === "address" || Ae === "bool" || Ae === "function" || Ae === "string" || Ae === "tuple" || bytesRegex$1.test(Ae) || integerRegex$1.test(Ae) || protectedKeywordsRegex.test(Ae);
}
function isValidDataLocation(Ae, t) {
  return t || Ae === "bytes" || Ae === "string" || Ae === "tuple";
}
function parseStructs(Ae) {
  const t = {}, Ie = Ae.length;
  for (let Me = 0; Me < Ie; Me++) {
    const Ue = Ae[Me];
    if (!isStructSignature(Ue))
      continue;
    const je = execStructSignature(Ue);
    if (!je)
      throw new InvalidSignatureError({ signature: Ue, type: "struct" });
    const fn = je.properties.split(";"), Ve = [], vn = fn.length;
    for (let En = 0; En < vn; En++) {
      const bi = fn[En].trim();
      if (!bi)
        continue;
      const mi = parseAbiParameter(bi, {
        type: "struct"
      });
      Ve.push(mi);
    }
    if (!Ve.length)
      throw new InvalidStructSignatureError({ signature: Ue });
    t[je.name] = Ve;
  }
  const Be = {}, Pe = Object.entries(t), Te = Pe.length;
  for (let Me = 0; Me < Te; Me++) {
    const [Ue, je] = Pe[Me];
    Be[Ue] = resolveStructs(je, t);
  }
  return Be;
}
const typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function resolveStructs(Ae, t, Ie = /* @__PURE__ */ new Set()) {
  const Be = [], Pe = Ae.length;
  for (let Te = 0; Te < Pe; Te++) {
    const Me = Ae[Te];
    if (isTupleRegex.test(Me.type))
      Be.push(Me);
    else {
      const je = execTyped(typeWithoutTupleRegex, Me.type);
      if (!(je != null && je.type))
        throw new InvalidAbiTypeParameterError({ abiParameter: Me });
      const { array: fn, type: Ve } = je;
      if (Ve in t) {
        if (Ie.has(Ve))
          throw new CircularReferenceError({ type: Ve });
        Be.push({
          ...Me,
          type: `tuple${fn ?? ""}`,
          components: resolveStructs(t[Ve] ?? [], t, /* @__PURE__ */ new Set([...Ie, Ve]))
        });
      } else if (isSolidityType(Ve))
        Be.push(Me);
      else
        throw new UnknownTypeError({ type: Ve });
    }
  }
  return Be;
}
function parseAbi(Ae) {
  const t = parseStructs(Ae), Ie = [], Be = Ae.length;
  for (let Pe = 0; Pe < Be; Pe++) {
    const Te = Ae[Pe];
    isStructSignature(Te) || Ie.push(parseSignature(Te, t));
  }
  return Ie;
}
function normalizeSignature(Ae) {
  let t = !0, Ie = "", Be = 0, Pe = "", Te = !1;
  for (let Me = 0; Me < Ae.length; Me++) {
    const Ue = Ae[Me];
    if (["(", ")", ","].includes(Ue) && (t = !0), Ue === "(" && Be++, Ue === ")" && Be--, !!t) {
      if (Be === 0) {
        if (Ue === " " && ["event", "function", ""].includes(Pe))
          Pe = "";
        else if (Pe += Ue, Ue === ")") {
          Te = !0;
          break;
        }
        continue;
      }
      if (Ue === " ") {
        Ae[Me - 1] !== "," && Ie !== "," && Ie !== ",(" && (Ie = "", t = !1);
        continue;
      }
      Pe += Ue, Ie += Ue;
    }
  }
  if (!Te)
    throw new BaseError$1("Unable to normalize signature.");
  return Pe;
}
const toSignature = (Ae) => {
  const t = typeof Ae == "string" ? Ae : formatAbiItem(Ae);
  return normalizeSignature(t);
};
function toSignatureHash(Ae) {
  return hashSignature(toSignature(Ae));
}
const toFunctionSelector = (Ae) => slice(toSignatureHash(Ae), 0, 4);
function bytesToBigInt(Ae, t = {}) {
  typeof t.size < "u" && assertSize(Ae, { size: t.size });
  const Ie = bytesToHex$2(Ae, t);
  return hexToBigInt(Ie, t);
}
function bytesToBool(Ae, t = {}) {
  let Ie = Ae;
  if (typeof t.size < "u" && (assertSize(Ie, { size: t.size }), Ie = trim(Ie)), Ie.length > 1 || Ie[0] > 1)
    throw new InvalidBytesBooleanError(Ie);
  return !!Ie[0];
}
function bytesToNumber(Ae, t = {}) {
  typeof t.size < "u" && assertSize(Ae, { size: t.size });
  const Ie = bytesToHex$2(Ae, t);
  return hexToNumber$2(Ie, t);
}
function bytesToString(Ae, t = {}) {
  let Ie = Ae;
  return typeof t.size < "u" && (assertSize(Ie, { size: t.size }), Ie = trim(Ie, { dir: "right" })), new TextDecoder().decode(Ie);
}
function encodeAbiParameters(Ae, t) {
  if (Ae.length !== t.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: Ae.length,
      givenLength: t.length
    });
  const Ie = prepareParams({
    params: Ae,
    values: t
  }), Be = encodeParams(Ie);
  return Be.length === 0 ? "0x" : Be;
}
function prepareParams({ params: Ae, values: t }) {
  const Ie = [];
  for (let Be = 0; Be < Ae.length; Be++)
    Ie.push(prepareParam({ param: Ae[Be], value: t[Be] }));
  return Ie;
}
function prepareParam({ param: Ae, value: t }) {
  const Ie = getArrayComponents(Ae.type);
  if (Ie) {
    const [Be, Pe] = Ie;
    return encodeArray(t, { length: Be, param: { ...Ae, type: Pe } });
  }
  if (Ae.type === "tuple")
    return encodeTuple(t, {
      param: Ae
    });
  if (Ae.type === "address")
    return encodeAddress(t);
  if (Ae.type === "bool")
    return encodeBool(t);
  if (Ae.type.startsWith("uint") || Ae.type.startsWith("int")) {
    const Be = Ae.type.startsWith("int");
    return encodeNumber(t, { signed: Be });
  }
  if (Ae.type.startsWith("bytes"))
    return encodeBytes(t, { param: Ae });
  if (Ae.type === "string")
    return encodeString(t);
  throw new InvalidAbiEncodingTypeError(Ae.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function encodeParams(Ae) {
  let t = 0;
  for (let Te = 0; Te < Ae.length; Te++) {
    const { dynamic: Me, encoded: Ue } = Ae[Te];
    Me ? t += 32 : t += size$1(Ue);
  }
  const Ie = [], Be = [];
  let Pe = 0;
  for (let Te = 0; Te < Ae.length; Te++) {
    const { dynamic: Me, encoded: Ue } = Ae[Te];
    Me ? (Ie.push(numberToHex(t + Pe, { size: 32 })), Be.push(Ue), Pe += size$1(Ue)) : Ie.push(Ue);
  }
  return concat$3([...Ie, ...Be]);
}
function encodeAddress(Ae) {
  if (!isAddress(Ae))
    throw new InvalidAddressError({ address: Ae });
  return { dynamic: !1, encoded: padHex(Ae.toLowerCase()) };
}
function encodeArray(Ae, { length: t, param: Ie }) {
  const Be = t === null;
  if (!Array.isArray(Ae))
    throw new InvalidArrayError(Ae);
  if (!Be && Ae.length !== t)
    throw new AbiEncodingArrayLengthMismatchError({
      expectedLength: t,
      givenLength: Ae.length,
      type: `${Ie.type}[${t}]`
    });
  let Pe = !1;
  const Te = [];
  for (let Me = 0; Me < Ae.length; Me++) {
    const Ue = prepareParam({ param: Ie, value: Ae[Me] });
    Ue.dynamic && (Pe = !0), Te.push(Ue);
  }
  if (Be || Pe) {
    const Me = encodeParams(Te);
    if (Be) {
      const Ue = numberToHex(Te.length, { size: 32 });
      return {
        dynamic: !0,
        encoded: Te.length > 0 ? concat$3([Ue, Me]) : Ue
      };
    }
    if (Pe)
      return { dynamic: !0, encoded: Me };
  }
  return {
    dynamic: !1,
    encoded: concat$3(Te.map(({ encoded: Me }) => Me))
  };
}
function encodeBytes(Ae, { param: t }) {
  const [, Ie] = t.type.split("bytes"), Be = size$1(Ae);
  if (!Ie) {
    let Pe = Ae;
    return Be % 32 !== 0 && (Pe = padHex(Pe, {
      dir: "right",
      size: Math.ceil((Ae.length - 2) / 2 / 32) * 32
    })), {
      dynamic: !0,
      encoded: concat$3([padHex(numberToHex(Be, { size: 32 })), Pe])
    };
  }
  if (Be !== Number.parseInt(Ie))
    throw new AbiEncodingBytesSizeMismatchError({
      expectedSize: Number.parseInt(Ie),
      value: Ae
    });
  return { dynamic: !1, encoded: padHex(Ae, { dir: "right" }) };
}
function encodeBool(Ae) {
  if (typeof Ae != "boolean")
    throw new BaseError$1(`Invalid boolean value: "${Ae}" (type: ${typeof Ae}). Expected: \`true\` or \`false\`.`);
  return { dynamic: !1, encoded: padHex(boolToHex(Ae)) };
}
function encodeNumber(Ae, { signed: t }) {
  return {
    dynamic: !1,
    encoded: numberToHex(Ae, {
      size: 32,
      signed: t
    })
  };
}
function encodeString(Ae) {
  const t = stringToHex(Ae), Ie = Math.ceil(size$1(t) / 32), Be = [];
  for (let Pe = 0; Pe < Ie; Pe++)
    Be.push(padHex(slice(t, Pe * 32, (Pe + 1) * 32), {
      dir: "right"
    }));
  return {
    dynamic: !0,
    encoded: concat$3([
      padHex(numberToHex(size$1(t), { size: 32 })),
      ...Be
    ])
  };
}
function encodeTuple(Ae, { param: t }) {
  let Ie = !1;
  const Be = [];
  for (let Pe = 0; Pe < t.components.length; Pe++) {
    const Te = t.components[Pe], Me = Array.isArray(Ae) ? Pe : Te.name, Ue = prepareParam({
      param: Te,
      value: Ae[Me]
    });
    Be.push(Ue), Ue.dynamic && (Ie = !0);
  }
  return {
    dynamic: Ie,
    encoded: Ie ? encodeParams(Be) : concat$3(Be.map(({ encoded: Pe }) => Pe))
  };
}
function getArrayComponents(Ae) {
  const t = Ae.match(/^(.*)\[(\d+)?\]$/);
  return t ? (
    // Return `null` if the array is dynamic.
    [t[2] ? Number(t[2]) : null, t[1]]
  ) : void 0;
}
function decodeAbiParameters(Ae, t) {
  const Ie = typeof t == "string" ? hexToBytes$2(t) : t, Be = createCursor(Ie);
  if (size$1(Ie) === 0 && Ae.length > 0)
    throw new AbiDecodingZeroDataError();
  if (size$1(t) && size$1(t) < 32)
    throw new AbiDecodingDataSizeTooSmallError({
      data: typeof t == "string" ? t : bytesToHex$2(t),
      params: Ae,
      size: size$1(t)
    });
  let Pe = 0;
  const Te = [];
  for (let Me = 0; Me < Ae.length; ++Me) {
    const Ue = Ae[Me];
    Be.setPosition(Pe);
    const [je, fn] = decodeParameter(Be, Ue, {
      staticPosition: 0
    });
    Pe += fn, Te.push(je);
  }
  return Te;
}
function decodeParameter(Ae, t, { staticPosition: Ie }) {
  const Be = getArrayComponents(t.type);
  if (Be) {
    const [Pe, Te] = Be;
    return decodeArray(Ae, { ...t, type: Te }, { length: Pe, staticPosition: Ie });
  }
  if (t.type === "tuple")
    return decodeTuple(Ae, t, { staticPosition: Ie });
  if (t.type === "address")
    return decodeAddress(Ae);
  if (t.type === "bool")
    return decodeBool(Ae);
  if (t.type.startsWith("bytes"))
    return decodeBytes(Ae, t, { staticPosition: Ie });
  if (t.type.startsWith("uint") || t.type.startsWith("int"))
    return decodeNumber(Ae, t);
  if (t.type === "string")
    return decodeString(Ae, { staticPosition: Ie });
  throw new InvalidAbiDecodingTypeError(t.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
const sizeOfLength = 32, sizeOfOffset = 32;
function decodeAddress(Ae) {
  const t = Ae.readBytes(32);
  return [checksumAddress(bytesToHex$2(sliceBytes(t, -20))), 32];
}
function decodeArray(Ae, t, { length: Ie, staticPosition: Be }) {
  if (!Ie) {
    const Me = bytesToNumber(Ae.readBytes(sizeOfOffset)), Ue = Be + Me, je = Ue + sizeOfLength;
    Ae.setPosition(Ue);
    const fn = bytesToNumber(Ae.readBytes(sizeOfLength)), Ve = hasDynamicChild(t);
    let vn = 0;
    const En = [];
    for (let fi = 0; fi < fn; ++fi) {
      Ae.setPosition(je + (Ve ? fi * 32 : vn));
      const [bi, mi] = decodeParameter(Ae, t, {
        staticPosition: je
      });
      vn += mi, En.push(bi);
    }
    return Ae.setPosition(Be + 32), [En, 32];
  }
  if (hasDynamicChild(t)) {
    const Me = bytesToNumber(Ae.readBytes(sizeOfOffset)), Ue = Be + Me, je = [];
    for (let fn = 0; fn < Ie; ++fn) {
      Ae.setPosition(Ue + fn * 32);
      const [Ve] = decodeParameter(Ae, t, {
        staticPosition: Ue
      });
      je.push(Ve);
    }
    return Ae.setPosition(Be + 32), [je, 32];
  }
  let Pe = 0;
  const Te = [];
  for (let Me = 0; Me < Ie; ++Me) {
    const [Ue, je] = decodeParameter(Ae, t, {
      staticPosition: Be + Pe
    });
    Pe += je, Te.push(Ue);
  }
  return [Te, Pe];
}
function decodeBool(Ae) {
  return [bytesToBool(Ae.readBytes(32), { size: 32 }), 32];
}
function decodeBytes(Ae, t, { staticPosition: Ie }) {
  const [Be, Pe] = t.type.split("bytes");
  if (!Pe) {
    const Me = bytesToNumber(Ae.readBytes(32));
    Ae.setPosition(Ie + Me);
    const Ue = bytesToNumber(Ae.readBytes(32));
    if (Ue === 0)
      return Ae.setPosition(Ie + 32), ["0x", 32];
    const je = Ae.readBytes(Ue);
    return Ae.setPosition(Ie + 32), [bytesToHex$2(je), 32];
  }
  return [bytesToHex$2(Ae.readBytes(Number.parseInt(Pe), 32)), 32];
}
function decodeNumber(Ae, t) {
  const Ie = t.type.startsWith("int"), Be = Number.parseInt(t.type.split("int")[1] || "256"), Pe = Ae.readBytes(32);
  return [
    Be > 48 ? bytesToBigInt(Pe, { signed: Ie }) : bytesToNumber(Pe, { signed: Ie }),
    32
  ];
}
function decodeTuple(Ae, t, { staticPosition: Ie }) {
  const Be = t.components.length === 0 || t.components.some(({ name: Me }) => !Me), Pe = Be ? [] : {};
  let Te = 0;
  if (hasDynamicChild(t)) {
    const Me = bytesToNumber(Ae.readBytes(sizeOfOffset)), Ue = Ie + Me;
    for (let je = 0; je < t.components.length; ++je) {
      const fn = t.components[je];
      Ae.setPosition(Ue + Te);
      const [Ve, vn] = decodeParameter(Ae, fn, {
        staticPosition: Ue
      });
      Te += vn, Pe[Be ? je : fn == null ? void 0 : fn.name] = Ve;
    }
    return Ae.setPosition(Ie + 32), [Pe, 32];
  }
  for (let Me = 0; Me < t.components.length; ++Me) {
    const Ue = t.components[Me], [je, fn] = decodeParameter(Ae, Ue, {
      staticPosition: Ie
    });
    Pe[Be ? Me : Ue == null ? void 0 : Ue.name] = je, Te += fn;
  }
  return [Pe, Te];
}
function decodeString(Ae, { staticPosition: t }) {
  const Ie = bytesToNumber(Ae.readBytes(32)), Be = t + Ie;
  Ae.setPosition(Be);
  const Pe = bytesToNumber(Ae.readBytes(32));
  if (Pe === 0)
    return Ae.setPosition(t + 32), ["", 32];
  const Te = Ae.readBytes(Pe, 32), Me = bytesToString(trim(Te));
  return Ae.setPosition(t + 32), [Me, 32];
}
function hasDynamicChild(Ae) {
  var Be;
  const { type: t } = Ae;
  if (t === "string" || t === "bytes" || t.endsWith("[]"))
    return !0;
  if (t === "tuple")
    return (Be = Ae.components) == null ? void 0 : Be.some(hasDynamicChild);
  const Ie = getArrayComponents(Ae.type);
  return !!(Ie && hasDynamicChild({ ...Ae, type: Ie[1] }));
}
function decodeErrorResult(Ae) {
  const { abi: t, data: Ie } = Ae, Be = slice(Ie, 0, 4);
  if (Be === "0x")
    throw new AbiDecodingZeroDataError();
  const Te = [...t || [], solidityError, solidityPanic].find((Me) => Me.type === "error" && Be === toFunctionSelector(formatAbiItem$1(Me)));
  if (!Te)
    throw new AbiErrorSignatureNotFoundError(Be, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem: Te,
    args: "inputs" in Te && Te.inputs && Te.inputs.length > 0 ? decodeAbiParameters(Te.inputs, slice(Ie, 4)) : void 0,
    errorName: Te.name
  };
}
function formatAbiItemWithArgs({ abiItem: Ae, args: t, includeFunctionName: Ie = !0, includeName: Be = !1 }) {
  if ("name" in Ae && "inputs" in Ae && Ae.inputs)
    return `${Ie ? Ae.name : ""}(${Ae.inputs.map((Pe, Te) => `${Be && Pe.name ? `${Pe.name}: ` : ""}${typeof t[Te] == "object" ? stringify$2(t[Te]) : t[Te]}`).join(", ")})`;
}
const toEventSelector = toSignatureHash;
function getAbiItem(Ae) {
  const { abi: t, args: Ie = [], name: Be } = Ae, Pe = isHex(Be, { strict: !1 }), Te = t.filter((Ue) => Pe ? Ue.type === "function" ? toFunctionSelector(Ue) === Be : Ue.type === "event" ? toEventSelector(Ue) === Be : !1 : "name" in Ue && Ue.name === Be);
  if (Te.length === 0)
    return;
  if (Te.length === 1)
    return Te[0];
  let Me;
  for (const Ue of Te) {
    if (!("inputs" in Ue))
      continue;
    if (!Ie || Ie.length === 0) {
      if (!Ue.inputs || Ue.inputs.length === 0)
        return Ue;
      continue;
    }
    if (!Ue.inputs || Ue.inputs.length === 0 || Ue.inputs.length !== Ie.length)
      continue;
    if (Ie.every((fn, Ve) => {
      const vn = "inputs" in Ue && Ue.inputs[Ve];
      return vn ? isArgOfType(fn, vn) : !1;
    })) {
      if (Me && "inputs" in Me && Me.inputs) {
        const fn = getAmbiguousTypes(Ue.inputs, Me.inputs, Ie);
        if (fn)
          throw new AbiItemAmbiguityError({
            abiItem: Ue,
            type: fn[0]
          }, {
            abiItem: Me,
            type: fn[1]
          });
      }
      Me = Ue;
    }
  }
  return Me || Te[0];
}
function isArgOfType(Ae, t) {
  const Ie = typeof Ae, Be = t.type;
  switch (Be) {
    case "address":
      return isAddress(Ae, { strict: !1 });
    case "bool":
      return Ie === "boolean";
    case "function":
      return Ie === "string";
    case "string":
      return Ie === "string";
    default:
      return Be === "tuple" && "components" in t ? Object.values(t.components).every((Pe, Te) => isArgOfType(Object.values(Ae)[Te], Pe)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(Be) ? Ie === "number" || Ie === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(Be) ? Ie === "string" || Ae instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(Be) ? Array.isArray(Ae) && Ae.every((Pe) => isArgOfType(Pe, {
        ...t,
        // Pop off `[]` or `[M]` from end of type
        type: Be.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1;
  }
}
function getAmbiguousTypes(Ae, t, Ie) {
  for (const Be in Ae) {
    const Pe = Ae[Be], Te = t[Be];
    if (Pe.type === "tuple" && Te.type === "tuple" && "components" in Pe && "components" in Te)
      return getAmbiguousTypes(Pe.components, Te.components, Ie[Be]);
    const Me = [Pe.type, Te.type];
    if (Me.includes("address") && Me.includes("bytes20") ? !0 : Me.includes("address") && Me.includes("string") ? isAddress(Ie[Be], { strict: !1 }) : Me.includes("address") && Me.includes("bytes") ? isAddress(Ie[Be], { strict: !1 }) : !1)
      return Me;
  }
}
class CallExecutionError extends BaseError$1 {
  constructor(t, { account: Ie, docsPath: Be, chain: Pe, data: Te, gas: Me, gasPrice: Ue, maxFeePerGas: je, maxPriorityFeePerGas: fn, nonce: Ve, to: vn, value: En, stateOverride: fi }) {
    var _i;
    const bi = Ie ? parseAccount(Ie) : void 0;
    let mi = prettyPrint({
      from: bi == null ? void 0 : bi.address,
      to: vn,
      value: typeof En < "u" && `${formatEther(En)} ${((_i = Pe == null ? void 0 : Pe.nativeCurrency) == null ? void 0 : _i.symbol) || "ETH"}`,
      data: Te,
      gas: Me,
      gasPrice: typeof Ue < "u" && `${formatGwei(Ue)} gwei`,
      maxFeePerGas: typeof je < "u" && `${formatGwei(je)} gwei`,
      maxPriorityFeePerGas: typeof fn < "u" && `${formatGwei(fn)} gwei`,
      nonce: Ve
    });
    fi && (mi += `
${prettyStateOverride(fi)}`), super(t.shortMessage, {
      cause: t,
      docsPath: Be,
      metaMessages: [
        ...t.metaMessages ? [...t.metaMessages, " "] : [],
        "Raw Call Arguments:",
        mi
      ].filter(Boolean),
      name: "CallExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = t;
  }
}
class ContractFunctionExecutionError extends BaseError$1 {
  constructor(t, { abi: Ie, args: Be, contractAddress: Pe, docsPath: Te, functionName: Me, sender: Ue }) {
    const je = getAbiItem({ abi: Ie, args: Be, name: Me }), fn = je ? formatAbiItemWithArgs({
      abiItem: je,
      args: Be,
      includeFunctionName: !1,
      includeName: !1
    }) : void 0, Ve = je ? formatAbiItem$1(je, { includeName: !0 }) : void 0, vn = prettyPrint({
      address: Pe && getContractAddress(Pe),
      function: Ve,
      args: fn && fn !== "()" && `${[...Array((Me == null ? void 0 : Me.length) ?? 0).keys()].map(() => " ").join("")}${fn}`,
      sender: Ue
    });
    super(t.shortMessage || `An unknown error occurred while executing the contract function "${Me}".`, {
      cause: t,
      docsPath: Te,
      metaMessages: [
        ...t.metaMessages ? [...t.metaMessages, " "] : [],
        vn && "Contract Call:",
        vn
      ].filter(Boolean),
      name: "ContractFunctionExecutionError"
    }), Object.defineProperty(this, "abi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "args", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "contractAddress", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "formattedArgs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "functionName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sender", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abi = Ie, this.args = Be, this.cause = t, this.contractAddress = Pe, this.functionName = Me, this.sender = Ue;
  }
}
class ContractFunctionRevertedError extends BaseError$1 {
  constructor({ abi: t, data: Ie, functionName: Be, message: Pe }) {
    let Te, Me, Ue, je;
    if (Ie && Ie !== "0x")
      try {
        Me = decodeErrorResult({ abi: t, data: Ie });
        const { abiItem: Ve, errorName: vn, args: En } = Me;
        if (vn === "Error")
          je = En[0];
        else if (vn === "Panic") {
          const [fi] = En;
          je = panicReasons[fi];
        } else {
          const fi = Ve ? formatAbiItem$1(Ve, { includeName: !0 }) : void 0, bi = Ve && En ? formatAbiItemWithArgs({
            abiItem: Ve,
            args: En,
            includeFunctionName: !1,
            includeName: !1
          }) : void 0;
          Ue = [
            fi ? `Error: ${fi}` : "",
            bi && bi !== "()" ? `       ${[...Array((vn == null ? void 0 : vn.length) ?? 0).keys()].map(() => " ").join("")}${bi}` : ""
          ];
        }
      } catch (Ve) {
        Te = Ve;
      }
    else Pe && (je = Pe);
    let fn;
    Te instanceof AbiErrorSignatureNotFoundError && (fn = Te.signature, Ue = [
      `Unable to decode signature "${fn}" as it was not found on the provided ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${fn}.`
    ]), super(je && je !== "execution reverted" || fn ? [
      `The contract function "${Be}" reverted with the following ${fn ? "signature" : "reason"}:`,
      je || fn
    ].join(`
`) : `The contract function "${Be}" reverted.`, {
      cause: Te,
      metaMessages: Ue,
      name: "ContractFunctionRevertedError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reason", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = Me, this.reason = je, this.signature = fn;
  }
}
class ContractFunctionZeroDataError extends BaseError$1 {
  constructor({ functionName: t }) {
    super(`The contract function "${t}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${t}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ],
      name: "ContractFunctionZeroDataError"
    });
  }
}
class CounterfactualDeploymentFailedError extends BaseError$1 {
  constructor({ factory: t }) {
    super(`Deployment for counterfactual contract call failed${t ? ` for factory "${t}".` : ""}`, {
      metaMessages: [
        "Please ensure:",
        "- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).",
        "- The `factoryData` is a valid encoded function call for contract deployment function on the factory."
      ],
      name: "CounterfactualDeploymentFailedError"
    });
  }
}
class RawContractError extends BaseError$1 {
  constructor({ data: t, message: Ie }) {
    super(Ie || "", { name: "RawContractError" }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = t;
  }
}
function getCallError(Ae, { docsPath: t, ...Ie }) {
  const Be = (() => {
    const Pe = getNodeError(Ae, Ie);
    return Pe instanceof UnknownNodeError ? Ae : Pe;
  })();
  return new CallExecutionError(Be, {
    docsPath: t,
    ...Ie
  });
}
const global = globalThis || void 0 || self;
function fixProto(Ae, t) {
  const {
    setPrototypeOf: Ie
  } = Object;
  Ie ? Ie(Ae, t) : Ae.__proto__ = t;
}
function fixStack(Ae, t = Ae.constructor) {
  const {
    captureStackTrace: Ie
  } = Error;
  Ie && Ie(Ae, t);
}
class CustomError extends Error {
  constructor(t, Ie) {
    super(t, Ie), _defineProperty(this, "name", void 0), Object.defineProperty(this, "name", {
      value: new.target.name,
      enumerable: !1,
      configurable: !0
    }), fixProto(this, new.target.prototype), fixStack(this);
  }
}
class AbstractCoreKitError extends CustomError {
  constructor(t, Ie) {
    super(Ie), _defineProperty(this, "code", void 0), _defineProperty(this, "message", void 0), this.code = t, this.message = Ie || "", Object.defineProperty(this, "name", {
      value: "TkeyError"
    });
  }
  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message
    };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
}
class CoreKitError extends AbstractCoreKitError {
  constructor(t, Ie) {
    super(t, Ie), Object.defineProperty(this, "name", {
      value: "CoreKitError"
    });
  }
  static fromCode(t, Ie = "") {
    return new CoreKitError(t, `${CoreKitError.messages[t]} ${Ie}`);
  }
  static default(t = "") {
    return new CoreKitError(1e3, `${CoreKitError.messages[1e3]} ${t}`);
  }
  // Configuration errors
  static chainConfigInvalid(t = "") {
    return CoreKitError.fromCode(1001, t);
  }
  static clientIdInvalid(t = "") {
    return CoreKitError.fromCode(1002, t);
  }
  static storageTypeUnsupported(t = "") {
    return CoreKitError.fromCode(1003, t);
  }
  static oauthLoginUnsupported(t = "") {
    return CoreKitError.fromCode(1004, t);
  }
  static noValidStorageOptionFound(t = "") {
    return CoreKitError.fromCode(1005, t);
  }
  static noDataFoundInStorage(t = "") {
    return CoreKitError.fromCode(1006, t);
  }
  static invalidConfig(t = "") {
    return CoreKitError.fromCode(1007, t);
  }
  // TSS and key management errors
  static tssLibRequired(t = "") {
    return CoreKitError.fromCode(1101, t);
  }
  static tkeyInstanceUninitialized(t = "") {
    return CoreKitError.fromCode(1102, t);
  }
  static duplicateTssIndex(t = "") {
    return CoreKitError.fromCode(1103, t);
  }
  static nodeDetailsRetrievalFailed(t = "") {
    return CoreKitError.fromCode(1104, t);
  }
  static prefetchValueExceeded(t = "") {
    return CoreKitError.fromCode(1105, t);
  }
  static invalidTorusLoginResponse(t = "") {
    return CoreKitError.fromCode(1106, t);
  }
  static invalidTorusAggregateLoginResponse(t = "") {
    return CoreKitError.fromCode(1107, t);
  }
  static unsupportedRedirectMethod(t = "") {
    return CoreKitError.fromCode(1108, t);
  }
  static postBoxKeyMissing(t = "") {
    return CoreKitError.fromCode(1109, t);
  }
  static tssShareTypeIndexMissing(t = "") {
    return CoreKitError.fromCode(1110, t);
  }
  static tssPublicKeyOrEndpointsMissing(t = "") {
    return CoreKitError.fromCode(1111, t);
  }
  static activeSessionNotFound(t = "") {
    return CoreKitError.fromCode(1112, t);
  }
  static tssNoncesMissing(t = "") {
    return CoreKitError.fromCode(1113, t);
  }
  static tssKeyImportNotAllowed(t = "") {
    return CoreKitError.fromCode(1114, t);
  }
  // Factor key and authentication errors
  static factorKeyNotPresent(t = "") {
    return CoreKitError.fromCode(1201, t);
  }
  static factorKeyAlreadyExists(t = "") {
    return CoreKitError.fromCode(1202, t);
  }
  static mfaAlreadyEnabled(t = "") {
    return CoreKitError.fromCode(1203, t);
  }
  static cannotDeleteLastFactor(t = "") {
    return CoreKitError.fromCode(1204, t);
  }
  static factorInUseCannotBeDeleted(t = "") {
    return CoreKitError.fromCode(1205, t);
  }
  static userNotLoggedIn(t = "") {
    return CoreKitError.fromCode(1206, t);
  }
  static providedFactorKeyInvalid(t = "") {
    return CoreKitError.fromCode(1207, t);
  }
  static factorEncsMissing(t = "") {
    return CoreKitError.fromCode(1208, t);
  }
  static noMetadataFound(t = "") {
    return CoreKitError.fromCode(1209, t);
  }
  static newShareIndexInvalid(t = "") {
    return CoreKitError.fromCode(1210, t);
  }
  static maximumFactorsReached(t = "") {
    return CoreKitError.fromCode(1211, t);
  }
  static noMetadataShareFound(t = "") {
    return CoreKitError.fromCode(1212, t);
  }
  static signaturesNotPresent(t = "") {
    return CoreKitError.fromCode(1213, t);
  }
  static factorPubsMissing(t = "") {
    return CoreKitError.fromCode(1214, t);
  }
  // Initialization and session management
  static commitChangesBeforeMFA(t = "") {
    return CoreKitError.fromCode(1301, t);
  }
  static mpcCoreKitNotInitialized(t = "") {
    return CoreKitError.fromCode(1302, t);
  }
}
_defineProperty(CoreKitError, "messages", {
  // Configuration errors
  1001: "You must specify a valid eip155 chain configuration in the options.",
  1002: "You must specify a web3auth clientId.",
  1003: "Unsupported storage type in this UX mode.",
  1004: "OAuth login is NOT supported in this UX mode.",
  1005: "No valid storage option found.",
  1006: "No data found in storage.",
  1007: "Invalid config.",
  // TSS and key management errors
  1101: "'tssLib' is required when running in this UX mode.",
  1102: "'tkey' instance has not been initialized.",
  1103: "Duplicate TSS index found. Ensure that each TSS index is unique.",
  1104: "Failed to retrieve node details. Please check your network connection and try again.",
  1105: "The prefetch TSS public keys exceeds the maximum allowed limit of 3.",
  1106: "Invalid 'TorusLoginResponse' data provided.",
  1107: "Invalid 'TorusAggregateLoginResponse' data provided.",
  1108: "Unsupported method type encountered in redirect result.",
  1109: "OAuthKey not present in state.",
  1110: "TSS Share Type (Index) not present in state when getting current factor key.",
  1111: "'tssPubKey' or 'torusNodeTSSEndpoints' are missing.",
  1112: "No active session found.",
  1113: "tssNonces not present in metadata when getting tss nonce.",
  1114: "A TSS key cannot be imported for an existing user who already has a key configured.",
  // Factor key and authentication errors
  1201: "factorKey not present in state when required.",
  1202: "A factor with the same key already exists.",
  1203: "MFA is already enabled.",
  1204: "Cannot delete the last remaining factor as at least one factor is required.",
  1205: "The factor currently in use cannot be deleted.",
  1206: "User is not logged in.",
  1207: "Provided factor key is invalid.",
  1208: "'factorEncs' mpt [resemt].",
  1209: "No metadata found for the provided factor key. Consider resetting your account if this error persists.",
  1210: "The new share index is not valid. It must be one of the valid share indices.",
  1211: "The maximum number of allowable factors (10) has been reached.",
  1212: "No metadata share found in the current polynomial.",
  1213: "No signatures found.",
  1214: "Factor public keys not present",
  // Initialization and session management
  1301: "The 'CommitChanges' method must be called before enabling MFA.",
  1302: "The MPC Core Kit is not initialized. Please ensure you call the 'init()' method to initialize the kit properly before attempting any operations."
});
let KeyType = /* @__PURE__ */ function(Ae) {
  return Ae.secp256k1 = "secp256k1", Ae.ed25519 = "ed25519", Ae;
}({});
const secp256k1$3 = new ellipticExports.ec("secp256k1");
let Point$1 = class Ha {
  constructor(t, Ie) {
    _defineProperty(this, "x", void 0), _defineProperty(this, "y", void 0), this.x = new BN$1(t, "hex"), this.y = new BN$1(Ie, "hex");
  }
  static fromScalar(t, Ie) {
    const Be = Ie.g.mul(t);
    return Ha.fromElliptic(Be);
  }
  /**
   * @deprecated Use `fromSEC1` instead.
   */
  static fromCompressedPub(t) {
    const Be = secp256k1$3.keyFromPublic(t, "hex").getPublic();
    return new Ha(Be.getX(), Be.getY());
  }
  static fromJSON(t) {
    const {
      x: Ie,
      y: Be
    } = t;
    return new Ha(Ie, Be);
  }
  static fromElliptic(t) {
    return t.isInfinity() ? new Ha(null, null) : new Ha(t.getX(), t.getY());
  }
  /**
   * Construct a point from SEC1 format.
   */
  static fromSEC1(t, Ie) {
    if (Ie.length === 2 && Ie === "00") {
      const Te = t.g.mul(new BN$1(0));
      return Ha.fromElliptic(Te);
    }
    const Pe = t.keyFromPublic(Ie, "hex").getPublic();
    return Ha.fromElliptic(Pe);
  }
  /**
   * @deprecated Use `toSEC1` instead.
   *
   * complies with EC and elliptic pub key types
   */
  encode(t) {
    switch (t) {
      case "arr":
        return Buffer$3.concat([Buffer$3.from("0x04", "hex"), Buffer$3.from(this.x.toString("hex"), "hex"), Buffer$3.from(this.y.toString("hex"), "hex")]);
      case "elliptic-compressed": {
        const Be = secp256k1$3.keyFromPublic({
          x: this.x.toString("hex"),
          y: this.y.toString("hex")
        }, "hex");
        return Buffer$3.from(Be.getPublic(!0, "hex"));
      }
      default:
        throw new Error("encoding doesnt exist in Point");
    }
  }
  toEllipticPoint(t) {
    return this.isIdentity() ? t.g.mul(new BN$1(0)) : t.keyFromPublic({
      x: this.x.toString("hex"),
      y: this.y.toString("hex")
    }, "hex").getPublic();
  }
  /**
   * Returns this point encoded in SEC1 format.
   * @param ec - Curve which point is on.
   * @param compressed - Whether to use compressed format.
   * @returns The SEC1-encoded point.
   */
  toSEC1(t, Ie = !1) {
    if (this.isIdentity())
      return Buffer$3.from("00", "hex");
    const Be = this.toEllipticPoint(t);
    return Buffer$3.from(Be.encode("hex", Ie), "hex");
  }
  toJSON() {
    return {
      x: this.x.toString("hex"),
      y: this.y.toString("hex")
    };
  }
  isIdentity() {
    return this.x === null && this.y === null;
  }
  equals(t) {
    return this.isIdentity() ? t.isIdentity() : this.x.eq(t.x) && this.y.eq(t.y);
  }
};
var Point$1$1 = Point$1;
class Ed25519Curve extends EC$2.ec {
  constructor() {
    super("ed25519");
  }
  bufferToScalar(t) {
    return new BN$1(t, "le");
  }
  generateScalar() {
    return this.genKeyPair().getPrivate();
  }
  scalarToBuffer(t, Ie) {
    return t.toString("hex"), t.toArrayLike(Ie, "le", 32);
  }
  pointToBuffer(t, Ie) {
    const Be = t.getX(), Te = t.getY().toArrayLike(Ie, "le", 32);
    return Te[Te.length - 1] |= Be.and(new BN$1(1)).eqn(1) ? 128 : 0, Te;
  }
}
const WEB3_SESSION_HEADER_KEY = "x-web3-session-id", DELIMITERS = {
  Delimiter1: "",
  Delimiter2: "",
  Delimiter3: "",
  Delimiter4: ""
};
globalThis.tss_clients === void 0 && (globalThis.tss_clients = /* @__PURE__ */ new Map());
globalThis.js_read_msg === void 0 && (globalThis.js_read_msg = async function(Ae, t, Ie, Be) {
  const Pe = globalThis.tss_clients.get(Ae);
  if (Pe.log(`reading msg, ${Be}`), Be === "ga1_worker_support")
    return "unsupported";
  const Te = Pe.msgQueue.find((Me) => Me.sender === Ie && Me.recipient === t && Me.msg_type === Be);
  return Te ? Te.msg_data : new Promise((Me, Ue) => {
    let je = 0;
    const fn = setInterval(() => {
      const Ve = Pe.msgQueue.find((vn) => vn.sender === Ie && vn.recipient === t && vn.msg_type === Be);
      Ve !== void 0 && (clearInterval(fn), Me(Ve.msg_data)), je >= 1e3 && (clearInterval(fn), Ue("Message not received in a reasonable time")), je++;
    }, 10);
  });
});
globalThis.js_send_msg === void 0 && (globalThis.js_send_msg = async function(Ae, t, Ie, Be, Pe) {
  const Te = globalThis.tss_clients.get(Ae);
  if (Te.log(`sending msg, ${Be}`), Be.indexOf("ga1_data_unprocessed") > -1)
    throw new Error("ga1_data_unprocessed should not be sent directly");
  if (Te.websocketOnly)
    Te.sockets[Ie].emit("send_msg", {
      session: Ae,
      sender: t,
      recipient: Ie,
      msg_type: Be,
      msg_data: Pe
    });
  else {
    const Me = Ae.split(DELIMITERS.Delimiter4)[1], Ue = Te.lookupEndpoint(Ae, Ie);
    fetch(`${Ue}/send`, {
      method: "POST",
      headers: {
        [WEB3_SESSION_HEADER_KEY]: Me,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        session: Ae,
        sender: t,
        recipient: Ie,
        msg_type: Be,
        msg_data: Pe
      })
    });
  }
  return !0;
});
var tssClientUtil_cjs = { exports: {} };
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(defineProperty);
(function(Ae) {
  (() => {
    var t = {};
    t.n = (fi) => {
      var bi = fi && fi.__esModule ? (
        /******/
        () => fi.default
      ) : (
        /******/
        () => fi
      );
      return t.d(bi, { a: bi }), bi;
    }, t.d = (fi, bi) => {
      for (var mi in bi)
        t.o(bi, mi) && !t.o(fi, mi) && Object.defineProperty(fi, mi, { enumerable: !0, get: bi[mi] });
    }, t.o = (fi, bi) => Object.prototype.hasOwnProperty.call(fi, bi), t.r = (fi) => {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(fi, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(fi, "__esModule", { value: !0 });
    };
    var Ie = {};
    t.r(Ie), t.d(Ie, {
      AwaitableMap: () => (
        /* reexport */
        Te
      ),
      MapQueue: () => (
        /* reexport */
        Me
      ),
      deriveShareCoefficients: () => (
        /* reexport */
        En
      ),
      fraction: () => (
        /* reexport */
        fn
      ),
      lagrangeCoefficient: () => (
        /* reexport */
        Ve
      ),
      lagrangeCoefficients: () => (
        /* reexport */
        vn
      )
    });
    const Be = require$$0$2;
    var Pe = /* @__PURE__ */ t.n(Be);
    class Te {
      constructor() {
        Pe()(this, "map", /* @__PURE__ */ new Map()), Pe()(this, "queue", /* @__PURE__ */ new Map());
      }
      get size() {
        return this.map.size;
      }
      getSync(bi) {
        return this.map.get(bi);
      }
      /**
       * Gets the value at key `k`, or waits for the duration of `timeout` for a
       * corresponding value to be set. If `timeout` is reached, returns
       * `undefined`.
       */
      async get(bi, mi = 0) {
        const _i = this.map.get(bi);
        return _i || new Promise((Ei) => {
          const Si = {
            resolve: Ei,
            timeout: setTimeout(() => {
              const Oi = this.queue.get(bi);
              if (Oi) {
                const Fi = Oi.indexOf(Si);
                Fi >= 0 && Oi.splice(Fi, 1);
              }
              Ei(void 0);
            }, mi)
          };
          let Mi = this.queue.get(bi);
          Mi || (Mi = [], this.queue.set(bi, Mi)), Mi.push(Si);
        });
      }
      set(bi, mi) {
        this.map.set(bi, mi);
        const _i = this.queue.get(bi);
        if (_i) {
          for (const Ei of _i)
            clearTimeout(Ei.timeout), Ei.resolve(mi);
          this.queue.delete(bi);
        }
      }
      delete(bi) {
        this.map.delete(bi), this.queue.delete(bi);
      }
      forEach(bi) {
        this.map.forEach(bi);
      }
      clear() {
        this.map.clear(), this.queue.clear();
      }
    }
    class Me {
      constructor() {
        Pe()(this, "buffer", /* @__PURE__ */ new Map()), Pe()(this, "queue", /* @__PURE__ */ new Map());
      }
      /**
       * Pops the next value queued for key `k` from the buffer, or waits for the
       * duration of `timeout` for a corresponding value to arrive. If `timeout` is
       * reached, returns `undefined`.
       */
      async pop(bi, mi = 0) {
        const _i = this.buffer.get(bi);
        return _i && _i.length > 0 ? _i.splice(0, 1)[0] : new Promise((Ei) => {
          const Si = {
            resolve: Ei,
            timeout: setTimeout(() => {
              const Oi = this.queue.get(bi);
              if (Oi) {
                const Fi = Oi.indexOf(Si);
                Fi >= 0 && Oi.splice(Fi, 1);
              }
              Ei(void 0);
            }, mi)
          };
          let Mi = this.queue.get(bi);
          Mi || (Mi = [], this.queue.set(bi, Mi)), Mi.push(Si);
        });
      }
      push(bi, mi) {
        const _i = this.queue.get(bi);
        if (_i && _i.length > 0) {
          const Si = _i.splice(0, 1)[0];
          clearTimeout(Si.timeout), Si.resolve(mi);
          return;
        }
        let Ei = this.buffer.get(bi);
        Ei || (Ei = [], this.buffer.set(bi, Ei)), Ei.push(mi);
      }
      delete(bi) {
        this.buffer.delete(bi), this.queue.delete(bi);
      }
      forEach(bi) {
        this.buffer.forEach((mi, _i) => {
          mi.forEach((Ei) => {
            bi(Ei, _i);
          });
        });
      }
      clear() {
        this.buffer.clear(), this.queue.clear();
      }
    }
    const Ue = bnExports;
    var je = /* @__PURE__ */ t.n(Ue);
    function fn(fi, bi, mi) {
      return fi.mul(bi.invm(mi)).umod(mi);
    }
    function Ve(fi, bi, mi, _i) {
      return fi.filter((Ei, Si) => Si !== bi).reduce((Ei, Si) => {
        const Mi = fn(mi.sub(Si), fi[bi].sub(Si), _i);
        return Ei.mul(Mi).umod(_i);
      }, new (je())(1));
    }
    function vn(fi, bi, mi) {
      const _i = fi.map((Si) => new (je())(Si)), Ei = new (je())(bi);
      return _i.map((Si, Mi) => Ve(_i, Mi, Ei, mi));
    }
    function En(fi, bi, mi, _i = 1, Ei = 2) {
      const Si = vn([_i, Ei], 0, mi), Mi = vn(fi, 0, mi);
      if (fi.includes(bi))
        throw new Error(`Invalid server x-coordinates: overlapping with client x-coordinate: ${fi} ${bi}`);
      const Oi = vn([bi, ...fi], 0, mi), Fi = Mi.map((Pi, Bi) => fn(Si[0].mul(Pi), Oi[Bi + 1], mi)), Ui = fn(Si[1], Oi[0], mi);
      return {
        serverCoefficients: Fi,
        clientCoefficient: Ui
      };
    }
    Ae.exports = Ie;
  })();
})(tssClientUtil_cjs);
const TORUS_LEGACY_NETWORK = {
  MAINNET: "mainnet",
  TESTNET: "testnet",
  CYAN: "cyan",
  AQUA: "aqua",
  CELESTE: "celeste"
}, TORUS_SAPPHIRE_NETWORK = {
  SAPPHIRE_DEVNET: "sapphire_devnet",
  SAPPHIRE_MAINNET: "sapphire_mainnet"
};
TORUS_LEGACY_NETWORK.MAINNET + "", TORUS_LEGACY_NETWORK.TESTNET + "", TORUS_LEGACY_NETWORK.CYAN + "", TORUS_LEGACY_NETWORK.AQUA + "", TORUS_LEGACY_NETWORK.CELESTE + "";
TORUS_LEGACY_NETWORK.AQUA + "", TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET, TORUS_LEGACY_NETWORK.CELESTE + "", TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET, TORUS_LEGACY_NETWORK.CYAN + "", TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET, TORUS_LEGACY_NETWORK.MAINNET + "", TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET, TORUS_LEGACY_NETWORK.TESTNET + "", TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET;
TORUS_LEGACY_NETWORK.MAINNET + "", TORUS_LEGACY_NETWORK.TESTNET + "", TORUS_LEGACY_NETWORK.CYAN + "", TORUS_LEGACY_NETWORK.AQUA + "", TORUS_LEGACY_NETWORK.CELESTE + "";
TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET + "", TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET + "", TORUS_LEGACY_NETWORK.MAINNET + "", TORUS_LEGACY_NETWORK.TESTNET + "", TORUS_LEGACY_NETWORK.CYAN + "", TORUS_LEGACY_NETWORK.AQUA + "", TORUS_LEGACY_NETWORK.CELESTE + "";
TORUS_LEGACY_NETWORK.MAINNET + "", TORUS_LEGACY_NETWORK.TESTNET + "", TORUS_LEGACY_NETWORK.CYAN + "", TORUS_LEGACY_NETWORK.AQUA + "", TORUS_LEGACY_NETWORK.CELESTE + "";
function storageAvailable(Ae) {
  let t = !1, Ie = 0, Be;
  try {
    Be = window[Ae], t = !0, Ie = Be.length;
    const Pe = "__storage_test__";
    return Be.setItem(Pe, Pe), Be.removeItem(Pe), !0;
  } catch (Pe) {
    const Te = Pe;
    return Te && // everything except Firefox
    (Te.code === 22 || // Firefox
    Te.code === 1014 || // test name field too, because code might not be present
    // everything except Firefox
    Te.name === "QuotaExceededError" || // Firefox
    Te.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
    t && Ie !== 0;
  }
}
class MemoryStore {
  constructor() {
    _defineProperty(this, "store", /* @__PURE__ */ new Map());
  }
  getItem(t) {
    return this.store.get(t) || null;
  }
  setItem(t, Ie) {
    this.store.set(t, Ie);
  }
  removeItem(t) {
    this.store.delete(t);
  }
}
class BrowserStorage {
  constructor(t, Ie) {
    _defineProperty(this, "storage", void 0), _defineProperty(this, "_storeKey", void 0), this.storage = Ie, this._storeKey = t;
    try {
      Ie.getItem(t) || this.resetStore();
    } catch {
    }
  }
  static getInstance(t) {
    let Ie = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "local";
    if (!this.instanceMap.has(t)) {
      let Be;
      Ie === "local" && storageAvailable("localStorage") ? Be = window.localStorage : Ie === "session" && storageAvailable("sessionStorage") ? Be = window.sessionStorage : Be = new MemoryStore(), this.instanceMap.set(t, new this(t, Be));
    }
    return this.instanceMap.get(t);
  }
  toJSON() {
    return this.storage.getItem(this._storeKey);
  }
  resetStore() {
    const t = this.getStore();
    return this.storage.removeItem(this._storeKey), t;
  }
  getStore() {
    return JSON.parse(this.storage.getItem(this._storeKey) || "{}");
  }
  get(t) {
    return JSON.parse(this.storage.getItem(this._storeKey) || "{}")[t];
  }
  set(t, Ie) {
    const Be = JSON.parse(this.storage.getItem(this._storeKey) || "{}");
    Be[t] = Ie, this.storage.setItem(this._storeKey, JSON.stringify(Be));
  }
}
_defineProperty(BrowserStorage, "instanceMap", /* @__PURE__ */ new Map());
_objectSpread2(_objectSpread2({}, TORUS_SAPPHIRE_NETWORK), TORUS_LEGACY_NETWORK);
function sigToRSV(Ae) {
  if (Ae.length !== 65)
    throw new Error(`Invalid signature length: expected 65, got ${Ae.length}`);
  return {
    r: Ae.subarray(0, 32),
    s: Ae.subarray(32, 64),
    v: Ae[64]
  };
}
function makeEthereumSigner(Ae) {
  if (Ae.keyType !== KeyType.secp256k1)
    throw new Error(`Invalid key type: expected secp256k1, got ${Ae.keyType}`);
  return {
    sign: async (t) => {
      const Ie = await Ae.sign(t, !0);
      return sigToRSV(Ie);
    },
    getPublic: async () => Point$1$1.fromSEC1(secp256k1$3, Ae.getPubKey().toString("hex")).toSEC1(secp256k1$3).subarray(1)
  };
}
const log = loglevel$1.getLogger("mpc-core-kit");
log.disableAll();
class BaseProvider extends BaseController {
  constructor({
    config: t,
    state: Ie
  }) {
    if (super({
      config: t,
      state: Ie
    }), _defineProperty(this, "_providerEngineProxy", null), _defineProperty(this, "keyExportFlagSetByCode", !1), !t.chainConfig) throw WalletInitializationError.invalidProviderConfigError("Please provide chainConfig");
    if (!t.chainConfig.chainId) throw WalletInitializationError.invalidProviderConfigError("Please provide chainId inside chainConfig");
    if (!t.chainConfig.rpcTarget) throw WalletInitializationError.invalidProviderConfigError("Please provide rpcTarget inside chainConfig");
    typeof t.keyExportEnabled == "boolean" && (this.keyExportFlagSetByCode = !0), this.defaultState = {
      chainId: "loading"
    }, this.defaultConfig = {
      chainConfig: t.chainConfig,
      networks: {
        [t.chainConfig.chainId]: t.chainConfig
      },
      keyExportEnabled: typeof t.keyExportEnabled == "boolean" ? t.keyExportEnabled : !0
    }, super.initialize();
  }
  get currentChainConfig() {
    return this.config.chainConfig;
  }
  get provider() {
    return this._providerEngineProxy;
  }
  get chainId() {
    return this.state.chainId;
  }
  set provider(t) {
    throw new Error("Method not implemented.");
  }
  async request(t) {
    var Ie;
    if (!t || typeof t != "object" || Array.isArray(t))
      throw rpcErrors.invalidRequest({
        message: WalletProviderError.invalidRequestArgs().message,
        data: _objectSpread2(_objectSpread2({}, t || {}), {}, {
          cause: WalletProviderError.invalidRequestArgs().message
        })
      });
    const {
      method: Be,
      params: Pe
    } = t;
    if (typeof Be != "string" || Be.length === 0)
      throw rpcErrors.invalidRequest({
        message: WalletProviderError.invalidRequestMethod().message,
        data: _objectSpread2(_objectSpread2({}, t || {}), {}, {
          cause: WalletProviderError.invalidRequestMethod().message
        })
      });
    if (Pe !== void 0 && !Array.isArray(Pe) && (typeof Pe != "object" || Pe === null))
      throw rpcErrors.invalidRequest({
        message: WalletProviderError.invalidRequestParams().message,
        data: _objectSpread2(_objectSpread2({}, t || {}), {}, {
          cause: WalletProviderError.invalidRequestParams().message
        })
      });
    return (Ie = this.provider) === null || Ie === void 0 ? void 0 : Ie.request(t);
  }
  sendAsync(t, Ie) {
    return Ie ? this.send(t, Ie) : this.request(t);
  }
  send(t, Ie) {
    this.request(t).then((Be) => Ie(null, {
      result: Be
    })).catch((Be) => Ie(Be, null));
  }
  addChain(t) {
    if (!t.chainId || !t.rpcTarget) throw rpcErrors.invalidParams("chainId is required");
    this.configure({
      networks: _objectSpread2(_objectSpread2({}, this.config.networks), {}, {
        [t.chainId]: t
      })
    });
  }
  getChainConfig(t) {
    var Ie;
    const Be = (Ie = this.config.networks) === null || Ie === void 0 ? void 0 : Ie[t];
    if (!Be) throw rpcErrors.invalidRequest(`Chain ${t} is not supported, please add chainConfig for it`);
    return Be;
  }
  updateProviderEngineProxy(t) {
    this._providerEngineProxy ? this._providerEngineProxy.setTarget(t) : this._providerEngineProxy = createEventEmitterProxy(t);
  }
  setKeyExportFlag(t) {
    this.keyExportFlagSetByCode || this.configure({
      keyExportEnabled: t
    });
  }
  getProviderEngineProxy() {
    return this._providerEngineProxy;
  }
}
function createWalletMiddleware({
  getAccounts: Ae,
  getPrivateKey: t,
  getPublicKey: Ie,
  processEthSignMessage: Be,
  processPersonalMessage: Pe,
  processTransaction: Te,
  processSignTransaction: Me,
  processTypedMessageV4: Ue
}) {
  if (!Ae)
    throw new Error("opts.getAccounts is required");
  async function je(Ei, Si) {
    if (typeof Ei == "string" && Ei.length > 0) {
      const Oi = (await Ae(Si)).map((Ui) => Ui.toLowerCase()), Fi = Ei.toLowerCase();
      if (Oi.includes(Fi))
        return Fi;
    }
    throw rpcErrors.invalidParams({
      message: "Invalid parameters: must provide an Ethereum address."
    });
  }
  async function fn(Ei, Si) {
    Si.result = await Ae(Ei);
  }
  async function Ve(Ei, Si) {
    if (!Te)
      throw rpcErrors.methodNotSupported();
    const Mi = Ei.params[0] || {
      from: ""
    };
    Mi.from = await je(Mi.from, Ei), Si.result = await Te(Mi, Ei);
  }
  async function vn(Ei, Si) {
    if (!Me)
      throw rpcErrors.methodNotSupported();
    const Mi = Ei.params[0] || {
      from: ""
    };
    Mi.from = await je(Mi.from, Ei), Si.result = await Me(Mi, Ei);
  }
  async function En(Ei, Si) {
    if (!Be)
      throw rpcErrors.methodNotSupported();
    let Mi = Ei.params;
    const Oi = Ei.params[2] || {};
    if (Array.isArray(Ei.params)) {
      if (Ei.params.length !== 2) throw new Error(`WalletMiddleware - incorrect params for ${Ei.method} method. expected [address, message]`);
      const Fi = Ei.params, Ui = Fi[0], Pi = Fi[1];
      Mi = {
        from: Ui,
        data: Pi
      };
    }
    Mi = _objectSpread2(_objectSpread2({}, Oi), Mi), Si.result = await Be(Mi, Ei);
  }
  async function fi(Ei, Si) {
    if (!Ue)
      throw rpcErrors.methodNotSupported();
    if (!(Ei != null && Ei.params)) throw new Error("WalletMiddleware - missing params");
    let Mi = Ei.params;
    if (Array.isArray(Ei.params)) {
      if (Ei.params.length !== 2) throw new Error(`WalletMiddleware - incorrect params for ${Ei.method} method. expected [address, typedData]`);
      const Oi = Ei.params, Fi = Oi[0], Ui = Oi[1];
      Mi = {
        from: Fi,
        data: Ui
      };
    }
    Si.result = await Ue(Mi, Ei);
  }
  async function bi(Ei, Si) {
    if (!Pe)
      throw rpcErrors.methodNotSupported();
    let Mi = Ei.params;
    const Oi = Ei.params[2] || {};
    if (Array.isArray(Ei.params)) {
      if (!(Ei.params.length >= 2)) throw new Error(`WalletMiddleware - incorrect params for ${Ei.method} method. expected [message, address]`);
      const Fi = Ei.params;
      if (typeof Fi[0] == "object") {
        const {
          challenge: Ui,
          address: Pi
        } = Fi[0];
        Mi = {
          from: Pi,
          data: Ui
        };
      } else {
        const Ui = Fi[0];
        Mi = {
          from: Fi[1],
          data: Ui
        };
      }
    }
    Mi = _objectSpread2(_objectSpread2({}, Oi), Mi), Si.result = await Pe(Mi, Ei);
  }
  async function mi(Ei, Si) {
    if (!t)
      throw rpcErrors.methodNotSupported();
    Si.result = t(Ei);
  }
  async function _i(Ei, Si) {
    if (!Ie)
      throw rpcErrors.methodNotSupported();
    Si.result = Ie(Ei);
  }
  return createScaffoldMiddleware({
    // account lookups
    eth_accounts: createAsyncMiddleware(fn),
    eth_private_key: createAsyncMiddleware(mi),
    eth_public_key: createAsyncMiddleware(_i),
    public_key: createAsyncMiddleware(_i),
    private_key: createAsyncMiddleware(mi),
    // tx signatures
    eth_sendTransaction: createAsyncMiddleware(Ve),
    eth_signTransaction: createAsyncMiddleware(vn),
    // message signatures
    eth_sign: createAsyncMiddleware(En),
    eth_signTypedData_v4: createAsyncMiddleware(fi),
    personal_sign: createAsyncMiddleware(bi)
  });
}
function createEthMiddleware(Ae) {
  const {
    getAccounts: t,
    getPrivateKey: Ie,
    getPublicKey: Be,
    processTransaction: Pe,
    processSignTransaction: Te,
    processEthSignMessage: Me,
    processTypedMessageV4: Ue,
    processPersonalMessage: je
  } = Ae;
  return mergeMiddleware([createScaffoldMiddleware({
    eth_syncing: !1
  }), createWalletMiddleware({
    getAccounts: t,
    getPrivateKey: Ie,
    getPublicKey: Be,
    processTransaction: Pe,
    processEthSignMessage: Me,
    processSignTransaction: Te,
    processTypedMessageV4: Ue,
    processPersonalMessage: je
  })]);
}
function createChainSwitchMiddleware({
  addChain: Ae,
  switchChain: t
}) {
  async function Ie(Pe, Te) {
    var Me;
    const Ue = (Me = Pe.params) !== null && Me !== void 0 && Me.length ? Pe.params[0] : void 0;
    if (!Ue) throw rpcErrors.invalidParams("Missing chain params");
    if (!Ue.chainId) throw rpcErrors.invalidParams("Missing chainId in chainParams");
    if (!Ue.rpcUrls || Ue.rpcUrls.length === 0) throw rpcErrors.invalidParams("Missing rpcUrls in chainParams");
    if (!Ue.nativeCurrency) throw rpcErrors.invalidParams("Missing nativeCurrency in chainParams");
    Te.result = await Ae(Ue);
  }
  async function Be(Pe, Te) {
    var Me;
    const Ue = (Me = Pe.params) !== null && Me !== void 0 && Me.length ? Pe.params[0] : void 0;
    if (!Ue) throw rpcErrors.invalidParams("Missing chainId");
    Te.result = await t(Ue);
  }
  return createScaffoldMiddleware({
    wallet_addEthereumChain: createAsyncMiddleware(Ie),
    wallet_switchEthereumChain: createAsyncMiddleware(Be)
  });
}
function createChainIdMiddleware(Ae) {
  return (t, Ie, Be, Pe) => t.method === "eth_chainId" ? (Ie.result = Ae, Pe()) : Be();
}
function createProviderConfigMiddleware(Ae) {
  return (t, Ie, Be, Pe) => t.method === "eth_provider_config" ? (Ie.result = Ae, Pe()) : Be();
}
function createJsonRpcClient(Ae) {
  const {
    chainId: t,
    rpcTarget: Ie
  } = Ae, Be = createFetchMiddleware({
    rpcTarget: Ie
  });
  return {
    networkMiddleware: mergeMiddleware([createChainIdMiddleware(t), createProviderConfigMiddleware(Ae), Be]),
    fetchMiddleware: Be
  };
}
const version$5 = "6.13.4";
function defineProperties(Ae, t, Ie) {
  for (let Be in t) {
    let Pe = t[Be];
    Object.defineProperty(Ae, Be, { enumerable: !0, value: Pe, writable: !1 });
  }
}
function stringify$1(Ae) {
  if (Ae == null)
    return "null";
  if (Array.isArray(Ae))
    return "[ " + Ae.map(stringify$1).join(", ") + " ]";
  if (Ae instanceof Uint8Array) {
    const t = "0123456789abcdef";
    let Ie = "0x";
    for (let Be = 0; Be < Ae.length; Be++)
      Ie += t[Ae[Be] >> 4], Ie += t[Ae[Be] & 15];
    return Ie;
  }
  if (typeof Ae == "object" && typeof Ae.toJSON == "function")
    return stringify$1(Ae.toJSON());
  switch (typeof Ae) {
    case "boolean":
    case "symbol":
      return Ae.toString();
    case "bigint":
      return BigInt(Ae).toString();
    case "number":
      return Ae.toString();
    case "string":
      return JSON.stringify(Ae);
    case "object": {
      const t = Object.keys(Ae);
      return t.sort(), "{ " + t.map((Ie) => `${stringify$1(Ie)}: ${stringify$1(Ae[Ie])}`).join(", ") + " }";
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function makeError(Ae, t, Ie) {
  let Be = Ae;
  {
    const Te = [];
    if (Ie) {
      if ("message" in Ie || "code" in Ie || "name" in Ie)
        throw new Error(`value will overwrite populated values: ${stringify$1(Ie)}`);
      for (const Me in Ie) {
        if (Me === "shortMessage")
          continue;
        const Ue = Ie[Me];
        Te.push(Me + "=" + stringify$1(Ue));
      }
    }
    Te.push(`code=${t}`), Te.push(`version=${version$5}`), Te.length && (Ae += " (" + Te.join(", ") + ")");
  }
  let Pe;
  switch (t) {
    case "INVALID_ARGUMENT":
      Pe = new TypeError(Ae);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      Pe = new RangeError(Ae);
      break;
    default:
      Pe = new Error(Ae);
  }
  return defineProperties(Pe, { code: t }), Ie && Object.assign(Pe, Ie), Pe.shortMessage == null && defineProperties(Pe, { shortMessage: Be }), Pe;
}
function assert$6(Ae, t, Ie, Be) {
  if (!Ae)
    throw makeError(t, Ie, Be);
}
function assertArgument(Ae, t, Ie, Be) {
  assert$6(Ae, t, "INVALID_ARGUMENT", { argument: Ie, value: Be });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((Ae, t) => {
  try {
    if ("test".normalize(t) !== "test")
      throw new Error("bad");
    if (t === "NFD" && "".normalize("NFD") !== "e")
      throw new Error("broken");
    Ae.push(t);
  } catch {
  }
  return Ae;
}, []);
function assertPrivate(Ae, t, Ie) {
  if (Ae !== t) {
    let Be = Ie, Pe = "new";
    Be += ".", Pe += " " + Ie, assert$6(!1, `private constructor; use ${Be}from* methods`, "UNSUPPORTED_OPERATION", {
      operation: Pe
    });
  }
}
function _getBytes(Ae, t, Ie) {
  if (Ae instanceof Uint8Array)
    return Ie ? new Uint8Array(Ae) : Ae;
  if (typeof Ae == "string" && Ae.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const Be = new Uint8Array((Ae.length - 2) / 2);
    let Pe = 2;
    for (let Te = 0; Te < Be.length; Te++)
      Be[Te] = parseInt(Ae.substring(Pe, Pe + 2), 16), Pe += 2;
    return Be;
  }
  assertArgument(!1, "invalid BytesLike value", t || "value", Ae);
}
function getBytes(Ae, t) {
  return _getBytes(Ae, t, !1);
}
function getBytesCopy(Ae, t) {
  return _getBytes(Ae, t, !0);
}
function isHexString$1(Ae, t) {
  return !(typeof Ae != "string" || !Ae.match(/^0x[0-9A-Fa-f]*$/) || typeof t == "number" && Ae.length !== 2 + 2 * t || t === !0 && Ae.length % 2 !== 0);
}
function isBytesLike$1(Ae) {
  return isHexString$1(Ae, !0) || Ae instanceof Uint8Array;
}
const HexCharacters$1 = "0123456789abcdef";
function hexlify$1(Ae) {
  const t = getBytes(Ae);
  let Ie = "0x";
  for (let Be = 0; Be < t.length; Be++) {
    const Pe = t[Be];
    Ie += HexCharacters$1[(Pe & 240) >> 4] + HexCharacters$1[Pe & 15];
  }
  return Ie;
}
function concat$2(Ae) {
  return "0x" + Ae.map((t) => hexlify$1(t).substring(2)).join("");
}
function dataLength(Ae) {
  return isHexString$1(Ae, !0) ? (Ae.length - 2) / 2 : getBytes(Ae).length;
}
function zeroPad$1(Ae, t, Ie) {
  const Be = getBytes(Ae);
  assert$6(t >= Be.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(Be),
    length: t,
    offset: t + 1
  });
  const Pe = new Uint8Array(t);
  return Pe.fill(0), Pe.set(Be, t - Be.length), hexlify$1(Pe);
}
function zeroPadValue(Ae, t) {
  return zeroPad$1(Ae, t);
}
const BN_0$4 = BigInt(0), BN_1$2 = BigInt(1), maxValue = 9007199254740991;
function toTwos(Ae, t) {
  let Ie = getBigInt(Ae, "value");
  const Be = BigInt(getNumber(t, "width")), Pe = BN_1$2 << Be - BN_1$2;
  if (Ie < BN_0$4) {
    Ie = -Ie, assert$6(Ie <= Pe, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: Ae
    });
    const Te = (BN_1$2 << Be) - BN_1$2;
    return (~Ie & Te) + BN_1$2;
  } else
    assert$6(Ie < Pe, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: Ae
    });
  return Ie;
}
function mask(Ae, t) {
  const Ie = getUint(Ae, "value"), Be = BigInt(getNumber(t, "bits"));
  return Ie & (BN_1$2 << Be) - BN_1$2;
}
function getBigInt(Ae, t) {
  switch (typeof Ae) {
    case "bigint":
      return Ae;
    case "number":
      return assertArgument(Number.isInteger(Ae), "underflow", t || "value", Ae), assertArgument(Ae >= -maxValue && Ae <= maxValue, "overflow", t || "value", Ae), BigInt(Ae);
    case "string":
      try {
        if (Ae === "")
          throw new Error("empty string");
        return Ae[0] === "-" && Ae[1] !== "-" ? -BigInt(Ae.substring(1)) : BigInt(Ae);
      } catch (Ie) {
        assertArgument(!1, `invalid BigNumberish string: ${Ie.message}`, t || "value", Ae);
      }
  }
  assertArgument(!1, "invalid BigNumberish value", t || "value", Ae);
}
function getUint(Ae, t) {
  const Ie = getBigInt(Ae, t);
  return assert$6(Ie >= BN_0$4, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value: Ae
  }), Ie;
}
function getNumber(Ae, t) {
  switch (typeof Ae) {
    case "bigint":
      return assertArgument(Ae >= -maxValue && Ae <= maxValue, "overflow", t || "value", Ae), Number(Ae);
    case "number":
      return assertArgument(Number.isInteger(Ae), "underflow", t || "value", Ae), assertArgument(Ae >= -maxValue && Ae <= maxValue, "overflow", t || "value", Ae), Ae;
    case "string":
      try {
        if (Ae === "")
          throw new Error("empty string");
        return getNumber(BigInt(Ae), t);
      } catch (Ie) {
        assertArgument(!1, `invalid numeric string: ${Ie.message}`, t || "value", Ae);
      }
  }
  assertArgument(!1, "invalid numeric value", t || "value", Ae);
}
function toBeHex(Ae, t) {
  let Be = getUint(Ae, "value").toString(16);
  {
    const Pe = getNumber(t, "width");
    for (assert$6(Pe * 2 >= Be.length, `value exceeds width (${Pe} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: Ae
    }); Be.length < Pe * 2; )
      Be = "0" + Be;
  }
  return "0x" + Be;
}
function toBeArray(Ae) {
  const t = getUint(Ae, "value");
  if (t === BN_0$4)
    return new Uint8Array([]);
  let Ie = t.toString(16);
  Ie.length % 2 && (Ie = "0" + Ie);
  const Be = new Uint8Array(Ie.length / 2);
  for (let Pe = 0; Pe < Be.length; Pe++) {
    const Te = Pe * 2;
    Be[Pe] = parseInt(Ie.substring(Te, Te + 2), 16);
  }
  return Be;
}
function toQuantity(Ae) {
  let t = hexlify$1(isBytesLike$1(Ae) ? Ae : toBeArray(Ae)).substring(2);
  for (; t.startsWith("0"); )
    t = t.substring(1);
  return t === "" && (t = "0"), "0x" + t;
}
function toUtf8Bytes$1(Ae, t) {
  assertArgument(typeof Ae == "string", "invalid string value", "str", Ae);
  let Ie = [];
  for (let Be = 0; Be < Ae.length; Be++) {
    const Pe = Ae.charCodeAt(Be);
    if (Pe < 128)
      Ie.push(Pe);
    else if (Pe < 2048)
      Ie.push(Pe >> 6 | 192), Ie.push(Pe & 63 | 128);
    else if ((Pe & 64512) == 55296) {
      Be++;
      const Te = Ae.charCodeAt(Be);
      assertArgument(Be < Ae.length && (Te & 64512) === 56320, "invalid surrogate pair", "str", Ae);
      const Me = 65536 + ((Pe & 1023) << 10) + (Te & 1023);
      Ie.push(Me >> 18 | 240), Ie.push(Me >> 12 & 63 | 128), Ie.push(Me >> 6 & 63 | 128), Ie.push(Me & 63 | 128);
    } else
      Ie.push(Pe >> 12 | 224), Ie.push(Pe >> 6 & 63 | 128), Ie.push(Pe & 63 | 128);
  }
  return new Uint8Array(Ie);
}
function hexlifyByte(Ae) {
  let t = Ae.toString(16);
  for (; t.length < 2; )
    t = "0" + t;
  return "0x" + t;
}
function unarrayifyInteger(Ae, t, Ie) {
  let Be = 0;
  for (let Pe = 0; Pe < Ie; Pe++)
    Be = Be * 256 + Ae[t + Pe];
  return Be;
}
function _decodeChildren(Ae, t, Ie, Be) {
  const Pe = [];
  for (; Ie < t + 1 + Be; ) {
    const Te = _decode(Ae, Ie);
    Pe.push(Te.result), Ie += Te.consumed, assert$6(Ie <= t + 1 + Be, "child data too short", "BUFFER_OVERRUN", {
      buffer: Ae,
      length: Be,
      offset: t
    });
  }
  return { consumed: 1 + Be, result: Pe };
}
function _decode(Ae, t) {
  assert$6(Ae.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: Ae,
    length: 0,
    offset: 1
  });
  const Ie = (Be) => {
    assert$6(Be <= Ae.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: Ae,
      length: Ae.length,
      offset: Be
    });
  };
  if (Ae[t] >= 248) {
    const Be = Ae[t] - 247;
    Ie(t + 1 + Be);
    const Pe = unarrayifyInteger(Ae, t + 1, Be);
    return Ie(t + 1 + Be + Pe), _decodeChildren(Ae, t, t + 1 + Be, Be + Pe);
  } else if (Ae[t] >= 192) {
    const Be = Ae[t] - 192;
    return Ie(t + 1 + Be), _decodeChildren(Ae, t, t + 1, Be);
  } else if (Ae[t] >= 184) {
    const Be = Ae[t] - 183;
    Ie(t + 1 + Be);
    const Pe = unarrayifyInteger(Ae, t + 1, Be);
    Ie(t + 1 + Be + Pe);
    const Te = hexlify$1(Ae.slice(t + 1 + Be, t + 1 + Be + Pe));
    return { consumed: 1 + Be + Pe, result: Te };
  } else if (Ae[t] >= 128) {
    const Be = Ae[t] - 128;
    Ie(t + 1 + Be);
    const Pe = hexlify$1(Ae.slice(t + 1, t + 1 + Be));
    return { consumed: 1 + Be, result: Pe };
  }
  return { consumed: 1, result: hexlifyByte(Ae[t]) };
}
function decodeRlp(Ae) {
  const t = getBytes(Ae, "data"), Ie = _decode(t, 0);
  return assertArgument(Ie.consumed === t.length, "unexpected junk after rlp payload", "data", Ae), Ie.result;
}
function arrayifyInteger(Ae) {
  const t = [];
  for (; Ae; )
    t.unshift(Ae & 255), Ae >>= 8;
  return t;
}
function _encode(Ae) {
  if (Array.isArray(Ae)) {
    let Be = [];
    if (Ae.forEach(function(Te) {
      Be = Be.concat(_encode(Te));
    }), Be.length <= 55)
      return Be.unshift(192 + Be.length), Be;
    const Pe = arrayifyInteger(Be.length);
    return Pe.unshift(247 + Pe.length), Pe.concat(Be);
  }
  const t = Array.prototype.slice.call(getBytes(Ae, "object"));
  if (t.length === 1 && t[0] <= 127)
    return t;
  if (t.length <= 55)
    return t.unshift(128 + t.length), t;
  const Ie = arrayifyInteger(t.length);
  return Ie.unshift(183 + Ie.length), Ie.concat(t);
}
const nibbles = "0123456789abcdef";
function encodeRlp(Ae) {
  let t = "0x";
  for (const Ie of _encode(Ae))
    t += nibbles[Ie >> 4], t += nibbles[Ie & 15];
  return t;
}
function number(Ae) {
  if (!Number.isSafeInteger(Ae) || Ae < 0)
    throw new Error(`Wrong positive integer: ${Ae}`);
}
function bytes(Ae, ...t) {
  if (!(Ae instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(Ae.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${Ae.length}`);
}
function hash$1(Ae) {
  if (typeof Ae != "function" || typeof Ae.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(Ae.outputLen), number(Ae.blockLen);
}
function exists(Ae, t = !0) {
  if (Ae.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && Ae.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(Ae, t) {
  bytes(Ae);
  const Ie = t.outputLen;
  if (Ae.length < Ie)
    throw new Error(`digestInto() expects output buffer of length at least ${Ie}`);
}
const crypto$2 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$1 = (Ae) => Ae instanceof Uint8Array, u32 = (Ae) => new Uint32Array(Ae.buffer, Ae.byteOffset, Math.floor(Ae.byteLength / 4)), createView = (Ae) => new DataView(Ae.buffer, Ae.byteOffset, Ae.byteLength), rotr = (Ae, t) => Ae << 32 - t | Ae >>> t, isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes$2(Ae) {
  if (typeof Ae != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof Ae}`);
  return new Uint8Array(new TextEncoder().encode(Ae));
}
function toBytes(Ae) {
  if (typeof Ae == "string" && (Ae = utf8ToBytes$2(Ae)), !u8a$1(Ae))
    throw new Error(`expected Uint8Array, got ${typeof Ae}`);
  return Ae;
}
function concatBytes$2(...Ae) {
  const t = new Uint8Array(Ae.reduce((Be, Pe) => Be + Pe.length, 0));
  let Ie = 0;
  return Ae.forEach((Be) => {
    if (!u8a$1(Be))
      throw new Error("Uint8Array expected");
    t.set(Be, Ie), Ie += Be.length;
  }), t;
}
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(Ae) {
  const t = (Be) => Ae().update(toBytes(Be)).digest(), Ie = Ae();
  return t.outputLen = Ie.outputLen, t.blockLen = Ie.blockLen, t.create = () => Ae(), t;
}
function randomBytes(Ae = 32) {
  if (crypto$2 && typeof crypto$2.getRandomValues == "function")
    return crypto$2.getRandomValues(new Uint8Array(Ae));
  throw new Error("crypto.getRandomValues must be defined");
}
let HMAC$2 = class extends Hash {
  constructor(t, Ie) {
    super(), this.finished = !1, this.destroyed = !1, hash$1(t);
    const Be = toBytes(Ie);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const Pe = this.blockLen, Te = new Uint8Array(Pe);
    Te.set(Be.length > Pe ? t.create().update(Be).digest() : Be);
    for (let Me = 0; Me < Te.length; Me++)
      Te[Me] ^= 54;
    this.iHash.update(Te), this.oHash = t.create();
    for (let Me = 0; Me < Te.length; Me++)
      Te[Me] ^= 106;
    this.oHash.update(Te), Te.fill(0);
  }
  update(t) {
    return exists(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    exists(this), bytes(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: Ie, iHash: Be, finished: Pe, destroyed: Te, blockLen: Me, outputLen: Ue } = this;
    return t = t, t.finished = Pe, t.destroyed = Te, t.blockLen = Me, t.outputLen = Ue, t.oHash = Ie._cloneInto(t.oHash), t.iHash = Be._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const hmac$3 = (Ae, t, Ie) => new HMAC$2(Ae, t).update(Ie).digest();
hmac$3.create = (Ae, t) => new HMAC$2(Ae, t);
function setBigUint64(Ae, t, Ie, Be) {
  if (typeof Ae.setBigUint64 == "function")
    return Ae.setBigUint64(t, Ie, Be);
  const Pe = BigInt(32), Te = BigInt(4294967295), Me = Number(Ie >> Pe & Te), Ue = Number(Ie & Te), je = Be ? 4 : 0, fn = Be ? 0 : 4;
  Ae.setUint32(t + je, Me, Be), Ae.setUint32(t + fn, Ue, Be);
}
class SHA2 extends Hash {
  constructor(t, Ie, Be, Pe) {
    super(), this.blockLen = t, this.outputLen = Ie, this.padOffset = Be, this.isLE = Pe, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = createView(this.buffer);
  }
  update(t) {
    exists(this);
    const { view: Ie, buffer: Be, blockLen: Pe } = this;
    t = toBytes(t);
    const Te = t.length;
    for (let Me = 0; Me < Te; ) {
      const Ue = Math.min(Pe - this.pos, Te - Me);
      if (Ue === Pe) {
        const je = createView(t);
        for (; Pe <= Te - Me; Me += Pe)
          this.process(je, Me);
        continue;
      }
      Be.set(t.subarray(Me, Me + Ue), this.pos), this.pos += Ue, Me += Ue, this.pos === Pe && (this.process(Ie, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    exists(this), output(t, this), this.finished = !0;
    const { buffer: Ie, view: Be, blockLen: Pe, isLE: Te } = this;
    let { pos: Me } = this;
    Ie[Me++] = 128, this.buffer.subarray(Me).fill(0), this.padOffset > Pe - Me && (this.process(Be, 0), Me = 0);
    for (let vn = Me; vn < Pe; vn++)
      Ie[vn] = 0;
    setBigUint64(Be, Pe - 8, BigInt(this.length * 8), Te), this.process(Be, 0);
    const Ue = createView(t), je = this.outputLen;
    if (je % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const fn = je / 4, Ve = this.get();
    if (fn > Ve.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let vn = 0; vn < fn; vn++)
      Ue.setUint32(4 * vn, Ve[vn], Te);
  }
  digest() {
    const { buffer: t, outputLen: Ie } = this;
    this.digestInto(t);
    const Be = t.slice(0, Ie);
    return this.destroy(), Be;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: Ie, buffer: Be, length: Pe, finished: Te, destroyed: Me, pos: Ue } = this;
    return t.length = Pe, t.pos = Ue, t.finished = Te, t.destroyed = Me, Pe % Ie && t.buffer.set(Be), t;
  }
}
const Chi = (Ae, t, Ie) => Ae & t ^ ~Ae & Ie, Maj = (Ae, t, Ie) => Ae & t ^ Ae & Ie ^ t & Ie, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV[0] | 0, this.B = IV[1] | 0, this.C = IV[2] | 0, this.D = IV[3] | 0, this.E = IV[4] | 0, this.F = IV[5] | 0, this.G = IV[6] | 0, this.H = IV[7] | 0;
  }
  get() {
    const { A: t, B: Ie, C: Be, D: Pe, E: Te, F: Me, G: Ue, H: je } = this;
    return [t, Ie, Be, Pe, Te, Me, Ue, je];
  }
  // prettier-ignore
  set(t, Ie, Be, Pe, Te, Me, Ue, je) {
    this.A = t | 0, this.B = Ie | 0, this.C = Be | 0, this.D = Pe | 0, this.E = Te | 0, this.F = Me | 0, this.G = Ue | 0, this.H = je | 0;
  }
  process(t, Ie) {
    for (let vn = 0; vn < 16; vn++, Ie += 4)
      SHA256_W[vn] = t.getUint32(Ie, !1);
    for (let vn = 16; vn < 64; vn++) {
      const En = SHA256_W[vn - 15], fi = SHA256_W[vn - 2], bi = rotr(En, 7) ^ rotr(En, 18) ^ En >>> 3, mi = rotr(fi, 17) ^ rotr(fi, 19) ^ fi >>> 10;
      SHA256_W[vn] = mi + SHA256_W[vn - 7] + bi + SHA256_W[vn - 16] | 0;
    }
    let { A: Be, B: Pe, C: Te, D: Me, E: Ue, F: je, G: fn, H: Ve } = this;
    for (let vn = 0; vn < 64; vn++) {
      const En = rotr(Ue, 6) ^ rotr(Ue, 11) ^ rotr(Ue, 25), fi = Ve + En + Chi(Ue, je, fn) + SHA256_K[vn] + SHA256_W[vn] | 0, mi = (rotr(Be, 2) ^ rotr(Be, 13) ^ rotr(Be, 22)) + Maj(Be, Pe, Te) | 0;
      Ve = fn, fn = je, je = Ue, Ue = Me + fi | 0, Me = Te, Te = Pe, Pe = Be, Be = fi + mi | 0;
    }
    Be = Be + this.A | 0, Pe = Pe + this.B | 0, Te = Te + this.C | 0, Me = Me + this.D | 0, Ue = Ue + this.E | 0, je = je + this.F | 0, fn = fn + this.G | 0, Ve = Ve + this.H | 0, this.set(Be, Pe, Te, Me, Ue, je, fn, Ve);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const sha256$2 = /* @__PURE__ */ wrapConstructor(() => new SHA256()), U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1), _32n = /* @__PURE__ */ BigInt(32);
function fromBig(Ae, t = !1) {
  return t ? { h: Number(Ae & U32_MASK64), l: Number(Ae >> _32n & U32_MASK64) } : { h: Number(Ae >> _32n & U32_MASK64) | 0, l: Number(Ae & U32_MASK64) | 0 };
}
function split(Ae, t = !1) {
  let Ie = new Uint32Array(Ae.length), Be = new Uint32Array(Ae.length);
  for (let Pe = 0; Pe < Ae.length; Pe++) {
    const { h: Te, l: Me } = fromBig(Ae[Pe], t);
    [Ie[Pe], Be[Pe]] = [Te, Me];
  }
  return [Ie, Be];
}
const toBig = (Ae, t) => BigInt(Ae >>> 0) << _32n | BigInt(t >>> 0), shrSH = (Ae, t, Ie) => Ae >>> Ie, shrSL = (Ae, t, Ie) => Ae << 32 - Ie | t >>> Ie, rotrSH = (Ae, t, Ie) => Ae >>> Ie | t << 32 - Ie, rotrSL = (Ae, t, Ie) => Ae << 32 - Ie | t >>> Ie, rotrBH = (Ae, t, Ie) => Ae << 64 - Ie | t >>> Ie - 32, rotrBL = (Ae, t, Ie) => Ae >>> Ie - 32 | t << 64 - Ie, rotr32H = (Ae, t) => t, rotr32L = (Ae, t) => Ae, rotlSH = (Ae, t, Ie) => Ae << Ie | t >>> 32 - Ie, rotlSL = (Ae, t, Ie) => t << Ie | Ae >>> 32 - Ie, rotlBH = (Ae, t, Ie) => t << Ie - 32 | Ae >>> 64 - Ie, rotlBL = (Ae, t, Ie) => Ae << Ie - 32 | t >>> 64 - Ie;
function add(Ae, t, Ie, Be) {
  const Pe = (t >>> 0) + (Be >>> 0);
  return { h: Ae + Ie + (Pe / 2 ** 32 | 0) | 0, l: Pe | 0 };
}
const add3L = (Ae, t, Ie) => (Ae >>> 0) + (t >>> 0) + (Ie >>> 0), add3H = (Ae, t, Ie, Be) => t + Ie + Be + (Ae / 2 ** 32 | 0) | 0, add4L = (Ae, t, Ie, Be) => (Ae >>> 0) + (t >>> 0) + (Ie >>> 0) + (Be >>> 0), add4H = (Ae, t, Ie, Be, Pe) => t + Ie + Be + Pe + (Ae / 2 ** 32 | 0) | 0, add5L = (Ae, t, Ie, Be, Pe) => (Ae >>> 0) + (t >>> 0) + (Ie >>> 0) + (Be >>> 0) + (Pe >>> 0), add5H = (Ae, t, Ie, Be, Pe, Te) => t + Ie + Be + Pe + Te + (Ae / 2 ** 32 | 0) | 0, u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
}, [SHA512_Kh, SHA512_Kl] = u64.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((Ae) => BigInt(Ae))), SHA512_W_H = /* @__PURE__ */ new Uint32Array(80), SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends SHA2 {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: t, Al: Ie, Bh: Be, Bl: Pe, Ch: Te, Cl: Me, Dh: Ue, Dl: je, Eh: fn, El: Ve, Fh: vn, Fl: En, Gh: fi, Gl: bi, Hh: mi, Hl: _i } = this;
    return [t, Ie, Be, Pe, Te, Me, Ue, je, fn, Ve, vn, En, fi, bi, mi, _i];
  }
  // prettier-ignore
  set(t, Ie, Be, Pe, Te, Me, Ue, je, fn, Ve, vn, En, fi, bi, mi, _i) {
    this.Ah = t | 0, this.Al = Ie | 0, this.Bh = Be | 0, this.Bl = Pe | 0, this.Ch = Te | 0, this.Cl = Me | 0, this.Dh = Ue | 0, this.Dl = je | 0, this.Eh = fn | 0, this.El = Ve | 0, this.Fh = vn | 0, this.Fl = En | 0, this.Gh = fi | 0, this.Gl = bi | 0, this.Hh = mi | 0, this.Hl = _i | 0;
  }
  process(t, Ie) {
    for (let Mi = 0; Mi < 16; Mi++, Ie += 4)
      SHA512_W_H[Mi] = t.getUint32(Ie), SHA512_W_L[Mi] = t.getUint32(Ie += 4);
    for (let Mi = 16; Mi < 80; Mi++) {
      const Oi = SHA512_W_H[Mi - 15] | 0, Fi = SHA512_W_L[Mi - 15] | 0, Ui = u64.rotrSH(Oi, Fi, 1) ^ u64.rotrSH(Oi, Fi, 8) ^ u64.shrSH(Oi, Fi, 7), Pi = u64.rotrSL(Oi, Fi, 1) ^ u64.rotrSL(Oi, Fi, 8) ^ u64.shrSL(Oi, Fi, 7), Bi = SHA512_W_H[Mi - 2] | 0, ji = SHA512_W_L[Mi - 2] | 0, Zi = u64.rotrSH(Bi, ji, 19) ^ u64.rotrBH(Bi, ji, 61) ^ u64.shrSH(Bi, ji, 6), zi = u64.rotrSL(Bi, ji, 19) ^ u64.rotrBL(Bi, ji, 61) ^ u64.shrSL(Bi, ji, 6), xi = u64.add4L(Pi, zi, SHA512_W_L[Mi - 7], SHA512_W_L[Mi - 16]), $i = u64.add4H(xi, Ui, Zi, SHA512_W_H[Mi - 7], SHA512_W_H[Mi - 16]);
      SHA512_W_H[Mi] = $i | 0, SHA512_W_L[Mi] = xi | 0;
    }
    let { Ah: Be, Al: Pe, Bh: Te, Bl: Me, Ch: Ue, Cl: je, Dh: fn, Dl: Ve, Eh: vn, El: En, Fh: fi, Fl: bi, Gh: mi, Gl: _i, Hh: Ei, Hl: Si } = this;
    for (let Mi = 0; Mi < 80; Mi++) {
      const Oi = u64.rotrSH(vn, En, 14) ^ u64.rotrSH(vn, En, 18) ^ u64.rotrBH(vn, En, 41), Fi = u64.rotrSL(vn, En, 14) ^ u64.rotrSL(vn, En, 18) ^ u64.rotrBL(vn, En, 41), Ui = vn & fi ^ ~vn & mi, Pi = En & bi ^ ~En & _i, Bi = u64.add5L(Si, Fi, Pi, SHA512_Kl[Mi], SHA512_W_L[Mi]), ji = u64.add5H(Bi, Ei, Oi, Ui, SHA512_Kh[Mi], SHA512_W_H[Mi]), Zi = Bi | 0, zi = u64.rotrSH(Be, Pe, 28) ^ u64.rotrBH(Be, Pe, 34) ^ u64.rotrBH(Be, Pe, 39), xi = u64.rotrSL(Be, Pe, 28) ^ u64.rotrBL(Be, Pe, 34) ^ u64.rotrBL(Be, Pe, 39), $i = Be & Te ^ Be & Ue ^ Te & Ue, vi = Pe & Me ^ Pe & je ^ Me & je;
      Ei = mi | 0, Si = _i | 0, mi = fi | 0, _i = bi | 0, fi = vn | 0, bi = En | 0, { h: vn, l: En } = u64.add(fn | 0, Ve | 0, ji | 0, Zi | 0), fn = Ue | 0, Ve = je | 0, Ue = Te | 0, je = Me | 0, Te = Be | 0, Me = Pe | 0;
      const wi = u64.add3L(Zi, xi, vi);
      Be = u64.add3H(wi, ji, zi, $i), Pe = wi | 0;
    }
    ({ h: Be, l: Pe } = u64.add(this.Ah | 0, this.Al | 0, Be | 0, Pe | 0)), { h: Te, l: Me } = u64.add(this.Bh | 0, this.Bl | 0, Te | 0, Me | 0), { h: Ue, l: je } = u64.add(this.Ch | 0, this.Cl | 0, Ue | 0, je | 0), { h: fn, l: Ve } = u64.add(this.Dh | 0, this.Dl | 0, fn | 0, Ve | 0), { h: vn, l: En } = u64.add(this.Eh | 0, this.El | 0, vn | 0, En | 0), { h: fi, l: bi } = u64.add(this.Fh | 0, this.Fl | 0, fi | 0, bi | 0), { h: mi, l: _i } = u64.add(this.Gh | 0, this.Gl | 0, mi | 0, _i | 0), { h: Ei, l: Si } = u64.add(this.Hh | 0, this.Hl | 0, Ei | 0, Si | 0), this.set(Be, Pe, Te, Me, Ue, je, fn, Ve, vn, En, fi, bi, mi, _i, Ei, Si);
  }
  roundClean() {
    SHA512_W_H.fill(0), SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const sha512$1 = /* @__PURE__ */ wrapConstructor(() => new SHA512());
function getGlobal() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("unable to locate global object");
}
const anyGlobal = getGlobal();
anyGlobal.crypto || anyGlobal.msCrypto;
function createHash(Ae) {
  switch (Ae) {
    case "sha256":
      return sha256$2.create();
    case "sha512":
      return sha512$1.create();
  }
  assertArgument(!1, "invalid hashing algorithm name", "algorithm", Ae);
}
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []], _0n$8 = /* @__PURE__ */ BigInt(0), _1n$a = /* @__PURE__ */ BigInt(1), _2n$6 = /* @__PURE__ */ BigInt(2), _7n = /* @__PURE__ */ BigInt(7), _256n = /* @__PURE__ */ BigInt(256), _0x71n = /* @__PURE__ */ BigInt(113);
for (let Ae = 0, t = _1n$a, Ie = 1, Be = 0; Ae < 24; Ae++) {
  [Ie, Be] = [Be, (2 * Ie + 3 * Be) % 5], SHA3_PI.push(2 * (5 * Be + Ie)), SHA3_ROTL.push((Ae + 1) * (Ae + 2) / 2 % 64);
  let Pe = _0n$8;
  for (let Te = 0; Te < 7; Te++)
    t = (t << _1n$a ^ (t >> _7n) * _0x71n) % _256n, t & _2n$6 && (Pe ^= _1n$a << (_1n$a << /* @__PURE__ */ BigInt(Te)) - _1n$a);
  _SHA3_IOTA.push(Pe);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, !0), rotlH = (Ae, t, Ie) => Ie > 32 ? rotlBH(Ae, t, Ie) : rotlSH(Ae, t, Ie), rotlL = (Ae, t, Ie) => Ie > 32 ? rotlBL(Ae, t, Ie) : rotlSL(Ae, t, Ie);
function keccakP(Ae, t = 24) {
  const Ie = new Uint32Array(10);
  for (let Be = 24 - t; Be < 24; Be++) {
    for (let Me = 0; Me < 10; Me++)
      Ie[Me] = Ae[Me] ^ Ae[Me + 10] ^ Ae[Me + 20] ^ Ae[Me + 30] ^ Ae[Me + 40];
    for (let Me = 0; Me < 10; Me += 2) {
      const Ue = (Me + 8) % 10, je = (Me + 2) % 10, fn = Ie[je], Ve = Ie[je + 1], vn = rotlH(fn, Ve, 1) ^ Ie[Ue], En = rotlL(fn, Ve, 1) ^ Ie[Ue + 1];
      for (let fi = 0; fi < 50; fi += 10)
        Ae[Me + fi] ^= vn, Ae[Me + fi + 1] ^= En;
    }
    let Pe = Ae[2], Te = Ae[3];
    for (let Me = 0; Me < 24; Me++) {
      const Ue = SHA3_ROTL[Me], je = rotlH(Pe, Te, Ue), fn = rotlL(Pe, Te, Ue), Ve = SHA3_PI[Me];
      Pe = Ae[Ve], Te = Ae[Ve + 1], Ae[Ve] = je, Ae[Ve + 1] = fn;
    }
    for (let Me = 0; Me < 50; Me += 10) {
      for (let Ue = 0; Ue < 10; Ue++)
        Ie[Ue] = Ae[Me + Ue];
      for (let Ue = 0; Ue < 10; Ue++)
        Ae[Me + Ue] ^= ~Ie[(Ue + 2) % 10] & Ie[(Ue + 4) % 10];
    }
    Ae[0] ^= SHA3_IOTA_H[Be], Ae[1] ^= SHA3_IOTA_L[Be];
  }
  Ie.fill(0);
}
class Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, Ie, Be, Pe = !1, Te = 24) {
    if (super(), this.blockLen = t, this.suffix = Ie, this.outputLen = Be, this.enableXOF = Pe, this.rounds = Te, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, number(Be), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    exists(this);
    const { blockLen: Ie, state: Be } = this;
    t = toBytes(t);
    const Pe = t.length;
    for (let Te = 0; Te < Pe; ) {
      const Me = Math.min(Ie - this.pos, Pe - Te);
      for (let Ue = 0; Ue < Me; Ue++)
        Be[this.pos++] ^= t[Te++];
      this.pos === Ie && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: Ie, pos: Be, blockLen: Pe } = this;
    t[Be] ^= Ie, Ie & 128 && Be === Pe - 1 && this.keccak(), t[Pe - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    exists(this, !1), bytes(t), this.finish();
    const Ie = this.state, { blockLen: Be } = this;
    for (let Pe = 0, Te = t.length; Pe < Te; ) {
      this.posOut >= Be && this.keccak();
      const Me = Math.min(Be - this.posOut, Te - Pe);
      t.set(Ie.subarray(this.posOut, this.posOut + Me), Pe), this.posOut += Me, Pe += Me;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return number(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (output(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: Ie, suffix: Be, outputLen: Pe, rounds: Te, enableXOF: Me } = this;
    return t || (t = new Keccak(Ie, Be, Pe, Me, Te)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = Te, t.suffix = Be, t.outputLen = Pe, t.enableXOF = Me, t.destroyed = this.destroyed, t;
  }
}
const gen = (Ae, t, Ie) => wrapConstructor(() => new Keccak(t, Ae, Ie)), keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
let locked = !1;
const _keccak256 = function(Ae) {
  return keccak_256(Ae);
};
let __keccak256 = _keccak256;
function keccak256$1(Ae) {
  const t = getBytes(Ae, "data");
  return hexlify$1(__keccak256(t));
}
keccak256$1._ = _keccak256;
keccak256$1.lock = function() {
  locked = !0;
};
keccak256$1.register = function(Ae) {
  if (locked)
    throw new TypeError("keccak256 is locked");
  __keccak256 = Ae;
};
Object.freeze(keccak256$1);
const _sha256 = function(Ae) {
  return createHash("sha256").update(Ae).digest();
};
let __sha256 = _sha256, locked256 = !1;
function sha256$1(Ae) {
  const t = getBytes(Ae, "data");
  return hexlify$1(__sha256(t));
}
sha256$1._ = _sha256;
sha256$1.lock = function() {
  locked256 = !0;
};
sha256$1.register = function(Ae) {
  if (locked256)
    throw new Error("sha256 is locked");
  __sha256 = Ae;
};
Object.freeze(sha256$1);
Object.freeze(sha256$1);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$7 = BigInt(0), _1n$9 = BigInt(1), _2n$5 = BigInt(2), u8a = (Ae) => Ae instanceof Uint8Array, hexes$1 = /* @__PURE__ */ Array.from({ length: 256 }, (Ae, t) => t.toString(16).padStart(2, "0"));
function bytesToHex$1(Ae) {
  if (!u8a(Ae))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let Ie = 0; Ie < Ae.length; Ie++)
    t += hexes$1[Ae[Ie]];
  return t;
}
function numberToHexUnpadded$1(Ae) {
  const t = Ae.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function hexToNumber$1(Ae) {
  if (typeof Ae != "string")
    throw new Error("hex string expected, got " + typeof Ae);
  return BigInt(Ae === "" ? "0" : `0x${Ae}`);
}
function hexToBytes$1(Ae) {
  if (typeof Ae != "string")
    throw new Error("hex string expected, got " + typeof Ae);
  const t = Ae.length;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const Ie = new Uint8Array(t / 2);
  for (let Be = 0; Be < Ie.length; Be++) {
    const Pe = Be * 2, Te = Ae.slice(Pe, Pe + 2), Me = Number.parseInt(Te, 16);
    if (Number.isNaN(Me) || Me < 0)
      throw new Error("Invalid byte sequence");
    Ie[Be] = Me;
  }
  return Ie;
}
function bytesToNumberBE$1(Ae) {
  return hexToNumber$1(bytesToHex$1(Ae));
}
function bytesToNumberLE$1(Ae) {
  if (!u8a(Ae))
    throw new Error("Uint8Array expected");
  return hexToNumber$1(bytesToHex$1(Uint8Array.from(Ae).reverse()));
}
function numberToBytesBE$1(Ae, t) {
  return hexToBytes$1(Ae.toString(16).padStart(t * 2, "0"));
}
function numberToBytesLE$1(Ae, t) {
  return numberToBytesBE$1(Ae, t).reverse();
}
function numberToVarBytesBE$1(Ae) {
  return hexToBytes$1(numberToHexUnpadded$1(Ae));
}
function ensureBytes$1(Ae, t, Ie) {
  let Be;
  if (typeof t == "string")
    try {
      Be = hexToBytes$1(t);
    } catch (Te) {
      throw new Error(`${Ae} must be valid hex string, got "${t}". Cause: ${Te}`);
    }
  else if (u8a(t))
    Be = Uint8Array.from(t);
  else
    throw new Error(`${Ae} must be hex string or Uint8Array`);
  const Pe = Be.length;
  if (typeof Ie == "number" && Pe !== Ie)
    throw new Error(`${Ae} expected ${Ie} bytes, got ${Pe}`);
  return Be;
}
function concatBytes$1(...Ae) {
  const t = new Uint8Array(Ae.reduce((Be, Pe) => Be + Pe.length, 0));
  let Ie = 0;
  return Ae.forEach((Be) => {
    if (!u8a(Be))
      throw new Error("Uint8Array expected");
    t.set(Be, Ie), Ie += Be.length;
  }), t;
}
function equalBytes$1(Ae, t) {
  if (Ae.length !== t.length)
    return !1;
  for (let Ie = 0; Ie < Ae.length; Ie++)
    if (Ae[Ie] !== t[Ie])
      return !1;
  return !0;
}
function utf8ToBytes$1(Ae) {
  if (typeof Ae != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof Ae}`);
  return new Uint8Array(new TextEncoder().encode(Ae));
}
function bitLen$1(Ae) {
  let t;
  for (t = 0; Ae > _0n$7; Ae >>= _1n$9, t += 1)
    ;
  return t;
}
function bitGet$1(Ae, t) {
  return Ae >> BigInt(t) & _1n$9;
}
const bitSet$1 = (Ae, t, Ie) => Ae | (Ie ? _1n$9 : _0n$7) << BigInt(t), bitMask$1 = (Ae) => (_2n$5 << BigInt(Ae - 1)) - _1n$9, u8n$1 = (Ae) => new Uint8Array(Ae), u8fr$1 = (Ae) => Uint8Array.from(Ae);
function createHmacDrbg$1(Ae, t, Ie) {
  if (typeof Ae != "number" || Ae < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof Ie != "function")
    throw new Error("hmacFn must be a function");
  let Be = u8n$1(Ae), Pe = u8n$1(Ae), Te = 0;
  const Me = () => {
    Be.fill(1), Pe.fill(0), Te = 0;
  }, Ue = (...vn) => Ie(Pe, Be, ...vn), je = (vn = u8n$1()) => {
    Pe = Ue(u8fr$1([0]), vn), Be = Ue(), vn.length !== 0 && (Pe = Ue(u8fr$1([1]), vn), Be = Ue());
  }, fn = () => {
    if (Te++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let vn = 0;
    const En = [];
    for (; vn < t; ) {
      Be = Ue();
      const fi = Be.slice();
      En.push(fi), vn += Be.length;
    }
    return concatBytes$1(...En);
  };
  return (vn, En) => {
    Me(), je(vn);
    let fi;
    for (; !(fi = En(fn())); )
      je();
    return Me(), fi;
  };
}
const validatorFns$1 = {
  bigint: (Ae) => typeof Ae == "bigint",
  function: (Ae) => typeof Ae == "function",
  boolean: (Ae) => typeof Ae == "boolean",
  string: (Ae) => typeof Ae == "string",
  stringOrUint8Array: (Ae) => typeof Ae == "string" || Ae instanceof Uint8Array,
  isSafeInteger: (Ae) => Number.isSafeInteger(Ae),
  array: (Ae) => Array.isArray(Ae),
  field: (Ae, t) => t.Fp.isValid(Ae),
  hash: (Ae) => typeof Ae == "function" && Number.isSafeInteger(Ae.outputLen)
};
function validateObject$1(Ae, t, Ie = {}) {
  const Be = (Pe, Te, Me) => {
    const Ue = validatorFns$1[Te];
    if (typeof Ue != "function")
      throw new Error(`Invalid validator "${Te}", expected function`);
    const je = Ae[Pe];
    if (!(Me && je === void 0) && !Ue(je, Ae))
      throw new Error(`Invalid param ${String(Pe)}=${je} (${typeof je}), expected ${Te}`);
  };
  for (const [Pe, Te] of Object.entries(t))
    Be(Pe, Te, !1);
  for (const [Pe, Te] of Object.entries(Ie))
    Be(Pe, Te, !0);
  return Ae;
}
const ut$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet: bitGet$1,
  bitLen: bitLen$1,
  bitMask: bitMask$1,
  bitSet: bitSet$1,
  bytesToHex: bytesToHex$1,
  bytesToNumberBE: bytesToNumberBE$1,
  bytesToNumberLE: bytesToNumberLE$1,
  concatBytes: concatBytes$1,
  createHmacDrbg: createHmacDrbg$1,
  ensureBytes: ensureBytes$1,
  equalBytes: equalBytes$1,
  hexToBytes: hexToBytes$1,
  hexToNumber: hexToNumber$1,
  numberToBytesBE: numberToBytesBE$1,
  numberToBytesLE: numberToBytesLE$1,
  numberToHexUnpadded: numberToHexUnpadded$1,
  numberToVarBytesBE: numberToVarBytesBE$1,
  utf8ToBytes: utf8ToBytes$1,
  validateObject: validateObject$1
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$6 = BigInt(0), _1n$8 = BigInt(1), _2n$4 = BigInt(2), _3n$3 = BigInt(3), _4n$1 = BigInt(4), _5n$1 = BigInt(5), _8n$1 = BigInt(8);
BigInt(9);
BigInt(16);
function mod$1(Ae, t) {
  const Ie = Ae % t;
  return Ie >= _0n$6 ? Ie : t + Ie;
}
function pow$1(Ae, t, Ie) {
  if (Ie <= _0n$6 || t < _0n$6)
    throw new Error("Expected power/modulo > 0");
  if (Ie === _1n$8)
    return _0n$6;
  let Be = _1n$8;
  for (; t > _0n$6; )
    t & _1n$8 && (Be = Be * Ae % Ie), Ae = Ae * Ae % Ie, t >>= _1n$8;
  return Be;
}
function pow2$1(Ae, t, Ie) {
  let Be = Ae;
  for (; t-- > _0n$6; )
    Be *= Be, Be %= Ie;
  return Be;
}
function invert$1(Ae, t) {
  if (Ae === _0n$6 || t <= _0n$6)
    throw new Error(`invert: expected positive integers, got n=${Ae} mod=${t}`);
  let Ie = mod$1(Ae, t), Be = t, Pe = _0n$6, Te = _1n$8;
  for (; Ie !== _0n$6; ) {
    const Ue = Be / Ie, je = Be % Ie, fn = Pe - Te * Ue;
    Be = Ie, Ie = je, Pe = Te, Te = fn;
  }
  if (Be !== _1n$8)
    throw new Error("invert: does not exist");
  return mod$1(Pe, t);
}
function tonelliShanks$1(Ae) {
  const t = (Ae - _1n$8) / _2n$4;
  let Ie, Be, Pe;
  for (Ie = Ae - _1n$8, Be = 0; Ie % _2n$4 === _0n$6; Ie /= _2n$4, Be++)
    ;
  for (Pe = _2n$4; Pe < Ae && pow$1(Pe, t, Ae) !== Ae - _1n$8; Pe++)
    ;
  if (Be === 1) {
    const Me = (Ae + _1n$8) / _4n$1;
    return function(je, fn) {
      const Ve = je.pow(fn, Me);
      if (!je.eql(je.sqr(Ve), fn))
        throw new Error("Cannot find square root");
      return Ve;
    };
  }
  const Te = (Ie + _1n$8) / _2n$4;
  return function(Ue, je) {
    if (Ue.pow(je, t) === Ue.neg(Ue.ONE))
      throw new Error("Cannot find square root");
    let fn = Be, Ve = Ue.pow(Ue.mul(Ue.ONE, Pe), Ie), vn = Ue.pow(je, Te), En = Ue.pow(je, Ie);
    for (; !Ue.eql(En, Ue.ONE); ) {
      if (Ue.eql(En, Ue.ZERO))
        return Ue.ZERO;
      let fi = 1;
      for (let mi = Ue.sqr(En); fi < fn && !Ue.eql(mi, Ue.ONE); fi++)
        mi = Ue.sqr(mi);
      const bi = Ue.pow(Ve, _1n$8 << BigInt(fn - fi - 1));
      Ve = Ue.sqr(bi), vn = Ue.mul(vn, bi), En = Ue.mul(En, Ve), fn = fi;
    }
    return vn;
  };
}
function FpSqrt$1(Ae) {
  if (Ae % _4n$1 === _3n$3) {
    const t = (Ae + _1n$8) / _4n$1;
    return function(Be, Pe) {
      const Te = Be.pow(Pe, t);
      if (!Be.eql(Be.sqr(Te), Pe))
        throw new Error("Cannot find square root");
      return Te;
    };
  }
  if (Ae % _8n$1 === _5n$1) {
    const t = (Ae - _5n$1) / _8n$1;
    return function(Be, Pe) {
      const Te = Be.mul(Pe, _2n$4), Me = Be.pow(Te, t), Ue = Be.mul(Pe, Me), je = Be.mul(Be.mul(Ue, _2n$4), Me), fn = Be.mul(Ue, Be.sub(je, Be.ONE));
      if (!Be.eql(Be.sqr(fn), Pe))
        throw new Error("Cannot find square root");
      return fn;
    };
  }
  return tonelliShanks$1(Ae);
}
const FIELD_FIELDS$1 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField$1(Ae) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, Ie = FIELD_FIELDS$1.reduce((Be, Pe) => (Be[Pe] = "function", Be), t);
  return validateObject$1(Ae, Ie);
}
function FpPow$1(Ae, t, Ie) {
  if (Ie < _0n$6)
    throw new Error("Expected power > 0");
  if (Ie === _0n$6)
    return Ae.ONE;
  if (Ie === _1n$8)
    return t;
  let Be = Ae.ONE, Pe = t;
  for (; Ie > _0n$6; )
    Ie & _1n$8 && (Be = Ae.mul(Be, Pe)), Pe = Ae.sqr(Pe), Ie >>= _1n$8;
  return Be;
}
function FpInvertBatch$1(Ae, t) {
  const Ie = new Array(t.length), Be = t.reduce((Te, Me, Ue) => Ae.is0(Me) ? Te : (Ie[Ue] = Te, Ae.mul(Te, Me)), Ae.ONE), Pe = Ae.inv(Be);
  return t.reduceRight((Te, Me, Ue) => Ae.is0(Me) ? Te : (Ie[Ue] = Ae.mul(Te, Ie[Ue]), Ae.mul(Te, Me)), Pe), Ie;
}
function nLength$1(Ae, t) {
  const Ie = t !== void 0 ? t : Ae.toString(2).length, Be = Math.ceil(Ie / 8);
  return { nBitLength: Ie, nByteLength: Be };
}
function Field$1(Ae, t, Ie = !1, Be = {}) {
  if (Ae <= _0n$6)
    throw new Error(`Expected Field ORDER > 0, got ${Ae}`);
  const { nBitLength: Pe, nByteLength: Te } = nLength$1(Ae, t);
  if (Te > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const Me = FpSqrt$1(Ae), Ue = Object.freeze({
    ORDER: Ae,
    BITS: Pe,
    BYTES: Te,
    MASK: bitMask$1(Pe),
    ZERO: _0n$6,
    ONE: _1n$8,
    create: (je) => mod$1(je, Ae),
    isValid: (je) => {
      if (typeof je != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof je}`);
      return _0n$6 <= je && je < Ae;
    },
    is0: (je) => je === _0n$6,
    isOdd: (je) => (je & _1n$8) === _1n$8,
    neg: (je) => mod$1(-je, Ae),
    eql: (je, fn) => je === fn,
    sqr: (je) => mod$1(je * je, Ae),
    add: (je, fn) => mod$1(je + fn, Ae),
    sub: (je, fn) => mod$1(je - fn, Ae),
    mul: (je, fn) => mod$1(je * fn, Ae),
    pow: (je, fn) => FpPow$1(Ue, je, fn),
    div: (je, fn) => mod$1(je * invert$1(fn, Ae), Ae),
    // Same as above, but doesn't normalize
    sqrN: (je) => je * je,
    addN: (je, fn) => je + fn,
    subN: (je, fn) => je - fn,
    mulN: (je, fn) => je * fn,
    inv: (je) => invert$1(je, Ae),
    sqrt: Be.sqrt || ((je) => Me(Ue, je)),
    invertBatch: (je) => FpInvertBatch$1(Ue, je),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (je, fn, Ve) => Ve ? fn : je,
    toBytes: (je) => Ie ? numberToBytesLE$1(je, Te) : numberToBytesBE$1(je, Te),
    fromBytes: (je) => {
      if (je.length !== Te)
        throw new Error(`Fp.fromBytes: expected ${Te}, got ${je.length}`);
      return Ie ? bytesToNumberLE$1(je) : bytesToNumberBE$1(je);
    }
  });
  return Object.freeze(Ue);
}
function getFieldBytesLength$1(Ae) {
  if (typeof Ae != "bigint")
    throw new Error("field order must be bigint");
  const t = Ae.toString(2).length;
  return Math.ceil(t / 8);
}
function getMinHashLength$1(Ae) {
  const t = getFieldBytesLength$1(Ae);
  return t + Math.ceil(t / 2);
}
function mapHashToField$1(Ae, t, Ie = !1) {
  const Be = Ae.length, Pe = getFieldBytesLength$1(t), Te = getMinHashLength$1(t);
  if (Be < 16 || Be < Te || Be > 1024)
    throw new Error(`expected ${Te}-1024 bytes of input, got ${Be}`);
  const Me = Ie ? bytesToNumberBE$1(Ae) : bytesToNumberLE$1(Ae), Ue = mod$1(Me, t - _1n$8) + _1n$8;
  return Ie ? numberToBytesLE$1(Ue, Pe) : numberToBytesBE$1(Ue, Pe);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$5 = BigInt(0), _1n$7 = BigInt(1);
function wNAF$1(Ae, t) {
  const Ie = (Pe, Te) => {
    const Me = Te.negate();
    return Pe ? Me : Te;
  }, Be = (Pe) => {
    const Te = Math.ceil(t / Pe) + 1, Me = 2 ** (Pe - 1);
    return { windows: Te, windowSize: Me };
  };
  return {
    constTimeNegate: Ie,
    // non-const time multiplication ladder
    unsafeLadder(Pe, Te) {
      let Me = Ae.ZERO, Ue = Pe;
      for (; Te > _0n$5; )
        Te & _1n$7 && (Me = Me.add(Ue)), Ue = Ue.double(), Te >>= _1n$7;
      return Me;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(Pe, Te) {
      const { windows: Me, windowSize: Ue } = Be(Te), je = [];
      let fn = Pe, Ve = fn;
      for (let vn = 0; vn < Me; vn++) {
        Ve = fn, je.push(Ve);
        for (let En = 1; En < Ue; En++)
          Ve = Ve.add(fn), je.push(Ve);
        fn = Ve.double();
      }
      return je;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(Pe, Te, Me) {
      const { windows: Ue, windowSize: je } = Be(Pe);
      let fn = Ae.ZERO, Ve = Ae.BASE;
      const vn = BigInt(2 ** Pe - 1), En = 2 ** Pe, fi = BigInt(Pe);
      for (let bi = 0; bi < Ue; bi++) {
        const mi = bi * je;
        let _i = Number(Me & vn);
        Me >>= fi, _i > je && (_i -= En, Me += _1n$7);
        const Ei = mi, Si = mi + Math.abs(_i) - 1, Mi = bi % 2 !== 0, Oi = _i < 0;
        _i === 0 ? Ve = Ve.add(Ie(Mi, Te[Ei])) : fn = fn.add(Ie(Oi, Te[Si]));
      }
      return { p: fn, f: Ve };
    },
    wNAFCached(Pe, Te, Me, Ue) {
      const je = Pe._WINDOW_SIZE || 1;
      let fn = Te.get(Pe);
      return fn || (fn = this.precomputeWindow(Pe, je), je !== 1 && Te.set(Pe, Ue(fn))), this.wNAF(je, fn, Me);
    }
  };
}
function validateBasic$1(Ae) {
  return validateField$1(Ae.Fp), validateObject$1(Ae, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...nLength$1(Ae.n, Ae.nBitLength),
    ...Ae,
    p: Ae.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts$1(Ae) {
  const t = validateBasic$1(Ae);
  validateObject$1(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: Ie, Fp: Be, a: Pe } = t;
  if (Ie) {
    if (!Be.eql(Pe, Be.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof Ie != "object" || typeof Ie.beta != "bigint" || typeof Ie.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: b2n$1, hexToBytes: h2b$1 } = ut$4, DER$1 = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(t = "") {
      super(t);
    }
  },
  _parseInt(Ae) {
    const { Err: t } = DER$1;
    if (Ae.length < 2 || Ae[0] !== 2)
      throw new t("Invalid signature integer tag");
    const Ie = Ae[1], Be = Ae.subarray(2, Ie + 2);
    if (!Ie || Be.length !== Ie)
      throw new t("Invalid signature integer: wrong length");
    if (Be[0] & 128)
      throw new t("Invalid signature integer: negative");
    if (Be[0] === 0 && !(Be[1] & 128))
      throw new t("Invalid signature integer: unnecessary leading zero");
    return { d: b2n$1(Be), l: Ae.subarray(Ie + 2) };
  },
  toSig(Ae) {
    const { Err: t } = DER$1, Ie = typeof Ae == "string" ? h2b$1(Ae) : Ae;
    if (!(Ie instanceof Uint8Array))
      throw new Error("ui8a expected");
    let Be = Ie.length;
    if (Be < 2 || Ie[0] != 48)
      throw new t("Invalid signature tag");
    if (Ie[1] !== Be - 2)
      throw new t("Invalid signature: incorrect length");
    const { d: Pe, l: Te } = DER$1._parseInt(Ie.subarray(2)), { d: Me, l: Ue } = DER$1._parseInt(Te);
    if (Ue.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: Pe, s: Me };
  },
  hexFromSig(Ae) {
    const t = (fn) => Number.parseInt(fn[0], 16) & 8 ? "00" + fn : fn, Ie = (fn) => {
      const Ve = fn.toString(16);
      return Ve.length & 1 ? `0${Ve}` : Ve;
    }, Be = t(Ie(Ae.s)), Pe = t(Ie(Ae.r)), Te = Be.length / 2, Me = Pe.length / 2, Ue = Ie(Te), je = Ie(Me);
    return `30${Ie(Me + Te + 4)}02${je}${Pe}02${Ue}${Be}`;
  }
}, _0n$4 = BigInt(0), _1n$6 = BigInt(1);
BigInt(2);
const _3n$2 = BigInt(3);
BigInt(4);
function weierstrassPoints$1(Ae) {
  const t = validatePointOpts$1(Ae), { Fp: Ie } = t, Be = t.toBytes || ((bi, mi, _i) => {
    const Ei = mi.toAffine();
    return concatBytes$1(Uint8Array.from([4]), Ie.toBytes(Ei.x), Ie.toBytes(Ei.y));
  }), Pe = t.fromBytes || ((bi) => {
    const mi = bi.subarray(1), _i = Ie.fromBytes(mi.subarray(0, Ie.BYTES)), Ei = Ie.fromBytes(mi.subarray(Ie.BYTES, 2 * Ie.BYTES));
    return { x: _i, y: Ei };
  });
  function Te(bi) {
    const { a: mi, b: _i } = t, Ei = Ie.sqr(bi), Si = Ie.mul(Ei, bi);
    return Ie.add(Ie.add(Si, Ie.mul(bi, mi)), _i);
  }
  if (!Ie.eql(Ie.sqr(t.Gy), Te(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function Me(bi) {
    return typeof bi == "bigint" && _0n$4 < bi && bi < t.n;
  }
  function Ue(bi) {
    if (!Me(bi))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function je(bi) {
    const { allowedPrivateKeyLengths: mi, nByteLength: _i, wrapPrivateKey: Ei, n: Si } = t;
    if (mi && typeof bi != "bigint") {
      if (bi instanceof Uint8Array && (bi = bytesToHex$1(bi)), typeof bi != "string" || !mi.includes(bi.length))
        throw new Error("Invalid key");
      bi = bi.padStart(_i * 2, "0");
    }
    let Mi;
    try {
      Mi = typeof bi == "bigint" ? bi : bytesToNumberBE$1(ensureBytes$1("private key", bi, _i));
    } catch {
      throw new Error(`private key must be ${_i} bytes, hex or bigint, not ${typeof bi}`);
    }
    return Ei && (Mi = mod$1(Mi, Si)), Ue(Mi), Mi;
  }
  const fn = /* @__PURE__ */ new Map();
  function Ve(bi) {
    if (!(bi instanceof vn))
      throw new Error("ProjectivePoint expected");
  }
  class vn {
    constructor(mi, _i, Ei) {
      if (this.px = mi, this.py = _i, this.pz = Ei, mi == null || !Ie.isValid(mi))
        throw new Error("x required");
      if (_i == null || !Ie.isValid(_i))
        throw new Error("y required");
      if (Ei == null || !Ie.isValid(Ei))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(mi) {
      const { x: _i, y: Ei } = mi || {};
      if (!mi || !Ie.isValid(_i) || !Ie.isValid(Ei))
        throw new Error("invalid affine point");
      if (mi instanceof vn)
        throw new Error("projective point not allowed");
      const Si = (Mi) => Ie.eql(Mi, Ie.ZERO);
      return Si(_i) && Si(Ei) ? vn.ZERO : new vn(_i, Ei, Ie.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(mi) {
      const _i = Ie.invertBatch(mi.map((Ei) => Ei.pz));
      return mi.map((Ei, Si) => Ei.toAffine(_i[Si])).map(vn.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(mi) {
      const _i = vn.fromAffine(Pe(ensureBytes$1("pointHex", mi)));
      return _i.assertValidity(), _i;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(mi) {
      return vn.BASE.multiply(je(mi));
    }
    // "Private method", don't use it directly
    _setWindowSize(mi) {
      this._WINDOW_SIZE = mi, fn.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint && !Ie.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: mi, y: _i } = this.toAffine();
      if (!Ie.isValid(mi) || !Ie.isValid(_i))
        throw new Error("bad point: x or y not FE");
      const Ei = Ie.sqr(_i), Si = Te(mi);
      if (!Ie.eql(Ei, Si))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: mi } = this.toAffine();
      if (Ie.isOdd)
        return !Ie.isOdd(mi);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(mi) {
      Ve(mi);
      const { px: _i, py: Ei, pz: Si } = this, { px: Mi, py: Oi, pz: Fi } = mi, Ui = Ie.eql(Ie.mul(_i, Fi), Ie.mul(Mi, Si)), Pi = Ie.eql(Ie.mul(Ei, Fi), Ie.mul(Oi, Si));
      return Ui && Pi;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new vn(this.px, Ie.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: mi, b: _i } = t, Ei = Ie.mul(_i, _3n$2), { px: Si, py: Mi, pz: Oi } = this;
      let Fi = Ie.ZERO, Ui = Ie.ZERO, Pi = Ie.ZERO, Bi = Ie.mul(Si, Si), ji = Ie.mul(Mi, Mi), Zi = Ie.mul(Oi, Oi), zi = Ie.mul(Si, Mi);
      return zi = Ie.add(zi, zi), Pi = Ie.mul(Si, Oi), Pi = Ie.add(Pi, Pi), Fi = Ie.mul(mi, Pi), Ui = Ie.mul(Ei, Zi), Ui = Ie.add(Fi, Ui), Fi = Ie.sub(ji, Ui), Ui = Ie.add(ji, Ui), Ui = Ie.mul(Fi, Ui), Fi = Ie.mul(zi, Fi), Pi = Ie.mul(Ei, Pi), Zi = Ie.mul(mi, Zi), zi = Ie.sub(Bi, Zi), zi = Ie.mul(mi, zi), zi = Ie.add(zi, Pi), Pi = Ie.add(Bi, Bi), Bi = Ie.add(Pi, Bi), Bi = Ie.add(Bi, Zi), Bi = Ie.mul(Bi, zi), Ui = Ie.add(Ui, Bi), Zi = Ie.mul(Mi, Oi), Zi = Ie.add(Zi, Zi), Bi = Ie.mul(Zi, zi), Fi = Ie.sub(Fi, Bi), Pi = Ie.mul(Zi, ji), Pi = Ie.add(Pi, Pi), Pi = Ie.add(Pi, Pi), new vn(Fi, Ui, Pi);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(mi) {
      Ve(mi);
      const { px: _i, py: Ei, pz: Si } = this, { px: Mi, py: Oi, pz: Fi } = mi;
      let Ui = Ie.ZERO, Pi = Ie.ZERO, Bi = Ie.ZERO;
      const ji = t.a, Zi = Ie.mul(t.b, _3n$2);
      let zi = Ie.mul(_i, Mi), xi = Ie.mul(Ei, Oi), $i = Ie.mul(Si, Fi), vi = Ie.add(_i, Ei), wi = Ie.add(Mi, Oi);
      vi = Ie.mul(vi, wi), wi = Ie.add(zi, xi), vi = Ie.sub(vi, wi), wi = Ie.add(_i, Si);
      let Ai = Ie.add(Mi, Fi);
      return wi = Ie.mul(wi, Ai), Ai = Ie.add(zi, $i), wi = Ie.sub(wi, Ai), Ai = Ie.add(Ei, Si), Ui = Ie.add(Oi, Fi), Ai = Ie.mul(Ai, Ui), Ui = Ie.add(xi, $i), Ai = Ie.sub(Ai, Ui), Bi = Ie.mul(ji, wi), Ui = Ie.mul(Zi, $i), Bi = Ie.add(Ui, Bi), Ui = Ie.sub(xi, Bi), Bi = Ie.add(xi, Bi), Pi = Ie.mul(Ui, Bi), xi = Ie.add(zi, zi), xi = Ie.add(xi, zi), $i = Ie.mul(ji, $i), wi = Ie.mul(Zi, wi), xi = Ie.add(xi, $i), $i = Ie.sub(zi, $i), $i = Ie.mul(ji, $i), wi = Ie.add(wi, $i), zi = Ie.mul(xi, wi), Pi = Ie.add(Pi, zi), zi = Ie.mul(Ai, wi), Ui = Ie.mul(vi, Ui), Ui = Ie.sub(Ui, zi), zi = Ie.mul(vi, xi), Bi = Ie.mul(Ai, Bi), Bi = Ie.add(Bi, zi), new vn(Ui, Pi, Bi);
    }
    subtract(mi) {
      return this.add(mi.negate());
    }
    is0() {
      return this.equals(vn.ZERO);
    }
    wNAF(mi) {
      return fi.wNAFCached(this, fn, mi, (_i) => {
        const Ei = Ie.invertBatch(_i.map((Si) => Si.pz));
        return _i.map((Si, Mi) => Si.toAffine(Ei[Mi])).map(vn.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(mi) {
      const _i = vn.ZERO;
      if (mi === _0n$4)
        return _i;
      if (Ue(mi), mi === _1n$6)
        return this;
      const { endo: Ei } = t;
      if (!Ei)
        return fi.unsafeLadder(this, mi);
      let { k1neg: Si, k1: Mi, k2neg: Oi, k2: Fi } = Ei.splitScalar(mi), Ui = _i, Pi = _i, Bi = this;
      for (; Mi > _0n$4 || Fi > _0n$4; )
        Mi & _1n$6 && (Ui = Ui.add(Bi)), Fi & _1n$6 && (Pi = Pi.add(Bi)), Bi = Bi.double(), Mi >>= _1n$6, Fi >>= _1n$6;
      return Si && (Ui = Ui.negate()), Oi && (Pi = Pi.negate()), Pi = new vn(Ie.mul(Pi.px, Ei.beta), Pi.py, Pi.pz), Ui.add(Pi);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(mi) {
      Ue(mi);
      let _i = mi, Ei, Si;
      const { endo: Mi } = t;
      if (Mi) {
        const { k1neg: Oi, k1: Fi, k2neg: Ui, k2: Pi } = Mi.splitScalar(_i);
        let { p: Bi, f: ji } = this.wNAF(Fi), { p: Zi, f: zi } = this.wNAF(Pi);
        Bi = fi.constTimeNegate(Oi, Bi), Zi = fi.constTimeNegate(Ui, Zi), Zi = new vn(Ie.mul(Zi.px, Mi.beta), Zi.py, Zi.pz), Ei = Bi.add(Zi), Si = ji.add(zi);
      } else {
        const { p: Oi, f: Fi } = this.wNAF(_i);
        Ei = Oi, Si = Fi;
      }
      return vn.normalizeZ([Ei, Si])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(mi, _i, Ei) {
      const Si = vn.BASE, Mi = (Fi, Ui) => Ui === _0n$4 || Ui === _1n$6 || !Fi.equals(Si) ? Fi.multiplyUnsafe(Ui) : Fi.multiply(Ui), Oi = Mi(this, _i).add(Mi(mi, Ei));
      return Oi.is0() ? void 0 : Oi;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(mi) {
      const { px: _i, py: Ei, pz: Si } = this, Mi = this.is0();
      mi == null && (mi = Mi ? Ie.ONE : Ie.inv(Si));
      const Oi = Ie.mul(_i, mi), Fi = Ie.mul(Ei, mi), Ui = Ie.mul(Si, mi);
      if (Mi)
        return { x: Ie.ZERO, y: Ie.ZERO };
      if (!Ie.eql(Ui, Ie.ONE))
        throw new Error("invZ was invalid");
      return { x: Oi, y: Fi };
    }
    isTorsionFree() {
      const { h: mi, isTorsionFree: _i } = t;
      if (mi === _1n$6)
        return !0;
      if (_i)
        return _i(vn, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: mi, clearCofactor: _i } = t;
      return mi === _1n$6 ? this : _i ? _i(vn, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(mi = !0) {
      return this.assertValidity(), Be(vn, this, mi);
    }
    toHex(mi = !0) {
      return bytesToHex$1(this.toRawBytes(mi));
    }
  }
  vn.BASE = new vn(t.Gx, t.Gy, Ie.ONE), vn.ZERO = new vn(Ie.ZERO, Ie.ONE, Ie.ZERO);
  const En = t.nBitLength, fi = wNAF$1(vn, t.endo ? Math.ceil(En / 2) : En);
  return {
    CURVE: t,
    ProjectivePoint: vn,
    normPrivateKeyToScalar: je,
    weierstrassEquation: Te,
    isWithinCurveOrder: Me
  };
}
function validateOpts$1(Ae) {
  const t = validateBasic$1(Ae);
  return validateObject$1(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function weierstrass$1(Ae) {
  const t = validateOpts$1(Ae), { Fp: Ie, n: Be } = t, Pe = Ie.BYTES + 1, Te = 2 * Ie.BYTES + 1;
  function Me(wi) {
    return _0n$4 < wi && wi < Ie.ORDER;
  }
  function Ue(wi) {
    return mod$1(wi, Be);
  }
  function je(wi) {
    return invert$1(wi, Be);
  }
  const { ProjectivePoint: fn, normPrivateKeyToScalar: Ve, weierstrassEquation: vn, isWithinCurveOrder: En } = weierstrassPoints$1({
    ...t,
    toBytes(wi, Ai, Ri) {
      const Ti = Ai.toAffine(), Ci = Ie.toBytes(Ti.x), Ii = concatBytes$1;
      return Ri ? Ii(Uint8Array.from([Ai.hasEvenY() ? 2 : 3]), Ci) : Ii(Uint8Array.from([4]), Ci, Ie.toBytes(Ti.y));
    },
    fromBytes(wi) {
      const Ai = wi.length, Ri = wi[0], Ti = wi.subarray(1);
      if (Ai === Pe && (Ri === 2 || Ri === 3)) {
        const Ci = bytesToNumberBE$1(Ti);
        if (!Me(Ci))
          throw new Error("Point is not on curve");
        const Ii = vn(Ci);
        let Li = Ie.sqrt(Ii);
        const Ni = (Li & _1n$6) === _1n$6;
        return (Ri & 1) === 1 !== Ni && (Li = Ie.neg(Li)), { x: Ci, y: Li };
      } else if (Ai === Te && Ri === 4) {
        const Ci = Ie.fromBytes(Ti.subarray(0, Ie.BYTES)), Ii = Ie.fromBytes(Ti.subarray(Ie.BYTES, 2 * Ie.BYTES));
        return { x: Ci, y: Ii };
      } else
        throw new Error(`Point of length ${Ai} was invalid. Expected ${Pe} compressed bytes or ${Te} uncompressed bytes`);
    }
  }), fi = (wi) => bytesToHex$1(numberToBytesBE$1(wi, t.nByteLength));
  function bi(wi) {
    const Ai = Be >> _1n$6;
    return wi > Ai;
  }
  function mi(wi) {
    return bi(wi) ? Ue(-wi) : wi;
  }
  const _i = (wi, Ai, Ri) => bytesToNumberBE$1(wi.slice(Ai, Ri));
  class Ei {
    constructor(Ai, Ri, Ti) {
      this.r = Ai, this.s = Ri, this.recovery = Ti, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(Ai) {
      const Ri = t.nByteLength;
      return Ai = ensureBytes$1("compactSignature", Ai, Ri * 2), new Ei(_i(Ai, 0, Ri), _i(Ai, Ri, 2 * Ri));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(Ai) {
      const { r: Ri, s: Ti } = DER$1.toSig(ensureBytes$1("DER", Ai));
      return new Ei(Ri, Ti);
    }
    assertValidity() {
      if (!En(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!En(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(Ai) {
      return new Ei(this.r, this.s, Ai);
    }
    recoverPublicKey(Ai) {
      const { r: Ri, s: Ti, recovery: Ci } = this, Ii = Pi(ensureBytes$1("msgHash", Ai));
      if (Ci == null || ![0, 1, 2, 3].includes(Ci))
        throw new Error("recovery id invalid");
      const Li = Ci === 2 || Ci === 3 ? Ri + t.n : Ri;
      if (Li >= Ie.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const Ni = Ci & 1 ? "03" : "02", Vi = fn.fromHex(Ni + fi(Li)), is = je(Li), Ki = Ue(-Ii * is), ts = Ue(Ti * is), qi = fn.BASE.multiplyAndAddUnsafe(Vi, Ki, ts);
      if (!qi)
        throw new Error("point at infinify");
      return qi.assertValidity(), qi;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return bi(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Ei(this.r, Ue(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes$1(this.toDERHex());
    }
    toDERHex() {
      return DER$1.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes$1(this.toCompactHex());
    }
    toCompactHex() {
      return fi(this.r) + fi(this.s);
    }
  }
  const Si = {
    isValidPrivateKey(wi) {
      try {
        return Ve(wi), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: Ve,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const wi = getMinHashLength$1(t.n);
      return mapHashToField$1(t.randomBytes(wi), t.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(wi = 8, Ai = fn.BASE) {
      return Ai._setWindowSize(wi), Ai.multiply(BigInt(3)), Ai;
    }
  };
  function Mi(wi, Ai = !0) {
    return fn.fromPrivateKey(wi).toRawBytes(Ai);
  }
  function Oi(wi) {
    const Ai = wi instanceof Uint8Array, Ri = typeof wi == "string", Ti = (Ai || Ri) && wi.length;
    return Ai ? Ti === Pe || Ti === Te : Ri ? Ti === 2 * Pe || Ti === 2 * Te : wi instanceof fn;
  }
  function Fi(wi, Ai, Ri = !0) {
    if (Oi(wi))
      throw new Error("first arg must be private key");
    if (!Oi(Ai))
      throw new Error("second arg must be public key");
    return fn.fromHex(Ai).multiply(Ve(wi)).toRawBytes(Ri);
  }
  const Ui = t.bits2int || function(wi) {
    const Ai = bytesToNumberBE$1(wi), Ri = wi.length * 8 - t.nBitLength;
    return Ri > 0 ? Ai >> BigInt(Ri) : Ai;
  }, Pi = t.bits2int_modN || function(wi) {
    return Ue(Ui(wi));
  }, Bi = bitMask$1(t.nBitLength);
  function ji(wi) {
    if (typeof wi != "bigint")
      throw new Error("bigint expected");
    if (!(_0n$4 <= wi && wi < Bi))
      throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return numberToBytesBE$1(wi, t.nByteLength);
  }
  function Zi(wi, Ai, Ri = zi) {
    if (["recovered", "canonical"].some((Xi) => Xi in Ri))
      throw new Error("sign() legacy options not supported");
    const { hash: Ti, randomBytes: Ci } = t;
    let { lowS: Ii, prehash: Li, extraEntropy: Ni } = Ri;
    Ii == null && (Ii = !0), wi = ensureBytes$1("msgHash", wi), Li && (wi = ensureBytes$1("prehashed msgHash", Ti(wi)));
    const Vi = Pi(wi), is = Ve(Ai), Ki = [ji(is), ji(Vi)];
    if (Ni != null) {
      const Xi = Ni === !0 ? Ci(Ie.BYTES) : Ni;
      Ki.push(ensureBytes$1("extraEntropy", Xi));
    }
    const ts = concatBytes$1(...Ki), qi = Vi;
    function Hi(Xi) {
      const ki = Ui(Xi);
      if (!En(ki))
        return;
      const Wi = je(ki), Yi = fn.BASE.multiply(ki).toAffine(), Qi = Ue(Yi.x);
      if (Qi === _0n$4)
        return;
      const ns = Ue(Wi * Ue(qi + Qi * is));
      if (ns === _0n$4)
        return;
      let us = (Yi.x === Qi ? 0 : 2) | Number(Yi.y & _1n$6), ps = ns;
      return Ii && bi(ns) && (ps = mi(ns), us ^= 1), new Ei(Qi, ps, us);
    }
    return { seed: ts, k2sig: Hi };
  }
  const zi = { lowS: t.lowS, prehash: !1 }, xi = { lowS: t.lowS, prehash: !1 };
  function $i(wi, Ai, Ri = zi) {
    const { seed: Ti, k2sig: Ci } = Zi(wi, Ai, Ri), Ii = t;
    return createHmacDrbg$1(Ii.hash.outputLen, Ii.nByteLength, Ii.hmac)(Ti, Ci);
  }
  fn.BASE._setWindowSize(8);
  function vi(wi, Ai, Ri, Ti = xi) {
    var Yi;
    const Ci = wi;
    if (Ai = ensureBytes$1("msgHash", Ai), Ri = ensureBytes$1("publicKey", Ri), "strict" in Ti)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: Ii, prehash: Li } = Ti;
    let Ni, Vi;
    try {
      if (typeof Ci == "string" || Ci instanceof Uint8Array)
        try {
          Ni = Ei.fromDER(Ci);
        } catch (Qi) {
          if (!(Qi instanceof DER$1.Err))
            throw Qi;
          Ni = Ei.fromCompact(Ci);
        }
      else if (typeof Ci == "object" && typeof Ci.r == "bigint" && typeof Ci.s == "bigint") {
        const { r: Qi, s: ns } = Ci;
        Ni = new Ei(Qi, ns);
      } else
        throw new Error("PARSE");
      Vi = fn.fromHex(Ri);
    } catch (Qi) {
      if (Qi.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (Ii && Ni.hasHighS())
      return !1;
    Li && (Ai = t.hash(Ai));
    const { r: is, s: Ki } = Ni, ts = Pi(Ai), qi = je(Ki), Hi = Ue(ts * qi), Xi = Ue(is * qi), ki = (Yi = fn.BASE.multiplyAndAddUnsafe(Vi, Hi, Xi)) == null ? void 0 : Yi.toAffine();
    return ki ? Ue(ki.x) === is : !1;
  }
  return {
    CURVE: t,
    getPublicKey: Mi,
    getSharedSecret: Fi,
    sign: $i,
    verify: vi,
    ProjectivePoint: fn,
    Signature: Ei,
    utils: Si
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash$1(Ae) {
  return {
    hash: Ae,
    hmac: (t, ...Ie) => hmac$3(Ae, t, concatBytes$2(...Ie)),
    randomBytes
  };
}
function createCurve$1(Ae, t) {
  const Ie = (Be) => weierstrass$1({ ...Ae, ...getHash$1(Be) });
  return Object.freeze({ ...Ie(t), create: Ie });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P$1 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), secp256k1N$1 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), _1n$5 = BigInt(1), _2n$3 = BigInt(2), divNearest$1 = (Ae, t) => (Ae + t / _2n$3) / t;
function sqrtMod$1(Ae) {
  const t = secp256k1P$1, Ie = BigInt(3), Be = BigInt(6), Pe = BigInt(11), Te = BigInt(22), Me = BigInt(23), Ue = BigInt(44), je = BigInt(88), fn = Ae * Ae * Ae % t, Ve = fn * fn * Ae % t, vn = pow2$1(Ve, Ie, t) * Ve % t, En = pow2$1(vn, Ie, t) * Ve % t, fi = pow2$1(En, _2n$3, t) * fn % t, bi = pow2$1(fi, Pe, t) * fi % t, mi = pow2$1(bi, Te, t) * bi % t, _i = pow2$1(mi, Ue, t) * mi % t, Ei = pow2$1(_i, je, t) * _i % t, Si = pow2$1(Ei, Ue, t) * mi % t, Mi = pow2$1(Si, Ie, t) * Ve % t, Oi = pow2$1(Mi, Me, t) * bi % t, Fi = pow2$1(Oi, Be, t) * fn % t, Ui = pow2$1(Fi, _2n$3, t);
  if (!Fp$1.eql(Fp$1.sqr(Ui), Ae))
    throw new Error("Cannot find square root");
  return Ui;
}
const Fp$1 = Field$1(secp256k1P$1, void 0, void 0, { sqrt: sqrtMod$1 }), secp256k1$2 = createCurve$1({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Fp$1,
  n: secp256k1N$1,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (Ae) => {
      const t = secp256k1N$1, Ie = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), Be = -_1n$5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), Pe = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), Te = Ie, Me = BigInt("0x100000000000000000000000000000000"), Ue = divNearest$1(Te * Ae, t), je = divNearest$1(-Be * Ae, t);
      let fn = mod$1(Ae - Ue * Ie - je * Pe, t), Ve = mod$1(-Ue * Be - je * Te, t);
      const vn = fn > Me, En = Ve > Me;
      if (vn && (fn = t - fn), En && (Ve = t - Ve), fn > Me || Ve > Me)
        throw new Error("splitScalar: Endomorphism failed, k=" + Ae);
      return { k1neg: vn, k1: fn, k2neg: En, k2: Ve };
    }
  }
}, sha256$2);
BigInt(0);
secp256k1$2.ProjectivePoint;
const ZeroAddress = "0x0000000000000000000000000000000000000000", ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000", MessagePrefix = `Ethereum Signed Message:
`, BN_0$3 = BigInt(0), BN_1$1 = BigInt(1), BN_2$1 = BigInt(2), BN_27$1 = BigInt(27), BN_28$1 = BigInt(28), BN_35$1 = BigInt(35), _guard = {};
function toUint256(Ae) {
  return zeroPadValue(toBeArray(Ae), 32);
}
var Xa, Za, Qa, Va, ya;
let Signature$1 = (ya = class {
  /**
   *  @private
   */
  constructor(t, Ie, Be, Pe) {
    ia(this, Xa);
    ia(this, Za);
    ia(this, Qa);
    ia(this, Va);
    assertPrivate(t, _guard, "Signature"), Jo(this, Xa, Ie), Jo(this, Za, Be), Jo(this, Qa, Pe), Jo(this, Va, null);
  }
  /**
   *  The ``r`` value for a signautre.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return ea(this, Xa);
  }
  set r(t) {
    assertArgument(dataLength(t) === 32, "invalid r", "value", t), Jo(this, Xa, hexlify$1(t));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return ea(this, Za);
  }
  set s(t) {
    assertArgument(dataLength(t) === 32, "invalid s", "value", t);
    const Ie = hexlify$1(t);
    assertArgument(parseInt(Ie.substring(0, 3)) < 8, "non-canonical s", "value", Ie), Jo(this, Za, Ie);
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return ea(this, Qa);
  }
  set v(t) {
    const Ie = getNumber(t, "value");
    assertArgument(Ie === 27 || Ie === 28, "invalid v", "v", t), Jo(this, Qa, Ie);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return ea(this, Va);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const t = this.networkV;
    return t == null ? null : ya.getChainId(t);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const t = getBytes(this.s);
    return this.yParity && (t[0] |= 128), hexlify$1(t);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return concat$2([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return concat$2([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const t = new ya(_guard, this.r, this.s, this.v);
    return this.networkV && Jo(t, Va, this.networkV), t;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const t = this.networkV;
    return {
      _type: "signature",
      networkV: t != null ? t.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(t) {
    const Ie = getBigInt(t, "v");
    return Ie == BN_27$1 || Ie == BN_28$1 ? BN_0$3 : (assertArgument(Ie >= BN_35$1, "invalid EIP-155 v", "v", t), (Ie - BN_35$1) / BN_2$1);
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(t, Ie) {
    return getBigInt(t) * BN_2$1 + BigInt(35 + Ie - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(t) {
    const Ie = getBigInt(t);
    return Ie === BN_0$3 || Ie === BN_27$1 ? 27 : Ie === BN_1$1 || Ie === BN_28$1 ? 28 : (assertArgument(Ie >= BN_35$1, "invalid v", "v", t), Ie & BN_1$1 ? 27 : 28);
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(t) {
    function Ie(fn, Ve) {
      assertArgument(fn, Ve, "signature", t);
    }
    if (t == null)
      return new ya(_guard, ZeroHash, ZeroHash, 27);
    if (typeof t == "string") {
      const fn = getBytes(t, "signature");
      if (fn.length === 64) {
        const Ve = hexlify$1(fn.slice(0, 32)), vn = fn.slice(32, 64), En = vn[0] & 128 ? 28 : 27;
        return vn[0] &= 127, new ya(_guard, Ve, hexlify$1(vn), En);
      }
      if (fn.length === 65) {
        const Ve = hexlify$1(fn.slice(0, 32)), vn = fn.slice(32, 64);
        Ie((vn[0] & 128) === 0, "non-canonical s");
        const En = ya.getNormalizedV(fn[64]);
        return new ya(_guard, Ve, hexlify$1(vn), En);
      }
      Ie(!1, "invalid raw signature length");
    }
    if (t instanceof ya)
      return t.clone();
    const Be = t.r;
    Ie(Be != null, "missing r");
    const Pe = toUint256(Be), Te = function(fn, Ve) {
      if (fn != null)
        return toUint256(fn);
      if (Ve != null) {
        Ie(isHexString$1(Ve, 32), "invalid yParityAndS");
        const vn = getBytes(Ve);
        return vn[0] &= 127, hexlify$1(vn);
      }
      Ie(!1, "missing s");
    }(t.s, t.yParityAndS);
    Ie((getBytes(Te)[0] & 128) == 0, "non-canonical s");
    const { networkV: Me, v: Ue } = function(fn, Ve, vn) {
      if (fn != null) {
        const En = getBigInt(fn);
        return {
          networkV: En >= BN_35$1 ? En : void 0,
          v: ya.getNormalizedV(En)
        };
      }
      if (Ve != null)
        return Ie(isHexString$1(Ve, 32), "invalid yParityAndS"), { v: getBytes(Ve)[0] & 128 ? 28 : 27 };
      if (vn != null) {
        switch (getNumber(vn, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        Ie(!1, "invalid yParity");
      }
      Ie(!1, "missing v");
    }(t.v, t.yParityAndS, t.yParity), je = new ya(_guard, Pe, Te, Ue);
    return Me && Jo(je, Va, Me), Ie(t.yParity == null || getNumber(t.yParity, "sig.yParity") === je.yParity, "yParity mismatch"), Ie(t.yParityAndS == null || t.yParityAndS === je.yParityAndS, "yParityAndS mismatch"), je;
  }
}, Xa = new WeakMap(), Za = new WeakMap(), Qa = new WeakMap(), Va = new WeakMap(), ya);
var La, xa;
let SigningKey$1 = (xa = class {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(t) {
    ia(this, La);
    assertArgument(dataLength(t) === 32, "invalid private key", "privateKey", "[REDACTED]"), Jo(this, La, hexlify$1(t));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return ea(this, La);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return xa.computePublicKey(ea(this, La));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return xa.computePublicKey(ea(this, La), !0);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(t) {
    assertArgument(dataLength(t) === 32, "invalid digest length", "digest", t);
    const Ie = secp256k1$2.sign(getBytesCopy(t), getBytesCopy(ea(this, La)), {
      lowS: !0
    });
    return Signature$1.from({
      r: toBeHex(Ie.r, 32),
      s: toBeHex(Ie.s, 32),
      v: Ie.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(t) {
    const Ie = xa.computePublicKey(t);
    return hexlify$1(secp256k1$2.getSharedSecret(getBytesCopy(ea(this, La)), getBytes(Ie), !1));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(t, Ie) {
    let Be = getBytes(t, "key");
    if (Be.length === 32) {
      const Te = secp256k1$2.getPublicKey(Be, !!Ie);
      return hexlify$1(Te);
    }
    if (Be.length === 64) {
      const Te = new Uint8Array(65);
      Te[0] = 4, Te.set(Be, 1), Be = Te;
    }
    const Pe = secp256k1$2.ProjectivePoint.fromHex(Be);
    return hexlify$1(Pe.toRawBytes(Ie));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(t, Ie) {
    assertArgument(dataLength(t) === 32, "invalid digest length", "digest", t);
    const Be = Signature$1.from(Ie);
    let Pe = secp256k1$2.Signature.fromCompact(getBytesCopy(concat$2([Be.r, Be.s])));
    Pe = Pe.addRecoveryBit(Be.yParity);
    const Te = Pe.recoverPublicKey(getBytesCopy(t));
    return assertArgument(Te != null, "invalid signautre for digest", "signature", Ie), "0x" + Te.toHex(!1);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(t, Ie, Be) {
    const Pe = secp256k1$2.ProjectivePoint.fromHex(xa.computePublicKey(t).substring(2)), Te = secp256k1$2.ProjectivePoint.fromHex(xa.computePublicKey(Ie).substring(2));
    return "0x" + Pe.add(Te).toHex(!!Be);
  }
}, La = new WeakMap(), xa);
const BN_0$2 = BigInt(0), BN_36 = BigInt(36);
function getChecksumAddress$1(Ae) {
  Ae = Ae.toLowerCase();
  const t = Ae.substring(2).split(""), Ie = new Uint8Array(40);
  for (let Pe = 0; Pe < 40; Pe++)
    Ie[Pe] = t[Pe].charCodeAt(0);
  const Be = getBytes(keccak256$1(Ie));
  for (let Pe = 0; Pe < 40; Pe += 2)
    Be[Pe >> 1] >> 4 >= 8 && (t[Pe] = t[Pe].toUpperCase()), (Be[Pe >> 1] & 15) >= 8 && (t[Pe + 1] = t[Pe + 1].toUpperCase());
  return "0x" + t.join("");
}
const ibanLookup$1 = {};
for (let Ae = 0; Ae < 10; Ae++)
  ibanLookup$1[String(Ae)] = String(Ae);
for (let Ae = 0; Ae < 26; Ae++)
  ibanLookup$1[String.fromCharCode(65 + Ae)] = String(10 + Ae);
const safeDigits$1 = 15;
function ibanChecksum$1(Ae) {
  Ae = Ae.toUpperCase(), Ae = Ae.substring(4) + Ae.substring(0, 2) + "00";
  let t = Ae.split("").map((Be) => ibanLookup$1[Be]).join("");
  for (; t.length >= safeDigits$1; ) {
    let Be = t.substring(0, safeDigits$1);
    t = parseInt(Be, 10) % 97 + t.substring(Be.length);
  }
  let Ie = String(98 - parseInt(t, 10) % 97);
  for (; Ie.length < 2; )
    Ie = "0" + Ie;
  return Ie;
}
const Base36 = function() {
  const Ae = {};
  for (let t = 0; t < 36; t++) {
    const Ie = "0123456789abcdefghijklmnopqrstuvwxyz"[t];
    Ae[Ie] = BigInt(t);
  }
  return Ae;
}();
function fromBase36(Ae) {
  Ae = Ae.toLowerCase();
  let t = BN_0$2;
  for (let Ie = 0; Ie < Ae.length; Ie++)
    t = t * BN_36 + Base36[Ae[Ie]];
  return t;
}
function getAddress$1(Ae) {
  if (assertArgument(typeof Ae == "string", "invalid address", "address", Ae), Ae.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    Ae.startsWith("0x") || (Ae = "0x" + Ae);
    const t = getChecksumAddress$1(Ae);
    return assertArgument(!Ae.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || t === Ae, "bad address checksum", "address", Ae), t;
  }
  if (Ae.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument(Ae.substring(2, 4) === ibanChecksum$1(Ae), "bad icap checksum", "address", Ae);
    let t = fromBase36(Ae.substring(4)).toString(16);
    for (; t.length < 40; )
      t = "0" + t;
    return getChecksumAddress$1("0x" + t);
  }
  assertArgument(!1, "invalid address", "address", Ae);
}
function id(Ae) {
  return keccak256$1(toUtf8Bytes$1(Ae));
}
function accessSetify(Ae, t) {
  return {
    address: getAddress$1(Ae),
    storageKeys: t.map((Ie, Be) => (assertArgument(isHexString$1(Ie, 32), "invalid slot", `storageKeys[${Be}]`, Ie), Ie.toLowerCase()))
  };
}
function accessListify(Ae) {
  if (Array.isArray(Ae))
    return Ae.map((Ie, Be) => Array.isArray(Ie) ? (assertArgument(Ie.length === 2, "invalid slot set", `value[${Be}]`, Ie), accessSetify(Ie[0], Ie[1])) : (assertArgument(Ie != null && typeof Ie == "object", "invalid address-slot set", "value", Ae), accessSetify(Ie.address, Ie.storageKeys)));
  assertArgument(Ae != null && typeof Ae == "object", "invalid access list", "value", Ae);
  const t = Object.keys(Ae).map((Ie) => {
    const Be = Ae[Ie].reduce((Pe, Te) => (Pe[Te] = !0, Pe), {});
    return accessSetify(Ie, Object.keys(Be).sort());
  });
  return t.sort((Ie, Be) => Ie.address.localeCompare(Be.address)), t;
}
function computeAddress$1(Ae) {
  let t;
  return typeof Ae == "string" ? t = SigningKey$1.computePublicKey(Ae, !1) : t = Ae.publicKey, getAddress$1(keccak256$1("0x" + t.substring(4)).substring(26));
}
function recoverAddress$1(Ae, t) {
  return computeAddress$1(SigningKey$1.recoverPublicKey(Ae, t));
}
const BN_0$1 = BigInt(0), BN_2 = BigInt(2), BN_27 = BigInt(27), BN_28 = BigInt(28), BN_35 = BigInt(35), BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), BLOB_SIZE = 4096 * 32;
function getVersionedHash(Ae, t) {
  let Ie = Ae.toString(16);
  for (; Ie.length < 2; )
    Ie = "0" + Ie;
  return Ie += sha256$1(t).substring(4), "0x" + Ie;
}
function handleAddress(Ae) {
  return Ae === "0x" ? null : getAddress$1(Ae);
}
function handleAccessList(Ae, t) {
  try {
    return accessListify(Ae);
  } catch (Ie) {
    assertArgument(!1, Ie.message, t, Ae);
  }
}
function handleNumber(Ae, t) {
  return Ae === "0x" ? 0 : getNumber(Ae, t);
}
function handleUint(Ae, t) {
  if (Ae === "0x")
    return BN_0$1;
  const Ie = getBigInt(Ae, t);
  return assertArgument(Ie <= BN_MAX_UINT, "value exceeds uint size", t, Ie), Ie;
}
function formatNumber(Ae, t) {
  const Ie = getBigInt(Ae, "value"), Be = toBeArray(Ie);
  return assertArgument(Be.length <= 32, "value too large", `tx.${t}`, Ie), Be;
}
function formatAccessList(Ae) {
  return accessListify(Ae).map((t) => [t.address, t.storageKeys]);
}
function formatHashes(Ae, t) {
  assertArgument(Array.isArray(Ae), `invalid ${t}`, "value", Ae);
  for (let Ie = 0; Ie < Ae.length; Ie++)
    assertArgument(isHexString$1(Ae[Ie], 32), "invalid ${ param } hash", `value[${Ie}]`, Ae[Ie]);
  return Ae;
}
function _parseLegacy(Ae) {
  const t = decodeRlp(Ae);
  assertArgument(Array.isArray(t) && (t.length === 9 || t.length === 6), "invalid field count for legacy transaction", "data", Ae);
  const Ie = {
    type: 0,
    nonce: handleNumber(t[0], "nonce"),
    gasPrice: handleUint(t[1], "gasPrice"),
    gasLimit: handleUint(t[2], "gasLimit"),
    to: handleAddress(t[3]),
    value: handleUint(t[4], "value"),
    data: hexlify$1(t[5]),
    chainId: BN_0$1
  };
  if (t.length === 6)
    return Ie;
  const Be = handleUint(t[6], "v"), Pe = handleUint(t[7], "r"), Te = handleUint(t[8], "s");
  if (Pe === BN_0$1 && Te === BN_0$1)
    Ie.chainId = Be;
  else {
    let Me = (Be - BN_35) / BN_2;
    Me < BN_0$1 && (Me = BN_0$1), Ie.chainId = Me, assertArgument(Me !== BN_0$1 || Be === BN_27 || Be === BN_28, "non-canonical legacy v", "v", t[6]), Ie.signature = Signature$1.from({
      r: zeroPadValue(t[7], 32),
      s: zeroPadValue(t[8], 32),
      v: Be
    });
  }
  return Ie;
}
function _serializeLegacy(Ae, t) {
  const Ie = [
    formatNumber(Ae.nonce, "nonce"),
    formatNumber(Ae.gasPrice || 0, "gasPrice"),
    formatNumber(Ae.gasLimit, "gasLimit"),
    Ae.to || "0x",
    formatNumber(Ae.value, "value"),
    Ae.data
  ];
  let Be = BN_0$1;
  if (Ae.chainId != BN_0$1)
    Be = getBigInt(Ae.chainId, "tx.chainId"), assertArgument(!t || t.networkV == null || t.legacyChainId === Be, "tx.chainId/sig.v mismatch", "sig", t);
  else if (Ae.signature) {
    const Te = Ae.signature.legacyChainId;
    Te != null && (Be = Te);
  }
  if (!t)
    return Be !== BN_0$1 && (Ie.push(toBeArray(Be)), Ie.push("0x"), Ie.push("0x")), encodeRlp(Ie);
  let Pe = BigInt(27 + t.yParity);
  return Be !== BN_0$1 ? Pe = Signature$1.getChainIdV(Be, t.v) : BigInt(t.v) !== Pe && assertArgument(!1, "tx.chainId/sig.v mismatch", "sig", t), Ie.push(toBeArray(Pe)), Ie.push(toBeArray(t.r)), Ie.push(toBeArray(t.s)), encodeRlp(Ie);
}
function _parseEipSignature(Ae, t) {
  let Ie;
  try {
    if (Ie = handleNumber(t[0], "yParity"), Ie !== 0 && Ie !== 1)
      throw new Error("bad yParity");
  } catch {
    assertArgument(!1, "invalid yParity", "yParity", t[0]);
  }
  const Be = zeroPadValue(t[1], 32), Pe = zeroPadValue(t[2], 32), Te = Signature$1.from({ r: Be, s: Pe, yParity: Ie });
  Ae.signature = Te;
}
function _parseEip1559(Ae) {
  const t = decodeRlp(getBytes(Ae).slice(1));
  assertArgument(Array.isArray(t) && (t.length === 9 || t.length === 12), "invalid field count for transaction type: 2", "data", hexlify$1(Ae));
  const Ie = {
    type: 2,
    chainId: handleUint(t[0], "chainId"),
    nonce: handleNumber(t[1], "nonce"),
    maxPriorityFeePerGas: handleUint(t[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(t[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(t[4], "gasLimit"),
    to: handleAddress(t[5]),
    value: handleUint(t[6], "value"),
    data: hexlify$1(t[7]),
    accessList: handleAccessList(t[8], "accessList")
  };
  return t.length === 9 || _parseEipSignature(Ie, t.slice(9)), Ie;
}
function _serializeEip1559(Ae, t) {
  const Ie = [
    formatNumber(Ae.chainId, "chainId"),
    formatNumber(Ae.nonce, "nonce"),
    formatNumber(Ae.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(Ae.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(Ae.gasLimit, "gasLimit"),
    Ae.to || "0x",
    formatNumber(Ae.value, "value"),
    Ae.data,
    formatAccessList(Ae.accessList || [])
  ];
  return t && (Ie.push(formatNumber(t.yParity, "yParity")), Ie.push(toBeArray(t.r)), Ie.push(toBeArray(t.s))), concat$2(["0x02", encodeRlp(Ie)]);
}
function _parseEip2930(Ae) {
  const t = decodeRlp(getBytes(Ae).slice(1));
  assertArgument(Array.isArray(t) && (t.length === 8 || t.length === 11), "invalid field count for transaction type: 1", "data", hexlify$1(Ae));
  const Ie = {
    type: 1,
    chainId: handleUint(t[0], "chainId"),
    nonce: handleNumber(t[1], "nonce"),
    gasPrice: handleUint(t[2], "gasPrice"),
    gasLimit: handleUint(t[3], "gasLimit"),
    to: handleAddress(t[4]),
    value: handleUint(t[5], "value"),
    data: hexlify$1(t[6]),
    accessList: handleAccessList(t[7], "accessList")
  };
  return t.length === 8 || _parseEipSignature(Ie, t.slice(8)), Ie;
}
function _serializeEip2930(Ae, t) {
  const Ie = [
    formatNumber(Ae.chainId, "chainId"),
    formatNumber(Ae.nonce, "nonce"),
    formatNumber(Ae.gasPrice || 0, "gasPrice"),
    formatNumber(Ae.gasLimit, "gasLimit"),
    Ae.to || "0x",
    formatNumber(Ae.value, "value"),
    Ae.data,
    formatAccessList(Ae.accessList || [])
  ];
  return t && (Ie.push(formatNumber(t.yParity, "recoveryParam")), Ie.push(toBeArray(t.r)), Ie.push(toBeArray(t.s))), concat$2(["0x01", encodeRlp(Ie)]);
}
function _parseEip4844(Ae) {
  let t = decodeRlp(getBytes(Ae).slice(1)), Ie = "3", Be = null;
  if (t.length === 4 && Array.isArray(t[0])) {
    Ie = "3 (network format)";
    const Te = t[1], Me = t[2], Ue = t[3];
    assertArgument(Array.isArray(Te), "invalid network format: blobs not an array", "fields[1]", Te), assertArgument(Array.isArray(Me), "invalid network format: commitments not an array", "fields[2]", Me), assertArgument(Array.isArray(Ue), "invalid network format: proofs not an array", "fields[3]", Ue), assertArgument(Te.length === Me.length, "invalid network format: blobs/commitments length mismatch", "fields", t), assertArgument(Te.length === Ue.length, "invalid network format: blobs/proofs length mismatch", "fields", t), Be = [];
    for (let je = 0; je < t[1].length; je++)
      Be.push({
        data: Te[je],
        commitment: Me[je],
        proof: Ue[je]
      });
    t = t[0];
  }
  assertArgument(Array.isArray(t) && (t.length === 11 || t.length === 14), `invalid field count for transaction type: ${Ie}`, "data", hexlify$1(Ae));
  const Pe = {
    type: 3,
    chainId: handleUint(t[0], "chainId"),
    nonce: handleNumber(t[1], "nonce"),
    maxPriorityFeePerGas: handleUint(t[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(t[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(t[4], "gasLimit"),
    to: handleAddress(t[5]),
    value: handleUint(t[6], "value"),
    data: hexlify$1(t[7]),
    accessList: handleAccessList(t[8], "accessList"),
    maxFeePerBlobGas: handleUint(t[9], "maxFeePerBlobGas"),
    blobVersionedHashes: t[10]
  };
  Be && (Pe.blobs = Be), assertArgument(Pe.to != null, `invalid address for transaction type: ${Ie}`, "data", Ae), assertArgument(Array.isArray(Pe.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", Ae);
  for (let Te = 0; Te < Pe.blobVersionedHashes.length; Te++)
    assertArgument(isHexString$1(Pe.blobVersionedHashes[Te], 32), `invalid blobVersionedHash at index ${Te}: must be length 32`, "data", Ae);
  return t.length === 11 || _parseEipSignature(Pe, t.slice(11)), Pe;
}
function _serializeEip4844(Ae, t, Ie) {
  const Be = [
    formatNumber(Ae.chainId, "chainId"),
    formatNumber(Ae.nonce, "nonce"),
    formatNumber(Ae.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(Ae.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(Ae.gasLimit, "gasLimit"),
    Ae.to || ZeroAddress,
    formatNumber(Ae.value, "value"),
    Ae.data,
    formatAccessList(Ae.accessList || []),
    formatNumber(Ae.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    formatHashes(Ae.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  return t && (Be.push(formatNumber(t.yParity, "yParity")), Be.push(toBeArray(t.r)), Be.push(toBeArray(t.s)), Ie) ? concat$2([
    "0x03",
    encodeRlp([
      Be,
      Ie.map((Pe) => Pe.data),
      Ie.map((Pe) => Pe.commitment),
      Ie.map((Pe) => Pe.proof)
    ])
  ]) : concat$2(["0x03", encodeRlp(Be)]);
}
var Sa, tc, rc, nc, ic, sc, oc, ac, cc, fc, uc, lc, Ja, za, qa, Ga, dc, Ac;
const ka = class ka {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    ia(this, dc);
    ia(this, Sa);
    ia(this, tc);
    ia(this, rc);
    ia(this, nc);
    ia(this, ic);
    ia(this, sc);
    ia(this, oc);
    ia(this, ac);
    ia(this, cc);
    ia(this, fc);
    ia(this, uc);
    ia(this, lc);
    ia(this, Ja);
    ia(this, za);
    ia(this, qa);
    ia(this, Ga);
    Jo(this, Sa, null), Jo(this, tc, null), Jo(this, nc, 0), Jo(this, ic, BN_0$1), Jo(this, sc, null), Jo(this, oc, null), Jo(this, ac, null), Jo(this, rc, "0x"), Jo(this, cc, BN_0$1), Jo(this, fc, BN_0$1), Jo(this, uc, null), Jo(this, lc, null), Jo(this, Ja, null), Jo(this, za, null), Jo(this, Ga, null), Jo(this, qa, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return ea(this, Sa);
  }
  set type(t) {
    switch (t) {
      case null:
        Jo(this, Sa, null);
        break;
      case 0:
      case "legacy":
        Jo(this, Sa, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        Jo(this, Sa, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        Jo(this, Sa, 2);
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        Jo(this, Sa, 3);
        break;
      default:
        assertArgument(!1, "unsupported transaction type", "type", t);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const t = ea(this, tc);
    return t == null && this.type === 3 ? ZeroAddress : t;
  }
  set to(t) {
    Jo(this, tc, t == null ? null : getAddress$1(t));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return ea(this, nc);
  }
  set nonce(t) {
    Jo(this, nc, getNumber(t, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return ea(this, ic);
  }
  set gasLimit(t) {
    Jo(this, ic, getBigInt(t));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const t = ea(this, sc);
    return t == null && (this.type === 0 || this.type === 1) ? BN_0$1 : t;
  }
  set gasPrice(t) {
    Jo(this, sc, t == null ? null : getBigInt(t, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const t = ea(this, oc);
    return t ?? (this.type === 2 || this.type === 3 ? BN_0$1 : null);
  }
  set maxPriorityFeePerGas(t) {
    Jo(this, oc, t == null ? null : getBigInt(t, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const t = ea(this, ac);
    return t ?? (this.type === 2 || this.type === 3 ? BN_0$1 : null);
  }
  set maxFeePerGas(t) {
    Jo(this, ac, t == null ? null : getBigInt(t, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return ea(this, rc);
  }
  set data(t) {
    Jo(this, rc, hexlify$1(t));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return ea(this, cc);
  }
  set value(t) {
    Jo(this, cc, getBigInt(t, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return ea(this, fc);
  }
  set chainId(t) {
    Jo(this, fc, getBigInt(t));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return ea(this, uc) || null;
  }
  set signature(t) {
    Jo(this, uc, t == null ? null : Signature$1.from(t));
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const t = ea(this, lc) || null;
    return t ?? (this.type === 1 || this.type === 2 || this.type === 3 ? [] : null);
  }
  set accessList(t) {
    Jo(this, lc, t == null ? null : accessListify(t));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const t = ea(this, Ja);
    return t == null && this.type === 3 ? BN_0$1 : t;
  }
  set maxFeePerBlobGas(t) {
    Jo(this, Ja, t == null ? null : getBigInt(t, "maxFeePerBlobGas"));
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let t = ea(this, za);
    return t == null && this.type === 3 ? [] : t;
  }
  set blobVersionedHashes(t) {
    if (t != null) {
      assertArgument(Array.isArray(t), "blobVersionedHashes must be an Array", "value", t), t = t.slice();
      for (let Ie = 0; Ie < t.length; Ie++)
        assertArgument(isHexString$1(t[Ie], 32), "invalid blobVersionedHash", `value[${Ie}]`, t[Ie]);
    }
    Jo(this, za, t);
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    return ea(this, Ga) == null ? null : ea(this, Ga).map((t) => Object.assign({}, t));
  }
  set blobs(t) {
    if (t == null) {
      Jo(this, Ga, null);
      return;
    }
    const Ie = [], Be = [];
    for (let Pe = 0; Pe < t.length; Pe++) {
      const Te = t[Pe];
      if (isBytesLike$1(Te)) {
        assert$6(ea(this, qa), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let Me = getBytes(Te);
        if (assertArgument(Me.length <= BLOB_SIZE, "blob is too large", `blobs[${Pe}]`, Te), Me.length !== BLOB_SIZE) {
          const fn = new Uint8Array(BLOB_SIZE);
          fn.set(Me), Me = fn;
        }
        const Ue = ea(this, qa).blobToKzgCommitment(Me), je = hexlify$1(ea(this, qa).computeBlobKzgProof(Me, Ue));
        Ie.push({
          data: hexlify$1(Me),
          commitment: hexlify$1(Ue),
          proof: je
        }), Be.push(getVersionedHash(1, Ue));
      } else {
        const Me = hexlify$1(Te.commitment);
        Ie.push({
          data: hexlify$1(Te.data),
          commitment: Me,
          proof: hexlify$1(Te.proof)
        }), Be.push(getVersionedHash(1, Me));
      }
    }
    Jo(this, Ga, Ie), Jo(this, za, Be);
  }
  get kzg() {
    return ea(this, qa);
  }
  set kzg(t) {
    Jo(this, qa, t);
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    return this.signature == null ? null : keccak256$1(mc(this, dc, Ac).call(this, !0, !1));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return keccak256$1(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    return this.signature == null ? null : recoverAddress$1(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    return this.signature == null ? null : SigningKey$1.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return mc(this, dc, Ac).call(this, !0, !0);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return mc(this, dc, Ac).call(this, !1, !1);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const t = this.inferTypes();
    return t.indexOf(2) >= 0 ? 2 : t.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const t = this.gasPrice != null, Ie = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null, Be = this.accessList != null, Pe = ea(this, Ja) != null || ea(this, za);
    this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && assert$6(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this }), assert$6(!Ie || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this }), assert$6(this.type !== 0 || !Be, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const Te = [];
    return this.type != null ? Te.push(this.type) : Ie ? Te.push(2) : t ? (Te.push(1), Be || Te.push(0)) : Be ? (Te.push(1), Te.push(2)) : (Pe && this.to || (Te.push(0), Te.push(1), Te.push(2)), Te.push(3)), Te.sort(), Te;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return ka.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const t = (Ie) => Ie == null ? null : Ie.toString();
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: t(this.gasLimit),
      gasPrice: t(this.gasPrice),
      maxPriorityFeePerGas: t(this.maxPriorityFeePerGas),
      maxFeePerGas: t(this.maxFeePerGas),
      value: t(this.value),
      chainId: t(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(t) {
    if (t == null)
      return new ka();
    if (typeof t == "string") {
      const Be = getBytes(t);
      if (Be[0] >= 127)
        return ka.from(_parseLegacy(Be));
      switch (Be[0]) {
        case 1:
          return ka.from(_parseEip2930(Be));
        case 2:
          return ka.from(_parseEip1559(Be));
        case 3:
          return ka.from(_parseEip4844(Be));
      }
      assert$6(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const Ie = new ka();
    return t.type != null && (Ie.type = t.type), t.to != null && (Ie.to = t.to), t.nonce != null && (Ie.nonce = t.nonce), t.gasLimit != null && (Ie.gasLimit = t.gasLimit), t.gasPrice != null && (Ie.gasPrice = t.gasPrice), t.maxPriorityFeePerGas != null && (Ie.maxPriorityFeePerGas = t.maxPriorityFeePerGas), t.maxFeePerGas != null && (Ie.maxFeePerGas = t.maxFeePerGas), t.maxFeePerBlobGas != null && (Ie.maxFeePerBlobGas = t.maxFeePerBlobGas), t.data != null && (Ie.data = t.data), t.value != null && (Ie.value = t.value), t.chainId != null && (Ie.chainId = t.chainId), t.signature != null && (Ie.signature = Signature$1.from(t.signature)), t.accessList != null && (Ie.accessList = t.accessList), t.blobVersionedHashes != null && (Ie.blobVersionedHashes = t.blobVersionedHashes), t.kzg != null && (Ie.kzg = t.kzg), t.blobs != null && (Ie.blobs = t.blobs), t.hash != null && (assertArgument(Ie.isSigned(), "unsigned transaction cannot define '.hash'", "tx", t), assertArgument(Ie.hash === t.hash, "hash mismatch", "tx", t)), t.from != null && (assertArgument(Ie.isSigned(), "unsigned transaction cannot define '.from'", "tx", t), assertArgument(Ie.from.toLowerCase() === (t.from || "").toLowerCase(), "from mismatch", "tx", t)), Ie;
  }
};
Sa = new WeakMap(), tc = new WeakMap(), rc = new WeakMap(), nc = new WeakMap(), ic = new WeakMap(), sc = new WeakMap(), oc = new WeakMap(), ac = new WeakMap(), cc = new WeakMap(), fc = new WeakMap(), uc = new WeakMap(), lc = new WeakMap(), Ja = new WeakMap(), za = new WeakMap(), qa = new WeakMap(), Ga = new WeakMap(), dc = new WeakSet(), Ac = function(t, Ie) {
  assert$6(!t || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  const Be = t ? this.signature : null;
  switch (this.inferType()) {
    case 0:
      return _serializeLegacy(this, Be);
    case 1:
      return _serializeEip2930(this, Be);
    case 2:
      return _serializeEip1559(this, Be);
    case 3:
      return _serializeEip4844(this, Be, Ie ? this.blobs : null);
  }
  assert$6(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
};
let Transaction = ka;
function hashMessage$2(Ae) {
  return typeof Ae == "string" && (Ae = toUtf8Bytes$1(Ae)), keccak256$1(concat$2([
    toUtf8Bytes$1(MessagePrefix),
    toUtf8Bytes$1(String(Ae.length)),
    Ae
  ]));
}
const padding = new Uint8Array(32);
padding.fill(0);
const BN__1 = BigInt(-1), BN_0 = BigInt(0), BN_1 = BigInt(1), BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(Ae) {
  const t = getBytes(Ae), Ie = t.length % 32;
  return Ie ? concat$2([t, padding.slice(Ie)]) : hexlify$1(t);
}
const hexTrue = toBeHex(BN_1, 32), hexFalse = toBeHex(BN_0, 32), domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(Ae) {
  return function(t) {
    return assertArgument(typeof t == "string", `invalid domain value for ${JSON.stringify(Ae)}`, `domain.${Ae}`, t), t;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(Ae) {
    const t = getBigInt(Ae, "domain.chainId");
    return assertArgument(t >= 0, "invalid chain ID", "domain.chainId", Ae), Number.isSafeInteger(t) ? Number(t) : toQuantity(t);
  },
  verifyingContract: function(Ae) {
    try {
      return getAddress$1(Ae).toLowerCase();
    } catch {
    }
    assertArgument(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", Ae);
  },
  salt: function(Ae) {
    const t = getBytes(Ae, "domain.salt");
    return assertArgument(t.length === 32, 'invalid domain value "salt"', "domain.salt", Ae), hexlify$1(t);
  }
};
function getBaseEncoder(Ae) {
  {
    const t = Ae.match(/^(u?)int(\d+)$/);
    if (t) {
      const Ie = t[1] === "", Be = parseInt(t[2]);
      assertArgument(Be % 8 === 0 && Be !== 0 && Be <= 256 && t[2] === String(Be), "invalid numeric width", "type", Ae);
      const Pe = mask(BN_MAX_UINT256, Ie ? Be - 1 : Be), Te = Ie ? (Pe + BN_1) * BN__1 : BN_0;
      return function(Me) {
        const Ue = getBigInt(Me, "value");
        return assertArgument(Ue >= Te && Ue <= Pe, `value out-of-bounds for ${Ae}`, "value", Ue), toBeHex(Ie ? toTwos(Ue, 256) : Ue, 32);
      };
    }
  }
  {
    const t = Ae.match(/^bytes(\d+)$/);
    if (t) {
      const Ie = parseInt(t[1]);
      return assertArgument(Ie !== 0 && Ie <= 32 && t[1] === String(Ie), "invalid bytes width", "type", Ae), function(Be) {
        const Pe = getBytes(Be);
        return assertArgument(Pe.length === Ie, `invalid length for ${Ae}`, "value", Be), hexPadRight(Be);
      };
    }
  }
  switch (Ae) {
    case "address":
      return function(t) {
        return zeroPadValue(getAddress$1(t), 32);
      };
    case "bool":
      return function(t) {
        return t ? hexTrue : hexFalse;
      };
    case "bytes":
      return function(t) {
        return keccak256$1(t);
      };
    case "string":
      return function(t) {
        return id(t);
      };
  }
  return null;
}
function encodeType$1(Ae, t) {
  return `${Ae}(${t.map(({ name: Ie, type: Be }) => Be + " " + Ie).join(",")})`;
}
function splitArray(Ae) {
  const t = Ae.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  return t ? {
    base: t[1],
    index: t[2] + t[4],
    array: {
      base: t[1],
      prefix: t[1] + t[2],
      count: t[5] ? parseInt(t[5]) : -1
    }
  } : { base: Ae };
}
var vc, Fa, hc, Rc, Kc;
const Ea = class Ea {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(t) {
    ia(this, Rc);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    jc(this, "primaryType");
    ia(this, vc);
    ia(this, Fa);
    ia(this, hc);
    Jo(this, Fa, /* @__PURE__ */ new Map()), Jo(this, hc, /* @__PURE__ */ new Map());
    const Ie = /* @__PURE__ */ new Map(), Be = /* @__PURE__ */ new Map(), Pe = /* @__PURE__ */ new Map(), Te = {};
    Object.keys(t).forEach((je) => {
      Te[je] = t[je].map(({ name: fn, type: Ve }) => {
        let { base: vn, index: En } = splitArray(Ve);
        return vn === "int" && !t.int && (vn = "int256"), vn === "uint" && !t.uint && (vn = "uint256"), { name: fn, type: vn + (En || "") };
      }), Ie.set(je, /* @__PURE__ */ new Set()), Be.set(je, []), Pe.set(je, /* @__PURE__ */ new Set());
    }), Jo(this, vc, JSON.stringify(Te));
    for (const je in Te) {
      const fn = /* @__PURE__ */ new Set();
      for (const Ve of Te[je]) {
        assertArgument(!fn.has(Ve.name), `duplicate variable name ${JSON.stringify(Ve.name)} in ${JSON.stringify(je)}`, "types", t), fn.add(Ve.name);
        const vn = splitArray(Ve.type).base;
        assertArgument(vn !== je, `circular type reference to ${JSON.stringify(vn)}`, "types", t), !getBaseEncoder(vn) && (assertArgument(Be.has(vn), `unknown type ${JSON.stringify(vn)}`, "types", t), Be.get(vn).push(je), Ie.get(je).add(vn));
      }
    }
    const Me = Array.from(Be.keys()).filter((je) => Be.get(je).length === 0);
    assertArgument(Me.length !== 0, "missing primary type", "types", t), assertArgument(Me.length === 1, `ambiguous primary types or unused types: ${Me.map((je) => JSON.stringify(je)).join(", ")}`, "types", t), defineProperties(this, { primaryType: Me[0] });
    function Ue(je, fn) {
      assertArgument(!fn.has(je), `circular type reference to ${JSON.stringify(je)}`, "types", t), fn.add(je);
      for (const Ve of Ie.get(je))
        if (Be.has(Ve)) {
          Ue(Ve, fn);
          for (const vn of fn)
            Pe.get(vn).add(Ve);
        }
      fn.delete(je);
    }
    Ue(this.primaryType, /* @__PURE__ */ new Set());
    for (const [je, fn] of Pe) {
      const Ve = Array.from(fn);
      Ve.sort(), ea(this, Fa).set(je, encodeType$1(je, Te[je]) + Ve.map((vn) => encodeType$1(vn, Te[vn])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(ea(this, vc));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(t) {
    let Ie = ea(this, hc).get(t);
    return Ie || (Ie = mc(this, Rc, Kc).call(this, t), ea(this, hc).set(t, Ie)), Ie;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(t) {
    const Ie = ea(this, Fa).get(t);
    return assertArgument(Ie, `unknown type: ${JSON.stringify(t)}`, "name", t), Ie;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(t, Ie) {
    return this.getEncoder(t)(Ie);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(t, Ie) {
    return keccak256$1(this.encodeData(t, Ie));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(t) {
    return this.encodeData(this.primaryType, t);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(t) {
    return this.hashStruct(this.primaryType, t);
  }
  /**
   *  @_ignore:
   */
  _visit(t, Ie, Be) {
    if (getBaseEncoder(t))
      return Be(t, Ie);
    const Pe = splitArray(t).array;
    if (Pe)
      return assertArgument(Pe.count === -1 || Pe.count === Ie.length, `array length mismatch; expected length ${Pe.count}`, "value", Ie), Ie.map((Me) => this._visit(Pe.prefix, Me, Be));
    const Te = this.types[t];
    if (Te)
      return Te.reduce((Me, { name: Ue, type: je }) => (Me[Ue] = this._visit(je, Ie[Ue], Be), Me), {});
    assertArgument(!1, `unknown type: ${t}`, "type", t);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(t, Ie) {
    return this._visit(this.primaryType, t, Ie);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(t) {
    return new Ea(t);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(t) {
    return Ea.from(t).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(t, Ie, Be) {
    return Ea.from(Ie).hashStruct(t, Be);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(t) {
    const Ie = [];
    for (const Be in t) {
      if (t[Be] == null)
        continue;
      const Pe = domainFieldTypes[Be];
      assertArgument(Pe, `invalid typed-data domain key: ${JSON.stringify(Be)}`, "domain", t), Ie.push({ name: Be, type: Pe });
    }
    return Ie.sort((Be, Pe) => domainFieldNames.indexOf(Be.name) - domainFieldNames.indexOf(Pe.name)), Ea.hashStruct("EIP712Domain", { EIP712Domain: Ie }, t);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(t, Ie, Be) {
    return concat$2([
      "0x1901",
      Ea.hashDomain(t),
      Ea.from(Ie).hash(Be)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(t, Ie, Be) {
    return keccak256$1(Ea.encode(t, Ie, Be));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(t, Ie, Be, Pe) {
    t = Object.assign({}, t);
    for (const Ue in t)
      t[Ue] == null && delete t[Ue];
    const Te = {};
    t.verifyingContract && !isHexString$1(t.verifyingContract, 20) && (Te[t.verifyingContract] = "0x");
    const Me = Ea.from(Ie);
    Me.visit(Be, (Ue, je) => (Ue === "address" && !isHexString$1(je, 20) && (Te[je] = "0x"), je));
    for (const Ue in Te)
      Te[Ue] = await Pe(Ue);
    return t.verifyingContract && Te[t.verifyingContract] && (t.verifyingContract = Te[t.verifyingContract]), Be = Me.visit(Be, (Ue, je) => Ue === "address" && Te[je] ? Te[je] : je), { domain: t, value: Be };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(t, Ie, Be) {
    Ea.hashDomain(t);
    const Pe = {}, Te = [];
    domainFieldNames.forEach((je) => {
      const fn = t[je];
      fn != null && (Pe[je] = domainChecks[je](fn), Te.push({ name: je, type: domainFieldTypes[je] }));
    });
    const Me = Ea.from(Ie);
    Ie = Me.types;
    const Ue = Object.assign({}, Ie);
    return assertArgument(Ue.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", Ie), Ue.EIP712Domain = Te, Me.encode(Be), {
      types: Ue,
      domain: Pe,
      primaryType: Me.primaryType,
      message: Me.visit(Be, (je, fn) => {
        if (je.match(/^bytes(\d*)/))
          return hexlify$1(getBytes(fn));
        if (je.match(/^u?int/))
          return getBigInt(fn).toString();
        switch (je) {
          case "address":
            return fn.toLowerCase();
          case "bool":
            return !!fn;
          case "string":
            return assertArgument(typeof fn == "string", "invalid string", "value", fn), fn;
        }
        assertArgument(!1, "unsupported type", "type", je);
      })
    };
  }
};
vc = new WeakMap(), Fa = new WeakMap(), hc = new WeakMap(), Rc = new WeakSet(), Kc = function(t) {
  {
    const Pe = getBaseEncoder(t);
    if (Pe)
      return Pe;
  }
  const Ie = splitArray(t).array;
  if (Ie) {
    const Pe = Ie.prefix, Te = this.getEncoder(Pe);
    return (Me) => {
      assertArgument(Ie.count === -1 || Ie.count === Me.length, `array length mismatch; expected length ${Ie.count}`, "value", Me);
      let Ue = Me.map(Te);
      return ea(this, Fa).has(Pe) && (Ue = Ue.map(keccak256$1)), keccak256$1(concat$2(Ue));
    };
  }
  const Be = this.types[t];
  if (Be) {
    const Pe = id(ea(this, Fa).get(t));
    return (Te) => {
      const Me = Be.map(({ name: Ue, type: je }) => {
        const fn = this.getEncoder(je)(Te[Ue]);
        return ea(this, Fa).has(je) ? keccak256$1(fn) : fn;
      });
      return Me.unshift(Pe), concat$2(Me);
    };
  }
  assertArgument(!1, `unknown type: ${t}`, "type", t);
};
let TypedDataEncoder = Ea;
const index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MessagePrefix,
  Signature: Signature$1,
  SigningKey: SigningKey$1,
  Transaction,
  TypedDataEncoder,
  ZeroAddress,
  ZeroHash,
  accessListify,
  assert: assert$6,
  assertArgument,
  assertPrivate,
  computeAddress: computeAddress$1,
  concat: concat$2,
  dataLength,
  decodeRlp,
  defineProperties,
  encodeRlp,
  getAddress: getAddress$1,
  getBigInt,
  getBytes,
  getBytesCopy,
  getNumber,
  getUint,
  hashMessage: hashMessage$2,
  hexlify: hexlify$1,
  id,
  isBytesLike: isBytesLike$1,
  isHexString: isHexString$1,
  keccak256: keccak256$1,
  makeError,
  mask,
  recoverAddress: recoverAddress$1,
  sha256: sha256$1,
  toBeArray,
  toBeHex,
  toQuantity,
  toTwos,
  toUtf8Bytes: toUtf8Bytes$1,
  version: version$5,
  zeroPadValue
}, Symbol.toStringTag, { value: "Module" })), BIG_NUMBER_WEI_MULTIPLIER = new BigNumber("1e18"), BIG_NUMBER_GWEI_MULTIPLIER = new BigNumber("1e9"), BIG_NUMBER_ETH_MULTIPLIER = new BigNumber("1"), toBigNumber = {
  hex: (Ae) => typeof Ae == "string" ? new BigNumber(stripHexPrefix(Ae), 16) : new BigNumber(Ae, 16),
  dec: (Ae) => new BigNumber(Ae, 10)
}, toNormalizedDenomination = {
  WEI: (Ae) => Ae.div(BIG_NUMBER_WEI_MULTIPLIER),
  GWEI: (Ae) => Ae.div(BIG_NUMBER_GWEI_MULTIPLIER),
  ETH: (Ae) => Ae.div(BIG_NUMBER_ETH_MULTIPLIER)
}, toSpecifiedDenomination = {
  WEI: (Ae) => Ae.times(BIG_NUMBER_WEI_MULTIPLIER).dp(0, BigNumber.ROUND_HALF_UP),
  GWEI: (Ae) => Ae.times(BIG_NUMBER_GWEI_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP),
  ETH: (Ae) => Ae.times(BIG_NUMBER_ETH_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP)
}, baseChange = {
  hex: (Ae) => Ae.toString(16),
  dec: (Ae) => new BigNumber(Ae).toString(10)
}, converter = (Ae) => {
  const {
    value: t,
    fromNumericBase: Ie,
    fromDenomination: Be,
    toNumericBase: Pe,
    toDenomination: Te,
    numberOfDecimals: Me
  } = Ae;
  let Ue = toBigNumber[Ie](t);
  return Be && (Ue = toNormalizedDenomination[Be](Ue)), Te && (Ue = toSpecifiedDenomination[Te](Ue)), Me && (Ue = Ue.dp(Me, BigNumber.ROUND_HALF_DOWN)), Pe && (Ue = baseChange[Pe](Ue)), Ue;
}, conversionUtil = (Ae, {
  fromNumericBase: t = "hex",
  toNumericBase: Ie,
  fromDenomination: Be,
  toDenomination: Pe,
  numberOfDecimals: Te
}) => converter({
  fromNumericBase: t,
  toNumericBase: Ie,
  fromDenomination: Be,
  toDenomination: Pe,
  numberOfDecimals: Te,
  value: Ae || "0"
});
function decGWEIToHexWEI(Ae) {
  return conversionUtil(Ae, {
    fromNumericBase: "dec",
    toNumericBase: "hex",
    fromDenomination: "GWEI",
    toDenomination: "WEI"
  });
}
function hexWEIToDecGWEI(Ae) {
  return conversionUtil(Ae, {
    fromNumericBase: "hex",
    toNumericBase: "dec",
    fromDenomination: "WEI",
    toDenomination: "GWEI"
  });
}
function normalizeGWEIDecimalNumbers(Ae) {
  const t = decGWEIToHexWEI(Ae);
  return hexWEIToDecGWEI(t).toString();
}
async function fetchEip1159GasEstimates(Ae) {
  const t = await get$1(Ae);
  return _objectSpread2(_objectSpread2({}, t), {}, {
    estimatedBaseFee: normalizeGWEIDecimalNumbers(t.estimatedBaseFee),
    low: _objectSpread2(_objectSpread2({}, t.low), {}, {
      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(t.low.suggestedMaxPriorityFeePerGas),
      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(t.low.suggestedMaxFeePerGas)
    }),
    medium: _objectSpread2(_objectSpread2({}, t.medium), {}, {
      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(t.medium.suggestedMaxPriorityFeePerGas),
      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(t.medium.suggestedMaxFeePerGas)
    }),
    high: _objectSpread2(_objectSpread2({}, t.high), {}, {
      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(t.high.suggestedMaxPriorityFeePerGas),
      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(t.high.suggestedMaxFeePerGas)
    })
  });
}
async function fetchLegacyGasPriceEstimates(Ae) {
  const t = await get$1(Ae, {
    referrer: Ae,
    referrerPolicy: "no-referrer-when-downgrade",
    method: "GET",
    mode: "cors"
  });
  return {
    low: t.SafeGasPrice,
    medium: t.ProposeGasPrice,
    high: t.FastGasPrice
  };
}
function validateAddress(Ae, t) {
  if (!Ae || typeof Ae != "string" || !isValidAddress(Ae))
    throw new Error(`Invalid "${t}" address: ${Ae} must be a valid string.`);
}
async function validateTypedSignMessageDataV4(Ae, t) {
  if (validateAddress(Ae.from, "from"), !Ae.data || Array.isArray(Ae.data) || typeof Ae.data != "object" && typeof Ae.data != "string")
    throw new Error('Invalid message "data": Must be a valid string or object.');
  let Ie;
  if (typeof Ae.data == "object")
    Ie = Ae.data;
  else
    try {
      Ie = JSON.parse(Ae.data);
    } catch {
      throw new Error("Data must be passed as a valid JSON string.");
    }
  if (!t)
    throw new Error("Current chainId cannot be null or undefined.");
  let {
    chainId: Be
  } = Ie.domain;
  if (Be) {
    typeof Be == "string" && (Be = parseInt(Be, Be.startsWith("0x") ? 16 : 10));
    const Pe = parseInt(t, 16);
    if (Number.isNaN(Pe))
      throw new Error(`Cannot sign messages for chainId "${Be}", because Web3Auth is switching networks.`);
    if (Be !== Pe)
      throw new Error(`Provided chainId "${Be}" must match the active chainId "${Pe}"`);
  }
}
function bnLessThan(Ae, t) {
  return Ae == null || t === null || t === void 0 ? null : new BigNumber(Ae, 10).lt(t, 10);
}
function bnToHex(Ae) {
  return addHexPrefix(Ae.toString(16));
}
function hexToBn(Ae) {
  return BN$1.isBN(Ae) ? Ae : new BN$1(stripHexPrefix(Ae), 16);
}
function BnMultiplyByFraction(Ae, t, Ie) {
  const Be = new BN$1(t), Pe = new BN$1(Ie);
  return Ae.mul(Be).div(Pe);
}
const LegacyGasAPIEndpoint = "https://gas-api.metaswap.codefi.network/networks/<chain_id>/gasPrices", EIP1559APIEndpoint = "https://gas-api.metaswap.codefi.network/networks/<chain_id>/suggestedGasFees", TRANSACTION_ENVELOPE_TYPES = {
  LEGACY: "0x0",
  ACCESS_LIST: "0x1",
  FEE_MARKET: "0x2"
}, TRANSACTION_TYPES = {
  SENT_ETHER: "sentEther",
  CONTRACT_INTERACTION: "contractInteraction",
  DEPLOY_CONTRACT: "contractDeployment",
  STANDARD_TRANSACTION: "transaction"
}, GAS_ESTIMATE_TYPES = {
  FEE_MARKET: "fee-market",
  LEGACY: "legacy",
  ETH_GASPRICE: "eth_gasPrice",
  NONE: "none"
};
class TransactionFormatter {
  constructor({
    getProviderEngineProxy: t
  }) {
    _defineProperty(this, "API_SUPPORTED_CHAINIDS", /* @__PURE__ */ new Set(["0x1", "0x5", "0x13881", "0xa4b1", "0xa86a", "0x2105", "0x38", "0xfa", "0xa", "0x89"])), _defineProperty(this, "chainConfig", null), _defineProperty(this, "getProviderEngineProxy", void 0), _defineProperty(this, "isEIP1559Compatible", !1), this.getProviderEngineProxy = t;
  }
  get providerProxy() {
    return this.getProviderEngineProxy();
  }
  async init() {
    this.chainConfig = await this.providerProxy.request({
      method: "eth_provider_config"
    }), this.isEIP1559Compatible = await this.getEIP1559Compatibility();
  }
  async formatTransaction(t) {
    if (!this.chainConfig) throw new Error("Chain config not initialized");
    const Ie = _objectSpread2({}, t);
    if (Ie.nonce === void 0 && (Ie.nonce = await this.providerProxy.request({
      method: "eth_getTransactionCount",
      params: [t.from, "latest"]
    })), !this.isEIP1559Compatible && Ie.gasPrice) {
      if (Ie.maxFeePerGas && delete Ie.maxFeePerGas, Ie.maxPriorityFeePerGas && delete Ie.maxPriorityFeePerGas, !Ie.gasLimit)
        if (Ie.gas)
          Ie.gasLimit = addHexPrefix(Ie.gas);
        else {
          const Me = await this.getDefaultGasLimit(Ie);
          Me && (Ie.gasLimit = Me);
        }
      return Ie;
    }
    if (!Ie.gasLimit)
      if (Ie.gas)
        Ie.gasLimit = addHexPrefix(Ie.gas);
      else {
        const Me = await this.getDefaultGasLimit(Ie);
        Me && (Ie.gasLimit = Me);
      }
    const {
      gasPrice: Be,
      maxFeePerGas: Pe,
      maxPriorityFeePerGas: Te
    } = await this.getDefaultGasFees(Ie);
    return this.isEIP1559Compatible ? (Ie.gasPrice && !Ie.maxFeePerGas && !Ie.maxPriorityFeePerGas ? (Ie.maxFeePerGas = Ie.gasPrice, Ie.maxPriorityFeePerGas = bnLessThan(typeof Te == "string" ? stripHexPrefix(Te) : Te, typeof Ie.gasPrice == "string" ? stripHexPrefix(Ie.gasPrice) : Ie.gasPrice.toString()) ? addHexPrefix(Te) : addHexPrefix(Ie.gasPrice.toString())) : (Pe && !Ie.maxFeePerGas && (Ie.maxFeePerGas = addHexPrefix(Pe)), Te && !Ie.maxPriorityFeePerGas && (Ie.maxPriorityFeePerGas = addHexPrefix(Te)), Be && !Ie.maxFeePerGas && (Ie.maxFeePerGas = addHexPrefix(Be)), Ie.maxFeePerGas && !Ie.maxPriorityFeePerGas && (Ie.maxPriorityFeePerGas = Ie.maxFeePerGas)), delete Ie.gasPrice) : (delete Ie.maxPriorityFeePerGas, delete Ie.maxFeePerGas), Be && !Ie.gasPrice && !Ie.maxPriorityFeePerGas && !Ie.maxFeePerGas && (Ie.gasPrice = Be), Ie.type = Number.parseInt(this.isEIP1559Compatible ? TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : TRANSACTION_ENVELOPE_TYPES.LEGACY, 16), Ie.chainId = this.chainConfig.chainId, Ie;
  }
  async fetchEthGasPriceEstimate() {
    const t = await this.providerProxy.request({
      method: "eth_gasPrice",
      params: []
    });
    return {
      gasPrice: hexWEIToDecGWEI(t).toString()
    };
  }
  async fetchGasEstimatesViaEthFeeHistory() {
    const Ie = "latest", Be = [10, 50, 95], Pe = await this.providerProxy.request({
      method: "eth_feeHistory",
      params: [10, Ie, Be]
    }), Te = Pe.baseFeePerGas[Pe.baseFeePerGas.length - 1], Me = Pe.reward.reduce((Ue, je) => ({
      slow: Ue.slow.plus(new BigNumber(je[0], 16)),
      average: Ue.average.plus(new BigNumber(je[1], 16)),
      fast: Ue.fast.plus(new BigNumber(je[2], 16))
    }), {
      slow: new BigNumber(0),
      average: new BigNumber(0),
      fast: new BigNumber(0)
    });
    return {
      estimatedBaseFee: hexWEIToDecGWEI(Te).toString(),
      high: {
        maxWaitTimeEstimate: 3e4,
        minWaitTimeEstimate: 15e3,
        suggestedMaxFeePerGas: hexWEIToDecGWEI(Me.fast.plus(Te).toString(16)).toString(),
        suggestedMaxPriorityFeePerGas: hexWEIToDecGWEI(Me.fast.toString(16)).toString()
      },
      medium: {
        maxWaitTimeEstimate: 45e3,
        minWaitTimeEstimate: 15e3,
        suggestedMaxFeePerGas: hexWEIToDecGWEI(Me.average.plus(Te).toString(16)).toString(),
        suggestedMaxPriorityFeePerGas: hexWEIToDecGWEI(Me.average.toString(16)).toString()
      },
      low: {
        maxWaitTimeEstimate: 6e4,
        minWaitTimeEstimate: 15e3,
        suggestedMaxFeePerGas: hexWEIToDecGWEI(Me.slow.plus(Te).toString(16)).toString(),
        suggestedMaxPriorityFeePerGas: hexWEIToDecGWEI(Me.slow.toString(16)).toString()
      }
    };
  }
  async getEIP1559Compatibility() {
    const t = await this.providerProxy.request({
      method: "eth_getBlockByNumber",
      params: ["latest", !1]
    });
    return !!(t && t.baseFeePerGas !== void 0);
  }
  async fetchGasFeeEstimateData() {
    if (!this.chainConfig) throw new Error("Chain config not initialized");
    const t = this.chainConfig.chainId === "0x1", Ie = Number.parseInt(this.chainConfig.chainId, 16);
    let Be;
    try {
      if (this.isEIP1559Compatible) {
        let Pe;
        try {
          if (this.API_SUPPORTED_CHAINIDS.has(this.chainConfig.chainId))
            Pe = await fetchEip1159GasEstimates(EIP1559APIEndpoint.replace("<chain_id>", `${Ie}`));
          else
            throw new Error("Chain id not supported by api");
        } catch {
          Pe = await this.fetchGasEstimatesViaEthFeeHistory();
        }
        Be = {
          gasFeeEstimates: Pe,
          gasEstimateType: GAS_ESTIMATE_TYPES.FEE_MARKET
        };
      } else if (t)
        Be = {
          gasFeeEstimates: await fetchLegacyGasPriceEstimates(LegacyGasAPIEndpoint.replace("<chain_id>", `${Ie}`)),
          gasEstimateType: GAS_ESTIMATE_TYPES.LEGACY
        };
      else
        throw new Error("Main gas fee/price estimation failed. Use fallback");
    } catch {
      try {
        Be = {
          gasFeeEstimates: await this.fetchEthGasPriceEstimate(),
          gasEstimateType: GAS_ESTIMATE_TYPES.ETH_GASPRICE
        };
      } catch (Te) {
        throw new Error(`Gas fee/price estimation failed. Message: ${Te.message}`);
      }
    }
    return Be;
  }
  async getDefaultGasFees(t) {
    if (!this.isEIP1559Compatible && t.gasPrice || this.isEIP1559Compatible && t.maxFeePerGas && t.maxPriorityFeePerGas)
      return {};
    try {
      const {
        gasFeeEstimates: Be,
        gasEstimateType: Pe
      } = await this.fetchGasFeeEstimateData();
      if (this.isEIP1559Compatible && Pe === GAS_ESTIMATE_TYPES.FEE_MARKET) {
        const {
          medium: {
            suggestedMaxPriorityFeePerGas: Te,
            suggestedMaxFeePerGas: Me
          } = {}
        } = Be;
        if (Te && Me)
          return {
            maxFeePerGas: addHexPrefix(decGWEIToHexWEI(Me)),
            maxPriorityFeePerGas: addHexPrefix(decGWEIToHexWEI(Te))
          };
      } else {
        if (Pe === GAS_ESTIMATE_TYPES.LEGACY)
          return {
            gasPrice: addHexPrefix(decGWEIToHexWEI(Be.medium))
          };
        if (Pe === GAS_ESTIMATE_TYPES.ETH_GASPRICE)
          return {
            gasPrice: addHexPrefix(decGWEIToHexWEI(Be.gasPrice))
          };
      }
    } catch (Be) {
      loglevel.error(Be);
    }
    const {
      gasPrice: Ie
    } = await this.fetchEthGasPriceEstimate();
    return {
      gasPrice: addHexPrefix(decGWEIToHexWEI(Ie))
    };
  }
  async estimateTxGas(t) {
    const Ie = _objectSpread2({}, t);
    return delete Ie.gasPrice, delete Ie.maxFeePerGas, delete Ie.maxPriorityFeePerGas, await this.providerProxy.request({
      method: "eth_estimateGas",
      params: [Ie]
    });
  }
  async analyzeGasUsage(t) {
    const Ie = await this.providerProxy.request({
      method: "eth_getBlockByNumber",
      params: ["latest", !1]
    }), Be = hexToBn(Ie.gasLimit), Pe = BnMultiplyByFraction(Be, 19, 20);
    let Te = bnToHex(Pe);
    try {
      Te = await this.estimateTxGas(t);
    } catch (Me) {
      loglevel.warn(Me);
    }
    return {
      blockGasLimit: Ie.gasLimit,
      estimatedGasHex: Te
    };
  }
  addGasBuffer(t, Ie, Be = 1.5) {
    const Pe = hexToBn(t), Me = hexToBn(Ie).muln(0.9), Ue = Pe.muln(Be);
    return Pe.gt(Me) ? bnToHex(Pe) : Ue.lt(Me) ? bnToHex(Ue) : bnToHex(Me);
  }
  async determineTransactionCategory(t) {
    const {
      data: Ie,
      to: Be
    } = t;
    let Pe = "", Te;
    if (Ie && !Be)
      Te = TRANSACTION_TYPES.DEPLOY_CONTRACT;
    else {
      try {
        Pe = await this.providerProxy.request({
          method: "eth_getCode",
          params: [Be, "latest"]
        });
      } catch (Ue) {
        loglevel.warn(Ue);
      }
      Te = !Pe || Pe === "0x" || Pe === "0x0" ? TRANSACTION_TYPES.SENT_ETHER : TRANSACTION_TYPES.CONTRACT_INTERACTION;
    }
    return {
      transactionCategory: Te,
      code: Pe
    };
  }
  async getDefaultGasLimit(t) {
    const {
      transactionCategory: Ie
    } = await this.determineTransactionCategory(_objectSpread2({}, t));
    if (t.gas)
      return addHexPrefix(t.gas);
    if (t.to && Ie === TRANSACTION_TYPES.SENT_ETHER) {
      if (t.data)
        throw Error("TxGasUtil - Trying to call a function on a non-contract address");
      return addHexPrefix(21e3.toString(16));
    }
    const {
      blockGasLimit: Be,
      estimatedGasHex: Pe
    } = await this.analyzeGasUsage(t);
    return this.addGasBuffer(addHexPrefix(Pe), Be);
  }
}
let SignTypedDataVersion = /* @__PURE__ */ function(Ae) {
  return Ae.V1 = "V1", Ae.V3 = "V3", Ae.V4 = "V4", Ae;
}({});
function createAccountMiddleware({
  updatePrivatekey: Ae
}) {
  async function t(Ie, Be) {
    var Pe;
    const Te = (Pe = Ie.params) !== null && Pe !== void 0 && Pe.length ? Ie.params[0] : void 0;
    if (!(Te != null && Te.privateKey)) throw rpcErrors.invalidParams("Missing privateKey");
    Be.result = await Ae(Te);
  }
  return createScaffoldMiddleware({
    wallet_updateAccount: createAsyncMiddleware(t)
  });
}
async function signTx(Ae, t, Ie) {
  const {
    Transaction: Be
  } = await Promise.resolve().then(() => index$1), Pe = await Ie.formatTransaction(Ae), Te = Be.from(_objectSpread2(_objectSpread2({}, Pe), {}, {
    from: void 0
    // from is already calculated inside Transaction.from and is not allowed to be passed in
  })), Me = stripHexPrefix(Te.unsignedHash), Ue = await t(Buffer$3.from(Me, "hex"));
  let {
    v: je
  } = Ue;
  const {
    r: fn,
    s: Ve
  } = Ue;
  je > 1 && (je = je - 27);
  const vn = Te;
  return vn.signature = Signature$1.from({
    v: je,
    r: `0x${fn.toString("hex")}`,
    s: `0x${Ve.toString("hex")}`
  }), vn.serialized;
}
async function signMessage$1(Ae, t) {
  const Ie = stripHexPrefix(t), Be = await Ae(Buffer$3.from(Ie, "hex"));
  let Pe = Be.v;
  return Pe <= 1 && (Pe = Pe + 27), concatSig(Buffer$3.from(intToBytes(Pe)), Be.r, Be.s);
}
async function personalSign(Ae, t) {
  if (t == null)
    throw new Error("Missing data parameter");
  const Ie = isHexString$2(t) ? Buffer$3.from(stripHexPrefix(t), "hex") : Buffer$3.from(t), Be = hashMessage$2(Ie), Pe = Buffer$3.from(`Ethereum Signed Message:
${Ie.length}`, "utf-8"), Te = await Ae(Buffer$3.from(Be.slice(2), "hex"), Buffer$3.concat([Pe, Ie]));
  let Me = Te.v;
  return Me <= 1 && (Me = Me + 27), concatSig(Buffer$3.from(toBytes$3(Me)), Te.r, Te.s);
}
function validateVersion(Ae, t) {
  if (!Object.keys(SignTypedDataVersion).includes(Ae))
    throw new Error(`Invalid version: '${Ae}'`);
}
async function signTypedData$1(Ae, t, Ie) {
  if (validateVersion(Ie), t == null)
    throw new Error("Missing data parameter");
  const Be = typeof t == "string" ? JSON.parse(t) : t, {
    v: Pe,
    r: Te,
    s: Me
  } = await Ae(Buffer$3.from(TypedDataEncoder.hash(Be.domain, Be.types, Be.message).slice(2), "hex"));
  let Ue = Pe;
  return Ue <= 1 && (Ue = Ue + 27), concatSig(Buffer$3.from(toBytes$3(Ue)), Te, Me);
}
function getProviderHandlers({
  txFormatter: Ae,
  sign: t,
  getPublic: Ie,
  getProviderEngineProxy: Be
}) {
  return {
    getAccounts: async (Pe) => {
      const Te = await Ie();
      return [`0x${Buffer$3.from(publicToAddress(Te)).toString("hex")}`];
    },
    getPrivateKey: async (Pe) => {
      throw providerErrors.custom({
        message: "MPC Provider cannot return private key",
        code: 4902
      });
    },
    getPublicKey: async (Pe) => `0x${(await Ie()).toString("hex")}`,
    processTransaction: async (Pe, Te) => {
      const Me = Be();
      if (!Me) throw providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const Ue = await signTx(Pe, t, Ae);
      return await Me.request({
        method: "eth_sendRawTransaction",
        params: [Ue]
      });
    },
    processSignTransaction: async (Pe, Te) => {
      if (!Be()) throw providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      return await signTx(Pe, t, Ae);
    },
    processEthSignMessage: async (Pe, Te) => signMessage$1(t, Pe.data),
    processPersonalMessage: async (Pe, Te) => personalSign(t, Pe.data),
    processTypedMessageV4: async (Pe, Te) => {
      loglevel.debug("processTypedMessageV4", Pe);
      const Me = Be();
      if (!Me) throw providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const Ue = await Me.request({
        method: "eth_chainId"
      });
      await validateTypedSignMessageDataV4(Pe, Ue);
      const je = typeof Pe.data == "string" ? JSON.parse(Pe.data) : Pe.data;
      return signTypedData$1(t, je, SignTypedDataVersion.V4);
    }
  };
}
var _EthereumSigningProvider;
class EthereumSigningProvider extends BaseProvider {
  constructor({
    config: t,
    state: Ie
  }) {
    super({
      config: {
        chainConfig: _objectSpread2(_objectSpread2({}, t.chainConfig), {}, {
          chainNamespace: CHAIN_NAMESPACES.EIP155
        })
      },
      state: Ie
    }), _defineProperty(this, "PROVIDER_CHAIN_NAMESPACE", CHAIN_NAMESPACES.EIP155);
  }
  async enable() {
    if (!this.state.signMethods) throw providerErrors.custom({
      message: "signMethods are not found in state, plz pass it in constructor state param",
      code: 4902
    });
    return await this.setupProvider(this.state.signMethods), this._providerEngineProxy.request({
      method: "eth_accounts"
    });
  }
  async setupProvider({
    sign: t,
    getPublic: Ie
  }) {
    const {
      chainNamespace: Be
    } = this.config.chainConfig;
    if (Be !== this.PROVIDER_CHAIN_NAMESPACE) throw WalletInitializationError.incompatibleChainNameSpace("Invalid chain namespace");
    const Pe = new TransactionFormatter({
      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)
    }), Te = getProviderHandlers({
      txFormatter: Pe,
      sign: t,
      getPublic: Ie,
      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)
    }), Me = createEthMiddleware(Te), Ue = this.getChainSwitchMiddleware(), je = new JRPCEngine(), {
      networkMiddleware: fn
    } = createJsonRpcClient(this.config.chainConfig);
    je.push(Me), je.push(Ue), je.push(this.getAccountMiddleware()), je.push(fn);
    const Ve = providerFromEngine(je);
    this.updateProviderEngineProxy(Ve), await Pe.init(), await this.lookupNetwork(), this.state.signMethods = {
      sign: t,
      getPublic: Ie
    };
  }
  async updateAccount(t) {
    if (!this._providerEngineProxy) throw providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const Ie = this.state.signMethods;
    if (!Ie)
      throw providerErrors.custom({
        message: "signing methods are unavailable ",
        code: 4092
      });
    const Be = (await Ie.getPublic()).toString("hex"), Pe = (await t.signMethods.getPublic()).toString("hex");
    if (Be !== Pe) {
      await this.setupProvider(t.signMethods);
      const Te = await this._providerEngineProxy.request({
        method: "eth_accounts"
      });
      this.emit("accountsChanged", Te);
    }
  }
  async switchChain(t) {
    if (!this._providerEngineProxy) throw providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const Ie = this.getChainConfig(t.chainId);
    if (this.update({
      chainId: "loading"
    }), this.configure({
      chainConfig: Ie
    }), !this.state.signMethods)
      throw providerErrors.custom({
        message: "sign methods are undefined",
        code: 4902
      });
    await this.setupProvider(this.state.signMethods);
  }
  async lookupNetwork() {
    if (!this._providerEngineProxy) throw providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const {
      chainId: t
    } = this.config.chainConfig;
    if (!t) throw rpcErrors.invalidParams("chainId is required while lookupNetwork");
    const Ie = await this._providerEngineProxy.request({
      method: "net_version",
      params: []
    }), Be = isHexString$2(Ie) ? parseInt(Ie, 16) : parseInt(Ie, 10);
    if (parseInt(t, 16) !== Be) throw providerErrors.chainDisconnected(`Invalid network, net_version is: ${Ie}`);
    return this.state.chainId !== t && (this.emit("chainChanged", t), this.emit("connect", {
      chainId: t
    })), this.update({
      chainId: t
    }), Ie;
  }
  getChainSwitchMiddleware() {
    return createChainSwitchMiddleware({
      addChain: async (Be) => {
        const {
          chainId: Pe,
          chainName: Te,
          rpcUrls: Me,
          blockExplorerUrls: Ue,
          nativeCurrency: je,
          iconUrls: fn
        } = Be;
        this.addChain({
          chainNamespace: CHAIN_NAMESPACES.EIP155,
          chainId: Pe,
          ticker: (je == null ? void 0 : je.symbol) || "ETH",
          tickerName: (je == null ? void 0 : je.name) || "Ether",
          displayName: Te,
          rpcTarget: Me[0],
          blockExplorerUrl: (Ue == null ? void 0 : Ue[0]) || "",
          decimals: (je == null ? void 0 : je.decimals) || 18,
          logo: (fn == null ? void 0 : fn[0]) || "https://images.toruswallet.io/eth.svg"
        });
      },
      switchChain: async (Be) => {
        const {
          chainId: Pe
        } = Be;
        await this.switchChain({
          chainId: Pe
        });
      }
    });
  }
  getAccountMiddleware() {
    return createAccountMiddleware({
      updateSignMethods: async (Ie) => {
        await this.updateAccount(Ie);
      }
    });
  }
}
_EthereumSigningProvider = EthereumSigningProvider;
_defineProperty(EthereumSigningProvider, "getProviderInstance", async (Ae) => {
  const t = new _EthereumSigningProvider({
    config: {
      chainConfig: Ae.chainConfig
    }
  });
  return await t.setupProvider(Ae.signMethods), t;
});
class FilterTypeNotSupportedError extends BaseError$1 {
  constructor(t) {
    super(`Filter type "${t}" is not supported.`, {
      name: "FilterTypeNotSupportedError"
    });
  }
}
const docsPath$4 = "/docs/contract/encodeEventTopics";
function encodeEventTopics(Ae) {
  var je;
  const { abi: t, eventName: Ie, args: Be } = Ae;
  let Pe = t[0];
  if (Ie) {
    const fn = getAbiItem({ abi: t, name: Ie });
    if (!fn)
      throw new AbiEventNotFoundError(Ie, { docsPath: docsPath$4 });
    Pe = fn;
  }
  if (Pe.type !== "event")
    throw new AbiEventNotFoundError(void 0, { docsPath: docsPath$4 });
  const Te = formatAbiItem$1(Pe), Me = toEventSelector(Te);
  let Ue = [];
  if (Be && "inputs" in Pe) {
    const fn = (je = Pe.inputs) == null ? void 0 : je.filter((vn) => "indexed" in vn && vn.indexed), Ve = Array.isArray(Be) ? Be : Object.values(Be).length > 0 ? (fn == null ? void 0 : fn.map((vn) => Be[vn.name])) ?? [] : [];
    Ve.length > 0 && (Ue = (fn == null ? void 0 : fn.map((vn, En) => Array.isArray(Ve[En]) ? Ve[En].map((fi, bi) => encodeArg({ param: vn, value: Ve[En][bi] })) : Ve[En] ? encodeArg({ param: vn, value: Ve[En] }) : null)) ?? []);
  }
  return [Me, ...Ue];
}
function encodeArg({ param: Ae, value: t }) {
  if (Ae.type === "string" || Ae.type === "bytes")
    return keccak256$2(toBytes$2(t));
  if (Ae.type === "tuple" || Ae.type.match(/^(.*)\[(\d+)?\]$/))
    throw new FilterTypeNotSupportedError(Ae.type);
  return encodeAbiParameters([Ae], [t]);
}
function createFilterRequestScope(Ae, { method: t }) {
  var Be, Pe;
  const Ie = {};
  return Ae.transport.type === "fallback" && ((Pe = (Be = Ae.transport).onResponse) == null || Pe.call(Be, ({ method: Te, response: Me, status: Ue, transport: je }) => {
    Ue === "success" && t === Te && (Ie[Me] = je.request);
  })), (Te) => Ie[Te] || Ae.request;
}
async function createContractEventFilter(Ae, t) {
  const { address: Ie, abi: Be, args: Pe, eventName: Te, fromBlock: Me, strict: Ue, toBlock: je } = t, fn = createFilterRequestScope(Ae, {
    method: "eth_newFilter"
  }), Ve = Te ? encodeEventTopics({
    abi: Be,
    args: Pe,
    eventName: Te
  }) : void 0, vn = await Ae.request({
    method: "eth_newFilter",
    params: [
      {
        address: Ie,
        fromBlock: typeof Me == "bigint" ? numberToHex(Me) : Me,
        toBlock: typeof je == "bigint" ? numberToHex(je) : je,
        topics: Ve
      }
    ]
  });
  return {
    abi: Be,
    args: Pe,
    eventName: Te,
    id: vn,
    request: fn(vn),
    strict: !!Ue,
    type: "event"
  };
}
const docsPath$3 = "/docs/contract/encodeFunctionData";
function prepareEncodeFunctionData(Ae) {
  const { abi: t, args: Ie, functionName: Be } = Ae;
  let Pe = t[0];
  if (Be) {
    const Te = getAbiItem({
      abi: t,
      args: Ie,
      name: Be
    });
    if (!Te)
      throw new AbiFunctionNotFoundError(Be, { docsPath: docsPath$3 });
    Pe = Te;
  }
  if (Pe.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath$3 });
  return {
    abi: [Pe],
    functionName: toFunctionSelector(formatAbiItem$1(Pe))
  };
}
function encodeFunctionData(Ae) {
  const { args: t } = Ae, { abi: Ie, functionName: Be } = (() => {
    var Ue;
    return Ae.abi.length === 1 && ((Ue = Ae.functionName) != null && Ue.startsWith("0x")) ? Ae : prepareEncodeFunctionData(Ae);
  })(), Pe = Ie[0], Te = Be, Me = "inputs" in Pe && Pe.inputs ? encodeAbiParameters(Pe.inputs, t ?? []) : void 0;
  return concatHex([Te, Me ?? "0x"]);
}
const EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(Ae, { abi: t, address: Ie, args: Be, docsPath: Pe, functionName: Te, sender: Me }) {
  const { code: Ue, data: je, message: fn, shortMessage: Ve } = Ae instanceof RawContractError ? Ae : Ae instanceof BaseError$1 ? Ae.walk((En) => "data" in En) || Ae.walk() : {}, vn = Ae instanceof AbiDecodingZeroDataError ? new ContractFunctionZeroDataError({ functionName: Te }) : [EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(Ue) && (je || fn || Ve) ? new ContractFunctionRevertedError({
    abi: t,
    data: typeof je == "object" ? je.data : je,
    functionName: Te,
    message: Ve ?? fn
  }) : Ae;
  return new ContractFunctionExecutionError(vn, {
    abi: t,
    args: Be,
    contractAddress: Ie,
    docsPath: Pe,
    functionName: Te,
    sender: Me
  });
}
async function estimateContractGas(Ae, t) {
  const { abi: Ie, address: Be, args: Pe, functionName: Te, ...Me } = t, Ue = encodeFunctionData({
    abi: Ie,
    args: Pe,
    functionName: Te
  });
  try {
    return await getAction(Ae, estimateGas, "estimateGas")({
      data: Ue,
      to: Be,
      ...Me
    });
  } catch (je) {
    const fn = Me.account ? parseAccount(Me.account) : void 0;
    throw getContractError(je, {
      abi: Ie,
      address: Be,
      args: Pe,
      docsPath: "/docs/contract/estimateContractGas",
      functionName: Te,
      sender: fn == null ? void 0 : fn.address
    });
  }
}
function isAddressEqual(Ae, t) {
  if (!isAddress(Ae, { strict: !1 }))
    throw new InvalidAddressError({ address: Ae });
  if (!isAddress(t, { strict: !1 }))
    throw new InvalidAddressError({ address: t });
  return Ae.toLowerCase() === t.toLowerCase();
}
const docsPath$2 = "/docs/contract/decodeEventLog";
function decodeEventLog(Ae) {
  const { abi: t, data: Ie, strict: Be, topics: Pe } = Ae, Te = Be ?? !0, [Me, ...Ue] = Pe;
  if (!Me)
    throw new AbiEventSignatureEmptyTopicsError({ docsPath: docsPath$2 });
  const je = t.length === 1 ? t[0] : t.find((mi) => mi.type === "event" && Me === toEventSelector(formatAbiItem$1(mi)));
  if (!(je && "name" in je) || je.type !== "event")
    throw new AbiEventSignatureNotFoundError(Me, { docsPath: docsPath$2 });
  const { name: fn, inputs: Ve } = je, vn = Ve == null ? void 0 : Ve.some((mi) => !("name" in mi && mi.name));
  let En = vn ? [] : {};
  const fi = Ve.filter((mi) => "indexed" in mi && mi.indexed);
  for (let mi = 0; mi < fi.length; mi++) {
    const _i = fi[mi], Ei = Ue[mi];
    if (!Ei)
      throw new DecodeLogTopicsMismatch({
        abiItem: je,
        param: _i
      });
    En[vn ? mi : _i.name || mi] = decodeTopic({ param: _i, value: Ei });
  }
  const bi = Ve.filter((mi) => !("indexed" in mi && mi.indexed));
  if (bi.length > 0) {
    if (Ie && Ie !== "0x")
      try {
        const mi = decodeAbiParameters(bi, Ie);
        if (mi)
          if (vn)
            En = [...En, ...mi];
          else
            for (let _i = 0; _i < bi.length; _i++)
              En[bi[_i].name] = mi[_i];
      } catch (mi) {
        if (Te)
          throw mi instanceof AbiDecodingDataSizeTooSmallError || mi instanceof PositionOutOfBoundsError ? new DecodeLogDataMismatch({
            abiItem: je,
            data: Ie,
            params: bi,
            size: size$1(Ie)
          }) : mi;
      }
    else if (Te)
      throw new DecodeLogDataMismatch({
        abiItem: je,
        data: "0x",
        params: bi,
        size: 0
      });
  }
  return {
    eventName: fn,
    args: Object.values(En).length > 0 ? En : void 0
  };
}
function decodeTopic({ param: Ae, value: t }) {
  return Ae.type === "string" || Ae.type === "bytes" || Ae.type === "tuple" || Ae.type.match(/^(.*)\[(\d+)?\]$/) ? t : (decodeAbiParameters([Ae], t) || [])[0];
}
function parseEventLogs(Ae) {
  const { abi: t, args: Ie, logs: Be, strict: Pe = !0 } = Ae, Te = (() => {
    if (Ae.eventName)
      return Array.isArray(Ae.eventName) ? Ae.eventName : [Ae.eventName];
  })();
  return Be.map((Me) => {
    var Ue;
    try {
      const je = t.find((Ve) => Ve.type === "event" && Me.topics[0] === toEventSelector(Ve));
      if (!je)
        return null;
      const fn = decodeEventLog({
        ...Me,
        abi: [je],
        strict: Pe
      });
      return Te && !Te.includes(fn.eventName) || !includesArgs({
        args: fn.args,
        inputs: je.inputs,
        matchArgs: Ie
      }) ? null : { ...fn, ...Me };
    } catch (je) {
      let fn, Ve;
      if (je instanceof AbiEventSignatureNotFoundError)
        return null;
      if (je instanceof DecodeLogDataMismatch || je instanceof DecodeLogTopicsMismatch) {
        if (Pe)
          return null;
        fn = je.abiItem.name, Ve = (Ue = je.abiItem.inputs) == null ? void 0 : Ue.some((vn) => !("name" in vn && vn.name));
      }
      return { ...Me, args: Ve ? [] : {}, eventName: fn };
    }
  }).filter(Boolean);
}
function includesArgs(Ae) {
  const { args: t, inputs: Ie, matchArgs: Be } = Ae;
  if (!Be)
    return !0;
  if (!t)
    return !1;
  function Pe(Te, Me, Ue) {
    try {
      return Te.type === "address" ? isAddressEqual(Me, Ue) : Te.type === "string" || Te.type === "bytes" ? keccak256$2(toBytes$2(Me)) === Ue : Me === Ue;
    } catch {
      return !1;
    }
  }
  return Array.isArray(t) && Array.isArray(Be) ? Be.every((Te, Me) => {
    if (Te == null)
      return !0;
    const Ue = Ie[Me];
    return Ue ? (Array.isArray(Te) ? Te : [Te]).some((fn) => Pe(Ue, fn, t[Me])) : !1;
  }) : typeof t == "object" && !Array.isArray(t) && typeof Be == "object" && !Array.isArray(Be) ? Object.entries(Be).every(([Te, Me]) => {
    if (Me == null)
      return !0;
    const Ue = Ie.find((fn) => fn.name === Te);
    return Ue ? (Array.isArray(Me) ? Me : [Me]).some((fn) => Pe(Ue, fn, t[Te])) : !1;
  }) : !1;
}
async function getLogs(Ae, { address: t, blockHash: Ie, fromBlock: Be, toBlock: Pe, event: Te, events: Me, args: Ue, strict: je } = {}) {
  const fn = je ?? !1, Ve = Me ?? (Te ? [Te] : void 0);
  let vn = [];
  Ve && (vn = [Ve.flatMap((mi) => encodeEventTopics({
    abi: [mi],
    eventName: mi.name,
    args: Me ? void 0 : Ue
  }))], Te && (vn = vn[0]));
  let En;
  Ie ? En = await Ae.request({
    method: "eth_getLogs",
    params: [{ address: t, topics: vn, blockHash: Ie }]
  }) : En = await Ae.request({
    method: "eth_getLogs",
    params: [
      {
        address: t,
        topics: vn,
        fromBlock: typeof Be == "bigint" ? numberToHex(Be) : Be,
        toBlock: typeof Pe == "bigint" ? numberToHex(Pe) : Pe
      }
    ]
  });
  const fi = En.map((bi) => formatLog(bi));
  return Ve ? parseEventLogs({
    abi: Ve,
    args: Ue,
    logs: fi,
    strict: fn
  }) : fi;
}
async function getContractEvents(Ae, t) {
  const { abi: Ie, address: Be, args: Pe, blockHash: Te, eventName: Me, fromBlock: Ue, toBlock: je, strict: fn } = t, Ve = Me ? getAbiItem({ abi: Ie, name: Me }) : void 0, vn = Ve ? void 0 : Ie.filter((En) => En.type === "event");
  return getAction(Ae, getLogs, "getLogs")({
    address: Be,
    args: Pe,
    blockHash: Te,
    event: Ve,
    events: vn,
    fromBlock: Ue,
    toBlock: je,
    strict: fn
  });
}
const docsPath$1 = "/docs/contract/decodeFunctionResult";
function decodeFunctionResult(Ae) {
  const { abi: t, args: Ie, functionName: Be, data: Pe } = Ae;
  let Te = t[0];
  if (Be) {
    const Ue = getAbiItem({ abi: t, args: Ie, name: Be });
    if (!Ue)
      throw new AbiFunctionNotFoundError(Be, { docsPath: docsPath$1 });
    Te = Ue;
  }
  if (Te.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath$1 });
  if (!Te.outputs)
    throw new AbiFunctionOutputsNotFoundError(Te.name, { docsPath: docsPath$1 });
  const Me = decodeAbiParameters(Te.outputs, Pe);
  if (Me && Me.length > 1)
    return Me;
  if (Me && Me.length === 1)
    return Me[0];
}
const multicall3Abi = [
  {
    inputs: [
      {
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "allowFailure",
            type: "bool"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            name: "success",
            type: "bool"
          },
          {
            name: "returnData",
            type: "bytes"
          }
        ],
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
], universalResolverErrors = [
  {
    inputs: [],
    name: "ResolverNotFound",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverWildcardNotSupported",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverNotContract",
    type: "error"
  },
  {
    inputs: [
      {
        name: "returnData",
        type: "bytes"
      }
    ],
    name: "ResolverError",
    type: "error"
  },
  {
    inputs: [
      {
        components: [
          {
            name: "status",
            type: "uint16"
          },
          {
            name: "message",
            type: "string"
          }
        ],
        name: "errors",
        type: "tuple[]"
      }
    ],
    name: "HttpError",
    type: "error"
  }
], universalResolverResolveAbi = [
  ...universalResolverErrors,
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  },
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" },
      { name: "gateways", type: "string[]" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  }
], universalResolverReverseAbi = [
  ...universalResolverErrors,
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "bytes", name: "reverseName" }],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  },
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "bytes", name: "reverseName" },
      { type: "string[]", name: "gateways" }
    ],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  }
], textResolverAbi = [
  {
    name: "text",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "key", type: "string" }
    ],
    outputs: [{ name: "", type: "string" }]
  }
], addressResolverAbi = [
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [{ name: "name", type: "bytes32" }],
    outputs: [{ name: "", type: "address" }]
  },
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "coinType", type: "uint256" }
    ],
    outputs: [{ name: "", type: "bytes" }]
  }
], universalSignatureValidatorAbi = [
  {
    inputs: [
      {
        name: "_signer",
        type: "address"
      },
      {
        name: "_hash",
        type: "bytes32"
      },
      {
        name: "_signature",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        name: "_signer",
        type: "address"
      },
      {
        name: "_hash",
        type: "bytes32"
      },
      {
        name: "_signature",
        type: "bytes"
      }
    ],
    outputs: [
      {
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function",
    name: "isValidSig"
  }
], aggregate3Signature = "0x82ad56cb", deploylessCallViaBytecodeBytecode = "0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe", deploylessCallViaFactoryBytecode = "0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe", universalSignatureValidatorByteCode = "0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572", docsPath = "/docs/contract/encodeDeployData";
function encodeDeployData(Ae) {
  const { abi: t, args: Ie, bytecode: Be } = Ae;
  if (!Ie || Ie.length === 0)
    return Be;
  const Pe = t.find((Me) => "type" in Me && Me.type === "constructor");
  if (!Pe)
    throw new AbiConstructorNotFoundError({ docsPath });
  if (!("inputs" in Pe))
    throw new AbiConstructorParamsNotFoundError({ docsPath });
  if (!Pe.inputs || Pe.inputs.length === 0)
    throw new AbiConstructorParamsNotFoundError({ docsPath });
  const Te = encodeAbiParameters(Pe.inputs, Ie);
  return concatHex([Be, Te]);
}
const schedulerCache = /* @__PURE__ */ new Map();
function createBatchScheduler({ fn: Ae, id: t, shouldSplitBatch: Ie, wait: Be = 0, sort: Pe }) {
  const Te = async () => {
    const Ve = je();
    Me();
    const vn = Ve.map(({ args: En }) => En);
    vn.length !== 0 && Ae(vn).then((En) => {
      var fi;
      Pe && Array.isArray(En) && En.sort(Pe);
      for (let bi = 0; bi < Ve.length; bi++) {
        const { pendingPromise: mi } = Ve[bi];
        (fi = mi.resolve) == null || fi.call(mi, [En[bi], En]);
      }
    }).catch((En) => {
      var fi;
      for (let bi = 0; bi < Ve.length; bi++) {
        const { pendingPromise: mi } = Ve[bi];
        (fi = mi.reject) == null || fi.call(mi, En);
      }
    });
  }, Me = () => schedulerCache.delete(t), Ue = () => je().map(({ args: Ve }) => Ve), je = () => schedulerCache.get(t) || [], fn = (Ve) => schedulerCache.set(t, [...je(), Ve]);
  return {
    flush: Me,
    async schedule(Ve) {
      const vn = {}, En = new Promise((mi, _i) => {
        vn.resolve = mi, vn.reject = _i;
      });
      return (Ie == null ? void 0 : Ie([...Ue(), Ve])) && Te(), je().length > 0 ? (fn({ args: Ve, pendingPromise: vn }), En) : (fn({ args: Ve, pendingPromise: vn }), setTimeout(Te, Be), En);
    }
  };
}
async function call(Ae, t) {
  var zi, xi, $i, vi;
  const { account: Ie = Ae.account, batch: Be = !!((zi = Ae.batch) != null && zi.multicall), blockNumber: Pe, blockTag: Te = "latest", accessList: Me, blobs: Ue, code: je, data: fn, factory: Ve, factoryData: vn, gas: En, gasPrice: fi, maxFeePerBlobGas: bi, maxFeePerGas: mi, maxPriorityFeePerGas: _i, nonce: Ei, to: Si, value: Mi, stateOverride: Oi, ...Fi } = t, Ui = Ie ? parseAccount(Ie) : void 0;
  if (je && (Ve || vn))
    throw new BaseError$1("Cannot provide both `code` & `factory`/`factoryData` as parameters.");
  if (je && Si)
    throw new BaseError$1("Cannot provide both `code` & `to` as parameters.");
  const Pi = je && fn, Bi = Ve && vn && Si && fn, ji = Pi || Bi, Zi = Pi ? toDeploylessCallViaBytecodeData({
    code: je,
    data: fn
  }) : Bi ? toDeploylessCallViaFactoryData({
    data: fn,
    factory: Ve,
    factoryData: vn,
    to: Si
  }) : fn;
  try {
    assertRequest(t);
    const Ai = (Pe ? numberToHex(Pe) : void 0) || Te, Ri = serializeStateOverride(Oi), Ti = (vi = ($i = (xi = Ae.chain) == null ? void 0 : xi.formatters) == null ? void 0 : $i.transactionRequest) == null ? void 0 : vi.format, Ii = (Ti || formatTransactionRequest)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(Fi, { format: Ti }),
      from: Ui == null ? void 0 : Ui.address,
      accessList: Me,
      blobs: Ue,
      data: Zi,
      gas: En,
      gasPrice: fi,
      maxFeePerBlobGas: bi,
      maxFeePerGas: mi,
      maxPriorityFeePerGas: _i,
      nonce: Ei,
      to: ji ? void 0 : Si,
      value: Mi
    });
    if (Be && shouldPerformMulticall({ request: Ii }) && !Ri)
      try {
        return await scheduleMulticall(Ae, {
          ...Ii,
          blockNumber: Pe,
          blockTag: Te
        });
      } catch (Ni) {
        if (!(Ni instanceof ClientChainNotConfiguredError) && !(Ni instanceof ChainDoesNotSupportContract))
          throw Ni;
      }
    const Li = await Ae.request({
      method: "eth_call",
      params: Ri ? [
        Ii,
        Ai,
        Ri
      ] : [Ii, Ai]
    });
    return Li === "0x" ? { data: void 0 } : { data: Li };
  } catch (wi) {
    const Ai = getRevertErrorData(wi), { offchainLookup: Ri, offchainLookupSignature: Ti } = await Promise.resolve().then(() => ccip);
    if (Ae.ccipRead !== !1 && (Ai == null ? void 0 : Ai.slice(0, 10)) === Ti && Si)
      return { data: await Ri(Ae, { data: Ai, to: Si }) };
    throw ji && (Ai == null ? void 0 : Ai.slice(0, 10)) === "0x101bb98d" ? new CounterfactualDeploymentFailedError({ factory: Ve }) : getCallError(wi, {
      ...t,
      account: Ui,
      chain: Ae.chain
    });
  }
}
function shouldPerformMulticall({ request: Ae }) {
  const { data: t, to: Ie, ...Be } = Ae;
  return !(!t || t.startsWith(aggregate3Signature) || !Ie || Object.values(Be).filter((Pe) => typeof Pe < "u").length > 0);
}
async function scheduleMulticall(Ae, t) {
  var mi;
  const { batchSize: Ie = 1024, wait: Be = 0 } = typeof ((mi = Ae.batch) == null ? void 0 : mi.multicall) == "object" ? Ae.batch.multicall : {}, { blockNumber: Pe, blockTag: Te = "latest", data: Me, multicallAddress: Ue, to: je } = t;
  let fn = Ue;
  if (!fn) {
    if (!Ae.chain)
      throw new ClientChainNotConfiguredError();
    fn = getChainContractAddress({
      blockNumber: Pe,
      chain: Ae.chain,
      contract: "multicall3"
    });
  }
  const vn = (Pe ? numberToHex(Pe) : void 0) || Te, { schedule: En } = createBatchScheduler({
    id: `${Ae.uid}.${vn}`,
    wait: Be,
    shouldSplitBatch(_i) {
      return _i.reduce((Si, { data: Mi }) => Si + (Mi.length - 2), 0) > Ie * 2;
    },
    fn: async (_i) => {
      const Ei = _i.map((Oi) => ({
        allowFailure: !0,
        callData: Oi.data,
        target: Oi.to
      })), Si = encodeFunctionData({
        abi: multicall3Abi,
        args: [Ei],
        functionName: "aggregate3"
      }), Mi = await Ae.request({
        method: "eth_call",
        params: [
          {
            data: Si,
            to: fn
          },
          vn
        ]
      });
      return decodeFunctionResult({
        abi: multicall3Abi,
        args: [Ei],
        functionName: "aggregate3",
        data: Mi || "0x"
      });
    }
  }), [{ returnData: fi, success: bi }] = await En({ data: Me, to: je });
  if (!bi)
    throw new RawContractError({ data: fi });
  return fi === "0x" ? { data: void 0 } : { data: fi };
}
function toDeploylessCallViaBytecodeData(Ae) {
  const { code: t, data: Ie } = Ae;
  return encodeDeployData({
    abi: parseAbi(["constructor(bytes, bytes)"]),
    bytecode: deploylessCallViaBytecodeBytecode,
    args: [t, Ie]
  });
}
function toDeploylessCallViaFactoryData(Ae) {
  const { data: t, factory: Ie, factoryData: Be, to: Pe } = Ae;
  return encodeDeployData({
    abi: parseAbi(["constructor(address, bytes, address, bytes)"]),
    bytecode: deploylessCallViaFactoryBytecode,
    args: [Pe, t, Ie, Be]
  });
}
function getRevertErrorData(Ae) {
  var Ie;
  if (!(Ae instanceof BaseError$1))
    return;
  const t = Ae.walk();
  return typeof (t == null ? void 0 : t.data) == "object" ? (Ie = t.data) == null ? void 0 : Ie.data : t.data;
}
async function readContract(Ae, t) {
  const { abi: Ie, address: Be, args: Pe, functionName: Te, ...Me } = t, Ue = encodeFunctionData({
    abi: Ie,
    args: Pe,
    functionName: Te
  });
  try {
    const { data: je } = await getAction(Ae, call, "call")({
      ...Me,
      data: Ue,
      to: Be
    });
    return decodeFunctionResult({
      abi: Ie,
      args: Pe,
      functionName: Te,
      data: je || "0x"
    });
  } catch (je) {
    throw getContractError(je, {
      abi: Ie,
      address: Be,
      args: Pe,
      docsPath: "/docs/contract/readContract",
      functionName: Te
    });
  }
}
async function simulateContract(Ae, t) {
  const { abi: Ie, address: Be, args: Pe, dataSuffix: Te, functionName: Me, ...Ue } = t, je = Ue.account ? parseAccount(Ue.account) : Ae.account, fn = encodeFunctionData({ abi: Ie, args: Pe, functionName: Me });
  try {
    const { data: Ve } = await getAction(Ae, call, "call")({
      batch: !1,
      data: `${fn}${Te ? Te.replace("0x", "") : ""}`,
      to: Be,
      ...Ue,
      account: je
    }), vn = decodeFunctionResult({
      abi: Ie,
      args: Pe,
      functionName: Me,
      data: Ve || "0x"
    }), En = Ie.filter((fi) => "name" in fi && fi.name === t.functionName);
    return {
      result: vn,
      request: {
        abi: En,
        address: Be,
        args: Pe,
        dataSuffix: Te,
        functionName: Me,
        ...Ue,
        account: je
      }
    };
  } catch (Ve) {
    throw getContractError(Ve, {
      abi: Ie,
      address: Be,
      args: Pe,
      docsPath: "/docs/contract/simulateContract",
      functionName: Me,
      sender: je == null ? void 0 : je.address
    });
  }
}
const listenersCache = /* @__PURE__ */ new Map(), cleanupCache = /* @__PURE__ */ new Map();
let callbackCount = 0;
function observe(Ae, t, Ie) {
  const Be = ++callbackCount, Pe = () => listenersCache.get(Ae) || [], Te = () => {
    const Ve = Pe();
    listenersCache.set(Ae, Ve.filter((vn) => vn.id !== Be));
  }, Me = () => {
    const Ve = cleanupCache.get(Ae);
    Pe().length === 1 && Ve && Ve(), Te();
  }, Ue = Pe();
  if (listenersCache.set(Ae, [
    ...Ue,
    { id: Be, fns: t }
  ]), Ue && Ue.length > 0)
    return Me;
  const je = {};
  for (const Ve in t)
    je[Ve] = (...vn) => {
      var fi, bi;
      const En = Pe();
      if (En.length !== 0)
        for (const mi of En)
          (bi = (fi = mi.fns)[Ve]) == null || bi.call(fi, ...vn);
    };
  const fn = Ie(je);
  return typeof fn == "function" && cleanupCache.set(Ae, fn), Me;
}
async function wait(Ae) {
  return new Promise((t) => setTimeout(t, Ae));
}
function poll(Ae, { emitOnBegin: t, initialWaitTime: Ie, interval: Be }) {
  let Pe = !0;
  const Te = () => Pe = !1;
  return (async () => {
    let Ue;
    t && (Ue = await Ae({ unpoll: Te }));
    const je = await (Ie == null ? void 0 : Ie(Ue)) ?? Be;
    await wait(je);
    const fn = async () => {
      Pe && (await Ae({ unpoll: Te }), await wait(Be), fn());
    };
    fn();
  })(), Te;
}
const promiseCache$1 = /* @__PURE__ */ new Map(), responseCache = /* @__PURE__ */ new Map();
function getCache(Ae) {
  const t = (Pe, Te) => ({
    clear: () => Te.delete(Pe),
    get: () => Te.get(Pe),
    set: (Me) => Te.set(Pe, Me)
  }), Ie = t(Ae, promiseCache$1), Be = t(Ae, responseCache);
  return {
    clear: () => {
      Ie.clear(), Be.clear();
    },
    promise: Ie,
    response: Be
  };
}
async function withCache(Ae, { cacheKey: t, cacheTime: Ie = Number.POSITIVE_INFINITY }) {
  const Be = getCache(t), Pe = Be.response.get();
  if (Pe && Ie > 0 && (/* @__PURE__ */ new Date()).getTime() - Pe.created.getTime() < Ie)
    return Pe.data;
  let Te = Be.promise.get();
  Te || (Te = Ae(), Be.promise.set(Te));
  try {
    const Me = await Te;
    return Be.response.set({ created: /* @__PURE__ */ new Date(), data: Me }), Me;
  } finally {
    Be.promise.clear();
  }
}
const cacheKey = (Ae) => `blockNumber.${Ae}`;
async function getBlockNumber(Ae, { cacheTime: t = Ae.cacheTime } = {}) {
  const Ie = await withCache(() => Ae.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(Ae.uid), cacheTime: t });
  return BigInt(Ie);
}
async function getFilterChanges(Ae, { filter: t }) {
  const Ie = "strict" in t && t.strict, Be = await t.request({
    method: "eth_getFilterChanges",
    params: [t.id]
  });
  if (typeof Be[0] == "string")
    return Be;
  const Pe = Be.map((Te) => formatLog(Te));
  return !("abi" in t) || !t.abi ? Pe : parseEventLogs({
    abi: t.abi,
    logs: Pe,
    strict: Ie
  });
}
async function uninstallFilter(Ae, { filter: t }) {
  return t.request({
    method: "eth_uninstallFilter",
    params: [t.id]
  });
}
function watchContractEvent(Ae, t) {
  const { abi: Ie, address: Be, args: Pe, batch: Te = !0, eventName: Me, fromBlock: Ue, onError: je, onLogs: fn, poll: Ve, pollingInterval: vn = Ae.pollingInterval, strict: En } = t;
  return (typeof Ve < "u" ? Ve : typeof Ue == "bigint" ? !0 : !(Ae.transport.type === "webSocket" || Ae.transport.type === "fallback" && Ae.transport.transports[0].config.type === "webSocket")) ? (() => {
    const _i = En ?? !1, Ei = stringify$2([
      "watchContractEvent",
      Be,
      Pe,
      Te,
      Ae.uid,
      Me,
      vn,
      _i,
      Ue
    ]);
    return observe(Ei, { onLogs: fn, onError: je }, (Si) => {
      let Mi;
      Ue !== void 0 && (Mi = Ue - 1n);
      let Oi, Fi = !1;
      const Ui = poll(async () => {
        var Pi;
        if (!Fi) {
          try {
            Oi = await getAction(Ae, createContractEventFilter, "createContractEventFilter")({
              abi: Ie,
              address: Be,
              args: Pe,
              eventName: Me,
              strict: _i,
              fromBlock: Ue
            });
          } catch {
          }
          Fi = !0;
          return;
        }
        try {
          let Bi;
          if (Oi)
            Bi = await getAction(Ae, getFilterChanges, "getFilterChanges")({ filter: Oi });
          else {
            const ji = await getAction(Ae, getBlockNumber, "getBlockNumber")({});
            Mi && Mi < ji ? Bi = await getAction(Ae, getContractEvents, "getContractEvents")({
              abi: Ie,
              address: Be,
              args: Pe,
              eventName: Me,
              fromBlock: Mi + 1n,
              toBlock: ji,
              strict: _i
            }) : Bi = [], Mi = ji;
          }
          if (Bi.length === 0)
            return;
          if (Te)
            Si.onLogs(Bi);
          else
            for (const ji of Bi)
              Si.onLogs([ji]);
        } catch (Bi) {
          Oi && Bi instanceof InvalidInputRpcError && (Fi = !1), (Pi = Si.onError) == null || Pi.call(Si, Bi);
        }
      }, {
        emitOnBegin: !0,
        interval: vn
      });
      return async () => {
        Oi && await getAction(Ae, uninstallFilter, "uninstallFilter")({ filter: Oi }), Ui();
      };
    });
  })() : (() => {
    const _i = En ?? !1, Ei = stringify$2([
      "watchContractEvent",
      Be,
      Pe,
      Te,
      Ae.uid,
      Me,
      vn,
      _i
    ]);
    let Si = !0, Mi = () => Si = !1;
    return observe(Ei, { onLogs: fn, onError: je }, (Oi) => ((async () => {
      try {
        const Fi = (() => {
          if (Ae.transport.type === "fallback") {
            const Bi = Ae.transport.transports.find((ji) => ji.config.type === "webSocket");
            return Bi ? Bi.value : Ae.transport;
          }
          return Ae.transport;
        })(), Ui = Me ? encodeEventTopics({
          abi: Ie,
          eventName: Me,
          args: Pe
        }) : [], { unsubscribe: Pi } = await Fi.subscribe({
          params: ["logs", { address: Be, topics: Ui }],
          onData(Bi) {
            var Zi;
            if (!Si)
              return;
            const ji = Bi.result;
            try {
              const { eventName: zi, args: xi } = decodeEventLog({
                abi: Ie,
                data: ji.data,
                topics: ji.topics,
                strict: En
              }), $i = formatLog(ji, {
                args: xi,
                eventName: zi
              });
              Oi.onLogs([$i]);
            } catch (zi) {
              let xi, $i;
              if (zi instanceof DecodeLogDataMismatch || zi instanceof DecodeLogTopicsMismatch) {
                if (En)
                  return;
                xi = zi.abiItem.name, $i = (Zi = zi.abiItem.inputs) == null ? void 0 : Zi.some((wi) => !("name" in wi && wi.name));
              }
              const vi = formatLog(ji, {
                args: $i ? [] : {},
                eventName: xi
              });
              Oi.onLogs([vi]);
            }
          },
          onError(Bi) {
            var ji;
            (ji = Oi.onError) == null || ji.call(Oi, Bi);
          }
        });
        Mi = Pi, Si || Mi();
      } catch (Fi) {
        je == null || je(Fi);
      }
    })(), () => Mi()));
  })();
}
function getTransactionError(Ae, { docsPath: t, ...Ie }) {
  const Be = (() => {
    const Pe = getNodeError(Ae, Ie);
    return Pe instanceof UnknownNodeError ? Ae : Pe;
  })();
  return new TransactionExecutionError(Be, {
    docsPath: t,
    ...Ie
  });
}
async function sendRawTransaction(Ae, { serializedTransaction: t }) {
  return Ae.request({
    method: "eth_sendRawTransaction",
    params: [t]
  }, { retryCount: 0 });
}
const supportsWalletNamespace = new LruMap(128);
async function sendTransaction(Ae, t) {
  var Ei, Si, Mi, Oi;
  const { account: Ie = Ae.account, chain: Be = Ae.chain, accessList: Pe, authorizationList: Te, blobs: Me, data: Ue, gas: je, gasPrice: fn, maxFeePerBlobGas: Ve, maxFeePerGas: vn, maxPriorityFeePerGas: En, nonce: fi, value: bi, ...mi } = t;
  if (typeof Ie > "u")
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const _i = Ie ? parseAccount(Ie) : null;
  try {
    assertRequest(t);
    const Fi = await (async () => {
      if (t.to)
        return t.to;
      if (Te && Te.length > 0)
        return await recoverAuthorizationAddress({
          authorization: Te[0]
        }).catch(() => {
          throw new BaseError$1("`to` is required. Could not infer from `authorizationList`.");
        });
    })();
    if ((_i == null ? void 0 : _i.type) === "json-rpc" || _i === null) {
      let Ui;
      Be !== null && (Ui = await getAction(Ae, getChainId, "getChainId")({}), assertCurrentChain({
        currentChainId: Ui,
        chain: Be
      }));
      const Pi = (Mi = (Si = (Ei = Ae.chain) == null ? void 0 : Ei.formatters) == null ? void 0 : Si.transactionRequest) == null ? void 0 : Mi.format, ji = (Pi || formatTransactionRequest)({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...extract(mi, { format: Pi }),
        accessList: Pe,
        authorizationList: Te,
        blobs: Me,
        chainId: Ui,
        data: Ue,
        from: _i == null ? void 0 : _i.address,
        gas: je,
        gasPrice: fn,
        maxFeePerBlobGas: Ve,
        maxFeePerGas: vn,
        maxPriorityFeePerGas: En,
        nonce: fi,
        to: Fi,
        value: bi
      }), Zi = supportsWalletNamespace.get(Ae.uid) ? "wallet_sendTransaction" : "eth_sendTransaction";
      try {
        return await Ae.request({
          method: Zi,
          params: [ji]
        }, { retryCount: 0 });
      } catch (zi) {
        const xi = zi;
        if (xi.name === "InvalidInputRpcError" || xi.name === "InvalidParamsRpcError" || xi.name === "MethodNotFoundRpcError" || xi.name === "MethodNotSupportedRpcError")
          return await Ae.request({
            method: "wallet_sendTransaction",
            params: [ji]
          }, { retryCount: 0 }).then(($i) => (supportsWalletNamespace.set(Ae.uid, !0), $i));
        throw xi;
      }
    }
    if ((_i == null ? void 0 : _i.type) === "local") {
      const Ui = await getAction(Ae, prepareTransactionRequest, "prepareTransactionRequest")({
        account: _i,
        accessList: Pe,
        authorizationList: Te,
        blobs: Me,
        chain: Be,
        data: Ue,
        gas: je,
        gasPrice: fn,
        maxFeePerBlobGas: Ve,
        maxFeePerGas: vn,
        maxPriorityFeePerGas: En,
        nonce: fi,
        nonceManager: _i.nonceManager,
        parameters: [...defaultParameters, "sidecars"],
        value: bi,
        ...mi,
        to: Fi
      }), Pi = (Oi = Be == null ? void 0 : Be.serializers) == null ? void 0 : Oi.transaction, Bi = await _i.signTransaction(Ui, {
        serializer: Pi
      });
      return await getAction(Ae, sendRawTransaction, "sendRawTransaction")({
        serializedTransaction: Bi
      });
    }
    throw (_i == null ? void 0 : _i.type) === "smart" ? new AccountTypeNotSupportedError({
      metaMessages: [
        "Consider using the `sendUserOperation` Action instead."
      ],
      docsPath: "/docs/actions/bundler/sendUserOperation",
      type: "smart"
    }) : new AccountTypeNotSupportedError({
      docsPath: "/docs/actions/wallet/sendTransaction",
      type: _i == null ? void 0 : _i.type
    });
  } catch (Fi) {
    throw Fi instanceof AccountTypeNotSupportedError ? Fi : getTransactionError(Fi, {
      ...t,
      account: _i,
      chain: t.chain || void 0
    });
  }
}
async function writeContract(Ae, t) {
  const { abi: Ie, account: Be = Ae.account, address: Pe, args: Te, dataSuffix: Me, functionName: Ue, ...je } = t;
  if (typeof Be > "u")
    throw new AccountNotFoundError({
      docsPath: "/docs/contract/writeContract"
    });
  const fn = Be ? parseAccount(Be) : null, Ve = encodeFunctionData({
    abi: Ie,
    args: Te,
    functionName: Ue
  });
  try {
    return await getAction(Ae, sendTransaction, "sendTransaction")({
      data: `${Ve}${Me ? Me.replace("0x", "") : ""}`,
      to: Pe,
      account: fn,
      ...je
    });
  } catch (vn) {
    throw getContractError(vn, {
      abi: Ie,
      address: Pe,
      args: Te,
      docsPath: "/docs/contract/writeContract",
      functionName: Ue,
      sender: fn == null ? void 0 : fn.address
    });
  }
}
class Eip712DomainNotFoundError extends BaseError$1 {
  constructor({ address: t }) {
    super(`No EIP-712 domain found on contract "${t}".`, {
      metaMessages: [
        "Ensure that:",
        `- The contract is deployed at the address "${t}".`,
        "- `eip712Domain()` function exists on the contract.",
        "- `eip712Domain()` function matches signature to ERC-5267 specification."
      ],
      name: "Eip712DomainNotFoundError"
    });
  }
}
async function getEip712Domain(Ae, t) {
  const { address: Ie, factory: Be, factoryData: Pe } = t;
  try {
    const [Te, Me, Ue, je, fn, Ve, vn] = await getAction(Ae, readContract, "readContract")({
      abi,
      address: Ie,
      functionName: "eip712Domain",
      factory: Be,
      factoryData: Pe
    });
    return {
      domain: {
        name: Me,
        version: Ue,
        chainId: Number(je),
        verifyingContract: fn,
        salt: Ve
      },
      extensions: vn,
      fields: Te
    };
  } catch (Te) {
    const Me = Te;
    throw Me.name === "ContractFunctionExecutionError" && Me.cause.name === "ContractFunctionZeroDataError" ? new Eip712DomainNotFoundError({ address: Ie }) : Me;
  }
}
const abi = [
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      { name: "fields", type: "bytes1" },
      { name: "name", type: "string" },
      { name: "version", type: "string" },
      { name: "chainId", type: "uint256" },
      { name: "verifyingContract", type: "address" },
      { name: "salt", type: "bytes32" },
      { name: "extensions", type: "uint256[]" }
    ],
    stateMutability: "view",
    type: "function"
  }
];
async function addChain(Ae, { chain: t }) {
  const { id: Ie, name: Be, nativeCurrency: Pe, rpcUrls: Te, blockExplorers: Me } = t;
  await Ae.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: numberToHex(Ie),
        chainName: Be,
        nativeCurrency: Pe,
        rpcUrls: Te.default.http,
        blockExplorerUrls: Me ? Object.values(Me).map(({ url: Ue }) => Ue) : void 0
      }
    ]
  }, { dedupe: !0, retryCount: 0 });
}
const size = 256;
let index = size, buffer;
function uid(Ae = 11) {
  if (!buffer || index + Ae > size * 2) {
    buffer = "", index = 0;
    for (let t = 0; t < size; t++)
      buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return buffer.substring(index, index++ + Ae);
}
function createClient(Ae) {
  const { batch: t, cacheTime: Ie = Ae.pollingInterval ?? 4e3, ccipRead: Be, key: Pe = "base", name: Te = "Base Client", pollingInterval: Me = 4e3, type: Ue = "base" } = Ae, je = Ae.chain, fn = Ae.account ? parseAccount(Ae.account) : void 0, { config: Ve, request: vn, value: En } = Ae.transport({
    chain: je,
    pollingInterval: Me
  }), fi = { ...Ve, ...En }, bi = {
    account: fn,
    batch: t,
    cacheTime: Ie,
    ccipRead: Be,
    chain: je,
    key: Pe,
    name: Te,
    pollingInterval: Me,
    request: vn,
    transport: fi,
    type: Ue,
    uid: uid()
  };
  function mi(_i) {
    return (Ei) => {
      const Si = Ei(_i);
      for (const Oi in bi)
        delete Si[Oi];
      const Mi = { ..._i, ...Si };
      return Object.assign(Mi, { extend: mi(Mi) });
    };
  }
  return Object.assign(bi, { extend: mi(bi) });
}
const promiseCache = /* @__PURE__ */ new LruMap(8192);
function withDedupe(Ae, { enabled: t = !0, id: Ie }) {
  if (!t || !Ie)
    return Ae();
  if (promiseCache.get(Ie))
    return promiseCache.get(Ie);
  const Be = Ae().finally(() => promiseCache.delete(Ie));
  return promiseCache.set(Ie, Be), Be;
}
function withRetry(Ae, { delay: t = 100, retryCount: Ie = 2, shouldRetry: Be = () => !0 } = {}) {
  return new Promise((Pe, Te) => {
    const Me = async ({ count: Ue = 0 } = {}) => {
      const je = async ({ error: fn }) => {
        const Ve = typeof t == "function" ? t({ count: Ue, error: fn }) : t;
        Ve && await wait(Ve), Me({ count: Ue + 1 });
      };
      try {
        const fn = await Ae();
        Pe(fn);
      } catch (fn) {
        if (Ue < Ie && await Be({ count: Ue, error: fn }))
          return je({ error: fn });
        Te(fn);
      }
    };
    Me();
  });
}
function buildRequest(Ae, t = {}) {
  return async (Ie, Be = {}) => {
    const { dedupe: Pe = !1, retryDelay: Te = 150, retryCount: Me = 3, uid: Ue } = {
      ...t,
      ...Be
    }, je = Pe ? keccak256$2(stringToHex(`${Ue}.${stringify$2(Ie)}`)) : void 0;
    return withDedupe(() => withRetry(async () => {
      try {
        return await Ae(Ie);
      } catch (fn) {
        const Ve = fn;
        switch (Ve.code) {
          case ParseRpcError.code:
            throw new ParseRpcError(Ve);
          case InvalidRequestRpcError.code:
            throw new InvalidRequestRpcError(Ve);
          case MethodNotFoundRpcError.code:
            throw new MethodNotFoundRpcError(Ve, { method: Ie.method });
          case InvalidParamsRpcError.code:
            throw new InvalidParamsRpcError(Ve);
          case InternalRpcError.code:
            throw new InternalRpcError(Ve);
          case InvalidInputRpcError.code:
            throw new InvalidInputRpcError(Ve);
          case ResourceNotFoundRpcError.code:
            throw new ResourceNotFoundRpcError(Ve);
          case ResourceUnavailableRpcError.code:
            throw new ResourceUnavailableRpcError(Ve);
          case TransactionRejectedRpcError.code:
            throw new TransactionRejectedRpcError(Ve);
          case MethodNotSupportedRpcError.code:
            throw new MethodNotSupportedRpcError(Ve, {
              method: Ie.method
            });
          case LimitExceededRpcError.code:
            throw new LimitExceededRpcError(Ve);
          case JsonRpcVersionUnsupportedError.code:
            throw new JsonRpcVersionUnsupportedError(Ve);
          case UserRejectedRequestError.code:
            throw new UserRejectedRequestError(Ve);
          case UnauthorizedProviderError.code:
            throw new UnauthorizedProviderError(Ve);
          case UnsupportedProviderMethodError.code:
            throw new UnsupportedProviderMethodError(Ve);
          case ProviderDisconnectedError.code:
            throw new ProviderDisconnectedError(Ve);
          case ChainDisconnectedError.code:
            throw new ChainDisconnectedError(Ve);
          case SwitchChainError.code:
            throw new SwitchChainError(Ve);
          case 5e3:
            throw new UserRejectedRequestError(Ve);
          default:
            throw fn instanceof BaseError$1 ? fn : new UnknownRpcError(Ve);
        }
      }
    }, {
      delay: ({ count: fn, error: Ve }) => {
        var vn;
        if (Ve && Ve instanceof HttpRequestError) {
          const En = (vn = Ve == null ? void 0 : Ve.headers) == null ? void 0 : vn.get("Retry-After");
          if (En != null && En.match(/\d/))
            return Number.parseInt(En) * 1e3;
        }
        return ~~(1 << fn) * Te;
      },
      retryCount: Me,
      shouldRetry: ({ error: fn }) => shouldRetry(fn)
    }), { enabled: Pe, id: je });
  };
}
function shouldRetry(Ae) {
  return "code" in Ae && typeof Ae.code == "number" ? Ae.code === -1 || Ae.code === LimitExceededRpcError.code || Ae.code === InternalRpcError.code : Ae instanceof HttpRequestError && Ae.status ? Ae.status === 403 || Ae.status === 408 || Ae.status === 413 || Ae.status === 429 || Ae.status === 500 || Ae.status === 502 || Ae.status === 503 || Ae.status === 504 : !0;
}
function createTransport({ key: Ae, name: t, request: Ie, retryCount: Be = 3, retryDelay: Pe = 150, timeout: Te, type: Me }, Ue) {
  const je = uid();
  return {
    config: {
      key: Ae,
      name: t,
      request: Ie,
      retryCount: Be,
      retryDelay: Pe,
      timeout: Te,
      type: Me
    },
    request: buildRequest(Ie, { retryCount: Be, retryDelay: Pe, uid: je }),
    value: Ue
  };
}
function custom(Ae, t = {}) {
  const { key: Ie = "custom", name: Be = "Custom Provider", retryDelay: Pe } = t;
  return ({ retryCount: Te }) => createTransport({
    key: Ie,
    name: Be,
    request: Ae.request.bind(Ae),
    retryCount: t.retryCount ?? Te,
    retryDelay: Pe,
    type: "custom"
  });
}
class UrlRequiredError extends BaseError$1 {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro",
      name: "UrlRequiredError"
    });
  }
}
function withTimeout(Ae, { errorInstance: t = new Error("timed out"), timeout: Ie, signal: Be }) {
  return new Promise((Pe, Te) => {
    (async () => {
      let Me;
      try {
        const Ue = new AbortController();
        Ie > 0 && (Me = setTimeout(() => {
          Be ? Ue.abort() : Te(t);
        }, Ie)), Pe(await Ae({ signal: (Ue == null ? void 0 : Ue.signal) || null }));
      } catch (Ue) {
        (Ue == null ? void 0 : Ue.name) === "AbortError" && Te(t), Te(Ue);
      } finally {
        clearTimeout(Me);
      }
    })();
  });
}
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
const idCache = /* @__PURE__ */ createIdStore();
function getHttpRpcClient(Ae, t = {}) {
  return {
    async request(Ie) {
      var vn;
      const { body: Be, onRequest: Pe = t.onRequest, onResponse: Te = t.onResponse, timeout: Me = t.timeout ?? 1e4 } = Ie, Ue = {
        ...t.fetchOptions ?? {},
        ...Ie.fetchOptions ?? {}
      }, { headers: je, method: fn, signal: Ve } = Ue;
      try {
        const En = await withTimeout(async ({ signal: bi }) => {
          const mi = {
            ...Ue,
            body: Array.isArray(Be) ? stringify$2(Be.map((Mi) => ({
              jsonrpc: "2.0",
              id: Mi.id ?? idCache.take(),
              ...Mi
            }))) : stringify$2({
              jsonrpc: "2.0",
              id: Be.id ?? idCache.take(),
              ...Be
            }),
            headers: {
              "Content-Type": "application/json",
              ...je
            },
            method: fn || "POST",
            signal: Ve || (Me > 0 ? bi : null)
          }, _i = new Request(Ae, mi), Ei = await (Pe == null ? void 0 : Pe(_i, mi)) ?? { ...mi, url: Ae };
          return await fetch(Ei.url ?? Ae, Ei);
        }, {
          errorInstance: new TimeoutError({ body: Be, url: Ae }),
          timeout: Me,
          signal: !0
        });
        Te && await Te(En);
        let fi;
        if ((vn = En.headers.get("Content-Type")) != null && vn.startsWith("application/json"))
          fi = await En.json();
        else {
          fi = await En.text();
          try {
            fi = JSON.parse(fi || "{}");
          } catch (bi) {
            if (En.ok)
              throw bi;
            fi = { error: fi };
          }
        }
        if (!En.ok)
          throw new HttpRequestError({
            body: Be,
            details: stringify$2(fi.error) || En.statusText,
            headers: En.headers,
            status: En.status,
            url: Ae
          });
        return fi;
      } catch (En) {
        throw En instanceof HttpRequestError || En instanceof TimeoutError ? En : new HttpRequestError({
          body: Be,
          cause: En,
          url: Ae
        });
      }
    }
  };
}
function http(Ae, t = {}) {
  const { batch: Ie, fetchOptions: Be, key: Pe = "http", name: Te = "HTTP JSON-RPC", onFetchRequest: Me, onFetchResponse: Ue, retryDelay: je } = t;
  return ({ chain: fn, retryCount: Ve, timeout: vn }) => {
    const { batchSize: En = 1e3, wait: fi = 0 } = typeof Ie == "object" ? Ie : {}, bi = t.retryCount ?? Ve, mi = vn ?? t.timeout ?? 1e4, _i = Ae || (fn == null ? void 0 : fn.rpcUrls.default.http[0]);
    if (!_i)
      throw new UrlRequiredError();
    const Ei = getHttpRpcClient(_i, {
      fetchOptions: Be,
      onRequest: Me,
      onResponse: Ue,
      timeout: mi
    });
    return createTransport({
      key: Pe,
      name: Te,
      async request({ method: Si, params: Mi }) {
        const Oi = { method: Si, params: Mi }, { schedule: Fi } = createBatchScheduler({
          id: _i,
          wait: fi,
          shouldSplitBatch(ji) {
            return ji.length > En;
          },
          fn: (ji) => Ei.request({
            body: ji
          }),
          sort: (ji, Zi) => ji.id - Zi.id
        }), Ui = async (ji) => Ie ? Fi(ji) : [
          await Ei.request({
            body: ji
          })
        ], [{ error: Pi, result: Bi }] = await Ui(Oi);
        if (Pi)
          throw new RpcRequestError({
            body: Oi,
            error: Pi,
            url: _i
          });
        return Bi;
      },
      retryCount: bi,
      retryDelay: je,
      timeout: mi,
      type: "http"
    }, {
      fetchOptions: Be,
      url: _i
    });
  };
}
function isNullUniversalResolverError(Ae, t) {
  var Be, Pe, Te, Me, Ue, je;
  if (!(Ae instanceof BaseError$1))
    return !1;
  const Ie = Ae.walk((fn) => fn instanceof ContractFunctionRevertedError);
  return Ie instanceof ContractFunctionRevertedError ? !!(((Be = Ie.data) == null ? void 0 : Be.errorName) === "ResolverNotFound" || ((Pe = Ie.data) == null ? void 0 : Pe.errorName) === "ResolverWildcardNotSupported" || ((Te = Ie.data) == null ? void 0 : Te.errorName) === "ResolverNotContract" || ((Me = Ie.data) == null ? void 0 : Me.errorName) === "ResolverError" || ((Ue = Ie.data) == null ? void 0 : Ue.errorName) === "HttpError" || (je = Ie.reason) != null && je.includes("Wildcard on non-extended resolvers is not supported") || t === "reverse" && Ie.reason === panicReasons[50]) : !1;
}
function encodedLabelToLabelhash(Ae) {
  if (Ae.length !== 66 || Ae.indexOf("[") !== 0 || Ae.indexOf("]") !== 65)
    return null;
  const t = `0x${Ae.slice(1, 65)}`;
  return isHex(t) ? t : null;
}
function namehash(Ae) {
  let t = new Uint8Array(32).fill(0);
  if (!Ae)
    return bytesToHex$2(t);
  const Ie = Ae.split(".");
  for (let Be = Ie.length - 1; Be >= 0; Be -= 1) {
    const Pe = encodedLabelToLabelhash(Ie[Be]), Te = Pe ? toBytes$2(Pe) : keccak256$2(stringToBytes(Ie[Be]), "bytes");
    t = keccak256$2(concat$3([t, Te]), "bytes");
  }
  return bytesToHex$2(t);
}
function encodeLabelhash(Ae) {
  return `[${Ae.slice(2)}]`;
}
function labelhash(Ae) {
  const t = new Uint8Array(32).fill(0);
  return Ae ? encodedLabelToLabelhash(Ae) || keccak256$2(stringToBytes(Ae)) : bytesToHex$2(t);
}
function packetToBytes(Ae) {
  const t = Ae.replace(/^\.|\.$/gm, "");
  if (t.length === 0)
    return new Uint8Array(1);
  const Ie = new Uint8Array(stringToBytes(t).byteLength + 2);
  let Be = 0;
  const Pe = t.split(".");
  for (let Te = 0; Te < Pe.length; Te++) {
    let Me = stringToBytes(Pe[Te]);
    Me.byteLength > 255 && (Me = stringToBytes(encodeLabelhash(labelhash(Pe[Te])))), Ie[Be] = Me.length, Ie.set(Me, Be + 1), Be += Me.length + 1;
  }
  return Ie.byteLength !== Be + 1 ? Ie.slice(0, Be + 1) : Ie;
}
async function getEnsAddress(Ae, { blockNumber: t, blockTag: Ie, coinType: Be, name: Pe, gatewayUrls: Te, strict: Me, universalResolverAddress: Ue }) {
  let je = Ue;
  if (!je) {
    if (!Ae.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    je = getChainContractAddress({
      blockNumber: t,
      chain: Ae.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const fn = encodeFunctionData({
      abi: addressResolverAbi,
      functionName: "addr",
      ...Be != null ? { args: [namehash(Pe), BigInt(Be)] } : { args: [namehash(Pe)] }
    }), Ve = {
      address: je,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [toHex(packetToBytes(Pe)), fn],
      blockNumber: t,
      blockTag: Ie
    }, vn = getAction(Ae, readContract, "readContract"), En = Te ? await vn({
      ...Ve,
      args: [...Ve.args, Te]
    }) : await vn(Ve);
    if (En[0] === "0x")
      return null;
    const fi = decodeFunctionResult({
      abi: addressResolverAbi,
      args: Be != null ? [namehash(Pe), BigInt(Be)] : void 0,
      functionName: "addr",
      data: En[0]
    });
    return fi === "0x" || trim(fi) === "0x00" ? null : fi;
  } catch (fn) {
    if (Me)
      throw fn;
    if (isNullUniversalResolverError(fn, "resolve"))
      return null;
    throw fn;
  }
}
class EnsAvatarInvalidMetadataError extends BaseError$1 {
  constructor({ data: t }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(t)}`
      ],
      name: "EnsAvatarInvalidMetadataError"
    });
  }
}
class EnsAvatarInvalidNftUriError extends BaseError$1 {
  constructor({ reason: t }) {
    super(`ENS NFT avatar URI is invalid. ${t}`, {
      name: "EnsAvatarInvalidNftUriError"
    });
  }
}
class EnsAvatarUriResolutionError extends BaseError$1 {
  constructor({ uri: t }) {
    super(`Unable to resolve ENS avatar URI "${t}". The URI may be malformed, invalid, or does not respond with a valid image.`, { name: "EnsAvatarUriResolutionError" });
  }
}
class EnsAvatarUnsupportedNamespaceError extends BaseError$1 {
  constructor({ namespace: t }) {
    super(`ENS NFT avatar namespace "${t}" is not supported. Must be "erc721" or "erc1155".`, { name: "EnsAvatarUnsupportedNamespaceError" });
  }
}
const networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/, ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/, base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/, dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(Ae) {
  try {
    const t = await fetch(Ae, { method: "HEAD" });
    if (t.status === 200) {
      const Ie = t.headers.get("content-type");
      return Ie == null ? void 0 : Ie.startsWith("image/");
    }
    return !1;
  } catch (t) {
    return typeof t == "object" && typeof t.response < "u" || !globalThis.hasOwnProperty("Image") ? !1 : new Promise((Ie) => {
      const Be = new Image();
      Be.onload = () => {
        Ie(!0);
      }, Be.onerror = () => {
        Ie(!1);
      }, Be.src = Ae;
    });
  }
}
function getGateway(Ae, t) {
  return Ae ? Ae.endsWith("/") ? Ae.slice(0, -1) : Ae : t;
}
function resolveAvatarUri({ uri: Ae, gatewayUrls: t }) {
  const Ie = base64Regex.test(Ae);
  if (Ie)
    return { uri: Ae, isOnChain: !0, isEncoded: Ie };
  const Be = getGateway(t == null ? void 0 : t.ipfs, "https://ipfs.io"), Pe = getGateway(t == null ? void 0 : t.arweave, "https://arweave.net"), Te = Ae.match(networkRegex), { protocol: Me, subpath: Ue, target: je, subtarget: fn = "" } = (Te == null ? void 0 : Te.groups) || {}, Ve = Me === "ipns:/" || Ue === "ipns/", vn = Me === "ipfs:/" || Ue === "ipfs/" || ipfsHashRegex.test(Ae);
  if (Ae.startsWith("http") && !Ve && !vn) {
    let fi = Ae;
    return t != null && t.arweave && (fi = Ae.replace(/https:\/\/arweave.net/g, t == null ? void 0 : t.arweave)), { uri: fi, isOnChain: !1, isEncoded: !1 };
  }
  if ((Ve || vn) && je)
    return {
      uri: `${Be}/${Ve ? "ipns" : "ipfs"}/${je}${fn}`,
      isOnChain: !1,
      isEncoded: !1
    };
  if (Me === "ar:/" && je)
    return {
      uri: `${Pe}/${je}${fn || ""}`,
      isOnChain: !1,
      isEncoded: !1
    };
  let En = Ae.replace(dataURIRegex, "");
  if (En.startsWith("<svg") && (En = `data:image/svg+xml;base64,${btoa(En)}`), En.startsWith("data:") || En.startsWith("{"))
    return {
      uri: En,
      isOnChain: !0,
      isEncoded: !1
    };
  throw new EnsAvatarUriResolutionError({ uri: Ae });
}
function getJsonImage(Ae) {
  if (typeof Ae != "object" || !("image" in Ae) && !("image_url" in Ae) && !("image_data" in Ae))
    throw new EnsAvatarInvalidMetadataError({ data: Ae });
  return Ae.image || Ae.image_url || Ae.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls: Ae, uri: t }) {
  try {
    const Ie = await fetch(t).then((Pe) => Pe.json());
    return await parseAvatarUri({
      gatewayUrls: Ae,
      uri: getJsonImage(Ie)
    });
  } catch {
    throw new EnsAvatarUriResolutionError({ uri: t });
  }
}
async function parseAvatarUri({ gatewayUrls: Ae, uri: t }) {
  const { uri: Ie, isOnChain: Be } = resolveAvatarUri({ uri: t, gatewayUrls: Ae });
  if (Be || await isImageUri(Ie))
    return Ie;
  throw new EnsAvatarUriResolutionError({ uri: t });
}
function parseNftUri(Ae) {
  let t = Ae;
  t.startsWith("did:nft:") && (t = t.replace("did:nft:", "").replace(/_/g, "/"));
  const [Ie, Be, Pe] = t.split("/"), [Te, Me] = Ie.split(":"), [Ue, je] = Be.split(":");
  if (!Te || Te.toLowerCase() !== "eip155")
    throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
  if (!Me)
    throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
  if (!je)
    throw new EnsAvatarInvalidNftUriError({
      reason: "Contract address not found"
    });
  if (!Pe)
    throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
  if (!Ue)
    throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
  return {
    chainID: Number.parseInt(Me),
    namespace: Ue.toLowerCase(),
    contractAddress: je,
    tokenID: Pe
  };
}
async function getNftTokenUri(Ae, { nft: t }) {
  if (t.namespace === "erc721")
    return readContract(Ae, {
      address: t.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(t.tokenID)]
    });
  if (t.namespace === "erc1155")
    return readContract(Ae, {
      address: t.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(t.tokenID)]
    });
  throw new EnsAvatarUnsupportedNamespaceError({ namespace: t.namespace });
}
async function parseAvatarRecord(Ae, { gatewayUrls: t, record: Ie }) {
  return /eip155:/i.test(Ie) ? parseNftAvatarUri(Ae, { gatewayUrls: t, record: Ie }) : parseAvatarUri({ uri: Ie, gatewayUrls: t });
}
async function parseNftAvatarUri(Ae, { gatewayUrls: t, record: Ie }) {
  const Be = parseNftUri(Ie), Pe = await getNftTokenUri(Ae, { nft: Be }), { uri: Te, isOnChain: Me, isEncoded: Ue } = resolveAvatarUri({ uri: Pe, gatewayUrls: t });
  if (Me && (Te.includes("data:application/json;base64,") || Te.startsWith("{"))) {
    const fn = Ue ? (
      // if it is encoded, decode it
      atob(Te.replace("data:application/json;base64,", ""))
    ) : (
      // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)
      Te
    ), Ve = JSON.parse(fn);
    return parseAvatarUri({ uri: getJsonImage(Ve), gatewayUrls: t });
  }
  let je = Be.tokenID;
  return Be.namespace === "erc1155" && (je = je.replace("0x", "").padStart(64, "0")), getMetadataAvatarUri({
    gatewayUrls: t,
    uri: Te.replace(/(?:0x)?{id}/, je)
  });
}
async function getEnsText(Ae, { blockNumber: t, blockTag: Ie, name: Be, key: Pe, gatewayUrls: Te, strict: Me, universalResolverAddress: Ue }) {
  let je = Ue;
  if (!je) {
    if (!Ae.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    je = getChainContractAddress({
      blockNumber: t,
      chain: Ae.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const fn = {
      address: je,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [
        toHex(packetToBytes(Be)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: "text",
          args: [namehash(Be), Pe]
        })
      ],
      blockNumber: t,
      blockTag: Ie
    }, Ve = getAction(Ae, readContract, "readContract"), vn = Te ? await Ve({
      ...fn,
      args: [...fn.args, Te]
    }) : await Ve(fn);
    if (vn[0] === "0x")
      return null;
    const En = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: "text",
      data: vn[0]
    });
    return En === "" ? null : En;
  } catch (fn) {
    if (Me)
      throw fn;
    if (isNullUniversalResolverError(fn, "resolve"))
      return null;
    throw fn;
  }
}
async function getEnsAvatar(Ae, { blockNumber: t, blockTag: Ie, assetGatewayUrls: Be, name: Pe, gatewayUrls: Te, strict: Me, universalResolverAddress: Ue }) {
  const je = await getAction(Ae, getEnsText, "getEnsText")({
    blockNumber: t,
    blockTag: Ie,
    key: "avatar",
    name: Pe,
    universalResolverAddress: Ue,
    gatewayUrls: Te,
    strict: Me
  });
  if (!je)
    return null;
  try {
    return await parseAvatarRecord(Ae, {
      record: je,
      gatewayUrls: Be
    });
  } catch {
    return null;
  }
}
async function getEnsName(Ae, { address: t, blockNumber: Ie, blockTag: Be, gatewayUrls: Pe, strict: Te, universalResolverAddress: Me }) {
  let Ue = Me;
  if (!Ue) {
    if (!Ae.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    Ue = getChainContractAddress({
      blockNumber: Ie,
      chain: Ae.chain,
      contract: "ensUniversalResolver"
    });
  }
  const je = `${t.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const fn = {
      address: Ue,
      abi: universalResolverReverseAbi,
      functionName: "reverse",
      args: [toHex(packetToBytes(je))],
      blockNumber: Ie,
      blockTag: Be
    }, Ve = getAction(Ae, readContract, "readContract"), [vn, En] = Pe ? await Ve({
      ...fn,
      args: [...fn.args, Pe]
    }) : await Ve(fn);
    return t.toLowerCase() !== En.toLowerCase() ? null : vn;
  } catch (fn) {
    if (Te)
      throw fn;
    if (isNullUniversalResolverError(fn, "reverse"))
      return null;
    throw fn;
  }
}
async function getEnsResolver(Ae, { blockNumber: t, blockTag: Ie, name: Be, universalResolverAddress: Pe }) {
  let Te = Pe;
  if (!Te) {
    if (!Ae.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    Te = getChainContractAddress({
      blockNumber: t,
      chain: Ae.chain,
      contract: "ensUniversalResolver"
    });
  }
  const [Me] = await getAction(Ae, readContract, "readContract")({
    address: Te,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [toHex(packetToBytes(Be))],
    blockNumber: t,
    blockTag: Ie
  });
  return Me;
}
async function createBlockFilter(Ae) {
  const t = createFilterRequestScope(Ae, {
    method: "eth_newBlockFilter"
  }), Ie = await Ae.request({
    method: "eth_newBlockFilter"
  });
  return { id: Ie, request: t(Ie), type: "block" };
}
async function createEventFilter(Ae, { address: t, args: Ie, event: Be, events: Pe, fromBlock: Te, strict: Me, toBlock: Ue } = {}) {
  const je = Pe ?? (Be ? [Be] : void 0), fn = createFilterRequestScope(Ae, {
    method: "eth_newFilter"
  });
  let Ve = [];
  je && (Ve = [je.flatMap((fi) => encodeEventTopics({
    abi: [fi],
    eventName: fi.name,
    args: Ie
  }))], Be && (Ve = Ve[0]));
  const vn = await Ae.request({
    method: "eth_newFilter",
    params: [
      {
        address: t,
        fromBlock: typeof Te == "bigint" ? numberToHex(Te) : Te,
        toBlock: typeof Ue == "bigint" ? numberToHex(Ue) : Ue,
        ...Ve.length ? { topics: Ve } : {}
      }
    ]
  });
  return {
    abi: je,
    args: Ie,
    eventName: Be ? Be.name : void 0,
    fromBlock: Te,
    id: vn,
    request: fn(vn),
    strict: !!Me,
    toBlock: Ue,
    type: "event"
  };
}
async function createPendingTransactionFilter(Ae) {
  const t = createFilterRequestScope(Ae, {
    method: "eth_newPendingTransactionFilter"
  }), Ie = await Ae.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id: Ie, request: t(Ie), type: "transaction" };
}
async function getBlobBaseFee(Ae) {
  const t = await Ae.request({
    method: "eth_blobBaseFee"
  });
  return BigInt(t);
}
async function getBlockTransactionCount(Ae, { blockHash: t, blockNumber: Ie, blockTag: Be = "latest" } = {}) {
  const Pe = Ie !== void 0 ? numberToHex(Ie) : void 0;
  let Te;
  return t ? Te = await Ae.request({
    method: "eth_getBlockTransactionCountByHash",
    params: [t]
  }, { dedupe: !0 }) : Te = await Ae.request({
    method: "eth_getBlockTransactionCountByNumber",
    params: [Pe || Be]
  }, { dedupe: !!Pe }), hexToNumber$2(Te);
}
async function getCode(Ae, { address: t, blockNumber: Ie, blockTag: Be = "latest" }) {
  const Pe = Ie !== void 0 ? numberToHex(Ie) : void 0, Te = await Ae.request({
    method: "eth_getCode",
    params: [t, Pe || Be]
  }, { dedupe: !!Pe });
  if (Te !== "0x")
    return Te;
}
function formatFeeHistory(Ae) {
  var t;
  return {
    baseFeePerGas: Ae.baseFeePerGas.map((Ie) => BigInt(Ie)),
    gasUsedRatio: Ae.gasUsedRatio,
    oldestBlock: BigInt(Ae.oldestBlock),
    reward: (t = Ae.reward) == null ? void 0 : t.map((Ie) => Ie.map((Be) => BigInt(Be)))
  };
}
async function getFeeHistory(Ae, { blockCount: t, blockNumber: Ie, blockTag: Be = "latest", rewardPercentiles: Pe }) {
  const Te = Ie ? numberToHex(Ie) : void 0, Me = await Ae.request({
    method: "eth_feeHistory",
    params: [
      numberToHex(t),
      Te || Be,
      Pe
    ]
  }, { dedupe: !!Te });
  return formatFeeHistory(Me);
}
async function getFilterLogs(Ae, { filter: t }) {
  const Ie = t.strict ?? !1, Pe = (await t.request({
    method: "eth_getFilterLogs",
    params: [t.id]
  })).map((Te) => formatLog(Te));
  return t.abi ? parseEventLogs({
    abi: t.abi,
    logs: Pe,
    strict: Ie
  }) : Pe;
}
class OffchainLookupError extends BaseError$1 {
  constructor({ callbackSelector: t, cause: Ie, data: Be, extraData: Pe, sender: Te, urls: Me }) {
    var Ue;
    super(Ie.shortMessage || "An error occurred while fetching for an offchain result.", {
      cause: Ie,
      metaMessages: [
        ...Ie.metaMessages || [],
        (Ue = Ie.metaMessages) != null && Ue.length ? "" : [],
        "Offchain Gateway Call:",
        Me && [
          "  Gateway URL(s):",
          ...Me.map((je) => `    ${getUrl(je)}`)
        ],
        `  Sender: ${Te}`,
        `  Data: ${Be}`,
        `  Callback selector: ${t}`,
        `  Extra data: ${Pe}`
      ].flat(),
      name: "OffchainLookupError"
    });
  }
}
class OffchainLookupResponseMalformedError extends BaseError$1 {
  constructor({ result: t, url: Ie }) {
    super("Offchain gateway response is malformed. Response data must be a hex value.", {
      metaMessages: [
        `Gateway URL: ${getUrl(Ie)}`,
        `Response: ${stringify$2(t)}`
      ],
      name: "OffchainLookupResponseMalformedError"
    });
  }
}
class OffchainLookupSenderMismatchError extends BaseError$1 {
  constructor({ sender: t, to: Ie }) {
    super("Reverted sender address does not match target contract address (`to`).", {
      metaMessages: [
        `Contract address: ${Ie}`,
        `OffchainLookup sender address: ${t}`
      ],
      name: "OffchainLookupSenderMismatchError"
    });
  }
}
const offchainLookupSignature = "0x556f1830", offchainLookupAbiItem = {
  name: "OffchainLookup",
  type: "error",
  inputs: [
    {
      name: "sender",
      type: "address"
    },
    {
      name: "urls",
      type: "string[]"
    },
    {
      name: "callData",
      type: "bytes"
    },
    {
      name: "callbackFunction",
      type: "bytes4"
    },
    {
      name: "extraData",
      type: "bytes"
    }
  ]
};
async function offchainLookup(Ae, { blockNumber: t, blockTag: Ie, data: Be, to: Pe }) {
  const { args: Te } = decodeErrorResult({
    data: Be,
    abi: [offchainLookupAbiItem]
  }), [Me, Ue, je, fn, Ve] = Te, { ccipRead: vn } = Ae, En = vn && typeof (vn == null ? void 0 : vn.request) == "function" ? vn.request : ccipRequest;
  try {
    if (!isAddressEqual(Pe, Me))
      throw new OffchainLookupSenderMismatchError({ sender: Me, to: Pe });
    const fi = await En({ data: je, sender: Me, urls: Ue }), { data: bi } = await call(Ae, {
      blockNumber: t,
      blockTag: Ie,
      data: concat$3([
        fn,
        encodeAbiParameters([{ type: "bytes" }, { type: "bytes" }], [fi, Ve])
      ]),
      to: Pe
    });
    return bi;
  } catch (fi) {
    throw new OffchainLookupError({
      callbackSelector: fn,
      cause: fi,
      data: Be,
      extraData: Ve,
      sender: Me,
      urls: Ue
    });
  }
}
async function ccipRequest({ data: Ae, sender: t, urls: Ie }) {
  var Pe;
  let Be = new Error("An unknown error occurred.");
  for (let Te = 0; Te < Ie.length; Te++) {
    const Me = Ie[Te], Ue = Me.includes("{data}") ? "GET" : "POST", je = Ue === "POST" ? { data: Ae, sender: t } : void 0, fn = Ue === "POST" ? { "Content-Type": "application/json" } : {};
    try {
      const Ve = await fetch(Me.replace("{sender}", t).replace("{data}", Ae), {
        body: JSON.stringify(je),
        headers: fn,
        method: Ue
      });
      let vn;
      if ((Pe = Ve.headers.get("Content-Type")) != null && Pe.startsWith("application/json") ? vn = (await Ve.json()).data : vn = await Ve.text(), !Ve.ok) {
        Be = new HttpRequestError({
          body: je,
          details: vn != null && vn.error ? stringify$2(vn.error) : Ve.statusText,
          headers: Ve.headers,
          status: Ve.status,
          url: Me
        });
        continue;
      }
      if (!isHex(vn)) {
        Be = new OffchainLookupResponseMalformedError({
          result: vn,
          url: Me
        });
        continue;
      }
      return vn;
    } catch (Ve) {
      Be = new HttpRequestError({
        body: je,
        details: Ve.message,
        url: Me
      });
    }
  }
  throw Be;
}
const ccip = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ccipRequest,
  offchainLookup,
  offchainLookupAbiItem,
  offchainLookupSignature
}, Symbol.toStringTag, { value: "Module" })), bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
class InvalidStructTypeError extends BaseError$1 {
  constructor({ type: t }) {
    super(`Struct type "${t}" is invalid.`, {
      metaMessages: ["Struct type must not be a Solidity type."],
      name: "InvalidStructTypeError"
    });
  }
}
function hashTypedData(Ae) {
  const { domain: t = {}, message: Ie, primaryType: Be } = Ae, Pe = {
    EIP712Domain: getTypesForEIP712Domain({ domain: t }),
    ...Ae.types
  };
  validateTypedData({
    domain: t,
    message: Ie,
    primaryType: Be,
    types: Pe
  });
  const Te = ["0x1901"];
  return t && Te.push(hashDomain({
    domain: t,
    types: Pe
  })), Be !== "EIP712Domain" && Te.push(hashStruct({
    data: Ie,
    primaryType: Be,
    types: Pe
  })), keccak256$2(concat$3(Te));
}
function hashDomain({ domain: Ae, types: t }) {
  return hashStruct({
    data: Ae,
    primaryType: "EIP712Domain",
    types: t
  });
}
function hashStruct({ data: Ae, primaryType: t, types: Ie }) {
  const Be = encodeData$1({
    data: Ae,
    primaryType: t,
    types: Ie
  });
  return keccak256$2(Be);
}
function encodeData$1({ data: Ae, primaryType: t, types: Ie }) {
  const Be = [{ type: "bytes32" }], Pe = [hashType({ primaryType: t, types: Ie })];
  for (const Te of Ie[t]) {
    const [Me, Ue] = encodeField({
      types: Ie,
      name: Te.name,
      type: Te.type,
      value: Ae[Te.name]
    });
    Be.push(Me), Pe.push(Ue);
  }
  return encodeAbiParameters(Be, Pe);
}
function hashType({ primaryType: Ae, types: t }) {
  const Ie = toHex(encodeType({ primaryType: Ae, types: t }));
  return keccak256$2(Ie);
}
function encodeType({ primaryType: Ae, types: t }) {
  let Ie = "";
  const Be = findTypeDependencies({ primaryType: Ae, types: t });
  Be.delete(Ae);
  const Pe = [Ae, ...Array.from(Be).sort()];
  for (const Te of Pe)
    Ie += `${Te}(${t[Te].map(({ name: Me, type: Ue }) => `${Ue} ${Me}`).join(",")})`;
  return Ie;
}
function findTypeDependencies({ primaryType: Ae, types: t }, Ie = /* @__PURE__ */ new Set()) {
  const Be = Ae.match(/^\w*/u), Pe = Be == null ? void 0 : Be[0];
  if (Ie.has(Pe) || t[Pe] === void 0)
    return Ie;
  Ie.add(Pe);
  for (const Te of t[Pe])
    findTypeDependencies({ primaryType: Te.type, types: t }, Ie);
  return Ie;
}
function encodeField({ types: Ae, name: t, type: Ie, value: Be }) {
  if (Ae[Ie] !== void 0)
    return [
      { type: "bytes32" },
      keccak256$2(encodeData$1({ data: Be, primaryType: Ie, types: Ae }))
    ];
  if (Ie === "bytes")
    return Be = `0x${(Be.length % 2 ? "0" : "") + Be.slice(2)}`, [{ type: "bytes32" }, keccak256$2(Be)];
  if (Ie === "string")
    return [{ type: "bytes32" }, keccak256$2(toHex(Be))];
  if (Ie.lastIndexOf("]") === Ie.length - 1) {
    const Pe = Ie.slice(0, Ie.lastIndexOf("[")), Te = Be.map((Me) => encodeField({
      name: t,
      type: Pe,
      types: Ae,
      value: Me
    }));
    return [
      { type: "bytes32" },
      keccak256$2(encodeAbiParameters(Te.map(([Me]) => Me), Te.map(([, Me]) => Me)))
    ];
  }
  return [{ type: Ie }, Be];
}
function serializeTypedData(Ae) {
  const { domain: t, message: Ie, primaryType: Be, types: Pe } = Ae, Te = (je, fn) => {
    const Ve = { ...fn };
    for (const vn of je) {
      const { name: En, type: fi } = vn;
      fi === "address" && (Ve[En] = Ve[En].toLowerCase());
    }
    return Ve;
  }, Me = Pe.EIP712Domain ? t ? Te(Pe.EIP712Domain, t) : {} : {}, Ue = (() => {
    if (Be !== "EIP712Domain")
      return Te(Pe[Be], Ie);
  })();
  return stringify$2({ domain: Me, message: Ue, primaryType: Be, types: Pe });
}
function validateTypedData(Ae) {
  const { domain: t, message: Ie, primaryType: Be, types: Pe } = Ae, Te = (Me, Ue) => {
    for (const je of Me) {
      const { name: fn, type: Ve } = je, vn = Ue[fn], En = Ve.match(integerRegex);
      if (En && (typeof vn == "number" || typeof vn == "bigint")) {
        const [mi, _i, Ei] = En;
        numberToHex(vn, {
          signed: _i === "int",
          size: Number.parseInt(Ei) / 8
        });
      }
      if (Ve === "address" && typeof vn == "string" && !isAddress(vn))
        throw new InvalidAddressError({ address: vn });
      const fi = Ve.match(bytesRegex);
      if (fi) {
        const [mi, _i] = fi;
        if (_i && size$1(vn) !== Number.parseInt(_i))
          throw new BytesSizeMismatchError({
            expectedSize: Number.parseInt(_i),
            givenSize: size$1(vn)
          });
      }
      const bi = Pe[Ve];
      bi && (validateReference(Ve), Te(bi, vn));
    }
  };
  Pe.EIP712Domain && t && Te(Pe.EIP712Domain, t), Be !== "EIP712Domain" && Te(Pe[Be], Ie);
}
function getTypesForEIP712Domain({ domain: Ae }) {
  return [
    typeof (Ae == null ? void 0 : Ae.name) == "string" && { name: "name", type: "string" },
    (Ae == null ? void 0 : Ae.version) && { name: "version", type: "string" },
    typeof (Ae == null ? void 0 : Ae.chainId) == "number" && {
      name: "chainId",
      type: "uint256"
    },
    (Ae == null ? void 0 : Ae.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (Ae == null ? void 0 : Ae.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
function validateReference(Ae) {
  if (Ae === "address" || Ae === "bool" || Ae === "string" || Ae.startsWith("bytes") || Ae.startsWith("uint") || Ae.startsWith("int"))
    throw new InvalidStructTypeError({ type: Ae });
}
const presignMessagePrefix = `Ethereum Signed Message:
`;
function toPrefixedMessage(Ae) {
  const t = typeof Ae == "string" ? stringToHex(Ae) : typeof Ae.raw == "string" ? Ae.raw : bytesToHex$2(Ae.raw), Ie = stringToHex(`${presignMessagePrefix}${size$1(t)}`);
  return concat$3([Ie, t]);
}
function hashMessage$1(Ae, t) {
  return keccak256$2(toPrefixedMessage(Ae), t);
}
const erc6492MagicBytes = "0x6492649264926492649264926492649264926492649264926492649264926492";
function isErc6492Signature(Ae) {
  return sliceHex(Ae, -32) === erc6492MagicBytes;
}
function serializeErc6492Signature(Ae) {
  const { address: t, data: Ie, signature: Be, to: Pe = "hex" } = Ae, Te = concatHex([
    encodeAbiParameters([{ type: "address" }, { type: "bytes" }, { type: "bytes" }], [t, Ie, Be]),
    erc6492MagicBytes
  ]);
  return Pe === "hex" ? Te : hexToBytes$2(Te);
}
class InvalidDecimalNumberError extends BaseError$1 {
  constructor({ value: t }) {
    super(`Number \`${t}\` is not a valid decimal number.`, {
      name: "InvalidDecimalNumberError"
    });
  }
}
function parseUnits(Ae, t) {
  if (!/^(-?)([0-9]*)\.?([0-9]*)$/.test(Ae))
    throw new InvalidDecimalNumberError({ value: Ae });
  let [Ie, Be = "0"] = Ae.split(".");
  const Pe = Ie.startsWith("-");
  if (Pe && (Ie = Ie.slice(1)), Be = Be.replace(/(0+)$/, ""), t === 0)
    Math.round(+`.${Be}`) === 1 && (Ie = `${BigInt(Ie) + 1n}`), Be = "";
  else if (Be.length > t) {
    const [Te, Me, Ue] = [
      Be.slice(0, t - 1),
      Be.slice(t - 1, t),
      Be.slice(t)
    ], je = Math.round(+`${Me}.${Ue}`);
    je > 9 ? Be = `${BigInt(Te) + BigInt(1)}0`.padStart(Te.length + 1, "0") : Be = `${Te}${je}`, Be.length > t && (Be = Be.slice(1), Ie = `${BigInt(Ie) + 1n}`), Be = Be.slice(0, t);
  } else
    Be = Be.padEnd(t, "0");
  return BigInt(`${Pe ? "-" : ""}${Ie}${Be}`);
}
function parseEther(Ae, t = "wei") {
  return parseUnits(Ae, etherUnits[t]);
}
function formatStorageProof(Ae) {
  return Ae.map((t) => ({
    ...t,
    value: BigInt(t.value)
  }));
}
function formatProof(Ae) {
  return {
    ...Ae,
    balance: Ae.balance ? BigInt(Ae.balance) : void 0,
    nonce: Ae.nonce ? hexToNumber$2(Ae.nonce) : void 0,
    storageProof: Ae.storageProof ? formatStorageProof(Ae.storageProof) : void 0
  };
}
async function getProof(Ae, { address: t, blockNumber: Ie, blockTag: Be, storageKeys: Pe }) {
  const Te = Be ?? "latest", Me = Ie !== void 0 ? numberToHex(Ie) : void 0, Ue = await Ae.request({
    method: "eth_getProof",
    params: [t, Pe, Me || Te]
  });
  return formatProof(Ue);
}
async function getStorageAt(Ae, { address: t, blockNumber: Ie, blockTag: Be = "latest", slot: Pe }) {
  const Te = Ie !== void 0 ? numberToHex(Ie) : void 0;
  return await Ae.request({
    method: "eth_getStorageAt",
    params: [t, Pe, Te || Be]
  });
}
async function getTransaction(Ae, { blockHash: t, blockNumber: Ie, blockTag: Be, hash: Pe, index: Te }) {
  var Ve, vn, En;
  const Me = Be || "latest", Ue = Ie !== void 0 ? numberToHex(Ie) : void 0;
  let je = null;
  if (Pe ? je = await Ae.request({
    method: "eth_getTransactionByHash",
    params: [Pe]
  }, { dedupe: !0 }) : t ? je = await Ae.request({
    method: "eth_getTransactionByBlockHashAndIndex",
    params: [t, numberToHex(Te)]
  }, { dedupe: !0 }) : (Ue || Me) && (je = await Ae.request({
    method: "eth_getTransactionByBlockNumberAndIndex",
    params: [Ue || Me, numberToHex(Te)]
  }, { dedupe: !!Ue })), !je)
    throw new TransactionNotFoundError({
      blockHash: t,
      blockNumber: Ie,
      blockTag: Me,
      hash: Pe,
      index: Te
    });
  return (((En = (vn = (Ve = Ae.chain) == null ? void 0 : Ve.formatters) == null ? void 0 : vn.transaction) == null ? void 0 : En.format) || formatTransaction)(je);
}
async function getTransactionConfirmations(Ae, { hash: t, transactionReceipt: Ie }) {
  const [Be, Pe] = await Promise.all([
    getAction(Ae, getBlockNumber, "getBlockNumber")({}),
    t ? getAction(Ae, getTransaction, "getTransaction")({ hash: t }) : void 0
  ]), Te = (Ie == null ? void 0 : Ie.blockNumber) || (Pe == null ? void 0 : Pe.blockNumber);
  return Te ? Be - Te + 1n : 0n;
}
async function getTransactionReceipt(Ae, { hash: t }) {
  var Pe, Te, Me;
  const Ie = await Ae.request({
    method: "eth_getTransactionReceipt",
    params: [t]
  }, { dedupe: !0 });
  if (!Ie)
    throw new TransactionReceiptNotFoundError({ hash: t });
  return (((Me = (Te = (Pe = Ae.chain) == null ? void 0 : Pe.formatters) == null ? void 0 : Te.transactionReceipt) == null ? void 0 : Me.format) || formatTransactionReceipt)(Ie);
}
async function multicall(Ae, t) {
  var _i;
  const { allowFailure: Ie = !0, batchSize: Be, blockNumber: Pe, blockTag: Te, multicallAddress: Me, stateOverride: Ue } = t, je = t.contracts, fn = Be ?? (typeof ((_i = Ae.batch) == null ? void 0 : _i.multicall) == "object" && Ae.batch.multicall.batchSize || 1024);
  let Ve = Me;
  if (!Ve) {
    if (!Ae.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    Ve = getChainContractAddress({
      blockNumber: Pe,
      chain: Ae.chain,
      contract: "multicall3"
    });
  }
  const vn = [[]];
  let En = 0, fi = 0;
  for (let Ei = 0; Ei < je.length; Ei++) {
    const { abi: Si, address: Mi, args: Oi, functionName: Fi } = je[Ei];
    try {
      const Ui = encodeFunctionData({ abi: Si, args: Oi, functionName: Fi });
      fi += (Ui.length - 2) / 2, // Check if batching is enabled.
      fn > 0 && // Check if the current size of the batch exceeds the size limit.
      fi > fn && // Check if the current chunk is not already empty.
      vn[En].length > 0 && (En++, fi = (Ui.length - 2) / 2, vn[En] = []), vn[En] = [
        ...vn[En],
        {
          allowFailure: !0,
          callData: Ui,
          target: Mi
        }
      ];
    } catch (Ui) {
      const Pi = getContractError(Ui, {
        abi: Si,
        address: Mi,
        args: Oi,
        docsPath: "/docs/contract/multicall",
        functionName: Fi
      });
      if (!Ie)
        throw Pi;
      vn[En] = [
        ...vn[En],
        {
          allowFailure: !0,
          callData: "0x",
          target: Mi
        }
      ];
    }
  }
  const bi = await Promise.allSettled(vn.map((Ei) => getAction(Ae, readContract, "readContract")({
    abi: multicall3Abi,
    address: Ve,
    args: [Ei],
    blockNumber: Pe,
    blockTag: Te,
    functionName: "aggregate3",
    stateOverride: Ue
  }))), mi = [];
  for (let Ei = 0; Ei < bi.length; Ei++) {
    const Si = bi[Ei];
    if (Si.status === "rejected") {
      if (!Ie)
        throw Si.reason;
      for (let Oi = 0; Oi < vn[Ei].length; Oi++)
        mi.push({
          status: "failure",
          error: Si.reason,
          result: void 0
        });
      continue;
    }
    const Mi = Si.value;
    for (let Oi = 0; Oi < Mi.length; Oi++) {
      const { returnData: Fi, success: Ui } = Mi[Oi], { callData: Pi } = vn[Ei][Oi], { abi: Bi, address: ji, functionName: Zi, args: zi } = je[mi.length];
      try {
        if (Pi === "0x")
          throw new AbiDecodingZeroDataError();
        if (!Ui)
          throw new RawContractError({ data: Fi });
        const xi = decodeFunctionResult({
          abi: Bi,
          args: zi,
          data: Fi,
          functionName: Zi
        });
        mi.push(Ie ? { result: xi, status: "success" } : xi);
      } catch (xi) {
        const $i = getContractError(xi, {
          abi: Bi,
          address: ji,
          args: zi,
          docsPath: "/docs/contract/multicall",
          functionName: Zi
        });
        if (!Ie)
          throw $i;
        mi.push({ error: $i, result: void 0, status: "failure" });
      }
    }
  }
  if (mi.length !== je.length)
    throw new BaseError$1("multicall results mismatch");
  return mi;
}
let HMAC$1 = class extends Hash$1 {
  constructor(t, Ie) {
    super(), this.finished = !1, this.destroyed = !1, hash$3(t);
    const Be = toBytes$1(Ie);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const Pe = this.blockLen, Te = new Uint8Array(Pe);
    Te.set(Be.length > Pe ? t.create().update(Be).digest() : Be);
    for (let Me = 0; Me < Te.length; Me++)
      Te[Me] ^= 54;
    this.iHash.update(Te), this.oHash = t.create();
    for (let Me = 0; Me < Te.length; Me++)
      Te[Me] ^= 106;
    this.oHash.update(Te), Te.fill(0);
  }
  update(t) {
    return exists$1(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    exists$1(this), bytes$1(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: Ie, iHash: Be, finished: Pe, destroyed: Te, blockLen: Me, outputLen: Ue } = this;
    return t = t, t.finished = Pe, t.destroyed = Te, t.blockLen = Me, t.outputLen = Ue, t.oHash = Ie._cloneInto(t.oHash), t.iHash = Be._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const hmac$2 = (Ae, t, Ie) => new HMAC$1(Ae, t).update(Ie).digest();
hmac$2.create = (Ae, t) => new HMAC$1(Ae, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = /* @__PURE__ */ BigInt(0), _1n$4 = /* @__PURE__ */ BigInt(1), _2n$2 = /* @__PURE__ */ BigInt(2);
function isBytes$1(Ae) {
  return Ae instanceof Uint8Array || Ae != null && typeof Ae == "object" && Ae.constructor.name === "Uint8Array";
}
function abytes(Ae) {
  if (!isBytes$1(Ae))
    throw new Error("Uint8Array expected");
}
function abool(Ae, t) {
  if (typeof t != "boolean")
    throw new Error(`${Ae} must be valid boolean, got "${t}".`);
}
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (Ae, t) => t.toString(16).padStart(2, "0"));
function bytesToHex(Ae) {
  abytes(Ae);
  let t = "";
  for (let Ie = 0; Ie < Ae.length; Ie++)
    t += hexes[Ae[Ie]];
  return t;
}
function numberToHexUnpadded(Ae) {
  const t = Ae.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function hexToNumber(Ae) {
  if (typeof Ae != "string")
    throw new Error("hex string expected, got " + typeof Ae);
  return BigInt(Ae === "" ? "0" : `0x${Ae}`);
}
const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(Ae) {
  if (Ae >= asciis._0 && Ae <= asciis._9)
    return Ae - asciis._0;
  if (Ae >= asciis._A && Ae <= asciis._F)
    return Ae - (asciis._A - 10);
  if (Ae >= asciis._a && Ae <= asciis._f)
    return Ae - (asciis._a - 10);
}
function hexToBytes(Ae) {
  if (typeof Ae != "string")
    throw new Error("hex string expected, got " + typeof Ae);
  const t = Ae.length, Ie = t / 2;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const Be = new Uint8Array(Ie);
  for (let Pe = 0, Te = 0; Pe < Ie; Pe++, Te += 2) {
    const Me = asciiToBase16(Ae.charCodeAt(Te)), Ue = asciiToBase16(Ae.charCodeAt(Te + 1));
    if (Me === void 0 || Ue === void 0) {
      const je = Ae[Te] + Ae[Te + 1];
      throw new Error('hex string expected, got non-hex character "' + je + '" at index ' + Te);
    }
    Be[Pe] = Me * 16 + Ue;
  }
  return Be;
}
function bytesToNumberBE(Ae) {
  return hexToNumber(bytesToHex(Ae));
}
function bytesToNumberLE(Ae) {
  return abytes(Ae), hexToNumber(bytesToHex(Uint8Array.from(Ae).reverse()));
}
function numberToBytesBE(Ae, t) {
  return hexToBytes(Ae.toString(16).padStart(t * 2, "0"));
}
function numberToBytesLE(Ae, t) {
  return numberToBytesBE(Ae, t).reverse();
}
function numberToVarBytesBE(Ae) {
  return hexToBytes(numberToHexUnpadded(Ae));
}
function ensureBytes(Ae, t, Ie) {
  let Be;
  if (typeof t == "string")
    try {
      Be = hexToBytes(t);
    } catch (Te) {
      throw new Error(`${Ae} must be valid hex string, got "${t}". Cause: ${Te}`);
    }
  else if (isBytes$1(t))
    Be = Uint8Array.from(t);
  else
    throw new Error(`${Ae} must be hex string or Uint8Array`);
  const Pe = Be.length;
  if (typeof Ie == "number" && Pe !== Ie)
    throw new Error(`${Ae} expected ${Ie} bytes, got ${Pe}`);
  return Be;
}
function concatBytes(...Ae) {
  let t = 0;
  for (let Be = 0; Be < Ae.length; Be++) {
    const Pe = Ae[Be];
    abytes(Pe), t += Pe.length;
  }
  const Ie = new Uint8Array(t);
  for (let Be = 0, Pe = 0; Be < Ae.length; Be++) {
    const Te = Ae[Be];
    Ie.set(Te, Pe), Pe += Te.length;
  }
  return Ie;
}
function equalBytes(Ae, t) {
  if (Ae.length !== t.length)
    return !1;
  let Ie = 0;
  for (let Be = 0; Be < Ae.length; Be++)
    Ie |= Ae[Be] ^ t[Be];
  return Ie === 0;
}
function utf8ToBytes(Ae) {
  if (typeof Ae != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof Ae}`);
  return new Uint8Array(new TextEncoder().encode(Ae));
}
const isPosBig = (Ae) => typeof Ae == "bigint" && _0n$3 <= Ae;
function inRange(Ae, t, Ie) {
  return isPosBig(Ae) && isPosBig(t) && isPosBig(Ie) && t <= Ae && Ae < Ie;
}
function aInRange(Ae, t, Ie, Be) {
  if (!inRange(t, Ie, Be))
    throw new Error(`expected valid ${Ae}: ${Ie} <= n < ${Be}, got ${typeof t} ${t}`);
}
function bitLen(Ae) {
  let t;
  for (t = 0; Ae > _0n$3; Ae >>= _1n$4, t += 1)
    ;
  return t;
}
function bitGet(Ae, t) {
  return Ae >> BigInt(t) & _1n$4;
}
function bitSet(Ae, t, Ie) {
  return Ae | (Ie ? _1n$4 : _0n$3) << BigInt(t);
}
const bitMask = (Ae) => (_2n$2 << BigInt(Ae - 1)) - _1n$4, u8n = (Ae) => new Uint8Array(Ae), u8fr = (Ae) => Uint8Array.from(Ae);
function createHmacDrbg(Ae, t, Ie) {
  if (typeof Ae != "number" || Ae < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof Ie != "function")
    throw new Error("hmacFn must be a function");
  let Be = u8n(Ae), Pe = u8n(Ae), Te = 0;
  const Me = () => {
    Be.fill(1), Pe.fill(0), Te = 0;
  }, Ue = (...vn) => Ie(Pe, Be, ...vn), je = (vn = u8n()) => {
    Pe = Ue(u8fr([0]), vn), Be = Ue(), vn.length !== 0 && (Pe = Ue(u8fr([1]), vn), Be = Ue());
  }, fn = () => {
    if (Te++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let vn = 0;
    const En = [];
    for (; vn < t; ) {
      Be = Ue();
      const fi = Be.slice();
      En.push(fi), vn += Be.length;
    }
    return concatBytes(...En);
  };
  return (vn, En) => {
    Me(), je(vn);
    let fi;
    for (; !(fi = En(fn())); )
      je();
    return Me(), fi;
  };
}
const validatorFns = {
  bigint: (Ae) => typeof Ae == "bigint",
  function: (Ae) => typeof Ae == "function",
  boolean: (Ae) => typeof Ae == "boolean",
  string: (Ae) => typeof Ae == "string",
  stringOrUint8Array: (Ae) => typeof Ae == "string" || isBytes$1(Ae),
  isSafeInteger: (Ae) => Number.isSafeInteger(Ae),
  array: (Ae) => Array.isArray(Ae),
  field: (Ae, t) => t.Fp.isValid(Ae),
  hash: (Ae) => typeof Ae == "function" && Number.isSafeInteger(Ae.outputLen)
};
function validateObject(Ae, t, Ie = {}) {
  const Be = (Pe, Te, Me) => {
    const Ue = validatorFns[Te];
    if (typeof Ue != "function")
      throw new Error(`Invalid validator "${Te}", expected function`);
    const je = Ae[Pe];
    if (!(Me && je === void 0) && !Ue(je, Ae))
      throw new Error(`Invalid param ${String(Pe)}=${je} (${typeof je}), expected ${Te}`);
  };
  for (const [Pe, Te] of Object.entries(t))
    Be(Pe, Te, !1);
  for (const [Pe, Te] of Object.entries(Ie))
    Be(Pe, Te, !0);
  return Ae;
}
const notImplemented = () => {
  throw new Error("not implemented");
};
function memoized(Ae) {
  const t = /* @__PURE__ */ new WeakMap();
  return (Ie, ...Be) => {
    const Pe = t.get(Ie);
    if (Pe !== void 0)
      return Pe;
    const Te = Ae(Ie, ...Be);
    return t.set(Ie, Te), Te;
  };
}
const ut$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aInRange,
  abool,
  abytes,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes,
  hexToNumber,
  inRange,
  isBytes: isBytes$1,
  memoized,
  notImplemented,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$3 = BigInt(1), _2n$1 = BigInt(2), _3n$1 = BigInt(3), _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
BigInt(9);
BigInt(16);
function mod(Ae, t) {
  const Ie = Ae % t;
  return Ie >= _0n$2 ? Ie : t + Ie;
}
function pow(Ae, t, Ie) {
  if (Ie <= _0n$2 || t < _0n$2)
    throw new Error("Expected power/modulo > 0");
  if (Ie === _1n$3)
    return _0n$2;
  let Be = _1n$3;
  for (; t > _0n$2; )
    t & _1n$3 && (Be = Be * Ae % Ie), Ae = Ae * Ae % Ie, t >>= _1n$3;
  return Be;
}
function pow2(Ae, t, Ie) {
  let Be = Ae;
  for (; t-- > _0n$2; )
    Be *= Be, Be %= Ie;
  return Be;
}
function invert(Ae, t) {
  if (Ae === _0n$2 || t <= _0n$2)
    throw new Error(`invert: expected positive integers, got n=${Ae} mod=${t}`);
  let Ie = mod(Ae, t), Be = t, Pe = _0n$2, Te = _1n$3;
  for (; Ie !== _0n$2; ) {
    const Ue = Be / Ie, je = Be % Ie, fn = Pe - Te * Ue;
    Be = Ie, Ie = je, Pe = Te, Te = fn;
  }
  if (Be !== _1n$3)
    throw new Error("invert: does not exist");
  return mod(Pe, t);
}
function tonelliShanks(Ae) {
  const t = (Ae - _1n$3) / _2n$1;
  let Ie, Be, Pe;
  for (Ie = Ae - _1n$3, Be = 0; Ie % _2n$1 === _0n$2; Ie /= _2n$1, Be++)
    ;
  for (Pe = _2n$1; Pe < Ae && pow(Pe, t, Ae) !== Ae - _1n$3; Pe++)
    ;
  if (Be === 1) {
    const Me = (Ae + _1n$3) / _4n;
    return function(je, fn) {
      const Ve = je.pow(fn, Me);
      if (!je.eql(je.sqr(Ve), fn))
        throw new Error("Cannot find square root");
      return Ve;
    };
  }
  const Te = (Ie + _1n$3) / _2n$1;
  return function(Ue, je) {
    if (Ue.pow(je, t) === Ue.neg(Ue.ONE))
      throw new Error("Cannot find square root");
    let fn = Be, Ve = Ue.pow(Ue.mul(Ue.ONE, Pe), Ie), vn = Ue.pow(je, Te), En = Ue.pow(je, Ie);
    for (; !Ue.eql(En, Ue.ONE); ) {
      if (Ue.eql(En, Ue.ZERO))
        return Ue.ZERO;
      let fi = 1;
      for (let mi = Ue.sqr(En); fi < fn && !Ue.eql(mi, Ue.ONE); fi++)
        mi = Ue.sqr(mi);
      const bi = Ue.pow(Ve, _1n$3 << BigInt(fn - fi - 1));
      Ve = Ue.sqr(bi), vn = Ue.mul(vn, bi), En = Ue.mul(En, Ve), fn = fi;
    }
    return vn;
  };
}
function FpSqrt(Ae) {
  if (Ae % _4n === _3n$1) {
    const t = (Ae + _1n$3) / _4n;
    return function(Be, Pe) {
      const Te = Be.pow(Pe, t);
      if (!Be.eql(Be.sqr(Te), Pe))
        throw new Error("Cannot find square root");
      return Te;
    };
  }
  if (Ae % _8n === _5n) {
    const t = (Ae - _5n) / _8n;
    return function(Be, Pe) {
      const Te = Be.mul(Pe, _2n$1), Me = Be.pow(Te, t), Ue = Be.mul(Pe, Me), je = Be.mul(Be.mul(Ue, _2n$1), Me), fn = Be.mul(Ue, Be.sub(je, Be.ONE));
      if (!Be.eql(Be.sqr(fn), Pe))
        throw new Error("Cannot find square root");
      return fn;
    };
  }
  return tonelliShanks(Ae);
}
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(Ae) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, Ie = FIELD_FIELDS.reduce((Be, Pe) => (Be[Pe] = "function", Be), t);
  return validateObject(Ae, Ie);
}
function FpPow(Ae, t, Ie) {
  if (Ie < _0n$2)
    throw new Error("Expected power > 0");
  if (Ie === _0n$2)
    return Ae.ONE;
  if (Ie === _1n$3)
    return t;
  let Be = Ae.ONE, Pe = t;
  for (; Ie > _0n$2; )
    Ie & _1n$3 && (Be = Ae.mul(Be, Pe)), Pe = Ae.sqr(Pe), Ie >>= _1n$3;
  return Be;
}
function FpInvertBatch(Ae, t) {
  const Ie = new Array(t.length), Be = t.reduce((Te, Me, Ue) => Ae.is0(Me) ? Te : (Ie[Ue] = Te, Ae.mul(Te, Me)), Ae.ONE), Pe = Ae.inv(Be);
  return t.reduceRight((Te, Me, Ue) => Ae.is0(Me) ? Te : (Ie[Ue] = Ae.mul(Te, Ie[Ue]), Ae.mul(Te, Me)), Pe), Ie;
}
function nLength(Ae, t) {
  const Ie = t !== void 0 ? t : Ae.toString(2).length, Be = Math.ceil(Ie / 8);
  return { nBitLength: Ie, nByteLength: Be };
}
function Field(Ae, t, Ie = !1, Be = {}) {
  if (Ae <= _0n$2)
    throw new Error(`Expected Field ORDER > 0, got ${Ae}`);
  const { nBitLength: Pe, nByteLength: Te } = nLength(Ae, t);
  if (Te > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const Me = FpSqrt(Ae), Ue = Object.freeze({
    ORDER: Ae,
    BITS: Pe,
    BYTES: Te,
    MASK: bitMask(Pe),
    ZERO: _0n$2,
    ONE: _1n$3,
    create: (je) => mod(je, Ae),
    isValid: (je) => {
      if (typeof je != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof je}`);
      return _0n$2 <= je && je < Ae;
    },
    is0: (je) => je === _0n$2,
    isOdd: (je) => (je & _1n$3) === _1n$3,
    neg: (je) => mod(-je, Ae),
    eql: (je, fn) => je === fn,
    sqr: (je) => mod(je * je, Ae),
    add: (je, fn) => mod(je + fn, Ae),
    sub: (je, fn) => mod(je - fn, Ae),
    mul: (je, fn) => mod(je * fn, Ae),
    pow: (je, fn) => FpPow(Ue, je, fn),
    div: (je, fn) => mod(je * invert(fn, Ae), Ae),
    // Same as above, but doesn't normalize
    sqrN: (je) => je * je,
    addN: (je, fn) => je + fn,
    subN: (je, fn) => je - fn,
    mulN: (je, fn) => je * fn,
    inv: (je) => invert(je, Ae),
    sqrt: Be.sqrt || ((je) => Me(Ue, je)),
    invertBatch: (je) => FpInvertBatch(Ue, je),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (je, fn, Ve) => Ve ? fn : je,
    toBytes: (je) => Ie ? numberToBytesLE(je, Te) : numberToBytesBE(je, Te),
    fromBytes: (je) => {
      if (je.length !== Te)
        throw new Error(`Fp.fromBytes: expected ${Te}, got ${je.length}`);
      return Ie ? bytesToNumberLE(je) : bytesToNumberBE(je);
    }
  });
  return Object.freeze(Ue);
}
function getFieldBytesLength(Ae) {
  if (typeof Ae != "bigint")
    throw new Error("field order must be bigint");
  const t = Ae.toString(2).length;
  return Math.ceil(t / 8);
}
function getMinHashLength(Ae) {
  const t = getFieldBytesLength(Ae);
  return t + Math.ceil(t / 2);
}
function mapHashToField(Ae, t, Ie = !1) {
  const Be = Ae.length, Pe = getFieldBytesLength(t), Te = getMinHashLength(t);
  if (Be < 16 || Be < Te || Be > 1024)
    throw new Error(`expected ${Te}-1024 bytes of input, got ${Be}`);
  const Me = Ie ? bytesToNumberBE(Ae) : bytesToNumberLE(Ae), Ue = mod(Me, t - _1n$3) + _1n$3;
  return Ie ? numberToBytesLE(Ue, Pe) : numberToBytesBE(Ue, Pe);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$1 = BigInt(0), _1n$2 = BigInt(1), pointPrecomputes = /* @__PURE__ */ new WeakMap(), pointWindowSizes = /* @__PURE__ */ new WeakMap();
function wNAF(Ae, t) {
  const Ie = (Te, Me) => {
    const Ue = Me.negate();
    return Te ? Ue : Me;
  }, Be = (Te) => {
    if (!Number.isSafeInteger(Te) || Te <= 0 || Te > t)
      throw new Error(`Wrong window size=${Te}, should be [1..${t}]`);
  }, Pe = (Te) => {
    Be(Te);
    const Me = Math.ceil(t / Te) + 1, Ue = 2 ** (Te - 1);
    return { windows: Me, windowSize: Ue };
  };
  return {
    constTimeNegate: Ie,
    // non-const time multiplication ladder
    unsafeLadder(Te, Me) {
      let Ue = Ae.ZERO, je = Te;
      for (; Me > _0n$1; )
        Me & _1n$2 && (Ue = Ue.add(je)), je = je.double(), Me >>= _1n$2;
      return Ue;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(Te, Me) {
      const { windows: Ue, windowSize: je } = Pe(Me), fn = [];
      let Ve = Te, vn = Ve;
      for (let En = 0; En < Ue; En++) {
        vn = Ve, fn.push(vn);
        for (let fi = 1; fi < je; fi++)
          vn = vn.add(Ve), fn.push(vn);
        Ve = vn.double();
      }
      return fn;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(Te, Me, Ue) {
      const { windows: je, windowSize: fn } = Pe(Te);
      let Ve = Ae.ZERO, vn = Ae.BASE;
      const En = BigInt(2 ** Te - 1), fi = 2 ** Te, bi = BigInt(Te);
      for (let mi = 0; mi < je; mi++) {
        const _i = mi * fn;
        let Ei = Number(Ue & En);
        Ue >>= bi, Ei > fn && (Ei -= fi, Ue += _1n$2);
        const Si = _i, Mi = _i + Math.abs(Ei) - 1, Oi = mi % 2 !== 0, Fi = Ei < 0;
        Ei === 0 ? vn = vn.add(Ie(Oi, Me[Si])) : Ve = Ve.add(Ie(Fi, Me[Mi]));
      }
      return { p: Ve, f: vn };
    },
    wNAFCached(Te, Me, Ue) {
      const je = pointWindowSizes.get(Te) || 1;
      let fn = pointPrecomputes.get(Te);
      return fn || (fn = this.precomputeWindow(Te, je), je !== 1 && pointPrecomputes.set(Te, Ue(fn))), this.wNAF(je, fn, Me);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(Te, Me) {
      Be(Me), pointWindowSizes.set(Te, Me), pointPrecomputes.delete(Te);
    }
  };
}
function pippenger(Ae, t, Ie, Be) {
  if (!Array.isArray(Ie) || !Array.isArray(Be) || Be.length !== Ie.length)
    throw new Error("arrays of points and scalars must have equal length");
  Be.forEach((Ve, vn) => {
    if (!t.isValid(Ve))
      throw new Error(`wrong scalar at index ${vn}`);
  }), Ie.forEach((Ve, vn) => {
    if (!(Ve instanceof Ae))
      throw new Error(`wrong point at index ${vn}`);
  });
  const Pe = bitLen(BigInt(Ie.length)), Te = Pe > 12 ? Pe - 3 : Pe > 4 ? Pe - 2 : Pe ? 2 : 1, Me = (1 << Te) - 1, Ue = new Array(Me + 1).fill(Ae.ZERO), je = Math.floor((t.BITS - 1) / Te) * Te;
  let fn = Ae.ZERO;
  for (let Ve = je; Ve >= 0; Ve -= Te) {
    Ue.fill(Ae.ZERO);
    for (let En = 0; En < Be.length; En++) {
      const fi = Be[En], bi = Number(fi >> BigInt(Ve) & BigInt(Me));
      Ue[bi] = Ue[bi].add(Ie[En]);
    }
    let vn = Ae.ZERO;
    for (let En = Ue.length - 1, fi = Ae.ZERO; En > 0; En--)
      fi = fi.add(Ue[En]), vn = vn.add(fi);
    if (fn = fn.add(vn), Ve !== 0)
      for (let En = 0; En < Te; En++)
        fn = fn.double();
  }
  return fn;
}
function validateBasic(Ae) {
  return validateField(Ae.Fp), validateObject(Ae, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...nLength(Ae.n, Ae.nBitLength),
    ...Ae,
    p: Ae.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validateSigVerOpts(Ae) {
  Ae.lowS !== void 0 && abool("lowS", Ae.lowS), Ae.prehash !== void 0 && abool("prehash", Ae.prehash);
}
function validatePointOpts(Ae) {
  const t = validateBasic(Ae);
  validateObject(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: Ie, Fp: Be, a: Pe } = t;
  if (Ie) {
    if (!Be.eql(Pe, Be.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof Ie != "object" || typeof Ie.beta != "bigint" || typeof Ie.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut$3, DER = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(t = "") {
      super(t);
    }
  },
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (Ae, t) => {
      const { Err: Ie } = DER;
      if (Ae < 0 || Ae > 256)
        throw new Ie("tlv.encode: wrong tag");
      if (t.length & 1)
        throw new Ie("tlv.encode: unpadded data");
      const Be = t.length / 2, Pe = numberToHexUnpadded(Be);
      if (Pe.length / 2 & 128)
        throw new Ie("tlv.encode: long form length too big");
      const Te = Be > 127 ? numberToHexUnpadded(Pe.length / 2 | 128) : "";
      return `${numberToHexUnpadded(Ae)}${Te}${Pe}${t}`;
    },
    // v - value, l - left bytes (unparsed)
    decode(Ae, t) {
      const { Err: Ie } = DER;
      let Be = 0;
      if (Ae < 0 || Ae > 256)
        throw new Ie("tlv.encode: wrong tag");
      if (t.length < 2 || t[Be++] !== Ae)
        throw new Ie("tlv.decode: wrong tlv");
      const Pe = t[Be++], Te = !!(Pe & 128);
      let Me = 0;
      if (!Te)
        Me = Pe;
      else {
        const je = Pe & 127;
        if (!je)
          throw new Ie("tlv.decode(long): indefinite length not supported");
        if (je > 4)
          throw new Ie("tlv.decode(long): byte length is too big");
        const fn = t.subarray(Be, Be + je);
        if (fn.length !== je)
          throw new Ie("tlv.decode: length bytes not complete");
        if (fn[0] === 0)
          throw new Ie("tlv.decode(long): zero leftmost byte");
        for (const Ve of fn)
          Me = Me << 8 | Ve;
        if (Be += je, Me < 128)
          throw new Ie("tlv.decode(long): not minimal encoding");
      }
      const Ue = t.subarray(Be, Be + Me);
      if (Ue.length !== Me)
        throw new Ie("tlv.decode: wrong value length");
      return { v: Ue, l: t.subarray(Be + Me) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(Ae) {
      const { Err: t } = DER;
      if (Ae < _0n)
        throw new t("integer: negative integers are not allowed");
      let Ie = numberToHexUnpadded(Ae);
      if (Number.parseInt(Ie[0], 16) & 8 && (Ie = "00" + Ie), Ie.length & 1)
        throw new t("unexpected assertion");
      return Ie;
    },
    decode(Ae) {
      const { Err: t } = DER;
      if (Ae[0] & 128)
        throw new t("Invalid signature integer: negative");
      if (Ae[0] === 0 && !(Ae[1] & 128))
        throw new t("Invalid signature integer: unnecessary leading zero");
      return b2n(Ae);
    }
  },
  toSig(Ae) {
    const { Err: t, _int: Ie, _tlv: Be } = DER, Pe = typeof Ae == "string" ? h2b(Ae) : Ae;
    abytes(Pe);
    const { v: Te, l: Me } = Be.decode(48, Pe);
    if (Me.length)
      throw new t("Invalid signature: left bytes after parsing");
    const { v: Ue, l: je } = Be.decode(2, Te), { v: fn, l: Ve } = Be.decode(2, je);
    if (Ve.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: Ie.decode(Ue), s: Ie.decode(fn) };
  },
  hexFromSig(Ae) {
    const { _tlv: t, _int: Ie } = DER, Be = `${t.encode(2, Ie.encode(Ae.r))}${t.encode(2, Ie.encode(Ae.s))}`;
    return t.encode(48, Be);
  }
}, _0n = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(Ae) {
  const t = validatePointOpts(Ae), { Fp: Ie } = t, Be = Field(t.n, t.nBitLength), Pe = t.toBytes || ((mi, _i, Ei) => {
    const Si = _i.toAffine();
    return concatBytes(Uint8Array.from([4]), Ie.toBytes(Si.x), Ie.toBytes(Si.y));
  }), Te = t.fromBytes || ((mi) => {
    const _i = mi.subarray(1), Ei = Ie.fromBytes(_i.subarray(0, Ie.BYTES)), Si = Ie.fromBytes(_i.subarray(Ie.BYTES, 2 * Ie.BYTES));
    return { x: Ei, y: Si };
  });
  function Me(mi) {
    const { a: _i, b: Ei } = t, Si = Ie.sqr(mi), Mi = Ie.mul(Si, mi);
    return Ie.add(Ie.add(Mi, Ie.mul(mi, _i)), Ei);
  }
  if (!Ie.eql(Ie.sqr(t.Gy), Me(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function Ue(mi) {
    return inRange(mi, _1n$1, t.n);
  }
  function je(mi) {
    const { allowedPrivateKeyLengths: _i, nByteLength: Ei, wrapPrivateKey: Si, n: Mi } = t;
    if (_i && typeof mi != "bigint") {
      if (isBytes$1(mi) && (mi = bytesToHex(mi)), typeof mi != "string" || !_i.includes(mi.length))
        throw new Error("Invalid key");
      mi = mi.padStart(Ei * 2, "0");
    }
    let Oi;
    try {
      Oi = typeof mi == "bigint" ? mi : bytesToNumberBE(ensureBytes("private key", mi, Ei));
    } catch {
      throw new Error(`private key must be ${Ei} bytes, hex or bigint, not ${typeof mi}`);
    }
    return Si && (Oi = mod(Oi, Mi)), aInRange("private key", Oi, _1n$1, Mi), Oi;
  }
  function fn(mi) {
    if (!(mi instanceof En))
      throw new Error("ProjectivePoint expected");
  }
  const Ve = memoized((mi, _i) => {
    const { px: Ei, py: Si, pz: Mi } = mi;
    if (Ie.eql(Mi, Ie.ONE))
      return { x: Ei, y: Si };
    const Oi = mi.is0();
    _i == null && (_i = Oi ? Ie.ONE : Ie.inv(Mi));
    const Fi = Ie.mul(Ei, _i), Ui = Ie.mul(Si, _i), Pi = Ie.mul(Mi, _i);
    if (Oi)
      return { x: Ie.ZERO, y: Ie.ZERO };
    if (!Ie.eql(Pi, Ie.ONE))
      throw new Error("invZ was invalid");
    return { x: Fi, y: Ui };
  }), vn = memoized((mi) => {
    if (mi.is0()) {
      if (t.allowInfinityPoint && !Ie.is0(mi.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: _i, y: Ei } = mi.toAffine();
    if (!Ie.isValid(_i) || !Ie.isValid(Ei))
      throw new Error("bad point: x or y not FE");
    const Si = Ie.sqr(Ei), Mi = Me(_i);
    if (!Ie.eql(Si, Mi))
      throw new Error("bad point: equation left != right");
    if (!mi.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  class En {
    constructor(_i, Ei, Si) {
      if (this.px = _i, this.py = Ei, this.pz = Si, _i == null || !Ie.isValid(_i))
        throw new Error("x required");
      if (Ei == null || !Ie.isValid(Ei))
        throw new Error("y required");
      if (Si == null || !Ie.isValid(Si))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(_i) {
      const { x: Ei, y: Si } = _i || {};
      if (!_i || !Ie.isValid(Ei) || !Ie.isValid(Si))
        throw new Error("invalid affine point");
      if (_i instanceof En)
        throw new Error("projective point not allowed");
      const Mi = (Oi) => Ie.eql(Oi, Ie.ZERO);
      return Mi(Ei) && Mi(Si) ? En.ZERO : new En(Ei, Si, Ie.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(_i) {
      const Ei = Ie.invertBatch(_i.map((Si) => Si.pz));
      return _i.map((Si, Mi) => Si.toAffine(Ei[Mi])).map(En.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(_i) {
      const Ei = En.fromAffine(Te(ensureBytes("pointHex", _i)));
      return Ei.assertValidity(), Ei;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(_i) {
      return En.BASE.multiply(je(_i));
    }
    // Multiscalar Multiplication
    static msm(_i, Ei) {
      return pippenger(En, Be, _i, Ei);
    }
    // "Private method", don't use it directly
    _setWindowSize(_i) {
      bi.setWindowSize(this, _i);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      vn(this);
    }
    hasEvenY() {
      const { y: _i } = this.toAffine();
      if (Ie.isOdd)
        return !Ie.isOdd(_i);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(_i) {
      fn(_i);
      const { px: Ei, py: Si, pz: Mi } = this, { px: Oi, py: Fi, pz: Ui } = _i, Pi = Ie.eql(Ie.mul(Ei, Ui), Ie.mul(Oi, Mi)), Bi = Ie.eql(Ie.mul(Si, Ui), Ie.mul(Fi, Mi));
      return Pi && Bi;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new En(this.px, Ie.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: _i, b: Ei } = t, Si = Ie.mul(Ei, _3n), { px: Mi, py: Oi, pz: Fi } = this;
      let Ui = Ie.ZERO, Pi = Ie.ZERO, Bi = Ie.ZERO, ji = Ie.mul(Mi, Mi), Zi = Ie.mul(Oi, Oi), zi = Ie.mul(Fi, Fi), xi = Ie.mul(Mi, Oi);
      return xi = Ie.add(xi, xi), Bi = Ie.mul(Mi, Fi), Bi = Ie.add(Bi, Bi), Ui = Ie.mul(_i, Bi), Pi = Ie.mul(Si, zi), Pi = Ie.add(Ui, Pi), Ui = Ie.sub(Zi, Pi), Pi = Ie.add(Zi, Pi), Pi = Ie.mul(Ui, Pi), Ui = Ie.mul(xi, Ui), Bi = Ie.mul(Si, Bi), zi = Ie.mul(_i, zi), xi = Ie.sub(ji, zi), xi = Ie.mul(_i, xi), xi = Ie.add(xi, Bi), Bi = Ie.add(ji, ji), ji = Ie.add(Bi, ji), ji = Ie.add(ji, zi), ji = Ie.mul(ji, xi), Pi = Ie.add(Pi, ji), zi = Ie.mul(Oi, Fi), zi = Ie.add(zi, zi), ji = Ie.mul(zi, xi), Ui = Ie.sub(Ui, ji), Bi = Ie.mul(zi, Zi), Bi = Ie.add(Bi, Bi), Bi = Ie.add(Bi, Bi), new En(Ui, Pi, Bi);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(_i) {
      fn(_i);
      const { px: Ei, py: Si, pz: Mi } = this, { px: Oi, py: Fi, pz: Ui } = _i;
      let Pi = Ie.ZERO, Bi = Ie.ZERO, ji = Ie.ZERO;
      const Zi = t.a, zi = Ie.mul(t.b, _3n);
      let xi = Ie.mul(Ei, Oi), $i = Ie.mul(Si, Fi), vi = Ie.mul(Mi, Ui), wi = Ie.add(Ei, Si), Ai = Ie.add(Oi, Fi);
      wi = Ie.mul(wi, Ai), Ai = Ie.add(xi, $i), wi = Ie.sub(wi, Ai), Ai = Ie.add(Ei, Mi);
      let Ri = Ie.add(Oi, Ui);
      return Ai = Ie.mul(Ai, Ri), Ri = Ie.add(xi, vi), Ai = Ie.sub(Ai, Ri), Ri = Ie.add(Si, Mi), Pi = Ie.add(Fi, Ui), Ri = Ie.mul(Ri, Pi), Pi = Ie.add($i, vi), Ri = Ie.sub(Ri, Pi), ji = Ie.mul(Zi, Ai), Pi = Ie.mul(zi, vi), ji = Ie.add(Pi, ji), Pi = Ie.sub($i, ji), ji = Ie.add($i, ji), Bi = Ie.mul(Pi, ji), $i = Ie.add(xi, xi), $i = Ie.add($i, xi), vi = Ie.mul(Zi, vi), Ai = Ie.mul(zi, Ai), $i = Ie.add($i, vi), vi = Ie.sub(xi, vi), vi = Ie.mul(Zi, vi), Ai = Ie.add(Ai, vi), xi = Ie.mul($i, Ai), Bi = Ie.add(Bi, xi), xi = Ie.mul(Ri, Ai), Pi = Ie.mul(wi, Pi), Pi = Ie.sub(Pi, xi), xi = Ie.mul(wi, $i), ji = Ie.mul(Ri, ji), ji = Ie.add(ji, xi), new En(Pi, Bi, ji);
    }
    subtract(_i) {
      return this.add(_i.negate());
    }
    is0() {
      return this.equals(En.ZERO);
    }
    wNAF(_i) {
      return bi.wNAFCached(this, _i, En.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(_i) {
      aInRange("scalar", _i, _0n, t.n);
      const Ei = En.ZERO;
      if (_i === _0n)
        return Ei;
      if (_i === _1n$1)
        return this;
      const { endo: Si } = t;
      if (!Si)
        return bi.unsafeLadder(this, _i);
      let { k1neg: Mi, k1: Oi, k2neg: Fi, k2: Ui } = Si.splitScalar(_i), Pi = Ei, Bi = Ei, ji = this;
      for (; Oi > _0n || Ui > _0n; )
        Oi & _1n$1 && (Pi = Pi.add(ji)), Ui & _1n$1 && (Bi = Bi.add(ji)), ji = ji.double(), Oi >>= _1n$1, Ui >>= _1n$1;
      return Mi && (Pi = Pi.negate()), Fi && (Bi = Bi.negate()), Bi = new En(Ie.mul(Bi.px, Si.beta), Bi.py, Bi.pz), Pi.add(Bi);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(_i) {
      const { endo: Ei, n: Si } = t;
      aInRange("scalar", _i, _1n$1, Si);
      let Mi, Oi;
      if (Ei) {
        const { k1neg: Fi, k1: Ui, k2neg: Pi, k2: Bi } = Ei.splitScalar(_i);
        let { p: ji, f: Zi } = this.wNAF(Ui), { p: zi, f: xi } = this.wNAF(Bi);
        ji = bi.constTimeNegate(Fi, ji), zi = bi.constTimeNegate(Pi, zi), zi = new En(Ie.mul(zi.px, Ei.beta), zi.py, zi.pz), Mi = ji.add(zi), Oi = Zi.add(xi);
      } else {
        const { p: Fi, f: Ui } = this.wNAF(_i);
        Mi = Fi, Oi = Ui;
      }
      return En.normalizeZ([Mi, Oi])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(_i, Ei, Si) {
      const Mi = En.BASE, Oi = (Ui, Pi) => Pi === _0n || Pi === _1n$1 || !Ui.equals(Mi) ? Ui.multiplyUnsafe(Pi) : Ui.multiply(Pi), Fi = Oi(this, Ei).add(Oi(_i, Si));
      return Fi.is0() ? void 0 : Fi;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(_i) {
      return Ve(this, _i);
    }
    isTorsionFree() {
      const { h: _i, isTorsionFree: Ei } = t;
      if (_i === _1n$1)
        return !0;
      if (Ei)
        return Ei(En, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: _i, clearCofactor: Ei } = t;
      return _i === _1n$1 ? this : Ei ? Ei(En, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(_i = !0) {
      return abool("isCompressed", _i), this.assertValidity(), Pe(En, this, _i);
    }
    toHex(_i = !0) {
      return abool("isCompressed", _i), bytesToHex(this.toRawBytes(_i));
    }
  }
  En.BASE = new En(t.Gx, t.Gy, Ie.ONE), En.ZERO = new En(Ie.ZERO, Ie.ONE, Ie.ZERO);
  const fi = t.nBitLength, bi = wNAF(En, t.endo ? Math.ceil(fi / 2) : fi);
  return {
    CURVE: t,
    ProjectivePoint: En,
    normPrivateKeyToScalar: je,
    weierstrassEquation: Me,
    isWithinCurveOrder: Ue
  };
}
function validateOpts(Ae) {
  const t = validateBasic(Ae);
  return validateObject(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function weierstrass(Ae) {
  const t = validateOpts(Ae), { Fp: Ie, n: Be } = t, Pe = Ie.BYTES + 1, Te = 2 * Ie.BYTES + 1;
  function Me(vi) {
    return mod(vi, Be);
  }
  function Ue(vi) {
    return invert(vi, Be);
  }
  const { ProjectivePoint: je, normPrivateKeyToScalar: fn, weierstrassEquation: Ve, isWithinCurveOrder: vn } = weierstrassPoints({
    ...t,
    toBytes(vi, wi, Ai) {
      const Ri = wi.toAffine(), Ti = Ie.toBytes(Ri.x), Ci = concatBytes;
      return abool("isCompressed", Ai), Ai ? Ci(Uint8Array.from([wi.hasEvenY() ? 2 : 3]), Ti) : Ci(Uint8Array.from([4]), Ti, Ie.toBytes(Ri.y));
    },
    fromBytes(vi) {
      const wi = vi.length, Ai = vi[0], Ri = vi.subarray(1);
      if (wi === Pe && (Ai === 2 || Ai === 3)) {
        const Ti = bytesToNumberBE(Ri);
        if (!inRange(Ti, _1n$1, Ie.ORDER))
          throw new Error("Point is not on curve");
        const Ci = Ve(Ti);
        let Ii;
        try {
          Ii = Ie.sqrt(Ci);
        } catch (Vi) {
          const is = Vi instanceof Error ? ": " + Vi.message : "";
          throw new Error("Point is not on curve" + is);
        }
        const Li = (Ii & _1n$1) === _1n$1;
        return (Ai & 1) === 1 !== Li && (Ii = Ie.neg(Ii)), { x: Ti, y: Ii };
      } else if (wi === Te && Ai === 4) {
        const Ti = Ie.fromBytes(Ri.subarray(0, Ie.BYTES)), Ci = Ie.fromBytes(Ri.subarray(Ie.BYTES, 2 * Ie.BYTES));
        return { x: Ti, y: Ci };
      } else
        throw new Error(`Point of length ${wi} was invalid. Expected ${Pe} compressed bytes or ${Te} uncompressed bytes`);
    }
  }), En = (vi) => bytesToHex(numberToBytesBE(vi, t.nByteLength));
  function fi(vi) {
    const wi = Be >> _1n$1;
    return vi > wi;
  }
  function bi(vi) {
    return fi(vi) ? Me(-vi) : vi;
  }
  const mi = (vi, wi, Ai) => bytesToNumberBE(vi.slice(wi, Ai));
  class _i {
    constructor(wi, Ai, Ri) {
      this.r = wi, this.s = Ai, this.recovery = Ri, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(wi) {
      const Ai = t.nByteLength;
      return wi = ensureBytes("compactSignature", wi, Ai * 2), new _i(mi(wi, 0, Ai), mi(wi, Ai, 2 * Ai));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(wi) {
      const { r: Ai, s: Ri } = DER.toSig(ensureBytes("DER", wi));
      return new _i(Ai, Ri);
    }
    assertValidity() {
      aInRange("r", this.r, _1n$1, Be), aInRange("s", this.s, _1n$1, Be);
    }
    addRecoveryBit(wi) {
      return new _i(this.r, this.s, wi);
    }
    recoverPublicKey(wi) {
      const { r: Ai, s: Ri, recovery: Ti } = this, Ci = Ui(ensureBytes("msgHash", wi));
      if (Ti == null || ![0, 1, 2, 3].includes(Ti))
        throw new Error("recovery id invalid");
      const Ii = Ti === 2 || Ti === 3 ? Ai + t.n : Ai;
      if (Ii >= Ie.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const Li = Ti & 1 ? "03" : "02", Ni = je.fromHex(Li + En(Ii)), Vi = Ue(Ii), is = Me(-Ci * Vi), Ki = Me(Ri * Vi), ts = je.BASE.multiplyAndAddUnsafe(Ni, is, Ki);
      if (!ts)
        throw new Error("point at infinify");
      return ts.assertValidity(), ts;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return fi(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new _i(this.r, Me(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return En(this.r) + En(this.s);
    }
  }
  const Ei = {
    isValidPrivateKey(vi) {
      try {
        return fn(vi), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: fn,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const vi = getMinHashLength(t.n);
      return mapHashToField(t.randomBytes(vi), t.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(vi = 8, wi = je.BASE) {
      return wi._setWindowSize(vi), wi.multiply(BigInt(3)), wi;
    }
  };
  function Si(vi, wi = !0) {
    return je.fromPrivateKey(vi).toRawBytes(wi);
  }
  function Mi(vi) {
    const wi = isBytes$1(vi), Ai = typeof vi == "string", Ri = (wi || Ai) && vi.length;
    return wi ? Ri === Pe || Ri === Te : Ai ? Ri === 2 * Pe || Ri === 2 * Te : vi instanceof je;
  }
  function Oi(vi, wi, Ai = !0) {
    if (Mi(vi))
      throw new Error("first arg must be private key");
    if (!Mi(wi))
      throw new Error("second arg must be public key");
    return je.fromHex(wi).multiply(fn(vi)).toRawBytes(Ai);
  }
  const Fi = t.bits2int || function(vi) {
    const wi = bytesToNumberBE(vi), Ai = vi.length * 8 - t.nBitLength;
    return Ai > 0 ? wi >> BigInt(Ai) : wi;
  }, Ui = t.bits2int_modN || function(vi) {
    return Me(Fi(vi));
  }, Pi = bitMask(t.nBitLength);
  function Bi(vi) {
    return aInRange(`num < 2^${t.nBitLength}`, vi, _0n, Pi), numberToBytesBE(vi, t.nByteLength);
  }
  function ji(vi, wi, Ai = Zi) {
    if (["recovered", "canonical"].some((Hi) => Hi in Ai))
      throw new Error("sign() legacy options not supported");
    const { hash: Ri, randomBytes: Ti } = t;
    let { lowS: Ci, prehash: Ii, extraEntropy: Li } = Ai;
    Ci == null && (Ci = !0), vi = ensureBytes("msgHash", vi), validateSigVerOpts(Ai), Ii && (vi = ensureBytes("prehashed msgHash", Ri(vi)));
    const Ni = Ui(vi), Vi = fn(wi), is = [Bi(Vi), Bi(Ni)];
    if (Li != null && Li !== !1) {
      const Hi = Li === !0 ? Ti(Ie.BYTES) : Li;
      is.push(ensureBytes("extraEntropy", Hi));
    }
    const Ki = concatBytes(...is), ts = Ni;
    function qi(Hi) {
      const Xi = Fi(Hi);
      if (!vn(Xi))
        return;
      const ki = Ue(Xi), Wi = je.BASE.multiply(Xi).toAffine(), Yi = Me(Wi.x);
      if (Yi === _0n)
        return;
      const Qi = Me(ki * Me(ts + Yi * Vi));
      if (Qi === _0n)
        return;
      let ns = (Wi.x === Yi ? 0 : 2) | Number(Wi.y & _1n$1), us = Qi;
      return Ci && fi(Qi) && (us = bi(Qi), ns ^= 1), new _i(Yi, us, ns);
    }
    return { seed: Ki, k2sig: qi };
  }
  const Zi = { lowS: t.lowS, prehash: !1 }, zi = { lowS: t.lowS, prehash: !1 };
  function xi(vi, wi, Ai = Zi) {
    const { seed: Ri, k2sig: Ti } = ji(vi, wi, Ai), Ci = t;
    return createHmacDrbg(Ci.hash.outputLen, Ci.nByteLength, Ci.hmac)(Ri, Ti);
  }
  je.BASE._setWindowSize(8);
  function $i(vi, wi, Ai, Ri = zi) {
    var Wi;
    const Ti = vi;
    if (wi = ensureBytes("msgHash", wi), Ai = ensureBytes("publicKey", Ai), "strict" in Ri)
      throw new Error("options.strict was renamed to lowS");
    validateSigVerOpts(Ri);
    const { lowS: Ci, prehash: Ii } = Ri;
    let Li, Ni;
    try {
      if (typeof Ti == "string" || isBytes$1(Ti))
        try {
          Li = _i.fromDER(Ti);
        } catch (Yi) {
          if (!(Yi instanceof DER.Err))
            throw Yi;
          Li = _i.fromCompact(Ti);
        }
      else if (typeof Ti == "object" && typeof Ti.r == "bigint" && typeof Ti.s == "bigint") {
        const { r: Yi, s: Qi } = Ti;
        Li = new _i(Yi, Qi);
      } else
        throw new Error("PARSE");
      Ni = je.fromHex(Ai);
    } catch (Yi) {
      if (Yi.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (Ci && Li.hasHighS())
      return !1;
    Ii && (wi = t.hash(wi));
    const { r: Vi, s: is } = Li, Ki = Ui(wi), ts = Ue(is), qi = Me(Ki * ts), Hi = Me(Vi * ts), Xi = (Wi = je.BASE.multiplyAndAddUnsafe(Ni, qi, Hi)) == null ? void 0 : Wi.toAffine();
    return Xi ? Me(Xi.x) === Vi : !1;
  }
  return {
    CURVE: t,
    getPublicKey: Si,
    getSharedSecret: Oi,
    sign: xi,
    verify: $i,
    ProjectivePoint: je,
    Signature: _i,
    utils: Ei
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(Ae) {
  return {
    hash: Ae,
    hmac: (t, ...Ie) => hmac$2(Ae, t, concatBytes$3(...Ie)),
    randomBytes: randomBytes$1
  };
}
function createCurve(Ae, t) {
  const Ie = (Be) => weierstrass({ ...Ae, ...getHash(Be) });
  return Object.freeze({ ...Ie(t), create: Ie });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), _1n = BigInt(1), _2n = BigInt(2), divNearest = (Ae, t) => (Ae + t / _2n) / t;
function sqrtMod(Ae) {
  const t = secp256k1P, Ie = BigInt(3), Be = BigInt(6), Pe = BigInt(11), Te = BigInt(22), Me = BigInt(23), Ue = BigInt(44), je = BigInt(88), fn = Ae * Ae * Ae % t, Ve = fn * fn * Ae % t, vn = pow2(Ve, Ie, t) * Ve % t, En = pow2(vn, Ie, t) * Ve % t, fi = pow2(En, _2n, t) * fn % t, bi = pow2(fi, Pe, t) * fi % t, mi = pow2(bi, Te, t) * bi % t, _i = pow2(mi, Ue, t) * mi % t, Ei = pow2(_i, je, t) * _i % t, Si = pow2(Ei, Ue, t) * mi % t, Mi = pow2(Si, Ie, t) * Ve % t, Oi = pow2(Mi, Me, t) * bi % t, Fi = pow2(Oi, Be, t) * fn % t, Ui = pow2(Fi, _2n, t);
  if (!Fp.eql(Fp.sqr(Ui), Ae))
    throw new Error("Cannot find square root");
  return Ui;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod }), secp256k1 = createCurve({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: !0,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (Ae) => {
      const t = secp256k1N, Ie = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), Be = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), Pe = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), Te = Ie, Me = BigInt("0x100000000000000000000000000000000"), Ue = divNearest(Te * Ae, t), je = divNearest(-Be * Ae, t);
      let fn = mod(Ae - Ue * Ie - je * Pe, t), Ve = mod(-Ue * Be - je * Te, t);
      const vn = fn > Me, En = Ve > Me;
      if (vn && (fn = t - fn), En && (Ve = t - Ve), fn > Me || Ve > Me)
        throw new Error("splitScalar: Endomorphism failed, k=" + Ae);
      return { k1neg: vn, k1: fn, k2neg: En, k2: Ve };
    }
  }
}, sha256$4);
BigInt(0);
secp256k1.ProjectivePoint;
const secp256k1$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  secp256k1
}, Symbol.toStringTag, { value: "Module" }));
function serializeSignature({ r: Ae, s: t, to: Ie = "hex", v: Be, yParity: Pe }) {
  const Te = (() => {
    if (Pe === 0 || Pe === 1)
      return Pe;
    if (Be && (Be === 27n || Be === 28n || Be >= 35n))
      return Be % 2n === 0n ? 1 : 0;
    throw new Error("Invalid `v` or `yParity` value");
  })(), Me = `0x${new secp256k1.Signature(hexToBigInt(Ae), hexToBigInt(t)).toCompactHex()}${Te === 0 ? "1b" : "1c"}`;
  return Ie === "hex" ? Me : hexToBytes$2(Me);
}
async function verifyHash(Ae, t) {
  var vn, En, fi;
  const { address: Ie, factory: Be, factoryData: Pe, hash: Te, signature: Me, universalSignatureVerifierAddress: Ue = (fi = (En = (vn = Ae.chain) == null ? void 0 : vn.contracts) == null ? void 0 : En.universalSignatureVerifier) == null ? void 0 : fi.address, ...je } = t, fn = isHex(Me) ? Me : typeof Me == "object" && "r" in Me && "s" in Me ? serializeSignature(Me) : bytesToHex$2(Me), Ve = await (async () => !Be && !Pe || isErc6492Signature(fn) ? fn : serializeErc6492Signature({
    address: Be,
    data: Pe,
    signature: fn
  }))();
  try {
    const bi = Ue ? {
      to: Ue,
      data: encodeFunctionData({
        abi: universalSignatureValidatorAbi,
        functionName: "isValidSig",
        args: [Ie, Te, Ve]
      }),
      ...je
    } : {
      data: encodeDeployData({
        abi: universalSignatureValidatorAbi,
        args: [Ie, Te, Ve],
        bytecode: universalSignatureValidatorByteCode
      }),
      ...je
    }, { data: mi } = await getAction(Ae, call, "call")(bi);
    return hexToBool(mi ?? "0x0");
  } catch (bi) {
    try {
      if (isAddressEqual(getAddress$2(Ie), await recoverAddress$2({ hash: Te, signature: Me })))
        return !0;
    } catch {
    }
    if (bi instanceof CallExecutionError)
      return !1;
    throw bi;
  }
}
async function verifyMessage(Ae, { address: t, message: Ie, factory: Be, factoryData: Pe, signature: Te, ...Me }) {
  const Ue = hashMessage$1(Ie);
  return verifyHash(Ae, {
    address: t,
    factory: Be,
    factoryData: Pe,
    hash: Ue,
    signature: Te,
    ...Me
  });
}
async function verifyTypedData(Ae, t) {
  const { address: Ie, factory: Be, factoryData: Pe, signature: Te, message: Me, primaryType: Ue, types: je, domain: fn, ...Ve } = t, vn = hashTypedData({ message: Me, primaryType: Ue, types: je, domain: fn });
  return verifyHash(Ae, {
    address: Ie,
    factory: Be,
    factoryData: Pe,
    hash: vn,
    signature: Te,
    ...Ve
  });
}
function watchBlockNumber(Ae, { emitOnBegin: t = !1, emitMissed: Ie = !1, onBlockNumber: Be, onError: Pe, poll: Te, pollingInterval: Me = Ae.pollingInterval }) {
  const Ue = typeof Te < "u" ? Te : !(Ae.transport.type === "webSocket" || Ae.transport.type === "fallback" && Ae.transport.transports[0].config.type === "webSocket");
  let je;
  return Ue ? (() => {
    const vn = stringify$2([
      "watchBlockNumber",
      Ae.uid,
      t,
      Ie,
      Me
    ]);
    return observe(vn, { onBlockNumber: Be, onError: Pe }, (En) => poll(async () => {
      var fi;
      try {
        const bi = await getAction(Ae, getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
        if (je) {
          if (bi === je)
            return;
          if (bi - je > 1 && Ie)
            for (let mi = je + 1n; mi < bi; mi++)
              En.onBlockNumber(mi, je), je = mi;
        }
        (!je || bi > je) && (En.onBlockNumber(bi, je), je = bi);
      } catch (bi) {
        (fi = En.onError) == null || fi.call(En, bi);
      }
    }, {
      emitOnBegin: t,
      interval: Me
    }));
  })() : (() => {
    const vn = stringify$2([
      "watchBlockNumber",
      Ae.uid,
      t,
      Ie
    ]);
    return observe(vn, { onBlockNumber: Be, onError: Pe }, (En) => {
      let fi = !0, bi = () => fi = !1;
      return (async () => {
        try {
          const mi = (() => {
            if (Ae.transport.type === "fallback") {
              const Ei = Ae.transport.transports.find((Si) => Si.config.type === "webSocket");
              return Ei ? Ei.value : Ae.transport;
            }
            return Ae.transport;
          })(), { unsubscribe: _i } = await mi.subscribe({
            params: ["newHeads"],
            onData(Ei) {
              var Mi;
              if (!fi)
                return;
              const Si = hexToBigInt((Mi = Ei.result) == null ? void 0 : Mi.number);
              En.onBlockNumber(Si, je), je = Si;
            },
            onError(Ei) {
              var Si;
              (Si = En.onError) == null || Si.call(En, Ei);
            }
          });
          bi = _i, fi || bi();
        } catch (mi) {
          Pe == null || Pe(mi);
        }
      })(), () => bi();
    });
  })();
}
async function waitForTransactionReceipt(Ae, {
  confirmations: t = 1,
  hash: Ie,
  onReplaced: Be,
  pollingInterval: Pe = Ae.pollingInterval,
  retryCount: Te = 6,
  retryDelay: Me = ({ count: je }) => ~~(1 << je) * 200,
  // exponential backoff
  timeout: Ue = 18e4
}) {
  const je = stringify$2(["waitForTransactionReceipt", Ae.uid, Ie]);
  let fn, Ve, vn, En = !1;
  return new Promise((fi, bi) => {
    Ue && setTimeout(() => bi(new WaitForTransactionReceiptTimeoutError({ hash: Ie })), Ue);
    const mi = observe(je, { onReplaced: Be, resolve: fi, reject: bi }, (_i) => {
      const Ei = getAction(Ae, watchBlockNumber, "watchBlockNumber")({
        emitMissed: !0,
        emitOnBegin: !0,
        poll: !0,
        pollingInterval: Pe,
        async onBlockNumber(Si) {
          const Mi = (Fi) => {
            Ei(), Fi(), mi();
          };
          let Oi = Si;
          if (!En)
            try {
              if (vn) {
                if (t > 1 && (!vn.blockNumber || Oi - vn.blockNumber + 1n < t))
                  return;
                Mi(() => _i.resolve(vn));
                return;
              }
              if (fn || (En = !0, await withRetry(async () => {
                fn = await getAction(Ae, getTransaction, "getTransaction")({ hash: Ie }), fn.blockNumber && (Oi = fn.blockNumber);
              }, {
                delay: Me,
                retryCount: Te
              }), En = !1), vn = await getAction(Ae, getTransactionReceipt, "getTransactionReceipt")({ hash: Ie }), t > 1 && (!vn.blockNumber || Oi - vn.blockNumber + 1n < t))
                return;
              Mi(() => _i.resolve(vn));
            } catch (Fi) {
              if (Fi instanceof TransactionNotFoundError || Fi instanceof TransactionReceiptNotFoundError) {
                if (!fn) {
                  En = !1;
                  return;
                }
                try {
                  Ve = fn, En = !0;
                  const Ui = await withRetry(() => getAction(Ae, getBlock, "getBlock")({
                    blockNumber: Oi,
                    includeTransactions: !0
                  }), {
                    delay: Me,
                    retryCount: Te,
                    shouldRetry: ({ error: ji }) => ji instanceof BlockNotFoundError
                  });
                  En = !1;
                  const Pi = Ui.transactions.find(({ from: ji, nonce: Zi }) => ji === Ve.from && Zi === Ve.nonce);
                  if (!Pi || (vn = await getAction(Ae, getTransactionReceipt, "getTransactionReceipt")({
                    hash: Pi.hash
                  }), t > 1 && (!vn.blockNumber || Oi - vn.blockNumber + 1n < t)))
                    return;
                  let Bi = "replaced";
                  Pi.to === Ve.to && Pi.value === Ve.value ? Bi = "repriced" : Pi.from === Pi.to && Pi.value === 0n && (Bi = "cancelled"), Mi(() => {
                    var ji;
                    (ji = _i.onReplaced) == null || ji.call(_i, {
                      reason: Bi,
                      replacedTransaction: Ve,
                      transaction: Pi,
                      transactionReceipt: vn
                    }), _i.resolve(vn);
                  });
                } catch (Ui) {
                  Mi(() => _i.reject(Ui));
                }
              } else
                Mi(() => _i.reject(Fi));
            }
        }
      });
    });
  });
}
function watchBlocks(Ae, { blockTag: t = "latest", emitMissed: Ie = !1, emitOnBegin: Be = !1, onBlock: Pe, onError: Te, includeTransactions: Me, poll: Ue, pollingInterval: je = Ae.pollingInterval }) {
  const fn = typeof Ue < "u" ? Ue : !(Ae.transport.type === "webSocket" || Ae.transport.type === "fallback" && Ae.transport.transports[0].config.type === "webSocket"), Ve = Me ?? !1;
  let vn;
  return fn ? (() => {
    const bi = stringify$2([
      "watchBlocks",
      Ae.uid,
      t,
      Ie,
      Be,
      Ve,
      je
    ]);
    return observe(bi, { onBlock: Pe, onError: Te }, (mi) => poll(async () => {
      var _i;
      try {
        const Ei = await getAction(Ae, getBlock, "getBlock")({
          blockTag: t,
          includeTransactions: Ve
        });
        if (Ei.number && (vn != null && vn.number)) {
          if (Ei.number === vn.number)
            return;
          if (Ei.number - vn.number > 1 && Ie)
            for (let Si = (vn == null ? void 0 : vn.number) + 1n; Si < Ei.number; Si++) {
              const Mi = await getAction(Ae, getBlock, "getBlock")({
                blockNumber: Si,
                includeTransactions: Ve
              });
              mi.onBlock(Mi, vn), vn = Mi;
            }
        }
        // If no previous block exists, emit.
        (!(vn != null && vn.number) || // If the block tag is "pending" with no block number, emit.
        t === "pending" && !(Ei != null && Ei.number) || // If the next block number is greater than the previous block number, emit.
        // We don't want to emit blocks in the past.
        Ei.number && Ei.number > vn.number) && (mi.onBlock(Ei, vn), vn = Ei);
      } catch (Ei) {
        (_i = mi.onError) == null || _i.call(mi, Ei);
      }
    }, {
      emitOnBegin: Be,
      interval: je
    }));
  })() : (() => {
    let bi = !0, mi = !0, _i = () => bi = !1;
    return (async () => {
      try {
        Be && getAction(Ae, getBlock, "getBlock")({
          blockTag: t,
          includeTransactions: Ve
        }).then((Mi) => {
          bi && mi && (Pe(Mi, void 0), mi = !1);
        });
        const Ei = (() => {
          if (Ae.transport.type === "fallback") {
            const Mi = Ae.transport.transports.find((Oi) => Oi.config.type === "webSocket");
            return Mi ? Mi.value : Ae.transport;
          }
          return Ae.transport;
        })(), { unsubscribe: Si } = await Ei.subscribe({
          params: ["newHeads"],
          onData(Mi) {
            var Ui, Pi, Bi;
            if (!bi)
              return;
            const Fi = (((Bi = (Pi = (Ui = Ae.chain) == null ? void 0 : Ui.formatters) == null ? void 0 : Pi.block) == null ? void 0 : Bi.format) || formatBlock)(Mi.result);
            Pe(Fi, vn), mi = !1, vn = Fi;
          },
          onError(Mi) {
            Te == null || Te(Mi);
          }
        });
        _i = Si, bi || _i();
      } catch (Ei) {
        Te == null || Te(Ei);
      }
    })(), () => _i();
  })();
}
function watchEvent(Ae, { address: t, args: Ie, batch: Be = !0, event: Pe, events: Te, fromBlock: Me, onError: Ue, onLogs: je, poll: fn, pollingInterval: Ve = Ae.pollingInterval, strict: vn }) {
  const En = typeof fn < "u" ? fn : typeof Me == "bigint" ? !0 : !(Ae.transport.type === "webSocket" || Ae.transport.type === "fallback" && Ae.transport.transports[0].config.type === "webSocket"), fi = vn ?? !1;
  return En ? (() => {
    const _i = stringify$2([
      "watchEvent",
      t,
      Ie,
      Be,
      Ae.uid,
      Pe,
      Ve,
      Me
    ]);
    return observe(_i, { onLogs: je, onError: Ue }, (Ei) => {
      let Si;
      Me !== void 0 && (Si = Me - 1n);
      let Mi, Oi = !1;
      const Fi = poll(async () => {
        var Ui;
        if (!Oi) {
          try {
            Mi = await getAction(Ae, createEventFilter, "createEventFilter")({
              address: t,
              args: Ie,
              event: Pe,
              events: Te,
              strict: fi,
              fromBlock: Me
            });
          } catch {
          }
          Oi = !0;
          return;
        }
        try {
          let Pi;
          if (Mi)
            Pi = await getAction(Ae, getFilterChanges, "getFilterChanges")({ filter: Mi });
          else {
            const Bi = await getAction(Ae, getBlockNumber, "getBlockNumber")({});
            Si && Si !== Bi ? Pi = await getAction(Ae, getLogs, "getLogs")({
              address: t,
              args: Ie,
              event: Pe,
              events: Te,
              fromBlock: Si + 1n,
              toBlock: Bi
            }) : Pi = [], Si = Bi;
          }
          if (Pi.length === 0)
            return;
          if (Be)
            Ei.onLogs(Pi);
          else
            for (const Bi of Pi)
              Ei.onLogs([Bi]);
        } catch (Pi) {
          Mi && Pi instanceof InvalidInputRpcError && (Oi = !1), (Ui = Ei.onError) == null || Ui.call(Ei, Pi);
        }
      }, {
        emitOnBegin: !0,
        interval: Ve
      });
      return async () => {
        Mi && await getAction(Ae, uninstallFilter, "uninstallFilter")({ filter: Mi }), Fi();
      };
    });
  })() : (() => {
    let _i = !0, Ei = () => _i = !1;
    return (async () => {
      try {
        const Si = (() => {
          if (Ae.transport.type === "fallback") {
            const Ui = Ae.transport.transports.find((Pi) => Pi.config.type === "webSocket");
            return Ui ? Ui.value : Ae.transport;
          }
          return Ae.transport;
        })(), Mi = Te ?? (Pe ? [Pe] : void 0);
        let Oi = [];
        Mi && (Oi = [Mi.flatMap((Pi) => encodeEventTopics({
          abi: [Pi],
          eventName: Pi.name,
          args: Ie
        }))], Pe && (Oi = Oi[0]));
        const { unsubscribe: Fi } = await Si.subscribe({
          params: ["logs", { address: t, topics: Oi }],
          onData(Ui) {
            var Bi;
            if (!_i)
              return;
            const Pi = Ui.result;
            try {
              const { eventName: ji, args: Zi } = decodeEventLog({
                abi: Mi ?? [],
                data: Pi.data,
                topics: Pi.topics,
                strict: fi
              }), zi = formatLog(Pi, { args: Zi, eventName: ji });
              je([zi]);
            } catch (ji) {
              let Zi, zi;
              if (ji instanceof DecodeLogDataMismatch || ji instanceof DecodeLogTopicsMismatch) {
                if (vn)
                  return;
                Zi = ji.abiItem.name, zi = (Bi = ji.abiItem.inputs) == null ? void 0 : Bi.some(($i) => !("name" in $i && $i.name));
              }
              const xi = formatLog(Pi, {
                args: zi ? [] : {},
                eventName: Zi
              });
              je([xi]);
            }
          },
          onError(Ui) {
            Ue == null || Ue(Ui);
          }
        });
        Ei = Fi, _i || Ei();
      } catch (Si) {
        Ue == null || Ue(Si);
      }
    })(), () => Ei();
  })();
}
function watchPendingTransactions(Ae, { batch: t = !0, onError: Ie, onTransactions: Be, poll: Pe, pollingInterval: Te = Ae.pollingInterval }) {
  return (typeof Pe < "u" ? Pe : Ae.transport.type !== "webSocket") ? (() => {
    const fn = stringify$2([
      "watchPendingTransactions",
      Ae.uid,
      t,
      Te
    ]);
    return observe(fn, { onTransactions: Be, onError: Ie }, (Ve) => {
      let vn;
      const En = poll(async () => {
        var fi;
        try {
          if (!vn)
            try {
              vn = await getAction(Ae, createPendingTransactionFilter, "createPendingTransactionFilter")({});
              return;
            } catch (mi) {
              throw En(), mi;
            }
          const bi = await getAction(Ae, getFilterChanges, "getFilterChanges")({ filter: vn });
          if (bi.length === 0)
            return;
          if (t)
            Ve.onTransactions(bi);
          else
            for (const mi of bi)
              Ve.onTransactions([mi]);
        } catch (bi) {
          (fi = Ve.onError) == null || fi.call(Ve, bi);
        }
      }, {
        emitOnBegin: !0,
        interval: Te
      });
      return async () => {
        vn && await getAction(Ae, uninstallFilter, "uninstallFilter")({ filter: vn }), En();
      };
    });
  })() : (() => {
    let fn = !0, Ve = () => fn = !1;
    return (async () => {
      try {
        const { unsubscribe: vn } = await Ae.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(En) {
            if (!fn)
              return;
            const fi = En.result;
            Be([fi]);
          },
          onError(En) {
            Ie == null || Ie(En);
          }
        });
        Ve = vn, fn || Ve();
      } catch (vn) {
        Ie == null || Ie(vn);
      }
    })(), () => Ve();
  })();
}
function parseSiweMessage(Ae) {
  var vn, En, fi;
  const { scheme: t, statement: Ie, ...Be } = ((vn = Ae.match(prefixRegex)) == null ? void 0 : vn.groups) ?? {}, { chainId: Pe, expirationTime: Te, issuedAt: Me, notBefore: Ue, requestId: je, ...fn } = ((En = Ae.match(suffixRegex)) == null ? void 0 : En.groups) ?? {}, Ve = (fi = Ae.split("Resources:")[1]) == null ? void 0 : fi.split(`
- `).slice(1);
  return {
    ...Be,
    ...fn,
    ...Pe ? { chainId: Number(Pe) } : {},
    ...Te ? { expirationTime: new Date(Te) } : {},
    ...Me ? { issuedAt: new Date(Me) } : {},
    ...Ue ? { notBefore: new Date(Ue) } : {},
    ...je ? { requestId: je } : {},
    ...Ve ? { resources: Ve } : {},
    ...t ? { scheme: t } : {},
    ...Ie ? { statement: Ie } : {}
  };
}
const prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/, suffixRegex = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;
function validateSiweMessage(Ae) {
  const { address: t, domain: Ie, message: Be, nonce: Pe, scheme: Te, time: Me = /* @__PURE__ */ new Date() } = Ae;
  if (Ie && Be.domain !== Ie || Pe && Be.nonce !== Pe || Te && Be.scheme !== Te || Be.expirationTime && Me >= Be.expirationTime || Be.notBefore && Me < Be.notBefore)
    return !1;
  try {
    if (!Be.address || t && !isAddressEqual(Be.address, t))
      return !1;
  } catch {
    return !1;
  }
  return !0;
}
async function verifySiweMessage(Ae, t) {
  const { address: Ie, domain: Be, message: Pe, nonce: Te, scheme: Me, signature: Ue, time: je = /* @__PURE__ */ new Date(), ...fn } = t, Ve = parseSiweMessage(Pe);
  if (!Ve.address || !validateSiweMessage({
    address: Ie,
    domain: Be,
    message: Ve,
    nonce: Te,
    scheme: Me,
    time: je
  }))
    return !1;
  const En = hashMessage$1(Pe);
  return verifyHash(Ae, {
    address: Ve.address,
    hash: En,
    signature: Ue,
    ...fn
  });
}
function publicActions(Ae) {
  return {
    call: (t) => call(Ae, t),
    createBlockFilter: () => createBlockFilter(Ae),
    createContractEventFilter: (t) => createContractEventFilter(Ae, t),
    createEventFilter: (t) => createEventFilter(Ae, t),
    createPendingTransactionFilter: () => createPendingTransactionFilter(Ae),
    estimateContractGas: (t) => estimateContractGas(Ae, t),
    estimateGas: (t) => estimateGas(Ae, t),
    getBalance: (t) => getBalance(Ae, t),
    getBlobBaseFee: () => getBlobBaseFee(Ae),
    getBlock: (t) => getBlock(Ae, t),
    getBlockNumber: (t) => getBlockNumber(Ae, t),
    getBlockTransactionCount: (t) => getBlockTransactionCount(Ae, t),
    getBytecode: (t) => getCode(Ae, t),
    getChainId: () => getChainId(Ae),
    getCode: (t) => getCode(Ae, t),
    getContractEvents: (t) => getContractEvents(Ae, t),
    getEip712Domain: (t) => getEip712Domain(Ae, t),
    getEnsAddress: (t) => getEnsAddress(Ae, t),
    getEnsAvatar: (t) => getEnsAvatar(Ae, t),
    getEnsName: (t) => getEnsName(Ae, t),
    getEnsResolver: (t) => getEnsResolver(Ae, t),
    getEnsText: (t) => getEnsText(Ae, t),
    getFeeHistory: (t) => getFeeHistory(Ae, t),
    estimateFeesPerGas: (t) => estimateFeesPerGas(Ae, t),
    getFilterChanges: (t) => getFilterChanges(Ae, t),
    getFilterLogs: (t) => getFilterLogs(Ae, t),
    getGasPrice: () => getGasPrice(Ae),
    getLogs: (t) => getLogs(Ae, t),
    getProof: (t) => getProof(Ae, t),
    estimateMaxPriorityFeePerGas: (t) => estimateMaxPriorityFeePerGas(Ae, t),
    getStorageAt: (t) => getStorageAt(Ae, t),
    getTransaction: (t) => getTransaction(Ae, t),
    getTransactionConfirmations: (t) => getTransactionConfirmations(Ae, t),
    getTransactionCount: (t) => getTransactionCount(Ae, t),
    getTransactionReceipt: (t) => getTransactionReceipt(Ae, t),
    multicall: (t) => multicall(Ae, t),
    prepareTransactionRequest: (t) => prepareTransactionRequest(Ae, t),
    readContract: (t) => readContract(Ae, t),
    sendRawTransaction: (t) => sendRawTransaction(Ae, t),
    simulateContract: (t) => simulateContract(Ae, t),
    verifyMessage: (t) => verifyMessage(Ae, t),
    verifySiweMessage: (t) => verifySiweMessage(Ae, t),
    verifyTypedData: (t) => verifyTypedData(Ae, t),
    uninstallFilter: (t) => uninstallFilter(Ae, t),
    waitForTransactionReceipt: (t) => waitForTransactionReceipt(Ae, t),
    watchBlocks: (t) => watchBlocks(Ae, t),
    watchBlockNumber: (t) => watchBlockNumber(Ae, t),
    watchContractEvent: (t) => watchContractEvent(Ae, t),
    watchEvent: (t) => watchEvent(Ae, t),
    watchPendingTransactions: (t) => watchPendingTransactions(Ae, t)
  };
}
function createPublicClient(Ae) {
  const { key: t = "public", name: Ie = "Public Client" } = Ae;
  return createClient({
    ...Ae,
    key: t,
    name: Ie,
    type: "publicClient"
  }).extend(publicActions);
}
function deployContract(Ae, t) {
  const { abi: Ie, args: Be, bytecode: Pe, ...Te } = t, Me = encodeDeployData({ abi: Ie, args: Be, bytecode: Pe });
  return sendTransaction(Ae, {
    ...Te,
    data: Me
  });
}
async function getAddresses(Ae) {
  var Ie;
  return ((Ie = Ae.account) == null ? void 0 : Ie.type) === "local" ? [Ae.account.address] : (await Ae.request({ method: "eth_accounts" }, { dedupe: !0 })).map((Be) => checksumAddress(Be));
}
async function getPermissions(Ae) {
  return await Ae.request({ method: "wallet_getPermissions" }, { dedupe: !0 });
}
async function requestAddresses(Ae) {
  return (await Ae.request({ method: "eth_requestAccounts" }, { dedupe: !0, retryCount: 0 })).map((Ie) => getAddress$2(Ie));
}
async function requestPermissions(Ae, t) {
  return Ae.request({
    method: "wallet_requestPermissions",
    params: [t]
  }, { retryCount: 0 });
}
async function signMessage(Ae, { account: t = Ae.account, message: Ie }) {
  if (!t)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const Be = parseAccount(t);
  if (Be.signMessage)
    return Be.signMessage({ message: Ie });
  const Pe = typeof Ie == "string" ? stringToHex(Ie) : Ie.raw instanceof Uint8Array ? toHex(Ie.raw) : Ie.raw;
  return Ae.request({
    method: "personal_sign",
    params: [Pe, Be.address]
  }, { retryCount: 0 });
}
async function signTransaction(Ae, t) {
  var fn, Ve, vn, En;
  const { account: Ie = Ae.account, chain: Be = Ae.chain, ...Pe } = t;
  if (!Ie)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTransaction"
    });
  const Te = parseAccount(Ie);
  assertRequest({
    account: Te,
    ...t
  });
  const Me = await getAction(Ae, getChainId, "getChainId")({});
  Be !== null && assertCurrentChain({
    currentChainId: Me,
    chain: Be
  });
  const Ue = (Be == null ? void 0 : Be.formatters) || ((fn = Ae.chain) == null ? void 0 : fn.formatters), je = ((Ve = Ue == null ? void 0 : Ue.transactionRequest) == null ? void 0 : Ve.format) || formatTransactionRequest;
  return Te.signTransaction ? Te.signTransaction({
    ...Pe,
    chainId: Me
  }, { serializer: (En = (vn = Ae.chain) == null ? void 0 : vn.serializers) == null ? void 0 : En.transaction }) : await Ae.request({
    method: "eth_signTransaction",
    params: [
      {
        ...je(Pe),
        chainId: numberToHex(Me),
        from: Te.address
      }
    ]
  }, { retryCount: 0 });
}
async function signTypedData(Ae, t) {
  const { account: Ie = Ae.account, domain: Be, message: Pe, primaryType: Te } = t;
  if (!Ie)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const Me = parseAccount(Ie), Ue = {
    EIP712Domain: getTypesForEIP712Domain({ domain: Be }),
    ...t.types
  };
  if (validateTypedData({ domain: Be, message: Pe, primaryType: Te, types: Ue }), Me.signTypedData)
    return Me.signTypedData({ domain: Be, message: Pe, primaryType: Te, types: Ue });
  const je = serializeTypedData({ domain: Be, message: Pe, primaryType: Te, types: Ue });
  return Ae.request({
    method: "eth_signTypedData_v4",
    params: [Me.address, je]
  }, { retryCount: 0 });
}
async function switchChain(Ae, { id: t }) {
  await Ae.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: numberToHex(t)
      }
    ]
  }, { retryCount: 0 });
}
async function watchAsset(Ae, t) {
  return await Ae.request({
    method: "wallet_watchAsset",
    params: t
  }, { retryCount: 0 });
}
function walletActions(Ae) {
  return {
    addChain: (t) => addChain(Ae, t),
    deployContract: (t) => deployContract(Ae, t),
    getAddresses: () => getAddresses(Ae),
    getChainId: () => getChainId(Ae),
    getPermissions: () => getPermissions(Ae),
    prepareTransactionRequest: (t) => prepareTransactionRequest(Ae, t),
    requestAddresses: () => requestAddresses(Ae),
    requestPermissions: (t) => requestPermissions(Ae, t),
    sendRawTransaction: (t) => sendRawTransaction(Ae, t),
    sendTransaction: (t) => sendTransaction(Ae, t),
    signMessage: (t) => signMessage(Ae, t),
    signTransaction: (t) => signTransaction(Ae, t),
    signTypedData: (t) => signTypedData(Ae, t),
    switchChain: (t) => switchChain(Ae, t),
    watchAsset: (t) => watchAsset(Ae, t),
    writeContract: (t) => writeContract(Ae, t)
  };
}
function createWalletClient(Ae) {
  const { key: t = "wallet", name: Ie = "Wallet Client", transport: Be } = Ae;
  return createClient({
    ...Ae,
    key: t,
    name: Ie,
    transport: Be,
    type: "walletClient"
  }).extend(walletActions);
}
var cjs$3 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(Ae, t) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Ie, Be) {
    Ie.__proto__ = Be;
  } || function(Ie, Be) {
    for (var Pe in Be) Be.hasOwnProperty(Pe) && (Ie[Pe] = Be[Pe]);
  }, extendStatics(Ae, t);
};
function __extends(Ae, t) {
  extendStatics(Ae, t);
  function Ie() {
    this.constructor = Ae;
  }
  Ae.prototype = t === null ? Object.create(t) : (Ie.prototype = t.prototype, new Ie());
}
var __assign = function() {
  return __assign = Object.assign || function(t) {
    for (var Ie, Be = 1, Pe = arguments.length; Be < Pe; Be++) {
      Ie = arguments[Be];
      for (var Te in Ie) Object.prototype.hasOwnProperty.call(Ie, Te) && (t[Te] = Ie[Te]);
    }
    return t;
  }, __assign.apply(this, arguments);
};
function __rest(Ae, t) {
  var Ie = {};
  for (var Be in Ae) Object.prototype.hasOwnProperty.call(Ae, Be) && t.indexOf(Be) < 0 && (Ie[Be] = Ae[Be]);
  if (Ae != null && typeof Object.getOwnPropertySymbols == "function")
    for (var Pe = 0, Be = Object.getOwnPropertySymbols(Ae); Pe < Be.length; Pe++)
      t.indexOf(Be[Pe]) < 0 && Object.prototype.propertyIsEnumerable.call(Ae, Be[Pe]) && (Ie[Be[Pe]] = Ae[Be[Pe]]);
  return Ie;
}
function __decorate(Ae, t, Ie, Be) {
  var Pe = arguments.length, Te = Pe < 3 ? t : Be === null ? Be = Object.getOwnPropertyDescriptor(t, Ie) : Be, Me;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") Te = Reflect.decorate(Ae, t, Ie, Be);
  else for (var Ue = Ae.length - 1; Ue >= 0; Ue--) (Me = Ae[Ue]) && (Te = (Pe < 3 ? Me(Te) : Pe > 3 ? Me(t, Ie, Te) : Me(t, Ie)) || Te);
  return Pe > 3 && Te && Object.defineProperty(t, Ie, Te), Te;
}
function __param(Ae, t) {
  return function(Ie, Be) {
    t(Ie, Be, Ae);
  };
}
function __metadata(Ae, t) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(Ae, t);
}
function __awaiter(Ae, t, Ie, Be) {
  function Pe(Te) {
    return Te instanceof Ie ? Te : new Ie(function(Me) {
      Me(Te);
    });
  }
  return new (Ie || (Ie = Promise))(function(Te, Me) {
    function Ue(Ve) {
      try {
        fn(Be.next(Ve));
      } catch (vn) {
        Me(vn);
      }
    }
    function je(Ve) {
      try {
        fn(Be.throw(Ve));
      } catch (vn) {
        Me(vn);
      }
    }
    function fn(Ve) {
      Ve.done ? Te(Ve.value) : Pe(Ve.value).then(Ue, je);
    }
    fn((Be = Be.apply(Ae, t || [])).next());
  });
}
function __generator(Ae, t) {
  var Ie = { label: 0, sent: function() {
    if (Te[0] & 1) throw Te[1];
    return Te[1];
  }, trys: [], ops: [] }, Be, Pe, Te, Me;
  return Me = { next: Ue(0), throw: Ue(1), return: Ue(2) }, typeof Symbol == "function" && (Me[Symbol.iterator] = function() {
    return this;
  }), Me;
  function Ue(fn) {
    return function(Ve) {
      return je([fn, Ve]);
    };
  }
  function je(fn) {
    if (Be) throw new TypeError("Generator is already executing.");
    for (; Ie; ) try {
      if (Be = 1, Pe && (Te = fn[0] & 2 ? Pe.return : fn[0] ? Pe.throw || ((Te = Pe.return) && Te.call(Pe), 0) : Pe.next) && !(Te = Te.call(Pe, fn[1])).done) return Te;
      switch (Pe = 0, Te && (fn = [fn[0] & 2, Te.value]), fn[0]) {
        case 0:
        case 1:
          Te = fn;
          break;
        case 4:
          return Ie.label++, { value: fn[1], done: !1 };
        case 5:
          Ie.label++, Pe = fn[1], fn = [0];
          continue;
        case 7:
          fn = Ie.ops.pop(), Ie.trys.pop();
          continue;
        default:
          if (Te = Ie.trys, !(Te = Te.length > 0 && Te[Te.length - 1]) && (fn[0] === 6 || fn[0] === 2)) {
            Ie = 0;
            continue;
          }
          if (fn[0] === 3 && (!Te || fn[1] > Te[0] && fn[1] < Te[3])) {
            Ie.label = fn[1];
            break;
          }
          if (fn[0] === 6 && Ie.label < Te[1]) {
            Ie.label = Te[1], Te = fn;
            break;
          }
          if (Te && Ie.label < Te[2]) {
            Ie.label = Te[2], Ie.ops.push(fn);
            break;
          }
          Te[2] && Ie.ops.pop(), Ie.trys.pop();
          continue;
      }
      fn = t.call(Ae, Ie);
    } catch (Ve) {
      fn = [6, Ve], Pe = 0;
    } finally {
      Be = Te = 0;
    }
    if (fn[0] & 5) throw fn[1];
    return { value: fn[0] ? fn[1] : void 0, done: !0 };
  }
}
function __createBinding(Ae, t, Ie, Be) {
  Be === void 0 && (Be = Ie), Ae[Be] = t[Ie];
}
function __exportStar(Ae, t) {
  for (var Ie in Ae) Ie !== "default" && !t.hasOwnProperty(Ie) && (t[Ie] = Ae[Ie]);
}
function __values(Ae) {
  var t = typeof Symbol == "function" && Symbol.iterator, Ie = t && Ae[t], Be = 0;
  if (Ie) return Ie.call(Ae);
  if (Ae && typeof Ae.length == "number") return {
    next: function() {
      return Ae && Be >= Ae.length && (Ae = void 0), { value: Ae && Ae[Be++], done: !Ae };
    }
  };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(Ae, t) {
  var Ie = typeof Symbol == "function" && Ae[Symbol.iterator];
  if (!Ie) return Ae;
  var Be = Ie.call(Ae), Pe, Te = [], Me;
  try {
    for (; (t === void 0 || t-- > 0) && !(Pe = Be.next()).done; ) Te.push(Pe.value);
  } catch (Ue) {
    Me = { error: Ue };
  } finally {
    try {
      Pe && !Pe.done && (Ie = Be.return) && Ie.call(Be);
    } finally {
      if (Me) throw Me.error;
    }
  }
  return Te;
}
function __spread() {
  for (var Ae = [], t = 0; t < arguments.length; t++)
    Ae = Ae.concat(__read(arguments[t]));
  return Ae;
}
function __spreadArrays() {
  for (var Ae = 0, t = 0, Ie = arguments.length; t < Ie; t++) Ae += arguments[t].length;
  for (var Be = Array(Ae), Pe = 0, t = 0; t < Ie; t++)
    for (var Te = arguments[t], Me = 0, Ue = Te.length; Me < Ue; Me++, Pe++)
      Be[Pe] = Te[Me];
  return Be;
}
function __await(Ae) {
  return this instanceof __await ? (this.v = Ae, this) : new __await(Ae);
}
function __asyncGenerator(Ae, t, Ie) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var Be = Ie.apply(Ae, t || []), Pe, Te = [];
  return Pe = {}, Me("next"), Me("throw"), Me("return"), Pe[Symbol.asyncIterator] = function() {
    return this;
  }, Pe;
  function Me(En) {
    Be[En] && (Pe[En] = function(fi) {
      return new Promise(function(bi, mi) {
        Te.push([En, fi, bi, mi]) > 1 || Ue(En, fi);
      });
    });
  }
  function Ue(En, fi) {
    try {
      je(Be[En](fi));
    } catch (bi) {
      vn(Te[0][3], bi);
    }
  }
  function je(En) {
    En.value instanceof __await ? Promise.resolve(En.value.v).then(fn, Ve) : vn(Te[0][2], En);
  }
  function fn(En) {
    Ue("next", En);
  }
  function Ve(En) {
    Ue("throw", En);
  }
  function vn(En, fi) {
    En(fi), Te.shift(), Te.length && Ue(Te[0][0], Te[0][1]);
  }
}
function __asyncDelegator(Ae) {
  var t, Ie;
  return t = {}, Be("next"), Be("throw", function(Pe) {
    throw Pe;
  }), Be("return"), t[Symbol.iterator] = function() {
    return this;
  }, t;
  function Be(Pe, Te) {
    t[Pe] = Ae[Pe] ? function(Me) {
      return (Ie = !Ie) ? { value: __await(Ae[Pe](Me)), done: Pe === "return" } : Te ? Te(Me) : Me;
    } : Te;
  }
}
function __asyncValues(Ae) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = Ae[Symbol.asyncIterator], Ie;
  return t ? t.call(Ae) : (Ae = typeof __values == "function" ? __values(Ae) : Ae[Symbol.iterator](), Ie = {}, Be("next"), Be("throw"), Be("return"), Ie[Symbol.asyncIterator] = function() {
    return this;
  }, Ie);
  function Be(Te) {
    Ie[Te] = Ae[Te] && function(Me) {
      return new Promise(function(Ue, je) {
        Me = Ae[Te](Me), Pe(Ue, je, Me.done, Me.value);
      });
    };
  }
  function Pe(Te, Me, Ue, je) {
    Promise.resolve(je).then(function(fn) {
      Te({ value: fn, done: Ue });
    }, Me);
  }
}
function __makeTemplateObject(Ae, t) {
  return Object.defineProperty ? Object.defineProperty(Ae, "raw", { value: t }) : Ae.raw = t, Ae;
}
function __importStar(Ae) {
  if (Ae && Ae.__esModule) return Ae;
  var t = {};
  if (Ae != null) for (var Ie in Ae) Object.hasOwnProperty.call(Ae, Ie) && (t[Ie] = Ae[Ie]);
  return t.default = Ae, t;
}
function __importDefault(Ae) {
  return Ae && Ae.__esModule ? Ae : { default: Ae };
}
function __classPrivateFieldGet(Ae, t) {
  if (!t.has(Ae))
    throw new TypeError("attempted to get private field on non-instance");
  return t.get(Ae);
}
function __classPrivateFieldSet(Ae, t, Ie) {
  if (!t.has(Ae))
    throw new TypeError("attempted to set private field on non-instance");
  return t.set(Ae, Ie), Ie;
}
const tslib_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __read,
  __rest,
  __spread,
  __spreadArrays,
  __values
}, Symbol.toStringTag, { value: "Module" })), require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6);
var utils = {}, delay = {}, hasRequiredDelay;
function requireDelay() {
  if (hasRequiredDelay) return delay;
  hasRequiredDelay = 1, Object.defineProperty(delay, "__esModule", { value: !0 }), delay.delay = void 0;
  function Ae(t) {
    return new Promise((Ie) => {
      setTimeout(() => {
        Ie(!0);
      }, t);
    });
  }
  return delay.delay = Ae, delay;
}
var convert = {}, constants = {}, misc = {}, hasRequiredMisc;
function requireMisc() {
  return hasRequiredMisc || (hasRequiredMisc = 1, Object.defineProperty(misc, "__esModule", { value: !0 }), misc.ONE_THOUSAND = misc.ONE_HUNDRED = void 0, misc.ONE_HUNDRED = 100, misc.ONE_THOUSAND = 1e3), misc;
}
var time = {}, hasRequiredTime;
function requireTime() {
  return hasRequiredTime || (hasRequiredTime = 1, function(Ae) {
    Object.defineProperty(Ae, "__esModule", { value: !0 }), Ae.ONE_YEAR = Ae.FOUR_WEEKS = Ae.THREE_WEEKS = Ae.TWO_WEEKS = Ae.ONE_WEEK = Ae.THIRTY_DAYS = Ae.SEVEN_DAYS = Ae.FIVE_DAYS = Ae.THREE_DAYS = Ae.ONE_DAY = Ae.TWENTY_FOUR_HOURS = Ae.TWELVE_HOURS = Ae.SIX_HOURS = Ae.THREE_HOURS = Ae.ONE_HOUR = Ae.SIXTY_MINUTES = Ae.THIRTY_MINUTES = Ae.TEN_MINUTES = Ae.FIVE_MINUTES = Ae.ONE_MINUTE = Ae.SIXTY_SECONDS = Ae.THIRTY_SECONDS = Ae.TEN_SECONDS = Ae.FIVE_SECONDS = Ae.ONE_SECOND = void 0, Ae.ONE_SECOND = 1, Ae.FIVE_SECONDS = 5, Ae.TEN_SECONDS = 10, Ae.THIRTY_SECONDS = 30, Ae.SIXTY_SECONDS = 60, Ae.ONE_MINUTE = Ae.SIXTY_SECONDS, Ae.FIVE_MINUTES = Ae.ONE_MINUTE * 5, Ae.TEN_MINUTES = Ae.ONE_MINUTE * 10, Ae.THIRTY_MINUTES = Ae.ONE_MINUTE * 30, Ae.SIXTY_MINUTES = Ae.ONE_MINUTE * 60, Ae.ONE_HOUR = Ae.SIXTY_MINUTES, Ae.THREE_HOURS = Ae.ONE_HOUR * 3, Ae.SIX_HOURS = Ae.ONE_HOUR * 6, Ae.TWELVE_HOURS = Ae.ONE_HOUR * 12, Ae.TWENTY_FOUR_HOURS = Ae.ONE_HOUR * 24, Ae.ONE_DAY = Ae.TWENTY_FOUR_HOURS, Ae.THREE_DAYS = Ae.ONE_DAY * 3, Ae.FIVE_DAYS = Ae.ONE_DAY * 5, Ae.SEVEN_DAYS = Ae.ONE_DAY * 7, Ae.THIRTY_DAYS = Ae.ONE_DAY * 30, Ae.ONE_WEEK = Ae.SEVEN_DAYS, Ae.TWO_WEEKS = Ae.ONE_WEEK * 2, Ae.THREE_WEEKS = Ae.ONE_WEEK * 3, Ae.FOUR_WEEKS = Ae.ONE_WEEK * 4, Ae.ONE_YEAR = Ae.ONE_DAY * 365;
  }(time)), time;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(Ae) {
    Object.defineProperty(Ae, "__esModule", { value: !0 });
    const t = require$$0$1;
    t.__exportStar(requireMisc(), Ae), t.__exportStar(requireTime(), Ae);
  }(constants)), constants;
}
var hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert) return convert;
  hasRequiredConvert = 1, Object.defineProperty(convert, "__esModule", { value: !0 }), convert.fromMiliseconds = convert.toMiliseconds = void 0;
  const Ae = requireConstants();
  function t(Be) {
    return Be * Ae.ONE_THOUSAND;
  }
  convert.toMiliseconds = t;
  function Ie(Be) {
    return Math.floor(Be / Ae.ONE_THOUSAND);
  }
  return convert.fromMiliseconds = Ie, convert;
}
var hasRequiredUtils;
function requireUtils() {
  return hasRequiredUtils || (hasRequiredUtils = 1, function(Ae) {
    Object.defineProperty(Ae, "__esModule", { value: !0 });
    const t = require$$0$1;
    t.__exportStar(requireDelay(), Ae), t.__exportStar(requireConvert(), Ae);
  }(utils)), utils;
}
var watch$2 = {}, hasRequiredWatch$1;
function requireWatch$1() {
  if (hasRequiredWatch$1) return watch$2;
  hasRequiredWatch$1 = 1, Object.defineProperty(watch$2, "__esModule", { value: !0 }), watch$2.Watch = void 0;
  class Ae {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(Ie) {
      if (this.timestamps.has(Ie))
        throw new Error(`Watch already started for label: ${Ie}`);
      this.timestamps.set(Ie, { started: Date.now() });
    }
    stop(Ie) {
      const Be = this.get(Ie);
      if (typeof Be.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${Ie}`);
      const Pe = Date.now() - Be.started;
      this.timestamps.set(Ie, { started: Be.started, elapsed: Pe });
    }
    get(Ie) {
      const Be = this.timestamps.get(Ie);
      if (typeof Be > "u")
        throw new Error(`No timestamp found for label: ${Ie}`);
      return Be;
    }
    elapsed(Ie) {
      const Be = this.get(Ie);
      return Be.elapsed || Date.now() - Be.started;
    }
  }
  return watch$2.Watch = Ae, watch$2.default = Ae, watch$2;
}
var types = {}, watch$1 = {}, hasRequiredWatch;
function requireWatch() {
  if (hasRequiredWatch) return watch$1;
  hasRequiredWatch = 1, Object.defineProperty(watch$1, "__esModule", { value: !0 }), watch$1.IWatch = void 0;
  class Ae {
  }
  return watch$1.IWatch = Ae, watch$1;
}
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(Ae) {
    Object.defineProperty(Ae, "__esModule", { value: !0 }), require$$0$1.__exportStar(requireWatch(), Ae);
  }(types)), types;
}
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  const t = require$$0$1;
  t.__exportStar(requireUtils(), Ae), t.__exportStar(requireWatch$1(), Ae), t.__exportStar(requireTypes(), Ae), t.__exportStar(requireConstants(), Ae);
})(cjs$3);
class IEvents {
}
let n$3 = class extends IEvents {
  constructor(t) {
    super();
  }
};
const s = cjs$3.FIVE_SECONDS, r$1 = { pulse: "heartbeat_pulse" };
let i$1 = class Wc extends n$3 {
  constructor(t) {
    super(t), this.events = new eventsExports.EventEmitter(), this.interval = s, this.interval = (t == null ? void 0 : t.interval) || s;
  }
  static async init(t) {
    const Ie = new Wc(t);
    return await Ie.init(), Ie;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(t, Ie) {
    this.events.on(t, Ie);
  }
  once(t, Ie) {
    this.events.once(t, Ie);
  }
  off(t, Ie) {
    this.events.off(t, Ie);
  }
  removeListener(t, Ie) {
    this.events.removeListener(t, Ie);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), cjs$3.toMiliseconds(this.interval));
  }
  pulse() {
    this.events.emit(r$1.pulse);
  }
};
const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(Ae, t) {
  if (Ae === "__proto__" || Ae === "constructor" && t && typeof t == "object" && "prototype" in t) {
    warnKeyDropped(Ae);
    return;
  }
  return t;
}
function warnKeyDropped(Ae) {
  console.warn(`[destr] Dropping "${Ae}" key to prevent prototype pollution.`);
}
function destr(Ae, t = {}) {
  if (typeof Ae != "string")
    return Ae;
  const Ie = Ae.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    Ae[0] === '"' && Ae.endsWith('"') && !Ae.includes("\\")
  )
    return Ie.slice(1, -1);
  if (Ie.length <= 9) {
    const Be = Ie.toLowerCase();
    if (Be === "true")
      return !0;
    if (Be === "false")
      return !1;
    if (Be === "undefined")
      return;
    if (Be === "null")
      return null;
    if (Be === "nan")
      return Number.NaN;
    if (Be === "infinity")
      return Number.POSITIVE_INFINITY;
    if (Be === "-infinity")
      return Number.NEGATIVE_INFINITY;
  }
  if (!JsonSigRx.test(Ae)) {
    if (t.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return Ae;
  }
  try {
    if (suspectProtoRx.test(Ae) || suspectConstructorRx.test(Ae)) {
      if (t.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(Ae, jsonParseTransform);
    }
    return JSON.parse(Ae);
  } catch (Be) {
    if (t.strict)
      throw Be;
    return Ae;
  }
}
function wrapToPromise(Ae) {
  return !Ae || typeof Ae.then != "function" ? Promise.resolve(Ae) : Ae;
}
function asyncCall(Ae, ...t) {
  try {
    return wrapToPromise(Ae(...t));
  } catch (Ie) {
    return Promise.reject(Ie);
  }
}
function isPrimitive(Ae) {
  const t = typeof Ae;
  return Ae === null || t !== "object" && t !== "function";
}
function isPureObject(Ae) {
  const t = Object.getPrototypeOf(Ae);
  return !t || t.isPrototypeOf(Object);
}
function stringify(Ae) {
  if (isPrimitive(Ae))
    return String(Ae);
  if (isPureObject(Ae) || Array.isArray(Ae))
    return JSON.stringify(Ae);
  if (typeof Ae.toJSON == "function")
    return stringify(Ae.toJSON());
  throw new Error("[unstorage] Cannot stringify value!");
}
function checkBufferSupport() {
  if (typeof Buffer$3 > "u")
    throw new TypeError("[unstorage] Buffer is not supported!");
}
const BASE64_PREFIX = "base64:";
function serializeRaw(Ae) {
  if (typeof Ae == "string")
    return Ae;
  checkBufferSupport();
  const t = Buffer$3.from(Ae).toString("base64");
  return BASE64_PREFIX + t;
}
function deserializeRaw(Ae) {
  return typeof Ae != "string" || !Ae.startsWith(BASE64_PREFIX) ? Ae : (checkBufferSupport(), Buffer$3.from(Ae.slice(BASE64_PREFIX.length), "base64"));
}
function normalizeKey(Ae) {
  return Ae ? Ae.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : "";
}
function joinKeys(...Ae) {
  return normalizeKey(Ae.join(":"));
}
function normalizeBaseKey(Ae) {
  return Ae = normalizeKey(Ae), Ae ? Ae + ":" : "";
}
function defineDriver(Ae) {
  return Ae;
}
const DRIVER_NAME = "memory", memory = () => {
  const Ae = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => Ae,
    hasItem(t) {
      return Ae.has(t);
    },
    getItem(t) {
      return Ae.get(t) ?? null;
    },
    getItemRaw(t) {
      return Ae.get(t) ?? null;
    },
    setItem(t, Ie) {
      Ae.set(t, Ie);
    },
    setItemRaw(t, Ie) {
      Ae.set(t, Ie);
    },
    removeItem(t) {
      Ae.delete(t);
    },
    getKeys() {
      return [...Ae.keys()];
    },
    clear() {
      Ae.clear();
    },
    dispose() {
      Ae.clear();
    }
  };
};
function createStorage(Ae = {}) {
  const t = {
    mounts: { "": Ae.driver || memory() },
    mountpoints: [""],
    watching: !1,
    watchListeners: [],
    unwatch: {}
  }, Ie = (fn) => {
    for (const Ve of t.mountpoints)
      if (fn.startsWith(Ve))
        return {
          base: Ve,
          relativeKey: fn.slice(Ve.length),
          driver: t.mounts[Ve]
        };
    return {
      base: "",
      relativeKey: fn,
      driver: t.mounts[""]
    };
  }, Be = (fn, Ve) => t.mountpoints.filter(
    (vn) => vn.startsWith(fn) || Ve && fn.startsWith(vn)
  ).map((vn) => ({
    relativeBase: fn.length > vn.length ? fn.slice(vn.length) : void 0,
    mountpoint: vn,
    driver: t.mounts[vn]
  })), Pe = (fn, Ve) => {
    if (t.watching) {
      Ve = normalizeKey(Ve);
      for (const vn of t.watchListeners)
        vn(fn, Ve);
    }
  }, Te = async () => {
    if (!t.watching) {
      t.watching = !0;
      for (const fn in t.mounts)
        t.unwatch[fn] = await watch(
          t.mounts[fn],
          Pe,
          fn
        );
    }
  }, Me = async () => {
    if (t.watching) {
      for (const fn in t.unwatch)
        await t.unwatch[fn]();
      t.unwatch = {}, t.watching = !1;
    }
  }, Ue = (fn, Ve, vn) => {
    const En = /* @__PURE__ */ new Map(), fi = (bi) => {
      let mi = En.get(bi.base);
      return mi || (mi = {
        driver: bi.driver,
        base: bi.base,
        items: []
      }, En.set(bi.base, mi)), mi;
    };
    for (const bi of fn) {
      const mi = typeof bi == "string", _i = normalizeKey(mi ? bi : bi.key), Ei = mi ? void 0 : bi.value, Si = mi || !bi.options ? Ve : { ...Ve, ...bi.options }, Mi = Ie(_i);
      fi(Mi).items.push({
        key: _i,
        value: Ei,
        relativeKey: Mi.relativeKey,
        options: Si
      });
    }
    return Promise.all([...En.values()].map((bi) => vn(bi))).then(
      (bi) => bi.flat()
    );
  }, je = {
    // Item
    hasItem(fn, Ve = {}) {
      fn = normalizeKey(fn);
      const { relativeKey: vn, driver: En } = Ie(fn);
      return asyncCall(En.hasItem, vn, Ve);
    },
    getItem(fn, Ve = {}) {
      fn = normalizeKey(fn);
      const { relativeKey: vn, driver: En } = Ie(fn);
      return asyncCall(En.getItem, vn, Ve).then(
        (fi) => destr(fi)
      );
    },
    getItems(fn, Ve) {
      return Ue(fn, Ve, (vn) => vn.driver.getItems ? asyncCall(
        vn.driver.getItems,
        vn.items.map((En) => ({
          key: En.relativeKey,
          options: En.options
        })),
        Ve
      ).then(
        (En) => En.map((fi) => ({
          key: joinKeys(vn.base, fi.key),
          value: destr(fi.value)
        }))
      ) : Promise.all(
        vn.items.map((En) => asyncCall(
          vn.driver.getItem,
          En.relativeKey,
          En.options
        ).then((fi) => ({
          key: En.key,
          value: destr(fi)
        })))
      ));
    },
    getItemRaw(fn, Ve = {}) {
      fn = normalizeKey(fn);
      const { relativeKey: vn, driver: En } = Ie(fn);
      return En.getItemRaw ? asyncCall(En.getItemRaw, vn, Ve) : asyncCall(En.getItem, vn, Ve).then(
        (fi) => deserializeRaw(fi)
      );
    },
    async setItem(fn, Ve, vn = {}) {
      if (Ve === void 0)
        return je.removeItem(fn);
      fn = normalizeKey(fn);
      const { relativeKey: En, driver: fi } = Ie(fn);
      fi.setItem && (await asyncCall(fi.setItem, En, stringify(Ve), vn), fi.watch || Pe("update", fn));
    },
    async setItems(fn, Ve) {
      await Ue(fn, Ve, async (vn) => {
        if (vn.driver.setItems)
          return asyncCall(
            vn.driver.setItems,
            vn.items.map((En) => ({
              key: En.relativeKey,
              value: stringify(En.value),
              options: En.options
            })),
            Ve
          );
        vn.driver.setItem && await Promise.all(
          vn.items.map((En) => asyncCall(
            vn.driver.setItem,
            En.relativeKey,
            stringify(En.value),
            En.options
          ))
        );
      });
    },
    async setItemRaw(fn, Ve, vn = {}) {
      if (Ve === void 0)
        return je.removeItem(fn, vn);
      fn = normalizeKey(fn);
      const { relativeKey: En, driver: fi } = Ie(fn);
      if (fi.setItemRaw)
        await asyncCall(fi.setItemRaw, En, Ve, vn);
      else if (fi.setItem)
        await asyncCall(fi.setItem, En, serializeRaw(Ve), vn);
      else
        return;
      fi.watch || Pe("update", fn);
    },
    async removeItem(fn, Ve = {}) {
      typeof Ve == "boolean" && (Ve = { removeMeta: Ve }), fn = normalizeKey(fn);
      const { relativeKey: vn, driver: En } = Ie(fn);
      En.removeItem && (await asyncCall(En.removeItem, vn, Ve), (Ve.removeMeta || Ve.removeMata) && await asyncCall(En.removeItem, vn + "$", Ve), En.watch || Pe("remove", fn));
    },
    // Meta
    async getMeta(fn, Ve = {}) {
      typeof Ve == "boolean" && (Ve = { nativeOnly: Ve }), fn = normalizeKey(fn);
      const { relativeKey: vn, driver: En } = Ie(fn), fi = /* @__PURE__ */ Object.create(null);
      if (En.getMeta && Object.assign(fi, await asyncCall(En.getMeta, vn, Ve)), !Ve.nativeOnly) {
        const bi = await asyncCall(
          En.getItem,
          vn + "$",
          Ve
        ).then((mi) => destr(mi));
        bi && typeof bi == "object" && (typeof bi.atime == "string" && (bi.atime = new Date(bi.atime)), typeof bi.mtime == "string" && (bi.mtime = new Date(bi.mtime)), Object.assign(fi, bi));
      }
      return fi;
    },
    setMeta(fn, Ve, vn = {}) {
      return this.setItem(fn + "$", Ve, vn);
    },
    removeMeta(fn, Ve = {}) {
      return this.removeItem(fn + "$", Ve);
    },
    // Keys
    async getKeys(fn, Ve = {}) {
      fn = normalizeBaseKey(fn);
      const vn = Be(fn, !0);
      let En = [];
      const fi = [];
      for (const bi of vn) {
        const mi = await asyncCall(
          bi.driver.getKeys,
          bi.relativeBase,
          Ve
        );
        for (const _i of mi) {
          const Ei = bi.mountpoint + normalizeKey(_i);
          En.some((Si) => Ei.startsWith(Si)) || fi.push(Ei);
        }
        En = [
          bi.mountpoint,
          ...En.filter((_i) => !_i.startsWith(bi.mountpoint))
        ];
      }
      return fn ? fi.filter(
        (bi) => bi.startsWith(fn) && bi[bi.length - 1] !== "$"
      ) : fi.filter((bi) => bi[bi.length - 1] !== "$");
    },
    // Utils
    async clear(fn, Ve = {}) {
      fn = normalizeBaseKey(fn), await Promise.all(
        Be(fn, !1).map(async (vn) => {
          if (vn.driver.clear)
            return asyncCall(vn.driver.clear, vn.relativeBase, Ve);
          if (vn.driver.removeItem) {
            const En = await vn.driver.getKeys(vn.relativeBase || "", Ve);
            return Promise.all(
              En.map((fi) => vn.driver.removeItem(fi, Ve))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(t.mounts).map((fn) => dispose(fn))
      );
    },
    async watch(fn) {
      return await Te(), t.watchListeners.push(fn), async () => {
        t.watchListeners = t.watchListeners.filter(
          (Ve) => Ve !== fn
        ), t.watchListeners.length === 0 && await Me();
      };
    },
    async unwatch() {
      t.watchListeners = [], await Me();
    },
    // Mount
    mount(fn, Ve) {
      if (fn = normalizeBaseKey(fn), fn && t.mounts[fn])
        throw new Error(`already mounted at ${fn}`);
      return fn && (t.mountpoints.push(fn), t.mountpoints.sort((vn, En) => En.length - vn.length)), t.mounts[fn] = Ve, t.watching && Promise.resolve(watch(Ve, Pe, fn)).then((vn) => {
        t.unwatch[fn] = vn;
      }).catch(console.error), je;
    },
    async unmount(fn, Ve = !0) {
      fn = normalizeBaseKey(fn), !(!fn || !t.mounts[fn]) && (t.watching && fn in t.unwatch && (t.unwatch[fn](), delete t.unwatch[fn]), Ve && await dispose(t.mounts[fn]), t.mountpoints = t.mountpoints.filter((vn) => vn !== fn), delete t.mounts[fn]);
    },
    getMount(fn = "") {
      fn = normalizeKey(fn) + ":";
      const Ve = Ie(fn);
      return {
        driver: Ve.driver,
        base: Ve.base
      };
    },
    getMounts(fn = "", Ve = {}) {
      return fn = normalizeKey(fn), Be(fn, Ve.parents).map((En) => ({
        driver: En.driver,
        base: En.mountpoint
      }));
    },
    // Aliases
    keys: (fn, Ve = {}) => je.getKeys(fn, Ve),
    get: (fn, Ve = {}) => je.getItem(fn, Ve),
    set: (fn, Ve, vn = {}) => je.setItem(fn, Ve, vn),
    has: (fn, Ve = {}) => je.hasItem(fn, Ve),
    del: (fn, Ve = {}) => je.removeItem(fn, Ve),
    remove: (fn, Ve = {}) => je.removeItem(fn, Ve)
  };
  return je;
}
function watch(Ae, t, Ie) {
  return Ae.watch ? Ae.watch((Be, Pe) => t(Be, Ie + Pe)) : () => {
  };
}
async function dispose(Ae) {
  typeof Ae.dispose == "function" && await asyncCall(Ae.dispose);
}
function promisifyRequest(Ae) {
  return new Promise((t, Ie) => {
    Ae.oncomplete = Ae.onsuccess = () => t(Ae.result), Ae.onabort = Ae.onerror = () => Ie(Ae.error);
  });
}
function createStore(Ae, t) {
  const Ie = indexedDB.open(Ae);
  Ie.onupgradeneeded = () => Ie.result.createObjectStore(t);
  const Be = promisifyRequest(Ie);
  return (Pe, Te) => Be.then((Me) => Te(Me.transaction(t, Pe).objectStore(t)));
}
let defaultGetStoreFunc;
function defaultGetStore() {
  return defaultGetStoreFunc || (defaultGetStoreFunc = createStore("keyval-store", "keyval")), defaultGetStoreFunc;
}
function get(Ae, t = defaultGetStore()) {
  return t("readonly", (Ie) => promisifyRequest(Ie.get(Ae)));
}
function set$1(Ae, t, Ie = defaultGetStore()) {
  return Ie("readwrite", (Be) => (Be.put(t, Ae), promisifyRequest(Be.transaction)));
}
function del(Ae, t = defaultGetStore()) {
  return t("readwrite", (Ie) => (Ie.delete(Ae), promisifyRequest(Ie.transaction)));
}
function clear(Ae = defaultGetStore()) {
  return Ae("readwrite", (t) => (t.clear(), promisifyRequest(t.transaction)));
}
function eachCursor(Ae, t) {
  return Ae.openCursor().onsuccess = function() {
    this.result && (t(this.result), this.result.continue());
  }, promisifyRequest(Ae.transaction);
}
function keys(Ae = defaultGetStore()) {
  return Ae("readonly", (t) => {
    if (t.getAllKeys)
      return promisifyRequest(t.getAllKeys());
    const Ie = [];
    return eachCursor(t, (Be) => Ie.push(Be.key)).then(() => Ie);
  });
}
const JSONStringify = (Ae) => JSON.stringify(Ae, (t, Ie) => typeof Ie == "bigint" ? Ie.toString() + "n" : Ie), JSONParse = (Ae) => {
  const t = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, Ie = Ae.replace(t, '$1"$2n"$3');
  return JSON.parse(Ie, (Be, Pe) => typeof Pe == "string" && Pe.match(/^\d+n$/) ? BigInt(Pe.substring(0, Pe.length - 1)) : Pe);
};
function safeJsonParse(Ae) {
  if (typeof Ae != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof Ae}`);
  try {
    return JSONParse(Ae);
  } catch {
    return Ae;
  }
}
function safeJsonStringify(Ae) {
  return typeof Ae == "string" ? Ae : JSONStringify(Ae) || "";
}
const x$6 = "idb-keyval";
var z$6 = (Ae = {}) => {
  const t = Ae.base && Ae.base.length > 0 ? `${Ae.base}:` : "", Ie = (Pe) => t + Pe;
  let Be;
  return Ae.dbName && Ae.storeName && (Be = createStore(Ae.dbName, Ae.storeName)), { name: x$6, options: Ae, async hasItem(Pe) {
    return !(typeof await get(Ie(Pe), Be) > "u");
  }, async getItem(Pe) {
    return await get(Ie(Pe), Be) ?? null;
  }, setItem(Pe, Te) {
    return set$1(Ie(Pe), Te, Be);
  }, removeItem(Pe) {
    return del(Ie(Pe), Be);
  }, getKeys() {
    return keys(Be);
  }, clear() {
    return clear(Be);
  } };
};
const D$3 = "WALLET_CONNECT_V2_INDEXED_DB", E$2 = "keyvaluestorage";
let _$3 = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z$6({ dbName: D$3, storeName: E$2 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const Ie = await this.indexedDb.getItem(t);
    if (Ie !== null) return Ie;
  }
  async setItem(t, Ie) {
    await this.indexedDb.setItem(t, safeJsonStringify(Ie));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l$2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, c$2 = { exports: {} };
(function() {
  let Ae;
  function t() {
  }
  Ae = t, Ae.prototype.getItem = function(Ie) {
    return this.hasOwnProperty(Ie) ? String(this[Ie]) : null;
  }, Ae.prototype.setItem = function(Ie, Be) {
    this[Ie] = String(Be);
  }, Ae.prototype.removeItem = function(Ie) {
    delete this[Ie];
  }, Ae.prototype.clear = function() {
    const Ie = this;
    Object.keys(Ie).forEach(function(Be) {
      Ie[Be] = void 0, delete Ie[Be];
    });
  }, Ae.prototype.key = function(Ie) {
    return Ie = Ie || 0, Object.keys(this)[Ie];
  }, Ae.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l$2 < "u" && l$2.localStorage ? c$2.exports = l$2.localStorage : typeof window < "u" && window.localStorage ? c$2.exports = window.localStorage : c$2.exports = new t();
})();
function k$3(Ae) {
  var t;
  return [Ae[0], safeJsonParse((t = Ae[1]) != null ? t : "")];
}
let K$3 = class {
  constructor() {
    this.localStorage = c$2.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k$3);
  }
  async getItem(t) {
    const Ie = this.localStorage.getItem(t);
    if (Ie !== null) return safeJsonParse(Ie);
  }
  async setItem(t, Ie) {
    this.localStorage.setItem(t, safeJsonStringify(Ie));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
const N$1 = "wc_storage_version", y$4 = 1, O$5 = async (Ae, t, Ie) => {
  const Be = N$1, Pe = await t.getItem(Be);
  if (Pe && Pe >= y$4) {
    Ie(t);
    return;
  }
  const Te = await Ae.getKeys();
  if (!Te.length) {
    Ie(t);
    return;
  }
  const Me = [];
  for (; Te.length; ) {
    const Ue = Te.shift();
    if (!Ue) continue;
    const je = Ue.toLowerCase();
    if (je.includes("wc@") || je.includes("walletconnect") || je.includes("wc_") || je.includes("wallet_connect")) {
      const fn = await Ae.getItem(Ue);
      await t.setItem(Ue, fn), Me.push(Ue);
    }
  }
  await t.setItem(Be, y$4), Ie(t), j$2(Ae, Me);
}, j$2 = async (Ae, t) => {
  t.length && t.forEach(async (Ie) => {
    await Ae.removeItem(Ie);
  });
};
let h$2 = class {
  constructor() {
    this.initialized = !1, this.setInitialized = (Ie) => {
      this.storage = Ie, this.initialized = !0;
    };
    const t = new K$3();
    this.storage = t;
    try {
      const Ie = new _$3();
      O$5(t, Ie, this.setInitialized);
    } catch {
      this.initialized = !0;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, Ie) {
    return await this.initialize(), this.storage.setItem(t, Ie);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const Ie = setInterval(() => {
        this.initialized && (clearInterval(Ie), t());
      }, 20);
    });
  }
};
function tryStringify(Ae) {
  try {
    return JSON.stringify(Ae);
  } catch {
    return '"[Circular]"';
  }
}
var quickFormatUnescaped = format$1;
function format$1(Ae, t, Ie) {
  var Be = Ie && Ie.stringify || tryStringify, Pe = 1;
  if (typeof Ae == "object" && Ae !== null) {
    var Te = t.length + Pe;
    if (Te === 1) return Ae;
    var Me = new Array(Te);
    Me[0] = Be(Ae);
    for (var Ue = 1; Ue < Te; Ue++)
      Me[Ue] = Be(t[Ue]);
    return Me.join(" ");
  }
  if (typeof Ae != "string")
    return Ae;
  var je = t.length;
  if (je === 0) return Ae;
  for (var fn = "", Ve = 1 - Pe, vn = -1, En = Ae && Ae.length || 0, fi = 0; fi < En; ) {
    if (Ae.charCodeAt(fi) === 37 && fi + 1 < En) {
      switch (vn = vn > -1 ? vn : 0, Ae.charCodeAt(fi + 1)) {
        case 100:
        case 102:
          if (Ve >= je || t[Ve] == null) break;
          vn < fi && (fn += Ae.slice(vn, fi)), fn += Number(t[Ve]), vn = fi + 2, fi++;
          break;
        case 105:
          if (Ve >= je || t[Ve] == null) break;
          vn < fi && (fn += Ae.slice(vn, fi)), fn += Math.floor(Number(t[Ve])), vn = fi + 2, fi++;
          break;
        case 79:
        case 111:
        case 106:
          if (Ve >= je || t[Ve] === void 0) break;
          vn < fi && (fn += Ae.slice(vn, fi));
          var bi = typeof t[Ve];
          if (bi === "string") {
            fn += "'" + t[Ve] + "'", vn = fi + 2, fi++;
            break;
          }
          if (bi === "function") {
            fn += t[Ve].name || "<anonymous>", vn = fi + 2, fi++;
            break;
          }
          fn += Be(t[Ve]), vn = fi + 2, fi++;
          break;
        case 115:
          if (Ve >= je)
            break;
          vn < fi && (fn += Ae.slice(vn, fi)), fn += String(t[Ve]), vn = fi + 2, fi++;
          break;
        case 37:
          vn < fi && (fn += Ae.slice(vn, fi)), fn += "%", vn = fi + 2, fi++, Ve--;
          break;
      }
      ++Ve;
    }
    ++fi;
  }
  return vn === -1 ? Ae : (vn < En && (fn += Ae.slice(vn)), fn);
}
const format = quickFormatUnescaped;
var browser$2 = pino;
const _console = pfGlobalThisOrFallback().console || {}, stdSerializers = {
  mapHttpRequest: mock,
  mapHttpResponse: mock,
  wrapRequestSerializer: passthrough,
  wrapResponseSerializer: passthrough,
  wrapErrorSerializer: passthrough,
  req: mock,
  res: mock,
  err: asErrValue
};
function shouldSerialize(Ae, t) {
  return Array.isArray(Ae) ? Ae.filter(function(Be) {
    return Be !== "!stdSerializers.err";
  }) : Ae === !0 ? Object.keys(t) : !1;
}
function pino(Ae) {
  Ae = Ae || {}, Ae.browser = Ae.browser || {};
  const t = Ae.browser.transmit;
  if (t && typeof t.send != "function")
    throw Error("pino: transmit option must have a send function");
  const Ie = Ae.browser.write || _console;
  Ae.browser.write && (Ae.browser.asObject = !0);
  const Be = Ae.serializers || {}, Pe = shouldSerialize(Ae.browser.serialize, Be);
  let Te = Ae.browser.serialize;
  Array.isArray(Ae.browser.serialize) && Ae.browser.serialize.indexOf("!stdSerializers.err") > -1 && (Te = !1);
  const Me = ["error", "fatal", "warn", "info", "debug", "trace"];
  typeof Ie == "function" && (Ie.error = Ie.fatal = Ie.warn = Ie.info = Ie.debug = Ie.trace = Ie), Ae.enabled === !1 && (Ae.level = "silent");
  const Ue = Ae.level || "info", je = Object.create(Ie);
  je.log || (je.log = noop), Object.defineProperty(je, "levelVal", {
    get: Ve
  }), Object.defineProperty(je, "level", {
    get: vn,
    set: En
  });
  const fn = {
    transmit: t,
    serialize: Pe,
    asObject: Ae.browser.asObject,
    levels: Me,
    timestamp: getTimeFunction(Ae)
  };
  je.levels = pino.levels, je.level = Ue, je.setMaxListeners = je.getMaxListeners = je.emit = je.addListener = je.on = je.prependListener = je.once = je.prependOnceListener = je.removeListener = je.removeAllListeners = je.listeners = je.listenerCount = je.eventNames = je.write = je.flush = noop, je.serializers = Be, je._serialize = Pe, je._stdErrSerialize = Te, je.child = fi, t && (je._logEvent = createLogEventShape());
  function Ve() {
    return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
  }
  function vn() {
    return this._level;
  }
  function En(bi) {
    if (bi !== "silent" && !this.levels.values[bi])
      throw Error("unknown level " + bi);
    this._level = bi, set(fn, je, "error", "log"), set(fn, je, "fatal", "error"), set(fn, je, "warn", "error"), set(fn, je, "info", "log"), set(fn, je, "debug", "log"), set(fn, je, "trace", "log");
  }
  function fi(bi, mi) {
    if (!bi)
      throw new Error("missing bindings for child Pino");
    mi = mi || {}, Pe && bi.serializers && (mi.serializers = bi.serializers);
    const _i = mi.serializers;
    if (Pe && _i) {
      var Ei = Object.assign({}, Be, _i), Si = Ae.browser.serialize === !0 ? Object.keys(Ei) : Pe;
      delete bi.serializers, applySerializers([bi], Si, Ei, this._stdErrSerialize);
    }
    function Mi(Oi) {
      this._childLevel = (Oi._childLevel | 0) + 1, this.error = bind(Oi, bi, "error"), this.fatal = bind(Oi, bi, "fatal"), this.warn = bind(Oi, bi, "warn"), this.info = bind(Oi, bi, "info"), this.debug = bind(Oi, bi, "debug"), this.trace = bind(Oi, bi, "trace"), Ei && (this.serializers = Ei, this._serialize = Si), t && (this._logEvent = createLogEventShape(
        [].concat(Oi._logEvent.bindings, bi)
      ));
    }
    return Mi.prototype = this, new Mi(this);
  }
  return je;
}
pino.levels = {
  values: {
    fatal: 60,
    error: 50,
    warn: 40,
    info: 30,
    debug: 20,
    trace: 10
  },
  labels: {
    10: "trace",
    20: "debug",
    30: "info",
    40: "warn",
    50: "error",
    60: "fatal"
  }
};
pino.stdSerializers = stdSerializers;
pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
function set(Ae, t, Ie, Be) {
  const Pe = Object.getPrototypeOf(t);
  t[Ie] = t.levelVal > t.levels.values[Ie] ? noop : Pe[Ie] ? Pe[Ie] : _console[Ie] || _console[Be] || noop, wrap(Ae, t, Ie);
}
function wrap(Ae, t, Ie) {
  !Ae.transmit && t[Ie] === noop || (t[Ie] = /* @__PURE__ */ function(Be) {
    return function() {
      const Te = Ae.timestamp(), Me = new Array(arguments.length), Ue = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
      for (var je = 0; je < Me.length; je++) Me[je] = arguments[je];
      if (Ae.serialize && !Ae.asObject && applySerializers(Me, this._serialize, this.serializers, this._stdErrSerialize), Ae.asObject ? Be.call(Ue, asObject(this, Ie, Me, Te)) : Be.apply(Ue, Me), Ae.transmit) {
        const fn = Ae.transmit.level || t.level, Ve = pino.levels.values[fn], vn = pino.levels.values[Ie];
        if (vn < Ve) return;
        transmit(this, {
          ts: Te,
          methodLevel: Ie,
          methodValue: vn,
          transmitLevel: fn,
          transmitValue: pino.levels.values[Ae.transmit.level || t.level],
          send: Ae.transmit.send,
          val: t.levelVal
        }, Me);
      }
    };
  }(t[Ie]));
}
function asObject(Ae, t, Ie, Be) {
  Ae._serialize && applySerializers(Ie, Ae._serialize, Ae.serializers, Ae._stdErrSerialize);
  const Pe = Ie.slice();
  let Te = Pe[0];
  const Me = {};
  Be && (Me.time = Be), Me.level = pino.levels.values[t];
  let Ue = (Ae._childLevel | 0) + 1;
  if (Ue < 1 && (Ue = 1), Te !== null && typeof Te == "object") {
    for (; Ue-- && typeof Pe[0] == "object"; )
      Object.assign(Me, Pe.shift());
    Te = Pe.length ? format(Pe.shift(), Pe) : void 0;
  } else typeof Te == "string" && (Te = format(Pe.shift(), Pe));
  return Te !== void 0 && (Me.msg = Te), Me;
}
function applySerializers(Ae, t, Ie, Be) {
  for (const Pe in Ae)
    if (Be && Ae[Pe] instanceof Error)
      Ae[Pe] = pino.stdSerializers.err(Ae[Pe]);
    else if (typeof Ae[Pe] == "object" && !Array.isArray(Ae[Pe]))
      for (const Te in Ae[Pe])
        t && t.indexOf(Te) > -1 && Te in Ie && (Ae[Pe][Te] = Ie[Te](Ae[Pe][Te]));
}
function bind(Ae, t, Ie) {
  return function() {
    const Be = new Array(1 + arguments.length);
    Be[0] = t;
    for (var Pe = 1; Pe < Be.length; Pe++)
      Be[Pe] = arguments[Pe - 1];
    return Ae[Ie].apply(this, Be);
  };
}
function transmit(Ae, t, Ie) {
  const Be = t.send, Pe = t.ts, Te = t.methodLevel, Me = t.methodValue, Ue = t.val, je = Ae._logEvent.bindings;
  applySerializers(
    Ie,
    Ae._serialize || Object.keys(Ae.serializers),
    Ae.serializers,
    Ae._stdErrSerialize === void 0 ? !0 : Ae._stdErrSerialize
  ), Ae._logEvent.ts = Pe, Ae._logEvent.messages = Ie.filter(function(fn) {
    return je.indexOf(fn) === -1;
  }), Ae._logEvent.level.label = Te, Ae._logEvent.level.value = Me, Be(Te, Ae._logEvent, Ue), Ae._logEvent = createLogEventShape(je);
}
function createLogEventShape(Ae) {
  return {
    ts: 0,
    messages: [],
    bindings: Ae || [],
    level: { label: "", value: 0 }
  };
}
function asErrValue(Ae) {
  const t = {
    type: Ae.constructor.name,
    msg: Ae.message,
    stack: Ae.stack
  };
  for (const Ie in Ae)
    t[Ie] === void 0 && (t[Ie] = Ae[Ie]);
  return t;
}
function getTimeFunction(Ae) {
  return typeof Ae.timestamp == "function" ? Ae.timestamp : Ae.timestamp === !1 ? nullTime : epochTime;
}
function mock() {
  return {};
}
function passthrough(Ae) {
  return Ae;
}
function noop() {
}
function nullTime() {
  return !1;
}
function epochTime() {
  return Date.now();
}
function unixTime() {
  return Math.round(Date.now() / 1e3);
}
function isoTime() {
  return new Date(Date.now()).toISOString();
}
function pfGlobalThisOrFallback() {
  function Ae(t) {
    return typeof t < "u" && t;
  }
  try {
    return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
      get: function() {
        return delete Object.prototype.globalThis, this.globalThis = this;
      },
      configurable: !0
    }), globalThis;
  } catch {
    return Ae(self) || Ae(window) || Ae(this) || {};
  }
}
const qt$3 = /* @__PURE__ */ getDefaultExportFromCjs(browser$2), c$1 = { level: "info" }, n$2 = "custom_context", l$1 = 1e3 * 1024;
let O$4 = class {
  constructor(t) {
    this.nodeValue = t, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
}, d$2 = class {
  constructor(t) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = t, this.sizeInBytes = 0;
  }
  append(t) {
    const Ie = new O$4(t);
    if (Ie.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${t} with size ${Ie.size}`);
    for (; this.size + Ie.size > this.maxSizeInBytes; ) this.shift();
    this.head ? (this.tail && (this.tail.next = Ie), this.tail = Ie) : (this.head = Ie, this.tail = Ie), this.lengthInNodes++, this.sizeInBytes += Ie.size;
  }
  shift() {
    if (!this.head) return;
    const t = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= t.size;
  }
  toArray() {
    const t = [];
    let Ie = this.head;
    for (; Ie !== null; ) t.push(Ie.value), Ie = Ie.next;
    return t;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let t = this.head;
    return { next: () => {
      if (!t) return { done: !0, value: null };
      const Ie = t.value;
      return t = t.next, { done: !1, value: Ie };
    } };
  }
}, L$3 = class {
  constructor(t, Ie = l$1) {
    this.level = t ?? "error", this.levelValue = browser$2.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = Ie, this.logs = new d$2(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(t, Ie) {
    Ie === browser$2.levels.values.error ? console.error(t) : Ie === browser$2.levels.values.warn ? console.warn(t) : Ie === browser$2.levels.values.debug ? console.debug(t) : Ie === browser$2.levels.values.trace ? console.trace(t) : console.log(t);
  }
  appendToLogs(t) {
    this.logs.append(safeJsonStringify({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: t }));
    const Ie = typeof t == "string" ? JSON.parse(t).level : t.level;
    Ie >= this.levelValue && this.forwardToConsole(t, Ie);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new d$2(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(t) {
    const Ie = this.getLogArray();
    return Ie.push(safeJsonStringify({ extraMetadata: t })), new Blob(Ie, { type: "application/json" });
  }
};
class m {
  constructor(t, Ie = l$1) {
    this.baseChunkLogger = new L$3(t, Ie);
  }
  write(t) {
    this.baseChunkLogger.appendToLogs(t);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(t) {
    return this.baseChunkLogger.logsToBlob(t);
  }
  downloadLogsBlobInBrowser(t) {
    const Ie = URL.createObjectURL(this.logsToBlob(t)), Be = document.createElement("a");
    Be.href = Ie, Be.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(Be), Be.click(), document.body.removeChild(Be), URL.revokeObjectURL(Ie);
  }
}
let B$3 = class {
  constructor(t, Ie = l$1) {
    this.baseChunkLogger = new L$3(t, Ie);
  }
  write(t) {
    this.baseChunkLogger.appendToLogs(t);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(t) {
    return this.baseChunkLogger.logsToBlob(t);
  }
};
var x$5 = Object.defineProperty, S$6 = Object.defineProperties, _$2 = Object.getOwnPropertyDescriptors, p$2 = Object.getOwnPropertySymbols, T$2 = Object.prototype.hasOwnProperty, z$5 = Object.prototype.propertyIsEnumerable, f$3 = (Ae, t, Ie) => t in Ae ? x$5(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, i = (Ae, t) => {
  for (var Ie in t || (t = {})) T$2.call(t, Ie) && f$3(Ae, Ie, t[Ie]);
  if (p$2) for (var Ie of p$2(t)) z$5.call(t, Ie) && f$3(Ae, Ie, t[Ie]);
  return Ae;
}, g$3 = (Ae, t) => S$6(Ae, _$2(t));
function k$2(Ae) {
  return g$3(i({}, Ae), { level: (Ae == null ? void 0 : Ae.level) || c$1.level });
}
function v$4(Ae, t = n$2) {
  return Ae[t] || "";
}
function b$3(Ae, t, Ie = n$2) {
  return Ae[Ie] = t, Ae;
}
function y$3(Ae, t = n$2) {
  let Ie = "";
  return typeof Ae.bindings > "u" ? Ie = v$4(Ae, t) : Ie = Ae.bindings().context || "", Ie;
}
function w$2(Ae, t, Ie = n$2) {
  const Be = y$3(Ae, Ie);
  return Be.trim() ? `${Be}/${t}` : t;
}
function E$1(Ae, t, Ie = n$2) {
  const Be = w$2(Ae, t, Ie), Pe = Ae.child({ context: Be });
  return b$3(Pe, Be, Ie);
}
function C$4(Ae) {
  var t, Ie;
  const Be = new m((t = Ae.opts) == null ? void 0 : t.level, Ae.maxSizeInBytes);
  return { logger: qt$3(g$3(i({}, Ae.opts), { level: "trace", browser: g$3(i({}, (Ie = Ae.opts) == null ? void 0 : Ie.browser), { write: (Pe) => Be.write(Pe) }) })), chunkLoggerController: Be };
}
function I$4(Ae) {
  var t;
  const Ie = new B$3((t = Ae.opts) == null ? void 0 : t.level, Ae.maxSizeInBytes);
  return { logger: qt$3(g$3(i({}, Ae.opts), { level: "trace" }), Ie), chunkLoggerController: Ie };
}
function A$1(Ae) {
  return typeof Ae.loggerOverride < "u" && typeof Ae.loggerOverride != "string" ? { logger: Ae.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? C$4(Ae) : I$4(Ae);
}
let n$1 = class extends IEvents {
  constructor(t) {
    super(), this.opts = t, this.protocol = "wc", this.version = 2;
  }
}, h$1 = class extends IEvents {
  constructor(t, Ie) {
    super(), this.core = t, this.logger = Ie, this.records = /* @__PURE__ */ new Map();
  }
}, a$1 = class {
  constructor(t, Ie) {
    this.logger = t, this.core = Ie;
  }
}, g$2 = class extends IEvents {
  constructor(t, Ie) {
    super(), this.relayer = t, this.logger = Ie;
  }
};
class u extends IEvents {
  constructor(t) {
    super();
  }
}
let p$1 = class {
  constructor(t, Ie, Be, Pe) {
    this.core = t, this.logger = Ie, this.name = Be;
  }
}, d$1 = class extends IEvents {
  constructor(t, Ie) {
    super(), this.relayer = t, this.logger = Ie;
  }
}, x$4 = class extends IEvents {
  constructor(t, Ie) {
    super(), this.core = t, this.logger = Ie;
  }
}, y$2 = class {
  constructor(t, Ie, Be) {
    this.core = t, this.logger = Ie, this.store = Be;
  }
}, v$3 = class {
  constructor(t, Ie) {
    this.projectId = t, this.logger = Ie;
  }
}, C$3 = class {
  constructor(t, Ie, Be) {
    this.core = t, this.logger = Ie, this.telemetryEnabled = Be;
  }
}, S$5 = class {
  constructor(t) {
    this.opts = t, this.protocol = "wc", this.version = 2;
  }
}, M$3 = class {
  constructor(t) {
    this.client = t;
  }
};
var ed25519 = {}, random = {}, system = {}, browser$1 = {};
Object.defineProperty(browser$1, "__esModule", { value: !0 });
browser$1.BrowserRandomSource = void 0;
const QUOTA = 65536;
class BrowserRandomSource {
  constructor() {
    this.isAvailable = !1, this.isInstantiated = !1;
    const t = typeof self < "u" ? self.crypto || self.msCrypto : null;
    t && t.getRandomValues !== void 0 && (this._crypto = t, this.isAvailable = !0, this.isInstantiated = !0);
  }
  randomBytes(t) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Browser random byte generator is not available.");
    const Ie = new Uint8Array(t);
    for (let Be = 0; Be < Ie.length; Be += QUOTA)
      this._crypto.getRandomValues(Ie.subarray(Be, Be + Math.min(Ie.length - Be, QUOTA)));
    return Ie;
  }
}
browser$1.BrowserRandomSource = BrowserRandomSource;
var node = {}, wipe$1 = {};
Object.defineProperty(wipe$1, "__esModule", { value: !0 });
function wipe(Ae) {
  for (var t = 0; t < Ae.length; t++)
    Ae[t] = 0;
  return Ae;
}
wipe$1.wipe = wipe;
Object.defineProperty(node, "__esModule", { value: !0 });
node.NodeRandomSource = void 0;
const wipe_1$3 = wipe$1;
class NodeRandomSource {
  constructor() {
    if (this.isAvailable = !1, this.isInstantiated = !1, typeof commonjsRequire$1 < "u") {
      const t = requireCryptoBrowserify();
      t && t.randomBytes && (this._crypto = t, this.isAvailable = !0, this.isInstantiated = !0);
    }
  }
  randomBytes(t) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Node.js random byte generator is not available.");
    let Ie = this._crypto.randomBytes(t);
    if (Ie.length !== t)
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    const Be = new Uint8Array(t);
    for (let Pe = 0; Pe < Be.length; Pe++)
      Be[Pe] = Ie[Pe];
    return (0, wipe_1$3.wipe)(Ie), Be;
  }
}
node.NodeRandomSource = NodeRandomSource;
Object.defineProperty(system, "__esModule", { value: !0 });
system.SystemRandomSource = void 0;
const browser_1 = browser$1, node_1 = node;
class SystemRandomSource {
  constructor() {
    if (this.isAvailable = !1, this.name = "", this._source = new browser_1.BrowserRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Browser";
      return;
    }
    if (this._source = new node_1.NodeRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Node";
      return;
    }
  }
  randomBytes(t) {
    if (!this.isAvailable)
      throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(t);
  }
}
system.SystemRandomSource = SystemRandomSource;
var binary = {}, int = {};
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  function t(Ue, je) {
    var fn = Ue >>> 16 & 65535, Ve = Ue & 65535, vn = je >>> 16 & 65535, En = je & 65535;
    return Ve * En + (fn * En + Ve * vn << 16 >>> 0) | 0;
  }
  Ae.mul = Math.imul || t;
  function Ie(Ue, je) {
    return Ue + je | 0;
  }
  Ae.add = Ie;
  function Be(Ue, je) {
    return Ue - je | 0;
  }
  Ae.sub = Be;
  function Pe(Ue, je) {
    return Ue << je | Ue >>> 32 - je;
  }
  Ae.rotl = Pe;
  function Te(Ue, je) {
    return Ue << 32 - je | Ue >>> je;
  }
  Ae.rotr = Te;
  function Me(Ue) {
    return typeof Ue == "number" && isFinite(Ue) && Math.floor(Ue) === Ue;
  }
  Ae.isInteger = Number.isInteger || Me, Ae.MAX_SAFE_INTEGER = 9007199254740991, Ae.isSafeInteger = function(Ue) {
    return Ae.isInteger(Ue) && Ue >= -Ae.MAX_SAFE_INTEGER && Ue <= Ae.MAX_SAFE_INTEGER;
  };
})(int);
Object.defineProperty(binary, "__esModule", { value: !0 });
var int_1 = int;
function readInt16BE(Ae, t) {
  return t === void 0 && (t = 0), (Ae[t + 0] << 8 | Ae[t + 1]) << 16 >> 16;
}
binary.readInt16BE = readInt16BE;
function readUint16BE(Ae, t) {
  return t === void 0 && (t = 0), (Ae[t + 0] << 8 | Ae[t + 1]) >>> 0;
}
binary.readUint16BE = readUint16BE;
function readInt16LE(Ae, t) {
  return t === void 0 && (t = 0), (Ae[t + 1] << 8 | Ae[t]) << 16 >> 16;
}
binary.readInt16LE = readInt16LE;
function readUint16LE(Ae, t) {
  return t === void 0 && (t = 0), (Ae[t + 1] << 8 | Ae[t]) >>> 0;
}
binary.readUint16LE = readUint16LE;
function writeUint16BE(Ae, t, Ie) {
  return t === void 0 && (t = new Uint8Array(2)), Ie === void 0 && (Ie = 0), t[Ie + 0] = Ae >>> 8, t[Ie + 1] = Ae >>> 0, t;
}
binary.writeUint16BE = writeUint16BE;
binary.writeInt16BE = writeUint16BE;
function writeUint16LE(Ae, t, Ie) {
  return t === void 0 && (t = new Uint8Array(2)), Ie === void 0 && (Ie = 0), t[Ie + 0] = Ae >>> 0, t[Ie + 1] = Ae >>> 8, t;
}
binary.writeUint16LE = writeUint16LE;
binary.writeInt16LE = writeUint16LE;
function readInt32BE(Ae, t) {
  return t === void 0 && (t = 0), Ae[t] << 24 | Ae[t + 1] << 16 | Ae[t + 2] << 8 | Ae[t + 3];
}
binary.readInt32BE = readInt32BE;
function readUint32BE(Ae, t) {
  return t === void 0 && (t = 0), (Ae[t] << 24 | Ae[t + 1] << 16 | Ae[t + 2] << 8 | Ae[t + 3]) >>> 0;
}
binary.readUint32BE = readUint32BE;
function readInt32LE(Ae, t) {
  return t === void 0 && (t = 0), Ae[t + 3] << 24 | Ae[t + 2] << 16 | Ae[t + 1] << 8 | Ae[t];
}
binary.readInt32LE = readInt32LE;
function readUint32LE(Ae, t) {
  return t === void 0 && (t = 0), (Ae[t + 3] << 24 | Ae[t + 2] << 16 | Ae[t + 1] << 8 | Ae[t]) >>> 0;
}
binary.readUint32LE = readUint32LE;
function writeUint32BE(Ae, t, Ie) {
  return t === void 0 && (t = new Uint8Array(4)), Ie === void 0 && (Ie = 0), t[Ie + 0] = Ae >>> 24, t[Ie + 1] = Ae >>> 16, t[Ie + 2] = Ae >>> 8, t[Ie + 3] = Ae >>> 0, t;
}
binary.writeUint32BE = writeUint32BE;
binary.writeInt32BE = writeUint32BE;
function writeUint32LE(Ae, t, Ie) {
  return t === void 0 && (t = new Uint8Array(4)), Ie === void 0 && (Ie = 0), t[Ie + 0] = Ae >>> 0, t[Ie + 1] = Ae >>> 8, t[Ie + 2] = Ae >>> 16, t[Ie + 3] = Ae >>> 24, t;
}
binary.writeUint32LE = writeUint32LE;
binary.writeInt32LE = writeUint32LE;
function readInt64BE(Ae, t) {
  t === void 0 && (t = 0);
  var Ie = readInt32BE(Ae, t), Be = readInt32BE(Ae, t + 4);
  return Ie * 4294967296 + Be - (Be >> 31) * 4294967296;
}
binary.readInt64BE = readInt64BE;
function readUint64BE(Ae, t) {
  t === void 0 && (t = 0);
  var Ie = readUint32BE(Ae, t), Be = readUint32BE(Ae, t + 4);
  return Ie * 4294967296 + Be;
}
binary.readUint64BE = readUint64BE;
function readInt64LE(Ae, t) {
  t === void 0 && (t = 0);
  var Ie = readInt32LE(Ae, t), Be = readInt32LE(Ae, t + 4);
  return Be * 4294967296 + Ie - (Ie >> 31) * 4294967296;
}
binary.readInt64LE = readInt64LE;
function readUint64LE(Ae, t) {
  t === void 0 && (t = 0);
  var Ie = readUint32LE(Ae, t), Be = readUint32LE(Ae, t + 4);
  return Be * 4294967296 + Ie;
}
binary.readUint64LE = readUint64LE;
function writeUint64BE(Ae, t, Ie) {
  return t === void 0 && (t = new Uint8Array(8)), Ie === void 0 && (Ie = 0), writeUint32BE(Ae / 4294967296 >>> 0, t, Ie), writeUint32BE(Ae >>> 0, t, Ie + 4), t;
}
binary.writeUint64BE = writeUint64BE;
binary.writeInt64BE = writeUint64BE;
function writeUint64LE(Ae, t, Ie) {
  return t === void 0 && (t = new Uint8Array(8)), Ie === void 0 && (Ie = 0), writeUint32LE(Ae >>> 0, t, Ie), writeUint32LE(Ae / 4294967296 >>> 0, t, Ie + 4), t;
}
binary.writeUint64LE = writeUint64LE;
binary.writeInt64LE = writeUint64LE;
function readUintBE(Ae, t, Ie) {
  if (Ie === void 0 && (Ie = 0), Ae % 8 !== 0)
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (Ae / 8 > t.length - Ie)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var Be = 0, Pe = 1, Te = Ae / 8 + Ie - 1; Te >= Ie; Te--)
    Be += t[Te] * Pe, Pe *= 256;
  return Be;
}
binary.readUintBE = readUintBE;
function readUintLE(Ae, t, Ie) {
  if (Ie === void 0 && (Ie = 0), Ae % 8 !== 0)
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (Ae / 8 > t.length - Ie)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var Be = 0, Pe = 1, Te = Ie; Te < Ie + Ae / 8; Te++)
    Be += t[Te] * Pe, Pe *= 256;
  return Be;
}
binary.readUintLE = readUintLE;
function writeUintBE(Ae, t, Ie, Be) {
  if (Ie === void 0 && (Ie = new Uint8Array(Ae / 8)), Be === void 0 && (Be = 0), Ae % 8 !== 0)
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!int_1.isSafeInteger(t))
    throw new Error("writeUintBE value must be an integer");
  for (var Pe = 1, Te = Ae / 8 + Be - 1; Te >= Be; Te--)
    Ie[Te] = t / Pe & 255, Pe *= 256;
  return Ie;
}
binary.writeUintBE = writeUintBE;
function writeUintLE(Ae, t, Ie, Be) {
  if (Ie === void 0 && (Ie = new Uint8Array(Ae / 8)), Be === void 0 && (Be = 0), Ae % 8 !== 0)
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!int_1.isSafeInteger(t))
    throw new Error("writeUintLE value must be an integer");
  for (var Pe = 1, Te = Be; Te < Be + Ae / 8; Te++)
    Ie[Te] = t / Pe & 255, Pe *= 256;
  return Ie;
}
binary.writeUintLE = writeUintLE;
function readFloat32BE(Ae, t) {
  t === void 0 && (t = 0);
  var Ie = new DataView(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  return Ie.getFloat32(t);
}
binary.readFloat32BE = readFloat32BE;
function readFloat32LE(Ae, t) {
  t === void 0 && (t = 0);
  var Ie = new DataView(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  return Ie.getFloat32(t, !0);
}
binary.readFloat32LE = readFloat32LE;
function readFloat64BE(Ae, t) {
  t === void 0 && (t = 0);
  var Ie = new DataView(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  return Ie.getFloat64(t);
}
binary.readFloat64BE = readFloat64BE;
function readFloat64LE(Ae, t) {
  t === void 0 && (t = 0);
  var Ie = new DataView(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  return Ie.getFloat64(t, !0);
}
binary.readFloat64LE = readFloat64LE;
function writeFloat32BE(Ae, t, Ie) {
  t === void 0 && (t = new Uint8Array(4)), Ie === void 0 && (Ie = 0);
  var Be = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return Be.setFloat32(Ie, Ae), t;
}
binary.writeFloat32BE = writeFloat32BE;
function writeFloat32LE(Ae, t, Ie) {
  t === void 0 && (t = new Uint8Array(4)), Ie === void 0 && (Ie = 0);
  var Be = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return Be.setFloat32(Ie, Ae, !0), t;
}
binary.writeFloat32LE = writeFloat32LE;
function writeFloat64BE(Ae, t, Ie) {
  t === void 0 && (t = new Uint8Array(8)), Ie === void 0 && (Ie = 0);
  var Be = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return Be.setFloat64(Ie, Ae), t;
}
binary.writeFloat64BE = writeFloat64BE;
function writeFloat64LE(Ae, t, Ie) {
  t === void 0 && (t = new Uint8Array(8)), Ie === void 0 && (Ie = 0);
  var Be = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return Be.setFloat64(Ie, Ae, !0), t;
}
binary.writeFloat64LE = writeFloat64LE;
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 }), Ae.randomStringForEntropy = Ae.randomString = Ae.randomUint32 = Ae.randomBytes = Ae.defaultRandomSource = void 0;
  const t = system, Ie = binary, Be = wipe$1;
  Ae.defaultRandomSource = new t.SystemRandomSource();
  function Pe(fn, Ve = Ae.defaultRandomSource) {
    return Ve.randomBytes(fn);
  }
  Ae.randomBytes = Pe;
  function Te(fn = Ae.defaultRandomSource) {
    const Ve = Pe(4, fn), vn = (0, Ie.readUint32LE)(Ve);
    return (0, Be.wipe)(Ve), vn;
  }
  Ae.randomUint32 = Te;
  const Me = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function Ue(fn, Ve = Me, vn = Ae.defaultRandomSource) {
    if (Ve.length < 2)
      throw new Error("randomString charset is too short");
    if (Ve.length > 256)
      throw new Error("randomString charset is too long");
    let En = "";
    const fi = Ve.length, bi = 256 - 256 % fi;
    for (; fn > 0; ) {
      const mi = Pe(Math.ceil(fn * 256 / bi), vn);
      for (let _i = 0; _i < mi.length && fn > 0; _i++) {
        const Ei = mi[_i];
        Ei < bi && (En += Ve.charAt(Ei % fi), fn--);
      }
      (0, Be.wipe)(mi);
    }
    return En;
  }
  Ae.randomString = Ue;
  function je(fn, Ve = Me, vn = Ae.defaultRandomSource) {
    const En = Math.ceil(fn / (Math.log(Ve.length) / Math.LN2));
    return Ue(En, Ve, vn);
  }
  Ae.randomStringForEntropy = je;
})(random);
var sha512 = {};
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  var t = binary, Ie = wipe$1;
  Ae.DIGEST_LENGTH = 64, Ae.BLOCK_SIZE = 128;
  var Be = (
    /** @class */
    function() {
      function Ue() {
        this.digestLength = Ae.DIGEST_LENGTH, this.blockSize = Ae.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return Ue.prototype._initState = function() {
        this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209;
      }, Ue.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, Ue.prototype.clean = function() {
        Ie.wipe(this._buffer), Ie.wipe(this._tempHi), Ie.wipe(this._tempLo), this.reset();
      }, Ue.prototype.update = function(je, fn) {
        if (fn === void 0 && (fn = je.length), this._finished)
          throw new Error("SHA512: can't update because hash was finished.");
        var Ve = 0;
        if (this._bytesHashed += fn, this._bufferLength > 0) {
          for (; this._bufferLength < Ae.BLOCK_SIZE && fn > 0; )
            this._buffer[this._bufferLength++] = je[Ve++], fn--;
          this._bufferLength === this.blockSize && (Te(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (fn >= this.blockSize && (Ve = Te(this._tempHi, this._tempLo, this._stateHi, this._stateLo, je, Ve, fn), fn %= this.blockSize); fn > 0; )
          this._buffer[this._bufferLength++] = je[Ve++], fn--;
        return this;
      }, Ue.prototype.finish = function(je) {
        if (!this._finished) {
          var fn = this._bytesHashed, Ve = this._bufferLength, vn = fn / 536870912 | 0, En = fn << 3, fi = fn % 128 < 112 ? 128 : 256;
          this._buffer[Ve] = 128;
          for (var bi = Ve + 1; bi < fi - 8; bi++)
            this._buffer[bi] = 0;
          t.writeUint32BE(vn, this._buffer, fi - 8), t.writeUint32BE(En, this._buffer, fi - 4), Te(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, fi), this._finished = !0;
        }
        for (var bi = 0; bi < this.digestLength / 8; bi++)
          t.writeUint32BE(this._stateHi[bi], je, bi * 8), t.writeUint32BE(this._stateLo[bi], je, bi * 8 + 4);
        return this;
      }, Ue.prototype.digest = function() {
        var je = new Uint8Array(this.digestLength);
        return this.finish(je), je;
      }, Ue.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, Ue.prototype.restoreState = function(je) {
        return this._stateHi.set(je.stateHi), this._stateLo.set(je.stateLo), this._bufferLength = je.bufferLength, je.buffer && this._buffer.set(je.buffer), this._bytesHashed = je.bytesHashed, this._finished = !1, this;
      }, Ue.prototype.cleanSavedState = function(je) {
        Ie.wipe(je.stateHi), Ie.wipe(je.stateLo), je.buffer && Ie.wipe(je.buffer), je.bufferLength = 0, je.bytesHashed = 0;
      }, Ue;
    }()
  );
  Ae.SHA512 = Be;
  var Pe = new Int32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  function Te(Ue, je, fn, Ve, vn, En, fi) {
    for (var bi = fn[0], mi = fn[1], _i = fn[2], Ei = fn[3], Si = fn[4], Mi = fn[5], Oi = fn[6], Fi = fn[7], Ui = Ve[0], Pi = Ve[1], Bi = Ve[2], ji = Ve[3], Zi = Ve[4], zi = Ve[5], xi = Ve[6], $i = Ve[7], vi, wi, Ai, Ri, Ti, Ci, Ii, Li; fi >= 128; ) {
      for (var Ni = 0; Ni < 16; Ni++) {
        var Vi = 8 * Ni + En;
        Ue[Ni] = t.readUint32BE(vn, Vi), je[Ni] = t.readUint32BE(vn, Vi + 4);
      }
      for (var Ni = 0; Ni < 80; Ni++) {
        var is = bi, Ki = mi, ts = _i, qi = Ei, Hi = Si, Xi = Mi, ki = Oi, Wi = Fi, Yi = Ui, Qi = Pi, ns = Bi, us = ji, ps = Zi, Ds = zi, Eo = xi, hs = $i;
        if (vi = Fi, wi = $i, Ti = wi & 65535, Ci = wi >>> 16, Ii = vi & 65535, Li = vi >>> 16, vi = (Si >>> 14 | Zi << 18) ^ (Si >>> 18 | Zi << 14) ^ (Zi >>> 9 | Si << 23), wi = (Zi >>> 14 | Si << 18) ^ (Zi >>> 18 | Si << 14) ^ (Si >>> 9 | Zi << 23), Ti += wi & 65535, Ci += wi >>> 16, Ii += vi & 65535, Li += vi >>> 16, vi = Si & Mi ^ ~Si & Oi, wi = Zi & zi ^ ~Zi & xi, Ti += wi & 65535, Ci += wi >>> 16, Ii += vi & 65535, Li += vi >>> 16, vi = Pe[Ni * 2], wi = Pe[Ni * 2 + 1], Ti += wi & 65535, Ci += wi >>> 16, Ii += vi & 65535, Li += vi >>> 16, vi = Ue[Ni % 16], wi = je[Ni % 16], Ti += wi & 65535, Ci += wi >>> 16, Ii += vi & 65535, Li += vi >>> 16, Ci += Ti >>> 16, Ii += Ci >>> 16, Li += Ii >>> 16, Ai = Ii & 65535 | Li << 16, Ri = Ti & 65535 | Ci << 16, vi = Ai, wi = Ri, Ti = wi & 65535, Ci = wi >>> 16, Ii = vi & 65535, Li = vi >>> 16, vi = (bi >>> 28 | Ui << 4) ^ (Ui >>> 2 | bi << 30) ^ (Ui >>> 7 | bi << 25), wi = (Ui >>> 28 | bi << 4) ^ (bi >>> 2 | Ui << 30) ^ (bi >>> 7 | Ui << 25), Ti += wi & 65535, Ci += wi >>> 16, Ii += vi & 65535, Li += vi >>> 16, vi = bi & mi ^ bi & _i ^ mi & _i, wi = Ui & Pi ^ Ui & Bi ^ Pi & Bi, Ti += wi & 65535, Ci += wi >>> 16, Ii += vi & 65535, Li += vi >>> 16, Ci += Ti >>> 16, Ii += Ci >>> 16, Li += Ii >>> 16, Wi = Ii & 65535 | Li << 16, hs = Ti & 65535 | Ci << 16, vi = qi, wi = us, Ti = wi & 65535, Ci = wi >>> 16, Ii = vi & 65535, Li = vi >>> 16, vi = Ai, wi = Ri, Ti += wi & 65535, Ci += wi >>> 16, Ii += vi & 65535, Li += vi >>> 16, Ci += Ti >>> 16, Ii += Ci >>> 16, Li += Ii >>> 16, qi = Ii & 65535 | Li << 16, us = Ti & 65535 | Ci << 16, mi = is, _i = Ki, Ei = ts, Si = qi, Mi = Hi, Oi = Xi, Fi = ki, bi = Wi, Pi = Yi, Bi = Qi, ji = ns, Zi = us, zi = ps, xi = Ds, $i = Eo, Ui = hs, Ni % 16 === 15)
          for (var Vi = 0; Vi < 16; Vi++)
            vi = Ue[Vi], wi = je[Vi], Ti = wi & 65535, Ci = wi >>> 16, Ii = vi & 65535, Li = vi >>> 16, vi = Ue[(Vi + 9) % 16], wi = je[(Vi + 9) % 16], Ti += wi & 65535, Ci += wi >>> 16, Ii += vi & 65535, Li += vi >>> 16, Ai = Ue[(Vi + 1) % 16], Ri = je[(Vi + 1) % 16], vi = (Ai >>> 1 | Ri << 31) ^ (Ai >>> 8 | Ri << 24) ^ Ai >>> 7, wi = (Ri >>> 1 | Ai << 31) ^ (Ri >>> 8 | Ai << 24) ^ (Ri >>> 7 | Ai << 25), Ti += wi & 65535, Ci += wi >>> 16, Ii += vi & 65535, Li += vi >>> 16, Ai = Ue[(Vi + 14) % 16], Ri = je[(Vi + 14) % 16], vi = (Ai >>> 19 | Ri << 13) ^ (Ri >>> 29 | Ai << 3) ^ Ai >>> 6, wi = (Ri >>> 19 | Ai << 13) ^ (Ai >>> 29 | Ri << 3) ^ (Ri >>> 6 | Ai << 26), Ti += wi & 65535, Ci += wi >>> 16, Ii += vi & 65535, Li += vi >>> 16, Ci += Ti >>> 16, Ii += Ci >>> 16, Li += Ii >>> 16, Ue[Vi] = Ii & 65535 | Li << 16, je[Vi] = Ti & 65535 | Ci << 16;
      }
      vi = bi, wi = Ui, Ti = wi & 65535, Ci = wi >>> 16, Ii = vi & 65535, Li = vi >>> 16, vi = fn[0], wi = Ve[0], Ti += wi & 65535, Ci += wi >>> 16, Ii += vi & 65535, Li += vi >>> 16, Ci += Ti >>> 16, Ii += Ci >>> 16, Li += Ii >>> 16, fn[0] = bi = Ii & 65535 | Li << 16, Ve[0] = Ui = Ti & 65535 | Ci << 16, vi = mi, wi = Pi, Ti = wi & 65535, Ci = wi >>> 16, Ii = vi & 65535, Li = vi >>> 16, vi = fn[1], wi = Ve[1], Ti += wi & 65535, Ci += wi >>> 16, Ii += vi & 65535, Li += vi >>> 16, Ci += Ti >>> 16, Ii += Ci >>> 16, Li += Ii >>> 16, fn[1] = mi = Ii & 65535 | Li << 16, Ve[1] = Pi = Ti & 65535 | Ci << 16, vi = _i, wi = Bi, Ti = wi & 65535, Ci = wi >>> 16, Ii = vi & 65535, Li = vi >>> 16, vi = fn[2], wi = Ve[2], Ti += wi & 65535, Ci += wi >>> 16, Ii += vi & 65535, Li += vi >>> 16, Ci += Ti >>> 16, Ii += Ci >>> 16, Li += Ii >>> 16, fn[2] = _i = Ii & 65535 | Li << 16, Ve[2] = Bi = Ti & 65535 | Ci << 16, vi = Ei, wi = ji, Ti = wi & 65535, Ci = wi >>> 16, Ii = vi & 65535, Li = vi >>> 16, vi = fn[3], wi = Ve[3], Ti += wi & 65535, Ci += wi >>> 16, Ii += vi & 65535, Li += vi >>> 16, Ci += Ti >>> 16, Ii += Ci >>> 16, Li += Ii >>> 16, fn[3] = Ei = Ii & 65535 | Li << 16, Ve[3] = ji = Ti & 65535 | Ci << 16, vi = Si, wi = Zi, Ti = wi & 65535, Ci = wi >>> 16, Ii = vi & 65535, Li = vi >>> 16, vi = fn[4], wi = Ve[4], Ti += wi & 65535, Ci += wi >>> 16, Ii += vi & 65535, Li += vi >>> 16, Ci += Ti >>> 16, Ii += Ci >>> 16, Li += Ii >>> 16, fn[4] = Si = Ii & 65535 | Li << 16, Ve[4] = Zi = Ti & 65535 | Ci << 16, vi = Mi, wi = zi, Ti = wi & 65535, Ci = wi >>> 16, Ii = vi & 65535, Li = vi >>> 16, vi = fn[5], wi = Ve[5], Ti += wi & 65535, Ci += wi >>> 16, Ii += vi & 65535, Li += vi >>> 16, Ci += Ti >>> 16, Ii += Ci >>> 16, Li += Ii >>> 16, fn[5] = Mi = Ii & 65535 | Li << 16, Ve[5] = zi = Ti & 65535 | Ci << 16, vi = Oi, wi = xi, Ti = wi & 65535, Ci = wi >>> 16, Ii = vi & 65535, Li = vi >>> 16, vi = fn[6], wi = Ve[6], Ti += wi & 65535, Ci += wi >>> 16, Ii += vi & 65535, Li += vi >>> 16, Ci += Ti >>> 16, Ii += Ci >>> 16, Li += Ii >>> 16, fn[6] = Oi = Ii & 65535 | Li << 16, Ve[6] = xi = Ti & 65535 | Ci << 16, vi = Fi, wi = $i, Ti = wi & 65535, Ci = wi >>> 16, Ii = vi & 65535, Li = vi >>> 16, vi = fn[7], wi = Ve[7], Ti += wi & 65535, Ci += wi >>> 16, Ii += vi & 65535, Li += vi >>> 16, Ci += Ti >>> 16, Ii += Ci >>> 16, Li += Ii >>> 16, fn[7] = Fi = Ii & 65535 | Li << 16, Ve[7] = $i = Ti & 65535 | Ci << 16, En += 128, fi -= 128;
    }
    return En;
  }
  function Me(Ue) {
    var je = new Be();
    je.update(Ue);
    var fn = je.digest();
    return je.clean(), fn;
  }
  Ae.hash = Me;
})(sha512);
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 }), Ae.convertSecretKeyToX25519 = Ae.convertPublicKeyToX25519 = Ae.verify = Ae.sign = Ae.extractPublicKeyFromSecretKey = Ae.generateKeyPair = Ae.generateKeyPairFromSeed = Ae.SEED_LENGTH = Ae.SECRET_KEY_LENGTH = Ae.PUBLIC_KEY_LENGTH = Ae.SIGNATURE_LENGTH = void 0;
  const t = random, Ie = sha512, Be = wipe$1;
  Ae.SIGNATURE_LENGTH = 64, Ae.PUBLIC_KEY_LENGTH = 32, Ae.SECRET_KEY_LENGTH = 64, Ae.SEED_LENGTH = 32;
  function Pe(qi) {
    const Hi = new Float64Array(16);
    if (qi)
      for (let Xi = 0; Xi < qi.length; Xi++)
        Hi[Xi] = qi[Xi];
    return Hi;
  }
  const Te = new Uint8Array(32);
  Te[0] = 9;
  const Me = Pe(), Ue = Pe([1]), je = Pe([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]), fn = Pe([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]), Ve = Pe([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]), vn = Pe([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]), En = Pe([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function fi(qi, Hi) {
    for (let Xi = 0; Xi < 16; Xi++)
      qi[Xi] = Hi[Xi] | 0;
  }
  function bi(qi) {
    let Hi = 1;
    for (let Xi = 0; Xi < 16; Xi++) {
      let ki = qi[Xi] + Hi + 65535;
      Hi = Math.floor(ki / 65536), qi[Xi] = ki - Hi * 65536;
    }
    qi[0] += Hi - 1 + 37 * (Hi - 1);
  }
  function mi(qi, Hi, Xi) {
    const ki = ~(Xi - 1);
    for (let Wi = 0; Wi < 16; Wi++) {
      const Yi = ki & (qi[Wi] ^ Hi[Wi]);
      qi[Wi] ^= Yi, Hi[Wi] ^= Yi;
    }
  }
  function _i(qi, Hi) {
    const Xi = Pe(), ki = Pe();
    for (let Wi = 0; Wi < 16; Wi++)
      ki[Wi] = Hi[Wi];
    bi(ki), bi(ki), bi(ki);
    for (let Wi = 0; Wi < 2; Wi++) {
      Xi[0] = ki[0] - 65517;
      for (let Qi = 1; Qi < 15; Qi++)
        Xi[Qi] = ki[Qi] - 65535 - (Xi[Qi - 1] >> 16 & 1), Xi[Qi - 1] &= 65535;
      Xi[15] = ki[15] - 32767 - (Xi[14] >> 16 & 1);
      const Yi = Xi[15] >> 16 & 1;
      Xi[14] &= 65535, mi(ki, Xi, 1 - Yi);
    }
    for (let Wi = 0; Wi < 16; Wi++)
      qi[2 * Wi] = ki[Wi] & 255, qi[2 * Wi + 1] = ki[Wi] >> 8;
  }
  function Ei(qi, Hi) {
    let Xi = 0;
    for (let ki = 0; ki < 32; ki++)
      Xi |= qi[ki] ^ Hi[ki];
    return (1 & Xi - 1 >>> 8) - 1;
  }
  function Si(qi, Hi) {
    const Xi = new Uint8Array(32), ki = new Uint8Array(32);
    return _i(Xi, qi), _i(ki, Hi), Ei(Xi, ki);
  }
  function Mi(qi) {
    const Hi = new Uint8Array(32);
    return _i(Hi, qi), Hi[0] & 1;
  }
  function Oi(qi, Hi) {
    for (let Xi = 0; Xi < 16; Xi++)
      qi[Xi] = Hi[2 * Xi] + (Hi[2 * Xi + 1] << 8);
    qi[15] &= 32767;
  }
  function Fi(qi, Hi, Xi) {
    for (let ki = 0; ki < 16; ki++)
      qi[ki] = Hi[ki] + Xi[ki];
  }
  function Ui(qi, Hi, Xi) {
    for (let ki = 0; ki < 16; ki++)
      qi[ki] = Hi[ki] - Xi[ki];
  }
  function Pi(qi, Hi, Xi) {
    let ki, Wi, Yi = 0, Qi = 0, ns = 0, us = 0, ps = 0, Ds = 0, Eo = 0, hs = 0, So = 0, _o = 0, vo = 0, Ro = 0, $o = 0, Io = 0, To = 0, Ao = 0, Po = 0, Co = 0, rs = 0, Gi = 0, Ji = 0, ss = 0, ls = 0, ds = 0, bs = 0, Mo = 0, Fo = 0, Bo = 0, Uo = 0, Lo = 0, Go = 0, Yo = Xi[0], Ko = Xi[1], No = Xi[2], Wo = Xi[3], os = Xi[4], as = Xi[5], go = Xi[6], bo = Xi[7], wo = Xi[8], qo = Xi[9], jo = Xi[10], Oo = Xi[11], Ho = Xi[12], zo = Xi[13], Do = Xi[14], Xo = Xi[15];
    ki = Hi[0], Yi += ki * Yo, Qi += ki * Ko, ns += ki * No, us += ki * Wo, ps += ki * os, Ds += ki * as, Eo += ki * go, hs += ki * bo, So += ki * wo, _o += ki * qo, vo += ki * jo, Ro += ki * Oo, $o += ki * Ho, Io += ki * zo, To += ki * Do, Ao += ki * Xo, ki = Hi[1], Qi += ki * Yo, ns += ki * Ko, us += ki * No, ps += ki * Wo, Ds += ki * os, Eo += ki * as, hs += ki * go, So += ki * bo, _o += ki * wo, vo += ki * qo, Ro += ki * jo, $o += ki * Oo, Io += ki * Ho, To += ki * zo, Ao += ki * Do, Po += ki * Xo, ki = Hi[2], ns += ki * Yo, us += ki * Ko, ps += ki * No, Ds += ki * Wo, Eo += ki * os, hs += ki * as, So += ki * go, _o += ki * bo, vo += ki * wo, Ro += ki * qo, $o += ki * jo, Io += ki * Oo, To += ki * Ho, Ao += ki * zo, Po += ki * Do, Co += ki * Xo, ki = Hi[3], us += ki * Yo, ps += ki * Ko, Ds += ki * No, Eo += ki * Wo, hs += ki * os, So += ki * as, _o += ki * go, vo += ki * bo, Ro += ki * wo, $o += ki * qo, Io += ki * jo, To += ki * Oo, Ao += ki * Ho, Po += ki * zo, Co += ki * Do, rs += ki * Xo, ki = Hi[4], ps += ki * Yo, Ds += ki * Ko, Eo += ki * No, hs += ki * Wo, So += ki * os, _o += ki * as, vo += ki * go, Ro += ki * bo, $o += ki * wo, Io += ki * qo, To += ki * jo, Ao += ki * Oo, Po += ki * Ho, Co += ki * zo, rs += ki * Do, Gi += ki * Xo, ki = Hi[5], Ds += ki * Yo, Eo += ki * Ko, hs += ki * No, So += ki * Wo, _o += ki * os, vo += ki * as, Ro += ki * go, $o += ki * bo, Io += ki * wo, To += ki * qo, Ao += ki * jo, Po += ki * Oo, Co += ki * Ho, rs += ki * zo, Gi += ki * Do, Ji += ki * Xo, ki = Hi[6], Eo += ki * Yo, hs += ki * Ko, So += ki * No, _o += ki * Wo, vo += ki * os, Ro += ki * as, $o += ki * go, Io += ki * bo, To += ki * wo, Ao += ki * qo, Po += ki * jo, Co += ki * Oo, rs += ki * Ho, Gi += ki * zo, Ji += ki * Do, ss += ki * Xo, ki = Hi[7], hs += ki * Yo, So += ki * Ko, _o += ki * No, vo += ki * Wo, Ro += ki * os, $o += ki * as, Io += ki * go, To += ki * bo, Ao += ki * wo, Po += ki * qo, Co += ki * jo, rs += ki * Oo, Gi += ki * Ho, Ji += ki * zo, ss += ki * Do, ls += ki * Xo, ki = Hi[8], So += ki * Yo, _o += ki * Ko, vo += ki * No, Ro += ki * Wo, $o += ki * os, Io += ki * as, To += ki * go, Ao += ki * bo, Po += ki * wo, Co += ki * qo, rs += ki * jo, Gi += ki * Oo, Ji += ki * Ho, ss += ki * zo, ls += ki * Do, ds += ki * Xo, ki = Hi[9], _o += ki * Yo, vo += ki * Ko, Ro += ki * No, $o += ki * Wo, Io += ki * os, To += ki * as, Ao += ki * go, Po += ki * bo, Co += ki * wo, rs += ki * qo, Gi += ki * jo, Ji += ki * Oo, ss += ki * Ho, ls += ki * zo, ds += ki * Do, bs += ki * Xo, ki = Hi[10], vo += ki * Yo, Ro += ki * Ko, $o += ki * No, Io += ki * Wo, To += ki * os, Ao += ki * as, Po += ki * go, Co += ki * bo, rs += ki * wo, Gi += ki * qo, Ji += ki * jo, ss += ki * Oo, ls += ki * Ho, ds += ki * zo, bs += ki * Do, Mo += ki * Xo, ki = Hi[11], Ro += ki * Yo, $o += ki * Ko, Io += ki * No, To += ki * Wo, Ao += ki * os, Po += ki * as, Co += ki * go, rs += ki * bo, Gi += ki * wo, Ji += ki * qo, ss += ki * jo, ls += ki * Oo, ds += ki * Ho, bs += ki * zo, Mo += ki * Do, Fo += ki * Xo, ki = Hi[12], $o += ki * Yo, Io += ki * Ko, To += ki * No, Ao += ki * Wo, Po += ki * os, Co += ki * as, rs += ki * go, Gi += ki * bo, Ji += ki * wo, ss += ki * qo, ls += ki * jo, ds += ki * Oo, bs += ki * Ho, Mo += ki * zo, Fo += ki * Do, Bo += ki * Xo, ki = Hi[13], Io += ki * Yo, To += ki * Ko, Ao += ki * No, Po += ki * Wo, Co += ki * os, rs += ki * as, Gi += ki * go, Ji += ki * bo, ss += ki * wo, ls += ki * qo, ds += ki * jo, bs += ki * Oo, Mo += ki * Ho, Fo += ki * zo, Bo += ki * Do, Uo += ki * Xo, ki = Hi[14], To += ki * Yo, Ao += ki * Ko, Po += ki * No, Co += ki * Wo, rs += ki * os, Gi += ki * as, Ji += ki * go, ss += ki * bo, ls += ki * wo, ds += ki * qo, bs += ki * jo, Mo += ki * Oo, Fo += ki * Ho, Bo += ki * zo, Uo += ki * Do, Lo += ki * Xo, ki = Hi[15], Ao += ki * Yo, Po += ki * Ko, Co += ki * No, rs += ki * Wo, Gi += ki * os, Ji += ki * as, ss += ki * go, ls += ki * bo, ds += ki * wo, bs += ki * qo, Mo += ki * jo, Fo += ki * Oo, Bo += ki * Ho, Uo += ki * zo, Lo += ki * Do, Go += ki * Xo, Yi += 38 * Po, Qi += 38 * Co, ns += 38 * rs, us += 38 * Gi, ps += 38 * Ji, Ds += 38 * ss, Eo += 38 * ls, hs += 38 * ds, So += 38 * bs, _o += 38 * Mo, vo += 38 * Fo, Ro += 38 * Bo, $o += 38 * Uo, Io += 38 * Lo, To += 38 * Go, Wi = 1, ki = Yi + Wi + 65535, Wi = Math.floor(ki / 65536), Yi = ki - Wi * 65536, ki = Qi + Wi + 65535, Wi = Math.floor(ki / 65536), Qi = ki - Wi * 65536, ki = ns + Wi + 65535, Wi = Math.floor(ki / 65536), ns = ki - Wi * 65536, ki = us + Wi + 65535, Wi = Math.floor(ki / 65536), us = ki - Wi * 65536, ki = ps + Wi + 65535, Wi = Math.floor(ki / 65536), ps = ki - Wi * 65536, ki = Ds + Wi + 65535, Wi = Math.floor(ki / 65536), Ds = ki - Wi * 65536, ki = Eo + Wi + 65535, Wi = Math.floor(ki / 65536), Eo = ki - Wi * 65536, ki = hs + Wi + 65535, Wi = Math.floor(ki / 65536), hs = ki - Wi * 65536, ki = So + Wi + 65535, Wi = Math.floor(ki / 65536), So = ki - Wi * 65536, ki = _o + Wi + 65535, Wi = Math.floor(ki / 65536), _o = ki - Wi * 65536, ki = vo + Wi + 65535, Wi = Math.floor(ki / 65536), vo = ki - Wi * 65536, ki = Ro + Wi + 65535, Wi = Math.floor(ki / 65536), Ro = ki - Wi * 65536, ki = $o + Wi + 65535, Wi = Math.floor(ki / 65536), $o = ki - Wi * 65536, ki = Io + Wi + 65535, Wi = Math.floor(ki / 65536), Io = ki - Wi * 65536, ki = To + Wi + 65535, Wi = Math.floor(ki / 65536), To = ki - Wi * 65536, ki = Ao + Wi + 65535, Wi = Math.floor(ki / 65536), Ao = ki - Wi * 65536, Yi += Wi - 1 + 37 * (Wi - 1), Wi = 1, ki = Yi + Wi + 65535, Wi = Math.floor(ki / 65536), Yi = ki - Wi * 65536, ki = Qi + Wi + 65535, Wi = Math.floor(ki / 65536), Qi = ki - Wi * 65536, ki = ns + Wi + 65535, Wi = Math.floor(ki / 65536), ns = ki - Wi * 65536, ki = us + Wi + 65535, Wi = Math.floor(ki / 65536), us = ki - Wi * 65536, ki = ps + Wi + 65535, Wi = Math.floor(ki / 65536), ps = ki - Wi * 65536, ki = Ds + Wi + 65535, Wi = Math.floor(ki / 65536), Ds = ki - Wi * 65536, ki = Eo + Wi + 65535, Wi = Math.floor(ki / 65536), Eo = ki - Wi * 65536, ki = hs + Wi + 65535, Wi = Math.floor(ki / 65536), hs = ki - Wi * 65536, ki = So + Wi + 65535, Wi = Math.floor(ki / 65536), So = ki - Wi * 65536, ki = _o + Wi + 65535, Wi = Math.floor(ki / 65536), _o = ki - Wi * 65536, ki = vo + Wi + 65535, Wi = Math.floor(ki / 65536), vo = ki - Wi * 65536, ki = Ro + Wi + 65535, Wi = Math.floor(ki / 65536), Ro = ki - Wi * 65536, ki = $o + Wi + 65535, Wi = Math.floor(ki / 65536), $o = ki - Wi * 65536, ki = Io + Wi + 65535, Wi = Math.floor(ki / 65536), Io = ki - Wi * 65536, ki = To + Wi + 65535, Wi = Math.floor(ki / 65536), To = ki - Wi * 65536, ki = Ao + Wi + 65535, Wi = Math.floor(ki / 65536), Ao = ki - Wi * 65536, Yi += Wi - 1 + 37 * (Wi - 1), qi[0] = Yi, qi[1] = Qi, qi[2] = ns, qi[3] = us, qi[4] = ps, qi[5] = Ds, qi[6] = Eo, qi[7] = hs, qi[8] = So, qi[9] = _o, qi[10] = vo, qi[11] = Ro, qi[12] = $o, qi[13] = Io, qi[14] = To, qi[15] = Ao;
  }
  function Bi(qi, Hi) {
    Pi(qi, Hi, Hi);
  }
  function ji(qi, Hi) {
    const Xi = Pe();
    let ki;
    for (ki = 0; ki < 16; ki++)
      Xi[ki] = Hi[ki];
    for (ki = 253; ki >= 0; ki--)
      Bi(Xi, Xi), ki !== 2 && ki !== 4 && Pi(Xi, Xi, Hi);
    for (ki = 0; ki < 16; ki++)
      qi[ki] = Xi[ki];
  }
  function Zi(qi, Hi) {
    const Xi = Pe();
    let ki;
    for (ki = 0; ki < 16; ki++)
      Xi[ki] = Hi[ki];
    for (ki = 250; ki >= 0; ki--)
      Bi(Xi, Xi), ki !== 1 && Pi(Xi, Xi, Hi);
    for (ki = 0; ki < 16; ki++)
      qi[ki] = Xi[ki];
  }
  function zi(qi, Hi) {
    const Xi = Pe(), ki = Pe(), Wi = Pe(), Yi = Pe(), Qi = Pe(), ns = Pe(), us = Pe(), ps = Pe(), Ds = Pe();
    Ui(Xi, qi[1], qi[0]), Ui(Ds, Hi[1], Hi[0]), Pi(Xi, Xi, Ds), Fi(ki, qi[0], qi[1]), Fi(Ds, Hi[0], Hi[1]), Pi(ki, ki, Ds), Pi(Wi, qi[3], Hi[3]), Pi(Wi, Wi, fn), Pi(Yi, qi[2], Hi[2]), Fi(Yi, Yi, Yi), Ui(Qi, ki, Xi), Ui(ns, Yi, Wi), Fi(us, Yi, Wi), Fi(ps, ki, Xi), Pi(qi[0], Qi, ns), Pi(qi[1], ps, us), Pi(qi[2], us, ns), Pi(qi[3], Qi, ps);
  }
  function xi(qi, Hi, Xi) {
    for (let ki = 0; ki < 4; ki++)
      mi(qi[ki], Hi[ki], Xi);
  }
  function $i(qi, Hi) {
    const Xi = Pe(), ki = Pe(), Wi = Pe();
    ji(Wi, Hi[2]), Pi(Xi, Hi[0], Wi), Pi(ki, Hi[1], Wi), _i(qi, ki), qi[31] ^= Mi(Xi) << 7;
  }
  function vi(qi, Hi, Xi) {
    fi(qi[0], Me), fi(qi[1], Ue), fi(qi[2], Ue), fi(qi[3], Me);
    for (let ki = 255; ki >= 0; --ki) {
      const Wi = Xi[ki / 8 | 0] >> (ki & 7) & 1;
      xi(qi, Hi, Wi), zi(Hi, qi), zi(qi, qi), xi(qi, Hi, Wi);
    }
  }
  function wi(qi, Hi) {
    const Xi = [Pe(), Pe(), Pe(), Pe()];
    fi(Xi[0], Ve), fi(Xi[1], vn), fi(Xi[2], Ue), Pi(Xi[3], Ve, vn), vi(qi, Xi, Hi);
  }
  function Ai(qi) {
    if (qi.length !== Ae.SEED_LENGTH)
      throw new Error(`ed25519: seed must be ${Ae.SEED_LENGTH} bytes`);
    const Hi = (0, Ie.hash)(qi);
    Hi[0] &= 248, Hi[31] &= 127, Hi[31] |= 64;
    const Xi = new Uint8Array(32), ki = [Pe(), Pe(), Pe(), Pe()];
    wi(ki, Hi), $i(Xi, ki);
    const Wi = new Uint8Array(64);
    return Wi.set(qi), Wi.set(Xi, 32), {
      publicKey: Xi,
      secretKey: Wi
    };
  }
  Ae.generateKeyPairFromSeed = Ai;
  function Ri(qi) {
    const Hi = (0, t.randomBytes)(32, qi), Xi = Ai(Hi);
    return (0, Be.wipe)(Hi), Xi;
  }
  Ae.generateKeyPair = Ri;
  function Ti(qi) {
    if (qi.length !== Ae.SECRET_KEY_LENGTH)
      throw new Error(`ed25519: secret key must be ${Ae.SECRET_KEY_LENGTH} bytes`);
    return new Uint8Array(qi.subarray(32));
  }
  Ae.extractPublicKeyFromSecretKey = Ti;
  const Ci = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function Ii(qi, Hi) {
    let Xi, ki, Wi, Yi;
    for (ki = 63; ki >= 32; --ki) {
      for (Xi = 0, Wi = ki - 32, Yi = ki - 12; Wi < Yi; ++Wi)
        Hi[Wi] += Xi - 16 * Hi[ki] * Ci[Wi - (ki - 32)], Xi = Math.floor((Hi[Wi] + 128) / 256), Hi[Wi] -= Xi * 256;
      Hi[Wi] += Xi, Hi[ki] = 0;
    }
    for (Xi = 0, Wi = 0; Wi < 32; Wi++)
      Hi[Wi] += Xi - (Hi[31] >> 4) * Ci[Wi], Xi = Hi[Wi] >> 8, Hi[Wi] &= 255;
    for (Wi = 0; Wi < 32; Wi++)
      Hi[Wi] -= Xi * Ci[Wi];
    for (ki = 0; ki < 32; ki++)
      Hi[ki + 1] += Hi[ki] >> 8, qi[ki] = Hi[ki] & 255;
  }
  function Li(qi) {
    const Hi = new Float64Array(64);
    for (let Xi = 0; Xi < 64; Xi++)
      Hi[Xi] = qi[Xi];
    for (let Xi = 0; Xi < 64; Xi++)
      qi[Xi] = 0;
    Ii(qi, Hi);
  }
  function Ni(qi, Hi) {
    const Xi = new Float64Array(64), ki = [Pe(), Pe(), Pe(), Pe()], Wi = (0, Ie.hash)(qi.subarray(0, 32));
    Wi[0] &= 248, Wi[31] &= 127, Wi[31] |= 64;
    const Yi = new Uint8Array(64);
    Yi.set(Wi.subarray(32), 32);
    const Qi = new Ie.SHA512();
    Qi.update(Yi.subarray(32)), Qi.update(Hi);
    const ns = Qi.digest();
    Qi.clean(), Li(ns), wi(ki, ns), $i(Yi, ki), Qi.reset(), Qi.update(Yi.subarray(0, 32)), Qi.update(qi.subarray(32)), Qi.update(Hi);
    const us = Qi.digest();
    Li(us);
    for (let ps = 0; ps < 32; ps++)
      Xi[ps] = ns[ps];
    for (let ps = 0; ps < 32; ps++)
      for (let Ds = 0; Ds < 32; Ds++)
        Xi[ps + Ds] += us[ps] * Wi[Ds];
    return Ii(Yi.subarray(32), Xi), Yi;
  }
  Ae.sign = Ni;
  function Vi(qi, Hi) {
    const Xi = Pe(), ki = Pe(), Wi = Pe(), Yi = Pe(), Qi = Pe(), ns = Pe(), us = Pe();
    return fi(qi[2], Ue), Oi(qi[1], Hi), Bi(Wi, qi[1]), Pi(Yi, Wi, je), Ui(Wi, Wi, qi[2]), Fi(Yi, qi[2], Yi), Bi(Qi, Yi), Bi(ns, Qi), Pi(us, ns, Qi), Pi(Xi, us, Wi), Pi(Xi, Xi, Yi), Zi(Xi, Xi), Pi(Xi, Xi, Wi), Pi(Xi, Xi, Yi), Pi(Xi, Xi, Yi), Pi(qi[0], Xi, Yi), Bi(ki, qi[0]), Pi(ki, ki, Yi), Si(ki, Wi) && Pi(qi[0], qi[0], En), Bi(ki, qi[0]), Pi(ki, ki, Yi), Si(ki, Wi) ? -1 : (Mi(qi[0]) === Hi[31] >> 7 && Ui(qi[0], Me, qi[0]), Pi(qi[3], qi[0], qi[1]), 0);
  }
  function is(qi, Hi, Xi) {
    const ki = new Uint8Array(32), Wi = [Pe(), Pe(), Pe(), Pe()], Yi = [Pe(), Pe(), Pe(), Pe()];
    if (Xi.length !== Ae.SIGNATURE_LENGTH)
      throw new Error(`ed25519: signature must be ${Ae.SIGNATURE_LENGTH} bytes`);
    if (Vi(Yi, qi))
      return !1;
    const Qi = new Ie.SHA512();
    Qi.update(Xi.subarray(0, 32)), Qi.update(qi), Qi.update(Hi);
    const ns = Qi.digest();
    return Li(ns), vi(Wi, Yi, ns), wi(Yi, Xi.subarray(32)), zi(Wi, Yi), $i(ki, Wi), !Ei(Xi, ki);
  }
  Ae.verify = is;
  function Ki(qi) {
    let Hi = [Pe(), Pe(), Pe(), Pe()];
    if (Vi(Hi, qi))
      throw new Error("Ed25519: invalid public key");
    let Xi = Pe(), ki = Pe(), Wi = Hi[1];
    Fi(Xi, Ue, Wi), Ui(ki, Ue, Wi), ji(ki, ki), Pi(Xi, Xi, ki);
    let Yi = new Uint8Array(32);
    return _i(Yi, Xi), Yi;
  }
  Ae.convertPublicKeyToX25519 = Ki;
  function ts(qi) {
    const Hi = (0, Ie.hash)(qi.subarray(0, 32));
    Hi[0] &= 248, Hi[31] &= 127, Hi[31] |= 64;
    const Xi = new Uint8Array(Hi.subarray(0, 32));
    return (0, Be.wipe)(Hi), Xi;
  }
  Ae.convertSecretKeyToX25519 = ts;
})(ed25519);
const JWT_IRIDIUM_ALG = "EdDSA", JWT_IRIDIUM_TYP = "JWT", JWT_DELIMITER = ".", JWT_ENCODING = "base64url", JSON_ENCODING = "utf8", DATA_ENCODING = "utf8", DID_DELIMITER = ":", DID_PREFIX = "did", DID_METHOD = "key", MULTICODEC_ED25519_ENCODING = "base58btc", MULTICODEC_ED25519_BASE = "z", MULTICODEC_ED25519_HEADER = "K36", KEY_PAIR_SEED_LENGTH = 32;
function allocUnsafe(Ae = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(Ae) : new Uint8Array(Ae);
}
function concat$1(Ae, t) {
  t || (t = Ae.reduce((Pe, Te) => Pe + Te.length, 0));
  const Ie = allocUnsafe(t);
  let Be = 0;
  for (const Pe of Ae)
    Ie.set(Pe, Be), Be += Pe.length;
  return Ie;
}
function base$1(Ae, t) {
  if (Ae.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var Ie = new Uint8Array(256), Be = 0; Be < Ie.length; Be++)
    Ie[Be] = 255;
  for (var Pe = 0; Pe < Ae.length; Pe++) {
    var Te = Ae.charAt(Pe), Me = Te.charCodeAt(0);
    if (Ie[Me] !== 255)
      throw new TypeError(Te + " is ambiguous");
    Ie[Me] = Pe;
  }
  var Ue = Ae.length, je = Ae.charAt(0), fn = Math.log(Ue) / Math.log(256), Ve = Math.log(256) / Math.log(Ue);
  function vn(bi) {
    if (bi instanceof Uint8Array || (ArrayBuffer.isView(bi) ? bi = new Uint8Array(bi.buffer, bi.byteOffset, bi.byteLength) : Array.isArray(bi) && (bi = Uint8Array.from(bi))), !(bi instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (bi.length === 0)
      return "";
    for (var mi = 0, _i = 0, Ei = 0, Si = bi.length; Ei !== Si && bi[Ei] === 0; )
      Ei++, mi++;
    for (var Mi = (Si - Ei) * Ve + 1 >>> 0, Oi = new Uint8Array(Mi); Ei !== Si; ) {
      for (var Fi = bi[Ei], Ui = 0, Pi = Mi - 1; (Fi !== 0 || Ui < _i) && Pi !== -1; Pi--, Ui++)
        Fi += 256 * Oi[Pi] >>> 0, Oi[Pi] = Fi % Ue >>> 0, Fi = Fi / Ue >>> 0;
      if (Fi !== 0)
        throw new Error("Non-zero carry");
      _i = Ui, Ei++;
    }
    for (var Bi = Mi - _i; Bi !== Mi && Oi[Bi] === 0; )
      Bi++;
    for (var ji = je.repeat(mi); Bi < Mi; ++Bi)
      ji += Ae.charAt(Oi[Bi]);
    return ji;
  }
  function En(bi) {
    if (typeof bi != "string")
      throw new TypeError("Expected String");
    if (bi.length === 0)
      return new Uint8Array();
    var mi = 0;
    if (bi[mi] !== " ") {
      for (var _i = 0, Ei = 0; bi[mi] === je; )
        _i++, mi++;
      for (var Si = (bi.length - mi) * fn + 1 >>> 0, Mi = new Uint8Array(Si); bi[mi]; ) {
        var Oi = Ie[bi.charCodeAt(mi)];
        if (Oi === 255)
          return;
        for (var Fi = 0, Ui = Si - 1; (Oi !== 0 || Fi < Ei) && Ui !== -1; Ui--, Fi++)
          Oi += Ue * Mi[Ui] >>> 0, Mi[Ui] = Oi % 256 >>> 0, Oi = Oi / 256 >>> 0;
        if (Oi !== 0)
          throw new Error("Non-zero carry");
        Ei = Fi, mi++;
      }
      if (bi[mi] !== " ") {
        for (var Pi = Si - Ei; Pi !== Si && Mi[Pi] === 0; )
          Pi++;
        for (var Bi = new Uint8Array(_i + (Si - Pi)), ji = _i; Pi !== Si; )
          Bi[ji++] = Mi[Pi++];
        return Bi;
      }
    }
  }
  function fi(bi) {
    var mi = En(bi);
    if (mi)
      return mi;
    throw new Error(`Non-${t} character`);
  }
  return {
    encode: vn,
    decodeUnsafe: En,
    decode: fi
  };
}
var src = base$1, _brrp__multiformats_scope_baseX = src;
const coerce = (Ae) => {
  if (Ae instanceof Uint8Array && Ae.constructor.name === "Uint8Array")
    return Ae;
  if (Ae instanceof ArrayBuffer)
    return new Uint8Array(Ae);
  if (ArrayBuffer.isView(Ae))
    return new Uint8Array(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  throw new Error("Unknown type, must be binary type");
}, fromString$1 = (Ae) => new TextEncoder().encode(Ae), toString$1 = (Ae) => new TextDecoder().decode(Ae);
class Encoder {
  constructor(t, Ie, Be) {
    this.name = t, this.prefix = Ie, this.baseEncode = Be;
  }
  encode(t) {
    if (t instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Decoder {
  constructor(t, Ie, Be) {
    if (this.name = t, this.prefix = Ie, Ie.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = Ie.codePointAt(0), this.baseDecode = Be;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(t) {
    return or$2(this, t);
  }
}
class ComposedDecoder {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return or$2(this, t);
  }
  decode(t) {
    const Ie = t[0], Be = this.decoders[Ie];
    if (Be)
      return Be.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const or$2 = (Ae, t) => new ComposedDecoder({
  ...Ae.decoders || { [Ae.prefix]: Ae },
  ...t.decoders || { [t.prefix]: t }
});
class Codec {
  constructor(t, Ie, Be, Pe) {
    this.name = t, this.prefix = Ie, this.baseEncode = Be, this.baseDecode = Pe, this.encoder = new Encoder(t, Ie, Be), this.decoder = new Decoder(t, Ie, Pe);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
}
const from = ({ name: Ae, prefix: t, encode: Ie, decode: Be }) => new Codec(Ae, t, Ie, Be), baseX = ({ prefix: Ae, name: t, alphabet: Ie }) => {
  const { encode: Be, decode: Pe } = _brrp__multiformats_scope_baseX(Ie, t);
  return from({
    prefix: Ae,
    name: t,
    encode: Be,
    decode: (Te) => coerce(Pe(Te))
  });
}, decode$2 = (Ae, t, Ie, Be) => {
  const Pe = {};
  for (let Ve = 0; Ve < t.length; ++Ve)
    Pe[t[Ve]] = Ve;
  let Te = Ae.length;
  for (; Ae[Te - 1] === "="; )
    --Te;
  const Me = new Uint8Array(Te * Ie / 8 | 0);
  let Ue = 0, je = 0, fn = 0;
  for (let Ve = 0; Ve < Te; ++Ve) {
    const vn = Pe[Ae[Ve]];
    if (vn === void 0)
      throw new SyntaxError(`Non-${Be} character`);
    je = je << Ie | vn, Ue += Ie, Ue >= 8 && (Ue -= 8, Me[fn++] = 255 & je >> Ue);
  }
  if (Ue >= Ie || 255 & je << 8 - Ue)
    throw new SyntaxError("Unexpected end of data");
  return Me;
}, encode$1 = (Ae, t, Ie) => {
  const Be = t[t.length - 1] === "=", Pe = (1 << Ie) - 1;
  let Te = "", Me = 0, Ue = 0;
  for (let je = 0; je < Ae.length; ++je)
    for (Ue = Ue << 8 | Ae[je], Me += 8; Me > Ie; )
      Me -= Ie, Te += t[Pe & Ue >> Me];
  if (Me && (Te += t[Pe & Ue << Ie - Me]), Be)
    for (; Te.length * Ie & 7; )
      Te += "=";
  return Te;
}, rfc4648 = ({ name: Ae, prefix: t, bitsPerChar: Ie, alphabet: Be }) => from({
  prefix: t,
  name: Ae,
  encode(Pe) {
    return encode$1(Pe, Be, Ie);
  },
  decode(Pe) {
    return decode$2(Pe, Be, Ie, Ae);
  }
}), identity = from({
  prefix: "\0",
  name: "identity",
  encode: (Ae) => toString$1(Ae),
  decode: (Ae) => fromString$1(Ae)
}), identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity
}, Symbol.toStringTag, { value: "Module" })), base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" })), base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" })), base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" })), base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" })), base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32,
  base32hex,
  base32hexpad,
  base32hexpadupper,
  base32hexupper,
  base32pad,
  base32padupper,
  base32upper,
  base32z
}, Symbol.toStringTag, { value: "Module" })), base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" })), base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc,
  base58flickr
}, Symbol.toStringTag, { value: "Module" })), base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), base64$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" })), alphabet = Array.from(""), alphabetBytesToChars = alphabet.reduce((Ae, t, Ie) => (Ae[Ie] = t, Ae), []), alphabetCharsToBytes = alphabet.reduce((Ae, t, Ie) => (Ae[t.codePointAt(0)] = Ie, Ae), []);
function encode(Ae) {
  return Ae.reduce((t, Ie) => (t += alphabetBytesToChars[Ie], t), "");
}
function decode$1(Ae) {
  const t = [];
  for (const Ie of Ae) {
    const Be = alphabetCharsToBytes[Ie.codePointAt(0)];
    if (Be === void 0)
      throw new Error(`Non-base256emoji character: ${Ie}`);
    t.push(Be);
  }
  return new Uint8Array(t);
}
const base256emoji = from({
  prefix: "",
  name: "base256emoji",
  encode,
  decode: decode$1
}), base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const bases = {
  ...identityBase,
  ...base2$1,
  ...base8$1,
  ...base10$1,
  ...base16$1,
  ...base32$1,
  ...base36$1,
  ...base58,
  ...base64$1,
  ...base256emoji$1
};
function createCodec(Ae, t, Ie, Be) {
  return {
    name: Ae,
    prefix: t,
    encoder: {
      name: Ae,
      prefix: t,
      encode: Ie
    },
    decoder: { decode: Be }
  };
}
const string = createCodec("utf8", "u", (Ae) => "u" + new TextDecoder("utf8").decode(Ae), (Ae) => new TextEncoder().encode(Ae.substring(1))), ascii = createCodec("ascii", "a", (Ae) => {
  let t = "a";
  for (let Ie = 0; Ie < Ae.length; Ie++)
    t += String.fromCharCode(Ae[Ie]);
  return t;
}, (Ae) => {
  Ae = Ae.substring(1);
  const t = allocUnsafe(Ae.length);
  for (let Ie = 0; Ie < Ae.length; Ie++)
    t[Ie] = Ae.charCodeAt(Ie);
  return t;
}), BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function toString(Ae, t = "utf8") {
  const Ie = BASES[t];
  if (!Ie)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(Ae.buffer, Ae.byteOffset, Ae.byteLength).toString("utf8") : Ie.encoder.encode(Ae).substring(1);
}
function fromString(Ae, t = "utf8") {
  const Ie = BASES[t];
  if (!Ie)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(Ae, "utf8") : Ie.decoder.decode(`${Ie.prefix}${Ae}`);
}
function decodeJSON(Ae) {
  return safeJsonParse(toString(fromString(Ae, JWT_ENCODING), JSON_ENCODING));
}
function encodeJSON(Ae) {
  return toString(fromString(safeJsonStringify(Ae), JSON_ENCODING), JWT_ENCODING);
}
function encodeIss(Ae) {
  const t = fromString(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING), Ie = MULTICODEC_ED25519_BASE + toString(concat$1([t, Ae]), MULTICODEC_ED25519_ENCODING);
  return [DID_PREFIX, DID_METHOD, Ie].join(DID_DELIMITER);
}
function encodeSig(Ae) {
  return toString(Ae, JWT_ENCODING);
}
function decodeSig(Ae) {
  return fromString(Ae, JWT_ENCODING);
}
function encodeData(Ae) {
  return fromString([encodeJSON(Ae.header), encodeJSON(Ae.payload)].join(JWT_DELIMITER), DATA_ENCODING);
}
function encodeJWT(Ae) {
  return [
    encodeJSON(Ae.header),
    encodeJSON(Ae.payload),
    encodeSig(Ae.signature)
  ].join(JWT_DELIMITER);
}
function decodeJWT(Ae) {
  const t = Ae.split(JWT_DELIMITER), Ie = decodeJSON(t[0]), Be = decodeJSON(t[1]), Pe = decodeSig(t[2]), Te = fromString(t.slice(0, 2).join(JWT_DELIMITER), DATA_ENCODING);
  return { header: Ie, payload: Be, signature: Pe, data: Te };
}
function generateKeyPair(Ae = random.randomBytes(KEY_PAIR_SEED_LENGTH)) {
  return ed25519.generateKeyPairFromSeed(Ae);
}
async function signJWT(Ae, t, Ie, Be, Pe = cjs$3.fromMiliseconds(Date.now())) {
  const Te = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP }, Me = encodeIss(Be.publicKey), Ue = Pe + Ie, je = { iss: Me, sub: Ae, aud: t, iat: Pe, exp: Ue }, fn = encodeData({ header: Te, payload: je }), Ve = ed25519.sign(Be.secretKey, fn);
  return encodeJWT({ header: Te, payload: je, signature: Ve });
}
var __spreadArray = function(Ae, t, Ie) {
  if (Ie || arguments.length === 2) for (var Be = 0, Pe = t.length, Te; Be < Pe; Be++)
    (Te || !(Be in t)) && (Te || (Te = Array.prototype.slice.call(t, 0, Be)), Te[Be] = t[Be]);
  return Ae.concat(Te || Array.prototype.slice.call(t));
}, BrowserInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function Ae(t, Ie, Be) {
      this.name = t, this.version = Ie, this.os = Be, this.type = "browser";
    }
    return Ae;
  }()
), NodeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function Ae(t) {
      this.version = t, this.type = "node", this.name = "node", this.os = process$1$1.platform;
    }
    return Ae;
  }()
), SearchBotDeviceInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function Ae(t, Ie, Be, Pe) {
      this.name = t, this.version = Ie, this.os = Be, this.bot = Pe, this.type = "bot-device";
    }
    return Ae;
  }()
), BotInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function Ae() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return Ae;
  }()
), ReactNativeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function Ae() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return Ae;
  }()
), SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, REQUIRED_VERSION_PARTS = 3, userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
], operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(Ae) {
  return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new ReactNativeInfo() : typeof navigator < "u" ? parseUserAgent(navigator.userAgent) : getNodeVersion();
}
function matchUserAgent(Ae) {
  return Ae !== "" && userAgentRules.reduce(function(t, Ie) {
    var Be = Ie[0], Pe = Ie[1];
    if (t)
      return t;
    var Te = Pe.exec(Ae);
    return !!Te && [Be, Te];
  }, !1);
}
function parseUserAgent(Ae) {
  var t = matchUserAgent(Ae);
  if (!t)
    return null;
  var Ie = t[0], Be = t[1];
  if (Ie === "searchbot")
    return new BotInfo();
  var Pe = Be[1] && Be[1].split(".").join("_").split("_").slice(0, 3);
  Pe ? Pe.length < REQUIRED_VERSION_PARTS && (Pe = __spreadArray(__spreadArray([], Pe, !0), createVersionParts(REQUIRED_VERSION_PARTS - Pe.length), !0)) : Pe = [];
  var Te = Pe.join("."), Me = detectOS(Ae), Ue = SEARCHBOT_OS_REGEX.exec(Ae);
  return Ue && Ue[1] ? new SearchBotDeviceInfo(Ie, Te, Me, Ue[1]) : new BrowserInfo(Ie, Te, Me);
}
function detectOS(Ae) {
  for (var t = 0, Ie = operatingSystemRules.length; t < Ie; t++) {
    var Be = operatingSystemRules[t], Pe = Be[0], Te = Be[1], Me = Te.exec(Ae);
    if (Me)
      return Pe;
  }
  return null;
}
function getNodeVersion() {
  var Ae = typeof process$1$1 < "u" && process$1$1.version;
  return Ae ? new NodeInfo(process$1$1.version.slice(1)) : null;
}
function createVersionParts(Ae) {
  for (var t = [], Ie = 0; Ie < Ae; Ie++)
    t.push("0");
  return t;
}
var cjs$2 = {};
Object.defineProperty(cjs$2, "__esModule", { value: !0 });
cjs$2.getLocalStorage = cjs$2.getLocalStorageOrThrow = cjs$2.getCrypto = cjs$2.getCryptoOrThrow = getLocation_1 = cjs$2.getLocation = cjs$2.getLocationOrThrow = getNavigator_1 = cjs$2.getNavigator = cjs$2.getNavigatorOrThrow = getDocument_1 = cjs$2.getDocument = cjs$2.getDocumentOrThrow = cjs$2.getFromWindowOrThrow = cjs$2.getFromWindow = void 0;
function getFromWindow(Ae) {
  let t;
  return typeof window < "u" && typeof window[Ae] < "u" && (t = window[Ae]), t;
}
cjs$2.getFromWindow = getFromWindow;
function getFromWindowOrThrow(Ae) {
  const t = getFromWindow(Ae);
  if (!t)
    throw new Error(`${Ae} is not defined in Window`);
  return t;
}
cjs$2.getFromWindowOrThrow = getFromWindowOrThrow;
function getDocumentOrThrow() {
  return getFromWindowOrThrow("document");
}
cjs$2.getDocumentOrThrow = getDocumentOrThrow;
function getDocument() {
  return getFromWindow("document");
}
var getDocument_1 = cjs$2.getDocument = getDocument;
function getNavigatorOrThrow() {
  return getFromWindowOrThrow("navigator");
}
cjs$2.getNavigatorOrThrow = getNavigatorOrThrow;
function getNavigator() {
  return getFromWindow("navigator");
}
var getNavigator_1 = cjs$2.getNavigator = getNavigator;
function getLocationOrThrow() {
  return getFromWindowOrThrow("location");
}
cjs$2.getLocationOrThrow = getLocationOrThrow;
function getLocation() {
  return getFromWindow("location");
}
var getLocation_1 = cjs$2.getLocation = getLocation;
function getCryptoOrThrow() {
  return getFromWindowOrThrow("crypto");
}
cjs$2.getCryptoOrThrow = getCryptoOrThrow;
function getCrypto() {
  return getFromWindow("crypto");
}
cjs$2.getCrypto = getCrypto;
function getLocalStorageOrThrow() {
  return getFromWindowOrThrow("localStorage");
}
cjs$2.getLocalStorageOrThrow = getLocalStorageOrThrow;
function getLocalStorage() {
  return getFromWindow("localStorage");
}
cjs$2.getLocalStorage = getLocalStorage;
var cjs$1 = {};
Object.defineProperty(cjs$1, "__esModule", { value: !0 });
var getWindowMetadata_1 = cjs$1.getWindowMetadata = void 0;
const window_getters_1 = cjs$2;
function getWindowMetadata() {
  let Ae, t;
  try {
    Ae = window_getters_1.getDocumentOrThrow(), t = window_getters_1.getLocationOrThrow();
  } catch {
    return null;
  }
  function Ie() {
    const vn = Ae.getElementsByTagName("link"), En = [];
    for (let fi = 0; fi < vn.length; fi++) {
      const bi = vn[fi], mi = bi.getAttribute("rel");
      if (mi && mi.toLowerCase().indexOf("icon") > -1) {
        const _i = bi.getAttribute("href");
        if (_i)
          if (_i.toLowerCase().indexOf("https:") === -1 && _i.toLowerCase().indexOf("http:") === -1 && _i.indexOf("//") !== 0) {
            let Ei = t.protocol + "//" + t.host;
            if (_i.indexOf("/") === 0)
              Ei += _i;
            else {
              const Si = t.pathname.split("/");
              Si.pop();
              const Mi = Si.join("/");
              Ei += Mi + "/" + _i;
            }
            En.push(Ei);
          } else if (_i.indexOf("//") === 0) {
            const Ei = t.protocol + _i;
            En.push(Ei);
          } else
            En.push(_i);
      }
    }
    return En;
  }
  function Be(...vn) {
    const En = Ae.getElementsByTagName("meta");
    for (let fi = 0; fi < En.length; fi++) {
      const bi = En[fi], mi = ["itemprop", "property", "name"].map((_i) => bi.getAttribute(_i)).filter((_i) => _i ? vn.includes(_i) : !1);
      if (mi.length && mi) {
        const _i = bi.getAttribute("content");
        if (_i)
          return _i;
      }
    }
    return "";
  }
  function Pe() {
    let vn = Be("name", "og:site_name", "og:title", "twitter:title");
    return vn || (vn = Ae.title), vn;
  }
  function Te() {
    return Be("description", "og:description", "twitter:description", "keywords");
  }
  const Me = Pe(), Ue = Te(), je = t.origin, fn = Ie();
  return {
    description: Ue,
    url: je,
    icons: fn,
    name: Me
  };
}
getWindowMetadata_1 = cjs$1.getWindowMetadata = getWindowMetadata;
var queryString = {}, strictUriEncode = (Ae) => encodeURIComponent(Ae).replace(/[!'()*]/g, (t) => `%${t.charCodeAt(0).toString(16).toUpperCase()}`), token = "%[a-f0-9]{2}", singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi"), multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(Ae, t) {
  try {
    return [decodeURIComponent(Ae.join(""))];
  } catch {
  }
  if (Ae.length === 1)
    return Ae;
  t = t || 1;
  var Ie = Ae.slice(0, t), Be = Ae.slice(t);
  return Array.prototype.concat.call([], decodeComponents(Ie), decodeComponents(Be));
}
function decode(Ae) {
  try {
    return decodeURIComponent(Ae);
  } catch {
    for (var t = Ae.match(singleMatcher) || [], Ie = 1; Ie < t.length; Ie++)
      Ae = decodeComponents(t, Ie).join(""), t = Ae.match(singleMatcher) || [];
    return Ae;
  }
}
function customDecodeURIComponent(Ae) {
  for (var t = {
    "%FE%FF": "",
    "%FF%FE": ""
  }, Ie = multiMatcher.exec(Ae); Ie; ) {
    try {
      t[Ie[0]] = decodeURIComponent(Ie[0]);
    } catch {
      var Be = decode(Ie[0]);
      Be !== Ie[0] && (t[Ie[0]] = Be);
    }
    Ie = multiMatcher.exec(Ae);
  }
  t["%C2"] = "";
  for (var Pe = Object.keys(t), Te = 0; Te < Pe.length; Te++) {
    var Me = Pe[Te];
    Ae = Ae.replace(new RegExp(Me, "g"), t[Me]);
  }
  return Ae;
}
var decodeUriComponent = function(Ae) {
  if (typeof Ae != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof Ae + "`");
  try {
    return Ae = Ae.replace(/\+/g, " "), decodeURIComponent(Ae);
  } catch {
    return customDecodeURIComponent(Ae);
  }
}, splitOnFirst = (Ae, t) => {
  if (!(typeof Ae == "string" && typeof t == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (t === "")
    return [Ae];
  const Ie = Ae.indexOf(t);
  return Ie === -1 ? [Ae] : [
    Ae.slice(0, Ie),
    Ae.slice(Ie + t.length)
  ];
}, filterObj = function(Ae, t) {
  for (var Ie = {}, Be = Object.keys(Ae), Pe = Array.isArray(t), Te = 0; Te < Be.length; Te++) {
    var Me = Be[Te], Ue = Ae[Me];
    (Pe ? t.indexOf(Me) !== -1 : t(Me, Ue, Ae)) && (Ie[Me] = Ue);
  }
  return Ie;
};
(function(Ae) {
  const t = strictUriEncode, Ie = decodeUriComponent, Be = splitOnFirst, Pe = filterObj, Te = (Si) => Si == null, Me = Symbol("encodeFragmentIdentifier");
  function Ue(Si) {
    switch (Si.arrayFormat) {
      case "index":
        return (Mi) => (Oi, Fi) => {
          const Ui = Oi.length;
          return Fi === void 0 || Si.skipNull && Fi === null || Si.skipEmptyString && Fi === "" ? Oi : Fi === null ? [...Oi, [Ve(Mi, Si), "[", Ui, "]"].join("")] : [
            ...Oi,
            [Ve(Mi, Si), "[", Ve(Ui, Si), "]=", Ve(Fi, Si)].join("")
          ];
        };
      case "bracket":
        return (Mi) => (Oi, Fi) => Fi === void 0 || Si.skipNull && Fi === null || Si.skipEmptyString && Fi === "" ? Oi : Fi === null ? [...Oi, [Ve(Mi, Si), "[]"].join("")] : [...Oi, [Ve(Mi, Si), "[]=", Ve(Fi, Si)].join("")];
      case "colon-list-separator":
        return (Mi) => (Oi, Fi) => Fi === void 0 || Si.skipNull && Fi === null || Si.skipEmptyString && Fi === "" ? Oi : Fi === null ? [...Oi, [Ve(Mi, Si), ":list="].join("")] : [...Oi, [Ve(Mi, Si), ":list=", Ve(Fi, Si)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const Mi = Si.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (Oi) => (Fi, Ui) => Ui === void 0 || Si.skipNull && Ui === null || Si.skipEmptyString && Ui === "" ? Fi : (Ui = Ui === null ? "" : Ui, Fi.length === 0 ? [[Ve(Oi, Si), Mi, Ve(Ui, Si)].join("")] : [[Fi, Ve(Ui, Si)].join(Si.arrayFormatSeparator)]);
      }
      default:
        return (Mi) => (Oi, Fi) => Fi === void 0 || Si.skipNull && Fi === null || Si.skipEmptyString && Fi === "" ? Oi : Fi === null ? [...Oi, Ve(Mi, Si)] : [...Oi, [Ve(Mi, Si), "=", Ve(Fi, Si)].join("")];
    }
  }
  function je(Si) {
    let Mi;
    switch (Si.arrayFormat) {
      case "index":
        return (Oi, Fi, Ui) => {
          if (Mi = /\[(\d*)\]$/.exec(Oi), Oi = Oi.replace(/\[\d*\]$/, ""), !Mi) {
            Ui[Oi] = Fi;
            return;
          }
          Ui[Oi] === void 0 && (Ui[Oi] = {}), Ui[Oi][Mi[1]] = Fi;
        };
      case "bracket":
        return (Oi, Fi, Ui) => {
          if (Mi = /(\[\])$/.exec(Oi), Oi = Oi.replace(/\[\]$/, ""), !Mi) {
            Ui[Oi] = Fi;
            return;
          }
          if (Ui[Oi] === void 0) {
            Ui[Oi] = [Fi];
            return;
          }
          Ui[Oi] = [].concat(Ui[Oi], Fi);
        };
      case "colon-list-separator":
        return (Oi, Fi, Ui) => {
          if (Mi = /(:list)$/.exec(Oi), Oi = Oi.replace(/:list$/, ""), !Mi) {
            Ui[Oi] = Fi;
            return;
          }
          if (Ui[Oi] === void 0) {
            Ui[Oi] = [Fi];
            return;
          }
          Ui[Oi] = [].concat(Ui[Oi], Fi);
        };
      case "comma":
      case "separator":
        return (Oi, Fi, Ui) => {
          const Pi = typeof Fi == "string" && Fi.includes(Si.arrayFormatSeparator), Bi = typeof Fi == "string" && !Pi && vn(Fi, Si).includes(Si.arrayFormatSeparator);
          Fi = Bi ? vn(Fi, Si) : Fi;
          const ji = Pi || Bi ? Fi.split(Si.arrayFormatSeparator).map((Zi) => vn(Zi, Si)) : Fi === null ? Fi : vn(Fi, Si);
          Ui[Oi] = ji;
        };
      case "bracket-separator":
        return (Oi, Fi, Ui) => {
          const Pi = /(\[\])$/.test(Oi);
          if (Oi = Oi.replace(/\[\]$/, ""), !Pi) {
            Ui[Oi] = Fi && vn(Fi, Si);
            return;
          }
          const Bi = Fi === null ? [] : Fi.split(Si.arrayFormatSeparator).map((ji) => vn(ji, Si));
          if (Ui[Oi] === void 0) {
            Ui[Oi] = Bi;
            return;
          }
          Ui[Oi] = [].concat(Ui[Oi], Bi);
        };
      default:
        return (Oi, Fi, Ui) => {
          if (Ui[Oi] === void 0) {
            Ui[Oi] = Fi;
            return;
          }
          Ui[Oi] = [].concat(Ui[Oi], Fi);
        };
    }
  }
  function fn(Si) {
    if (typeof Si != "string" || Si.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function Ve(Si, Mi) {
    return Mi.encode ? Mi.strict ? t(Si) : encodeURIComponent(Si) : Si;
  }
  function vn(Si, Mi) {
    return Mi.decode ? Ie(Si) : Si;
  }
  function En(Si) {
    return Array.isArray(Si) ? Si.sort() : typeof Si == "object" ? En(Object.keys(Si)).sort((Mi, Oi) => Number(Mi) - Number(Oi)).map((Mi) => Si[Mi]) : Si;
  }
  function fi(Si) {
    const Mi = Si.indexOf("#");
    return Mi !== -1 && (Si = Si.slice(0, Mi)), Si;
  }
  function bi(Si) {
    let Mi = "";
    const Oi = Si.indexOf("#");
    return Oi !== -1 && (Mi = Si.slice(Oi)), Mi;
  }
  function mi(Si) {
    Si = fi(Si);
    const Mi = Si.indexOf("?");
    return Mi === -1 ? "" : Si.slice(Mi + 1);
  }
  function _i(Si, Mi) {
    return Mi.parseNumbers && !Number.isNaN(Number(Si)) && typeof Si == "string" && Si.trim() !== "" ? Si = Number(Si) : Mi.parseBooleans && Si !== null && (Si.toLowerCase() === "true" || Si.toLowerCase() === "false") && (Si = Si.toLowerCase() === "true"), Si;
  }
  function Ei(Si, Mi) {
    Mi = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, Mi), fn(Mi.arrayFormatSeparator);
    const Oi = je(Mi), Fi = /* @__PURE__ */ Object.create(null);
    if (typeof Si != "string" || (Si = Si.trim().replace(/^[?#&]/, ""), !Si))
      return Fi;
    for (const Ui of Si.split("&")) {
      if (Ui === "")
        continue;
      let [Pi, Bi] = Be(Mi.decode ? Ui.replace(/\+/g, " ") : Ui, "=");
      Bi = Bi === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(Mi.arrayFormat) ? Bi : vn(Bi, Mi), Oi(vn(Pi, Mi), Bi, Fi);
    }
    for (const Ui of Object.keys(Fi)) {
      const Pi = Fi[Ui];
      if (typeof Pi == "object" && Pi !== null)
        for (const Bi of Object.keys(Pi))
          Pi[Bi] = _i(Pi[Bi], Mi);
      else
        Fi[Ui] = _i(Pi, Mi);
    }
    return Mi.sort === !1 ? Fi : (Mi.sort === !0 ? Object.keys(Fi).sort() : Object.keys(Fi).sort(Mi.sort)).reduce((Ui, Pi) => {
      const Bi = Fi[Pi];
      return Bi && typeof Bi == "object" && !Array.isArray(Bi) ? Ui[Pi] = En(Bi) : Ui[Pi] = Bi, Ui;
    }, /* @__PURE__ */ Object.create(null));
  }
  Ae.extract = mi, Ae.parse = Ei, Ae.stringify = (Si, Mi) => {
    if (!Si)
      return "";
    Mi = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, Mi), fn(Mi.arrayFormatSeparator);
    const Oi = (Bi) => Mi.skipNull && Te(Si[Bi]) || Mi.skipEmptyString && Si[Bi] === "", Fi = Ue(Mi), Ui = {};
    for (const Bi of Object.keys(Si))
      Oi(Bi) || (Ui[Bi] = Si[Bi]);
    const Pi = Object.keys(Ui);
    return Mi.sort !== !1 && Pi.sort(Mi.sort), Pi.map((Bi) => {
      const ji = Si[Bi];
      return ji === void 0 ? "" : ji === null ? Ve(Bi, Mi) : Array.isArray(ji) ? ji.length === 0 && Mi.arrayFormat === "bracket-separator" ? Ve(Bi, Mi) + "[]" : ji.reduce(Fi(Bi), []).join("&") : Ve(Bi, Mi) + "=" + Ve(ji, Mi);
    }).filter((Bi) => Bi.length > 0).join("&");
  }, Ae.parseUrl = (Si, Mi) => {
    Mi = Object.assign({
      decode: !0
    }, Mi);
    const [Oi, Fi] = Be(Si, "#");
    return Object.assign(
      {
        url: Oi.split("?")[0] || "",
        query: Ei(mi(Si), Mi)
      },
      Mi && Mi.parseFragmentIdentifier && Fi ? { fragmentIdentifier: vn(Fi, Mi) } : {}
    );
  }, Ae.stringifyUrl = (Si, Mi) => {
    Mi = Object.assign({
      encode: !0,
      strict: !0,
      [Me]: !0
    }, Mi);
    const Oi = fi(Si.url).split("?")[0] || "", Fi = Ae.extract(Si.url), Ui = Ae.parse(Fi, { sort: !1 }), Pi = Object.assign(Ui, Si.query);
    let Bi = Ae.stringify(Pi, Mi);
    Bi && (Bi = `?${Bi}`);
    let ji = bi(Si.url);
    return Si.fragmentIdentifier && (ji = `#${Mi[Me] ? Ve(Si.fragmentIdentifier, Mi) : Si.fragmentIdentifier}`), `${Oi}${Bi}${ji}`;
  }, Ae.pick = (Si, Mi, Oi) => {
    Oi = Object.assign({
      parseFragmentIdentifier: !0,
      [Me]: !1
    }, Oi);
    const { url: Fi, query: Ui, fragmentIdentifier: Pi } = Ae.parseUrl(Si, Oi);
    return Ae.stringifyUrl({
      url: Fi,
      query: Pe(Ui, Mi),
      fragmentIdentifier: Pi
    }, Oi);
  }, Ae.exclude = (Si, Mi, Oi) => {
    const Fi = Array.isArray(Mi) ? (Ui) => !Mi.includes(Ui) : (Ui, Pi) => !Mi(Ui, Pi);
    return Ae.pick(Si, Fi, Oi);
  };
})(queryString);
var sha3$1 = { exports: {} };
(function(Ae) {
  (function() {
    var t = "input is invalid type", Ie = "finalize already called", Be = typeof window == "object", Pe = Be ? window : {};
    Pe.JS_SHA3_NO_WINDOW && (Be = !1);
    var Te = !Be && typeof self == "object", Me = !Pe.JS_SHA3_NO_NODE_JS && typeof process$1$1 == "object" && process$1$1.versions && process$1$1.versions.node;
    Me ? Pe = commonjsGlobal : Te && (Pe = self);
    var Ue = !Pe.JS_SHA3_NO_COMMON_JS && !0 && Ae.exports, je = !Pe.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", fn = "0123456789abcdef".split(""), Ve = [31, 7936, 2031616, 520093696], vn = [4, 1024, 262144, 67108864], En = [1, 256, 65536, 16777216], fi = [6, 1536, 393216, 100663296], bi = [0, 8, 16, 24], mi = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ], _i = [224, 256, 384, 512], Ei = [128, 256], Si = ["hex", "buffer", "arrayBuffer", "array", "digest"], Mi = {
      128: 168,
      256: 136
    };
    (Pe.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(Ki) {
      return Object.prototype.toString.call(Ki) === "[object Array]";
    }), je && (Pe.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(Ki) {
      return typeof Ki == "object" && Ki.buffer && Ki.buffer.constructor === ArrayBuffer;
    });
    for (var Oi = function(Ki, ts, qi) {
      return function(Hi) {
        return new Ni(Ki, ts, Ki).update(Hi)[qi]();
      };
    }, Fi = function(Ki, ts, qi) {
      return function(Hi, Xi) {
        return new Ni(Ki, ts, Xi).update(Hi)[qi]();
      };
    }, Ui = function(Ki, ts, qi) {
      return function(Hi, Xi, ki, Wi) {
        return vi["cshake" + Ki].update(Hi, Xi, ki, Wi)[qi]();
      };
    }, Pi = function(Ki, ts, qi) {
      return function(Hi, Xi, ki, Wi) {
        return vi["kmac" + Ki].update(Hi, Xi, ki, Wi)[qi]();
      };
    }, Bi = function(Ki, ts, qi, Hi) {
      for (var Xi = 0; Xi < Si.length; ++Xi) {
        var ki = Si[Xi];
        Ki[ki] = ts(qi, Hi, ki);
      }
      return Ki;
    }, ji = function(Ki, ts) {
      var qi = Oi(Ki, ts, "hex");
      return qi.create = function() {
        return new Ni(Ki, ts, Ki);
      }, qi.update = function(Hi) {
        return qi.create().update(Hi);
      }, Bi(qi, Oi, Ki, ts);
    }, Zi = function(Ki, ts) {
      var qi = Fi(Ki, ts, "hex");
      return qi.create = function(Hi) {
        return new Ni(Ki, ts, Hi);
      }, qi.update = function(Hi, Xi) {
        return qi.create(Xi).update(Hi);
      }, Bi(qi, Fi, Ki, ts);
    }, zi = function(Ki, ts) {
      var qi = Mi[Ki], Hi = Ui(Ki, ts, "hex");
      return Hi.create = function(Xi, ki, Wi) {
        return !ki && !Wi ? vi["shake" + Ki].create(Xi) : new Ni(Ki, ts, Xi).bytepad([ki, Wi], qi);
      }, Hi.update = function(Xi, ki, Wi, Yi) {
        return Hi.create(ki, Wi, Yi).update(Xi);
      }, Bi(Hi, Ui, Ki, ts);
    }, xi = function(Ki, ts) {
      var qi = Mi[Ki], Hi = Pi(Ki, ts, "hex");
      return Hi.create = function(Xi, ki, Wi) {
        return new Vi(Ki, ts, ki).bytepad(["KMAC", Wi], qi).bytepad([Xi], qi);
      }, Hi.update = function(Xi, ki, Wi, Yi) {
        return Hi.create(Xi, Wi, Yi).update(ki);
      }, Bi(Hi, Pi, Ki, ts);
    }, $i = [
      { name: "keccak", padding: En, bits: _i, createMethod: ji },
      { name: "sha3", padding: fi, bits: _i, createMethod: ji },
      { name: "shake", padding: Ve, bits: Ei, createMethod: Zi },
      { name: "cshake", padding: vn, bits: Ei, createMethod: zi },
      { name: "kmac", padding: vn, bits: Ei, createMethod: xi }
    ], vi = {}, wi = [], Ai = 0; Ai < $i.length; ++Ai)
      for (var Ri = $i[Ai], Ti = Ri.bits, Ci = 0; Ci < Ti.length; ++Ci) {
        var Ii = Ri.name + "_" + Ti[Ci];
        if (wi.push(Ii), vi[Ii] = Ri.createMethod(Ti[Ci], Ri.padding), Ri.name !== "sha3") {
          var Li = Ri.name + Ti[Ci];
          wi.push(Li), vi[Li] = vi[Ii];
        }
      }
    function Ni(Ki, ts, qi) {
      this.blocks = [], this.s = [], this.padding = ts, this.outputBits = qi, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (Ki << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = qi >> 5, this.extraBytes = (qi & 31) >> 3;
      for (var Hi = 0; Hi < 50; ++Hi)
        this.s[Hi] = 0;
    }
    Ni.prototype.update = function(Ki) {
      if (this.finalized)
        throw new Error(Ie);
      var ts, qi = typeof Ki;
      if (qi !== "string") {
        if (qi === "object") {
          if (Ki === null)
            throw new Error(t);
          if (je && Ki.constructor === ArrayBuffer)
            Ki = new Uint8Array(Ki);
          else if (!Array.isArray(Ki) && (!je || !ArrayBuffer.isView(Ki)))
            throw new Error(t);
        } else
          throw new Error(t);
        ts = !0;
      }
      for (var Hi = this.blocks, Xi = this.byteCount, ki = Ki.length, Wi = this.blockCount, Yi = 0, Qi = this.s, ns, us; Yi < ki; ) {
        if (this.reset)
          for (this.reset = !1, Hi[0] = this.block, ns = 1; ns < Wi + 1; ++ns)
            Hi[ns] = 0;
        if (ts)
          for (ns = this.start; Yi < ki && ns < Xi; ++Yi)
            Hi[ns >> 2] |= Ki[Yi] << bi[ns++ & 3];
        else
          for (ns = this.start; Yi < ki && ns < Xi; ++Yi)
            us = Ki.charCodeAt(Yi), us < 128 ? Hi[ns >> 2] |= us << bi[ns++ & 3] : us < 2048 ? (Hi[ns >> 2] |= (192 | us >> 6) << bi[ns++ & 3], Hi[ns >> 2] |= (128 | us & 63) << bi[ns++ & 3]) : us < 55296 || us >= 57344 ? (Hi[ns >> 2] |= (224 | us >> 12) << bi[ns++ & 3], Hi[ns >> 2] |= (128 | us >> 6 & 63) << bi[ns++ & 3], Hi[ns >> 2] |= (128 | us & 63) << bi[ns++ & 3]) : (us = 65536 + ((us & 1023) << 10 | Ki.charCodeAt(++Yi) & 1023), Hi[ns >> 2] |= (240 | us >> 18) << bi[ns++ & 3], Hi[ns >> 2] |= (128 | us >> 12 & 63) << bi[ns++ & 3], Hi[ns >> 2] |= (128 | us >> 6 & 63) << bi[ns++ & 3], Hi[ns >> 2] |= (128 | us & 63) << bi[ns++ & 3]);
        if (this.lastByteIndex = ns, ns >= Xi) {
          for (this.start = ns - Xi, this.block = Hi[Wi], ns = 0; ns < Wi; ++ns)
            Qi[ns] ^= Hi[ns];
          is(Qi), this.reset = !0;
        } else
          this.start = ns;
      }
      return this;
    }, Ni.prototype.encode = function(Ki, ts) {
      var qi = Ki & 255, Hi = 1, Xi = [qi];
      for (Ki = Ki >> 8, qi = Ki & 255; qi > 0; )
        Xi.unshift(qi), Ki = Ki >> 8, qi = Ki & 255, ++Hi;
      return ts ? Xi.push(Hi) : Xi.unshift(Hi), this.update(Xi), Xi.length;
    }, Ni.prototype.encodeString = function(Ki) {
      var ts, qi = typeof Ki;
      if (qi !== "string") {
        if (qi === "object") {
          if (Ki === null)
            throw new Error(t);
          if (je && Ki.constructor === ArrayBuffer)
            Ki = new Uint8Array(Ki);
          else if (!Array.isArray(Ki) && (!je || !ArrayBuffer.isView(Ki)))
            throw new Error(t);
        } else
          throw new Error(t);
        ts = !0;
      }
      var Hi = 0, Xi = Ki.length;
      if (ts)
        Hi = Xi;
      else
        for (var ki = 0; ki < Ki.length; ++ki) {
          var Wi = Ki.charCodeAt(ki);
          Wi < 128 ? Hi += 1 : Wi < 2048 ? Hi += 2 : Wi < 55296 || Wi >= 57344 ? Hi += 3 : (Wi = 65536 + ((Wi & 1023) << 10 | Ki.charCodeAt(++ki) & 1023), Hi += 4);
        }
      return Hi += this.encode(Hi * 8), this.update(Ki), Hi;
    }, Ni.prototype.bytepad = function(Ki, ts) {
      for (var qi = this.encode(ts), Hi = 0; Hi < Ki.length; ++Hi)
        qi += this.encodeString(Ki[Hi]);
      var Xi = ts - qi % ts, ki = [];
      return ki.length = Xi, this.update(ki), this;
    }, Ni.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var Ki = this.blocks, ts = this.lastByteIndex, qi = this.blockCount, Hi = this.s;
        if (Ki[ts >> 2] |= this.padding[ts & 3], this.lastByteIndex === this.byteCount)
          for (Ki[0] = Ki[qi], ts = 1; ts < qi + 1; ++ts)
            Ki[ts] = 0;
        for (Ki[qi - 1] |= 2147483648, ts = 0; ts < qi; ++ts)
          Hi[ts] ^= Ki[ts];
        is(Hi);
      }
    }, Ni.prototype.toString = Ni.prototype.hex = function() {
      this.finalize();
      for (var Ki = this.blockCount, ts = this.s, qi = this.outputBlocks, Hi = this.extraBytes, Xi = 0, ki = 0, Wi = "", Yi; ki < qi; ) {
        for (Xi = 0; Xi < Ki && ki < qi; ++Xi, ++ki)
          Yi = ts[Xi], Wi += fn[Yi >> 4 & 15] + fn[Yi & 15] + fn[Yi >> 12 & 15] + fn[Yi >> 8 & 15] + fn[Yi >> 20 & 15] + fn[Yi >> 16 & 15] + fn[Yi >> 28 & 15] + fn[Yi >> 24 & 15];
        ki % Ki === 0 && (is(ts), Xi = 0);
      }
      return Hi && (Yi = ts[Xi], Wi += fn[Yi >> 4 & 15] + fn[Yi & 15], Hi > 1 && (Wi += fn[Yi >> 12 & 15] + fn[Yi >> 8 & 15]), Hi > 2 && (Wi += fn[Yi >> 20 & 15] + fn[Yi >> 16 & 15])), Wi;
    }, Ni.prototype.arrayBuffer = function() {
      this.finalize();
      var Ki = this.blockCount, ts = this.s, qi = this.outputBlocks, Hi = this.extraBytes, Xi = 0, ki = 0, Wi = this.outputBits >> 3, Yi;
      Hi ? Yi = new ArrayBuffer(qi + 1 << 2) : Yi = new ArrayBuffer(Wi);
      for (var Qi = new Uint32Array(Yi); ki < qi; ) {
        for (Xi = 0; Xi < Ki && ki < qi; ++Xi, ++ki)
          Qi[ki] = ts[Xi];
        ki % Ki === 0 && is(ts);
      }
      return Hi && (Qi[Xi] = ts[Xi], Yi = Yi.slice(0, Wi)), Yi;
    }, Ni.prototype.buffer = Ni.prototype.arrayBuffer, Ni.prototype.digest = Ni.prototype.array = function() {
      this.finalize();
      for (var Ki = this.blockCount, ts = this.s, qi = this.outputBlocks, Hi = this.extraBytes, Xi = 0, ki = 0, Wi = [], Yi, Qi; ki < qi; ) {
        for (Xi = 0; Xi < Ki && ki < qi; ++Xi, ++ki)
          Yi = ki << 2, Qi = ts[Xi], Wi[Yi] = Qi & 255, Wi[Yi + 1] = Qi >> 8 & 255, Wi[Yi + 2] = Qi >> 16 & 255, Wi[Yi + 3] = Qi >> 24 & 255;
        ki % Ki === 0 && is(ts);
      }
      return Hi && (Yi = ki << 2, Qi = ts[Xi], Wi[Yi] = Qi & 255, Hi > 1 && (Wi[Yi + 1] = Qi >> 8 & 255), Hi > 2 && (Wi[Yi + 2] = Qi >> 16 & 255)), Wi;
    };
    function Vi(Ki, ts, qi) {
      Ni.call(this, Ki, ts, qi);
    }
    Vi.prototype = new Ni(), Vi.prototype.finalize = function() {
      return this.encode(this.outputBits, !0), Ni.prototype.finalize.call(this);
    };
    var is = function(Ki) {
      var ts, qi, Hi, Xi, ki, Wi, Yi, Qi, ns, us, ps, Ds, Eo, hs, So, _o, vo, Ro, $o, Io, To, Ao, Po, Co, rs, Gi, Ji, ss, ls, ds, bs, Mo, Fo, Bo, Uo, Lo, Go, Yo, Ko, No, Wo, os, as, go, bo, wo, qo, jo, Oo, Ho, zo, Do, Xo, na, Vo, ra, Zo, ta, ca, oa, ga, ba, ua;
      for (Hi = 0; Hi < 48; Hi += 2)
        Xi = Ki[0] ^ Ki[10] ^ Ki[20] ^ Ki[30] ^ Ki[40], ki = Ki[1] ^ Ki[11] ^ Ki[21] ^ Ki[31] ^ Ki[41], Wi = Ki[2] ^ Ki[12] ^ Ki[22] ^ Ki[32] ^ Ki[42], Yi = Ki[3] ^ Ki[13] ^ Ki[23] ^ Ki[33] ^ Ki[43], Qi = Ki[4] ^ Ki[14] ^ Ki[24] ^ Ki[34] ^ Ki[44], ns = Ki[5] ^ Ki[15] ^ Ki[25] ^ Ki[35] ^ Ki[45], us = Ki[6] ^ Ki[16] ^ Ki[26] ^ Ki[36] ^ Ki[46], ps = Ki[7] ^ Ki[17] ^ Ki[27] ^ Ki[37] ^ Ki[47], Ds = Ki[8] ^ Ki[18] ^ Ki[28] ^ Ki[38] ^ Ki[48], Eo = Ki[9] ^ Ki[19] ^ Ki[29] ^ Ki[39] ^ Ki[49], ts = Ds ^ (Wi << 1 | Yi >>> 31), qi = Eo ^ (Yi << 1 | Wi >>> 31), Ki[0] ^= ts, Ki[1] ^= qi, Ki[10] ^= ts, Ki[11] ^= qi, Ki[20] ^= ts, Ki[21] ^= qi, Ki[30] ^= ts, Ki[31] ^= qi, Ki[40] ^= ts, Ki[41] ^= qi, ts = Xi ^ (Qi << 1 | ns >>> 31), qi = ki ^ (ns << 1 | Qi >>> 31), Ki[2] ^= ts, Ki[3] ^= qi, Ki[12] ^= ts, Ki[13] ^= qi, Ki[22] ^= ts, Ki[23] ^= qi, Ki[32] ^= ts, Ki[33] ^= qi, Ki[42] ^= ts, Ki[43] ^= qi, ts = Wi ^ (us << 1 | ps >>> 31), qi = Yi ^ (ps << 1 | us >>> 31), Ki[4] ^= ts, Ki[5] ^= qi, Ki[14] ^= ts, Ki[15] ^= qi, Ki[24] ^= ts, Ki[25] ^= qi, Ki[34] ^= ts, Ki[35] ^= qi, Ki[44] ^= ts, Ki[45] ^= qi, ts = Qi ^ (Ds << 1 | Eo >>> 31), qi = ns ^ (Eo << 1 | Ds >>> 31), Ki[6] ^= ts, Ki[7] ^= qi, Ki[16] ^= ts, Ki[17] ^= qi, Ki[26] ^= ts, Ki[27] ^= qi, Ki[36] ^= ts, Ki[37] ^= qi, Ki[46] ^= ts, Ki[47] ^= qi, ts = us ^ (Xi << 1 | ki >>> 31), qi = ps ^ (ki << 1 | Xi >>> 31), Ki[8] ^= ts, Ki[9] ^= qi, Ki[18] ^= ts, Ki[19] ^= qi, Ki[28] ^= ts, Ki[29] ^= qi, Ki[38] ^= ts, Ki[39] ^= qi, Ki[48] ^= ts, Ki[49] ^= qi, hs = Ki[0], So = Ki[1], wo = Ki[11] << 4 | Ki[10] >>> 28, qo = Ki[10] << 4 | Ki[11] >>> 28, ss = Ki[20] << 3 | Ki[21] >>> 29, ls = Ki[21] << 3 | Ki[20] >>> 29, oa = Ki[31] << 9 | Ki[30] >>> 23, ga = Ki[30] << 9 | Ki[31] >>> 23, os = Ki[40] << 18 | Ki[41] >>> 14, as = Ki[41] << 18 | Ki[40] >>> 14, Bo = Ki[2] << 1 | Ki[3] >>> 31, Uo = Ki[3] << 1 | Ki[2] >>> 31, _o = Ki[13] << 12 | Ki[12] >>> 20, vo = Ki[12] << 12 | Ki[13] >>> 20, jo = Ki[22] << 10 | Ki[23] >>> 22, Oo = Ki[23] << 10 | Ki[22] >>> 22, ds = Ki[33] << 13 | Ki[32] >>> 19, bs = Ki[32] << 13 | Ki[33] >>> 19, ba = Ki[42] << 2 | Ki[43] >>> 30, ua = Ki[43] << 2 | Ki[42] >>> 30, na = Ki[5] << 30 | Ki[4] >>> 2, Vo = Ki[4] << 30 | Ki[5] >>> 2, Lo = Ki[14] << 6 | Ki[15] >>> 26, Go = Ki[15] << 6 | Ki[14] >>> 26, Ro = Ki[25] << 11 | Ki[24] >>> 21, $o = Ki[24] << 11 | Ki[25] >>> 21, Ho = Ki[34] << 15 | Ki[35] >>> 17, zo = Ki[35] << 15 | Ki[34] >>> 17, Mo = Ki[45] << 29 | Ki[44] >>> 3, Fo = Ki[44] << 29 | Ki[45] >>> 3, Co = Ki[6] << 28 | Ki[7] >>> 4, rs = Ki[7] << 28 | Ki[6] >>> 4, ra = Ki[17] << 23 | Ki[16] >>> 9, Zo = Ki[16] << 23 | Ki[17] >>> 9, Yo = Ki[26] << 25 | Ki[27] >>> 7, Ko = Ki[27] << 25 | Ki[26] >>> 7, Io = Ki[36] << 21 | Ki[37] >>> 11, To = Ki[37] << 21 | Ki[36] >>> 11, Do = Ki[47] << 24 | Ki[46] >>> 8, Xo = Ki[46] << 24 | Ki[47] >>> 8, go = Ki[8] << 27 | Ki[9] >>> 5, bo = Ki[9] << 27 | Ki[8] >>> 5, Gi = Ki[18] << 20 | Ki[19] >>> 12, Ji = Ki[19] << 20 | Ki[18] >>> 12, ta = Ki[29] << 7 | Ki[28] >>> 25, ca = Ki[28] << 7 | Ki[29] >>> 25, No = Ki[38] << 8 | Ki[39] >>> 24, Wo = Ki[39] << 8 | Ki[38] >>> 24, Ao = Ki[48] << 14 | Ki[49] >>> 18, Po = Ki[49] << 14 | Ki[48] >>> 18, Ki[0] = hs ^ ~_o & Ro, Ki[1] = So ^ ~vo & $o, Ki[10] = Co ^ ~Gi & ss, Ki[11] = rs ^ ~Ji & ls, Ki[20] = Bo ^ ~Lo & Yo, Ki[21] = Uo ^ ~Go & Ko, Ki[30] = go ^ ~wo & jo, Ki[31] = bo ^ ~qo & Oo, Ki[40] = na ^ ~ra & ta, Ki[41] = Vo ^ ~Zo & ca, Ki[2] = _o ^ ~Ro & Io, Ki[3] = vo ^ ~$o & To, Ki[12] = Gi ^ ~ss & ds, Ki[13] = Ji ^ ~ls & bs, Ki[22] = Lo ^ ~Yo & No, Ki[23] = Go ^ ~Ko & Wo, Ki[32] = wo ^ ~jo & Ho, Ki[33] = qo ^ ~Oo & zo, Ki[42] = ra ^ ~ta & oa, Ki[43] = Zo ^ ~ca & ga, Ki[4] = Ro ^ ~Io & Ao, Ki[5] = $o ^ ~To & Po, Ki[14] = ss ^ ~ds & Mo, Ki[15] = ls ^ ~bs & Fo, Ki[24] = Yo ^ ~No & os, Ki[25] = Ko ^ ~Wo & as, Ki[34] = jo ^ ~Ho & Do, Ki[35] = Oo ^ ~zo & Xo, Ki[44] = ta ^ ~oa & ba, Ki[45] = ca ^ ~ga & ua, Ki[6] = Io ^ ~Ao & hs, Ki[7] = To ^ ~Po & So, Ki[16] = ds ^ ~Mo & Co, Ki[17] = bs ^ ~Fo & rs, Ki[26] = No ^ ~os & Bo, Ki[27] = Wo ^ ~as & Uo, Ki[36] = Ho ^ ~Do & go, Ki[37] = zo ^ ~Xo & bo, Ki[46] = oa ^ ~ba & na, Ki[47] = ga ^ ~ua & Vo, Ki[8] = Ao ^ ~hs & _o, Ki[9] = Po ^ ~So & vo, Ki[18] = Mo ^ ~Co & Gi, Ki[19] = Fo ^ ~rs & Ji, Ki[28] = os ^ ~Bo & Lo, Ki[29] = as ^ ~Uo & Go, Ki[38] = Do ^ ~go & wo, Ki[39] = Xo ^ ~bo & qo, Ki[48] = ba ^ ~na & ra, Ki[49] = ua ^ ~Vo & Zo, Ki[0] ^= mi[Hi], Ki[1] ^= mi[Hi + 1];
    };
    if (Ue)
      Ae.exports = vi;
    else
      for (Ai = 0; Ai < wi.length; ++Ai)
        Pe[wi[Ai]] = vi[wi[Ai]];
  })();
})(sha3$1);
var sha3Exports = sha3$1.exports;
const sha3 = /* @__PURE__ */ getDefaultExportFromCjs(sha3Exports), version$4 = "logger/5.7.0";
let _permanentCensorErrors = !1, _censorErrors = !1;
const LogLevels = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels.default, _globalLogger = null;
function _checkNormalize() {
  try {
    const Ae = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((t) => {
      try {
        if ("test".normalize(t) !== "test")
          throw new Error("bad normalize");
      } catch {
        Ae.push(t);
      }
    }), Ae.length)
      throw new Error("missing " + Ae.join(", "));
    if ("".normalize("NFD") !== "e")
      throw new Error("broken implementation");
  } catch (Ae) {
    return Ae.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(Ae) {
  Ae.DEBUG = "DEBUG", Ae.INFO = "INFO", Ae.WARNING = "WARNING", Ae.ERROR = "ERROR", Ae.OFF = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(Ae) {
  Ae.UNKNOWN_ERROR = "UNKNOWN_ERROR", Ae.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", Ae.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", Ae.NETWORK_ERROR = "NETWORK_ERROR", Ae.SERVER_ERROR = "SERVER_ERROR", Ae.TIMEOUT = "TIMEOUT", Ae.BUFFER_OVERRUN = "BUFFER_OVERRUN", Ae.NUMERIC_FAULT = "NUMERIC_FAULT", Ae.MISSING_NEW = "MISSING_NEW", Ae.INVALID_ARGUMENT = "INVALID_ARGUMENT", Ae.MISSING_ARGUMENT = "MISSING_ARGUMENT", Ae.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", Ae.CALL_EXCEPTION = "CALL_EXCEPTION", Ae.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", Ae.NONCE_EXPIRED = "NONCE_EXPIRED", Ae.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", Ae.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", Ae.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", Ae.ACTION_REJECTED = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(t) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: t,
      writable: !1
    });
  }
  _log(t, Ie) {
    const Be = t.toLowerCase();
    LogLevels[Be] == null && this.throwArgumentError("invalid log level name", "logLevel", t), !(_logLevel > LogLevels[Be]) && console.log.apply(console, Ie);
  }
  debug(...t) {
    this._log(Logger.levels.DEBUG, t);
  }
  info(...t) {
    this._log(Logger.levels.INFO, t);
  }
  warn(...t) {
    this._log(Logger.levels.WARNING, t);
  }
  makeError(t, Ie, Be) {
    if (_censorErrors)
      return this.makeError("censored error", Ie, {});
    Ie || (Ie = Logger.errors.UNKNOWN_ERROR), Be || (Be = {});
    const Pe = [];
    Object.keys(Be).forEach((je) => {
      const fn = Be[je];
      try {
        if (fn instanceof Uint8Array) {
          let Ve = "";
          for (let vn = 0; vn < fn.length; vn++)
            Ve += HEX[fn[vn] >> 4], Ve += HEX[fn[vn] & 15];
          Pe.push(je + "=Uint8Array(0x" + Ve + ")");
        } else
          Pe.push(je + "=" + JSON.stringify(fn));
      } catch {
        Pe.push(je + "=" + JSON.stringify(Be[je].toString()));
      }
    }), Pe.push(`code=${Ie}`), Pe.push(`version=${this.version}`);
    const Te = t;
    let Me = "";
    switch (Ie) {
      case ErrorCode.NUMERIC_FAULT: {
        Me = "NUMERIC_FAULT";
        const je = t;
        switch (je) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            Me += "-" + je;
            break;
          case "negative-power":
          case "negative-width":
            Me += "-unsupported";
            break;
          case "unbound-bitwise-result":
            Me += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        Me = Ie;
        break;
    }
    Me && (t += " [ See: https://links.ethers.org/v5-errors-" + Me + " ]"), Pe.length && (t += " (" + Pe.join(", ") + ")");
    const Ue = new Error(t);
    return Ue.reason = Te, Ue.code = Ie, Object.keys(Be).forEach(function(je) {
      Ue[je] = Be[je];
    }), Ue;
  }
  throwError(t, Ie, Be) {
    throw this.makeError(t, Ie, Be);
  }
  throwArgumentError(t, Ie, Be) {
    return this.throwError(t, Logger.errors.INVALID_ARGUMENT, {
      argument: Ie,
      value: Be
    });
  }
  assert(t, Ie, Be, Pe) {
    t || this.throwError(Ie, Be, Pe);
  }
  assertArgument(t, Ie, Be, Pe) {
    t || this.throwArgumentError(Ie, Be, Pe);
  }
  checkNormalize(t) {
    _normalizeError && this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: _normalizeError
    });
  }
  checkSafeUint53(t, Ie) {
    typeof t == "number" && (Ie == null && (Ie = "value not safe"), (t < 0 || t >= 9007199254740991) && this.throwError(Ie, Logger.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: t
    }), t % 1 && this.throwError(Ie, Logger.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: t
    }));
  }
  checkArgumentCount(t, Ie, Be) {
    Be ? Be = ": " + Be : Be = "", t < Ie && this.throwError("missing argument" + Be, Logger.errors.MISSING_ARGUMENT, {
      count: t,
      expectedCount: Ie
    }), t > Ie && this.throwError("too many arguments" + Be, Logger.errors.UNEXPECTED_ARGUMENT, {
      count: t,
      expectedCount: Ie
    });
  }
  checkNew(t, Ie) {
    (t === Object || t == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: Ie.name });
  }
  checkAbstract(t, Ie) {
    t === Ie ? this.throwError("cannot instantiate abstract class " + JSON.stringify(Ie.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: t.name, operation: "new" }) : (t === Object || t == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: Ie.name });
  }
  static globalLogger() {
    return _globalLogger || (_globalLogger = new Logger(version$4)), _globalLogger;
  }
  static setCensorship(t, Ie) {
    if (!t && Ie && this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), _permanentCensorErrors) {
      if (!t)
        return;
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!t, _permanentCensorErrors = !!Ie;
  }
  static setLogLevel(t) {
    const Ie = LogLevels[t.toLowerCase()];
    if (Ie == null) {
      Logger.globalLogger().warn("invalid log level - " + t);
      return;
    }
    _logLevel = Ie;
  }
  static from(t) {
    return new Logger(t);
  }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
const version$3 = "bytes/5.7.0", logger$3 = new Logger(version$3);
function isHexable(Ae) {
  return !!Ae.toHexString;
}
function addSlice(Ae) {
  return Ae.slice || (Ae.slice = function() {
    const t = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(Ae, t)));
  }), Ae;
}
function isBytesLike(Ae) {
  return isHexString(Ae) && !(Ae.length % 2) || isBytes(Ae);
}
function isInteger(Ae) {
  return typeof Ae == "number" && Ae == Ae && Ae % 1 === 0;
}
function isBytes(Ae) {
  if (Ae == null)
    return !1;
  if (Ae.constructor === Uint8Array)
    return !0;
  if (typeof Ae == "string" || !isInteger(Ae.length) || Ae.length < 0)
    return !1;
  for (let t = 0; t < Ae.length; t++) {
    const Ie = Ae[t];
    if (!isInteger(Ie) || Ie < 0 || Ie >= 256)
      return !1;
  }
  return !0;
}
function arrayify(Ae, t) {
  if (t || (t = {}), typeof Ae == "number") {
    logger$3.checkSafeUint53(Ae, "invalid arrayify value");
    const Ie = [];
    for (; Ae; )
      Ie.unshift(Ae & 255), Ae = parseInt(String(Ae / 256));
    return Ie.length === 0 && Ie.push(0), addSlice(new Uint8Array(Ie));
  }
  if (t.allowMissingPrefix && typeof Ae == "string" && Ae.substring(0, 2) !== "0x" && (Ae = "0x" + Ae), isHexable(Ae) && (Ae = Ae.toHexString()), isHexString(Ae)) {
    let Ie = Ae.substring(2);
    Ie.length % 2 && (t.hexPad === "left" ? Ie = "0" + Ie : t.hexPad === "right" ? Ie += "0" : logger$3.throwArgumentError("hex data is odd-length", "value", Ae));
    const Be = [];
    for (let Pe = 0; Pe < Ie.length; Pe += 2)
      Be.push(parseInt(Ie.substring(Pe, Pe + 2), 16));
    return addSlice(new Uint8Array(Be));
  }
  return isBytes(Ae) ? addSlice(new Uint8Array(Ae)) : logger$3.throwArgumentError("invalid arrayify value", "value", Ae);
}
function concat(Ae) {
  const t = Ae.map((Pe) => arrayify(Pe)), Ie = t.reduce((Pe, Te) => Pe + Te.length, 0), Be = new Uint8Array(Ie);
  return t.reduce((Pe, Te) => (Be.set(Te, Pe), Pe + Te.length), 0), addSlice(Be);
}
function zeroPad(Ae, t) {
  Ae = arrayify(Ae), Ae.length > t && logger$3.throwArgumentError("value out of range", "value", arguments[0]);
  const Ie = new Uint8Array(t);
  return Ie.set(Ae, t - Ae.length), addSlice(Ie);
}
function isHexString(Ae, t) {
  return !(typeof Ae != "string" || !Ae.match(/^0x[0-9A-Fa-f]*$/) || t && Ae.length !== 2 + 2 * t);
}
const HexCharacters = "0123456789abcdef";
function hexlify(Ae, t) {
  if (t || (t = {}), typeof Ae == "number") {
    logger$3.checkSafeUint53(Ae, "invalid hexlify value");
    let Ie = "";
    for (; Ae; )
      Ie = HexCharacters[Ae & 15] + Ie, Ae = Math.floor(Ae / 16);
    return Ie.length ? (Ie.length % 2 && (Ie = "0" + Ie), "0x" + Ie) : "0x00";
  }
  if (typeof Ae == "bigint")
    return Ae = Ae.toString(16), Ae.length % 2 ? "0x0" + Ae : "0x" + Ae;
  if (t.allowMissingPrefix && typeof Ae == "string" && Ae.substring(0, 2) !== "0x" && (Ae = "0x" + Ae), isHexable(Ae))
    return Ae.toHexString();
  if (isHexString(Ae))
    return Ae.length % 2 && (t.hexPad === "left" ? Ae = "0x0" + Ae.substring(2) : t.hexPad === "right" ? Ae += "0" : logger$3.throwArgumentError("hex data is odd-length", "value", Ae)), Ae.toLowerCase();
  if (isBytes(Ae)) {
    let Ie = "0x";
    for (let Be = 0; Be < Ae.length; Be++) {
      let Pe = Ae[Be];
      Ie += HexCharacters[(Pe & 240) >> 4] + HexCharacters[Pe & 15];
    }
    return Ie;
  }
  return logger$3.throwArgumentError("invalid hexlify value", "value", Ae);
}
function hexDataLength(Ae) {
  if (typeof Ae != "string")
    Ae = hexlify(Ae);
  else if (!isHexString(Ae) || Ae.length % 2)
    return null;
  return (Ae.length - 2) / 2;
}
function hexDataSlice(Ae, t, Ie) {
  return typeof Ae != "string" ? Ae = hexlify(Ae) : (!isHexString(Ae) || Ae.length % 2) && logger$3.throwArgumentError("invalid hexData", "value", Ae), t = 2 + 2 * t, "0x" + Ae.substring(t);
}
function hexZeroPad(Ae, t) {
  for (typeof Ae != "string" ? Ae = hexlify(Ae) : isHexString(Ae) || logger$3.throwArgumentError("invalid hex string", "value", Ae), Ae.length > 2 * t + 2 && logger$3.throwArgumentError("value out of range", "value", arguments[1]); Ae.length < 2 * t + 2; )
    Ae = "0x0" + Ae.substring(2);
  return Ae;
}
function splitSignature(Ae) {
  const t = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(Ae)) {
    let Ie = arrayify(Ae);
    Ie.length === 64 ? (t.v = 27 + (Ie[32] >> 7), Ie[32] &= 127, t.r = hexlify(Ie.slice(0, 32)), t.s = hexlify(Ie.slice(32, 64))) : Ie.length === 65 ? (t.r = hexlify(Ie.slice(0, 32)), t.s = hexlify(Ie.slice(32, 64)), t.v = Ie[64]) : logger$3.throwArgumentError("invalid signature string", "signature", Ae), t.v < 27 && (t.v === 0 || t.v === 1 ? t.v += 27 : logger$3.throwArgumentError("signature invalid v byte", "signature", Ae)), t.recoveryParam = 1 - t.v % 2, t.recoveryParam && (Ie[32] |= 128), t._vs = hexlify(Ie.slice(32, 64));
  } else {
    if (t.r = Ae.r, t.s = Ae.s, t.v = Ae.v, t.recoveryParam = Ae.recoveryParam, t._vs = Ae._vs, t._vs != null) {
      const Pe = zeroPad(arrayify(t._vs), 32);
      t._vs = hexlify(Pe);
      const Te = Pe[0] >= 128 ? 1 : 0;
      t.recoveryParam == null ? t.recoveryParam = Te : t.recoveryParam !== Te && logger$3.throwArgumentError("signature recoveryParam mismatch _vs", "signature", Ae), Pe[0] &= 127;
      const Me = hexlify(Pe);
      t.s == null ? t.s = Me : t.s !== Me && logger$3.throwArgumentError("signature v mismatch _vs", "signature", Ae);
    }
    if (t.recoveryParam == null)
      t.v == null ? logger$3.throwArgumentError("signature missing v and recoveryParam", "signature", Ae) : t.v === 0 || t.v === 1 ? t.recoveryParam = t.v : t.recoveryParam = 1 - t.v % 2;
    else if (t.v == null)
      t.v = 27 + t.recoveryParam;
    else {
      const Pe = t.v === 0 || t.v === 1 ? t.v : 1 - t.v % 2;
      t.recoveryParam !== Pe && logger$3.throwArgumentError("signature recoveryParam mismatch v", "signature", Ae);
    }
    t.r == null || !isHexString(t.r) ? logger$3.throwArgumentError("signature missing or invalid r", "signature", Ae) : t.r = hexZeroPad(t.r, 32), t.s == null || !isHexString(t.s) ? logger$3.throwArgumentError("signature missing or invalid s", "signature", Ae) : t.s = hexZeroPad(t.s, 32);
    const Ie = arrayify(t.s);
    Ie[0] >= 128 && logger$3.throwArgumentError("signature s out of range", "signature", Ae), t.recoveryParam && (Ie[0] |= 128);
    const Be = hexlify(Ie);
    t._vs && (isHexString(t._vs) || logger$3.throwArgumentError("signature invalid _vs", "signature", Ae), t._vs = hexZeroPad(t._vs, 32)), t._vs == null ? t._vs = Be : t._vs !== Be && logger$3.throwArgumentError("signature _vs mismatch v and s", "signature", Ae);
  }
  return t.yParityAndS = t._vs, t.compact = t.r + t.yParityAndS.substring(2), t;
}
function keccak256(Ae) {
  return "0x" + sha3.keccak_256(arrayify(Ae));
}
var BN = BN$1.BN;
function _base36To16(Ae) {
  return new BN(Ae, 36).toString(16);
}
const version$2 = "strings/5.7.0", logger$2 = new Logger(version$2);
var UnicodeNormalizationForm;
(function(Ae) {
  Ae.current = "", Ae.NFC = "NFC", Ae.NFD = "NFD", Ae.NFKC = "NFKC", Ae.NFKD = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Ae) {
  Ae.UNEXPECTED_CONTINUE = "unexpected continuation byte", Ae.BAD_PREFIX = "bad codepoint prefix", Ae.OVERRUN = "string overrun", Ae.MISSING_CONTINUE = "missing continuation byte", Ae.OUT_OF_RANGE = "out of UTF-8 range", Ae.UTF16_SURROGATE = "UTF-16 surrogate", Ae.OVERLONG = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function toUtf8Bytes(Ae, t = UnicodeNormalizationForm.current) {
  t != UnicodeNormalizationForm.current && (logger$2.checkNormalize(), Ae = Ae.normalize(t));
  let Ie = [];
  for (let Be = 0; Be < Ae.length; Be++) {
    const Pe = Ae.charCodeAt(Be);
    if (Pe < 128)
      Ie.push(Pe);
    else if (Pe < 2048)
      Ie.push(Pe >> 6 | 192), Ie.push(Pe & 63 | 128);
    else if ((Pe & 64512) == 55296) {
      Be++;
      const Te = Ae.charCodeAt(Be);
      if (Be >= Ae.length || (Te & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const Me = 65536 + ((Pe & 1023) << 10) + (Te & 1023);
      Ie.push(Me >> 18 | 240), Ie.push(Me >> 12 & 63 | 128), Ie.push(Me >> 6 & 63 | 128), Ie.push(Me & 63 | 128);
    } else
      Ie.push(Pe >> 12 | 224), Ie.push(Pe >> 6 & 63 | 128), Ie.push(Pe & 63 | 128);
  }
  return arrayify(Ie);
}
const messagePrefix = `Ethereum Signed Message:
`;
function hashMessage(Ae) {
  return typeof Ae == "string" && (Ae = toUtf8Bytes(Ae)), keccak256(concat([
    toUtf8Bytes(messagePrefix),
    toUtf8Bytes(String(Ae.length)),
    Ae
  ]));
}
const version$1 = "address/5.7.0", logger$1 = new Logger(version$1);
function getChecksumAddress(Ae) {
  isHexString(Ae, 20) || logger$1.throwArgumentError("invalid address", "address", Ae), Ae = Ae.toLowerCase();
  const t = Ae.substring(2).split(""), Ie = new Uint8Array(40);
  for (let Pe = 0; Pe < 40; Pe++)
    Ie[Pe] = t[Pe].charCodeAt(0);
  const Be = arrayify(keccak256(Ie));
  for (let Pe = 0; Pe < 40; Pe += 2)
    Be[Pe >> 1] >> 4 >= 8 && (t[Pe] = t[Pe].toUpperCase()), (Be[Pe >> 1] & 15) >= 8 && (t[Pe + 1] = t[Pe + 1].toUpperCase());
  return "0x" + t.join("");
}
const MAX_SAFE_INTEGER = 9007199254740991;
function log10(Ae) {
  return Math.log10 ? Math.log10(Ae) : Math.log(Ae) / Math.LN10;
}
const ibanLookup = {};
for (let Ae = 0; Ae < 10; Ae++)
  ibanLookup[String(Ae)] = String(Ae);
for (let Ae = 0; Ae < 26; Ae++)
  ibanLookup[String.fromCharCode(65 + Ae)] = String(10 + Ae);
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(Ae) {
  Ae = Ae.toUpperCase(), Ae = Ae.substring(4) + Ae.substring(0, 2) + "00";
  let t = Ae.split("").map((Be) => ibanLookup[Be]).join("");
  for (; t.length >= safeDigits; ) {
    let Be = t.substring(0, safeDigits);
    t = parseInt(Be, 10) % 97 + t.substring(Be.length);
  }
  let Ie = String(98 - parseInt(t, 10) % 97);
  for (; Ie.length < 2; )
    Ie = "0" + Ie;
  return Ie;
}
function getAddress(Ae) {
  let t = null;
  if (typeof Ae != "string" && logger$1.throwArgumentError("invalid address", "address", Ae), Ae.match(/^(0x)?[0-9a-fA-F]{40}$/))
    Ae.substring(0, 2) !== "0x" && (Ae = "0x" + Ae), t = getChecksumAddress(Ae), Ae.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && t !== Ae && logger$1.throwArgumentError("bad address checksum", "address", Ae);
  else if (Ae.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (Ae.substring(2, 4) !== ibanChecksum(Ae) && logger$1.throwArgumentError("bad icap checksum", "address", Ae), t = _base36To16(Ae.substring(4)); t.length < 40; )
      t = "0" + t;
    t = getChecksumAddress("0x" + t);
  } else
    logger$1.throwArgumentError("invalid address", "address", Ae);
  return t;
}
function defineReadOnly(Ae, t, Ie) {
  Object.defineProperty(Ae, t, {
    enumerable: !0,
    value: Ie,
    writable: !1
  });
}
function createCommonjsModule(Ae, t, Ie) {
  return Ie = {
    path: t,
    exports: {},
    require: function(Be, Pe) {
      return commonjsRequire(Be, Pe ?? Ie.path);
    }
  }, Ae(Ie, Ie.exports), Ie.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert;
function assert(Ae, t) {
  if (!Ae)
    throw new Error(t || "Assertion failed");
}
assert.equal = function Ae(t, Ie, Be) {
  if (t != Ie)
    throw new Error(Be || "Assertion failed: " + t + " != " + Ie);
};
var utils_1 = createCommonjsModule(function(Ae, t) {
  var Ie = t;
  function Be(Me, Ue) {
    if (Array.isArray(Me))
      return Me.slice();
    if (!Me)
      return [];
    var je = [];
    if (typeof Me != "string") {
      for (var fn = 0; fn < Me.length; fn++)
        je[fn] = Me[fn] | 0;
      return je;
    }
    if (Ue === "hex") {
      Me = Me.replace(/[^a-z0-9]+/ig, ""), Me.length % 2 !== 0 && (Me = "0" + Me);
      for (var fn = 0; fn < Me.length; fn += 2)
        je.push(parseInt(Me[fn] + Me[fn + 1], 16));
    } else
      for (var fn = 0; fn < Me.length; fn++) {
        var Ve = Me.charCodeAt(fn), vn = Ve >> 8, En = Ve & 255;
        vn ? je.push(vn, En) : je.push(En);
      }
    return je;
  }
  Ie.toArray = Be;
  function Pe(Me) {
    return Me.length === 1 ? "0" + Me : Me;
  }
  Ie.zero2 = Pe;
  function Te(Me) {
    for (var Ue = "", je = 0; je < Me.length; je++)
      Ue += Pe(Me[je].toString(16));
    return Ue;
  }
  Ie.toHex = Te, Ie.encode = function(Ue, je) {
    return je === "hex" ? Te(Ue) : Ue;
  };
}), utils_1$1 = createCommonjsModule(function(Ae, t) {
  var Ie = t;
  Ie.assert = minimalisticAssert, Ie.toArray = utils_1.toArray, Ie.zero2 = utils_1.zero2, Ie.toHex = utils_1.toHex, Ie.encode = utils_1.encode;
  function Be(je, fn, Ve) {
    var vn = new Array(Math.max(je.bitLength(), Ve) + 1);
    vn.fill(0);
    for (var En = 1 << fn + 1, fi = je.clone(), bi = 0; bi < vn.length; bi++) {
      var mi, _i = fi.andln(En - 1);
      fi.isOdd() ? (_i > (En >> 1) - 1 ? mi = (En >> 1) - _i : mi = _i, fi.isubn(mi)) : mi = 0, vn[bi] = mi, fi.iushrn(1);
    }
    return vn;
  }
  Ie.getNAF = Be;
  function Pe(je, fn) {
    var Ve = [
      [],
      []
    ];
    je = je.clone(), fn = fn.clone();
    for (var vn = 0, En = 0, fi; je.cmpn(-vn) > 0 || fn.cmpn(-En) > 0; ) {
      var bi = je.andln(3) + vn & 3, mi = fn.andln(3) + En & 3;
      bi === 3 && (bi = -1), mi === 3 && (mi = -1);
      var _i;
      bi & 1 ? (fi = je.andln(7) + vn & 7, (fi === 3 || fi === 5) && mi === 2 ? _i = -bi : _i = bi) : _i = 0, Ve[0].push(_i);
      var Ei;
      mi & 1 ? (fi = fn.andln(7) + En & 7, (fi === 3 || fi === 5) && bi === 2 ? Ei = -mi : Ei = mi) : Ei = 0, Ve[1].push(Ei), 2 * vn === _i + 1 && (vn = 1 - vn), 2 * En === Ei + 1 && (En = 1 - En), je.iushrn(1), fn.iushrn(1);
    }
    return Ve;
  }
  Ie.getJSF = Pe;
  function Te(je, fn, Ve) {
    var vn = "_" + fn;
    je.prototype[fn] = function() {
      return this[vn] !== void 0 ? this[vn] : this[vn] = Ve.call(this);
    };
  }
  Ie.cachedProperty = Te;
  function Me(je) {
    return typeof je == "string" ? Ie.toArray(je, "hex") : je;
  }
  Ie.parseBytes = Me;
  function Ue(je) {
    return new BN$1(je, "hex", "le");
  }
  Ie.intFromLE = Ue;
}), getNAF = utils_1$1.getNAF, getJSF = utils_1$1.getJSF, assert$1 = utils_1$1.assert;
function BaseCurve(Ae, t) {
  this.type = Ae, this.p = new BN$1(t.p, 16), this.red = t.prime ? BN$1.red(t.prime) : BN$1.mont(this.p), this.zero = new BN$1(0).toRed(this.red), this.one = new BN$1(1).toRed(this.red), this.two = new BN$1(2).toRed(this.red), this.n = t.n && new BN$1(t.n, 16), this.g = t.g && this.pointFromJSON(t.g, t.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var Ie = this.n && this.p.div(this.n);
  !Ie || Ie.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base = BaseCurve;
BaseCurve.prototype.point = function Ae() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function Ae() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function Ae(t, Ie) {
  assert$1(t.precomputed);
  var Be = t._getDoubles(), Pe = getNAF(Ie, 1, this._bitLength), Te = (1 << Be.step + 1) - (Be.step % 2 === 0 ? 2 : 1);
  Te /= 3;
  var Me = [], Ue, je;
  for (Ue = 0; Ue < Pe.length; Ue += Be.step) {
    je = 0;
    for (var fn = Ue + Be.step - 1; fn >= Ue; fn--)
      je = (je << 1) + Pe[fn];
    Me.push(je);
  }
  for (var Ve = this.jpoint(null, null, null), vn = this.jpoint(null, null, null), En = Te; En > 0; En--) {
    for (Ue = 0; Ue < Me.length; Ue++)
      je = Me[Ue], je === En ? vn = vn.mixedAdd(Be.points[Ue]) : je === -En && (vn = vn.mixedAdd(Be.points[Ue].neg()));
    Ve = Ve.add(vn);
  }
  return Ve.toP();
};
BaseCurve.prototype._wnafMul = function Ae(t, Ie) {
  var Be = 4, Pe = t._getNAFPoints(Be);
  Be = Pe.wnd;
  for (var Te = Pe.points, Me = getNAF(Ie, Be, this._bitLength), Ue = this.jpoint(null, null, null), je = Me.length - 1; je >= 0; je--) {
    for (var fn = 0; je >= 0 && Me[je] === 0; je--)
      fn++;
    if (je >= 0 && fn++, Ue = Ue.dblp(fn), je < 0)
      break;
    var Ve = Me[je];
    assert$1(Ve !== 0), t.type === "affine" ? Ve > 0 ? Ue = Ue.mixedAdd(Te[Ve - 1 >> 1]) : Ue = Ue.mixedAdd(Te[-Ve - 1 >> 1].neg()) : Ve > 0 ? Ue = Ue.add(Te[Ve - 1 >> 1]) : Ue = Ue.add(Te[-Ve - 1 >> 1].neg());
  }
  return t.type === "affine" ? Ue.toP() : Ue;
};
BaseCurve.prototype._wnafMulAdd = function Ae(t, Ie, Be, Pe, Te) {
  var Me = this._wnafT1, Ue = this._wnafT2, je = this._wnafT3, fn = 0, Ve, vn, En;
  for (Ve = 0; Ve < Pe; Ve++) {
    En = Ie[Ve];
    var fi = En._getNAFPoints(t);
    Me[Ve] = fi.wnd, Ue[Ve] = fi.points;
  }
  for (Ve = Pe - 1; Ve >= 1; Ve -= 2) {
    var bi = Ve - 1, mi = Ve;
    if (Me[bi] !== 1 || Me[mi] !== 1) {
      je[bi] = getNAF(Be[bi], Me[bi], this._bitLength), je[mi] = getNAF(Be[mi], Me[mi], this._bitLength), fn = Math.max(je[bi].length, fn), fn = Math.max(je[mi].length, fn);
      continue;
    }
    var _i = [
      Ie[bi],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      Ie[mi]
      /* 7 */
    ];
    Ie[bi].y.cmp(Ie[mi].y) === 0 ? (_i[1] = Ie[bi].add(Ie[mi]), _i[2] = Ie[bi].toJ().mixedAdd(Ie[mi].neg())) : Ie[bi].y.cmp(Ie[mi].y.redNeg()) === 0 ? (_i[1] = Ie[bi].toJ().mixedAdd(Ie[mi]), _i[2] = Ie[bi].add(Ie[mi].neg())) : (_i[1] = Ie[bi].toJ().mixedAdd(Ie[mi]), _i[2] = Ie[bi].toJ().mixedAdd(Ie[mi].neg()));
    var Ei = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], Si = getJSF(Be[bi], Be[mi]);
    for (fn = Math.max(Si[0].length, fn), je[bi] = new Array(fn), je[mi] = new Array(fn), vn = 0; vn < fn; vn++) {
      var Mi = Si[0][vn] | 0, Oi = Si[1][vn] | 0;
      je[bi][vn] = Ei[(Mi + 1) * 3 + (Oi + 1)], je[mi][vn] = 0, Ue[bi] = _i;
    }
  }
  var Fi = this.jpoint(null, null, null), Ui = this._wnafT4;
  for (Ve = fn; Ve >= 0; Ve--) {
    for (var Pi = 0; Ve >= 0; ) {
      var Bi = !0;
      for (vn = 0; vn < Pe; vn++)
        Ui[vn] = je[vn][Ve] | 0, Ui[vn] !== 0 && (Bi = !1);
      if (!Bi)
        break;
      Pi++, Ve--;
    }
    if (Ve >= 0 && Pi++, Fi = Fi.dblp(Pi), Ve < 0)
      break;
    for (vn = 0; vn < Pe; vn++) {
      var ji = Ui[vn];
      ji !== 0 && (ji > 0 ? En = Ue[vn][ji - 1 >> 1] : ji < 0 && (En = Ue[vn][-ji - 1 >> 1].neg()), En.type === "affine" ? Fi = Fi.mixedAdd(En) : Fi = Fi.add(En));
    }
  }
  for (Ve = 0; Ve < Pe; Ve++)
    Ue[Ve] = null;
  return Te ? Fi : Fi.toP();
};
function BasePoint(Ae, t) {
  this.curve = Ae, this.type = t, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function Ae() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function Ae() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function Ae(t, Ie) {
  t = utils_1$1.toArray(t, Ie);
  var Be = this.p.byteLength();
  if ((t[0] === 4 || t[0] === 6 || t[0] === 7) && t.length - 1 === 2 * Be) {
    t[0] === 6 ? assert$1(t[t.length - 1] % 2 === 0) : t[0] === 7 && assert$1(t[t.length - 1] % 2 === 1);
    var Pe = this.point(
      t.slice(1, 1 + Be),
      t.slice(1 + Be, 1 + 2 * Be)
    );
    return Pe;
  } else if ((t[0] === 2 || t[0] === 3) && t.length - 1 === Be)
    return this.pointFromX(t.slice(1, 1 + Be), t[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function Ae(t) {
  return this.encode(t, !0);
};
BasePoint.prototype._encode = function Ae(t) {
  var Ie = this.curve.p.byteLength(), Be = this.getX().toArray("be", Ie);
  return t ? [this.getY().isEven() ? 2 : 3].concat(Be) : [4].concat(Be, this.getY().toArray("be", Ie));
};
BasePoint.prototype.encode = function Ae(t, Ie) {
  return utils_1$1.encode(this._encode(Ie), t);
};
BasePoint.prototype.precompute = function Ae(t) {
  if (this.precomputed)
    return this;
  var Ie = {
    doubles: null,
    naf: null,
    beta: null
  };
  return Ie.naf = this._getNAFPoints(8), Ie.doubles = this._getDoubles(4, t), Ie.beta = this._getBeta(), this.precomputed = Ie, this;
};
BasePoint.prototype._hasDoubles = function Ae(t) {
  if (!this.precomputed)
    return !1;
  var Ie = this.precomputed.doubles;
  return Ie ? Ie.points.length >= Math.ceil((t.bitLength() + 1) / Ie.step) : !1;
};
BasePoint.prototype._getDoubles = function Ae(t, Ie) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var Be = [this], Pe = this, Te = 0; Te < Ie; Te += t) {
    for (var Me = 0; Me < t; Me++)
      Pe = Pe.dbl();
    Be.push(Pe);
  }
  return {
    step: t,
    points: Be
  };
};
BasePoint.prototype._getNAFPoints = function Ae(t) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var Ie = [this], Be = (1 << t) - 1, Pe = Be === 1 ? null : this.dbl(), Te = 1; Te < Be; Te++)
    Ie[Te] = Ie[Te - 1].add(Pe);
  return {
    wnd: t,
    points: Ie
  };
};
BasePoint.prototype._getBeta = function Ae() {
  return null;
};
BasePoint.prototype.dblp = function Ae(t) {
  for (var Ie = this, Be = 0; Be < t; Be++)
    Ie = Ie.dbl();
  return Ie;
};
var inherits_browser = createCommonjsModule(function(Ae) {
  typeof Object.create == "function" ? Ae.exports = function(Ie, Be) {
    Be && (Ie.super_ = Be, Ie.prototype = Object.create(Be.prototype, {
      constructor: {
        value: Ie,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : Ae.exports = function(Ie, Be) {
    if (Be) {
      Ie.super_ = Be;
      var Pe = function() {
      };
      Pe.prototype = Be.prototype, Ie.prototype = new Pe(), Ie.prototype.constructor = Ie;
    }
  };
}), assert$2 = utils_1$1.assert;
function ShortCurve(Ae) {
  base.call(this, "short", Ae), this.a = new BN$1(Ae.a, 16).toRed(this.red), this.b = new BN$1(Ae.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(Ae), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function Ae(t) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var Ie, Be;
    if (t.beta)
      Ie = new BN$1(t.beta, 16).toRed(this.red);
    else {
      var Pe = this._getEndoRoots(this.p);
      Ie = Pe[0].cmp(Pe[1]) < 0 ? Pe[0] : Pe[1], Ie = Ie.toRed(this.red);
    }
    if (t.lambda)
      Be = new BN$1(t.lambda, 16);
    else {
      var Te = this._getEndoRoots(this.n);
      this.g.mul(Te[0]).x.cmp(this.g.x.redMul(Ie)) === 0 ? Be = Te[0] : (Be = Te[1], assert$2(this.g.mul(Be).x.cmp(this.g.x.redMul(Ie)) === 0));
    }
    var Me;
    return t.basis ? Me = t.basis.map(function(Ue) {
      return {
        a: new BN$1(Ue.a, 16),
        b: new BN$1(Ue.b, 16)
      };
    }) : Me = this._getEndoBasis(Be), {
      beta: Ie,
      lambda: Be,
      basis: Me
    };
  }
};
ShortCurve.prototype._getEndoRoots = function Ae(t) {
  var Ie = t === this.p ? this.red : BN$1.mont(t), Be = new BN$1(2).toRed(Ie).redInvm(), Pe = Be.redNeg(), Te = new BN$1(3).toRed(Ie).redNeg().redSqrt().redMul(Be), Me = Pe.redAdd(Te).fromRed(), Ue = Pe.redSub(Te).fromRed();
  return [Me, Ue];
};
ShortCurve.prototype._getEndoBasis = function Ae(t) {
  for (var Ie = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), Be = t, Pe = this.n.clone(), Te = new BN$1(1), Me = new BN$1(0), Ue = new BN$1(0), je = new BN$1(1), fn, Ve, vn, En, fi, bi, mi, _i = 0, Ei, Si; Be.cmpn(0) !== 0; ) {
    var Mi = Pe.div(Be);
    Ei = Pe.sub(Mi.mul(Be)), Si = Ue.sub(Mi.mul(Te));
    var Oi = je.sub(Mi.mul(Me));
    if (!vn && Ei.cmp(Ie) < 0)
      fn = mi.neg(), Ve = Te, vn = Ei.neg(), En = Si;
    else if (vn && ++_i === 2)
      break;
    mi = Ei, Pe = Be, Be = Ei, Ue = Te, Te = Si, je = Me, Me = Oi;
  }
  fi = Ei.neg(), bi = Si;
  var Fi = vn.sqr().add(En.sqr()), Ui = fi.sqr().add(bi.sqr());
  return Ui.cmp(Fi) >= 0 && (fi = fn, bi = Ve), vn.negative && (vn = vn.neg(), En = En.neg()), fi.negative && (fi = fi.neg(), bi = bi.neg()), [
    { a: vn, b: En },
    { a: fi, b: bi }
  ];
};
ShortCurve.prototype._endoSplit = function Ae(t) {
  var Ie = this.endo.basis, Be = Ie[0], Pe = Ie[1], Te = Pe.b.mul(t).divRound(this.n), Me = Be.b.neg().mul(t).divRound(this.n), Ue = Te.mul(Be.a), je = Me.mul(Pe.a), fn = Te.mul(Be.b), Ve = Me.mul(Pe.b), vn = t.sub(Ue).sub(je), En = fn.add(Ve).neg();
  return { k1: vn, k2: En };
};
ShortCurve.prototype.pointFromX = function Ae(t, Ie) {
  t = new BN$1(t, 16), t.red || (t = t.toRed(this.red));
  var Be = t.redSqr().redMul(t).redIAdd(t.redMul(this.a)).redIAdd(this.b), Pe = Be.redSqrt();
  if (Pe.redSqr().redSub(Be).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var Te = Pe.fromRed().isOdd();
  return (Ie && !Te || !Ie && Te) && (Pe = Pe.redNeg()), this.point(t, Pe);
};
ShortCurve.prototype.validate = function Ae(t) {
  if (t.inf)
    return !0;
  var Ie = t.x, Be = t.y, Pe = this.a.redMul(Ie), Te = Ie.redSqr().redMul(Ie).redIAdd(Pe).redIAdd(this.b);
  return Be.redSqr().redISub(Te).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function Ae(t, Ie, Be) {
  for (var Pe = this._endoWnafT1, Te = this._endoWnafT2, Me = 0; Me < t.length; Me++) {
    var Ue = this._endoSplit(Ie[Me]), je = t[Me], fn = je._getBeta();
    Ue.k1.negative && (Ue.k1.ineg(), je = je.neg(!0)), Ue.k2.negative && (Ue.k2.ineg(), fn = fn.neg(!0)), Pe[Me * 2] = je, Pe[Me * 2 + 1] = fn, Te[Me * 2] = Ue.k1, Te[Me * 2 + 1] = Ue.k2;
  }
  for (var Ve = this._wnafMulAdd(1, Pe, Te, Me * 2, Be), vn = 0; vn < Me * 2; vn++)
    Pe[vn] = null, Te[vn] = null;
  return Ve;
};
function Point(Ae, t, Ie, Be) {
  base.BasePoint.call(this, Ae, "affine"), t === null && Ie === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$1(t, 16), this.y = new BN$1(Ie, 16), Be && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits_browser(Point, base.BasePoint);
ShortCurve.prototype.point = function Ae(t, Ie, Be) {
  return new Point(this, t, Ie, Be);
};
ShortCurve.prototype.pointFromJSON = function Ae(t, Ie) {
  return Point.fromJSON(this, t, Ie);
};
Point.prototype._getBeta = function Ae() {
  if (this.curve.endo) {
    var t = this.precomputed;
    if (t && t.beta)
      return t.beta;
    var Ie = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (t) {
      var Be = this.curve, Pe = function(Te) {
        return Be.point(Te.x.redMul(Be.endo.beta), Te.y);
      };
      t.beta = Ie, Ie.precomputed = {
        beta: null,
        naf: t.naf && {
          wnd: t.naf.wnd,
          points: t.naf.points.map(Pe)
        },
        doubles: t.doubles && {
          step: t.doubles.step,
          points: t.doubles.points.map(Pe)
        }
      };
    }
    return Ie;
  }
};
Point.prototype.toJSON = function Ae() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point.fromJSON = function Ae(t, Ie, Be) {
  typeof Ie == "string" && (Ie = JSON.parse(Ie));
  var Pe = t.point(Ie[0], Ie[1], Be);
  if (!Ie[2])
    return Pe;
  function Te(Ue) {
    return t.point(Ue[0], Ue[1], Be);
  }
  var Me = Ie[2];
  return Pe.precomputed = {
    beta: null,
    doubles: Me.doubles && {
      step: Me.doubles.step,
      points: [Pe].concat(Me.doubles.points.map(Te))
    },
    naf: Me.naf && {
      wnd: Me.naf.wnd,
      points: [Pe].concat(Me.naf.points.map(Te))
    }
  }, Pe;
};
Point.prototype.inspect = function Ae() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function Ae() {
  return this.inf;
};
Point.prototype.add = function Ae(t) {
  if (this.inf)
    return t;
  if (t.inf)
    return this;
  if (this.eq(t))
    return this.dbl();
  if (this.neg().eq(t))
    return this.curve.point(null, null);
  if (this.x.cmp(t.x) === 0)
    return this.curve.point(null, null);
  var Ie = this.y.redSub(t.y);
  Ie.cmpn(0) !== 0 && (Ie = Ie.redMul(this.x.redSub(t.x).redInvm()));
  var Be = Ie.redSqr().redISub(this.x).redISub(t.x), Pe = Ie.redMul(this.x.redSub(Be)).redISub(this.y);
  return this.curve.point(Be, Pe);
};
Point.prototype.dbl = function Ae() {
  if (this.inf)
    return this;
  var t = this.y.redAdd(this.y);
  if (t.cmpn(0) === 0)
    return this.curve.point(null, null);
  var Ie = this.curve.a, Be = this.x.redSqr(), Pe = t.redInvm(), Te = Be.redAdd(Be).redIAdd(Be).redIAdd(Ie).redMul(Pe), Me = Te.redSqr().redISub(this.x.redAdd(this.x)), Ue = Te.redMul(this.x.redSub(Me)).redISub(this.y);
  return this.curve.point(Me, Ue);
};
Point.prototype.getX = function Ae() {
  return this.x.fromRed();
};
Point.prototype.getY = function Ae() {
  return this.y.fromRed();
};
Point.prototype.mul = function Ae(t) {
  return t = new BN$1(t, 16), this.isInfinity() ? this : this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [t]) : this.curve._wnafMul(this, t);
};
Point.prototype.mulAdd = function Ae(t, Ie, Be) {
  var Pe = [this, Ie], Te = [t, Be];
  return this.curve.endo ? this.curve._endoWnafMulAdd(Pe, Te) : this.curve._wnafMulAdd(1, Pe, Te, 2);
};
Point.prototype.jmulAdd = function Ae(t, Ie, Be) {
  var Pe = [this, Ie], Te = [t, Be];
  return this.curve.endo ? this.curve._endoWnafMulAdd(Pe, Te, !0) : this.curve._wnafMulAdd(1, Pe, Te, 2, !0);
};
Point.prototype.eq = function Ae(t) {
  return this === t || this.inf === t.inf && (this.inf || this.x.cmp(t.x) === 0 && this.y.cmp(t.y) === 0);
};
Point.prototype.neg = function Ae(t) {
  if (this.inf)
    return this;
  var Ie = this.curve.point(this.x, this.y.redNeg());
  if (t && this.precomputed) {
    var Be = this.precomputed, Pe = function(Te) {
      return Te.neg();
    };
    Ie.precomputed = {
      naf: Be.naf && {
        wnd: Be.naf.wnd,
        points: Be.naf.points.map(Pe)
      },
      doubles: Be.doubles && {
        step: Be.doubles.step,
        points: Be.doubles.points.map(Pe)
      }
    };
  }
  return Ie;
};
Point.prototype.toJ = function Ae() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var t = this.curve.jpoint(this.x, this.y, this.curve.one);
  return t;
};
function JPoint(Ae, t, Ie, Be) {
  base.BasePoint.call(this, Ae, "jacobian"), t === null && Ie === null && Be === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$1(0)) : (this.x = new BN$1(t, 16), this.y = new BN$1(Ie, 16), this.z = new BN$1(Be, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base.BasePoint);
ShortCurve.prototype.jpoint = function Ae(t, Ie, Be) {
  return new JPoint(this, t, Ie, Be);
};
JPoint.prototype.toP = function Ae() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var t = this.z.redInvm(), Ie = t.redSqr(), Be = this.x.redMul(Ie), Pe = this.y.redMul(Ie).redMul(t);
  return this.curve.point(Be, Pe);
};
JPoint.prototype.neg = function Ae() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function Ae(t) {
  if (this.isInfinity())
    return t;
  if (t.isInfinity())
    return this;
  var Ie = t.z.redSqr(), Be = this.z.redSqr(), Pe = this.x.redMul(Ie), Te = t.x.redMul(Be), Me = this.y.redMul(Ie.redMul(t.z)), Ue = t.y.redMul(Be.redMul(this.z)), je = Pe.redSub(Te), fn = Me.redSub(Ue);
  if (je.cmpn(0) === 0)
    return fn.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var Ve = je.redSqr(), vn = Ve.redMul(je), En = Pe.redMul(Ve), fi = fn.redSqr().redIAdd(vn).redISub(En).redISub(En), bi = fn.redMul(En.redISub(fi)).redISub(Me.redMul(vn)), mi = this.z.redMul(t.z).redMul(je);
  return this.curve.jpoint(fi, bi, mi);
};
JPoint.prototype.mixedAdd = function Ae(t) {
  if (this.isInfinity())
    return t.toJ();
  if (t.isInfinity())
    return this;
  var Ie = this.z.redSqr(), Be = this.x, Pe = t.x.redMul(Ie), Te = this.y, Me = t.y.redMul(Ie).redMul(this.z), Ue = Be.redSub(Pe), je = Te.redSub(Me);
  if (Ue.cmpn(0) === 0)
    return je.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var fn = Ue.redSqr(), Ve = fn.redMul(Ue), vn = Be.redMul(fn), En = je.redSqr().redIAdd(Ve).redISub(vn).redISub(vn), fi = je.redMul(vn.redISub(En)).redISub(Te.redMul(Ve)), bi = this.z.redMul(Ue);
  return this.curve.jpoint(En, fi, bi);
};
JPoint.prototype.dblp = function Ae(t) {
  if (t === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!t)
    return this.dbl();
  var Ie;
  if (this.curve.zeroA || this.curve.threeA) {
    var Be = this;
    for (Ie = 0; Ie < t; Ie++)
      Be = Be.dbl();
    return Be;
  }
  var Pe = this.curve.a, Te = this.curve.tinv, Me = this.x, Ue = this.y, je = this.z, fn = je.redSqr().redSqr(), Ve = Ue.redAdd(Ue);
  for (Ie = 0; Ie < t; Ie++) {
    var vn = Me.redSqr(), En = Ve.redSqr(), fi = En.redSqr(), bi = vn.redAdd(vn).redIAdd(vn).redIAdd(Pe.redMul(fn)), mi = Me.redMul(En), _i = bi.redSqr().redISub(mi.redAdd(mi)), Ei = mi.redISub(_i), Si = bi.redMul(Ei);
    Si = Si.redIAdd(Si).redISub(fi);
    var Mi = Ve.redMul(je);
    Ie + 1 < t && (fn = fn.redMul(fi)), Me = _i, je = Mi, Ve = Si;
  }
  return this.curve.jpoint(Me, Ve.redMul(Te), je);
};
JPoint.prototype.dbl = function Ae() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function Ae() {
  var t, Ie, Be;
  if (this.zOne) {
    var Pe = this.x.redSqr(), Te = this.y.redSqr(), Me = Te.redSqr(), Ue = this.x.redAdd(Te).redSqr().redISub(Pe).redISub(Me);
    Ue = Ue.redIAdd(Ue);
    var je = Pe.redAdd(Pe).redIAdd(Pe), fn = je.redSqr().redISub(Ue).redISub(Ue), Ve = Me.redIAdd(Me);
    Ve = Ve.redIAdd(Ve), Ve = Ve.redIAdd(Ve), t = fn, Ie = je.redMul(Ue.redISub(fn)).redISub(Ve), Be = this.y.redAdd(this.y);
  } else {
    var vn = this.x.redSqr(), En = this.y.redSqr(), fi = En.redSqr(), bi = this.x.redAdd(En).redSqr().redISub(vn).redISub(fi);
    bi = bi.redIAdd(bi);
    var mi = vn.redAdd(vn).redIAdd(vn), _i = mi.redSqr(), Ei = fi.redIAdd(fi);
    Ei = Ei.redIAdd(Ei), Ei = Ei.redIAdd(Ei), t = _i.redISub(bi).redISub(bi), Ie = mi.redMul(bi.redISub(t)).redISub(Ei), Be = this.y.redMul(this.z), Be = Be.redIAdd(Be);
  }
  return this.curve.jpoint(t, Ie, Be);
};
JPoint.prototype._threeDbl = function Ae() {
  var t, Ie, Be;
  if (this.zOne) {
    var Pe = this.x.redSqr(), Te = this.y.redSqr(), Me = Te.redSqr(), Ue = this.x.redAdd(Te).redSqr().redISub(Pe).redISub(Me);
    Ue = Ue.redIAdd(Ue);
    var je = Pe.redAdd(Pe).redIAdd(Pe).redIAdd(this.curve.a), fn = je.redSqr().redISub(Ue).redISub(Ue);
    t = fn;
    var Ve = Me.redIAdd(Me);
    Ve = Ve.redIAdd(Ve), Ve = Ve.redIAdd(Ve), Ie = je.redMul(Ue.redISub(fn)).redISub(Ve), Be = this.y.redAdd(this.y);
  } else {
    var vn = this.z.redSqr(), En = this.y.redSqr(), fi = this.x.redMul(En), bi = this.x.redSub(vn).redMul(this.x.redAdd(vn));
    bi = bi.redAdd(bi).redIAdd(bi);
    var mi = fi.redIAdd(fi);
    mi = mi.redIAdd(mi);
    var _i = mi.redAdd(mi);
    t = bi.redSqr().redISub(_i), Be = this.y.redAdd(this.z).redSqr().redISub(En).redISub(vn);
    var Ei = En.redSqr();
    Ei = Ei.redIAdd(Ei), Ei = Ei.redIAdd(Ei), Ei = Ei.redIAdd(Ei), Ie = bi.redMul(mi.redISub(t)).redISub(Ei);
  }
  return this.curve.jpoint(t, Ie, Be);
};
JPoint.prototype._dbl = function Ae() {
  var t = this.curve.a, Ie = this.x, Be = this.y, Pe = this.z, Te = Pe.redSqr().redSqr(), Me = Ie.redSqr(), Ue = Be.redSqr(), je = Me.redAdd(Me).redIAdd(Me).redIAdd(t.redMul(Te)), fn = Ie.redAdd(Ie);
  fn = fn.redIAdd(fn);
  var Ve = fn.redMul(Ue), vn = je.redSqr().redISub(Ve.redAdd(Ve)), En = Ve.redISub(vn), fi = Ue.redSqr();
  fi = fi.redIAdd(fi), fi = fi.redIAdd(fi), fi = fi.redIAdd(fi);
  var bi = je.redMul(En).redISub(fi), mi = Be.redAdd(Be).redMul(Pe);
  return this.curve.jpoint(vn, bi, mi);
};
JPoint.prototype.trpl = function Ae() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var t = this.x.redSqr(), Ie = this.y.redSqr(), Be = this.z.redSqr(), Pe = Ie.redSqr(), Te = t.redAdd(t).redIAdd(t), Me = Te.redSqr(), Ue = this.x.redAdd(Ie).redSqr().redISub(t).redISub(Pe);
  Ue = Ue.redIAdd(Ue), Ue = Ue.redAdd(Ue).redIAdd(Ue), Ue = Ue.redISub(Me);
  var je = Ue.redSqr(), fn = Pe.redIAdd(Pe);
  fn = fn.redIAdd(fn), fn = fn.redIAdd(fn), fn = fn.redIAdd(fn);
  var Ve = Te.redIAdd(Ue).redSqr().redISub(Me).redISub(je).redISub(fn), vn = Ie.redMul(Ve);
  vn = vn.redIAdd(vn), vn = vn.redIAdd(vn);
  var En = this.x.redMul(je).redISub(vn);
  En = En.redIAdd(En), En = En.redIAdd(En);
  var fi = this.y.redMul(Ve.redMul(fn.redISub(Ve)).redISub(Ue.redMul(je)));
  fi = fi.redIAdd(fi), fi = fi.redIAdd(fi), fi = fi.redIAdd(fi);
  var bi = this.z.redAdd(Ue).redSqr().redISub(Be).redISub(je);
  return this.curve.jpoint(En, fi, bi);
};
JPoint.prototype.mul = function Ae(t, Ie) {
  return t = new BN$1(t, Ie), this.curve._wnafMul(this, t);
};
JPoint.prototype.eq = function Ae(t) {
  if (t.type === "affine")
    return this.eq(t.toJ());
  if (this === t)
    return !0;
  var Ie = this.z.redSqr(), Be = t.z.redSqr();
  if (this.x.redMul(Be).redISub(t.x.redMul(Ie)).cmpn(0) !== 0)
    return !1;
  var Pe = Ie.redMul(this.z), Te = Be.redMul(t.z);
  return this.y.redMul(Te).redISub(t.y.redMul(Pe)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function Ae(t) {
  var Ie = this.z.redSqr(), Be = t.toRed(this.curve.red).redMul(Ie);
  if (this.x.cmp(Be) === 0)
    return !0;
  for (var Pe = t.clone(), Te = this.curve.redN.redMul(Ie); ; ) {
    if (Pe.iadd(this.curve.n), Pe.cmp(this.curve.p) >= 0)
      return !1;
    if (Be.redIAdd(Te), this.x.cmp(Be) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function Ae() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function Ae() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(Ae, t) {
  var Ie = t;
  Ie.base = base, Ie.short = short_1, Ie.mont = /*RicMoo:ethers:require(./mont)*/
  null, Ie.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
}), curves_1 = createCommonjsModule(function(Ae, t) {
  var Ie = t, Be = utils_1$1.assert;
  function Pe(Ue) {
    Ue.type === "short" ? this.curve = new curve_1.short(Ue) : Ue.type === "edwards" ? this.curve = new curve_1.edwards(Ue) : this.curve = new curve_1.mont(Ue), this.g = this.curve.g, this.n = this.curve.n, this.hash = Ue.hash, Be(this.g.validate(), "Invalid curve"), Be(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  Ie.PresetCurve = Pe;
  function Te(Ue, je) {
    Object.defineProperty(Ie, Ue, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var fn = new Pe(je);
        return Object.defineProperty(Ie, Ue, {
          configurable: !0,
          enumerable: !0,
          value: fn
        }), fn;
      }
    });
  }
  Te("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash$5.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), Te("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash$5.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), Te("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash$5.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), Te("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash$5.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), Te("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash$5.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), Te("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$5.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), Te("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$5.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var Me;
  try {
    Me = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch {
    Me = void 0;
  }
  Te("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash$5.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      Me
    ]
  });
});
function HmacDRBG(Ae) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(Ae);
  this.hash = Ae.hash, this.predResist = !!Ae.predResist, this.outLen = this.hash.outSize, this.minEntropy = Ae.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var t = utils_1.toArray(Ae.entropy, Ae.entropyEnc || "hex"), Ie = utils_1.toArray(Ae.nonce, Ae.nonceEnc || "hex"), Be = utils_1.toArray(Ae.pers, Ae.persEnc || "hex");
  minimalisticAssert(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(t, Ie, Be);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function Ae(t, Ie, Be) {
  var Pe = t.concat(Ie).concat(Be);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var Te = 0; Te < this.V.length; Te++)
    this.K[Te] = 0, this.V[Te] = 1;
  this._update(Pe), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function Ae() {
  return new hash$5.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function Ae(t) {
  var Ie = this._hmac().update(this.V).update([0]);
  t && (Ie = Ie.update(t)), this.K = Ie.digest(), this.V = this._hmac().update(this.V).digest(), t && (this.K = this._hmac().update(this.V).update([1]).update(t).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG.prototype.reseed = function Ae(t, Ie, Be, Pe) {
  typeof Ie != "string" && (Pe = Be, Be = Ie, Ie = null), t = utils_1.toArray(t, Ie), Be = utils_1.toArray(Be, Pe), minimalisticAssert(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(t.concat(Be || [])), this._reseed = 1;
};
HmacDRBG.prototype.generate = function Ae(t, Ie, Be, Pe) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof Ie != "string" && (Pe = Be, Be = Ie, Ie = null), Be && (Be = utils_1.toArray(Be, Pe || "hex"), this._update(Be));
  for (var Te = []; Te.length < t; )
    this.V = this._hmac().update(this.V).digest(), Te = Te.concat(this.V);
  var Me = Te.slice(0, t);
  return this._update(Be), this._reseed++, utils_1.encode(Me, Ie);
};
var assert$3 = utils_1$1.assert;
function KeyPair(Ae, t) {
  this.ec = Ae, this.priv = null, this.pub = null, t.priv && this._importPrivate(t.priv, t.privEnc), t.pub && this._importPublic(t.pub, t.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function Ae(t, Ie, Be) {
  return Ie instanceof KeyPair ? Ie : new KeyPair(t, {
    pub: Ie,
    pubEnc: Be
  });
};
KeyPair.fromPrivate = function Ae(t, Ie, Be) {
  return Ie instanceof KeyPair ? Ie : new KeyPair(t, {
    priv: Ie,
    privEnc: Be
  });
};
KeyPair.prototype.validate = function Ae() {
  var t = this.getPublic();
  return t.isInfinity() ? { result: !1, reason: "Invalid public key" } : t.validate() ? t.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair.prototype.getPublic = function Ae(t, Ie) {
  return typeof t == "string" && (Ie = t, t = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), Ie ? this.pub.encode(Ie, t) : this.pub;
};
KeyPair.prototype.getPrivate = function Ae(t) {
  return t === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair.prototype._importPrivate = function Ae(t, Ie) {
  this.priv = new BN$1(t, Ie || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function Ae(t, Ie) {
  if (t.x || t.y) {
    this.ec.curve.type === "mont" ? assert$3(t.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$3(t.x && t.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(t.x, t.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(t, Ie);
};
KeyPair.prototype.derive = function Ae(t) {
  return t.validate() || assert$3(t.validate(), "public point not validated"), t.mul(this.priv).getX();
};
KeyPair.prototype.sign = function Ae(t, Ie, Be) {
  return this.ec.sign(t, this, Ie, Be);
};
KeyPair.prototype.verify = function Ae(t, Ie) {
  return this.ec.verify(t, Ie, this);
};
KeyPair.prototype.inspect = function Ae() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4 = utils_1$1.assert;
function Signature(Ae, t) {
  if (Ae instanceof Signature)
    return Ae;
  this._importDER(Ae, t) || (assert$4(Ae.r && Ae.s, "Signature without r or s"), this.r = new BN$1(Ae.r, 16), this.s = new BN$1(Ae.s, 16), Ae.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = Ae.recoveryParam);
}
var signature = Signature;
function Position() {
  this.place = 0;
}
function getLength(Ae, t) {
  var Ie = Ae[t.place++];
  if (!(Ie & 128))
    return Ie;
  var Be = Ie & 15;
  if (Be === 0 || Be > 4)
    return !1;
  for (var Pe = 0, Te = 0, Me = t.place; Te < Be; Te++, Me++)
    Pe <<= 8, Pe |= Ae[Me], Pe >>>= 0;
  return Pe <= 127 ? !1 : (t.place = Me, Pe);
}
function rmPadding(Ae) {
  for (var t = 0, Ie = Ae.length - 1; !Ae[t] && !(Ae[t + 1] & 128) && t < Ie; )
    t++;
  return t === 0 ? Ae : Ae.slice(t);
}
Signature.prototype._importDER = function Ae(t, Ie) {
  t = utils_1$1.toArray(t, Ie);
  var Be = new Position();
  if (t[Be.place++] !== 48)
    return !1;
  var Pe = getLength(t, Be);
  if (Pe === !1 || Pe + Be.place !== t.length || t[Be.place++] !== 2)
    return !1;
  var Te = getLength(t, Be);
  if (Te === !1)
    return !1;
  var Me = t.slice(Be.place, Te + Be.place);
  if (Be.place += Te, t[Be.place++] !== 2)
    return !1;
  var Ue = getLength(t, Be);
  if (Ue === !1 || t.length !== Ue + Be.place)
    return !1;
  var je = t.slice(Be.place, Ue + Be.place);
  if (Me[0] === 0)
    if (Me[1] & 128)
      Me = Me.slice(1);
    else
      return !1;
  if (je[0] === 0)
    if (je[1] & 128)
      je = je.slice(1);
    else
      return !1;
  return this.r = new BN$1(Me), this.s = new BN$1(je), this.recoveryParam = null, !0;
};
function constructLength(Ae, t) {
  if (t < 128) {
    Ae.push(t);
    return;
  }
  var Ie = 1 + (Math.log(t) / Math.LN2 >>> 3);
  for (Ae.push(Ie | 128); --Ie; )
    Ae.push(t >>> (Ie << 3) & 255);
  Ae.push(t);
}
Signature.prototype.toDER = function Ae(t) {
  var Ie = this.r.toArray(), Be = this.s.toArray();
  for (Ie[0] & 128 && (Ie = [0].concat(Ie)), Be[0] & 128 && (Be = [0].concat(Be)), Ie = rmPadding(Ie), Be = rmPadding(Be); !Be[0] && !(Be[1] & 128); )
    Be = Be.slice(1);
  var Pe = [2];
  constructLength(Pe, Ie.length), Pe = Pe.concat(Ie), Pe.push(2), constructLength(Pe, Be.length);
  var Te = Pe.concat(Be), Me = [48];
  return constructLength(Me, Te.length), Me = Me.concat(Te), utils_1$1.encode(Me, t);
};
var rand = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
), assert$5 = utils_1$1.assert;
function EC(Ae) {
  if (!(this instanceof EC))
    return new EC(Ae);
  typeof Ae == "string" && (assert$5(
    Object.prototype.hasOwnProperty.call(curves_1, Ae),
    "Unknown curve " + Ae
  ), Ae = curves_1[Ae]), Ae instanceof curves_1.PresetCurve && (Ae = { curve: Ae }), this.curve = Ae.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = Ae.curve.g, this.g.precompute(Ae.curve.n.bitLength() + 1), this.hash = Ae.hash || Ae.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function Ae(t) {
  return new key(this, t);
};
EC.prototype.keyFromPrivate = function Ae(t, Ie) {
  return key.fromPrivate(this, t, Ie);
};
EC.prototype.keyFromPublic = function Ae(t, Ie) {
  return key.fromPublic(this, t, Ie);
};
EC.prototype.genKeyPair = function Ae(t) {
  t || (t = {});
  for (var Ie = new hmacDrbg({
    hash: this.hash,
    pers: t.pers,
    persEnc: t.persEnc || "utf8",
    entropy: t.entropy || rand(this.hash.hmacStrength),
    entropyEnc: t.entropy && t.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), Be = this.n.byteLength(), Pe = this.n.sub(new BN$1(2)); ; ) {
    var Te = new BN$1(Ie.generate(Be));
    if (!(Te.cmp(Pe) > 0))
      return Te.iaddn(1), this.keyFromPrivate(Te);
  }
};
EC.prototype._truncateToN = function Ae(t, Ie) {
  var Be = t.byteLength() * 8 - this.n.bitLength();
  return Be > 0 && (t = t.ushrn(Be)), !Ie && t.cmp(this.n) >= 0 ? t.sub(this.n) : t;
};
EC.prototype.sign = function Ae(t, Ie, Be, Pe) {
  typeof Be == "object" && (Pe = Be, Be = null), Pe || (Pe = {}), Ie = this.keyFromPrivate(Ie, Be), t = this._truncateToN(new BN$1(t, 16));
  for (var Te = this.n.byteLength(), Me = Ie.getPrivate().toArray("be", Te), Ue = t.toArray("be", Te), je = new hmacDrbg({
    hash: this.hash,
    entropy: Me,
    nonce: Ue,
    pers: Pe.pers,
    persEnc: Pe.persEnc || "utf8"
  }), fn = this.n.sub(new BN$1(1)), Ve = 0; ; Ve++) {
    var vn = Pe.k ? Pe.k(Ve) : new BN$1(je.generate(this.n.byteLength()));
    if (vn = this._truncateToN(vn, !0), !(vn.cmpn(1) <= 0 || vn.cmp(fn) >= 0)) {
      var En = this.g.mul(vn);
      if (!En.isInfinity()) {
        var fi = En.getX(), bi = fi.umod(this.n);
        if (bi.cmpn(0) !== 0) {
          var mi = vn.invm(this.n).mul(bi.mul(Ie.getPrivate()).iadd(t));
          if (mi = mi.umod(this.n), mi.cmpn(0) !== 0) {
            var _i = (En.getY().isOdd() ? 1 : 0) | (fi.cmp(bi) !== 0 ? 2 : 0);
            return Pe.canonical && mi.cmp(this.nh) > 0 && (mi = this.n.sub(mi), _i ^= 1), new signature({ r: bi, s: mi, recoveryParam: _i });
          }
        }
      }
    }
  }
};
EC.prototype.verify = function Ae(t, Ie, Be, Pe) {
  t = this._truncateToN(new BN$1(t, 16)), Be = this.keyFromPublic(Be, Pe), Ie = new signature(Ie, "hex");
  var Te = Ie.r, Me = Ie.s;
  if (Te.cmpn(1) < 0 || Te.cmp(this.n) >= 0 || Me.cmpn(1) < 0 || Me.cmp(this.n) >= 0)
    return !1;
  var Ue = Me.invm(this.n), je = Ue.mul(t).umod(this.n), fn = Ue.mul(Te).umod(this.n), Ve;
  return this.curve._maxwellTrick ? (Ve = this.g.jmulAdd(je, Be.getPublic(), fn), Ve.isInfinity() ? !1 : Ve.eqXToP(Te)) : (Ve = this.g.mulAdd(je, Be.getPublic(), fn), Ve.isInfinity() ? !1 : Ve.getX().umod(this.n).cmp(Te) === 0);
};
EC.prototype.recoverPubKey = function(Ae, t, Ie, Be) {
  assert$5((3 & Ie) === Ie, "The recovery param is more than two bits"), t = new signature(t, Be);
  var Pe = this.n, Te = new BN$1(Ae), Me = t.r, Ue = t.s, je = Ie & 1, fn = Ie >> 1;
  if (Me.cmp(this.curve.p.umod(this.curve.n)) >= 0 && fn)
    throw new Error("Unable to find sencond key candinate");
  fn ? Me = this.curve.pointFromX(Me.add(this.curve.n), je) : Me = this.curve.pointFromX(Me, je);
  var Ve = t.r.invm(Pe), vn = Pe.sub(Te).mul(Ve).umod(Pe), En = Ue.mul(Ve).umod(Pe);
  return this.g.mulAdd(vn, Me, En);
};
EC.prototype.getKeyRecoveryParam = function(Ae, t, Ie, Be) {
  if (t = new signature(t, Be), t.recoveryParam !== null)
    return t.recoveryParam;
  for (var Pe = 0; Pe < 4; Pe++) {
    var Te;
    try {
      Te = this.recoverPubKey(Ae, t, Pe);
    } catch {
      continue;
    }
    if (Te.eq(Ie))
      return Pe;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(Ae, t) {
  var Ie = t;
  Ie.version = "6.5.4", Ie.utils = utils_1$1, Ie.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }, Ie.curve = curve_1, Ie.curves = curves_1, Ie.ec = ec, Ie.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
}), EC$1 = elliptic_1.ec;
const version = "signing-key/5.7.0", logger = new Logger(version);
let _curve = null;
function getCurve() {
  return _curve || (_curve = new EC$1("secp256k1")), _curve;
}
class SigningKey {
  constructor(t) {
    defineReadOnly(this, "curve", "secp256k1"), defineReadOnly(this, "privateKey", hexlify(t)), hexDataLength(this.privateKey) !== 32 && logger.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    const Ie = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + Ie.getPublic(!1, "hex")), defineReadOnly(this, "compressedPublicKey", "0x" + Ie.getPublic(!0, "hex")), defineReadOnly(this, "_isSigningKey", !0);
  }
  _addPoint(t) {
    const Ie = getCurve().keyFromPublic(arrayify(this.publicKey)), Be = getCurve().keyFromPublic(arrayify(t));
    return "0x" + Ie.pub.add(Be.pub).encodeCompressed("hex");
  }
  signDigest(t) {
    const Ie = getCurve().keyFromPrivate(arrayify(this.privateKey)), Be = arrayify(t);
    Be.length !== 32 && logger.throwArgumentError("bad digest length", "digest", t);
    const Pe = Ie.sign(Be, { canonical: !0 });
    return splitSignature({
      recoveryParam: Pe.recoveryParam,
      r: hexZeroPad("0x" + Pe.r.toString(16), 32),
      s: hexZeroPad("0x" + Pe.s.toString(16), 32)
    });
  }
  computeSharedSecret(t) {
    const Ie = getCurve().keyFromPrivate(arrayify(this.privateKey)), Be = getCurve().keyFromPublic(arrayify(computePublicKey(t)));
    return hexZeroPad("0x" + Ie.derive(Be.getPublic()).toString(16), 32);
  }
  static isSigningKey(t) {
    return !!(t && t._isSigningKey);
  }
}
function recoverPublicKey(Ae, t) {
  const Ie = splitSignature(t), Be = { r: arrayify(Ie.r), s: arrayify(Ie.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(Ae), Be, Ie.recoveryParam).encode("hex", !1);
}
function computePublicKey(Ae, t) {
  const Ie = arrayify(Ae);
  return Ie.length === 32 ? new SigningKey(Ie).publicKey : Ie.length === 33 ? "0x" + getCurve().keyFromPublic(Ie).getPublic(!1, "hex") : Ie.length === 65 ? hexlify(Ie) : logger.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
var TransactionTypes;
(function(Ae) {
  Ae[Ae.legacy = 0] = "legacy", Ae[Ae.eip2930 = 1] = "eip2930", Ae[Ae.eip1559 = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function computeAddress(Ae) {
  const t = computePublicKey(Ae);
  return getAddress(hexDataSlice(keccak256(hexDataSlice(t, 1)), 12));
}
function recoverAddress(Ae, t) {
  return computeAddress(recoverPublicKey(arrayify(Ae), t));
}
var chacha20poly1305 = {}, chacha = {};
Object.defineProperty(chacha, "__esModule", { value: !0 });
var binary_1 = binary, wipe_1$2 = wipe$1, ROUNDS = 20;
function core(Ae, t, Ie) {
  for (var Be = 1634760805, Pe = 857760878, Te = 2036477234, Me = 1797285236, Ue = Ie[3] << 24 | Ie[2] << 16 | Ie[1] << 8 | Ie[0], je = Ie[7] << 24 | Ie[6] << 16 | Ie[5] << 8 | Ie[4], fn = Ie[11] << 24 | Ie[10] << 16 | Ie[9] << 8 | Ie[8], Ve = Ie[15] << 24 | Ie[14] << 16 | Ie[13] << 8 | Ie[12], vn = Ie[19] << 24 | Ie[18] << 16 | Ie[17] << 8 | Ie[16], En = Ie[23] << 24 | Ie[22] << 16 | Ie[21] << 8 | Ie[20], fi = Ie[27] << 24 | Ie[26] << 16 | Ie[25] << 8 | Ie[24], bi = Ie[31] << 24 | Ie[30] << 16 | Ie[29] << 8 | Ie[28], mi = t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0], _i = t[7] << 24 | t[6] << 16 | t[5] << 8 | t[4], Ei = t[11] << 24 | t[10] << 16 | t[9] << 8 | t[8], Si = t[15] << 24 | t[14] << 16 | t[13] << 8 | t[12], Mi = Be, Oi = Pe, Fi = Te, Ui = Me, Pi = Ue, Bi = je, ji = fn, Zi = Ve, zi = vn, xi = En, $i = fi, vi = bi, wi = mi, Ai = _i, Ri = Ei, Ti = Si, Ci = 0; Ci < ROUNDS; Ci += 2)
    Mi = Mi + Pi | 0, wi ^= Mi, wi = wi >>> 16 | wi << 16, zi = zi + wi | 0, Pi ^= zi, Pi = Pi >>> 20 | Pi << 12, Oi = Oi + Bi | 0, Ai ^= Oi, Ai = Ai >>> 16 | Ai << 16, xi = xi + Ai | 0, Bi ^= xi, Bi = Bi >>> 20 | Bi << 12, Fi = Fi + ji | 0, Ri ^= Fi, Ri = Ri >>> 16 | Ri << 16, $i = $i + Ri | 0, ji ^= $i, ji = ji >>> 20 | ji << 12, Ui = Ui + Zi | 0, Ti ^= Ui, Ti = Ti >>> 16 | Ti << 16, vi = vi + Ti | 0, Zi ^= vi, Zi = Zi >>> 20 | Zi << 12, Fi = Fi + ji | 0, Ri ^= Fi, Ri = Ri >>> 24 | Ri << 8, $i = $i + Ri | 0, ji ^= $i, ji = ji >>> 25 | ji << 7, Ui = Ui + Zi | 0, Ti ^= Ui, Ti = Ti >>> 24 | Ti << 8, vi = vi + Ti | 0, Zi ^= vi, Zi = Zi >>> 25 | Zi << 7, Oi = Oi + Bi | 0, Ai ^= Oi, Ai = Ai >>> 24 | Ai << 8, xi = xi + Ai | 0, Bi ^= xi, Bi = Bi >>> 25 | Bi << 7, Mi = Mi + Pi | 0, wi ^= Mi, wi = wi >>> 24 | wi << 8, zi = zi + wi | 0, Pi ^= zi, Pi = Pi >>> 25 | Pi << 7, Mi = Mi + Bi | 0, Ti ^= Mi, Ti = Ti >>> 16 | Ti << 16, $i = $i + Ti | 0, Bi ^= $i, Bi = Bi >>> 20 | Bi << 12, Oi = Oi + ji | 0, wi ^= Oi, wi = wi >>> 16 | wi << 16, vi = vi + wi | 0, ji ^= vi, ji = ji >>> 20 | ji << 12, Fi = Fi + Zi | 0, Ai ^= Fi, Ai = Ai >>> 16 | Ai << 16, zi = zi + Ai | 0, Zi ^= zi, Zi = Zi >>> 20 | Zi << 12, Ui = Ui + Pi | 0, Ri ^= Ui, Ri = Ri >>> 16 | Ri << 16, xi = xi + Ri | 0, Pi ^= xi, Pi = Pi >>> 20 | Pi << 12, Fi = Fi + Zi | 0, Ai ^= Fi, Ai = Ai >>> 24 | Ai << 8, zi = zi + Ai | 0, Zi ^= zi, Zi = Zi >>> 25 | Zi << 7, Ui = Ui + Pi | 0, Ri ^= Ui, Ri = Ri >>> 24 | Ri << 8, xi = xi + Ri | 0, Pi ^= xi, Pi = Pi >>> 25 | Pi << 7, Oi = Oi + ji | 0, wi ^= Oi, wi = wi >>> 24 | wi << 8, vi = vi + wi | 0, ji ^= vi, ji = ji >>> 25 | ji << 7, Mi = Mi + Bi | 0, Ti ^= Mi, Ti = Ti >>> 24 | Ti << 8, $i = $i + Ti | 0, Bi ^= $i, Bi = Bi >>> 25 | Bi << 7;
  binary_1.writeUint32LE(Mi + Be | 0, Ae, 0), binary_1.writeUint32LE(Oi + Pe | 0, Ae, 4), binary_1.writeUint32LE(Fi + Te | 0, Ae, 8), binary_1.writeUint32LE(Ui + Me | 0, Ae, 12), binary_1.writeUint32LE(Pi + Ue | 0, Ae, 16), binary_1.writeUint32LE(Bi + je | 0, Ae, 20), binary_1.writeUint32LE(ji + fn | 0, Ae, 24), binary_1.writeUint32LE(Zi + Ve | 0, Ae, 28), binary_1.writeUint32LE(zi + vn | 0, Ae, 32), binary_1.writeUint32LE(xi + En | 0, Ae, 36), binary_1.writeUint32LE($i + fi | 0, Ae, 40), binary_1.writeUint32LE(vi + bi | 0, Ae, 44), binary_1.writeUint32LE(wi + mi | 0, Ae, 48), binary_1.writeUint32LE(Ai + _i | 0, Ae, 52), binary_1.writeUint32LE(Ri + Ei | 0, Ae, 56), binary_1.writeUint32LE(Ti + Si | 0, Ae, 60);
}
function streamXOR(Ae, t, Ie, Be, Pe) {
  if (Pe === void 0 && (Pe = 0), Ae.length !== 32)
    throw new Error("ChaCha: key size must be 32 bytes");
  if (Be.length < Ie.length)
    throw new Error("ChaCha: destination is shorter than source");
  var Te, Me;
  if (Pe === 0) {
    if (t.length !== 8 && t.length !== 12)
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    Te = new Uint8Array(16), Me = Te.length - t.length, Te.set(t, Me);
  } else {
    if (t.length !== 16)
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    Te = t, Me = Pe;
  }
  for (var Ue = new Uint8Array(64), je = 0; je < Ie.length; je += 64) {
    core(Ue, Te, Ae);
    for (var fn = je; fn < je + 64 && fn < Ie.length; fn++)
      Be[fn] = Ie[fn] ^ Ue[fn - je];
    incrementCounter(Te, 0, Me);
  }
  return wipe_1$2.wipe(Ue), Pe === 0 && wipe_1$2.wipe(Te), Be;
}
chacha.streamXOR = streamXOR;
function stream(Ae, t, Ie, Be) {
  return Be === void 0 && (Be = 0), wipe_1$2.wipe(Ie), streamXOR(Ae, t, Ie, Ie, Be);
}
chacha.stream = stream;
function incrementCounter(Ae, t, Ie) {
  for (var Be = 1; Ie--; )
    Be = Be + (Ae[t] & 255) | 0, Ae[t] = Be & 255, Be >>>= 8, t++;
  if (Be > 0)
    throw new Error("ChaCha: counter overflow");
}
var poly1305 = {}, constantTime = {};
Object.defineProperty(constantTime, "__esModule", { value: !0 });
function select(Ae, t, Ie) {
  return ~(Ae - 1) & t | Ae - 1 & Ie;
}
constantTime.select = select;
function lessOrEqual(Ae, t) {
  return (Ae | 0) - (t | 0) - 1 >>> 31 & 1;
}
constantTime.lessOrEqual = lessOrEqual;
function compare(Ae, t) {
  if (Ae.length !== t.length)
    return 0;
  for (var Ie = 0, Be = 0; Be < Ae.length; Be++)
    Ie |= Ae[Be] ^ t[Be];
  return 1 & Ie - 1 >>> 8;
}
constantTime.compare = compare;
function equal(Ae, t) {
  return Ae.length === 0 || t.length === 0 ? !1 : compare(Ae, t) !== 0;
}
constantTime.equal = equal;
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  var t = constantTime, Ie = wipe$1;
  Ae.DIGEST_LENGTH = 16;
  var Be = (
    /** @class */
    function() {
      function Me(Ue) {
        this.digestLength = Ae.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
        var je = Ue[0] | Ue[1] << 8;
        this._r[0] = je & 8191;
        var fn = Ue[2] | Ue[3] << 8;
        this._r[1] = (je >>> 13 | fn << 3) & 8191;
        var Ve = Ue[4] | Ue[5] << 8;
        this._r[2] = (fn >>> 10 | Ve << 6) & 7939;
        var vn = Ue[6] | Ue[7] << 8;
        this._r[3] = (Ve >>> 7 | vn << 9) & 8191;
        var En = Ue[8] | Ue[9] << 8;
        this._r[4] = (vn >>> 4 | En << 12) & 255, this._r[5] = En >>> 1 & 8190;
        var fi = Ue[10] | Ue[11] << 8;
        this._r[6] = (En >>> 14 | fi << 2) & 8191;
        var bi = Ue[12] | Ue[13] << 8;
        this._r[7] = (fi >>> 11 | bi << 5) & 8065;
        var mi = Ue[14] | Ue[15] << 8;
        this._r[8] = (bi >>> 8 | mi << 8) & 8191, this._r[9] = mi >>> 5 & 127, this._pad[0] = Ue[16] | Ue[17] << 8, this._pad[1] = Ue[18] | Ue[19] << 8, this._pad[2] = Ue[20] | Ue[21] << 8, this._pad[3] = Ue[22] | Ue[23] << 8, this._pad[4] = Ue[24] | Ue[25] << 8, this._pad[5] = Ue[26] | Ue[27] << 8, this._pad[6] = Ue[28] | Ue[29] << 8, this._pad[7] = Ue[30] | Ue[31] << 8;
      }
      return Me.prototype._blocks = function(Ue, je, fn) {
        for (var Ve = this._fin ? 0 : 2048, vn = this._h[0], En = this._h[1], fi = this._h[2], bi = this._h[3], mi = this._h[4], _i = this._h[5], Ei = this._h[6], Si = this._h[7], Mi = this._h[8], Oi = this._h[9], Fi = this._r[0], Ui = this._r[1], Pi = this._r[2], Bi = this._r[3], ji = this._r[4], Zi = this._r[5], zi = this._r[6], xi = this._r[7], $i = this._r[8], vi = this._r[9]; fn >= 16; ) {
          var wi = Ue[je + 0] | Ue[je + 1] << 8;
          vn += wi & 8191;
          var Ai = Ue[je + 2] | Ue[je + 3] << 8;
          En += (wi >>> 13 | Ai << 3) & 8191;
          var Ri = Ue[je + 4] | Ue[je + 5] << 8;
          fi += (Ai >>> 10 | Ri << 6) & 8191;
          var Ti = Ue[je + 6] | Ue[je + 7] << 8;
          bi += (Ri >>> 7 | Ti << 9) & 8191;
          var Ci = Ue[je + 8] | Ue[je + 9] << 8;
          mi += (Ti >>> 4 | Ci << 12) & 8191, _i += Ci >>> 1 & 8191;
          var Ii = Ue[je + 10] | Ue[je + 11] << 8;
          Ei += (Ci >>> 14 | Ii << 2) & 8191;
          var Li = Ue[je + 12] | Ue[je + 13] << 8;
          Si += (Ii >>> 11 | Li << 5) & 8191;
          var Ni = Ue[je + 14] | Ue[je + 15] << 8;
          Mi += (Li >>> 8 | Ni << 8) & 8191, Oi += Ni >>> 5 | Ve;
          var Vi = 0, is = Vi;
          is += vn * Fi, is += En * (5 * vi), is += fi * (5 * $i), is += bi * (5 * xi), is += mi * (5 * zi), Vi = is >>> 13, is &= 8191, is += _i * (5 * Zi), is += Ei * (5 * ji), is += Si * (5 * Bi), is += Mi * (5 * Pi), is += Oi * (5 * Ui), Vi += is >>> 13, is &= 8191;
          var Ki = Vi;
          Ki += vn * Ui, Ki += En * Fi, Ki += fi * (5 * vi), Ki += bi * (5 * $i), Ki += mi * (5 * xi), Vi = Ki >>> 13, Ki &= 8191, Ki += _i * (5 * zi), Ki += Ei * (5 * Zi), Ki += Si * (5 * ji), Ki += Mi * (5 * Bi), Ki += Oi * (5 * Pi), Vi += Ki >>> 13, Ki &= 8191;
          var ts = Vi;
          ts += vn * Pi, ts += En * Ui, ts += fi * Fi, ts += bi * (5 * vi), ts += mi * (5 * $i), Vi = ts >>> 13, ts &= 8191, ts += _i * (5 * xi), ts += Ei * (5 * zi), ts += Si * (5 * Zi), ts += Mi * (5 * ji), ts += Oi * (5 * Bi), Vi += ts >>> 13, ts &= 8191;
          var qi = Vi;
          qi += vn * Bi, qi += En * Pi, qi += fi * Ui, qi += bi * Fi, qi += mi * (5 * vi), Vi = qi >>> 13, qi &= 8191, qi += _i * (5 * $i), qi += Ei * (5 * xi), qi += Si * (5 * zi), qi += Mi * (5 * Zi), qi += Oi * (5 * ji), Vi += qi >>> 13, qi &= 8191;
          var Hi = Vi;
          Hi += vn * ji, Hi += En * Bi, Hi += fi * Pi, Hi += bi * Ui, Hi += mi * Fi, Vi = Hi >>> 13, Hi &= 8191, Hi += _i * (5 * vi), Hi += Ei * (5 * $i), Hi += Si * (5 * xi), Hi += Mi * (5 * zi), Hi += Oi * (5 * Zi), Vi += Hi >>> 13, Hi &= 8191;
          var Xi = Vi;
          Xi += vn * Zi, Xi += En * ji, Xi += fi * Bi, Xi += bi * Pi, Xi += mi * Ui, Vi = Xi >>> 13, Xi &= 8191, Xi += _i * Fi, Xi += Ei * (5 * vi), Xi += Si * (5 * $i), Xi += Mi * (5 * xi), Xi += Oi * (5 * zi), Vi += Xi >>> 13, Xi &= 8191;
          var ki = Vi;
          ki += vn * zi, ki += En * Zi, ki += fi * ji, ki += bi * Bi, ki += mi * Pi, Vi = ki >>> 13, ki &= 8191, ki += _i * Ui, ki += Ei * Fi, ki += Si * (5 * vi), ki += Mi * (5 * $i), ki += Oi * (5 * xi), Vi += ki >>> 13, ki &= 8191;
          var Wi = Vi;
          Wi += vn * xi, Wi += En * zi, Wi += fi * Zi, Wi += bi * ji, Wi += mi * Bi, Vi = Wi >>> 13, Wi &= 8191, Wi += _i * Pi, Wi += Ei * Ui, Wi += Si * Fi, Wi += Mi * (5 * vi), Wi += Oi * (5 * $i), Vi += Wi >>> 13, Wi &= 8191;
          var Yi = Vi;
          Yi += vn * $i, Yi += En * xi, Yi += fi * zi, Yi += bi * Zi, Yi += mi * ji, Vi = Yi >>> 13, Yi &= 8191, Yi += _i * Bi, Yi += Ei * Pi, Yi += Si * Ui, Yi += Mi * Fi, Yi += Oi * (5 * vi), Vi += Yi >>> 13, Yi &= 8191;
          var Qi = Vi;
          Qi += vn * vi, Qi += En * $i, Qi += fi * xi, Qi += bi * zi, Qi += mi * Zi, Vi = Qi >>> 13, Qi &= 8191, Qi += _i * ji, Qi += Ei * Bi, Qi += Si * Pi, Qi += Mi * Ui, Qi += Oi * Fi, Vi += Qi >>> 13, Qi &= 8191, Vi = (Vi << 2) + Vi | 0, Vi = Vi + is | 0, is = Vi & 8191, Vi = Vi >>> 13, Ki += Vi, vn = is, En = Ki, fi = ts, bi = qi, mi = Hi, _i = Xi, Ei = ki, Si = Wi, Mi = Yi, Oi = Qi, je += 16, fn -= 16;
        }
        this._h[0] = vn, this._h[1] = En, this._h[2] = fi, this._h[3] = bi, this._h[4] = mi, this._h[5] = _i, this._h[6] = Ei, this._h[7] = Si, this._h[8] = Mi, this._h[9] = Oi;
      }, Me.prototype.finish = function(Ue, je) {
        je === void 0 && (je = 0);
        var fn = new Uint16Array(10), Ve, vn, En, fi;
        if (this._leftover) {
          for (fi = this._leftover, this._buffer[fi++] = 1; fi < 16; fi++)
            this._buffer[fi] = 0;
          this._fin = 1, this._blocks(this._buffer, 0, 16);
        }
        for (Ve = this._h[1] >>> 13, this._h[1] &= 8191, fi = 2; fi < 10; fi++)
          this._h[fi] += Ve, Ve = this._h[fi] >>> 13, this._h[fi] &= 8191;
        for (this._h[0] += Ve * 5, Ve = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += Ve, Ve = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += Ve, fn[0] = this._h[0] + 5, Ve = fn[0] >>> 13, fn[0] &= 8191, fi = 1; fi < 10; fi++)
          fn[fi] = this._h[fi] + Ve, Ve = fn[fi] >>> 13, fn[fi] &= 8191;
        for (fn[9] -= 8192, vn = (Ve ^ 1) - 1, fi = 0; fi < 10; fi++)
          fn[fi] &= vn;
        for (vn = ~vn, fi = 0; fi < 10; fi++)
          this._h[fi] = this._h[fi] & vn | fn[fi];
        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, En = this._h[0] + this._pad[0], this._h[0] = En & 65535, fi = 1; fi < 8; fi++)
          En = (this._h[fi] + this._pad[fi] | 0) + (En >>> 16) | 0, this._h[fi] = En & 65535;
        return Ue[je + 0] = this._h[0] >>> 0, Ue[je + 1] = this._h[0] >>> 8, Ue[je + 2] = this._h[1] >>> 0, Ue[je + 3] = this._h[1] >>> 8, Ue[je + 4] = this._h[2] >>> 0, Ue[je + 5] = this._h[2] >>> 8, Ue[je + 6] = this._h[3] >>> 0, Ue[je + 7] = this._h[3] >>> 8, Ue[je + 8] = this._h[4] >>> 0, Ue[je + 9] = this._h[4] >>> 8, Ue[je + 10] = this._h[5] >>> 0, Ue[je + 11] = this._h[5] >>> 8, Ue[je + 12] = this._h[6] >>> 0, Ue[je + 13] = this._h[6] >>> 8, Ue[je + 14] = this._h[7] >>> 0, Ue[je + 15] = this._h[7] >>> 8, this._finished = !0, this;
      }, Me.prototype.update = function(Ue) {
        var je = 0, fn = Ue.length, Ve;
        if (this._leftover) {
          Ve = 16 - this._leftover, Ve > fn && (Ve = fn);
          for (var vn = 0; vn < Ve; vn++)
            this._buffer[this._leftover + vn] = Ue[je + vn];
          if (fn -= Ve, je += Ve, this._leftover += Ve, this._leftover < 16)
            return this;
          this._blocks(this._buffer, 0, 16), this._leftover = 0;
        }
        if (fn >= 16 && (Ve = fn - fn % 16, this._blocks(Ue, je, Ve), je += Ve, fn -= Ve), fn) {
          for (var vn = 0; vn < fn; vn++)
            this._buffer[this._leftover + vn] = Ue[je + vn];
          this._leftover += fn;
        }
        return this;
      }, Me.prototype.digest = function() {
        if (this._finished)
          throw new Error("Poly1305 was finished");
        var Ue = new Uint8Array(16);
        return this.finish(Ue), Ue;
      }, Me.prototype.clean = function() {
        return Ie.wipe(this._buffer), Ie.wipe(this._r), Ie.wipe(this._h), Ie.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;
      }, Me;
    }()
  );
  Ae.Poly1305 = Be;
  function Pe(Me, Ue) {
    var je = new Be(Me);
    je.update(Ue);
    var fn = je.digest();
    return je.clean(), fn;
  }
  Ae.oneTimeAuth = Pe;
  function Te(Me, Ue) {
    return Me.length !== Ae.DIGEST_LENGTH || Ue.length !== Ae.DIGEST_LENGTH ? !1 : t.equal(Me, Ue);
  }
  Ae.equal = Te;
})(poly1305);
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  var t = chacha, Ie = poly1305, Be = wipe$1, Pe = binary, Te = constantTime;
  Ae.KEY_LENGTH = 32, Ae.NONCE_LENGTH = 12, Ae.TAG_LENGTH = 16;
  var Me = new Uint8Array(16), Ue = (
    /** @class */
    function() {
      function je(fn) {
        if (this.nonceLength = Ae.NONCE_LENGTH, this.tagLength = Ae.TAG_LENGTH, fn.length !== Ae.KEY_LENGTH)
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(fn);
      }
      return je.prototype.seal = function(fn, Ve, vn, En) {
        if (fn.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        var fi = new Uint8Array(16);
        fi.set(fn, fi.length - fn.length);
        var bi = new Uint8Array(32);
        t.stream(this._key, fi, bi, 4);
        var mi = Ve.length + this.tagLength, _i;
        if (En) {
          if (En.length !== mi)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          _i = En;
        } else
          _i = new Uint8Array(mi);
        return t.streamXOR(this._key, fi, Ve, _i, 4), this._authenticate(_i.subarray(_i.length - this.tagLength, _i.length), bi, _i.subarray(0, _i.length - this.tagLength), vn), Be.wipe(fi), _i;
      }, je.prototype.open = function(fn, Ve, vn, En) {
        if (fn.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        if (Ve.length < this.tagLength)
          return null;
        var fi = new Uint8Array(16);
        fi.set(fn, fi.length - fn.length);
        var bi = new Uint8Array(32);
        t.stream(this._key, fi, bi, 4);
        var mi = new Uint8Array(this.tagLength);
        if (this._authenticate(mi, bi, Ve.subarray(0, Ve.length - this.tagLength), vn), !Te.equal(mi, Ve.subarray(Ve.length - this.tagLength, Ve.length)))
          return null;
        var _i = Ve.length - this.tagLength, Ei;
        if (En) {
          if (En.length !== _i)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          Ei = En;
        } else
          Ei = new Uint8Array(_i);
        return t.streamXOR(this._key, fi, Ve.subarray(0, Ve.length - this.tagLength), Ei, 4), Be.wipe(fi), Ei;
      }, je.prototype.clean = function() {
        return Be.wipe(this._key), this;
      }, je.prototype._authenticate = function(fn, Ve, vn, En) {
        var fi = new Ie.Poly1305(Ve);
        En && (fi.update(En), En.length % 16 > 0 && fi.update(Me.subarray(En.length % 16))), fi.update(vn), vn.length % 16 > 0 && fi.update(Me.subarray(vn.length % 16));
        var bi = new Uint8Array(8);
        En && Pe.writeUint64LE(En.length, bi), fi.update(bi), Pe.writeUint64LE(vn.length, bi), fi.update(bi);
        for (var mi = fi.digest(), _i = 0; _i < mi.length; _i++)
          fn[_i] = mi[_i];
        fi.clean(), Be.wipe(mi), Be.wipe(bi);
      }, je;
    }()
  );
  Ae.ChaCha20Poly1305 = Ue;
})(chacha20poly1305);
var hkdf = {}, hmac$1 = {}, hash = {};
Object.defineProperty(hash, "__esModule", { value: !0 });
function isSerializableHash(Ae) {
  return typeof Ae.saveState < "u" && typeof Ae.restoreState < "u" && typeof Ae.cleanSavedState < "u";
}
hash.isSerializableHash = isSerializableHash;
Object.defineProperty(hmac$1, "__esModule", { value: !0 });
var hash_1 = hash, constant_time_1 = constantTime, wipe_1$1 = wipe$1, HMAC = (
  /** @class */
  function() {
    function Ae(t, Ie) {
      this._finished = !1, this._inner = new t(), this._outer = new t(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
      var Be = new Uint8Array(this.blockSize);
      Ie.length > this.blockSize ? this._inner.update(Ie).finish(Be).clean() : Be.set(Ie);
      for (var Pe = 0; Pe < Be.length; Pe++)
        Be[Pe] ^= 54;
      this._inner.update(Be);
      for (var Pe = 0; Pe < Be.length; Pe++)
        Be[Pe] ^= 106;
      this._outer.update(Be), hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), wipe_1$1.wipe(Be);
    }
    return Ae.prototype.reset = function() {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer))
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, Ae.prototype.clean = function() {
      hash_1.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), hash_1.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();
    }, Ae.prototype.update = function(t) {
      return this._inner.update(t), this;
    }, Ae.prototype.finish = function(t) {
      return this._finished ? (this._outer.finish(t), this) : (this._inner.finish(t), this._outer.update(t.subarray(0, this.digestLength)).finish(t), this._finished = !0, this);
    }, Ae.prototype.digest = function() {
      var t = new Uint8Array(this.digestLength);
      return this.finish(t), t;
    }, Ae.prototype.saveState = function() {
      if (!hash_1.isSerializableHash(this._inner))
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      return this._inner.saveState();
    }, Ae.prototype.restoreState = function(t) {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer))
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      return this._inner.restoreState(t), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, Ae.prototype.cleanSavedState = function(t) {
      if (!hash_1.isSerializableHash(this._inner))
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      this._inner.cleanSavedState(t);
    }, Ae;
  }()
);
hmac$1.HMAC = HMAC;
function hmac(Ae, t, Ie) {
  var Be = new HMAC(Ae, t);
  Be.update(Ie);
  var Pe = Be.digest();
  return Be.clean(), Pe;
}
hmac$1.hmac = hmac;
hmac$1.equal = constant_time_1.equal;
Object.defineProperty(hkdf, "__esModule", { value: !0 });
var hmac_1 = hmac$1, wipe_1 = wipe$1, HKDF = (
  /** @class */
  function() {
    function Ae(t, Ie, Be, Pe) {
      Be === void 0 && (Be = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = t, this._info = Pe;
      var Te = hmac_1.hmac(this._hash, Be, Ie);
      this._hmac = new hmac_1.HMAC(t, Te), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;
    }
    return Ae.prototype._fillBuffer = function() {
      this._counter[0]++;
      var t = this._counter[0];
      if (t === 0)
        throw new Error("hkdf: cannot expand more");
      this._hmac.reset(), t > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;
    }, Ae.prototype.expand = function(t) {
      for (var Ie = new Uint8Array(t), Be = 0; Be < Ie.length; Be++)
        this._bufpos === this._buffer.length && this._fillBuffer(), Ie[Be] = this._buffer[this._bufpos++];
      return Ie;
    }, Ae.prototype.clean = function() {
      this._hmac.clean(), wipe_1.wipe(this._buffer), wipe_1.wipe(this._counter), this._bufpos = 0;
    }, Ae;
  }()
), HKDF_1 = hkdf.HKDF = HKDF, sha256 = {};
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  var t = binary, Ie = wipe$1;
  Ae.DIGEST_LENGTH = 32, Ae.BLOCK_SIZE = 64;
  var Be = (
    /** @class */
    function() {
      function Ue() {
        this.digestLength = Ae.DIGEST_LENGTH, this.blockSize = Ae.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return Ue.prototype._initState = function() {
        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
      }, Ue.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, Ue.prototype.clean = function() {
        Ie.wipe(this._buffer), Ie.wipe(this._temp), this.reset();
      }, Ue.prototype.update = function(je, fn) {
        if (fn === void 0 && (fn = je.length), this._finished)
          throw new Error("SHA256: can't update because hash was finished.");
        var Ve = 0;
        if (this._bytesHashed += fn, this._bufferLength > 0) {
          for (; this._bufferLength < this.blockSize && fn > 0; )
            this._buffer[this._bufferLength++] = je[Ve++], fn--;
          this._bufferLength === this.blockSize && (Te(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (fn >= this.blockSize && (Ve = Te(this._temp, this._state, je, Ve, fn), fn %= this.blockSize); fn > 0; )
          this._buffer[this._bufferLength++] = je[Ve++], fn--;
        return this;
      }, Ue.prototype.finish = function(je) {
        if (!this._finished) {
          var fn = this._bytesHashed, Ve = this._bufferLength, vn = fn / 536870912 | 0, En = fn << 3, fi = fn % 64 < 56 ? 64 : 128;
          this._buffer[Ve] = 128;
          for (var bi = Ve + 1; bi < fi - 8; bi++)
            this._buffer[bi] = 0;
          t.writeUint32BE(vn, this._buffer, fi - 8), t.writeUint32BE(En, this._buffer, fi - 4), Te(this._temp, this._state, this._buffer, 0, fi), this._finished = !0;
        }
        for (var bi = 0; bi < this.digestLength / 4; bi++)
          t.writeUint32BE(this._state[bi], je, bi * 4);
        return this;
      }, Ue.prototype.digest = function() {
        var je = new Uint8Array(this.digestLength);
        return this.finish(je), je;
      }, Ue.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, Ue.prototype.restoreState = function(je) {
        return this._state.set(je.state), this._bufferLength = je.bufferLength, je.buffer && this._buffer.set(je.buffer), this._bytesHashed = je.bytesHashed, this._finished = !1, this;
      }, Ue.prototype.cleanSavedState = function(je) {
        Ie.wipe(je.state), je.buffer && Ie.wipe(je.buffer), je.bufferLength = 0, je.bytesHashed = 0;
      }, Ue;
    }()
  );
  Ae.SHA256 = Be;
  var Pe = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function Te(Ue, je, fn, Ve, vn) {
    for (; vn >= 64; ) {
      for (var En = je[0], fi = je[1], bi = je[2], mi = je[3], _i = je[4], Ei = je[5], Si = je[6], Mi = je[7], Oi = 0; Oi < 16; Oi++) {
        var Fi = Ve + Oi * 4;
        Ue[Oi] = t.readUint32BE(fn, Fi);
      }
      for (var Oi = 16; Oi < 64; Oi++) {
        var Ui = Ue[Oi - 2], Pi = (Ui >>> 17 | Ui << 15) ^ (Ui >>> 19 | Ui << 13) ^ Ui >>> 10;
        Ui = Ue[Oi - 15];
        var Bi = (Ui >>> 7 | Ui << 25) ^ (Ui >>> 18 | Ui << 14) ^ Ui >>> 3;
        Ue[Oi] = (Pi + Ue[Oi - 7] | 0) + (Bi + Ue[Oi - 16] | 0);
      }
      for (var Oi = 0; Oi < 64; Oi++) {
        var Pi = (((_i >>> 6 | _i << 26) ^ (_i >>> 11 | _i << 21) ^ (_i >>> 25 | _i << 7)) + (_i & Ei ^ ~_i & Si) | 0) + (Mi + (Pe[Oi] + Ue[Oi] | 0) | 0) | 0, Bi = ((En >>> 2 | En << 30) ^ (En >>> 13 | En << 19) ^ (En >>> 22 | En << 10)) + (En & fi ^ En & bi ^ fi & bi) | 0;
        Mi = Si, Si = Ei, Ei = _i, _i = mi + Pi | 0, mi = bi, bi = fi, fi = En, En = Pi + Bi | 0;
      }
      je[0] += En, je[1] += fi, je[2] += bi, je[3] += mi, je[4] += _i, je[5] += Ei, je[6] += Si, je[7] += Mi, Ve += 64, vn -= 64;
    }
    return Ve;
  }
  function Me(Ue) {
    var je = new Be();
    je.update(Ue);
    var fn = je.digest();
    return je.clean(), fn;
  }
  Ae.hash = Me;
})(sha256);
var x25519 = {};
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 }), Ae.sharedKey = Ae.generateKeyPair = Ae.generateKeyPairFromSeed = Ae.scalarMultBase = Ae.scalarMult = Ae.SHARED_KEY_LENGTH = Ae.SECRET_KEY_LENGTH = Ae.PUBLIC_KEY_LENGTH = void 0;
  const t = random, Ie = wipe$1;
  Ae.PUBLIC_KEY_LENGTH = 32, Ae.SECRET_KEY_LENGTH = 32, Ae.SHARED_KEY_LENGTH = 32;
  function Be(Oi) {
    const Fi = new Float64Array(16);
    if (Oi)
      for (let Ui = 0; Ui < Oi.length; Ui++)
        Fi[Ui] = Oi[Ui];
    return Fi;
  }
  const Pe = new Uint8Array(32);
  Pe[0] = 9;
  const Te = Be([56129, 1]);
  function Me(Oi) {
    let Fi = 1;
    for (let Ui = 0; Ui < 16; Ui++) {
      let Pi = Oi[Ui] + Fi + 65535;
      Fi = Math.floor(Pi / 65536), Oi[Ui] = Pi - Fi * 65536;
    }
    Oi[0] += Fi - 1 + 37 * (Fi - 1);
  }
  function Ue(Oi, Fi, Ui) {
    const Pi = ~(Ui - 1);
    for (let Bi = 0; Bi < 16; Bi++) {
      const ji = Pi & (Oi[Bi] ^ Fi[Bi]);
      Oi[Bi] ^= ji, Fi[Bi] ^= ji;
    }
  }
  function je(Oi, Fi) {
    const Ui = Be(), Pi = Be();
    for (let Bi = 0; Bi < 16; Bi++)
      Pi[Bi] = Fi[Bi];
    Me(Pi), Me(Pi), Me(Pi);
    for (let Bi = 0; Bi < 2; Bi++) {
      Ui[0] = Pi[0] - 65517;
      for (let Zi = 1; Zi < 15; Zi++)
        Ui[Zi] = Pi[Zi] - 65535 - (Ui[Zi - 1] >> 16 & 1), Ui[Zi - 1] &= 65535;
      Ui[15] = Pi[15] - 32767 - (Ui[14] >> 16 & 1);
      const ji = Ui[15] >> 16 & 1;
      Ui[14] &= 65535, Ue(Pi, Ui, 1 - ji);
    }
    for (let Bi = 0; Bi < 16; Bi++)
      Oi[2 * Bi] = Pi[Bi] & 255, Oi[2 * Bi + 1] = Pi[Bi] >> 8;
  }
  function fn(Oi, Fi) {
    for (let Ui = 0; Ui < 16; Ui++)
      Oi[Ui] = Fi[2 * Ui] + (Fi[2 * Ui + 1] << 8);
    Oi[15] &= 32767;
  }
  function Ve(Oi, Fi, Ui) {
    for (let Pi = 0; Pi < 16; Pi++)
      Oi[Pi] = Fi[Pi] + Ui[Pi];
  }
  function vn(Oi, Fi, Ui) {
    for (let Pi = 0; Pi < 16; Pi++)
      Oi[Pi] = Fi[Pi] - Ui[Pi];
  }
  function En(Oi, Fi, Ui) {
    let Pi, Bi, ji = 0, Zi = 0, zi = 0, xi = 0, $i = 0, vi = 0, wi = 0, Ai = 0, Ri = 0, Ti = 0, Ci = 0, Ii = 0, Li = 0, Ni = 0, Vi = 0, is = 0, Ki = 0, ts = 0, qi = 0, Hi = 0, Xi = 0, ki = 0, Wi = 0, Yi = 0, Qi = 0, ns = 0, us = 0, ps = 0, Ds = 0, Eo = 0, hs = 0, So = Ui[0], _o = Ui[1], vo = Ui[2], Ro = Ui[3], $o = Ui[4], Io = Ui[5], To = Ui[6], Ao = Ui[7], Po = Ui[8], Co = Ui[9], rs = Ui[10], Gi = Ui[11], Ji = Ui[12], ss = Ui[13], ls = Ui[14], ds = Ui[15];
    Pi = Fi[0], ji += Pi * So, Zi += Pi * _o, zi += Pi * vo, xi += Pi * Ro, $i += Pi * $o, vi += Pi * Io, wi += Pi * To, Ai += Pi * Ao, Ri += Pi * Po, Ti += Pi * Co, Ci += Pi * rs, Ii += Pi * Gi, Li += Pi * Ji, Ni += Pi * ss, Vi += Pi * ls, is += Pi * ds, Pi = Fi[1], Zi += Pi * So, zi += Pi * _o, xi += Pi * vo, $i += Pi * Ro, vi += Pi * $o, wi += Pi * Io, Ai += Pi * To, Ri += Pi * Ao, Ti += Pi * Po, Ci += Pi * Co, Ii += Pi * rs, Li += Pi * Gi, Ni += Pi * Ji, Vi += Pi * ss, is += Pi * ls, Ki += Pi * ds, Pi = Fi[2], zi += Pi * So, xi += Pi * _o, $i += Pi * vo, vi += Pi * Ro, wi += Pi * $o, Ai += Pi * Io, Ri += Pi * To, Ti += Pi * Ao, Ci += Pi * Po, Ii += Pi * Co, Li += Pi * rs, Ni += Pi * Gi, Vi += Pi * Ji, is += Pi * ss, Ki += Pi * ls, ts += Pi * ds, Pi = Fi[3], xi += Pi * So, $i += Pi * _o, vi += Pi * vo, wi += Pi * Ro, Ai += Pi * $o, Ri += Pi * Io, Ti += Pi * To, Ci += Pi * Ao, Ii += Pi * Po, Li += Pi * Co, Ni += Pi * rs, Vi += Pi * Gi, is += Pi * Ji, Ki += Pi * ss, ts += Pi * ls, qi += Pi * ds, Pi = Fi[4], $i += Pi * So, vi += Pi * _o, wi += Pi * vo, Ai += Pi * Ro, Ri += Pi * $o, Ti += Pi * Io, Ci += Pi * To, Ii += Pi * Ao, Li += Pi * Po, Ni += Pi * Co, Vi += Pi * rs, is += Pi * Gi, Ki += Pi * Ji, ts += Pi * ss, qi += Pi * ls, Hi += Pi * ds, Pi = Fi[5], vi += Pi * So, wi += Pi * _o, Ai += Pi * vo, Ri += Pi * Ro, Ti += Pi * $o, Ci += Pi * Io, Ii += Pi * To, Li += Pi * Ao, Ni += Pi * Po, Vi += Pi * Co, is += Pi * rs, Ki += Pi * Gi, ts += Pi * Ji, qi += Pi * ss, Hi += Pi * ls, Xi += Pi * ds, Pi = Fi[6], wi += Pi * So, Ai += Pi * _o, Ri += Pi * vo, Ti += Pi * Ro, Ci += Pi * $o, Ii += Pi * Io, Li += Pi * To, Ni += Pi * Ao, Vi += Pi * Po, is += Pi * Co, Ki += Pi * rs, ts += Pi * Gi, qi += Pi * Ji, Hi += Pi * ss, Xi += Pi * ls, ki += Pi * ds, Pi = Fi[7], Ai += Pi * So, Ri += Pi * _o, Ti += Pi * vo, Ci += Pi * Ro, Ii += Pi * $o, Li += Pi * Io, Ni += Pi * To, Vi += Pi * Ao, is += Pi * Po, Ki += Pi * Co, ts += Pi * rs, qi += Pi * Gi, Hi += Pi * Ji, Xi += Pi * ss, ki += Pi * ls, Wi += Pi * ds, Pi = Fi[8], Ri += Pi * So, Ti += Pi * _o, Ci += Pi * vo, Ii += Pi * Ro, Li += Pi * $o, Ni += Pi * Io, Vi += Pi * To, is += Pi * Ao, Ki += Pi * Po, ts += Pi * Co, qi += Pi * rs, Hi += Pi * Gi, Xi += Pi * Ji, ki += Pi * ss, Wi += Pi * ls, Yi += Pi * ds, Pi = Fi[9], Ti += Pi * So, Ci += Pi * _o, Ii += Pi * vo, Li += Pi * Ro, Ni += Pi * $o, Vi += Pi * Io, is += Pi * To, Ki += Pi * Ao, ts += Pi * Po, qi += Pi * Co, Hi += Pi * rs, Xi += Pi * Gi, ki += Pi * Ji, Wi += Pi * ss, Yi += Pi * ls, Qi += Pi * ds, Pi = Fi[10], Ci += Pi * So, Ii += Pi * _o, Li += Pi * vo, Ni += Pi * Ro, Vi += Pi * $o, is += Pi * Io, Ki += Pi * To, ts += Pi * Ao, qi += Pi * Po, Hi += Pi * Co, Xi += Pi * rs, ki += Pi * Gi, Wi += Pi * Ji, Yi += Pi * ss, Qi += Pi * ls, ns += Pi * ds, Pi = Fi[11], Ii += Pi * So, Li += Pi * _o, Ni += Pi * vo, Vi += Pi * Ro, is += Pi * $o, Ki += Pi * Io, ts += Pi * To, qi += Pi * Ao, Hi += Pi * Po, Xi += Pi * Co, ki += Pi * rs, Wi += Pi * Gi, Yi += Pi * Ji, Qi += Pi * ss, ns += Pi * ls, us += Pi * ds, Pi = Fi[12], Li += Pi * So, Ni += Pi * _o, Vi += Pi * vo, is += Pi * Ro, Ki += Pi * $o, ts += Pi * Io, qi += Pi * To, Hi += Pi * Ao, Xi += Pi * Po, ki += Pi * Co, Wi += Pi * rs, Yi += Pi * Gi, Qi += Pi * Ji, ns += Pi * ss, us += Pi * ls, ps += Pi * ds, Pi = Fi[13], Ni += Pi * So, Vi += Pi * _o, is += Pi * vo, Ki += Pi * Ro, ts += Pi * $o, qi += Pi * Io, Hi += Pi * To, Xi += Pi * Ao, ki += Pi * Po, Wi += Pi * Co, Yi += Pi * rs, Qi += Pi * Gi, ns += Pi * Ji, us += Pi * ss, ps += Pi * ls, Ds += Pi * ds, Pi = Fi[14], Vi += Pi * So, is += Pi * _o, Ki += Pi * vo, ts += Pi * Ro, qi += Pi * $o, Hi += Pi * Io, Xi += Pi * To, ki += Pi * Ao, Wi += Pi * Po, Yi += Pi * Co, Qi += Pi * rs, ns += Pi * Gi, us += Pi * Ji, ps += Pi * ss, Ds += Pi * ls, Eo += Pi * ds, Pi = Fi[15], is += Pi * So, Ki += Pi * _o, ts += Pi * vo, qi += Pi * Ro, Hi += Pi * $o, Xi += Pi * Io, ki += Pi * To, Wi += Pi * Ao, Yi += Pi * Po, Qi += Pi * Co, ns += Pi * rs, us += Pi * Gi, ps += Pi * Ji, Ds += Pi * ss, Eo += Pi * ls, hs += Pi * ds, ji += 38 * Ki, Zi += 38 * ts, zi += 38 * qi, xi += 38 * Hi, $i += 38 * Xi, vi += 38 * ki, wi += 38 * Wi, Ai += 38 * Yi, Ri += 38 * Qi, Ti += 38 * ns, Ci += 38 * us, Ii += 38 * ps, Li += 38 * Ds, Ni += 38 * Eo, Vi += 38 * hs, Bi = 1, Pi = ji + Bi + 65535, Bi = Math.floor(Pi / 65536), ji = Pi - Bi * 65536, Pi = Zi + Bi + 65535, Bi = Math.floor(Pi / 65536), Zi = Pi - Bi * 65536, Pi = zi + Bi + 65535, Bi = Math.floor(Pi / 65536), zi = Pi - Bi * 65536, Pi = xi + Bi + 65535, Bi = Math.floor(Pi / 65536), xi = Pi - Bi * 65536, Pi = $i + Bi + 65535, Bi = Math.floor(Pi / 65536), $i = Pi - Bi * 65536, Pi = vi + Bi + 65535, Bi = Math.floor(Pi / 65536), vi = Pi - Bi * 65536, Pi = wi + Bi + 65535, Bi = Math.floor(Pi / 65536), wi = Pi - Bi * 65536, Pi = Ai + Bi + 65535, Bi = Math.floor(Pi / 65536), Ai = Pi - Bi * 65536, Pi = Ri + Bi + 65535, Bi = Math.floor(Pi / 65536), Ri = Pi - Bi * 65536, Pi = Ti + Bi + 65535, Bi = Math.floor(Pi / 65536), Ti = Pi - Bi * 65536, Pi = Ci + Bi + 65535, Bi = Math.floor(Pi / 65536), Ci = Pi - Bi * 65536, Pi = Ii + Bi + 65535, Bi = Math.floor(Pi / 65536), Ii = Pi - Bi * 65536, Pi = Li + Bi + 65535, Bi = Math.floor(Pi / 65536), Li = Pi - Bi * 65536, Pi = Ni + Bi + 65535, Bi = Math.floor(Pi / 65536), Ni = Pi - Bi * 65536, Pi = Vi + Bi + 65535, Bi = Math.floor(Pi / 65536), Vi = Pi - Bi * 65536, Pi = is + Bi + 65535, Bi = Math.floor(Pi / 65536), is = Pi - Bi * 65536, ji += Bi - 1 + 37 * (Bi - 1), Bi = 1, Pi = ji + Bi + 65535, Bi = Math.floor(Pi / 65536), ji = Pi - Bi * 65536, Pi = Zi + Bi + 65535, Bi = Math.floor(Pi / 65536), Zi = Pi - Bi * 65536, Pi = zi + Bi + 65535, Bi = Math.floor(Pi / 65536), zi = Pi - Bi * 65536, Pi = xi + Bi + 65535, Bi = Math.floor(Pi / 65536), xi = Pi - Bi * 65536, Pi = $i + Bi + 65535, Bi = Math.floor(Pi / 65536), $i = Pi - Bi * 65536, Pi = vi + Bi + 65535, Bi = Math.floor(Pi / 65536), vi = Pi - Bi * 65536, Pi = wi + Bi + 65535, Bi = Math.floor(Pi / 65536), wi = Pi - Bi * 65536, Pi = Ai + Bi + 65535, Bi = Math.floor(Pi / 65536), Ai = Pi - Bi * 65536, Pi = Ri + Bi + 65535, Bi = Math.floor(Pi / 65536), Ri = Pi - Bi * 65536, Pi = Ti + Bi + 65535, Bi = Math.floor(Pi / 65536), Ti = Pi - Bi * 65536, Pi = Ci + Bi + 65535, Bi = Math.floor(Pi / 65536), Ci = Pi - Bi * 65536, Pi = Ii + Bi + 65535, Bi = Math.floor(Pi / 65536), Ii = Pi - Bi * 65536, Pi = Li + Bi + 65535, Bi = Math.floor(Pi / 65536), Li = Pi - Bi * 65536, Pi = Ni + Bi + 65535, Bi = Math.floor(Pi / 65536), Ni = Pi - Bi * 65536, Pi = Vi + Bi + 65535, Bi = Math.floor(Pi / 65536), Vi = Pi - Bi * 65536, Pi = is + Bi + 65535, Bi = Math.floor(Pi / 65536), is = Pi - Bi * 65536, ji += Bi - 1 + 37 * (Bi - 1), Oi[0] = ji, Oi[1] = Zi, Oi[2] = zi, Oi[3] = xi, Oi[4] = $i, Oi[5] = vi, Oi[6] = wi, Oi[7] = Ai, Oi[8] = Ri, Oi[9] = Ti, Oi[10] = Ci, Oi[11] = Ii, Oi[12] = Li, Oi[13] = Ni, Oi[14] = Vi, Oi[15] = is;
  }
  function fi(Oi, Fi) {
    En(Oi, Fi, Fi);
  }
  function bi(Oi, Fi) {
    const Ui = Be();
    for (let Pi = 0; Pi < 16; Pi++)
      Ui[Pi] = Fi[Pi];
    for (let Pi = 253; Pi >= 0; Pi--)
      fi(Ui, Ui), Pi !== 2 && Pi !== 4 && En(Ui, Ui, Fi);
    for (let Pi = 0; Pi < 16; Pi++)
      Oi[Pi] = Ui[Pi];
  }
  function mi(Oi, Fi) {
    const Ui = new Uint8Array(32), Pi = new Float64Array(80), Bi = Be(), ji = Be(), Zi = Be(), zi = Be(), xi = Be(), $i = Be();
    for (let Ri = 0; Ri < 31; Ri++)
      Ui[Ri] = Oi[Ri];
    Ui[31] = Oi[31] & 127 | 64, Ui[0] &= 248, fn(Pi, Fi);
    for (let Ri = 0; Ri < 16; Ri++)
      ji[Ri] = Pi[Ri];
    Bi[0] = zi[0] = 1;
    for (let Ri = 254; Ri >= 0; --Ri) {
      const Ti = Ui[Ri >>> 3] >>> (Ri & 7) & 1;
      Ue(Bi, ji, Ti), Ue(Zi, zi, Ti), Ve(xi, Bi, Zi), vn(Bi, Bi, Zi), Ve(Zi, ji, zi), vn(ji, ji, zi), fi(zi, xi), fi($i, Bi), En(Bi, Zi, Bi), En(Zi, ji, xi), Ve(xi, Bi, Zi), vn(Bi, Bi, Zi), fi(ji, Bi), vn(Zi, zi, $i), En(Bi, Zi, Te), Ve(Bi, Bi, zi), En(Zi, Zi, Bi), En(Bi, zi, $i), En(zi, ji, Pi), fi(ji, xi), Ue(Bi, ji, Ti), Ue(Zi, zi, Ti);
    }
    for (let Ri = 0; Ri < 16; Ri++)
      Pi[Ri + 16] = Bi[Ri], Pi[Ri + 32] = Zi[Ri], Pi[Ri + 48] = ji[Ri], Pi[Ri + 64] = zi[Ri];
    const vi = Pi.subarray(32), wi = Pi.subarray(16);
    bi(vi, vi), En(wi, wi, vi);
    const Ai = new Uint8Array(32);
    return je(Ai, wi), Ai;
  }
  Ae.scalarMult = mi;
  function _i(Oi) {
    return mi(Oi, Pe);
  }
  Ae.scalarMultBase = _i;
  function Ei(Oi) {
    if (Oi.length !== Ae.SECRET_KEY_LENGTH)
      throw new Error(`x25519: seed must be ${Ae.SECRET_KEY_LENGTH} bytes`);
    const Fi = new Uint8Array(Oi);
    return {
      publicKey: _i(Fi),
      secretKey: Fi
    };
  }
  Ae.generateKeyPairFromSeed = Ei;
  function Si(Oi) {
    const Fi = (0, t.randomBytes)(32, Oi), Ui = Ei(Fi);
    return (0, Ie.wipe)(Fi), Ui;
  }
  Ae.generateKeyPair = Si;
  function Mi(Oi, Fi, Ui = !1) {
    if (Oi.length !== Ae.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect secret key length");
    if (Fi.length !== Ae.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect public key length");
    const Pi = mi(Oi, Fi);
    if (Ui) {
      let Bi = 0;
      for (let ji = 0; ji < Pi.length; ji++)
        Bi |= Pi[ji];
      if (Bi === 0)
        throw new Error("X25519: invalid shared key");
    }
    return Pi;
  }
  Ae.sharedKey = Mi;
})(x25519);
const C$2 = { waku: { publish: "waku_publish", batchPublish: "waku_batchPublish", subscribe: "waku_subscribe", batchSubscribe: "waku_batchSubscribe", subscription: "waku_subscription", unsubscribe: "waku_unsubscribe", batchUnsubscribe: "waku_batchUnsubscribe", batchFetchMessages: "waku_batchFetchMessages" }, irn: { publish: "irn_publish", batchPublish: "irn_batchPublish", subscribe: "irn_subscribe", batchSubscribe: "irn_batchSubscribe", subscription: "irn_subscription", unsubscribe: "irn_unsubscribe", batchUnsubscribe: "irn_batchUnsubscribe", batchFetchMessages: "irn_batchFetchMessages" }, iridium: { publish: "iridium_publish", batchPublish: "iridium_batchPublish", subscribe: "iridium_subscribe", batchSubscribe: "iridium_batchSubscribe", subscription: "iridium_subscription", unsubscribe: "iridium_unsubscribe", batchUnsubscribe: "iridium_batchUnsubscribe", batchFetchMessages: "iridium_batchFetchMessages" } }, H$1 = ":";
function re$2(Ae) {
  const [t, Ie] = Ae.split(H$1);
  return { namespace: t, reference: Ie };
}
function W$2(Ae, t) {
  return Ae.includes(":") ? [Ae] : t.chains || [];
}
var gt$3 = Object.defineProperty, Ke = Object.getOwnPropertySymbols, vt$2 = Object.prototype.hasOwnProperty, bt$2 = Object.prototype.propertyIsEnumerable, Le$1 = (Ae, t, Ie) => t in Ae ? gt$3(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, Fe = (Ae, t) => {
  for (var Ie in t || (t = {})) vt$2.call(t, Ie) && Le$1(Ae, Ie, t[Ie]);
  if (Ke) for (var Ie of Ke(t)) bt$2.call(t, Ie) && Le$1(Ae, Ie, t[Ie]);
  return Ae;
};
const qe = "ReactNative", y$1 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, He = "js";
function ce$1() {
  return typeof process$1$1 < "u" && typeof process$1$1.versions < "u" && typeof process$1$1.versions.node < "u";
}
function _$1() {
  return !getDocument_1() && !!getNavigator_1() && navigator.product === qe;
}
function V$3() {
  return !ce$1() && !!getNavigator_1() && !!getDocument_1();
}
function P$2() {
  return _$1() ? y$1.reactNative : ce$1() ? y$1.node : V$3() ? y$1.browser : y$1.unknown;
}
function Ot$2() {
  var Ae;
  try {
    return _$1() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (Ae = global.Application) == null ? void 0 : Ae.applicationId : void 0;
  } catch {
    return;
  }
}
function We$2(Ae, t) {
  let Ie = queryString.parse(Ae);
  return Ie = Fe(Fe({}, Ie), t), Ae = queryString.stringify(Ie), Ae;
}
function Nt$2() {
  return getWindowMetadata_1() || { name: "", description: "", url: "", icons: [""] };
}
function Je$1() {
  if (P$2() === y$1.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: Ie, Version: Be } = global.Platform;
    return [Ie, Be].join("-");
  }
  const Ae = detect();
  if (Ae === null) return "unknown";
  const t = Ae.os ? Ae.os.replace(" ", "").toLowerCase() : "unknown";
  return Ae.type === "browser" ? [t, Ae.name, Ae.version].join("-") : [t, Ae.version].join("-");
}
function ze() {
  var Ae;
  const t = P$2();
  return t === y$1.browser ? [t, ((Ae = getLocation_1()) == null ? void 0 : Ae.host) || "unknown"].join(":") : t;
}
function Ge(Ae, t, Ie) {
  const Be = Je$1(), Pe = ze();
  return [[Ae, t].join("-"), [He, Ie].join("-"), Be, Pe].join("/");
}
function $t$2({ protocol: Ae, version: t, relayUrl: Ie, sdkVersion: Be, auth: Pe, projectId: Te, useOnCloseEvent: Me, bundleId: Ue }) {
  const je = Ie.split("?"), fn = Ge(Ae, t, Be), Ve = { auth: Pe, ua: fn, projectId: Te, useOnCloseEvent: Me || void 0, origin: Ue || void 0 }, vn = We$2(je[1] || "", Ve);
  return je[0] + "?" + vn;
}
function $$2(Ae, t) {
  return Ae.filter((Ie) => t.includes(Ie)).length === Ae.length;
}
function Tt$2(Ae) {
  return Object.fromEntries(Ae.entries());
}
function Pt$2(Ae) {
  return new Map(Object.entries(Ae));
}
function _t$2(Ae = cjs$3.FIVE_MINUTES, t) {
  const Ie = cjs$3.toMiliseconds(Ae || cjs$3.FIVE_MINUTES);
  let Be, Pe, Te;
  return { resolve: (Me) => {
    Te && Be && (clearTimeout(Te), Be(Me));
  }, reject: (Me) => {
    Te && Pe && (clearTimeout(Te), Pe(Me));
  }, done: () => new Promise((Me, Ue) => {
    Te = setTimeout(() => {
      Ue(new Error(t));
    }, Ie), Be = Me, Pe = Ue;
  }) };
}
function kt$2(Ae, t, Ie) {
  return new Promise(async (Be, Pe) => {
    const Te = setTimeout(() => Pe(new Error(Ie)), t);
    try {
      const Me = await Ae;
      Be(Me);
    } catch (Me) {
      Pe(Me);
    }
    clearTimeout(Te);
  });
}
function ae$2(Ae, t) {
  if (typeof t == "string" && t.startsWith(`${Ae}:`)) return t;
  if (Ae.toLowerCase() === "topic") {
    if (typeof t != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${t}`;
  } else if (Ae.toLowerCase() === "id") {
    if (typeof t != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${t}`;
  }
  throw new Error(`Unknown expirer target type: ${Ae}`);
}
function Dt$2(Ae) {
  return ae$2("topic", Ae);
}
function xt$2(Ae) {
  return ae$2("id", Ae);
}
function Vt$2(Ae) {
  const [t, Ie] = Ae.split(":"), Be = { id: void 0, topic: void 0 };
  if (t === "topic" && typeof Ie == "string") Be.topic = Ie;
  else if (t === "id" && Number.isInteger(Number(Ie))) Be.id = Number(Ie);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${Ie}`);
  return Be;
}
function Mt$2(Ae, t) {
  return cjs$3.fromMiliseconds(Date.now() + cjs$3.toMiliseconds(Ae));
}
function Kt$2(Ae) {
  return Date.now() >= cjs$3.toMiliseconds(Ae);
}
function Lt$2(Ae, t) {
  return `${Ae}${t ? `:${t}` : ""}`;
}
function N(Ae = [], t = []) {
  return [.../* @__PURE__ */ new Set([...Ae, ...t])];
}
async function Ft$2({ id: Ae, topic: t, wcDeepLink: Ie }) {
  var Be;
  try {
    if (!Ie) return;
    const Pe = typeof Ie == "string" ? JSON.parse(Ie) : Ie, Te = Pe == null ? void 0 : Pe.href;
    if (typeof Te != "string") return;
    const Me = Xe$1(Te, Ae, t), Ue = P$2();
    if (Ue === y$1.browser) {
      if (!((Be = getDocument_1()) != null && Be.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      Me.startsWith("https://") || Me.startsWith("http://") ? window.open(Me, "_blank", "noreferrer noopener") : window.open(Me, en$1() ? "_blank" : "_self", "noreferrer noopener");
    } else Ue === y$1.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(Me);
  } catch (Pe) {
    console.error(Pe);
  }
}
function Xe$1(Ae, t, Ie) {
  const Be = `requestId=${t}&sessionTopic=${Ie}`;
  Ae.endsWith("/") && (Ae = Ae.slice(0, -1));
  let Pe = `${Ae}`;
  if (Ae.startsWith("https://t.me")) {
    const Te = Ae.includes("?") ? "&startapp=" : "?startapp=";
    Pe = `${Pe}${Te}${nn$1(Be, !0)}`;
  } else Pe = `${Pe}/wc?${Be}`;
  return Pe;
}
async function qt$2(Ae, t) {
  let Ie = "";
  try {
    if (V$3() && (Ie = localStorage.getItem(t), Ie)) return Ie;
    Ie = await Ae.getItem(t);
  } catch (Be) {
    console.error(Be);
  }
  return Ie;
}
function Bt$2(Ae, t) {
  if (!Ae.includes(t)) return null;
  const Ie = Ae.split(/([&,?,=])/), Be = Ie.indexOf(t);
  return Ie[Be + 2];
}
function Ht$2() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (Ae) => {
    const t = Math.random() * 16 | 0;
    return (Ae === "x" ? t : t & 3 | 8).toString(16);
  });
}
function Wt$2() {
  return typeof process$1$1 < "u" && process$1$1.env.IS_VITEST === "true";
}
function en$1() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function nn$1(Ae, t = !1) {
  const Ie = Buffer$3.from(Ae).toString("base64");
  return t ? Ie.replace(/[=]/g, "") : Ie;
}
function le$1(Ae) {
  return Buffer$3.from(Ae, "base64").toString("utf-8");
}
const Jt$2 = "https://rpc.walletconnect.org/v1";
async function tn$1(Ae, t, Ie, Be, Pe, Te) {
  switch (Ie.t) {
    case "eip191":
      return rn$1(Ae, t, Ie.s);
    case "eip1271":
      return await on$1(Ae, t, Ie.s, Be, Pe, Te);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${Ie.t}`);
  }
}
function rn$1(Ae, t, Ie) {
  return recoverAddress(hashMessage(t), Ie).toLowerCase() === Ae.toLowerCase();
}
async function on$1(Ae, t, Ie, Be, Pe, Te) {
  const Me = re$2(Be);
  if (!Me.namespace || !Me.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${Be}`);
  try {
    const Ue = "0x1626ba7e", je = "0000000000000000000000000000000000000000000000000000000000000040", fn = "0000000000000000000000000000000000000000000000000000000000000041", Ve = Ie.substring(2), vn = hashMessage(t).substring(2), En = Ue + vn + je + fn + Ve, fi = await fetch(`${Te || Jt$2}/?chainId=${Be}&projectId=${Pe}`, { method: "POST", body: JSON.stringify({ id: zt$2(), jsonrpc: "2.0", method: "eth_call", params: [{ to: Ae, data: En }, "latest"] }) }), { result: bi } = await fi.json();
    return bi ? bi.slice(0, Ue.length).toLowerCase() === Ue.toLowerCase() : !1;
  } catch (Ue) {
    return console.error("isValidEip1271Signature: ", Ue), !1;
  }
}
function zt$2() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
var Gt$2 = Object.defineProperty, Yt$2 = Object.defineProperties, Qt$2 = Object.getOwnPropertyDescriptors, sn$1 = Object.getOwnPropertySymbols, Zt$2 = Object.prototype.hasOwnProperty, Xt$2 = Object.prototype.propertyIsEnumerable, cn$1 = (Ae, t, Ie) => t in Ae ? Gt$2(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, de$1 = (Ae, t) => {
  for (var Ie in t || (t = {})) Zt$2.call(t, Ie) && cn$1(Ae, Ie, t[Ie]);
  if (sn$1) for (var Ie of sn$1(t)) Xt$2.call(t, Ie) && cn$1(Ae, Ie, t[Ie]);
  return Ae;
}, an$1 = (Ae, t) => Yt$2(Ae, Qt$2(t));
const er$2 = "did:pkh:", z$4 = (Ae) => Ae == null ? void 0 : Ae.split(":"), un$1 = (Ae) => {
  const t = Ae && z$4(Ae);
  if (t) return Ae.includes(er$2) ? t[3] : t[1];
}, ln$1 = (Ae) => {
  const t = Ae && z$4(Ae);
  if (t) return t[2] + ":" + t[3];
}, fe$2 = (Ae) => {
  const t = Ae && z$4(Ae);
  if (t) return t.pop();
};
async function nr$2(Ae) {
  const { cacao: t, projectId: Ie } = Ae, { s: Be, p: Pe } = t, Te = dn$1(Pe, Pe.iss), Me = fe$2(Pe.iss);
  return await tn$1(Me, Te, Be, ln$1(Pe.iss), Ie);
}
const dn$1 = (Ae, t) => {
  const Ie = `${Ae.domain} wants you to sign in with your Ethereum account:`, Be = fe$2(t);
  if (!Ae.aud && !Ae.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let Pe = Ae.statement || void 0;
  const Te = `URI: ${Ae.aud || Ae.uri}`, Me = `Version: ${Ae.version}`, Ue = `Chain ID: ${un$1(t)}`, je = `Nonce: ${Ae.nonce}`, fn = `Issued At: ${Ae.iat}`, Ve = Ae.exp ? `Expiration Time: ${Ae.exp}` : void 0, vn = Ae.nbf ? `Not Before: ${Ae.nbf}` : void 0, En = Ae.requestId ? `Request ID: ${Ae.requestId}` : void 0, fi = Ae.resources ? `Resources:${Ae.resources.map((mi) => `
- ${mi}`).join("")}` : void 0, bi = Y$2(Ae.resources);
  if (bi) {
    const mi = R$2(bi);
    Pe = he$1(Pe, mi);
  }
  return [Ie, Be, "", Pe, "", Te, Me, Ue, je, fn, Ve, vn, En, fi].filter((mi) => mi != null).join(`
`);
};
function hn$1(Ae) {
  return Buffer$3.from(JSON.stringify(Ae)).toString("base64");
}
function yn$1(Ae) {
  return JSON.parse(Buffer$3.from(Ae, "base64").toString("utf-8"));
}
function O$3(Ae) {
  if (!Ae) throw new Error("No recap provided, value is undefined");
  if (!Ae.att) throw new Error("No `att` property found");
  const t = Object.keys(Ae.att);
  if (!(t != null && t.length)) throw new Error("No resources found in `att` property");
  t.forEach((Ie) => {
    const Be = Ae.att[Ie];
    if (Array.isArray(Be)) throw new Error(`Resource must be an object: ${Ie}`);
    if (typeof Be != "object") throw new Error(`Resource must be an object: ${Ie}`);
    if (!Object.keys(Be).length) throw new Error(`Resource object is empty: ${Ie}`);
    Object.keys(Be).forEach((Pe) => {
      const Te = Be[Pe];
      if (!Array.isArray(Te)) throw new Error(`Ability limits ${Pe} must be an array of objects, found: ${Te}`);
      if (!Te.length) throw new Error(`Value of ${Pe} is empty array, must be an array with objects`);
      Te.forEach((Me) => {
        if (typeof Me != "object") throw new Error(`Ability limits (${Pe}) must be an array of objects, found: ${Me}`);
      });
    });
  });
}
function gn$1(Ae, t, Ie, Be = {}) {
  return Ie == null || Ie.sort((Pe, Te) => Pe.localeCompare(Te)), { att: { [Ae]: pe$1(t, Ie, Be) } };
}
function pe$1(Ae, t, Ie = {}) {
  t = t == null ? void 0 : t.sort((Pe, Te) => Pe.localeCompare(Te));
  const Be = t.map((Pe) => ({ [`${Ae}/${Pe}`]: [Ie] }));
  return Object.assign({}, ...Be);
}
function G$1(Ae) {
  return O$3(Ae), `urn:recap:${hn$1(Ae).replace(/=/g, "")}`;
}
function R$2(Ae) {
  const t = yn$1(Ae.replace("urn:recap:", ""));
  return O$3(t), t;
}
function ir$2(Ae, t, Ie) {
  const Be = gn$1(Ae, t, Ie);
  return G$1(Be);
}
function me$3(Ae) {
  return Ae && Ae.includes("urn:recap:");
}
function cr$2(Ae, t) {
  const Ie = R$2(Ae), Be = R$2(t), Pe = bn$1(Ie, Be);
  return G$1(Pe);
}
function bn$1(Ae, t) {
  O$3(Ae), O$3(t);
  const Ie = Object.keys(Ae.att).concat(Object.keys(t.att)).sort((Pe, Te) => Pe.localeCompare(Te)), Be = { att: {} };
  return Ie.forEach((Pe) => {
    var Te, Me;
    Object.keys(((Te = Ae.att) == null ? void 0 : Te[Pe]) || {}).concat(Object.keys(((Me = t.att) == null ? void 0 : Me[Pe]) || {})).sort((Ue, je) => Ue.localeCompare(je)).forEach((Ue) => {
      var je, fn;
      Be.att[Pe] = an$1(de$1({}, Be.att[Pe]), { [Ue]: ((je = Ae.att[Pe]) == null ? void 0 : je[Ue]) || ((fn = t.att[Pe]) == null ? void 0 : fn[Ue]) });
    });
  }), Be;
}
function he$1(Ae = "", t) {
  O$3(t);
  const Ie = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (Ae.includes(Ie)) return Ae;
  const Be = [];
  let Pe = 0;
  Object.keys(t.att).forEach((Ue) => {
    const je = Object.keys(t.att[Ue]).map((vn) => ({ ability: vn.split("/")[0], action: vn.split("/")[1] }));
    je.sort((vn, En) => vn.action.localeCompare(En.action));
    const fn = {};
    je.forEach((vn) => {
      fn[vn.ability] || (fn[vn.ability] = []), fn[vn.ability].push(vn.action);
    });
    const Ve = Object.keys(fn).map((vn) => (Pe++, `(${Pe}) '${vn}': '${fn[vn].join("', '")}' for '${Ue}'.`));
    Be.push(Ve.join(", ").replace(".,", "."));
  });
  const Te = Be.join(" "), Me = `${Ie}${Te}`;
  return `${Ae ? Ae + " " : ""}${Me}`;
}
function ar$2(Ae) {
  var t;
  const Ie = R$2(Ae);
  O$3(Ie);
  const Be = (t = Ie.att) == null ? void 0 : t.eip155;
  return Be ? Object.keys(Be).map((Pe) => Pe.split("/")[1]) : [];
}
function ur$2(Ae) {
  const t = R$2(Ae);
  O$3(t);
  const Ie = [];
  return Object.values(t.att).forEach((Be) => {
    Object.values(Be).forEach((Pe) => {
      var Te;
      (Te = Pe == null ? void 0 : Pe[0]) != null && Te.chains && Ie.push(Pe[0].chains);
    });
  }), [...new Set(Ie.flat())];
}
function Y$2(Ae) {
  if (!Ae) return;
  const t = Ae == null ? void 0 : Ae[Ae.length - 1];
  return me$3(t) ? t : void 0;
}
const ye$3 = "base10", g$1 = "base16", ge$1 = "base64pad", lr$2 = "base64url", k$1 = "utf8", ve$1 = 0, D$2 = 1, M$2 = 2, dr$2 = 0, wn = 1, K$2 = 12, be$3 = 32;
function fr$2() {
  const Ae = x25519.generateKeyPair();
  return { privateKey: toString(Ae.secretKey, g$1), publicKey: toString(Ae.publicKey, g$1) };
}
function pr$2() {
  const Ae = random.randomBytes(be$3);
  return toString(Ae, g$1);
}
function mr$2(Ae, t) {
  const Ie = x25519.sharedKey(fromString(Ae, g$1), fromString(t, g$1), !0), Be = new HKDF_1(sha256.SHA256, Ie).expand(be$3);
  return toString(Be, g$1);
}
function hr$2(Ae) {
  const t = sha256.hash(fromString(Ae, g$1));
  return toString(t, g$1);
}
function yr$2(Ae) {
  const t = sha256.hash(fromString(Ae, k$1));
  return toString(t, g$1);
}
function Ee$2(Ae) {
  return fromString(`${Ae}`, ye$3);
}
function A(Ae) {
  return Number(toString(Ae, ye$3));
}
function gr$2(Ae) {
  const t = Ee$2(typeof Ae.type < "u" ? Ae.type : ve$1);
  if (A(t) === D$2 && typeof Ae.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const Ie = typeof Ae.senderPublicKey < "u" ? fromString(Ae.senderPublicKey, g$1) : void 0, Be = typeof Ae.iv < "u" ? fromString(Ae.iv, g$1) : random.randomBytes(K$2), Pe = new chacha20poly1305.ChaCha20Poly1305(fromString(Ae.symKey, g$1)).seal(Be, fromString(Ae.message, k$1));
  return we$3({ type: t, sealed: Pe, iv: Be, senderPublicKey: Ie, encoding: Ae.encoding });
}
function vr$2(Ae, t) {
  const Ie = Ee$2(M$2), Be = random.randomBytes(K$2), Pe = fromString(Ae, k$1);
  return we$3({ type: Ie, sealed: Pe, iv: Be, encoding: t });
}
function br$2(Ae) {
  const t = new chacha20poly1305.ChaCha20Poly1305(fromString(Ae.symKey, g$1)), { sealed: Ie, iv: Be } = Q$1({ encoded: Ae.encoded, encoding: Ae == null ? void 0 : Ae.encoding }), Pe = t.open(Be, Ie);
  if (Pe === null) throw new Error("Failed to decrypt");
  return toString(Pe, k$1);
}
function Er$2(Ae, t) {
  const { sealed: Ie } = Q$1({ encoded: Ae, encoding: t });
  return toString(Ie, k$1);
}
function we$3(Ae) {
  const { encoding: t = ge$1 } = Ae;
  if (A(Ae.type) === M$2) return toString(concat$1([Ae.type, Ae.sealed]), t);
  if (A(Ae.type) === D$2) {
    if (typeof Ae.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat$1([Ae.type, Ae.senderPublicKey, Ae.iv, Ae.sealed]), t);
  }
  return toString(concat$1([Ae.type, Ae.iv, Ae.sealed]), t);
}
function Q$1(Ae) {
  const { encoded: t, encoding: Ie = ge$1 } = Ae, Be = fromString(t, Ie), Pe = Be.slice(dr$2, wn), Te = wn;
  if (A(Pe) === D$2) {
    const fn = Te + be$3, Ve = fn + K$2, vn = Be.slice(Te, fn), En = Be.slice(fn, Ve), fi = Be.slice(Ve);
    return { type: Pe, sealed: fi, iv: En, senderPublicKey: vn };
  }
  if (A(Pe) === M$2) {
    const fn = Be.slice(Te), Ve = random.randomBytes(K$2);
    return { type: Pe, sealed: fn, iv: Ve };
  }
  const Me = Te + K$2, Ue = Be.slice(Te, Me), je = Be.slice(Me);
  return { type: Pe, sealed: je, iv: Ue };
}
function wr$2(Ae, t) {
  const Ie = Q$1({ encoded: Ae, encoding: t == null ? void 0 : t.encoding });
  return On({ type: A(Ie.type), senderPublicKey: typeof Ie.senderPublicKey < "u" ? toString(Ie.senderPublicKey, g$1) : void 0, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey });
}
function On(Ae) {
  const t = (Ae == null ? void 0 : Ae.type) || ve$1;
  if (t === D$2) {
    if (typeof (Ae == null ? void 0 : Ae.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (Ae == null ? void 0 : Ae.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: t, senderPublicKey: Ae == null ? void 0 : Ae.senderPublicKey, receiverPublicKey: Ae == null ? void 0 : Ae.receiverPublicKey };
}
function Or$2(Ae) {
  return Ae.type === D$2 && typeof Ae.senderPublicKey == "string" && typeof Ae.receiverPublicKey == "string";
}
function Nr$2(Ae) {
  return Ae.type === M$2;
}
function Nn(Ae) {
  return new ellipticExports.ec("p256").keyFromPublic({ x: Buffer$3.from(Ae.x, "base64").toString("hex"), y: Buffer$3.from(Ae.y, "base64").toString("hex") }, "hex");
}
function Sr$2(Ae) {
  let t = Ae.replace(/-/g, "+").replace(/_/g, "/");
  const Ie = t.length % 4;
  return Ie > 0 && (t += "=".repeat(4 - Ie)), t;
}
function $r$2(Ae) {
  return Buffer$3.from(Sr$2(Ae), "base64");
}
function Rr$2(Ae, t) {
  const [Ie, Be, Pe] = Ae.split("."), Te = $r$2(Pe);
  if (Te.length !== 64) throw new Error("Invalid signature length");
  const Me = Te.slice(0, 32).toString("hex"), Ue = Te.slice(32, 64).toString("hex"), je = `${Ie}.${Be}`, fn = new sha256.SHA256().update(Buffer$3.from(je)).digest(), Ve = Nn(t), vn = Buffer$3.from(fn).toString("hex");
  if (!Ve.verify(vn, { r: Me, s: Ue })) throw new Error("Invalid signature");
  return decodeJWT(Ae).payload;
}
const Sn = "irn";
function Ir$1(Ae) {
  return (Ae == null ? void 0 : Ae.relay) || { protocol: Sn };
}
function jr$1(Ae) {
  const t = C$2[Ae];
  if (typeof t > "u") throw new Error(`Relay Protocol not supported: ${Ae}`);
  return t;
}
var Tr$2 = Object.defineProperty, Pr$2 = Object.defineProperties, Ar$2 = Object.getOwnPropertyDescriptors, $n = Object.getOwnPropertySymbols, Cr$2 = Object.prototype.hasOwnProperty, Ur$1 = Object.prototype.propertyIsEnumerable, Rn = (Ae, t, Ie) => t in Ae ? Tr$2(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, In = (Ae, t) => {
  for (var Ie in t || (t = {})) Cr$2.call(t, Ie) && Rn(Ae, Ie, t[Ie]);
  if ($n) for (var Ie of $n(t)) Ur$1.call(t, Ie) && Rn(Ae, Ie, t[Ie]);
  return Ae;
}, _r$2 = (Ae, t) => Pr$2(Ae, Ar$2(t));
function jn(Ae, t = "-") {
  const Ie = {}, Be = "relay" + t;
  return Object.keys(Ae).forEach((Pe) => {
    if (Pe.startsWith(Be)) {
      const Te = Pe.replace(Be, ""), Me = Ae[Pe];
      Ie[Te] = Me;
    }
  }), Ie;
}
function kr$1(Ae) {
  if (!Ae.includes("wc:")) {
    const je = le$1(Ae);
    je != null && je.includes("wc:") && (Ae = je);
  }
  Ae = Ae.includes("wc://") ? Ae.replace("wc://", "") : Ae, Ae = Ae.includes("wc:") ? Ae.replace("wc:", "") : Ae;
  const t = Ae.indexOf(":"), Ie = Ae.indexOf("?") !== -1 ? Ae.indexOf("?") : void 0, Be = Ae.substring(0, t), Pe = Ae.substring(t + 1, Ie).split("@"), Te = typeof Ie < "u" ? Ae.substring(Ie) : "", Me = queryString.parse(Te), Ue = typeof Me.methods == "string" ? Me.methods.split(",") : void 0;
  return { protocol: Be, topic: Tn(Pe[0]), version: parseInt(Pe[1], 10), symKey: Me.symKey, relay: jn(Me), methods: Ue, expiryTimestamp: Me.expiryTimestamp ? parseInt(Me.expiryTimestamp, 10) : void 0 };
}
function Tn(Ae) {
  return Ae.startsWith("//") ? Ae.substring(2) : Ae;
}
function Pn(Ae, t = "-") {
  const Ie = "relay", Be = {};
  return Object.keys(Ae).forEach((Pe) => {
    const Te = Ie + t + Pe;
    Ae[Pe] && (Be[Te] = Ae[Pe]);
  }), Be;
}
function Dr$2(Ae) {
  return `${Ae.protocol}:${Ae.topic}@${Ae.version}?` + queryString.stringify(In(_r$2(In({ symKey: Ae.symKey }, Pn(Ae.relay)), { expiryTimestamp: Ae.expiryTimestamp }), Ae.methods ? { methods: Ae.methods.join(",") } : {}));
}
function xr$2(Ae, t, Ie) {
  return `${Ae}?wc_ev=${Ie}&topic=${t}`;
}
var Vr$1 = Object.defineProperty, Mr$1 = Object.defineProperties, Kr$1 = Object.getOwnPropertyDescriptors, An = Object.getOwnPropertySymbols, Lr$1 = Object.prototype.hasOwnProperty, Fr$2 = Object.prototype.propertyIsEnumerable, Cn = (Ae, t, Ie) => t in Ae ? Vr$1(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, qr$1 = (Ae, t) => {
  for (var Ie in t || (t = {})) Lr$1.call(t, Ie) && Cn(Ae, Ie, t[Ie]);
  if (An) for (var Ie of An(t)) Fr$2.call(t, Ie) && Cn(Ae, Ie, t[Ie]);
  return Ae;
}, Br$2 = (Ae, t) => Mr$1(Ae, Kr$1(t));
function C$1(Ae) {
  const t = [];
  return Ae.forEach((Ie) => {
    const [Be, Pe] = Ie.split(":");
    t.push(`${Be}:${Pe}`);
  }), t;
}
function Un(Ae) {
  const t = [];
  return Object.values(Ae).forEach((Ie) => {
    t.push(...C$1(Ie.accounts));
  }), t;
}
function _n(Ae, t) {
  const Ie = [];
  return Object.values(Ae).forEach((Be) => {
    C$1(Be.accounts).includes(t) && Ie.push(...Be.methods);
  }), Ie;
}
function kn(Ae, t) {
  const Ie = [];
  return Object.values(Ae).forEach((Be) => {
    C$1(Be.accounts).includes(t) && Ie.push(...Be.events);
  }), Ie;
}
function Wr$1(Ae) {
  const { proposal: { requiredNamespaces: t, optionalNamespaces: Ie = {} }, supportedNamespaces: Be } = Ae, Pe = Ne(t), Te = Ne(Ie), Me = {};
  Object.keys(Be).forEach((fn) => {
    const Ve = Be[fn].chains, vn = Be[fn].methods, En = Be[fn].events, fi = Be[fn].accounts;
    Ve.forEach((bi) => {
      if (!fi.some((mi) => mi.includes(bi))) throw new Error(`No accounts provided for chain ${bi} in namespace ${fn}`);
    }), Me[fn] = { chains: Ve, methods: vn, events: En, accounts: fi };
  });
  const Ue = zn(t, Me, "approve()");
  if (Ue) throw new Error(Ue.message);
  const je = {};
  return !Object.keys(t).length && !Object.keys(Ie).length ? Me : (Object.keys(Pe).forEach((fn) => {
    const Ve = Be[fn].chains.filter((bi) => {
      var mi, _i;
      return (_i = (mi = Pe[fn]) == null ? void 0 : mi.chains) == null ? void 0 : _i.includes(bi);
    }), vn = Be[fn].methods.filter((bi) => {
      var mi, _i;
      return (_i = (mi = Pe[fn]) == null ? void 0 : mi.methods) == null ? void 0 : _i.includes(bi);
    }), En = Be[fn].events.filter((bi) => {
      var mi, _i;
      return (_i = (mi = Pe[fn]) == null ? void 0 : mi.events) == null ? void 0 : _i.includes(bi);
    }), fi = Ve.map((bi) => Be[fn].accounts.filter((mi) => mi.includes(`${bi}:`))).flat();
    je[fn] = { chains: Ve, methods: vn, events: En, accounts: fi };
  }), Object.keys(Te).forEach((fn) => {
    var Ve, vn, En, fi, bi, mi;
    if (!Be[fn]) return;
    const _i = (vn = (Ve = Te[fn]) == null ? void 0 : Ve.chains) == null ? void 0 : vn.filter((Oi) => Be[fn].chains.includes(Oi)), Ei = Be[fn].methods.filter((Oi) => {
      var Fi, Ui;
      return (Ui = (Fi = Te[fn]) == null ? void 0 : Fi.methods) == null ? void 0 : Ui.includes(Oi);
    }), Si = Be[fn].events.filter((Oi) => {
      var Fi, Ui;
      return (Ui = (Fi = Te[fn]) == null ? void 0 : Fi.events) == null ? void 0 : Ui.includes(Oi);
    }), Mi = _i == null ? void 0 : _i.map((Oi) => Be[fn].accounts.filter((Fi) => Fi.includes(`${Oi}:`))).flat();
    je[fn] = { chains: N((En = je[fn]) == null ? void 0 : En.chains, _i), methods: N((fi = je[fn]) == null ? void 0 : fi.methods, Ei), events: N((bi = je[fn]) == null ? void 0 : bi.events, Si), accounts: N((mi = je[fn]) == null ? void 0 : mi.accounts, Mi) };
  }), je);
}
function Oe(Ae) {
  return Ae.includes(":");
}
function Dn$1(Ae) {
  return Oe(Ae) ? Ae.split(":")[0] : Ae;
}
function Ne(Ae) {
  var t, Ie, Be;
  const Pe = {};
  if (!Z$3(Ae)) return Pe;
  for (const [Te, Me] of Object.entries(Ae)) {
    const Ue = Oe(Te) ? [Te] : Me.chains, je = Me.methods || [], fn = Me.events || [], Ve = Dn$1(Te);
    Pe[Ve] = Br$2(qr$1({}, Pe[Ve]), { chains: N(Ue, (t = Pe[Ve]) == null ? void 0 : t.chains), methods: N(je, (Ie = Pe[Ve]) == null ? void 0 : Ie.methods), events: N(fn, (Be = Pe[Ve]) == null ? void 0 : Be.events) });
  }
  return Pe;
}
function xn(Ae) {
  const t = {};
  return Ae == null || Ae.forEach((Ie) => {
    const [Be, Pe] = Ie.split(":");
    t[Be] || (t[Be] = { accounts: [], chains: [], events: [] }), t[Be].accounts.push(Ie), t[Be].chains.push(`${Be}:${Pe}`);
  }), t;
}
function Jr$1(Ae, t) {
  t = t.map((Be) => Be.replace("did:pkh:", ""));
  const Ie = xn(t);
  for (const [Be, Pe] of Object.entries(Ie)) Pe.methods ? Pe.methods = N(Pe.methods, Ae) : Pe.methods = Ae, Pe.events = ["chainChanged", "accountsChanged"];
  return Ie;
}
const Vn = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, Mn = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function S$4(Ae, t) {
  const { message: Ie, code: Be } = Mn[Ae];
  return { message: t ? `${Ie} ${t}` : Ie, code: Be };
}
function U$2(Ae, t) {
  const { message: Ie, code: Be } = Vn[Ae];
  return { message: t ? `${Ie} ${t}` : Ie, code: Be };
}
function L$2(Ae, t) {
  return !!Array.isArray(Ae);
}
function Z$3(Ae) {
  return Object.getPrototypeOf(Ae) === Object.prototype && Object.keys(Ae).length;
}
function I$3(Ae) {
  return typeof Ae > "u";
}
function b$2(Ae, t) {
  return t && I$3(Ae) ? !0 : typeof Ae == "string" && !!Ae.trim().length;
}
function X$1(Ae, t) {
  return typeof Ae == "number" && !isNaN(Ae);
}
function zr$2(Ae, t) {
  const { requiredNamespaces: Ie } = t, Be = Object.keys(Ae.namespaces), Pe = Object.keys(Ie);
  let Te = !0;
  return $$2(Pe, Be) ? (Be.forEach((Me) => {
    const { accounts: Ue, methods: je, events: fn } = Ae.namespaces[Me], Ve = C$1(Ue), vn = Ie[Me];
    (!$$2(W$2(Me, vn), Ve) || !$$2(vn.methods, je) || !$$2(vn.events, fn)) && (Te = !1);
  }), Te) : !1;
}
function F$2(Ae) {
  return b$2(Ae, !1) && Ae.includes(":") ? Ae.split(":").length === 2 : !1;
}
function Kn(Ae) {
  if (b$2(Ae, !1) && Ae.includes(":")) {
    const t = Ae.split(":");
    if (t.length === 3) {
      const Ie = t[0] + ":" + t[1];
      return !!t[2] && F$2(Ie);
    }
  }
  return !1;
}
function Gr$1(Ae) {
  function t(Ie) {
    try {
      return typeof new URL(Ie) < "u";
    } catch {
      return !1;
    }
  }
  try {
    if (b$2(Ae, !1)) {
      if (t(Ae)) return !0;
      const Ie = le$1(Ae);
      return t(Ie);
    }
  } catch {
  }
  return !1;
}
function Yr$1(Ae) {
  var t;
  return (t = Ae == null ? void 0 : Ae.proposer) == null ? void 0 : t.publicKey;
}
function Qr$1(Ae) {
  return Ae == null ? void 0 : Ae.topic;
}
function Zr$1(Ae, t) {
  let Ie = null;
  return b$2(Ae == null ? void 0 : Ae.publicKey, !1) || (Ie = S$4("MISSING_OR_INVALID", `${t} controller public key should be a string`)), Ie;
}
function Se(Ae) {
  let t = !0;
  return L$2(Ae) ? Ae.length && (t = Ae.every((Ie) => b$2(Ie, !1))) : t = !1, t;
}
function Ln(Ae, t, Ie) {
  let Be = null;
  return L$2(t) && t.length ? t.forEach((Pe) => {
    Be || F$2(Pe) || (Be = U$2("UNSUPPORTED_CHAINS", `${Ie}, chain ${Pe} should be a string and conform to "namespace:chainId" format`));
  }) : F$2(Ae) || (Be = U$2("UNSUPPORTED_CHAINS", `${Ie}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), Be;
}
function Fn(Ae, t, Ie) {
  let Be = null;
  return Object.entries(Ae).forEach(([Pe, Te]) => {
    if (Be) return;
    const Me = Ln(Pe, W$2(Pe, Te), `${t} ${Ie}`);
    Me && (Be = Me);
  }), Be;
}
function qn(Ae, t) {
  let Ie = null;
  return L$2(Ae) ? Ae.forEach((Be) => {
    Ie || Kn(Be) || (Ie = U$2("UNSUPPORTED_ACCOUNTS", `${t}, account ${Be} should be a string and conform to "namespace:chainId:address" format`));
  }) : Ie = U$2("UNSUPPORTED_ACCOUNTS", `${t}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), Ie;
}
function Bn(Ae, t) {
  let Ie = null;
  return Object.values(Ae).forEach((Be) => {
    if (Ie) return;
    const Pe = qn(Be == null ? void 0 : Be.accounts, `${t} namespace`);
    Pe && (Ie = Pe);
  }), Ie;
}
function Hn(Ae, t) {
  let Ie = null;
  return Se(Ae == null ? void 0 : Ae.methods) ? Se(Ae == null ? void 0 : Ae.events) || (Ie = U$2("UNSUPPORTED_EVENTS", `${t}, events should be an array of strings or empty array for no events`)) : Ie = U$2("UNSUPPORTED_METHODS", `${t}, methods should be an array of strings or empty array for no methods`), Ie;
}
function $e(Ae, t) {
  let Ie = null;
  return Object.values(Ae).forEach((Be) => {
    if (Ie) return;
    const Pe = Hn(Be, `${t}, namespace`);
    Pe && (Ie = Pe);
  }), Ie;
}
function Xr$1(Ae, t, Ie) {
  let Be = null;
  if (Ae && Z$3(Ae)) {
    const Pe = $e(Ae, t);
    Pe && (Be = Pe);
    const Te = Fn(Ae, t, Ie);
    Te && (Be = Te);
  } else Be = S$4("MISSING_OR_INVALID", `${t}, ${Ie} should be an object with data`);
  return Be;
}
function Wn(Ae, t) {
  let Ie = null;
  if (Ae && Z$3(Ae)) {
    const Be = $e(Ae, t);
    Be && (Ie = Be);
    const Pe = Bn(Ae, t);
    Pe && (Ie = Pe);
  } else Ie = S$4("MISSING_OR_INVALID", `${t}, namespaces should be an object with data`);
  return Ie;
}
function Jn(Ae) {
  return b$2(Ae.protocol, !0);
}
function eo(Ae, t) {
  let Ie = !1;
  return Ae ? Ae && L$2(Ae) && Ae.length && Ae.forEach((Be) => {
    Ie = Jn(Be);
  }) : Ie = !0, Ie;
}
function no(Ae) {
  return typeof Ae == "number";
}
function to(Ae) {
  return typeof Ae < "u" && typeof Ae !== null;
}
function ro(Ae) {
  return !(!Ae || typeof Ae != "object" || !Ae.code || !X$1(Ae.code) || !Ae.message || !b$2(Ae.message, !1));
}
function oo(Ae) {
  return !(I$3(Ae) || !b$2(Ae.method, !1));
}
function so(Ae) {
  return !(I$3(Ae) || I$3(Ae.result) && I$3(Ae.error) || !X$1(Ae.id) || !b$2(Ae.jsonrpc, !1));
}
function io(Ae) {
  return !(I$3(Ae) || !b$2(Ae.name, !1));
}
function co(Ae, t) {
  return !(!F$2(t) || !Un(Ae).includes(t));
}
function ao(Ae, t, Ie) {
  return b$2(Ie, !1) ? _n(Ae, t).includes(Ie) : !1;
}
function uo(Ae, t, Ie) {
  return b$2(Ie, !1) ? kn(Ae, t).includes(Ie) : !1;
}
function zn(Ae, t, Ie) {
  let Be = null;
  const Pe = lo(Ae), Te = fo(t), Me = Object.keys(Pe), Ue = Object.keys(Te), je = Gn(Object.keys(Ae)), fn = Gn(Object.keys(t)), Ve = je.filter((vn) => !fn.includes(vn));
  return Ve.length && (Be = S$4("NON_CONFORMING_NAMESPACES", `${Ie} namespaces keys don't satisfy requiredNamespaces.
      Required: ${Ve.toString()}
      Received: ${Object.keys(t).toString()}`)), $$2(Me, Ue) || (Be = S$4("NON_CONFORMING_NAMESPACES", `${Ie} namespaces chains don't satisfy required namespaces.
      Required: ${Me.toString()}
      Approved: ${Ue.toString()}`)), Object.keys(t).forEach((vn) => {
    if (!vn.includes(":") || Be) return;
    const En = C$1(t[vn].accounts);
    En.includes(vn) || (Be = S$4("NON_CONFORMING_NAMESPACES", `${Ie} namespaces accounts don't satisfy namespace accounts for ${vn}
        Required: ${vn}
        Approved: ${En.toString()}`));
  }), Me.forEach((vn) => {
    Be || ($$2(Pe[vn].methods, Te[vn].methods) ? $$2(Pe[vn].events, Te[vn].events) || (Be = S$4("NON_CONFORMING_NAMESPACES", `${Ie} namespaces events don't satisfy namespace events for ${vn}`)) : Be = S$4("NON_CONFORMING_NAMESPACES", `${Ie} namespaces methods don't satisfy namespace methods for ${vn}`));
  }), Be;
}
function lo(Ae) {
  const t = {};
  return Object.keys(Ae).forEach((Ie) => {
    var Be;
    Ie.includes(":") ? t[Ie] = Ae[Ie] : (Be = Ae[Ie].chains) == null || Be.forEach((Pe) => {
      t[Pe] = { methods: Ae[Ie].methods, events: Ae[Ie].events };
    });
  }), t;
}
function Gn(Ae) {
  return [...new Set(Ae.map((t) => t.includes(":") ? t.split(":")[0] : t))];
}
function fo(Ae) {
  const t = {};
  return Object.keys(Ae).forEach((Ie) => {
    if (Ie.includes(":")) t[Ie] = Ae[Ie];
    else {
      const Be = C$1(Ae[Ie].accounts);
      Be == null || Be.forEach((Pe) => {
        t[Pe] = { accounts: Ae[Ie].accounts.filter((Te) => Te.includes(`${Pe}:`)), methods: Ae[Ie].methods, events: Ae[Ie].events };
      });
    }
  }), t;
}
function po(Ae, t) {
  return X$1(Ae) && Ae <= t.max && Ae >= t.min;
}
function mo() {
  const Ae = P$2();
  return new Promise((t) => {
    switch (Ae) {
      case y$1.browser:
        t(Yn());
        break;
      case y$1.reactNative:
        t(Qn());
        break;
      case y$1.node:
        t(Zn());
        break;
      default:
        t(!0);
    }
  });
}
function Yn() {
  return V$3() && (navigator == null ? void 0 : navigator.onLine);
}
async function Qn() {
  if (_$1() && typeof global < "u" && global != null && global.NetInfo) {
    const Ae = await (global == null ? void 0 : global.NetInfo.fetch());
    return Ae == null ? void 0 : Ae.isConnected;
  }
  return !0;
}
function Zn() {
  return !0;
}
function ho(Ae) {
  switch (P$2()) {
    case y$1.browser:
      Xn(Ae);
      break;
    case y$1.reactNative:
      et$2(Ae);
      break;
  }
}
function Xn(Ae) {
  !_$1() && V$3() && (window.addEventListener("online", () => Ae(!0)), window.addEventListener("offline", () => Ae(!1)));
}
function et$2(Ae) {
  _$1() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener((t) => Ae(t == null ? void 0 : t.isConnected)));
}
const Re = {};
class yo {
  static get(t) {
    return Re[t];
  }
  static set(t, Ie) {
    Re[t] = Ie;
  }
  static delete(t) {
    delete Re[t];
  }
}
const PARSE_ERROR = "PARSE_ERROR", INVALID_REQUEST = "INVALID_REQUEST", METHOD_NOT_FOUND = "METHOD_NOT_FOUND", INVALID_PARAMS = "INVALID_PARAMS", INTERNAL_ERROR = "INTERNAL_ERROR", SERVER_ERROR = "SERVER_ERROR", RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603], STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
}, DEFAULT_ERROR = SERVER_ERROR;
function isReservedErrorCode(Ae) {
  return RESERVED_ERROR_CODES.includes(Ae);
}
function getError(Ae) {
  return Object.keys(STANDARD_ERROR_MAP).includes(Ae) ? STANDARD_ERROR_MAP[Ae] : STANDARD_ERROR_MAP[DEFAULT_ERROR];
}
function getErrorByCode(Ae) {
  const t = Object.values(STANDARD_ERROR_MAP).find((Ie) => Ie.code === Ae);
  return t || STANDARD_ERROR_MAP[DEFAULT_ERROR];
}
function parseConnectionError(Ae, t, Ie) {
  return Ae.message.includes("getaddrinfo ENOTFOUND") || Ae.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${Ie} RPC url at ${t}`) : Ae;
}
var cjs = {}, crypto$1 = {}, hasRequiredCrypto;
function requireCrypto() {
  if (hasRequiredCrypto) return crypto$1;
  hasRequiredCrypto = 1, Object.defineProperty(crypto$1, "__esModule", { value: !0 }), crypto$1.isBrowserCryptoAvailable = crypto$1.getSubtleCrypto = crypto$1.getBrowerCrypto = void 0;
  function Ae() {
    return (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.crypto) || (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.msCrypto) || {};
  }
  crypto$1.getBrowerCrypto = Ae;
  function t() {
    const Be = Ae();
    return Be.subtle || Be.webkitSubtle;
  }
  crypto$1.getSubtleCrypto = t;
  function Ie() {
    return !!Ae() && !!t();
  }
  return crypto$1.isBrowserCryptoAvailable = Ie, crypto$1;
}
var env = {}, hasRequiredEnv;
function requireEnv() {
  if (hasRequiredEnv) return env;
  hasRequiredEnv = 1, Object.defineProperty(env, "__esModule", { value: !0 }), env.isBrowser = env.isNode = env.isReactNative = void 0;
  function Ae() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  env.isReactNative = Ae;
  function t() {
    return typeof process$1$1 < "u" && typeof process$1$1.versions < "u" && typeof process$1$1.versions.node < "u";
  }
  env.isNode = t;
  function Ie() {
    return !Ae() && !t();
  }
  return env.isBrowser = Ie, env;
}
(function(Ae) {
  Object.defineProperty(Ae, "__esModule", { value: !0 });
  const t = require$$0$1;
  t.__exportStar(requireCrypto(), Ae), t.__exportStar(requireEnv(), Ae);
})(cjs);
function payloadId(Ae = 3) {
  const t = Date.now() * Math.pow(10, Ae), Ie = Math.floor(Math.random() * Math.pow(10, Ae));
  return t + Ie;
}
function getBigIntRpcId(Ae = 6) {
  return BigInt(payloadId(Ae));
}
function formatJsonRpcRequest(Ae, t, Ie) {
  return {
    id: Ie || payloadId(),
    jsonrpc: "2.0",
    method: Ae,
    params: t
  };
}
function formatJsonRpcResult(Ae, t) {
  return {
    id: Ae,
    jsonrpc: "2.0",
    result: t
  };
}
function formatJsonRpcError(Ae, t, Ie) {
  return {
    id: Ae,
    jsonrpc: "2.0",
    error: formatErrorMessage(t)
  };
}
function formatErrorMessage(Ae, t) {
  return typeof Ae > "u" ? getError(INTERNAL_ERROR) : (typeof Ae == "string" && (Ae = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: Ae })), isReservedErrorCode(Ae.code) && (Ae = getErrorByCode(Ae.code)), Ae);
}
class e {
}
class n extends e {
  constructor() {
    super();
  }
}
class r extends n {
  constructor(t) {
    super();
  }
}
const WS_REGEX = "^wss?:";
function getUrlProtocol(Ae) {
  const t = Ae.match(new RegExp(/^\w+:/, "gi"));
  if (!(!t || !t.length))
    return t[0];
}
function matchRegexProtocol(Ae, t) {
  const Ie = getUrlProtocol(Ae);
  return typeof Ie > "u" ? !1 : new RegExp(t).test(Ie);
}
function isWsUrl(Ae) {
  return matchRegexProtocol(Ae, WS_REGEX);
}
function isLocalhostUrl(Ae) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(Ae);
}
function isJsonRpcPayload(Ae) {
  return typeof Ae == "object" && "id" in Ae && "jsonrpc" in Ae && Ae.jsonrpc === "2.0";
}
function isJsonRpcRequest(Ae) {
  return isJsonRpcPayload(Ae) && "method" in Ae;
}
function isJsonRpcResponse(Ae) {
  return isJsonRpcPayload(Ae) && (isJsonRpcResult(Ae) || isJsonRpcError(Ae));
}
function isJsonRpcResult(Ae) {
  return "result" in Ae;
}
function isJsonRpcError(Ae) {
  return "error" in Ae;
}
let o$1 = class extends r {
  constructor(t) {
    super(t), this.events = new eventsExports.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(t), this.connection.connected && this.registerEventListeners();
  }
  async connect(t = this.connection) {
    await this.open(t);
  }
  async disconnect() {
    await this.close();
  }
  on(t, Ie) {
    this.events.on(t, Ie);
  }
  once(t, Ie) {
    this.events.once(t, Ie);
  }
  off(t, Ie) {
    this.events.off(t, Ie);
  }
  removeListener(t, Ie) {
    this.events.removeListener(t, Ie);
  }
  async request(t, Ie) {
    return this.requestStrict(formatJsonRpcRequest(t.method, t.params || [], t.id || getBigIntRpcId().toString()), Ie);
  }
  async requestStrict(t, Ie) {
    return new Promise(async (Be, Pe) => {
      if (!this.connection.connected) try {
        await this.open();
      } catch (Te) {
        Pe(Te);
      }
      this.events.on(`${t.id}`, (Te) => {
        isJsonRpcError(Te) ? Pe(Te.error) : Be(Te.result);
      });
      try {
        await this.connection.send(t, Ie);
      } catch (Te) {
        Pe(Te);
      }
    });
  }
  setConnection(t = this.connection) {
    return t;
  }
  onPayload(t) {
    this.events.emit("payload", t), isJsonRpcResponse(t) ? this.events.emit(`${t.id}`, t) : this.events.emit("message", { type: t.method, data: t.params });
  }
  onClose(t) {
    t && t.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${t.code} ${t.reason ? `(${t.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(t = this.connection) {
    this.connection === t && this.connection.connected || (this.connection.connected && this.close(), typeof t == "string" && (await this.connection.open(t), t = this.connection), this.connection = this.setConnection(t), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (t) => this.onPayload(t)), this.connection.on("close", (t) => this.onClose(t)), this.connection.on("error", (t) => this.events.emit("error", t)), this.connection.on("register_error", (t) => this.onClose()), this.hasRegisteredEventListeners = !0);
  }
};
const w$1 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"), b$1 = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", a = (Ae) => Ae.split("?")[0], h = 10, S$3 = w$1();
let f$2 = class {
  constructor(t) {
    if (this.url = t, this.events = new eventsExports.EventEmitter(), this.registering = !1, !isWsUrl(t)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${t}`);
    this.url = t;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(t, Ie) {
    this.events.on(t, Ie);
  }
  once(t, Ie) {
    this.events.once(t, Ie);
  }
  off(t, Ie) {
    this.events.off(t, Ie);
  }
  removeListener(t, Ie) {
    this.events.removeListener(t, Ie);
  }
  async open(t = this.url) {
    await this.register(t);
  }
  async close() {
    return new Promise((t, Ie) => {
      if (typeof this.socket > "u") {
        Ie(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (Be) => {
        this.onClose(Be), t();
      }, this.socket.close();
    });
  }
  async send(t) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(t));
    } catch (Ie) {
      this.onError(t.id, Ie);
    }
  }
  register(t = this.url) {
    if (!isWsUrl(t)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${t}`);
    if (this.registering) {
      const Ie = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= Ie || this.events.listenerCount("open") >= Ie) && this.events.setMaxListeners(Ie + 1), new Promise((Be, Pe) => {
        this.events.once("register_error", (Te) => {
          this.resetMaxListeners(), Pe(Te);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return Pe(new Error("WebSocket connection is missing or invalid"));
          Be(this.socket);
        });
      });
    }
    return this.url = t, this.registering = !0, new Promise((Ie, Be) => {
      const Pe = new URLSearchParams(t).get("origin"), Te = cjs.isReactNative() ? { headers: { origin: Pe } } : { rejectUnauthorized: !isLocalhostUrl(t) }, Me = new S$3(t, [], Te);
      b$1() ? Me.onerror = (Ue) => {
        const je = Ue;
        Be(this.emitError(je.error));
      } : Me.on("error", (Ue) => {
        Be(this.emitError(Ue));
      }), Me.onopen = () => {
        this.onOpen(Me), Ie(Me);
      };
    });
  }
  onOpen(t) {
    t.onmessage = (Ie) => this.onPayload(Ie), t.onclose = (Ie) => this.onClose(Ie), this.socket = t, this.registering = !1, this.events.emit("open");
  }
  onClose(t) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", t);
  }
  onPayload(t) {
    if (typeof t.data > "u") return;
    const Ie = typeof t.data == "string" ? safeJsonParse(t.data) : t.data;
    this.events.emit("payload", Ie);
  }
  onError(t, Ie) {
    const Be = this.parseError(Ie), Pe = Be.message || Be.toString(), Te = formatJsonRpcError(t, Pe);
    this.events.emit("payload", Te);
  }
  parseError(t, Ie = this.url) {
    return parseConnectionError(t, a(Ie), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h && this.events.setMaxListeners(h);
  }
  emitError(t) {
    const Ie = this.parseError(new Error((t == null ? void 0 : t.message) || `WebSocket connection failed for host: ${a(this.url)}`));
    return this.events.emit("register_error", Ie), Ie;
  }
};
var lodash_isequal = { exports: {} };
lodash_isequal.exports;
(function(Ae, t) {
  var Ie = 200, Be = "__lodash_hash_undefined__", Pe = 1, Te = 2, Me = 9007199254740991, Ue = "[object Arguments]", je = "[object Array]", fn = "[object AsyncFunction]", Ve = "[object Boolean]", vn = "[object Date]", En = "[object Error]", fi = "[object Function]", bi = "[object GeneratorFunction]", mi = "[object Map]", _i = "[object Number]", Ei = "[object Null]", Si = "[object Object]", Mi = "[object Promise]", Oi = "[object Proxy]", Fi = "[object RegExp]", Ui = "[object Set]", Pi = "[object String]", Bi = "[object Symbol]", ji = "[object Undefined]", Zi = "[object WeakMap]", zi = "[object ArrayBuffer]", xi = "[object DataView]", $i = "[object Float32Array]", vi = "[object Float64Array]", wi = "[object Int8Array]", Ai = "[object Int16Array]", Ri = "[object Int32Array]", Ti = "[object Uint8Array]", Ci = "[object Uint8ClampedArray]", Ii = "[object Uint16Array]", Li = "[object Uint32Array]", Ni = /[\\^$.*+?()[\]{}|]/g, Vi = /^\[object .+?Constructor\]$/, is = /^(?:0|[1-9]\d*)$/, Ki = {};
  Ki[$i] = Ki[vi] = Ki[wi] = Ki[Ai] = Ki[Ri] = Ki[Ti] = Ki[Ci] = Ki[Ii] = Ki[Li] = !0, Ki[Ue] = Ki[je] = Ki[zi] = Ki[Ve] = Ki[xi] = Ki[vn] = Ki[En] = Ki[fi] = Ki[mi] = Ki[_i] = Ki[Si] = Ki[Fi] = Ki[Ui] = Ki[Pi] = Ki[Zi] = !1;
  var ts = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, qi = typeof self == "object" && self && self.Object === Object && self, Hi = ts || qi || Function("return this")(), Xi = t && !t.nodeType && t, ki = Xi && !0 && Ae && !Ae.nodeType && Ae, Wi = ki && ki.exports === Xi, Yi = Wi && ts.process, Qi = function() {
    try {
      return Yi && Yi.binding && Yi.binding("util");
    } catch {
    }
  }(), ns = Qi && Qi.isTypedArray;
  function us(cs, gs) {
    for (var xo = -1, ko = cs == null ? 0 : cs.length, sa = 0, Qo = []; ++xo < ko; ) {
      var fa = cs[xo];
      gs(fa, xo, cs) && (Qo[sa++] = fa);
    }
    return Qo;
  }
  function ps(cs, gs) {
    for (var xo = -1, ko = gs.length, sa = cs.length; ++xo < ko; )
      cs[sa + xo] = gs[xo];
    return cs;
  }
  function Ds(cs, gs) {
    for (var xo = -1, ko = cs == null ? 0 : cs.length; ++xo < ko; )
      if (gs(cs[xo], xo, cs))
        return !0;
    return !1;
  }
  function Eo(cs, gs) {
    for (var xo = -1, ko = Array(cs); ++xo < cs; )
      ko[xo] = gs(xo);
    return ko;
  }
  function hs(cs) {
    return function(gs) {
      return cs(gs);
    };
  }
  function So(cs, gs) {
    return cs.has(gs);
  }
  function _o(cs, gs) {
    return cs == null ? void 0 : cs[gs];
  }
  function vo(cs) {
    var gs = -1, xo = Array(cs.size);
    return cs.forEach(function(ko, sa) {
      xo[++gs] = [sa, ko];
    }), xo;
  }
  function Ro(cs, gs) {
    return function(xo) {
      return cs(gs(xo));
    };
  }
  function $o(cs) {
    var gs = -1, xo = Array(cs.size);
    return cs.forEach(function(ko) {
      xo[++gs] = ko;
    }), xo;
  }
  var Io = Array.prototype, To = Function.prototype, Ao = Object.prototype, Po = Hi["__core-js_shared__"], Co = To.toString, rs = Ao.hasOwnProperty, Gi = function() {
    var cs = /[^.]+$/.exec(Po && Po.keys && Po.keys.IE_PROTO || "");
    return cs ? "Symbol(src)_1." + cs : "";
  }(), Ji = Ao.toString, ss = RegExp(
    "^" + Co.call(rs).replace(Ni, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), ls = Wi ? Hi.Buffer : void 0, ds = Hi.Symbol, bs = Hi.Uint8Array, Mo = Ao.propertyIsEnumerable, Fo = Io.splice, Bo = ds ? ds.toStringTag : void 0, Uo = Object.getOwnPropertySymbols, Lo = ls ? ls.isBuffer : void 0, Go = Ro(Object.keys, Object), Yo = Ya(Hi, "DataView"), Ko = Ya(Hi, "Map"), No = Ya(Hi, "Promise"), Wo = Ya(Hi, "Set"), os = Ya(Hi, "WeakMap"), as = Ya(Object, "create"), go = Ka(Yo), bo = Ka(Ko), wo = Ka(No), qo = Ka(Wo), jo = Ka(os), Oo = ds ? ds.prototype : void 0, Ho = Oo ? Oo.valueOf : void 0;
  function zo(cs) {
    var gs = -1, xo = cs == null ? 0 : cs.length;
    for (this.clear(); ++gs < xo; ) {
      var ko = cs[gs];
      this.set(ko[0], ko[1]);
    }
  }
  function Do() {
    this.__data__ = as ? as(null) : {}, this.size = 0;
  }
  function Xo(cs) {
    var gs = this.has(cs) && delete this.__data__[cs];
    return this.size -= gs ? 1 : 0, gs;
  }
  function na(cs) {
    var gs = this.__data__;
    if (as) {
      var xo = gs[cs];
      return xo === Be ? void 0 : xo;
    }
    return rs.call(gs, cs) ? gs[cs] : void 0;
  }
  function Vo(cs) {
    var gs = this.__data__;
    return as ? gs[cs] !== void 0 : rs.call(gs, cs);
  }
  function ra(cs, gs) {
    var xo = this.__data__;
    return this.size += this.has(cs) ? 0 : 1, xo[cs] = as && gs === void 0 ? Be : gs, this;
  }
  zo.prototype.clear = Do, zo.prototype.delete = Xo, zo.prototype.get = na, zo.prototype.has = Vo, zo.prototype.set = ra;
  function Zo(cs) {
    var gs = -1, xo = cs == null ? 0 : cs.length;
    for (this.clear(); ++gs < xo; ) {
      var ko = cs[gs];
      this.set(ko[0], ko[1]);
    }
  }
  function ta() {
    this.__data__ = [], this.size = 0;
  }
  function ca(cs) {
    var gs = this.__data__, xo = wc(gs, cs);
    if (xo < 0)
      return !1;
    var ko = gs.length - 1;
    return xo == ko ? gs.pop() : Fo.call(gs, xo, 1), --this.size, !0;
  }
  function oa(cs) {
    var gs = this.__data__, xo = wc(gs, cs);
    return xo < 0 ? void 0 : gs[xo][1];
  }
  function ga(cs) {
    return wc(this.__data__, cs) > -1;
  }
  function ba(cs, gs) {
    var xo = this.__data__, ko = wc(xo, cs);
    return ko < 0 ? (++this.size, xo.push([cs, gs])) : xo[ko][1] = gs, this;
  }
  Zo.prototype.clear = ta, Zo.prototype.delete = ca, Zo.prototype.get = oa, Zo.prototype.has = ga, Zo.prototype.set = ba;
  function ua(cs) {
    var gs = -1, xo = cs == null ? 0 : cs.length;
    for (this.clear(); ++gs < xo; ) {
      var ko = cs[gs];
      this.set(ko[0], ko[1]);
    }
  }
  function Aa() {
    this.size = 0, this.__data__ = {
      hash: new zo(),
      map: new (Ko || Zo)(),
      string: new zo()
    };
  }
  function Ra(cs) {
    var gs = _c(this, cs).delete(cs);
    return this.size -= gs ? 1 : 0, gs;
  }
  function Ia(cs) {
    return _c(this, cs).get(cs);
  }
  function Ba(cs) {
    return _c(this, cs).has(cs);
  }
  function Pa(cs, gs) {
    var xo = _c(this, cs), ko = xo.size;
    return xo.set(cs, gs), this.size += xo.size == ko ? 0 : 1, this;
  }
  ua.prototype.clear = Aa, ua.prototype.delete = Ra, ua.prototype.get = Ia, ua.prototype.has = Ba, ua.prototype.set = Pa;
  function va(cs) {
    var gs = -1, xo = cs == null ? 0 : cs.length;
    for (this.__data__ = new ua(); ++gs < xo; )
      this.add(cs[gs]);
  }
  function Ta(cs) {
    return this.__data__.set(cs, Be), this;
  }
  function Ma(cs) {
    return this.__data__.has(cs);
  }
  va.prototype.add = va.prototype.push = Ta, va.prototype.has = Ma;
  function ha(cs) {
    var gs = this.__data__ = new Zo(cs);
    this.size = gs.size;
  }
  function Ca() {
    this.__data__ = new Zo(), this.size = 0;
  }
  function Na(cs) {
    var gs = this.__data__, xo = gs.delete(cs);
    return this.size = gs.size, xo;
  }
  function Oa(cs) {
    return this.__data__.get(cs);
  }
  function pc(cs) {
    return this.__data__.has(cs);
  }
  function gc(cs, gs) {
    var xo = this.__data__;
    if (xo instanceof Zo) {
      var ko = xo.__data__;
      if (!Ko || ko.length < Ie - 1)
        return ko.push([cs, gs]), this.size = ++xo.size, this;
      xo = this.__data__ = new ua(ko);
    }
    return xo.set(cs, gs), this.size = xo.size, this;
  }
  ha.prototype.clear = Ca, ha.prototype.delete = Na, ha.prototype.get = Oa, ha.prototype.has = pc, ha.prototype.set = gc;
  function Yc(cs, gs) {
    var xo = Ec(cs), ko = !xo && df(cs), sa = !xo && !ko && Ic(cs), Qo = !xo && !ko && !sa && qc(cs), fa = xo || ko || sa || Qo, la = fa ? Eo(cs.length, String) : [], da = la.length;
    for (var aa in cs)
      rs.call(cs, aa) && !(fa && // Safari 9 has enumerable `arguments.length` in strict mode.
      (aa == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      sa && (aa == "offset" || aa == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      Qo && (aa == "buffer" || aa == "byteLength" || aa == "byteOffset") || // Skip index properties.
      af(aa, da))) && la.push(aa);
    return la;
  }
  function wc(cs, gs) {
    for (var xo = cs.length; xo--; )
      if (Oc(cs[xo][0], gs))
        return xo;
    return -1;
  }
  function Xc(cs, gs, xo) {
    var ko = gs(cs);
    return Ec(cs) ? ko : ps(ko, xo(cs));
  }
  function bc(cs) {
    return cs == null ? cs === void 0 ? ji : Ei : Bo && Bo in Object(cs) ? sf(cs) : lf(cs);
  }
  function Tc(cs) {
    return yc(cs) && bc(cs) == Ue;
  }
  function Mc(cs, gs, xo, ko, sa) {
    return cs === gs ? !0 : cs == null || gs == null || !yc(cs) && !yc(gs) ? cs !== cs && gs !== gs : Zc(cs, gs, xo, ko, Mc, sa);
  }
  function Zc(cs, gs, xo, ko, sa, Qo) {
    var fa = Ec(cs), la = Ec(gs), da = fa ? je : Ua(cs), aa = la ? je : Ua(gs);
    da = da == Ue ? Si : da, aa = aa == Ue ? Si : aa;
    var ma = da == Si, $a = aa == Si, pa = da == aa;
    if (pa && Ic(cs)) {
      if (!Ic(gs))
        return !1;
      fa = !0, ma = !1;
    }
    if (pa && !ma)
      return Qo || (Qo = new ha()), fa || qc(cs) ? Cc(cs, gs, xo, ko, sa, Qo) : rf(cs, gs, da, xo, ko, sa, Qo);
    if (!(xo & Pe)) {
      var wa = ma && rs.call(cs, "__wrapped__"), _a = $a && rs.call(gs, "__wrapped__");
      if (wa || _a) {
        var ja = wa ? cs.value() : cs, Da = _a ? gs.value() : gs;
        return Qo || (Qo = new ha()), sa(ja, Da, xo, ko, Qo);
      }
    }
    return pa ? (Qo || (Qo = new ha()), nf(cs, gs, xo, ko, sa, Qo)) : !1;
  }
  function Qc(cs) {
    if (!Lc(cs) || ff(cs))
      return !1;
    var gs = Dc(cs) ? ss : Vi;
    return gs.test(Ka(cs));
  }
  function ef(cs) {
    return yc(cs) && kc(cs.length) && !!Ki[bc(cs)];
  }
  function tf(cs) {
    if (!uf(cs))
      return Go(cs);
    var gs = [];
    for (var xo in Object(cs))
      rs.call(cs, xo) && xo != "constructor" && gs.push(xo);
    return gs;
  }
  function Cc(cs, gs, xo, ko, sa, Qo) {
    var fa = xo & Pe, la = cs.length, da = gs.length;
    if (la != da && !(fa && da > la))
      return !1;
    var aa = Qo.get(cs);
    if (aa && Qo.get(gs))
      return aa == gs;
    var ma = -1, $a = !0, pa = xo & Te ? new va() : void 0;
    for (Qo.set(cs, gs), Qo.set(gs, cs); ++ma < la; ) {
      var wa = cs[ma], _a = gs[ma];
      if (ko)
        var ja = fa ? ko(_a, wa, ma, gs, cs, Qo) : ko(wa, _a, ma, cs, gs, Qo);
      if (ja !== void 0) {
        if (ja)
          continue;
        $a = !1;
        break;
      }
      if (pa) {
        if (!Ds(gs, function(Da, Wa) {
          if (!So(pa, Wa) && (wa === Da || sa(wa, Da, xo, ko, Qo)))
            return pa.push(Wa);
        })) {
          $a = !1;
          break;
        }
      } else if (!(wa === _a || sa(wa, _a, xo, ko, Qo))) {
        $a = !1;
        break;
      }
    }
    return Qo.delete(cs), Qo.delete(gs), $a;
  }
  function rf(cs, gs, xo, ko, sa, Qo, fa) {
    switch (xo) {
      case xi:
        if (cs.byteLength != gs.byteLength || cs.byteOffset != gs.byteOffset)
          return !1;
        cs = cs.buffer, gs = gs.buffer;
      case zi:
        return !(cs.byteLength != gs.byteLength || !Qo(new bs(cs), new bs(gs)));
      case Ve:
      case vn:
      case _i:
        return Oc(+cs, +gs);
      case En:
        return cs.name == gs.name && cs.message == gs.message;
      case Fi:
      case Pi:
        return cs == gs + "";
      case mi:
        var la = vo;
      case Ui:
        var da = ko & Pe;
        if (la || (la = $o), cs.size != gs.size && !da)
          return !1;
        var aa = fa.get(cs);
        if (aa)
          return aa == gs;
        ko |= Te, fa.set(cs, gs);
        var ma = Cc(la(cs), la(gs), ko, sa, Qo, fa);
        return fa.delete(cs), ma;
      case Bi:
        if (Ho)
          return Ho.call(cs) == Ho.call(gs);
    }
    return !1;
  }
  function nf(cs, gs, xo, ko, sa, Qo) {
    var fa = xo & Pe, la = Nc(cs), da = la.length, aa = Nc(gs), ma = aa.length;
    if (da != ma && !fa)
      return !1;
    for (var $a = da; $a--; ) {
      var pa = la[$a];
      if (!(fa ? pa in gs : rs.call(gs, pa)))
        return !1;
    }
    var wa = Qo.get(cs);
    if (wa && Qo.get(gs))
      return wa == gs;
    var _a = !0;
    Qo.set(cs, gs), Qo.set(gs, cs);
    for (var ja = fa; ++$a < da; ) {
      pa = la[$a];
      var Da = cs[pa], Wa = gs[pa];
      if (ko)
        var Fc = fa ? ko(Wa, Da, pa, gs, cs, Qo) : ko(Da, Wa, pa, cs, gs, Qo);
      if (!(Fc === void 0 ? Da === Wa || sa(Da, Wa, xo, ko, Qo) : Fc)) {
        _a = !1;
        break;
      }
      ja || (ja = pa == "constructor");
    }
    if (_a && !ja) {
      var $c = cs.constructor, Sc = gs.constructor;
      $c != Sc && "constructor" in cs && "constructor" in gs && !(typeof $c == "function" && $c instanceof $c && typeof Sc == "function" && Sc instanceof Sc) && (_a = !1);
    }
    return Qo.delete(cs), Qo.delete(gs), _a;
  }
  function Nc(cs) {
    return Xc(cs, gf, of);
  }
  function _c(cs, gs) {
    var xo = cs.__data__;
    return cf(gs) ? xo[typeof gs == "string" ? "string" : "hash"] : xo.map;
  }
  function Ya(cs, gs) {
    var xo = _o(cs, gs);
    return Qc(xo) ? xo : void 0;
  }
  function sf(cs) {
    var gs = rs.call(cs, Bo), xo = cs[Bo];
    try {
      cs[Bo] = void 0;
      var ko = !0;
    } catch {
    }
    var sa = Ji.call(cs);
    return ko && (gs ? cs[Bo] = xo : delete cs[Bo]), sa;
  }
  var of = Uo ? function(cs) {
    return cs == null ? [] : (cs = Object(cs), us(Uo(cs), function(gs) {
      return Mo.call(cs, gs);
    }));
  } : bf, Ua = bc;
  (Yo && Ua(new Yo(new ArrayBuffer(1))) != xi || Ko && Ua(new Ko()) != mi || No && Ua(No.resolve()) != Mi || Wo && Ua(new Wo()) != Ui || os && Ua(new os()) != Zi) && (Ua = function(cs) {
    var gs = bc(cs), xo = gs == Si ? cs.constructor : void 0, ko = xo ? Ka(xo) : "";
    if (ko)
      switch (ko) {
        case go:
          return xi;
        case bo:
          return mi;
        case wo:
          return Mi;
        case qo:
          return Ui;
        case jo:
          return Zi;
      }
    return gs;
  });
  function af(cs, gs) {
    return gs = gs ?? Me, !!gs && (typeof cs == "number" || is.test(cs)) && cs > -1 && cs % 1 == 0 && cs < gs;
  }
  function cf(cs) {
    var gs = typeof cs;
    return gs == "string" || gs == "number" || gs == "symbol" || gs == "boolean" ? cs !== "__proto__" : cs === null;
  }
  function ff(cs) {
    return !!Gi && Gi in cs;
  }
  function uf(cs) {
    var gs = cs && cs.constructor, xo = typeof gs == "function" && gs.prototype || Ao;
    return cs === xo;
  }
  function lf(cs) {
    return Ji.call(cs);
  }
  function Ka(cs) {
    if (cs != null) {
      try {
        return Co.call(cs);
      } catch {
      }
      try {
        return cs + "";
      } catch {
      }
    }
    return "";
  }
  function Oc(cs, gs) {
    return cs === gs || cs !== cs && gs !== gs;
  }
  var df = Tc(/* @__PURE__ */ function() {
    return arguments;
  }()) ? Tc : function(cs) {
    return yc(cs) && rs.call(cs, "callee") && !Mo.call(cs, "callee");
  }, Ec = Array.isArray;
  function hf(cs) {
    return cs != null && kc(cs.length) && !Dc(cs);
  }
  var Ic = Lo || yf;
  function pf(cs, gs) {
    return Mc(cs, gs);
  }
  function Dc(cs) {
    if (!Lc(cs))
      return !1;
    var gs = bc(cs);
    return gs == fi || gs == bi || gs == fn || gs == Oi;
  }
  function kc(cs) {
    return typeof cs == "number" && cs > -1 && cs % 1 == 0 && cs <= Me;
  }
  function Lc(cs) {
    var gs = typeof cs;
    return cs != null && (gs == "object" || gs == "function");
  }
  function yc(cs) {
    return cs != null && typeof cs == "object";
  }
  var qc = ns ? hs(ns) : ef;
  function gf(cs) {
    return hf(cs) ? Yc(cs) : tf(cs);
  }
  function bf() {
    return [];
  }
  function yf() {
    return !1;
  }
  Ae.exports = pf;
})(lodash_isequal, lodash_isequal.exports);
var lodash_isequalExports = lodash_isequal.exports;
const ys$1 = /* @__PURE__ */ getDefaultExportFromCjs(lodash_isequalExports), ye$2 = "wc", De$1 = 2, ie$2 = "core", x$3 = `${ye$2}@2:${ie$2}:`, Ye = { name: ie$2, logger: "error" }, Je = { database: ":memory:" }, Xe = "crypto", me$2 = "client_ed25519_seed", We$1 = cjs$3.ONE_DAY, Ze$1 = "keychain", Qe = "0.3", et$1 = "messages", tt$1 = "0.3", it$2 = cjs$3.SIX_HOURS, st$2 = "publisher", rt$2 = "irn", nt$2 = "error", be$2 = "wss://relay.walletconnect.org", ot$2 = "relayer", v$2 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" }, at$2 = "_subscription", I$2 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, ht$2 = 0.1, se$2 = "2.17.1", M$1 = { link_mode: "link_mode", relay: "relay" }, ct$2 = "0.3", lt$2 = "WALLETCONNECT_CLIENT_ID", fe$1 = "WALLETCONNECT_LINK_MODE_APPS", O$2 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, ut$2 = "subscription", dt$2 = "0.3", pt$2 = cjs$3.FIVE_SECONDS * 1e3, gt$2 = "pairing", yt$2 = "0.3", B$2 = { wc_pairingDelete: { req: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: cjs$3.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: cjs$3.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 0 } } }, V$2 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" }, P$1 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, Dt$1 = "history", mt$1 = "0.3", bt$1 = "expirer", S$2 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, ft$1 = "0.3", _t$1 = "verify-api", vs$1 = "https://verify.walletconnect.com", Et$1 = "https://verify.walletconnect.org", J$1 = Et$1, vt$1 = `${J$1}/v3`, wt$1 = [vs$1, Et$1], It$1 = "echo", Tt$1 = "https://echo.walletconnect.com", z$3 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" }, $$1 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" }, Is$1 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" }, Ts$1 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" }, Cs = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" }, Ps$1 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" }, Ct$1 = 0.1, Pt$1 = "event-client", St$1 = 86400, Rt$1 = "https://pulse.walletconnect.org/batch";
function Ss$1(Ae, t) {
  if (Ae.length >= 255) throw new TypeError("Alphabet too long");
  for (var Ie = new Uint8Array(256), Be = 0; Be < Ie.length; Be++) Ie[Be] = 255;
  for (var Pe = 0; Pe < Ae.length; Pe++) {
    var Te = Ae.charAt(Pe), Me = Te.charCodeAt(0);
    if (Ie[Me] !== 255) throw new TypeError(Te + " is ambiguous");
    Ie[Me] = Pe;
  }
  var Ue = Ae.length, je = Ae.charAt(0), fn = Math.log(Ue) / Math.log(256), Ve = Math.log(256) / Math.log(Ue);
  function vn(bi) {
    if (bi instanceof Uint8Array || (ArrayBuffer.isView(bi) ? bi = new Uint8Array(bi.buffer, bi.byteOffset, bi.byteLength) : Array.isArray(bi) && (bi = Uint8Array.from(bi))), !(bi instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (bi.length === 0) return "";
    for (var mi = 0, _i = 0, Ei = 0, Si = bi.length; Ei !== Si && bi[Ei] === 0; ) Ei++, mi++;
    for (var Mi = (Si - Ei) * Ve + 1 >>> 0, Oi = new Uint8Array(Mi); Ei !== Si; ) {
      for (var Fi = bi[Ei], Ui = 0, Pi = Mi - 1; (Fi !== 0 || Ui < _i) && Pi !== -1; Pi--, Ui++) Fi += 256 * Oi[Pi] >>> 0, Oi[Pi] = Fi % Ue >>> 0, Fi = Fi / Ue >>> 0;
      if (Fi !== 0) throw new Error("Non-zero carry");
      _i = Ui, Ei++;
    }
    for (var Bi = Mi - _i; Bi !== Mi && Oi[Bi] === 0; ) Bi++;
    for (var ji = je.repeat(mi); Bi < Mi; ++Bi) ji += Ae.charAt(Oi[Bi]);
    return ji;
  }
  function En(bi) {
    if (typeof bi != "string") throw new TypeError("Expected String");
    if (bi.length === 0) return new Uint8Array();
    var mi = 0;
    if (bi[mi] !== " ") {
      for (var _i = 0, Ei = 0; bi[mi] === je; ) _i++, mi++;
      for (var Si = (bi.length - mi) * fn + 1 >>> 0, Mi = new Uint8Array(Si); bi[mi]; ) {
        var Oi = Ie[bi.charCodeAt(mi)];
        if (Oi === 255) return;
        for (var Fi = 0, Ui = Si - 1; (Oi !== 0 || Fi < Ei) && Ui !== -1; Ui--, Fi++) Oi += Ue * Mi[Ui] >>> 0, Mi[Ui] = Oi % 256 >>> 0, Oi = Oi / 256 >>> 0;
        if (Oi !== 0) throw new Error("Non-zero carry");
        Ei = Fi, mi++;
      }
      if (bi[mi] !== " ") {
        for (var Pi = Si - Ei; Pi !== Si && Mi[Pi] === 0; ) Pi++;
        for (var Bi = new Uint8Array(_i + (Si - Pi)), ji = _i; Pi !== Si; ) Bi[ji++] = Mi[Pi++];
        return Bi;
      }
    }
  }
  function fi(bi) {
    var mi = En(bi);
    if (mi) return mi;
    throw new Error(`Non-${t} character`);
  }
  return { encode: vn, decodeUnsafe: En, decode: fi };
}
var Rs$1 = Ss$1, xs = Rs$1;
const xt$1 = (Ae) => {
  if (Ae instanceof Uint8Array && Ae.constructor.name === "Uint8Array") return Ae;
  if (Ae instanceof ArrayBuffer) return new Uint8Array(Ae);
  if (ArrayBuffer.isView(Ae)) return new Uint8Array(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  throw new Error("Unknown type, must be binary type");
}, Os = (Ae) => new TextEncoder().encode(Ae), As = (Ae) => new TextDecoder().decode(Ae);
let Ns$1 = class {
  constructor(t, Ie, Be) {
    this.name = t, this.prefix = Ie, this.baseEncode = Be;
  }
  encode(t) {
    if (t instanceof Uint8Array) return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
};
class zs {
  constructor(t, Ie, Be) {
    if (this.name = t, this.prefix = Ie, Ie.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = Ie.codePointAt(0), this.baseDecode = Be;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(t) {
    return Ot$1(this, t);
  }
}
class Ls {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return Ot$1(this, t);
  }
  decode(t) {
    const Ie = t[0], Be = this.decoders[Ie];
    if (Be) return Be.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const Ot$1 = (Ae, t) => new Ls({ ...Ae.decoders || { [Ae.prefix]: Ae }, ...t.decoders || { [t.prefix]: t } });
class $s {
  constructor(t, Ie, Be, Pe) {
    this.name = t, this.prefix = Ie, this.baseEncode = Be, this.baseDecode = Pe, this.encoder = new Ns$1(t, Ie, Be), this.decoder = new zs(t, Ie, Pe);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
}
const re$1 = ({ name: Ae, prefix: t, encode: Ie, decode: Be }) => new $s(Ae, t, Ie, Be), X = ({ prefix: Ae, name: t, alphabet: Ie }) => {
  const { encode: Be, decode: Pe } = xs(Ie, t);
  return re$1({ prefix: Ae, name: t, encode: Be, decode: (Te) => xt$1(Pe(Te)) });
}, ks = (Ae, t, Ie, Be) => {
  const Pe = {};
  for (let Ve = 0; Ve < t.length; ++Ve) Pe[t[Ve]] = Ve;
  let Te = Ae.length;
  for (; Ae[Te - 1] === "="; ) --Te;
  const Me = new Uint8Array(Te * Ie / 8 | 0);
  let Ue = 0, je = 0, fn = 0;
  for (let Ve = 0; Ve < Te; ++Ve) {
    const vn = Pe[Ae[Ve]];
    if (vn === void 0) throw new SyntaxError(`Non-${Be} character`);
    je = je << Ie | vn, Ue += Ie, Ue >= 8 && (Ue -= 8, Me[fn++] = 255 & je >> Ue);
  }
  if (Ue >= Ie || 255 & je << 8 - Ue) throw new SyntaxError("Unexpected end of data");
  return Me;
}, Ms = (Ae, t, Ie) => {
  const Be = t[t.length - 1] === "=", Pe = (1 << Ie) - 1;
  let Te = "", Me = 0, Ue = 0;
  for (let je = 0; je < Ae.length; ++je) for (Ue = Ue << 8 | Ae[je], Me += 8; Me > Ie; ) Me -= Ie, Te += t[Pe & Ue >> Me];
  if (Me && (Te += t[Pe & Ue << Ie - Me]), Be) for (; Te.length * Ie & 7; ) Te += "=";
  return Te;
}, f$1 = ({ name: Ae, prefix: t, bitsPerChar: Ie, alphabet: Be }) => re$1({ prefix: t, name: Ae, encode(Pe) {
  return Ms(Pe, Be, Ie);
}, decode(Pe) {
  return ks(Pe, Be, Ie, Ae);
} }), Us = re$1({ prefix: "\0", name: "identity", encode: (Ae) => As(Ae), decode: (Ae) => Os(Ae) });
var Fs = Object.freeze({ __proto__: null, identity: Us });
const Ks = f$1({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Bs = Object.freeze({ __proto__: null, base2: Ks });
const Vs = f$1({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var js = Object.freeze({ __proto__: null, base8: Vs });
const qs$1 = X({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Gs = Object.freeze({ __proto__: null, base10: qs$1 });
const Hs = f$1({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), Ys = f$1({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Js = Object.freeze({ __proto__: null, base16: Hs, base16upper: Ys });
const Xs = f$1({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), Ws = f$1({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), Zs = f$1({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), Qs = f$1({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), er$1 = f$1({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), tr$1 = f$1({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), ir$1 = f$1({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), sr$1 = f$1({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), rr$1 = f$1({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var nr$1 = Object.freeze({ __proto__: null, base32: Xs, base32upper: Ws, base32pad: Zs, base32padupper: Qs, base32hex: er$1, base32hexupper: tr$1, base32hexpad: ir$1, base32hexpadupper: sr$1, base32z: rr$1 });
const or$1 = X({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), ar$1 = X({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var hr$1 = Object.freeze({ __proto__: null, base36: or$1, base36upper: ar$1 });
const cr$1 = X({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), lr$1 = X({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var ur$1 = Object.freeze({ __proto__: null, base58btc: cr$1, base58flickr: lr$1 });
const dr$1 = f$1({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), pr$1 = f$1({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), gr$1 = f$1({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), yr$1 = f$1({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Dr$1 = Object.freeze({ __proto__: null, base64: dr$1, base64pad: pr$1, base64url: gr$1, base64urlpad: yr$1 });
const At$1 = Array.from(""), mr$1 = At$1.reduce((Ae, t, Ie) => (Ae[Ie] = t, Ae), []), br$1 = At$1.reduce((Ae, t, Ie) => (Ae[t.codePointAt(0)] = Ie, Ae), []);
function fr$1(Ae) {
  return Ae.reduce((t, Ie) => (t += mr$1[Ie], t), "");
}
function _r$1(Ae) {
  const t = [];
  for (const Ie of Ae) {
    const Be = br$1[Ie.codePointAt(0)];
    if (Be === void 0) throw new Error(`Non-base256emoji character: ${Ie}`);
    t.push(Be);
  }
  return new Uint8Array(t);
}
const Er$1 = re$1({ prefix: "", name: "base256emoji", encode: fr$1, decode: _r$1 });
var vr$1 = Object.freeze({ __proto__: null, base256emoji: Er$1 }), wr$1 = zt$1, Nt$1 = 128, Ir = 127, Tr$1 = ~Ir, Cr$1 = Math.pow(2, 31);
function zt$1(Ae, t, Ie) {
  t = t || [], Ie = Ie || 0;
  for (var Be = Ie; Ae >= Cr$1; ) t[Ie++] = Ae & 255 | Nt$1, Ae /= 128;
  for (; Ae & Tr$1; ) t[Ie++] = Ae & 255 | Nt$1, Ae >>>= 7;
  return t[Ie] = Ae | 0, zt$1.bytes = Ie - Be + 1, t;
}
var Pr$1 = _e$1, Sr$1 = 128, Lt$1 = 127;
function _e$1(Ae, Be) {
  var Ie = 0, Be = Be || 0, Pe = 0, Te = Be, Me, Ue = Ae.length;
  do {
    if (Te >= Ue) throw _e$1.bytes = 0, new RangeError("Could not decode varint");
    Me = Ae[Te++], Ie += Pe < 28 ? (Me & Lt$1) << Pe : (Me & Lt$1) * Math.pow(2, Pe), Pe += 7;
  } while (Me >= Sr$1);
  return _e$1.bytes = Te - Be, Ie;
}
var Rr$1 = Math.pow(2, 7), xr$1 = Math.pow(2, 14), Or$1 = Math.pow(2, 21), Ar$1 = Math.pow(2, 28), Nr$1 = Math.pow(2, 35), zr$1 = Math.pow(2, 42), Lr = Math.pow(2, 49), $r$1 = Math.pow(2, 56), kr = Math.pow(2, 63), Mr = function(Ae) {
  return Ae < Rr$1 ? 1 : Ae < xr$1 ? 2 : Ae < Or$1 ? 3 : Ae < Ar$1 ? 4 : Ae < Nr$1 ? 5 : Ae < zr$1 ? 6 : Ae < Lr ? 7 : Ae < $r$1 ? 8 : Ae < kr ? 9 : 10;
}, Ur = { encode: wr$1, decode: Pr$1, encodingLength: Mr }, $t$1 = Ur;
const kt$1 = (Ae, t, Ie = 0) => ($t$1.encode(Ae, t, Ie), t), Mt$1 = (Ae) => $t$1.encodingLength(Ae), Ee$1 = (Ae, t) => {
  const Ie = t.byteLength, Be = Mt$1(Ae), Pe = Be + Mt$1(Ie), Te = new Uint8Array(Pe + Ie);
  return kt$1(Ae, Te, 0), kt$1(Ie, Te, Be), Te.set(t, Pe), new Fr$1(Ae, Ie, t, Te);
};
let Fr$1 = class {
  constructor(t, Ie, Be, Pe) {
    this.code = t, this.size = Ie, this.digest = Be, this.bytes = Pe;
  }
};
const Ut$1 = ({ name: Ae, code: t, encode: Ie }) => new Kr(Ae, t, Ie);
class Kr {
  constructor(t, Ie, Be) {
    this.name = t, this.code = Ie, this.encode = Be;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const Ie = this.encode(t);
      return Ie instanceof Uint8Array ? Ee$1(this.code, Ie) : Ie.then((Be) => Ee$1(this.code, Be));
    } else throw Error("Unknown type, must be binary type");
  }
}
const Ft$1 = (Ae) => async (t) => new Uint8Array(await crypto.subtle.digest(Ae, t)), Br$1 = Ut$1({ name: "sha2-256", code: 18, encode: Ft$1("SHA-256") }), Vr = Ut$1({ name: "sha2-512", code: 19, encode: Ft$1("SHA-512") });
var jr = Object.freeze({ __proto__: null, sha256: Br$1, sha512: Vr });
const Kt$1 = 0, qr = "identity", Bt$1 = xt$1, Gr = (Ae) => Ee$1(Kt$1, Bt$1(Ae)), Hr = { code: Kt$1, name: qr, encode: Bt$1, digest: Gr };
var Yr = Object.freeze({ __proto__: null, identity: Hr });
new TextEncoder(), new TextDecoder();
const Vt$1 = { ...Fs, ...Bs, ...js, ...Gs, ...Js, ...nr$1, ...hr$1, ...ur$1, ...Dr$1, ...vr$1 };
({ ...jr, ...Yr });
function Jr(Ae = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(Ae) : new Uint8Array(Ae);
}
function jt$1(Ae, t, Ie, Be) {
  return { name: Ae, prefix: t, encoder: { name: Ae, prefix: t, encode: Ie }, decoder: { decode: Be } };
}
const qt$1 = jt$1("utf8", "u", (Ae) => "u" + new TextDecoder("utf8").decode(Ae), (Ae) => new TextEncoder().encode(Ae.substring(1))), ve = jt$1("ascii", "a", (Ae) => {
  let t = "a";
  for (let Ie = 0; Ie < Ae.length; Ie++) t += String.fromCharCode(Ae[Ie]);
  return t;
}, (Ae) => {
  Ae = Ae.substring(1);
  const t = Jr(Ae.length);
  for (let Ie = 0; Ie < Ae.length; Ie++) t[Ie] = Ae.charCodeAt(Ie);
  return t;
}), Xr = { utf8: qt$1, "utf-8": qt$1, hex: Vt$1.base16, latin1: ve, ascii: ve, binary: ve, ...Vt$1 };
function Wr(Ae, t = "utf8") {
  const Ie = Xr[t];
  if (!Ie) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(Ae, "utf8") : Ie.decoder.decode(`${Ie.prefix}${Ae}`);
}
let Gt$1 = class {
  constructor(t, Ie) {
    this.core = t, this.logger = Ie, this.keychain = /* @__PURE__ */ new Map(), this.name = Ze$1, this.version = Qe, this.initialized = !1, this.storagePrefix = x$3, this.init = async () => {
      if (!this.initialized) {
        const Be = await this.getKeyChain();
        typeof Be < "u" && (this.keychain = Be), this.initialized = !0;
      }
    }, this.has = (Be) => (this.isInitialized(), this.keychain.has(Be)), this.set = async (Be, Pe) => {
      this.isInitialized(), this.keychain.set(Be, Pe), await this.persist();
    }, this.get = (Be) => {
      this.isInitialized();
      const Pe = this.keychain.get(Be);
      if (typeof Pe > "u") {
        const { message: Te } = S$4("NO_MATCHING_KEY", `${this.name}: ${Be}`);
        throw new Error(Te);
      }
      return Pe;
    }, this.del = async (Be) => {
      this.isInitialized(), this.keychain.delete(Be), await this.persist();
    }, this.core = t, this.logger = E$1(Ie, this.name);
  }
  get context() {
    return y$3(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(t) {
    await this.core.storage.setItem(this.storageKey, Tt$2(t));
  }
  async getKeyChain() {
    const t = await this.core.storage.getItem(this.storageKey);
    return typeof t < "u" ? Pt$2(t) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}, Ht$1 = class {
  constructor(t, Ie, Be) {
    this.core = t, this.logger = Ie, this.name = Xe, this.randomSessionIdentifier = pr$2(), this.initialized = !1, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0);
    }, this.hasKeys = (Pe) => (this.isInitialized(), this.keychain.has(Pe)), this.getClientId = async () => {
      this.isInitialized();
      const Pe = await this.getClientSeed(), Te = generateKeyPair(Pe);
      return encodeIss(Te.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const Pe = fr$2();
      return this.setPrivateKey(Pe.publicKey, Pe.privateKey);
    }, this.signJWT = async (Pe) => {
      this.isInitialized();
      const Te = await this.getClientSeed(), Me = generateKeyPair(Te), Ue = this.randomSessionIdentifier;
      return await signJWT(Ue, Pe, We$1, Me);
    }, this.generateSharedKey = (Pe, Te, Me) => {
      this.isInitialized();
      const Ue = this.getPrivateKey(Pe), je = mr$2(Ue, Te);
      return this.setSymKey(je, Me);
    }, this.setSymKey = async (Pe, Te) => {
      this.isInitialized();
      const Me = Te || hr$2(Pe);
      return await this.keychain.set(Me, Pe), Me;
    }, this.deleteKeyPair = async (Pe) => {
      this.isInitialized(), await this.keychain.del(Pe);
    }, this.deleteSymKey = async (Pe) => {
      this.isInitialized(), await this.keychain.del(Pe);
    }, this.encode = async (Pe, Te, Me) => {
      this.isInitialized();
      const Ue = On(Me), je = safeJsonStringify(Te);
      if (Nr$2(Ue)) return vr$2(je, Me == null ? void 0 : Me.encoding);
      if (Or$2(Ue)) {
        const En = Ue.senderPublicKey, fi = Ue.receiverPublicKey;
        Pe = await this.generateSharedKey(En, fi);
      }
      const fn = this.getSymKey(Pe), { type: Ve, senderPublicKey: vn } = Ue;
      return gr$2({ type: Ve, symKey: fn, message: je, senderPublicKey: vn, encoding: Me == null ? void 0 : Me.encoding });
    }, this.decode = async (Pe, Te, Me) => {
      this.isInitialized();
      const Ue = wr$2(Te, Me);
      if (Nr$2(Ue)) {
        const je = Er$2(Te, Me == null ? void 0 : Me.encoding);
        return safeJsonParse(je);
      }
      if (Or$2(Ue)) {
        const je = Ue.receiverPublicKey, fn = Ue.senderPublicKey;
        Pe = await this.generateSharedKey(je, fn);
      }
      try {
        const je = this.getSymKey(Pe), fn = br$2({ symKey: je, encoded: Te, encoding: Me == null ? void 0 : Me.encoding });
        return safeJsonParse(fn);
      } catch (je) {
        this.logger.error(`Failed to decode message from topic: '${Pe}', clientId: '${await this.getClientId()}'`), this.logger.error(je);
      }
    }, this.getPayloadType = (Pe, Te = ge$1) => {
      const Me = Q$1({ encoded: Pe, encoding: Te });
      return A(Me.type);
    }, this.getPayloadSenderPublicKey = (Pe, Te = ge$1) => {
      const Me = Q$1({ encoded: Pe, encoding: Te });
      return Me.senderPublicKey ? toString(Me.senderPublicKey, g$1) : void 0;
    }, this.core = t, this.logger = E$1(Ie, this.name), this.keychain = Be || new Gt$1(this.core, this.logger);
  }
  get context() {
    return y$3(this.logger);
  }
  async setPrivateKey(t, Ie) {
    return await this.keychain.set(t, Ie), t;
  }
  getPrivateKey(t) {
    return this.keychain.get(t);
  }
  async getClientSeed() {
    let t = "";
    try {
      t = this.keychain.get(me$2);
    } catch {
      t = pr$2(), await this.keychain.set(me$2, t);
    }
    return Wr(t, "base16");
  }
  getSymKey(t) {
    return this.keychain.get(t);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}, Yt$1 = class extends a$1 {
  constructor(t, Ie) {
    super(t, Ie), this.logger = t, this.core = Ie, this.messages = /* @__PURE__ */ new Map(), this.name = et$1, this.version = tt$1, this.initialized = !1, this.storagePrefix = x$3, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const Be = await this.getRelayerMessages();
          typeof Be < "u" && (this.messages = Be), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (Be) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(Be);
        } finally {
          this.initialized = !0;
        }
      }
    }, this.set = async (Be, Pe) => {
      this.isInitialized();
      const Te = yr$2(Pe);
      let Me = this.messages.get(Be);
      return typeof Me > "u" && (Me = {}), typeof Me[Te] < "u" || (Me[Te] = Pe, this.messages.set(Be, Me), await this.persist()), Te;
    }, this.get = (Be) => {
      this.isInitialized();
      let Pe = this.messages.get(Be);
      return typeof Pe > "u" && (Pe = {}), Pe;
    }, this.has = (Be, Pe) => {
      this.isInitialized();
      const Te = this.get(Be), Me = yr$2(Pe);
      return typeof Te[Me] < "u";
    }, this.del = async (Be) => {
      this.isInitialized(), this.messages.delete(Be), await this.persist();
    }, this.logger = E$1(t, this.name), this.core = Ie;
  }
  get context() {
    return y$3(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(t) {
    await this.core.storage.setItem(this.storageKey, Tt$2(t));
  }
  async getRelayerMessages() {
    const t = await this.core.storage.getItem(this.storageKey);
    return typeof t < "u" ? Pt$2(t) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
};
class Zr extends g$2 {
  constructor(t, Ie) {
    super(t, Ie), this.relayer = t, this.logger = Ie, this.events = new eventsExports.EventEmitter(), this.name = st$2, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = cjs$3.toMiliseconds(cjs$3.ONE_MINUTE), this.failedPublishTimeout = cjs$3.toMiliseconds(cjs$3.ONE_SECOND), this.needsTransportRestart = !1, this.publish = async (Be, Pe, Te) => {
      var Me;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: Be, message: Pe, opts: Te } });
      const Ue = (Te == null ? void 0 : Te.ttl) || it$2, je = Ir$1(Te), fn = (Te == null ? void 0 : Te.prompt) || !1, Ve = (Te == null ? void 0 : Te.tag) || 0, vn = (Te == null ? void 0 : Te.id) || getBigIntRpcId().toString(), En = { topic: Be, message: Pe, opts: { ttl: Ue, relay: je, prompt: fn, tag: Ve, id: vn, attestation: Te == null ? void 0 : Te.attestation } }, fi = `Failed to publish payload, please try again. id:${vn} tag:${Ve}`, bi = Date.now();
      let mi, _i = 1;
      try {
        for (; mi === void 0; ) {
          if (Date.now() - bi > this.publishTimeout) throw new Error(fi);
          this.logger.trace({ id: vn, attempts: _i }, `publisher.publish - attempt ${_i}`), mi = await await kt$2(this.rpcPublish(Be, Pe, Ue, je, fn, Ve, vn, Te == null ? void 0 : Te.attestation).catch((Ei) => this.logger.warn(Ei)), this.publishTimeout, fi), _i++, mi || await new Promise((Ei) => setTimeout(Ei, this.failedPublishTimeout));
        }
        this.relayer.events.emit(v$2.publish, En), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { id: vn, topic: Be, message: Pe, opts: Te } });
      } catch (Ei) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(Ei), (Me = Te == null ? void 0 : Te.internal) != null && Me.throwOnFailedPublish) throw Ei;
        this.queue.set(vn, En);
      }
    }, this.on = (Be, Pe) => {
      this.events.on(Be, Pe);
    }, this.once = (Be, Pe) => {
      this.events.once(Be, Pe);
    }, this.off = (Be, Pe) => {
      this.events.off(Be, Pe);
    }, this.removeListener = (Be, Pe) => {
      this.events.removeListener(Be, Pe);
    }, this.relayer = t, this.logger = E$1(Ie, this.name), this.registerEventListeners();
  }
  get context() {
    return y$3(this.logger);
  }
  rpcPublish(t, Ie, Be, Pe, Te, Me, Ue, je) {
    var fn, Ve, vn, En;
    const fi = { method: jr$1(Pe.protocol).publish, params: { topic: t, message: Ie, ttl: Be, prompt: Te, tag: Me, attestation: je }, id: Ue };
    return I$3((fn = fi.params) == null ? void 0 : fn.prompt) && ((Ve = fi.params) == null || delete Ve.prompt), I$3((vn = fi.params) == null ? void 0 : vn.tag) && ((En = fi.params) == null || delete En.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: fi }), this.relayer.request(fi);
  }
  removeRequestFromQueue(t) {
    this.queue.delete(t);
  }
  checkQueue() {
    this.queue.forEach(async (t) => {
      const { topic: Ie, message: Be, opts: Pe } = t;
      await this.publish(Ie, Be, Pe);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r$1.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = !1, this.relayer.events.emit(v$2.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(v$2.message_ack, (t) => {
      this.removeRequestFromQueue(t.id.toString());
    });
  }
}
class Qr {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (t, Ie) => {
      const Be = this.get(t);
      this.exists(t, Ie) || this.map.set(t, [...Be, Ie]);
    }, this.get = (t) => this.map.get(t) || [], this.exists = (t, Ie) => this.get(t).includes(Ie), this.delete = (t, Ie) => {
      if (typeof Ie > "u") {
        this.map.delete(t);
        return;
      }
      if (!this.map.has(t)) return;
      const Be = this.get(t);
      if (!this.exists(t, Ie)) return;
      const Pe = Be.filter((Te) => Te !== Ie);
      if (!Pe.length) {
        this.map.delete(t);
        return;
      }
      this.map.set(t, Pe);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var en = Object.defineProperty, tn = Object.defineProperties, sn = Object.getOwnPropertyDescriptors, Jt$1 = Object.getOwnPropertySymbols, rn = Object.prototype.hasOwnProperty, nn = Object.prototype.propertyIsEnumerable, Xt$1 = (Ae, t, Ie) => t in Ae ? en(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, W$1 = (Ae, t) => {
  for (var Ie in t || (t = {})) rn.call(t, Ie) && Xt$1(Ae, Ie, t[Ie]);
  if (Jt$1) for (var Ie of Jt$1(t)) nn.call(t, Ie) && Xt$1(Ae, Ie, t[Ie]);
  return Ae;
}, we$2 = (Ae, t) => tn(Ae, sn(t));
let Wt$1 = class extends d$1 {
  constructor(t, Ie) {
    super(t, Ie), this.relayer = t, this.logger = Ie, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new Qr(), this.events = new eventsExports.EventEmitter(), this.name = ut$2, this.version = dt$2, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = x$3, this.subscribeTimeout = cjs$3.toMiliseconds(cjs$3.ONE_MINUTE), this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.pendingBatchMessages = [], this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = !0;
    }, this.subscribe = async (Be, Pe) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: Be, opts: Pe } });
      try {
        const Te = Ir$1(Pe), Me = { topic: Be, relay: Te, transportType: Pe == null ? void 0 : Pe.transportType };
        this.pending.set(Be, Me);
        const Ue = await this.rpcSubscribe(Be, Te, Pe);
        return typeof Ue == "string" && (this.onSubscribe(Ue, Me), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: Be, opts: Pe } })), Ue;
      } catch (Te) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(Te), Te;
      }
    }, this.unsubscribe = async (Be, Pe) => {
      await this.restartToComplete(), this.isInitialized(), typeof (Pe == null ? void 0 : Pe.id) < "u" ? await this.unsubscribeById(Be, Pe.id, Pe) : await this.unsubscribeByTopic(Be, Pe);
    }, this.isSubscribed = async (Be) => {
      if (this.topics.includes(Be)) return !0;
      const Pe = `${this.pendingSubscriptionWatchLabel}_${Be}`;
      return await new Promise((Te, Me) => {
        const Ue = new cjs$3.Watch();
        Ue.start(Pe);
        const je = setInterval(() => {
          !this.pending.has(Be) && this.topics.includes(Be) && (clearInterval(je), Ue.stop(Pe), Te(!0)), Ue.elapsed(Pe) >= pt$2 && (clearInterval(je), Ue.stop(Pe), Me(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => !1);
    }, this.on = (Be, Pe) => {
      this.events.on(Be, Pe);
    }, this.once = (Be, Pe) => {
      this.events.once(Be, Pe);
    }, this.off = (Be, Pe) => {
      this.events.off(Be, Pe);
    }, this.removeListener = (Be, Pe) => {
      this.events.removeListener(Be, Pe);
    }, this.start = async () => {
      await this.onConnect();
    }, this.stop = async () => {
      await this.onDisconnect();
    }, this.restart = async () => {
      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;
    }, this.relayer = t, this.logger = E$1(Ie, this.name), this.clientId = "";
  }
  get context() {
    return y$3(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(t, Ie) {
    let Be = !1;
    try {
      Be = this.getSubscription(t).topic === Ie;
    } catch {
    }
    return Be;
  }
  onEnable() {
    this.cached = [], this.initialized = !0;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(t, Ie) {
    const Be = this.topicMap.get(t);
    await Promise.all(Be.map(async (Pe) => await this.unsubscribeById(t, Pe, Ie)));
  }
  async unsubscribeById(t, Ie, Be) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: t, id: Ie, opts: Be } });
    try {
      const Pe = Ir$1(Be);
      await this.rpcUnsubscribe(t, Ie, Pe);
      const Te = U$2("USER_DISCONNECTED", `${this.name}, ${t}`);
      await this.onUnsubscribe(t, Ie, Te), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: t, id: Ie, opts: Be } });
    } catch (Pe) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(Pe), Pe;
    }
  }
  async rpcSubscribe(t, Ie, Be) {
    var Pe;
    (Be == null ? void 0 : Be.transportType) === M$1.relay && await this.restartToComplete();
    const Te = { method: jr$1(Ie.protocol).subscribe, params: { topic: t } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: Te });
    const Me = (Pe = Be == null ? void 0 : Be.internal) == null ? void 0 : Pe.throwOnFailedPublish;
    try {
      const Ue = yr$2(t + this.clientId);
      if ((Be == null ? void 0 : Be.transportType) === M$1.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(Te).catch((fn) => this.logger.warn(fn));
      }, cjs$3.toMiliseconds(cjs$3.ONE_SECOND)), Ue;
      const je = await kt$2(this.relayer.request(Te).catch((fn) => this.logger.warn(fn)), this.subscribeTimeout, `Subscribing to ${t} failed, please try again`);
      if (!je && Me) throw new Error(`Subscribing to ${t} failed, please try again`);
      return je ? Ue : null;
    } catch (Ue) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(v$2.connection_stalled), Me) throw Ue;
    }
    return null;
  }
  async rpcBatchSubscribe(t) {
    if (!t.length) return;
    const Ie = t[0].relay, Be = { method: jr$1(Ie.protocol).batchSubscribe, params: { topics: t.map((Pe) => Pe.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: Be });
    try {
      return await await kt$2(this.relayer.request(Be).catch((Pe) => this.logger.warn(Pe)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(v$2.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(t) {
    if (!t.length) return;
    const Ie = t[0].relay, Be = { method: jr$1(Ie.protocol).batchFetchMessages, params: { topics: t.map((Te) => Te.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: Be });
    let Pe;
    try {
      Pe = await await kt$2(this.relayer.request(Be).catch((Te) => this.logger.warn(Te)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(v$2.connection_stalled);
    }
    return Pe;
  }
  rpcUnsubscribe(t, Ie, Be) {
    const Pe = { method: jr$1(Be.protocol).unsubscribe, params: { topic: t, id: Ie } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: Pe }), this.relayer.request(Pe);
  }
  onSubscribe(t, Ie) {
    this.setSubscription(t, we$2(W$1({}, Ie), { id: t })), this.pending.delete(Ie.topic);
  }
  onBatchSubscribe(t) {
    t.length && t.forEach((Ie) => {
      this.setSubscription(Ie.id, W$1({}, Ie)), this.pending.delete(Ie.topic);
    });
  }
  async onUnsubscribe(t, Ie, Be) {
    this.events.removeAllListeners(Ie), this.hasSubscription(Ie, t) && this.deleteSubscription(Ie, Be), await this.relayer.messages.del(t);
  }
  async setRelayerSubscriptions(t) {
    await this.relayer.core.storage.setItem(this.storageKey, t);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(t, Ie) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: t, subscription: Ie }), this.addSubscription(t, Ie);
  }
  addSubscription(t, Ie) {
    this.subscriptions.set(t, W$1({}, Ie)), this.topicMap.set(Ie.topic, t), this.events.emit(O$2.created, Ie);
  }
  getSubscription(t) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: t });
    const Ie = this.subscriptions.get(t);
    if (!Ie) {
      const { message: Be } = S$4("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw new Error(Be);
    }
    return Ie;
  }
  deleteSubscription(t, Ie) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: t, reason: Ie });
    const Be = this.getSubscription(t);
    this.subscriptions.delete(t), this.topicMap.delete(Be.topic, t), this.events.emit(O$2.deleted, we$2(W$1({}, Be), { reason: Ie }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(O$2.sync);
  }
  async reset() {
    if (this.cached.length) {
      const t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let Ie = 0; Ie < t; Ie++) {
        const Be = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchFetchMessages(Be), await this.batchSubscribe(Be);
      }
    }
    this.events.emit(O$2.resubscribed);
  }
  async restore() {
    try {
      const t = await this.getRelayerSubscriptions();
      if (typeof t > "u" || !t.length) return;
      if (this.subscriptions.size) {
        const { message: Ie } = S$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Ie), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(Ie);
      }
      this.cached = t, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(t);
    }
  }
  async batchSubscribe(t) {
    if (!t.length) return;
    const Ie = await this.rpcBatchSubscribe(t);
    L$2(Ie) && this.onBatchSubscribe(Ie.map((Be, Pe) => we$2(W$1({}, t[Pe]), { id: Be })));
  }
  async batchFetchMessages(t) {
    if (!t.length) return;
    this.logger.trace(`Fetching batch messages for ${t.length} subscriptions`);
    const Ie = await this.rpcBatchFetchMessages(t);
    Ie && Ie.messages && (this.pendingBatchMessages = this.pendingBatchMessages.concat(Ie.messages));
  }
  async onConnect() {
    await this.restart(), this.onEnable();
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || !this.relayer.connected) return;
    const t = [];
    this.pending.forEach((Ie) => {
      t.push(Ie);
    }), await this.batchSubscribe(t), this.pendingBatchMessages.length && (await this.relayer.handleBatchMessageEvents(this.pendingBatchMessages), this.pendingBatchMessages = []);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r$1.pulse, async () => {
      await this.checkPending();
    }), this.events.on(O$2.created, async (t) => {
      const Ie = O$2.created;
      this.logger.info(`Emitting ${Ie}`), this.logger.debug({ type: "event", event: Ie, data: t }), await this.persist();
    }), this.events.on(O$2.deleted, async (t) => {
      const Ie = O$2.deleted;
      this.logger.info(`Emitting ${Ie}`), this.logger.debug({ type: "event", event: Ie, data: t }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  async restartToComplete() {
    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen(), this.restartInProgress && await new Promise((t) => {
      const Ie = setInterval(() => {
        this.restartInProgress || (clearInterval(Ie), t());
      }, this.pollingInterval);
    });
  }
};
var on = Object.defineProperty, Zt$1 = Object.getOwnPropertySymbols, an = Object.prototype.hasOwnProperty, hn = Object.prototype.propertyIsEnumerable, Qt$1 = (Ae, t, Ie) => t in Ae ? on(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, ei = (Ae, t) => {
  for (var Ie in t || (t = {})) an.call(t, Ie) && Qt$1(Ae, Ie, t[Ie]);
  if (Zt$1) for (var Ie of Zt$1(t)) hn.call(t, Ie) && Qt$1(Ae, Ie, t[Ie]);
  return Ae;
};
class ti extends u {
  constructor(t) {
    super(t), this.protocol = "wc", this.version = 2, this.events = new eventsExports.EventEmitter(), this.name = ot$2, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "stalled", "interrupted"], this.hasExperiencedNetworkDisruption = !1, this.requestsInFlight = /* @__PURE__ */ new Map(), this.heartBeatTimeout = cjs$3.toMiliseconds(cjs$3.THIRTY_SECONDS + cjs$3.ONE_SECOND), this.request = async (Ie) => {
      var Be, Pe;
      this.logger.debug("Publishing Request Payload");
      const Te = Ie.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        const Me = this.provider.request(Ie);
        this.requestsInFlight.set(Te, { promise: Me, request: Ie }), this.logger.trace({ id: Te, method: Ie.method, topic: (Be = Ie.params) == null ? void 0 : Be.topic }, "relayer.request - attempt to publish...");
        const Ue = await new Promise(async (je, fn) => {
          const Ve = () => {
            fn(new Error(`relayer.request - publish interrupted, id: ${Te}`));
          };
          this.provider.on(I$2.disconnect, Ve);
          const vn = await Me;
          this.provider.off(I$2.disconnect, Ve), je(vn);
        });
        return this.logger.trace({ id: Te, method: Ie.method, topic: (Pe = Ie.params) == null ? void 0 : Pe.topic }, "relayer.request - published"), Ue;
      } catch (Me) {
        throw this.logger.debug(`Failed to Publish Request: ${Te}`), Me;
      } finally {
        this.requestsInFlight.delete(Te);
      }
    }, this.resetPingTimeout = () => {
      if (ce$1()) try {
        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
          var Ie, Be, Pe;
          (Pe = (Be = (Ie = this.provider) == null ? void 0 : Ie.connection) == null ? void 0 : Be.socket) == null || Pe.terminate();
        }, this.heartBeatTimeout);
      } catch (Ie) {
        this.logger.warn(Ie);
      }
    }, this.onPayloadHandler = (Ie) => {
      this.onProviderPayload(Ie), this.resetPingTimeout();
    }, this.onConnectHandler = () => {
      this.logger.trace("relayer connected"), this.startPingTimeout(), this.events.emit(v$2.connect);
    }, this.onDisconnectHandler = () => {
      this.logger.trace("relayer disconnected"), this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (Ie) => {
      this.logger.error(Ie), this.events.emit(v$2.error, Ie), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(I$2.payload, this.onPayloadHandler), this.provider.on(I$2.connect, this.onConnectHandler), this.provider.on(I$2.disconnect, this.onDisconnectHandler), this.provider.on(I$2.error, this.onProviderErrorHandler);
    }, this.core = t.core, this.logger = typeof t.logger < "u" && typeof t.logger != "string" ? E$1(t.logger, this.name) : qt$3(k$2({ level: t.logger || nt$2 })), this.messages = new Yt$1(this.logger, t.core), this.subscriber = new Wt$1(this, this.logger), this.publisher = new Zr(this, this.logger), this.relayUrl = (t == null ? void 0 : t.relayUrl) || be$2, this.projectId = t.projectId, this.bundleId = Ot$2(), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = !0, this.subscriber.cached.length > 0) try {
      await this.transportOpen();
    } catch (t) {
      this.logger.warn(t);
    }
  }
  get context() {
    return y$3(this.logger);
  }
  get connected() {
    var t, Ie, Be;
    return ((Be = (Ie = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : Ie.socket) == null ? void 0 : Be.readyState) === 1;
  }
  get connecting() {
    var t, Ie, Be;
    return ((Be = (Ie = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : Ie.socket) == null ? void 0 : Be.readyState) === 0;
  }
  async publish(t, Ie, Be) {
    this.isInitialized(), await this.publisher.publish(t, Ie, Be), await this.recordMessageEvent({ topic: t, message: Ie, publishedAt: Date.now(), transportType: M$1.relay });
  }
  async subscribe(t, Ie) {
    var Be, Pe, Te;
    this.isInitialized(), (Ie == null ? void 0 : Ie.transportType) === "relay" && await this.toEstablishConnection();
    const Me = typeof ((Be = Ie == null ? void 0 : Ie.internal) == null ? void 0 : Be.throwOnFailedPublish) > "u" ? !0 : (Pe = Ie == null ? void 0 : Ie.internal) == null ? void 0 : Pe.throwOnFailedPublish;
    let Ue = ((Te = this.subscriber.topicMap.get(t)) == null ? void 0 : Te[0]) || "", je;
    const fn = (Ve) => {
      Ve.topic === t && (this.subscriber.off(O$2.created, fn), je());
    };
    return await Promise.all([new Promise((Ve) => {
      je = Ve, this.subscriber.on(O$2.created, fn);
    }), new Promise(async (Ve, vn) => {
      Ue = await this.subscriber.subscribe(t, ei({ internal: { throwOnFailedPublish: Me } }, Ie)).catch((En) => {
        Me && vn(En);
      }) || Ue, Ve();
    })]), Ue;
  }
  async unsubscribe(t, Ie) {
    this.isInitialized(), await this.subscriber.unsubscribe(t, Ie);
  }
  on(t, Ie) {
    this.events.on(t, Ie);
  }
  once(t, Ie) {
    this.events.once(t, Ie);
  }
  off(t, Ie) {
    this.events.off(t, Ie);
  }
  removeListener(t, Ie) {
    this.events.removeListener(t, Ie);
  }
  async transportDisconnect() {
    if (!this.hasExperiencedNetworkDisruption && this.connected && this.requestsInFlight.size > 0) try {
      await Promise.all(Array.from(this.requestsInFlight.values()).map((t) => t.promise));
    } catch (t) {
      this.logger.warn(t);
    }
    this.hasExperiencedNetworkDisruption || this.connected ? await kt$2(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = !0, await this.transportDisconnect();
  }
  async transportOpen(t) {
    await this.confirmOnlineStateOrThrow(), t && t !== this.relayUrl && (this.relayUrl = t, await this.transportDisconnect()), await this.createProvider(), this.connectionAttemptInProgress = !0, this.transportExplicitlyClosed = !1;
    try {
      await new Promise(async (Ie, Be) => {
        const Pe = () => {
          this.provider.off(I$2.disconnect, Pe), Be(new Error("Connection interrupted while trying to subscribe"));
        };
        this.provider.on(I$2.disconnect, Pe), await kt$2(this.provider.connect(), cjs$3.toMiliseconds(cjs$3.ONE_MINUTE), `Socket stalled when trying to connect to ${this.relayUrl}`).catch((Te) => {
          Be(Te);
        }).finally(() => {
          clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;
        }), this.subscriber.start().catch((Te) => {
          this.logger.error(Te), this.onDisconnectHandler();
        }), this.hasExperiencedNetworkDisruption = !1, Ie();
      });
    } catch (Ie) {
      this.logger.error(Ie);
      const Be = Ie;
      if (this.hasExperiencedNetworkDisruption = !0, !this.isConnectionStalled(Be.message)) throw Ie;
    } finally {
      this.connectionAttemptInProgress = !1;
    }
  }
  async restartTransport(t) {
    this.connectionAttemptInProgress || (this.relayUrl = t || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await mo()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(t) {
    if ((t == null ? void 0 : t.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const Ie = t.sort((Be, Pe) => Be.publishedAt - Pe.publishedAt);
    this.logger.trace(`Batch of ${Ie.length} message events sorted`);
    for (const Be of Ie) try {
      await this.onMessageEvent(Be);
    } catch (Pe) {
      this.logger.warn(Pe);
    }
    this.logger.trace(`Batch of ${Ie.length} message events processed`);
  }
  async onLinkMessageEvent(t, Ie) {
    const { topic: Be } = t;
    if (!Ie.sessionExists) {
      const Pe = Mt$2(cjs$3.FIVE_MINUTES), Te = { topic: Be, expiry: Pe, relay: { protocol: "irn" }, active: !1 };
      await this.core.pairing.pairings.set(Be, Te);
    }
    this.events.emit(v$2.message, t), await this.recordMessageEvent(t);
  }
  startPingTimeout() {
    var t, Ie, Be, Pe, Te;
    if (ce$1()) try {
      (Ie = (t = this.provider) == null ? void 0 : t.connection) != null && Ie.socket && ((Te = (Pe = (Be = this.provider) == null ? void 0 : Be.connection) == null ? void 0 : Pe.socket) == null || Te.once("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (Me) {
      this.logger.warn(Me);
    }
  }
  isConnectionStalled(t) {
    return this.staleConnectionErrors.some((Ie) => t.includes(Ie));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const t = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o$1(new f$2($t$2({ sdkVersion: se$2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: t, useOnCloseEvent: !0, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(t) {
    const { topic: Ie, message: Be } = t;
    await this.messages.set(Ie, Be);
  }
  async shouldIgnoreMessageEvent(t) {
    const { topic: Ie, message: Be } = t;
    if (!Be || Be.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${Be}`), !0;
    if (!await this.subscriber.isSubscribed(Ie)) return this.logger.debug(`Ignoring message for non-subscribed topic ${Ie}`), !0;
    const Pe = this.messages.has(Ie, Be);
    return Pe && this.logger.debug(`Ignoring duplicate message: ${Be}`), Pe;
  }
  async onProviderPayload(t) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: t }), isJsonRpcRequest(t)) {
      if (!t.method.endsWith(at$2)) return;
      const Ie = t.params, { topic: Be, message: Pe, publishedAt: Te, attestation: Me } = Ie.data, Ue = { topic: Be, message: Pe, publishedAt: Te, transportType: M$1.relay, attestation: Me };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(ei({ type: "event", event: Ie.id }, Ue)), this.events.emit(Ie.id, Ue), await this.acknowledgePayload(t), await this.onMessageEvent(Ue);
    } else isJsonRpcResponse(t) && this.events.emit(v$2.message_ack, t);
  }
  async onMessageEvent(t) {
    await this.shouldIgnoreMessageEvent(t) || (this.events.emit(v$2.message, t), await this.recordMessageEvent(t));
  }
  async acknowledgePayload(t) {
    const Ie = formatJsonRpcResult(t.id, !0);
    await this.provider.connection.send(Ie);
  }
  unregisterProviderListeners() {
    this.provider.off(I$2.payload, this.onPayloadHandler), this.provider.off(I$2.connect, this.onConnectHandler), this.provider.off(I$2.disconnect, this.onDisconnectHandler), this.provider.off(I$2.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let t = await mo();
    ho(async (Ie) => {
      t !== Ie && (t = Ie, Ie ? await this.restartTransport().catch((Be) => this.logger.error(Be)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportDisconnect(), this.transportExplicitlyClosed = !1));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), this.requestsInFlight.clear(), clearTimeout(this.pingTimeout), this.events.emit(v$2.disconnect), this.connectionAttemptInProgress = !1, !this.transportExplicitlyClosed && (this.reconnectTimeout || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((t) => this.logger.error(t));
    }, cjs$3.toMiliseconds(ht$2))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (this.connectionAttemptInProgress && await new Promise((t) => {
      const Ie = setInterval(() => {
        this.connected && (clearInterval(Ie), t());
      }, this.connectionStatusPollingInterval);
    }), await this.transportOpen());
  }
}
var cn = Object.defineProperty, ii = Object.getOwnPropertySymbols, ln = Object.prototype.hasOwnProperty, un = Object.prototype.propertyIsEnumerable, si = (Ae, t, Ie) => t in Ae ? cn(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, ri = (Ae, t) => {
  for (var Ie in t || (t = {})) ln.call(t, Ie) && si(Ae, Ie, t[Ie]);
  if (ii) for (var Ie of ii(t)) un.call(t, Ie) && si(Ae, Ie, t[Ie]);
  return Ae;
};
class ni extends p$1 {
  constructor(t, Ie, Be, Pe = x$3, Te = void 0) {
    super(t, Ie, Be, Pe), this.core = t, this.logger = Ie, this.name = Be, this.map = /* @__PURE__ */ new Map(), this.version = ct$2, this.cached = [], this.initialized = !1, this.storagePrefix = x$3, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((Me) => {
        this.getKey && Me !== null && !I$3(Me) ? this.map.set(this.getKey(Me), Me) : Yr$1(Me) ? this.map.set(Me.id, Me) : Qr$1(Me) && this.map.set(Me.topic, Me);
      }), this.cached = [], this.initialized = !0);
    }, this.set = async (Me, Ue) => {
      this.isInitialized(), this.map.has(Me) ? await this.update(Me, Ue) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: Me, value: Ue }), this.map.set(Me, Ue), await this.persist());
    }, this.get = (Me) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: Me }), this.getData(Me)), this.getAll = (Me) => (this.isInitialized(), Me ? this.values.filter((Ue) => Object.keys(Me).every((je) => ys$1(Ue[je], Me[je]))) : this.values), this.update = async (Me, Ue) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: Me, update: Ue });
      const je = ri(ri({}, this.getData(Me)), Ue);
      this.map.set(Me, je), await this.persist();
    }, this.delete = async (Me, Ue) => {
      this.isInitialized(), this.map.has(Me) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: Me, reason: Ue }), this.map.delete(Me), this.addToRecentlyDeleted(Me), await this.persist());
    }, this.logger = E$1(Ie, this.name), this.storagePrefix = Pe, this.getKey = Te;
  }
  get context() {
    return y$3(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(t) {
    this.recentlyDeleted.push(t), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(t) {
    await this.core.storage.setItem(this.storageKey, t);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(t) {
    const Ie = this.map.get(t);
    if (!Ie) {
      if (this.recentlyDeleted.includes(t)) {
        const { message: Pe } = S$4("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${t}`);
        throw this.logger.error(Pe), new Error(Pe);
      }
      const { message: Be } = S$4("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw this.logger.error(Be), new Error(Be);
    }
    return Ie;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const t = await this.getDataStore();
      if (typeof t > "u" || !t.length) return;
      if (this.map.size) {
        const { message: Ie } = S$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Ie), new Error(Ie);
      }
      this.cached = t, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(t);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class oi {
  constructor(t, Ie) {
    this.core = t, this.logger = Ie, this.name = gt$2, this.version = yt$2, this.events = new es(), this.initialized = !1, this.storagePrefix = x$3, this.ignoredPayloadTypes = [D$2], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
    }, this.register = ({ methods: Be }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...Be])];
    }, this.create = async (Be) => {
      this.isInitialized();
      const Pe = pr$2(), Te = await this.core.crypto.setSymKey(Pe), Me = Mt$2(cjs$3.FIVE_MINUTES), Ue = { protocol: rt$2 }, je = { topic: Te, expiry: Me, relay: Ue, active: !1, methods: Be == null ? void 0 : Be.methods }, fn = Dr$2({ protocol: this.core.protocol, version: this.core.version, topic: Te, symKey: Pe, relay: Ue, expiryTimestamp: Me, methods: Be == null ? void 0 : Be.methods });
      return this.events.emit(V$2.create, je), this.core.expirer.set(Te, Me), await this.pairings.set(Te, je), await this.core.relayer.subscribe(Te, { transportType: Be == null ? void 0 : Be.transportType }), { topic: Te, uri: fn };
    }, this.pair = async (Be) => {
      this.isInitialized();
      const Pe = this.core.eventClient.createEvent({ properties: { topic: Be == null ? void 0 : Be.uri, trace: [z$3.pairing_started] } });
      this.isValidPair(Be, Pe);
      const { topic: Te, symKey: Me, relay: Ue, expiryTimestamp: je, methods: fn } = kr$1(Be.uri);
      Pe.props.properties.topic = Te, Pe.addTrace(z$3.pairing_uri_validation_success), Pe.addTrace(z$3.pairing_uri_not_expired);
      let Ve;
      if (this.pairings.keys.includes(Te)) {
        if (Ve = this.pairings.get(Te), Pe.addTrace(z$3.existing_pairing), Ve.active) throw Pe.setError($$1.active_pairing_already_exists), new Error(`Pairing already exists: ${Te}. Please try again with a new connection URI.`);
        Pe.addTrace(z$3.pairing_not_expired);
      }
      const vn = je || Mt$2(cjs$3.FIVE_MINUTES), En = { topic: Te, relay: Ue, expiry: vn, active: !1, methods: fn };
      this.core.expirer.set(Te, vn), await this.pairings.set(Te, En), Pe.addTrace(z$3.store_new_pairing), Be.activatePairing && await this.activate({ topic: Te }), this.events.emit(V$2.create, En), Pe.addTrace(z$3.emit_inactive_pairing), this.core.crypto.keychain.has(Te) || await this.core.crypto.setSymKey(Me, Te), Pe.addTrace(z$3.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        Pe.setError($$1.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(Te, { relay: Ue });
      } catch (fi) {
        throw Pe.setError($$1.subscribe_pairing_topic_failure), fi;
      }
      return Pe.addTrace(z$3.subscribe_pairing_topic_success), En;
    }, this.activate = async ({ topic: Be }) => {
      this.isInitialized();
      const Pe = Mt$2(cjs$3.THIRTY_DAYS);
      this.core.expirer.set(Be, Pe), await this.pairings.update(Be, { active: !0, expiry: Pe });
    }, this.ping = async (Be) => {
      this.isInitialized(), await this.isValidPing(Be);
      const { topic: Pe } = Be;
      if (this.pairings.keys.includes(Pe)) {
        const Te = await this.sendRequest(Pe, "wc_pairingPing", {}), { done: Me, resolve: Ue, reject: je } = _t$2();
        this.events.once(Lt$2("pairing_ping", Te), ({ error: fn }) => {
          fn ? je(fn) : Ue();
        }), await Me();
      }
    }, this.updateExpiry = async ({ topic: Be, expiry: Pe }) => {
      this.isInitialized(), await this.pairings.update(Be, { expiry: Pe });
    }, this.updateMetadata = async ({ topic: Be, metadata: Pe }) => {
      this.isInitialized(), await this.pairings.update(Be, { peerMetadata: Pe });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (Be) => {
      this.isInitialized(), await this.isValidDisconnect(Be);
      const { topic: Pe } = Be;
      this.pairings.keys.includes(Pe) && (await this.sendRequest(Pe, "wc_pairingDelete", U$2("USER_DISCONNECTED")), await this.deletePairing(Pe));
    }, this.formatUriFromPairing = (Be) => {
      this.isInitialized();
      const { topic: Pe, relay: Te, expiry: Me, methods: Ue } = Be, je = this.core.crypto.keychain.get(Pe);
      return Dr$2({ protocol: this.core.protocol, version: this.core.version, topic: Pe, symKey: je, relay: Te, expiryTimestamp: Me, methods: Ue });
    }, this.sendRequest = async (Be, Pe, Te) => {
      const Me = formatJsonRpcRequest(Pe, Te), Ue = await this.core.crypto.encode(Be, Me), je = B$2[Pe].req;
      return this.core.history.set(Be, Me), this.core.relayer.publish(Be, Ue, je), Me.id;
    }, this.sendResult = async (Be, Pe, Te) => {
      const Me = formatJsonRpcResult(Be, Te), Ue = await this.core.crypto.encode(Pe, Me), je = await this.core.history.get(Pe, Be), fn = B$2[je.request.method].res;
      await this.core.relayer.publish(Pe, Ue, fn), await this.core.history.resolve(Me);
    }, this.sendError = async (Be, Pe, Te) => {
      const Me = formatJsonRpcError(Be, Te), Ue = await this.core.crypto.encode(Pe, Me), je = await this.core.history.get(Pe, Be), fn = B$2[je.request.method] ? B$2[je.request.method].res : B$2.unregistered_method.res;
      await this.core.relayer.publish(Pe, Ue, fn), await this.core.history.resolve(Me);
    }, this.deletePairing = async (Be, Pe) => {
      await this.core.relayer.unsubscribe(Be), await Promise.all([this.pairings.delete(Be, U$2("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(Be), Pe ? Promise.resolve() : this.core.expirer.del(Be)]);
    }, this.cleanup = async () => {
      const Be = this.pairings.getAll().filter((Pe) => Kt$2(Pe.expiry));
      await Promise.all(Be.map((Pe) => this.deletePairing(Pe.topic)));
    }, this.onRelayEventRequest = (Be) => {
      const { topic: Pe, payload: Te } = Be;
      switch (Te.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(Pe, Te);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(Pe, Te);
        default:
          return this.onUnknownRpcMethodRequest(Pe, Te);
      }
    }, this.onRelayEventResponse = async (Be) => {
      const { topic: Pe, payload: Te } = Be, Me = (await this.core.history.get(Pe, Te.id)).request.method;
      switch (Me) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(Pe, Te);
        default:
          return this.onUnknownRpcMethodResponse(Me);
      }
    }, this.onPairingPingRequest = async (Be, Pe) => {
      const { id: Te } = Pe;
      try {
        this.isValidPing({ topic: Be }), await this.sendResult(Te, Be, !0), this.events.emit(V$2.ping, { id: Te, topic: Be });
      } catch (Me) {
        await this.sendError(Te, Be, Me), this.logger.error(Me);
      }
    }, this.onPairingPingResponse = (Be, Pe) => {
      const { id: Te } = Pe;
      setTimeout(() => {
        isJsonRpcResult(Pe) ? this.events.emit(Lt$2("pairing_ping", Te), {}) : isJsonRpcError(Pe) && this.events.emit(Lt$2("pairing_ping", Te), { error: Pe.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (Be, Pe) => {
      const { id: Te } = Pe;
      try {
        this.isValidDisconnect({ topic: Be }), await this.deletePairing(Be), this.events.emit(V$2.delete, { id: Te, topic: Be });
      } catch (Me) {
        await this.sendError(Te, Be, Me), this.logger.error(Me);
      }
    }, this.onUnknownRpcMethodRequest = async (Be, Pe) => {
      const { id: Te, method: Me } = Pe;
      try {
        if (this.registeredMethods.includes(Me)) return;
        const Ue = U$2("WC_METHOD_UNSUPPORTED", Me);
        await this.sendError(Te, Be, Ue), this.logger.error(Ue);
      } catch (Ue) {
        await this.sendError(Te, Be, Ue), this.logger.error(Ue);
      }
    }, this.onUnknownRpcMethodResponse = (Be) => {
      this.registeredMethods.includes(Be) || this.logger.error(U$2("WC_METHOD_UNSUPPORTED", Be));
    }, this.isValidPair = (Be, Pe) => {
      var Te;
      if (!to(Be)) {
        const { message: Ue } = S$4("MISSING_OR_INVALID", `pair() params: ${Be}`);
        throw Pe.setError($$1.malformed_pairing_uri), new Error(Ue);
      }
      if (!Gr$1(Be.uri)) {
        const { message: Ue } = S$4("MISSING_OR_INVALID", `pair() uri: ${Be.uri}`);
        throw Pe.setError($$1.malformed_pairing_uri), new Error(Ue);
      }
      const Me = kr$1(Be == null ? void 0 : Be.uri);
      if (!((Te = Me == null ? void 0 : Me.relay) != null && Te.protocol)) {
        const { message: Ue } = S$4("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw Pe.setError($$1.malformed_pairing_uri), new Error(Ue);
      }
      if (!(Me != null && Me.symKey)) {
        const { message: Ue } = S$4("MISSING_OR_INVALID", "pair() uri#symKey");
        throw Pe.setError($$1.malformed_pairing_uri), new Error(Ue);
      }
      if (Me != null && Me.expiryTimestamp && cjs$3.toMiliseconds(Me == null ? void 0 : Me.expiryTimestamp) < Date.now()) {
        Pe.setError($$1.pairing_expired);
        const { message: Ue } = S$4("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(Ue);
      }
    }, this.isValidPing = async (Be) => {
      if (!to(Be)) {
        const { message: Te } = S$4("MISSING_OR_INVALID", `ping() params: ${Be}`);
        throw new Error(Te);
      }
      const { topic: Pe } = Be;
      await this.isValidPairingTopic(Pe);
    }, this.isValidDisconnect = async (Be) => {
      if (!to(Be)) {
        const { message: Te } = S$4("MISSING_OR_INVALID", `disconnect() params: ${Be}`);
        throw new Error(Te);
      }
      const { topic: Pe } = Be;
      await this.isValidPairingTopic(Pe);
    }, this.isValidPairingTopic = async (Be) => {
      if (!b$2(Be, !1)) {
        const { message: Pe } = S$4("MISSING_OR_INVALID", `pairing topic should be a string: ${Be}`);
        throw new Error(Pe);
      }
      if (!this.pairings.keys.includes(Be)) {
        const { message: Pe } = S$4("NO_MATCHING_KEY", `pairing topic doesn't exist: ${Be}`);
        throw new Error(Pe);
      }
      if (Kt$2(this.pairings.get(Be).expiry)) {
        await this.deletePairing(Be);
        const { message: Pe } = S$4("EXPIRED", `pairing topic: ${Be}`);
        throw new Error(Pe);
      }
    }, this.core = t, this.logger = E$1(Ie, this.name), this.pairings = new ni(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y$3(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(v$2.message, async (t) => {
      const { topic: Ie, message: Be, transportType: Pe } = t;
      if (!this.pairings.keys.includes(Ie) || Pe === M$1.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(Be))) return;
      const Te = await this.core.crypto.decode(Ie, Be);
      try {
        isJsonRpcRequest(Te) ? (this.core.history.set(Ie, Te), this.onRelayEventRequest({ topic: Ie, payload: Te })) : isJsonRpcResponse(Te) && (await this.core.history.resolve(Te), await this.onRelayEventResponse({ topic: Ie, payload: Te }), this.core.history.delete(Ie, Te.id));
      } catch (Me) {
        this.logger.error(Me);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(S$2.expired, async (t) => {
      const { topic: Ie } = Vt$2(t.target);
      Ie && this.pairings.keys.includes(Ie) && (await this.deletePairing(Ie, !0), this.events.emit(V$2.expire, { topic: Ie }));
    });
  }
}
class ai extends h$1 {
  constructor(t, Ie) {
    super(t, Ie), this.core = t, this.logger = Ie, this.records = /* @__PURE__ */ new Map(), this.events = new eventsExports.EventEmitter(), this.name = Dt$1, this.version = mt$1, this.cached = [], this.initialized = !1, this.storagePrefix = x$3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((Be) => this.records.set(Be.id, Be)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.set = (Be, Pe, Te) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: Be, request: Pe, chainId: Te }), this.records.has(Pe.id)) return;
      const Me = { id: Pe.id, topic: Be, request: { method: Pe.method, params: Pe.params || null }, chainId: Te, expiry: Mt$2(cjs$3.THIRTY_DAYS) };
      this.records.set(Me.id, Me), this.persist(), this.events.emit(P$1.created, Me);
    }, this.resolve = async (Be) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: Be }), !this.records.has(Be.id)) return;
      const Pe = await this.getRecord(Be.id);
      typeof Pe.response > "u" && (Pe.response = isJsonRpcError(Be) ? { error: Be.error } : { result: Be.result }, this.records.set(Pe.id, Pe), this.persist(), this.events.emit(P$1.updated, Pe));
    }, this.get = async (Be, Pe) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: Be, id: Pe }), await this.getRecord(Pe)), this.delete = (Be, Pe) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: Pe }), this.values.forEach((Te) => {
        if (Te.topic === Be) {
          if (typeof Pe < "u" && Te.id !== Pe) return;
          this.records.delete(Te.id), this.events.emit(P$1.deleted, Te);
        }
      }), this.persist();
    }, this.exists = async (Be, Pe) => (this.isInitialized(), this.records.has(Pe) ? (await this.getRecord(Pe)).topic === Be : !1), this.on = (Be, Pe) => {
      this.events.on(Be, Pe);
    }, this.once = (Be, Pe) => {
      this.events.once(Be, Pe);
    }, this.off = (Be, Pe) => {
      this.events.off(Be, Pe);
    }, this.removeListener = (Be, Pe) => {
      this.events.removeListener(Be, Pe);
    }, this.logger = E$1(Ie, this.name);
  }
  get context() {
    return y$3(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const t = [];
    return this.values.forEach((Ie) => {
      if (typeof Ie.response < "u") return;
      const Be = { topic: Ie.topic, request: formatJsonRpcRequest(Ie.request.method, Ie.request.params, Ie.id), chainId: Ie.chainId };
      return t.push(Be);
    }), t;
  }
  async setJsonRpcRecords(t) {
    await this.core.storage.setItem(this.storageKey, t);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(t) {
    this.isInitialized();
    const Ie = this.records.get(t);
    if (!Ie) {
      const { message: Be } = S$4("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw new Error(Be);
    }
    return Ie;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(P$1.sync);
  }
  async restore() {
    try {
      const t = await this.getJsonRpcRecords();
      if (typeof t > "u" || !t.length) return;
      if (this.records.size) {
        const { message: Ie } = S$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Ie), new Error(Ie);
      }
      this.cached = t, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(t);
    }
  }
  registerEventListeners() {
    this.events.on(P$1.created, (t) => {
      const Ie = P$1.created;
      this.logger.info(`Emitting ${Ie}`), this.logger.debug({ type: "event", event: Ie, record: t });
    }), this.events.on(P$1.updated, (t) => {
      const Ie = P$1.updated;
      this.logger.info(`Emitting ${Ie}`), this.logger.debug({ type: "event", event: Ie, record: t });
    }), this.events.on(P$1.deleted, (t) => {
      const Ie = P$1.deleted;
      this.logger.info(`Emitting ${Ie}`), this.logger.debug({ type: "event", event: Ie, record: t });
    }), this.core.heartbeat.on(r$1.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let t = !1;
      this.records.forEach((Ie) => {
        cjs$3.toMiliseconds(Ie.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${Ie.id}`), this.records.delete(Ie.id), this.events.emit(P$1.deleted, Ie, !1), t = !0);
      }), t && this.persist();
    } catch (t) {
      this.logger.warn(t);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class hi extends x$4 {
  constructor(t, Ie) {
    super(t, Ie), this.core = t, this.logger = Ie, this.expirations = /* @__PURE__ */ new Map(), this.events = new eventsExports.EventEmitter(), this.name = bt$1, this.version = ft$1, this.cached = [], this.initialized = !1, this.storagePrefix = x$3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((Be) => this.expirations.set(Be.target, Be)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.has = (Be) => {
      try {
        const Pe = this.formatTarget(Be);
        return typeof this.getExpiration(Pe) < "u";
      } catch {
        return !1;
      }
    }, this.set = (Be, Pe) => {
      this.isInitialized();
      const Te = this.formatTarget(Be), Me = { target: Te, expiry: Pe };
      this.expirations.set(Te, Me), this.checkExpiry(Te, Me), this.events.emit(S$2.created, { target: Te, expiration: Me });
    }, this.get = (Be) => {
      this.isInitialized();
      const Pe = this.formatTarget(Be);
      return this.getExpiration(Pe);
    }, this.del = (Be) => {
      if (this.isInitialized(), this.has(Be)) {
        const Pe = this.formatTarget(Be), Te = this.getExpiration(Pe);
        this.expirations.delete(Pe), this.events.emit(S$2.deleted, { target: Pe, expiration: Te });
      }
    }, this.on = (Be, Pe) => {
      this.events.on(Be, Pe);
    }, this.once = (Be, Pe) => {
      this.events.once(Be, Pe);
    }, this.off = (Be, Pe) => {
      this.events.off(Be, Pe);
    }, this.removeListener = (Be, Pe) => {
      this.events.removeListener(Be, Pe);
    }, this.logger = E$1(Ie, this.name);
  }
  get context() {
    return y$3(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(t) {
    if (typeof t == "string") return Dt$2(t);
    if (typeof t == "number") return xt$2(t);
    const { message: Ie } = S$4("UNKNOWN_TYPE", `Target type: ${typeof t}`);
    throw new Error(Ie);
  }
  async setExpirations(t) {
    await this.core.storage.setItem(this.storageKey, t);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(S$2.sync);
  }
  async restore() {
    try {
      const t = await this.getExpirations();
      if (typeof t > "u" || !t.length) return;
      if (this.expirations.size) {
        const { message: Ie } = S$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(Ie), new Error(Ie);
      }
      this.cached = t, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (t) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(t);
    }
  }
  getExpiration(t) {
    const Ie = this.expirations.get(t);
    if (!Ie) {
      const { message: Be } = S$4("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw this.logger.warn(Be), new Error(Be);
    }
    return Ie;
  }
  checkExpiry(t, Ie) {
    const { expiry: Be } = Ie;
    cjs$3.toMiliseconds(Be) - Date.now() <= 0 && this.expire(t, Ie);
  }
  expire(t, Ie) {
    this.expirations.delete(t), this.events.emit(S$2.expired, { target: t, expiration: Ie });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((t, Ie) => this.checkExpiry(Ie, t));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r$1.pulse, () => this.checkExpirations()), this.events.on(S$2.created, (t) => {
      const Ie = S$2.created;
      this.logger.info(`Emitting ${Ie}`), this.logger.debug({ type: "event", event: Ie, data: t }), this.persist();
    }), this.events.on(S$2.expired, (t) => {
      const Ie = S$2.expired;
      this.logger.info(`Emitting ${Ie}`), this.logger.debug({ type: "event", event: Ie, data: t }), this.persist();
    }), this.events.on(S$2.deleted, (t) => {
      const Ie = S$2.deleted;
      this.logger.info(`Emitting ${Ie}`), this.logger.debug({ type: "event", event: Ie, data: t }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
}
class ci extends y$2 {
  constructor(t, Ie, Be) {
    super(t, Ie, Be), this.core = t, this.logger = Ie, this.store = Be, this.name = _t$1, this.verifyUrlV3 = vt$1, this.storagePrefix = x$3, this.version = De$1, this.init = async () => {
      var Pe;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && cjs$3.toMiliseconds((Pe = this.publicKey) == null ? void 0 : Pe.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }, this.register = async (Pe) => {
      if (!V$3() || this.isDevEnv) return;
      const Te = window.location.origin, { id: Me, decryptedId: Ue } = Pe, je = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${Te}&id=${Me}&decryptedId=${Ue}`;
      try {
        const fn = getDocument_1(), Ve = this.startAbortTimer(cjs$3.ONE_SECOND * 5), vn = await new Promise((En, fi) => {
          const bi = () => {
            window.removeEventListener("message", _i), fn.body.removeChild(mi), fi("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", bi);
          const mi = fn.createElement("iframe");
          mi.src = je, mi.style.display = "none", mi.addEventListener("error", bi, { signal: this.abortController.signal });
          const _i = (Ei) => {
            if (Ei.data && typeof Ei.data == "string") try {
              const Si = JSON.parse(Ei.data);
              if (Si.type === "verify_attestation") {
                if (decodeJWT(Si.attestation).payload.id !== Me) return;
                clearInterval(Ve), fn.body.removeChild(mi), this.abortController.signal.removeEventListener("abort", bi), window.removeEventListener("message", _i), En(Si.attestation === null ? "" : Si.attestation);
              }
            } catch (Si) {
              this.logger.warn(Si);
            }
          };
          fn.body.appendChild(mi), window.addEventListener("message", _i, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", vn), vn;
      } catch (fn) {
        this.logger.warn(fn);
      }
      return "";
    }, this.resolve = async (Pe) => {
      if (this.isDevEnv) return "";
      const { attestationId: Te, hash: Me, encryptedId: Ue } = Pe;
      if (Te === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (Te) {
        if (decodeJWT(Te).payload.id !== Ue) return;
        const fn = await this.isValidJwtAttestation(Te);
        if (fn) {
          if (!fn.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return fn;
        }
      }
      if (!Me) return;
      const je = this.getVerifyUrl(Pe == null ? void 0 : Pe.verifyUrl);
      return this.fetchAttestation(Me, je);
    }, this.fetchAttestation = async (Pe, Te) => {
      this.logger.debug(`resolving attestation: ${Pe} from url: ${Te}`);
      const Me = this.startAbortTimer(cjs$3.ONE_SECOND * 5), Ue = await fetch(`${Te}/attestation/${Pe}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(Me), Ue.status === 200 ? await Ue.json() : void 0;
    }, this.getVerifyUrl = (Pe) => {
      let Te = Pe || J$1;
      return wt$1.includes(Te) || (this.logger.info(`verify url: ${Te}, not included in trusted list, assigning default: ${J$1}`), Te = J$1), Te;
    }, this.fetchPublicKey = async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const Pe = this.startAbortTimer(cjs$3.FIVE_SECONDS), Te = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(Pe), await Te.json();
      } catch (Pe) {
        this.logger.warn(Pe);
      }
    }, this.persistPublicKey = async (Pe) => {
      this.logger.debug("persisting public key to local storage", Pe), await this.store.setItem(this.storeKey, Pe), this.publicKey = Pe;
    }, this.removePublicKey = async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }, this.isValidJwtAttestation = async (Pe) => {
      const Te = await this.getPublicKey();
      try {
        if (Te) return this.validateAttestation(Pe, Te);
      } catch (Ue) {
        this.logger.error(Ue), this.logger.warn("error validating attestation");
      }
      const Me = await this.fetchAndPersistPublicKey();
      try {
        if (Me) return this.validateAttestation(Pe, Me);
      } catch (Ue) {
        this.logger.error(Ue), this.logger.warn("error validating attestation");
      }
    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (Te) => {
        const Me = await this.fetchPublicKey();
        Me && (await this.persistPublicKey(Me), Te(Me));
      });
      const Pe = await this.fetchPromise;
      return this.fetchPromise = void 0, Pe;
    }, this.validateAttestation = (Pe, Te) => {
      const Me = Rr$2(Pe, Te.publicKey), Ue = { hasExpired: cjs$3.toMiliseconds(Me.exp) < Date.now(), payload: Me };
      if (Ue.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: Ue.payload.origin, isScam: Ue.payload.isScam, isVerified: Ue.payload.isVerified };
    }, this.logger = E$1(Ie, this.name), this.abortController = new AbortController(), this.isDevEnv = Wt$2(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y$3(this.logger);
  }
  startAbortTimer(t) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), cjs$3.toMiliseconds(t));
  }
}
class li extends v$3 {
  constructor(t, Ie) {
    super(t, Ie), this.projectId = t, this.logger = Ie, this.context = It$1, this.registerDeviceToken = async (Be) => {
      const { clientId: Pe, token: Te, notificationType: Me, enableEncrypted: Ue = !1 } = Be, je = `${Tt$1}/${this.projectId}/clients`;
      await fetch(je, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: Pe, type: Me, token: Te, always_raw: Ue }) });
    }, this.logger = E$1(Ie, this.context);
  }
}
var dn = Object.defineProperty, ui = Object.getOwnPropertySymbols, pn = Object.prototype.hasOwnProperty, gn = Object.prototype.propertyIsEnumerable, di = (Ae, t, Ie) => t in Ae ? dn(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, Z$2 = (Ae, t) => {
  for (var Ie in t || (t = {})) pn.call(t, Ie) && di(Ae, Ie, t[Ie]);
  if (ui) for (var Ie of ui(t)) gn.call(t, Ie) && di(Ae, Ie, t[Ie]);
  return Ae;
};
class pi extends C$3 {
  constructor(t, Ie, Be = !0) {
    super(t, Ie, Be), this.core = t, this.logger = Ie, this.context = Pt$1, this.storagePrefix = x$3, this.storageVersion = Ct$1, this.events = /* @__PURE__ */ new Map(), this.shouldPersist = !1, this.init = async () => {
      if (!Wt$2()) try {
        const Pe = { eventId: Ht$2(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Ge(this.core.relayer.protocol, this.core.relayer.version, se$2) } } };
        await this.sendEvent([Pe]);
      } catch (Pe) {
        this.logger.warn(Pe);
      }
    }, this.createEvent = (Pe) => {
      const { event: Te = "ERROR", type: Me = "", properties: { topic: Ue, trace: je } } = Pe, fn = Ht$2(), Ve = this.core.projectId || "", vn = Date.now(), En = Z$2({ eventId: fn, timestamp: vn, props: { event: Te, type: Me, properties: { topic: Ue, trace: je } }, bundleId: Ve, domain: this.getAppDomain() }, this.setMethods(fn));
      return this.telemetryEnabled && (this.events.set(fn, En), this.shouldPersist = !0), En;
    }, this.getEvent = (Pe) => {
      const { eventId: Te, topic: Me } = Pe;
      if (Te) return this.events.get(Te);
      const Ue = Array.from(this.events.values()).find((je) => je.props.properties.topic === Me);
      if (Ue) return Z$2(Z$2({}, Ue), this.setMethods(Ue.eventId));
    }, this.deleteEvent = (Pe) => {
      const { eventId: Te } = Pe;
      this.events.delete(Te), this.shouldPersist = !0;
    }, this.setEventListeners = () => {
      this.core.heartbeat.on(r$1.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((Pe) => {
          cjs$3.fromMiliseconds(Date.now()) - cjs$3.fromMiliseconds(Pe.timestamp) > St$1 && (this.events.delete(Pe.eventId), this.shouldPersist = !0);
        });
      });
    }, this.setMethods = (Pe) => ({ addTrace: (Te) => this.addTrace(Pe, Te), setError: (Te) => this.setError(Pe, Te) }), this.addTrace = (Pe, Te) => {
      const Me = this.events.get(Pe);
      Me && (Me.props.properties.trace.push(Te), this.events.set(Pe, Me), this.shouldPersist = !0);
    }, this.setError = (Pe, Te) => {
      const Me = this.events.get(Pe);
      Me && (Me.props.type = Te, Me.timestamp = Date.now(), this.events.set(Pe, Me), this.shouldPersist = !0);
    }, this.persist = async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = !1;
    }, this.restore = async () => {
      try {
        const Pe = await this.core.storage.getItem(this.storageKey) || [];
        if (!Pe.length) return;
        Pe.forEach((Te) => {
          this.events.set(Te.eventId, Z$2(Z$2({}, Te), this.setMethods(Te.eventId)));
        });
      } catch (Pe) {
        this.logger.warn(Pe);
      }
    }, this.submit = async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const Pe = [];
      for (const [Te, Me] of this.events) Me.props.type && Pe.push(Me);
      if (Pe.length !== 0) try {
        if ((await this.sendEvent(Pe)).ok) for (const Te of Pe) this.events.delete(Te.eventId), this.shouldPersist = !0;
      } catch (Te) {
        this.logger.warn(Te);
      }
    }, this.sendEvent = async (Pe) => {
      const Te = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${Rt$1}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${se$2}${Te}`, { method: "POST", body: JSON.stringify(Pe) });
    }, this.getAppDomain = () => Nt$2().url, this.logger = E$1(Ie, this.context), this.telemetryEnabled = Be, Be ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
}
var yn = Object.defineProperty, gi = Object.getOwnPropertySymbols, Dn = Object.prototype.hasOwnProperty, mn = Object.prototype.propertyIsEnumerable, yi = (Ae, t, Ie) => t in Ae ? yn(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, Di = (Ae, t) => {
  for (var Ie in t || (t = {})) Dn.call(t, Ie) && yi(Ae, Ie, t[Ie]);
  if (gi) for (var Ie of gi(t)) mn.call(t, Ie) && yi(Ae, Ie, t[Ie]);
  return Ae;
};
let ne$2 = class Vc extends n$1 {
  constructor(t) {
    var Ie;
    super(t), this.protocol = ye$2, this.version = De$1, this.name = ie$2, this.events = new eventsExports.EventEmitter(), this.initialized = !1, this.on = (Me, Ue) => this.events.on(Me, Ue), this.once = (Me, Ue) => this.events.once(Me, Ue), this.off = (Me, Ue) => this.events.off(Me, Ue), this.removeListener = (Me, Ue) => this.events.removeListener(Me, Ue), this.dispatchEnvelope = ({ topic: Me, message: Ue, sessionExists: je }) => {
      if (!Me || !Ue) return;
      const fn = { topic: Me, message: Ue, publishedAt: Date.now(), transportType: M$1.link_mode };
      this.relayer.onLinkMessageEvent(fn, { sessionExists: je });
    }, this.projectId = t == null ? void 0 : t.projectId, this.relayUrl = (t == null ? void 0 : t.relayUrl) || be$2, this.customStoragePrefix = t != null && t.customStoragePrefix ? `:${t.customStoragePrefix}` : "";
    const Be = k$2({ level: typeof (t == null ? void 0 : t.logger) == "string" && t.logger ? t.logger : Ye.logger }), { logger: Pe, chunkLoggerController: Te } = A$1({ opts: Be, maxSizeInBytes: t == null ? void 0 : t.maxLogBlobSizeInBytes, loggerOverride: t == null ? void 0 : t.logger });
    this.logChunkController = Te, (Ie = this.logChunkController) != null && Ie.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var Me, Ue;
      (Me = this.logChunkController) != null && Me.downloadLogsBlobInBrowser && ((Ue = this.logChunkController) == null || Ue.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E$1(Pe, this.name), this.heartbeat = new i$1(), this.crypto = new Ht$1(this, this.logger, t == null ? void 0 : t.keychain), this.history = new ai(this, this.logger), this.expirer = new hi(this, this.logger), this.storage = t != null && t.storage ? t.storage : new h$2(Di(Di({}, Je), t == null ? void 0 : t.storageOptions)), this.relayer = new ti({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new oi(this, this.logger), this.verify = new ci(this, this.logger, this.storage), this.echoClient = new li(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new pi(this, this.logger, t == null ? void 0 : t.telemetryEnabled);
  }
  static async init(t) {
    const Ie = new Vc(t);
    await Ie.initialize();
    const Be = await Ie.crypto.getClientId();
    return await Ie.storage.setItem(lt$2, Be), Ie;
  }
  get context() {
    return y$3(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var t;
    return (t = this.logChunkController) == null ? void 0 : t.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(t) {
    this.linkModeSupportedApps.includes(t) || (this.linkModeSupportedApps.push(t), await this.storage.setItem(fe$1, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.eventClient.init(), this.linkModeSupportedApps = await this.storage.getItem(fe$1) || [], this.initialized = !0, this.logger.info("Core Initialization Success");
    } catch (t) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, t), this.logger.error(t.message), t;
    }
  }
};
const bn = ne$2;
function unfetch_module(Ae, t) {
  return t = t || {}, new Promise(function(Ie, Be) {
    var Pe = new XMLHttpRequest(), Te = [], Me = [], Ue = {}, je = function() {
      return { ok: (Pe.status / 100 | 0) == 2, statusText: Pe.statusText, status: Pe.status, url: Pe.responseURL, text: function() {
        return Promise.resolve(Pe.responseText);
      }, json: function() {
        return Promise.resolve(Pe.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([Pe.response]));
      }, clone: je, headers: { keys: function() {
        return Te;
      }, entries: function() {
        return Me;
      }, get: function(Ve) {
        return Ue[Ve.toLowerCase()];
      }, has: function(Ve) {
        return Ve.toLowerCase() in Ue;
      } } };
    };
    for (var fn in Pe.open(t.method || "get", Ae, !0), Pe.onload = function() {
      Pe.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(Ve, vn, En) {
        Te.push(vn = vn.toLowerCase()), Me.push([vn, En]), Ue[vn] = Ue[vn] ? Ue[vn] + "," + En : En;
      }), Ie(je());
    }, Pe.onerror = Be, Pe.withCredentials = t.credentials == "include", t.headers) Pe.setRequestHeader(fn, t.headers[fn]);
    Pe.send(t.body || null);
  });
}
const unfetch_module$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: unfetch_module
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(unfetch_module$1);
var browser = self.fetch || (self.fetch = require$$0.default || require$$0);
const ke = /* @__PURE__ */ getDefaultExportFromCjs(browser);
class G {
  constructor(t) {
    this.client = t;
  }
}
class H {
  constructor(t) {
    this.opts = t;
  }
}
const Y$1 = "https://rpc.walletconnect.com/v1", R$1 = { wc_authRequest: { req: { ttl: cjs$3.ONE_DAY, prompt: !0, tag: 3e3 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 3001 } } }, U$1 = { min: cjs$3.FIVE_MINUTES, max: cjs$3.SEVEN_DAYS }, $ = "wc", Q = 1, Z$1 = "auth", B$1 = "authClient", F$1 = `${$}@1:${Z$1}:`, x$2 = `${F$1}:PUB_KEY`;
function z$2(Ae) {
  return Ae == null ? void 0 : Ae.split(":");
}
function Ze(Ae) {
  const t = Ae && z$2(Ae);
  if (t) return t[3];
}
function We(Ae) {
  const t = Ae && z$2(Ae);
  if (t) return t[2] + ":" + t[3];
}
function W(Ae) {
  const t = Ae && z$2(Ae);
  if (t) return t.pop();
}
async function et(Ae, t, Ie, Be, Pe) {
  switch (Ie.t) {
    case "eip191":
      return tt(Ae, t, Ie.s);
    case "eip1271":
      return await rt$1(Ae, t, Ie.s, Be, Pe);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${Ie.t}`);
  }
}
function tt(Ae, t, Ie) {
  return recoverAddress(hashMessage(t), Ie).toLowerCase() === Ae.toLowerCase();
}
async function rt$1(Ae, t, Ie, Be, Pe) {
  try {
    const Te = "0x1626ba7e", Me = "0000000000000000000000000000000000000000000000000000000000000040", Ue = "0000000000000000000000000000000000000000000000000000000000000041", je = Ie.substring(2), fn = hashMessage(t).substring(2), Ve = Te + fn + Me + Ue + je, vn = await ke(`${Y$1}/?chainId=${Be}&projectId=${Pe}`, { method: "POST", body: JSON.stringify({ id: it$1(), jsonrpc: "2.0", method: "eth_call", params: [{ to: Ae, data: Ve }, "latest"] }) }), { result: En } = await vn.json();
    return En ? En.slice(0, Te.length).toLowerCase() === Te.toLowerCase() : !1;
  } catch (Te) {
    return console.error("isValidEip1271Signature: ", Te), !1;
  }
}
function it$1() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function ee$1(Ae) {
  return Ae.getAll().filter((t) => "requester" in t);
}
function te$1(Ae, t) {
  return ee$1(Ae).find((Ie) => Ie.id === t);
}
function nt$1(Ae) {
  const t = Gr$1(Ae.aud), Ie = new RegExp(`${Ae.domain}`).test(Ae.aud), Be = !!Ae.nonce, Pe = Ae.type ? Ae.type === "eip4361" : !0, Te = Ae.expiry;
  if (Te && !po(Te, U$1)) {
    const { message: Me } = S$4("MISSING_OR_INVALID", `request() expiry: ${Te}. Expiry must be a number (in seconds) between ${U$1.min} and ${U$1.max}`);
    throw new Error(Me);
  }
  return !!(t && Ie && Be && Pe);
}
function st$1(Ae, t) {
  return !!te$1(t, Ae.id);
}
function ot$1(Ae = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(Ae) : new Uint8Array(Ae);
}
function ut$1(Ae, t) {
  if (Ae.length >= 255) throw new TypeError("Alphabet too long");
  for (var Ie = new Uint8Array(256), Be = 0; Be < Ie.length; Be++) Ie[Be] = 255;
  for (var Pe = 0; Pe < Ae.length; Pe++) {
    var Te = Ae.charAt(Pe), Me = Te.charCodeAt(0);
    if (Ie[Me] !== 255) throw new TypeError(Te + " is ambiguous");
    Ie[Me] = Pe;
  }
  var Ue = Ae.length, je = Ae.charAt(0), fn = Math.log(Ue) / Math.log(256), Ve = Math.log(256) / Math.log(Ue);
  function vn(bi) {
    if (bi instanceof Uint8Array || (ArrayBuffer.isView(bi) ? bi = new Uint8Array(bi.buffer, bi.byteOffset, bi.byteLength) : Array.isArray(bi) && (bi = Uint8Array.from(bi))), !(bi instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (bi.length === 0) return "";
    for (var mi = 0, _i = 0, Ei = 0, Si = bi.length; Ei !== Si && bi[Ei] === 0; ) Ei++, mi++;
    for (var Mi = (Si - Ei) * Ve + 1 >>> 0, Oi = new Uint8Array(Mi); Ei !== Si; ) {
      for (var Fi = bi[Ei], Ui = 0, Pi = Mi - 1; (Fi !== 0 || Ui < _i) && Pi !== -1; Pi--, Ui++) Fi += 256 * Oi[Pi] >>> 0, Oi[Pi] = Fi % Ue >>> 0, Fi = Fi / Ue >>> 0;
      if (Fi !== 0) throw new Error("Non-zero carry");
      _i = Ui, Ei++;
    }
    for (var Bi = Mi - _i; Bi !== Mi && Oi[Bi] === 0; ) Bi++;
    for (var ji = je.repeat(mi); Bi < Mi; ++Bi) ji += Ae.charAt(Oi[Bi]);
    return ji;
  }
  function En(bi) {
    if (typeof bi != "string") throw new TypeError("Expected String");
    if (bi.length === 0) return new Uint8Array();
    var mi = 0;
    if (bi[mi] !== " ") {
      for (var _i = 0, Ei = 0; bi[mi] === je; ) _i++, mi++;
      for (var Si = (bi.length - mi) * fn + 1 >>> 0, Mi = new Uint8Array(Si); bi[mi]; ) {
        var Oi = Ie[bi.charCodeAt(mi)];
        if (Oi === 255) return;
        for (var Fi = 0, Ui = Si - 1; (Oi !== 0 || Fi < Ei) && Ui !== -1; Ui--, Fi++) Oi += Ue * Mi[Ui] >>> 0, Mi[Ui] = Oi % 256 >>> 0, Oi = Oi / 256 >>> 0;
        if (Oi !== 0) throw new Error("Non-zero carry");
        Ei = Fi, mi++;
      }
      if (bi[mi] !== " ") {
        for (var Pi = Si - Ei; Pi !== Si && Mi[Pi] === 0; ) Pi++;
        for (var Bi = new Uint8Array(_i + (Si - Pi)), ji = _i; Pi !== Si; ) Bi[ji++] = Mi[Pi++];
        return Bi;
      }
    }
  }
  function fi(bi) {
    var mi = En(bi);
    if (mi) return mi;
    throw new Error(`Non-${t} character`);
  }
  return { encode: vn, decodeUnsafe: En, decode: fi };
}
var at$1 = ut$1, Dt = at$1;
const re = (Ae) => {
  if (Ae instanceof Uint8Array && Ae.constructor.name === "Uint8Array") return Ae;
  if (Ae instanceof ArrayBuffer) return new Uint8Array(Ae);
  if (ArrayBuffer.isView(Ae)) return new Uint8Array(Ae.buffer, Ae.byteOffset, Ae.byteLength);
  throw new Error("Unknown type, must be binary type");
}, ct$1 = (Ae) => new TextEncoder().encode(Ae), ht$1 = (Ae) => new TextDecoder().decode(Ae);
let lt$1 = class {
  constructor(t, Ie, Be) {
    this.name = t, this.prefix = Ie, this.baseEncode = Be;
  }
  encode(t) {
    if (t instanceof Uint8Array) return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
}, dt$1 = class {
  constructor(t, Ie, Be) {
    if (this.name = t, this.prefix = Ie, Ie.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = Ie.codePointAt(0), this.baseDecode = Be;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(t) {
    return ie$1(this, t);
  }
}, pt$1 = class {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return ie$1(this, t);
  }
  decode(t) {
    const Ie = t[0], Be = this.decoders[Ie];
    if (Be) return Be.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
const ie$1 = (Ae, t) => new pt$1({ ...Ae.decoders || { [Ae.prefix]: Ae }, ...t.decoders || { [t.prefix]: t } });
class ft {
  constructor(t, Ie, Be, Pe) {
    this.name = t, this.prefix = Ie, this.baseEncode = Be, this.baseDecode = Pe, this.encoder = new lt$1(t, Ie, Be), this.decoder = new dt$1(t, Ie, Pe);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
}
const O$1 = ({ name: Ae, prefix: t, encode: Ie, decode: Be }) => new ft(Ae, t, Ie, Be), T$1 = ({ prefix: Ae, name: t, alphabet: Ie }) => {
  const { encode: Be, decode: Pe } = Dt(Ie, t);
  return O$1({ prefix: Ae, name: t, encode: Be, decode: (Te) => re(Pe(Te)) });
}, gt$1 = (Ae, t, Ie, Be) => {
  const Pe = {};
  for (let Ve = 0; Ve < t.length; ++Ve) Pe[t[Ve]] = Ve;
  let Te = Ae.length;
  for (; Ae[Te - 1] === "="; ) --Te;
  const Me = new Uint8Array(Te * Ie / 8 | 0);
  let Ue = 0, je = 0, fn = 0;
  for (let Ve = 0; Ve < Te; ++Ve) {
    const vn = Pe[Ae[Ve]];
    if (vn === void 0) throw new SyntaxError(`Non-${Be} character`);
    je = je << Ie | vn, Ue += Ie, Ue >= 8 && (Ue -= 8, Me[fn++] = 255 & je >> Ue);
  }
  if (Ue >= Ie || 255 & je << 8 - Ue) throw new SyntaxError("Unexpected end of data");
  return Me;
}, Et = (Ae, t, Ie) => {
  const Be = t[t.length - 1] === "=", Pe = (1 << Ie) - 1;
  let Te = "", Me = 0, Ue = 0;
  for (let je = 0; je < Ae.length; ++je) for (Ue = Ue << 8 | Ae[je], Me += 8; Me > Ie; ) Me -= Ie, Te += t[Pe & Ue >> Me];
  if (Me && (Te += t[Pe & Ue << Ie - Me]), Be) for (; Te.length * Ie & 7; ) Te += "=";
  return Te;
}, d = ({ name: Ae, prefix: t, bitsPerChar: Ie, alphabet: Be }) => O$1({ prefix: t, name: Ae, encode(Pe) {
  return Et(Pe, Be, Ie);
}, decode(Pe) {
  return gt$1(Pe, Be, Ie, Ae);
} }), bt = O$1({ prefix: "\0", name: "identity", encode: (Ae) => ht$1(Ae), decode: (Ae) => ct$1(Ae) });
var yt$1 = Object.freeze({ __proto__: null, identity: bt });
const wt = d({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Ct = Object.freeze({ __proto__: null, base2: wt });
const mt = d({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var vt = Object.freeze({ __proto__: null, base8: mt });
const At = T$1({ prefix: "9", name: "base10", alphabet: "0123456789" });
var _t = Object.freeze({ __proto__: null, base10: At });
const xt = d({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), Rt = d({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ft = Object.freeze({ __proto__: null, base16: xt, base16upper: Rt });
const Tt = d({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), It = d({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), qt = d({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), Ut = d({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), Ot = d({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), St = d({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), Pt = d({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), Nt = d({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), $t = d({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Bt = Object.freeze({ __proto__: null, base32: Tt, base32upper: It, base32pad: qt, base32padupper: Ut, base32hex: Ot, base32hexupper: St, base32hexpad: Pt, base32hexpadupper: Nt, base32z: $t });
const zt = T$1({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), jt = T$1({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Mt = Object.freeze({ __proto__: null, base36: zt, base36upper: jt });
const Lt = T$1({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), Kt = T$1({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Vt = Object.freeze({ __proto__: null, base58btc: Lt, base58flickr: Kt });
const kt = d({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), Jt = d({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), Xt = d({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), Gt = d({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ht = Object.freeze({ __proto__: null, base64: kt, base64pad: Jt, base64url: Xt, base64urlpad: Gt });
const ne$1 = Array.from(""), Yt = ne$1.reduce((Ae, t, Ie) => (Ae[Ie] = t, Ae), []), Qt = ne$1.reduce((Ae, t, Ie) => (Ae[t.codePointAt(0)] = Ie, Ae), []);
function Zt(Ae) {
  return Ae.reduce((t, Ie) => (t += Yt[Ie], t), "");
}
function Wt(Ae) {
  const t = [];
  for (const Ie of Ae) {
    const Be = Qt[Ie.codePointAt(0)];
    if (Be === void 0) throw new Error(`Non-base256emoji character: ${Ie}`);
    t.push(Be);
  }
  return new Uint8Array(t);
}
const er = O$1({ prefix: "", name: "base256emoji", encode: Zt, decode: Wt });
var tr = Object.freeze({ __proto__: null, base256emoji: er }), rr = oe$1, se$1 = 128, ir = 127, nr = ~ir, sr = Math.pow(2, 31);
function oe$1(Ae, t, Ie) {
  t = t || [], Ie = Ie || 0;
  for (var Be = Ie; Ae >= sr; ) t[Ie++] = Ae & 255 | se$1, Ae /= 128;
  for (; Ae & nr; ) t[Ie++] = Ae & 255 | se$1, Ae >>>= 7;
  return t[Ie] = Ae | 0, oe$1.bytes = Ie - Be + 1, t;
}
var or = j$1, ur = 128, ue = 127;
function j$1(Ae, Be) {
  var Ie = 0, Be = Be || 0, Pe = 0, Te = Be, Me, Ue = Ae.length;
  do {
    if (Te >= Ue) throw j$1.bytes = 0, new RangeError("Could not decode varint");
    Me = Ae[Te++], Ie += Pe < 28 ? (Me & ue) << Pe : (Me & ue) * Math.pow(2, Pe), Pe += 7;
  } while (Me >= ur);
  return j$1.bytes = Te - Be, Ie;
}
var ar = Math.pow(2, 7), Dr = Math.pow(2, 14), cr = Math.pow(2, 21), hr = Math.pow(2, 28), lr = Math.pow(2, 35), dr = Math.pow(2, 42), pr = Math.pow(2, 49), fr = Math.pow(2, 56), gr = Math.pow(2, 63), Er = function(Ae) {
  return Ae < ar ? 1 : Ae < Dr ? 2 : Ae < cr ? 3 : Ae < hr ? 4 : Ae < lr ? 5 : Ae < dr ? 6 : Ae < pr ? 7 : Ae < fr ? 8 : Ae < gr ? 9 : 10;
}, br = { encode: rr, decode: or, encodingLength: Er }, ae$1 = br;
const De = (Ae, t, Ie = 0) => (ae$1.encode(Ae, t, Ie), t), ce = (Ae) => ae$1.encodingLength(Ae), M = (Ae, t) => {
  const Ie = t.byteLength, Be = ce(Ae), Pe = Be + ce(Ie), Te = new Uint8Array(Pe + Ie);
  return De(Ae, Te, 0), De(Ie, Te, Be), Te.set(t, Pe), new yr(Ae, Ie, t, Te);
};
class yr {
  constructor(t, Ie, Be, Pe) {
    this.code = t, this.size = Ie, this.digest = Be, this.bytes = Pe;
  }
}
const he = ({ name: Ae, code: t, encode: Ie }) => new wr(Ae, t, Ie);
class wr {
  constructor(t, Ie, Be) {
    this.name = t, this.code = Ie, this.encode = Be;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const Ie = this.encode(t);
      return Ie instanceof Uint8Array ? M(this.code, Ie) : Ie.then((Be) => M(this.code, Be));
    } else throw Error("Unknown type, must be binary type");
  }
}
const le = (Ae) => async (t) => new Uint8Array(await crypto.subtle.digest(Ae, t)), Cr = he({ name: "sha2-256", code: 18, encode: le("SHA-256") }), mr = he({ name: "sha2-512", code: 19, encode: le("SHA-512") });
var vr = Object.freeze({ __proto__: null, sha256: Cr, sha512: mr });
const de = 0, Ar = "identity", pe = re, _r = (Ae) => M(de, pe(Ae)), xr = { code: de, name: Ar, encode: pe, digest: _r };
var Rr = Object.freeze({ __proto__: null, identity: xr });
new TextEncoder(), new TextDecoder();
const fe = { ...yt$1, ...Ct, ...vt, ..._t, ...Ft, ...Bt, ...Mt, ...Vt, ...Ht, ...tr };
({ ...vr, ...Rr });
function ge(Ae, t, Ie, Be) {
  return { name: Ae, prefix: t, encoder: { name: Ae, prefix: t, encode: Ie }, decoder: { decode: Be } };
}
const Ee = ge("utf8", "u", (Ae) => "u" + new TextDecoder("utf8").decode(Ae), (Ae) => new TextEncoder().encode(Ae.substring(1))), L$1 = ge("ascii", "a", (Ae) => {
  let t = "a";
  for (let Ie = 0; Ie < Ae.length; Ie++) t += String.fromCharCode(Ae[Ie]);
  return t;
}, (Ae) => {
  Ae = Ae.substring(1);
  const t = ot$1(Ae.length);
  for (let Ie = 0; Ie < Ae.length; Ie++) t[Ie] = Ae.charCodeAt(Ie);
  return t;
}), be$1 = { utf8: Ee, "utf-8": Ee, hex: fe.base16, latin1: L$1, ascii: L$1, binary: L$1, ...fe };
function Fr(Ae, t = "utf8") {
  const Ie = be$1[t];
  if (!Ie) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(Ae, "utf8") : Ie.decoder.decode(`${Ie.prefix}${Ae}`);
}
function Tr(Ae, t = "utf8") {
  const Ie = be$1[t];
  if (!Ie) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(Ae.buffer, Ae.byteOffset, Ae.byteLength).toString("utf8") : Ie.encoder.encode(Ae).substring(1);
}
const ye$1 = "base16", we$1 = "utf8";
function K$1(Ae) {
  const t = sha256.hash(Fr(Ae, we$1));
  return Tr(t, ye$1);
}
var Or = Object.defineProperty, Sr = Object.defineProperties, Pr = Object.getOwnPropertyDescriptors, Ce$1 = Object.getOwnPropertySymbols, Nr = Object.prototype.hasOwnProperty, $r = Object.prototype.propertyIsEnumerable, me$1 = (Ae, t, Ie) => t in Ae ? Or(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, I$1 = (Ae, t) => {
  for (var Ie in t || (t = {})) Nr.call(t, Ie) && me$1(Ae, Ie, t[Ie]);
  if (Ce$1) for (var Ie of Ce$1(t)) $r.call(t, Ie) && me$1(Ae, Ie, t[Ie]);
  return Ae;
}, V$1 = (Ae, t) => Sr(Ae, Pr(t));
class Br extends G {
  constructor(t) {
    super(t), this.initialized = !1, this.name = "authEngine", this.init = () => {
      this.initialized || (this.registerRelayerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(R$1) }), this.initialized = !0);
    }, this.request = async (Ie, Be) => {
      if (this.isInitialized(), !nt$1(Ie)) throw new Error("Invalid request");
      if (Be != null && Be.topic) return await this.requestOnKnownPairing(Be.topic, Ie);
      const { chainId: Pe, statement: Te, aud: Me, domain: Ue, nonce: je, type: fn, exp: Ve, nbf: vn } = Ie, { topic: En, uri: fi } = await this.client.core.pairing.create();
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: En, uri: fi } });
      const bi = await this.client.core.crypto.generateKeyPair(), mi = hr$2(bi);
      await this.client.authKeys.set(x$2, { responseTopic: mi, publicKey: bi }), await this.client.pairingTopics.set(mi, { topic: mi, pairingTopic: En }), await this.client.core.relayer.subscribe(mi), this.client.logger.info(`sending request to new pairing topic: ${En}`);
      const _i = await this.sendRequest(En, "wc_authRequest", { payloadParams: { type: fn ?? "eip4361", chainId: Pe, statement: Te, aud: Me, domain: Ue, version: "1", nonce: je, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: Ve, nbf: vn }, requester: { publicKey: bi, metadata: this.client.metadata } }, {}, Ie.expiry);
      return this.client.logger.info(`sent request to new pairing topic: ${En}`), { uri: fi, id: _i };
    }, this.respond = async (Ie, Be) => {
      if (this.isInitialized(), !st$1(Ie, this.client.requests)) throw new Error("Invalid response");
      const Pe = te$1(this.client.requests, Ie.id);
      if (!Pe) throw new Error(`Could not find pending auth request with id ${Ie.id}`);
      const Te = Pe.requester.publicKey, Me = await this.client.core.crypto.generateKeyPair(), Ue = hr$2(Te), je = { type: D$2, receiverPublicKey: Te, senderPublicKey: Me };
      if ("error" in Ie) {
        await this.sendError(Pe.id, Ue, Ie, je);
        return;
      }
      const fn = { h: { t: "eip4361" }, p: V$1(I$1({}, Pe.cacaoPayload), { iss: Be }), s: Ie.signature };
      await this.sendResult(Pe.id, Ue, fn, je), await this.client.core.pairing.activate({ topic: Pe.pairingTopic }), await this.client.requests.update(Pe.id, I$1({}, fn));
    }, this.getPendingRequests = () => ee$1(this.client.requests), this.formatMessage = (Ie, Be) => {
      this.client.logger.debug(`formatMessage, cacao is: ${JSON.stringify(Ie)}`);
      const Pe = `${Ie.domain} wants you to sign in with your Ethereum account:`, Te = W(Be), Me = Ie.statement, Ue = `URI: ${Ie.aud}`, je = `Version: ${Ie.version}`, fn = `Chain ID: ${Ze(Be)}`, Ve = `Nonce: ${Ie.nonce}`, vn = `Issued At: ${Ie.iat}`, En = Ie.exp ? `Expiry: ${Ie.exp}` : void 0, fi = Ie.resources && Ie.resources.length > 0 ? `Resources:
${Ie.resources.map((bi) => `- ${bi}`).join(`
`)}` : void 0;
      return [Pe, Te, "", Me, "", Ue, je, fn, Ve, vn, En, fi].filter((bi) => bi != null).join(`
`);
    }, this.setExpiry = async (Ie, Be) => {
      this.client.core.pairing.pairings.keys.includes(Ie) && await this.client.core.pairing.updateExpiry({ topic: Ie, expiry: Be }), this.client.core.expirer.set(Ie, Be);
    }, this.sendRequest = async (Ie, Be, Pe, Te, Me) => {
      const Ue = formatJsonRpcRequest(Be, Pe), je = await this.client.core.crypto.encode(Ie, Ue, Te), fn = R$1[Be].req;
      if (Me && (fn.ttl = Me), this.client.core.history.set(Ie, Ue), V$3()) {
        const Ve = K$1(JSON.stringify(Ue));
        this.client.core.verify.register({ attestationId: Ve });
      }
      return await this.client.core.relayer.publish(Ie, je, V$1(I$1({}, fn), { internal: { throwOnFailedPublish: !0 } })), Ue.id;
    }, this.sendResult = async (Ie, Be, Pe, Te) => {
      const Me = formatJsonRpcResult(Ie, Pe), Ue = await this.client.core.crypto.encode(Be, Me, Te), je = await this.client.core.history.get(Be, Ie), fn = R$1[je.request.method].res;
      return await this.client.core.relayer.publish(Be, Ue, V$1(I$1({}, fn), { internal: { throwOnFailedPublish: !0 } })), await this.client.core.history.resolve(Me), Me.id;
    }, this.sendError = async (Ie, Be, Pe, Te) => {
      const Me = formatJsonRpcError(Ie, Pe.error), Ue = await this.client.core.crypto.encode(Be, Me, Te), je = await this.client.core.history.get(Be, Ie), fn = R$1[je.request.method].res;
      return await this.client.core.relayer.publish(Be, Ue, fn), await this.client.core.history.resolve(Me), Me.id;
    }, this.requestOnKnownPairing = async (Ie, Be) => {
      const Pe = this.client.core.pairing.pairings.getAll({ active: !0 }).find((fi) => fi.topic === Ie);
      if (!Pe) throw new Error(`Could not find pairing for provided topic ${Ie}`);
      const { publicKey: Te } = this.client.authKeys.get(x$2), { chainId: Me, statement: Ue, aud: je, domain: fn, nonce: Ve, type: vn } = Be, En = await this.sendRequest(Pe.topic, "wc_authRequest", { payloadParams: { type: vn ?? "eip4361", chainId: Me, statement: Ue, aud: je, domain: fn, version: "1", nonce: Ve, iat: (/* @__PURE__ */ new Date()).toISOString() }, requester: { publicKey: Te, metadata: this.client.metadata } }, {}, Be.expiry);
      return this.client.logger.info(`sent request to known pairing topic: ${Pe.topic}`), { id: En };
    }, this.onPairingCreated = (Ie) => {
      const Be = this.getPendingRequests();
      if (Be) {
        const Pe = Object.values(Be).find((Te) => Te.pairingTopic === Ie.topic);
        Pe && this.handleAuthRequest(Pe);
      }
    }, this.onRelayEventRequest = (Ie) => {
      const { topic: Be, payload: Pe } = Ie, Te = Pe.method;
      switch (Te) {
        case "wc_authRequest":
          return this.onAuthRequest(Be, Pe);
        default:
          return this.client.logger.info(`Unsupported request method ${Te}`);
      }
    }, this.onRelayEventResponse = async (Ie) => {
      const { topic: Be, payload: Pe } = Ie, Te = (await this.client.core.history.get(Be, Pe.id)).request.method;
      switch (Te) {
        case "wc_authRequest":
          return this.onAuthResponse(Be, Pe);
        default:
          return this.client.logger.info(`Unsupported response method ${Te}`);
      }
    }, this.onAuthRequest = async (Ie, Be) => {
      const { requester: Pe, payloadParams: Te } = Be.params;
      this.client.logger.info({ type: "onAuthRequest", topic: Ie, payload: Be });
      const Me = K$1(JSON.stringify(Be)), Ue = await this.getVerifyContext(Me, this.client.metadata), je = { requester: Pe, pairingTopic: Ie, id: Be.id, cacaoPayload: Te, verifyContext: Ue };
      await this.client.requests.set(Be.id, je), this.handleAuthRequest(je);
    }, this.handleAuthRequest = async (Ie) => {
      const { id: Be, pairingTopic: Pe, requester: Te, cacaoPayload: Me, verifyContext: Ue } = Ie;
      try {
        this.client.emit("auth_request", { id: Be, topic: Pe, params: { requester: Te, cacaoPayload: Me }, verifyContext: Ue });
      } catch (je) {
        await this.sendError(Ie.id, Ie.pairingTopic, je), this.client.logger.error(je);
      }
    }, this.onAuthResponse = async (Ie, Be) => {
      const { id: Pe } = Be;
      if (this.client.logger.info({ type: "onAuthResponse", topic: Ie, response: Be }), isJsonRpcResult(Be)) {
        const { pairingTopic: Te } = this.client.pairingTopics.get(Ie);
        await this.client.core.pairing.activate({ topic: Te });
        const { s: Me, p: Ue } = Be.result;
        await this.client.requests.set(Pe, I$1({ id: Pe, pairingTopic: Te }, Be.result));
        const je = this.formatMessage(Ue, Ue.iss);
        this.client.logger.debug(`reconstructed message:
`, JSON.stringify(je)), this.client.logger.debug("payload.iss:", Ue.iss), this.client.logger.debug("signature:", Me);
        const fn = W(Ue.iss), Ve = We(Ue.iss);
        if (!fn) throw new Error("Could not derive address from `payload.iss`");
        if (!Ve) throw new Error("Could not derive chainId from `payload.iss`");
        this.client.logger.debug("walletAddress extracted from `payload.iss`:", fn), await et(fn, je, Me, Ve, this.client.projectId) ? this.client.emit("auth_response", { id: Pe, topic: Ie, params: Be }) : this.client.emit("auth_response", { id: Pe, topic: Ie, params: { message: "Invalid signature", code: -1 } });
      } else isJsonRpcError(Be) && this.client.emit("auth_response", { id: Pe, topic: Ie, params: Be });
    }, this.getVerifyContext = async (Ie, Be) => {
      const Pe = { verified: { verifyUrl: Be.verifyUrl || "", validation: "UNKNOWN", origin: Be.url || "" } };
      try {
        const Te = await this.client.core.verify.resolve({ attestationId: Ie, verifyUrl: Be.verifyUrl });
        Te && (Pe.verified.origin = Te.origin, Pe.verified.isScam = Te.isScam, Pe.verified.validation = origin === new URL(Be.url).origin ? "VALID" : "INVALID");
      } catch (Te) {
        this.client.logger.error(Te);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(Pe)}`), Pe;
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(v$2.message, async (t) => {
      const { topic: Ie, message: Be } = t, { responseTopic: Pe, publicKey: Te } = this.client.authKeys.keys.includes(x$2) ? this.client.authKeys.get(x$2) : { responseTopic: void 0, publicKey: void 0 };
      if (Pe && Ie !== Pe) {
        this.client.logger.debug("[Auth] Ignoring message from unknown topic", Ie);
        return;
      }
      const Me = await this.client.core.crypto.decode(Ie, Be, { receiverPublicKey: Te });
      isJsonRpcRequest(Me) ? (this.client.core.history.set(Ie, Me), this.onRelayEventRequest({ topic: Ie, payload: Me })) : isJsonRpcResponse(Me) && (await this.client.core.history.resolve(Me), this.onRelayEventResponse({ topic: Ie, payload: Me }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(V$2.create, (t) => this.onPairingCreated(t));
  }
}
let S$1 = class Jc extends H {
  constructor(t) {
    super(t), this.protocol = $, this.version = Q, this.name = B$1, this.events = new eventsExports.EventEmitter(), this.emit = (Be, Pe) => this.events.emit(Be, Pe), this.on = (Be, Pe) => this.events.on(Be, Pe), this.once = (Be, Pe) => this.events.once(Be, Pe), this.off = (Be, Pe) => this.events.off(Be, Pe), this.removeListener = (Be, Pe) => this.events.removeListener(Be, Pe), this.request = async (Be, Pe) => {
      try {
        return await this.engine.request(Be, Pe);
      } catch (Te) {
        throw this.logger.error(Te.message), Te;
      }
    }, this.respond = async (Be, Pe) => {
      try {
        return await this.engine.respond(Be, Pe);
      } catch (Te) {
        throw this.logger.error(Te.message), Te;
      }
    }, this.getPendingRequests = () => {
      try {
        return this.engine.getPendingRequests();
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.formatMessage = (Be, Pe) => {
      try {
        return this.engine.formatMessage(Be, Pe);
      } catch (Te) {
        throw this.logger.error(Te.message), Te;
      }
    };
    const Ie = typeof t.logger < "u" && typeof t.logger != "string" ? t.logger : qt$3(k$2({ level: t.logger || "error" }));
    this.name = (t == null ? void 0 : t.name) || B$1, this.metadata = t.metadata, this.projectId = t.projectId, this.core = t.core || new bn(t), this.logger = E$1(Ie, this.name), this.authKeys = new ni(this.core, this.logger, "authKeys", F$1, () => x$2), this.pairingTopics = new ni(this.core, this.logger, "pairingTopics", F$1), this.requests = new ni(this.core, this.logger, "requests", F$1, (Be) => Be.id), this.engine = new Br(this);
  }
  static async init(t) {
    const Ie = new Jc(t);
    return await Ie.initialize(), Ie;
  }
  get context() {
    return y$3(this.logger);
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.authKeys.init(), await this.requests.init(), await this.pairingTopics.init(), await this.engine.init(), this.logger.info("AuthClient Initialization Success"), this.logger.info({ authClient: this });
    } catch (t) {
      throw this.logger.info("AuthClient Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
const zr = S$1, be = "wc", Ce = 2, Le = "client", ye = `${be}@${Ce}:${Le}:`, we = { name: Le, logger: "error", controller: !1, relayUrl: "wss://relay.walletconnect.org" }, xe = "WALLETCONNECT_DEEPLINK_CHOICE", st = "proposal", it = "Proposal expired", rt = "session", z$1 = cjs$3.SEVEN_DAYS, nt = "engine", v$1 = { wc_sessionPropose: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1101 }, reject: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1120 }, autoReject: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1121 } }, wc_sessionSettle: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1114 }, res: { ttl: cjs$3.ONE_DAY, prompt: !1, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: cjs$3.ONE_HOUR, prompt: !0, tag: 1116 }, res: { ttl: cjs$3.ONE_HOUR, prompt: !1, tag: 1117 }, reject: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1118 }, autoReject: { ttl: cjs$3.FIVE_MINUTES, prompt: !1, tag: 1119 } } }, me = { min: cjs$3.FIVE_MINUTES, max: cjs$3.SEVEN_DAYS }, x$1 = { idle: "IDLE", active: "ACTIVE" }, ot = "request", at = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"], ct = "wc", lt = "auth", pt = "authKeys", ht = "pairingTopics", dt = "requests", oe = `${ct}@${1.5}:${lt}:`, ae = `${oe}:PUB_KEY`;
var ys = Object.defineProperty, ws = Object.defineProperties, ms = Object.getOwnPropertyDescriptors, ut = Object.getOwnPropertySymbols, _s = Object.prototype.hasOwnProperty, Es = Object.prototype.propertyIsEnumerable, gt = (Ae, t, Ie) => t in Ae ? ys(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, I = (Ae, t) => {
  for (var Ie in t || (t = {})) _s.call(t, Ie) && gt(Ae, Ie, t[Ie]);
  if (ut) for (var Ie of ut(t)) Es.call(t, Ie) && gt(Ae, Ie, t[Ie]);
  return Ae;
}, D$1 = (Ae, t) => ws(Ae, ms(t));
class Rs extends M$3 {
  constructor(t) {
    super(t), this.name = nt, this.events = new es(), this.initialized = !1, this.requestQueue = { state: x$1.idle, queue: [] }, this.sessionRequestQueue = { state: x$1.idle, queue: [] }, this.requestQueueDelay = cjs$3.ONE_SECOND, this.expectedPairingMethodMap = /* @__PURE__ */ new Map(), this.recentlyDeletedMap = /* @__PURE__ */ new Map(), this.recentlyDeletedLimit = 200, this.relayMessageCache = [], this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(v$1) }), this.initialized = !0, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, cjs$3.toMiliseconds(this.requestQueueDelay)));
    }, this.connect = async (Ie) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const Be = D$1(I({}, Ie), { requiredNamespaces: Ie.requiredNamespaces || {}, optionalNamespaces: Ie.optionalNamespaces || {} });
      await this.isValidConnect(Be);
      const { pairingTopic: Pe, requiredNamespaces: Te, optionalNamespaces: Me, sessionProperties: Ue, relays: je } = Be;
      let fn = Pe, Ve, vn = !1;
      try {
        fn && (vn = this.client.core.pairing.pairings.get(fn).active);
      } catch (Oi) {
        throw this.client.logger.error(`connect() -> pairing.get(${fn}) failed`), Oi;
      }
      if (!fn || !vn) {
        const { topic: Oi, uri: Fi } = await this.client.core.pairing.create();
        fn = Oi, Ve = Fi;
      }
      if (!fn) {
        const { message: Oi } = S$4("NO_MATCHING_KEY", `connect() pairing topic: ${fn}`);
        throw new Error(Oi);
      }
      const En = await this.client.core.crypto.generateKeyPair(), fi = v$1.wc_sessionPropose.req.ttl || cjs$3.FIVE_MINUTES, bi = Mt$2(fi), mi = I({ requiredNamespaces: Te, optionalNamespaces: Me, relays: je ?? [{ protocol: rt$2 }], proposer: { publicKey: En, metadata: this.client.metadata }, expiryTimestamp: bi, pairingTopic: fn }, Ue && { sessionProperties: Ue }), { reject: _i, resolve: Ei, done: Si } = _t$2(fi, it);
      this.events.once(Lt$2("session_connect"), async ({ error: Oi, session: Fi }) => {
        if (Oi) _i(Oi);
        else if (Fi) {
          Fi.self.publicKey = En;
          const Ui = D$1(I({}, Fi), { pairingTopic: mi.pairingTopic, requiredNamespaces: mi.requiredNamespaces, optionalNamespaces: mi.optionalNamespaces, transportType: M$1.relay });
          await this.client.session.set(Fi.topic, Ui), await this.setExpiry(Fi.topic, Fi.expiry), fn && await this.client.core.pairing.updateMetadata({ topic: fn, metadata: Fi.peer.metadata }), this.cleanupDuplicatePairings(Ui), Ei(Ui);
        }
      });
      const Mi = await this.sendRequest({ topic: fn, method: "wc_sessionPropose", params: mi, throwOnFailedPublish: !0 });
      return await this.setProposal(Mi, I({ id: Mi }, mi)), { uri: Ve, approval: Si };
    }, this.pair = async (Ie) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(Ie);
      } catch (Be) {
        throw this.client.logger.error("pair() failed"), Be;
      }
    }, this.approve = async (Ie) => {
      var Be, Pe, Te;
      const Me = this.client.core.eventClient.createEvent({ properties: { topic: (Be = Ie == null ? void 0 : Ie.id) == null ? void 0 : Be.toString(), trace: [Is$1.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (Bi) {
        throw Me.setError(Ts$1.no_internet_connection), Bi;
      }
      try {
        await this.isValidProposalId(Ie == null ? void 0 : Ie.id);
      } catch (Bi) {
        throw this.client.logger.error(`approve() -> proposal.get(${Ie == null ? void 0 : Ie.id}) failed`), Me.setError(Ts$1.proposal_not_found), Bi;
      }
      try {
        await this.isValidApprove(Ie);
      } catch (Bi) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), Me.setError(Ts$1.session_approve_namespace_validation_failure), Bi;
      }
      const { id: Ue, relayProtocol: je, namespaces: fn, sessionProperties: Ve, sessionConfig: vn } = Ie, En = this.client.proposal.get(Ue);
      this.client.core.eventClient.deleteEvent({ eventId: Me.eventId });
      const { pairingTopic: fi, proposer: bi, requiredNamespaces: mi, optionalNamespaces: _i } = En;
      let Ei = (Pe = this.client.core.eventClient) == null ? void 0 : Pe.getEvent({ topic: fi });
      Ei || (Ei = (Te = this.client.core.eventClient) == null ? void 0 : Te.createEvent({ type: Is$1.session_approve_started, properties: { topic: fi, trace: [Is$1.session_approve_started, Is$1.session_namespaces_validation_success] } }));
      const Si = await this.client.core.crypto.generateKeyPair(), Mi = bi.publicKey, Oi = await this.client.core.crypto.generateSharedKey(Si, Mi), Fi = I(I({ relay: { protocol: je ?? "irn" }, namespaces: fn, controller: { publicKey: Si, metadata: this.client.metadata }, expiry: Mt$2(z$1) }, Ve && { sessionProperties: Ve }), vn && { sessionConfig: vn }), Ui = M$1.relay;
      Ei.addTrace(Is$1.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(Oi, { transportType: Ui });
      } catch (Bi) {
        throw Ei.setError(Ts$1.subscribe_session_topic_failure), Bi;
      }
      Ei.addTrace(Is$1.subscribe_session_topic_success);
      const Pi = D$1(I({}, Fi), { topic: Oi, requiredNamespaces: mi, optionalNamespaces: _i, pairingTopic: fi, acknowledged: !1, self: Fi.controller, peer: { publicKey: bi.publicKey, metadata: bi.metadata }, controller: Si, transportType: M$1.relay });
      await this.client.session.set(Oi, Pi), Ei.addTrace(Is$1.store_session);
      try {
        Ei.addTrace(Is$1.publishing_session_settle), await this.sendRequest({ topic: Oi, method: "wc_sessionSettle", params: Fi, throwOnFailedPublish: !0 }).catch((Bi) => {
          throw Ei == null || Ei.setError(Ts$1.session_settle_publish_failure), Bi;
        }), Ei.addTrace(Is$1.session_settle_publish_success), Ei.addTrace(Is$1.publishing_session_approve), await this.sendResult({ id: Ue, topic: fi, result: { relay: { protocol: je ?? "irn" }, responderPublicKey: Si }, throwOnFailedPublish: !0 }).catch((Bi) => {
          throw Ei == null || Ei.setError(Ts$1.session_approve_publish_failure), Bi;
        }), Ei.addTrace(Is$1.session_approve_publish_success);
      } catch (Bi) {
        throw this.client.logger.error(Bi), this.client.session.delete(Oi, U$2("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(Oi), Bi;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: Ei.eventId }), await this.client.core.pairing.updateMetadata({ topic: fi, metadata: bi.metadata }), await this.client.proposal.delete(Ue, U$2("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: fi }), await this.setExpiry(Oi, Mt$2(z$1)), { topic: Oi, acknowledged: () => Promise.resolve(this.client.session.get(Oi)) };
    }, this.reject = async (Ie) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(Ie);
      } catch (Me) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), Me;
      }
      const { id: Be, reason: Pe } = Ie;
      let Te;
      try {
        Te = this.client.proposal.get(Be).pairingTopic;
      } catch (Me) {
        throw this.client.logger.error(`reject() -> proposal.get(${Be}) failed`), Me;
      }
      Te && (await this.sendError({ id: Be, topic: Te, error: Pe, rpcOpts: v$1.wc_sessionPropose.reject }), await this.client.proposal.delete(Be, U$2("USER_DISCONNECTED")));
    }, this.update = async (Ie) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(Ie);
      } catch (vn) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), vn;
      }
      const { topic: Be, namespaces: Pe } = Ie, { done: Te, resolve: Me, reject: Ue } = _t$2(), je = payloadId(), fn = getBigIntRpcId().toString(), Ve = this.client.session.get(Be).namespaces;
      return this.events.once(Lt$2("session_update", je), ({ error: vn }) => {
        vn ? Ue(vn) : Me();
      }), await this.client.session.update(Be, { namespaces: Pe }), await this.sendRequest({ topic: Be, method: "wc_sessionUpdate", params: { namespaces: Pe }, throwOnFailedPublish: !0, clientRpcId: je, relayRpcId: fn }).catch((vn) => {
        this.client.logger.error(vn), this.client.session.update(Be, { namespaces: Ve }), Ue(vn);
      }), { acknowledged: Te };
    }, this.extend = async (Ie) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(Ie);
      } catch (je) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), je;
      }
      const { topic: Be } = Ie, Pe = payloadId(), { done: Te, resolve: Me, reject: Ue } = _t$2();
      return this.events.once(Lt$2("session_extend", Pe), ({ error: je }) => {
        je ? Ue(je) : Me();
      }), await this.setExpiry(Be, Mt$2(z$1)), this.sendRequest({ topic: Be, method: "wc_sessionExtend", params: {}, clientRpcId: Pe, throwOnFailedPublish: !0 }).catch((je) => {
        Ue(je);
      }), { acknowledged: Te };
    }, this.request = async (Ie) => {
      this.isInitialized();
      try {
        await this.isValidRequest(Ie);
      } catch (bi) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), bi;
      }
      const { chainId: Be, request: Pe, topic: Te, expiry: Me = v$1.wc_sessionRequest.req.ttl } = Ie, Ue = this.client.session.get(Te);
      (Ue == null ? void 0 : Ue.transportType) === M$1.relay && await this.confirmOnlineStateOrThrow();
      const je = payloadId(), fn = getBigIntRpcId().toString(), { done: Ve, resolve: vn, reject: En } = _t$2(Me, "Request expired. Please try again.");
      this.events.once(Lt$2("session_request", je), ({ error: bi, result: mi }) => {
        bi ? En(bi) : vn(mi);
      });
      const fi = this.getAppLinkIfEnabled(Ue.peer.metadata, Ue.transportType);
      return fi ? (await this.sendRequest({ clientRpcId: je, relayRpcId: fn, topic: Te, method: "wc_sessionRequest", params: { request: D$1(I({}, Pe), { expiryTimestamp: Mt$2(Me) }), chainId: Be }, expiry: Me, throwOnFailedPublish: !0, appLink: fi }).catch((bi) => En(bi)), this.client.events.emit("session_request_sent", { topic: Te, request: Pe, chainId: Be, id: je }), await Ve()) : await Promise.all([new Promise(async (bi) => {
        await this.sendRequest({ clientRpcId: je, relayRpcId: fn, topic: Te, method: "wc_sessionRequest", params: { request: D$1(I({}, Pe), { expiryTimestamp: Mt$2(Me) }), chainId: Be }, expiry: Me, throwOnFailedPublish: !0 }).catch((mi) => En(mi)), this.client.events.emit("session_request_sent", { topic: Te, request: Pe, chainId: Be, id: je }), bi();
      }), new Promise(async (bi) => {
        var mi;
        if (!((mi = Ue.sessionConfig) != null && mi.disableDeepLink)) {
          const _i = await qt$2(this.client.core.storage, xe);
          await Ft$2({ id: je, topic: Te, wcDeepLink: _i });
        }
        bi();
      }), Ve()]).then((bi) => bi[2]);
    }, this.respond = async (Ie) => {
      this.isInitialized(), await this.isValidRespond(Ie);
      const { topic: Be, response: Pe } = Ie, { id: Te } = Pe, Me = this.client.session.get(Be);
      Me.transportType === M$1.relay && await this.confirmOnlineStateOrThrow();
      const Ue = this.getAppLinkIfEnabled(Me.peer.metadata, Me.transportType);
      isJsonRpcResult(Pe) ? await this.sendResult({ id: Te, topic: Be, result: Pe.result, throwOnFailedPublish: !0, appLink: Ue }) : isJsonRpcError(Pe) && await this.sendError({ id: Te, topic: Be, error: Pe.error, appLink: Ue }), this.cleanupAfterResponse(Ie);
    }, this.ping = async (Ie) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(Ie);
      } catch (Pe) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), Pe;
      }
      const { topic: Be } = Ie;
      if (this.client.session.keys.includes(Be)) {
        const Pe = payloadId(), Te = getBigIntRpcId().toString(), { done: Me, resolve: Ue, reject: je } = _t$2();
        this.events.once(Lt$2("session_ping", Pe), ({ error: fn }) => {
          fn ? je(fn) : Ue();
        }), await Promise.all([this.sendRequest({ topic: Be, method: "wc_sessionPing", params: {}, throwOnFailedPublish: !0, clientRpcId: Pe, relayRpcId: Te }), Me()]);
      } else this.client.core.pairing.pairings.keys.includes(Be) && await this.client.core.pairing.ping({ topic: Be });
    }, this.emit = async (Ie) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(Ie);
      const { topic: Be, event: Pe, chainId: Te } = Ie, Me = getBigIntRpcId().toString();
      await this.sendRequest({ topic: Be, method: "wc_sessionEvent", params: { event: Pe, chainId: Te }, throwOnFailedPublish: !0, relayRpcId: Me });
    }, this.disconnect = async (Ie) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(Ie);
      const { topic: Be } = Ie;
      if (this.client.session.keys.includes(Be)) await this.sendRequest({ topic: Be, method: "wc_sessionDelete", params: U$2("USER_DISCONNECTED"), throwOnFailedPublish: !0 }), await this.deleteSession({ topic: Be, emitEvent: !1 });
      else if (this.client.core.pairing.pairings.keys.includes(Be)) await this.client.core.pairing.disconnect({ topic: Be });
      else {
        const { message: Pe } = S$4("MISMATCHED_TOPIC", `Session or pairing topic not found: ${Be}`);
        throw new Error(Pe);
      }
    }, this.find = (Ie) => (this.isInitialized(), this.client.session.getAll().filter((Be) => zr$2(Be, Ie))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (Ie, Be) => {
      var Pe;
      this.isInitialized(), this.isValidAuthenticate(Ie);
      const Te = Be && this.client.core.linkModeSupportedApps.includes(Be) && ((Pe = this.client.metadata.redirect) == null ? void 0 : Pe.linkMode), Me = Te ? M$1.link_mode : M$1.relay;
      Me === M$1.relay && await this.confirmOnlineStateOrThrow();
      const { chains: Ue, statement: je = "", uri: fn, domain: Ve, nonce: vn, type: En, exp: fi, nbf: bi, methods: mi = [], expiry: _i } = Ie, Ei = [...Ie.resources || []], { topic: Si, uri: Mi } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: Me });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: Si, uri: Mi } });
      const Oi = await this.client.core.crypto.generateKeyPair(), Fi = hr$2(Oi);
      if (await Promise.all([this.client.auth.authKeys.set(ae, { responseTopic: Fi, publicKey: Oi }), this.client.auth.pairingTopics.set(Fi, { topic: Fi, pairingTopic: Si })]), await this.client.core.relayer.subscribe(Fi, { transportType: Me }), this.client.logger.info(`sending request to new pairing topic: ${Si}`), mi.length > 0) {
        const { namespace: Ti } = re$2(Ue[0]);
        let Ci = ir$2(Ti, "request", mi);
        Y$2(Ei) && (Ci = cr$2(Ci, Ei.pop())), Ei.push(Ci);
      }
      const Ui = _i && _i > v$1.wc_sessionAuthenticate.req.ttl ? _i : v$1.wc_sessionAuthenticate.req.ttl, Pi = { authPayload: { type: En ?? "caip122", chains: Ue, statement: je, aud: fn, domain: Ve, version: "1", nonce: vn, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: fi, nbf: bi, resources: Ei }, requester: { publicKey: Oi, metadata: this.client.metadata }, expiryTimestamp: Mt$2(Ui) }, Bi = { eip155: { chains: Ue, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...mi])], events: ["chainChanged", "accountsChanged"] } }, ji = { requiredNamespaces: {}, optionalNamespaces: Bi, relays: [{ protocol: "irn" }], pairingTopic: Si, proposer: { publicKey: Oi, metadata: this.client.metadata }, expiryTimestamp: Mt$2(v$1.wc_sessionPropose.req.ttl) }, { done: Zi, resolve: zi, reject: xi } = _t$2(Ui, "Request expired"), $i = async ({ error: Ti, session: Ci }) => {
        if (this.events.off(Lt$2("session_request", wi), vi), Ti) xi(Ti);
        else if (Ci) {
          Ci.self.publicKey = Oi, await this.client.session.set(Ci.topic, Ci), await this.setExpiry(Ci.topic, Ci.expiry), Si && await this.client.core.pairing.updateMetadata({ topic: Si, metadata: Ci.peer.metadata });
          const Ii = this.client.session.get(Ci.topic);
          await this.deleteProposal(Ai), zi({ session: Ii });
        }
      }, vi = async (Ti) => {
        var Ci, Ii, Li;
        if (await this.deletePendingAuthRequest(wi, { message: "fulfilled", code: 0 }), Ti.error) {
          const Hi = U$2("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return Ti.error.code === Hi.code ? void 0 : (this.events.off(Lt$2("session_connect"), $i), xi(Ti.error.message));
        }
        await this.deleteProposal(Ai), this.events.off(Lt$2("session_connect"), $i);
        const { cacaos: Ni, responder: Vi } = Ti.result, is = [], Ki = [];
        for (const Hi of Ni) {
          await nr$2({ cacao: Hi, projectId: this.client.core.projectId }) || (this.client.logger.error(Hi, "Signature verification failed"), xi(U$2("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: Xi } = Hi, ki = Y$2(Xi.resources), Wi = [ln$1(Xi.iss)], Yi = fe$2(Xi.iss);
          if (ki) {
            const Qi = ar$2(ki), ns = ur$2(ki);
            is.push(...Qi), Wi.push(...ns);
          }
          for (const Qi of Wi) Ki.push(`${Qi}:${Yi}`);
        }
        const ts = await this.client.core.crypto.generateSharedKey(Oi, Vi.publicKey);
        let qi;
        is.length > 0 && (qi = { topic: ts, acknowledged: !0, self: { publicKey: Oi, metadata: this.client.metadata }, peer: Vi, controller: Vi.publicKey, expiry: Mt$2(z$1), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: Si, namespaces: Jr$1([...new Set(is)], [...new Set(Ki)]), transportType: Me }, await this.client.core.relayer.subscribe(ts, { transportType: Me }), await this.client.session.set(ts, qi), Si && await this.client.core.pairing.updateMetadata({ topic: Si, metadata: Vi.metadata }), qi = this.client.session.get(ts)), (Ci = this.client.metadata.redirect) != null && Ci.linkMode && (Ii = Vi.metadata.redirect) != null && Ii.linkMode && (Li = Vi.metadata.redirect) != null && Li.universal && Be && (this.client.core.addLinkModeSupportedApp(Vi.metadata.redirect.universal), this.client.session.update(ts, { transportType: M$1.link_mode })), zi({ auths: Ni, session: qi });
      }, wi = payloadId(), Ai = payloadId();
      this.events.once(Lt$2("session_connect"), $i), this.events.once(Lt$2("session_request", wi), vi);
      let Ri;
      try {
        if (Te) {
          const Ti = formatJsonRpcRequest("wc_sessionAuthenticate", Pi, wi);
          this.client.core.history.set(Si, Ti);
          const Ci = await this.client.core.crypto.encode("", Ti, { type: M$2, encoding: lr$2 });
          Ri = xr$2(Be, Si, Ci);
        } else await Promise.all([this.sendRequest({ topic: Si, method: "wc_sessionAuthenticate", params: Pi, expiry: Ie.expiry, throwOnFailedPublish: !0, clientRpcId: wi }), this.sendRequest({ topic: Si, method: "wc_sessionPropose", params: ji, expiry: v$1.wc_sessionPropose.req.ttl, throwOnFailedPublish: !0, clientRpcId: Ai })]);
      } catch (Ti) {
        throw this.events.off(Lt$2("session_connect"), $i), this.events.off(Lt$2("session_request", wi), vi), Ti;
      }
      return await this.setProposal(Ai, I({ id: Ai }, ji)), await this.setAuthRequest(wi, { request: D$1(I({}, Pi), { verifyContext: {} }), pairingTopic: Si, transportType: Me }), { uri: Ri ?? Mi, response: Zi };
    }, this.approveSessionAuthenticate = async (Ie) => {
      const { id: Be, auths: Pe } = Ie, Te = this.client.core.eventClient.createEvent({ properties: { topic: Be.toString(), trace: [Cs.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (_i) {
        throw Te.setError(Ps$1.no_internet_connection), _i;
      }
      const Me = this.getPendingAuthRequest(Be);
      if (!Me) throw Te.setError(Ps$1.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${Be}`);
      const Ue = Me.transportType || M$1.relay;
      Ue === M$1.relay && await this.confirmOnlineStateOrThrow();
      const je = Me.requester.publicKey, fn = await this.client.core.crypto.generateKeyPair(), Ve = hr$2(je), vn = { type: D$2, receiverPublicKey: je, senderPublicKey: fn }, En = [], fi = [];
      for (const _i of Pe) {
        if (!await nr$2({ cacao: _i, projectId: this.client.core.projectId })) {
          Te.setError(Ps$1.invalid_cacao);
          const Fi = U$2("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: Be, topic: Ve, error: Fi, encodeOpts: vn }), new Error(Fi.message);
        }
        Te.addTrace(Cs.cacaos_verified);
        const { p: Ei } = _i, Si = Y$2(Ei.resources), Mi = [ln$1(Ei.iss)], Oi = fe$2(Ei.iss);
        if (Si) {
          const Fi = ar$2(Si), Ui = ur$2(Si);
          En.push(...Fi), Mi.push(...Ui);
        }
        for (const Fi of Mi) fi.push(`${Fi}:${Oi}`);
      }
      const bi = await this.client.core.crypto.generateSharedKey(fn, je);
      Te.addTrace(Cs.create_authenticated_session_topic);
      let mi;
      if ((En == null ? void 0 : En.length) > 0) {
        mi = { topic: bi, acknowledged: !0, self: { publicKey: fn, metadata: this.client.metadata }, peer: { publicKey: je, metadata: Me.requester.metadata }, controller: je, expiry: Mt$2(z$1), authentication: Pe, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: Me.pairingTopic, namespaces: Jr$1([...new Set(En)], [...new Set(fi)]), transportType: Ue }, Te.addTrace(Cs.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(bi, { transportType: Ue });
        } catch (_i) {
          throw Te.setError(Ps$1.subscribe_authenticated_session_topic_failure), _i;
        }
        Te.addTrace(Cs.subscribe_authenticated_session_topic_success), await this.client.session.set(bi, mi), Te.addTrace(Cs.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: Me.pairingTopic, metadata: Me.requester.metadata });
      }
      Te.addTrace(Cs.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: Ve, id: Be, result: { cacaos: Pe, responder: { publicKey: fn, metadata: this.client.metadata } }, encodeOpts: vn, throwOnFailedPublish: !0, appLink: this.getAppLinkIfEnabled(Me.requester.metadata, Ue) });
      } catch (_i) {
        throw Te.setError(Ps$1.authenticated_session_approve_publish_failure), _i;
      }
      return await this.client.auth.requests.delete(Be, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: Me.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: Te.eventId }), { session: mi };
    }, this.rejectSessionAuthenticate = async (Ie) => {
      this.isInitialized();
      const { id: Be, reason: Pe } = Ie, Te = this.getPendingAuthRequest(Be);
      if (!Te) throw new Error(`Could not find pending auth request with id ${Be}`);
      Te.transportType === M$1.relay && await this.confirmOnlineStateOrThrow();
      const Me = Te.requester.publicKey, Ue = await this.client.core.crypto.generateKeyPair(), je = hr$2(Me), fn = { type: D$2, receiverPublicKey: Me, senderPublicKey: Ue };
      await this.sendError({ id: Be, topic: je, error: Pe, encodeOpts: fn, rpcOpts: v$1.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(Te.requester.metadata, Te.transportType) }), await this.client.auth.requests.delete(Be, { message: "rejected", code: 0 }), await this.client.proposal.delete(Be, U$2("USER_DISCONNECTED"));
    }, this.formatAuthMessage = (Ie) => {
      this.isInitialized();
      const { request: Be, iss: Pe } = Ie;
      return dn$1(Be, Pe);
    }, this.processRelayMessageCache = () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const Ie = this.relayMessageCache.shift();
          Ie && await this.onRelayMessage(Ie);
        } catch (Ie) {
          this.client.logger.error(Ie);
        }
      }, 50);
    }, this.cleanupDuplicatePairings = async (Ie) => {
      if (Ie.pairingTopic) try {
        const Be = this.client.core.pairing.pairings.get(Ie.pairingTopic), Pe = this.client.core.pairing.pairings.getAll().filter((Te) => {
          var Me, Ue;
          return ((Me = Te.peerMetadata) == null ? void 0 : Me.url) && ((Ue = Te.peerMetadata) == null ? void 0 : Ue.url) === Ie.peer.metadata.url && Te.topic && Te.topic !== Be.topic;
        });
        if (Pe.length === 0) return;
        this.client.logger.info(`Cleaning up ${Pe.length} duplicate pairing(s)`), await Promise.all(Pe.map((Te) => this.client.core.pairing.disconnect({ topic: Te.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (Be) {
        this.client.logger.error(Be);
      }
    }, this.deleteSession = async (Ie) => {
      var Be;
      const { topic: Pe, expirerHasDeleted: Te = !1, emitEvent: Me = !0, id: Ue = 0 } = Ie, { self: je } = this.client.session.get(Pe);
      await this.client.core.relayer.unsubscribe(Pe), await this.client.session.delete(Pe, U$2("USER_DISCONNECTED")), this.addToRecentlyDeleted(Pe, "session"), this.client.core.crypto.keychain.has(je.publicKey) && await this.client.core.crypto.deleteKeyPair(je.publicKey), this.client.core.crypto.keychain.has(Pe) && await this.client.core.crypto.deleteSymKey(Pe), Te || this.client.core.expirer.del(Pe), this.client.core.storage.removeItem(xe).catch((fn) => this.client.logger.warn(fn)), this.getPendingSessionRequests().forEach((fn) => {
        fn.topic === Pe && this.deletePendingSessionRequest(fn.id, U$2("USER_DISCONNECTED"));
      }), Pe === ((Be = this.sessionRequestQueue.queue[0]) == null ? void 0 : Be.topic) && (this.sessionRequestQueue.state = x$1.idle), Me && this.client.events.emit("session_delete", { id: Ue, topic: Pe });
    }, this.deleteProposal = async (Ie, Be) => {
      if (Be) try {
        const Pe = this.client.proposal.get(Ie), Te = this.client.core.eventClient.getEvent({ topic: Pe.pairingTopic });
        Te == null || Te.setError(Ts$1.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(Ie, U$2("USER_DISCONNECTED")), Be ? Promise.resolve() : this.client.core.expirer.del(Ie)]), this.addToRecentlyDeleted(Ie, "proposal");
    }, this.deletePendingSessionRequest = async (Ie, Be, Pe = !1) => {
      await Promise.all([this.client.pendingRequest.delete(Ie, Be), Pe ? Promise.resolve() : this.client.core.expirer.del(Ie)]), this.addToRecentlyDeleted(Ie, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((Te) => Te.id !== Ie), Pe && (this.sessionRequestQueue.state = x$1.idle, this.client.events.emit("session_request_expire", { id: Ie }));
    }, this.deletePendingAuthRequest = async (Ie, Be, Pe = !1) => {
      await Promise.all([this.client.auth.requests.delete(Ie, Be), Pe ? Promise.resolve() : this.client.core.expirer.del(Ie)]);
    }, this.setExpiry = async (Ie, Be) => {
      this.client.session.keys.includes(Ie) && (this.client.core.expirer.set(Ie, Be), await this.client.session.update(Ie, { expiry: Be }));
    }, this.setProposal = async (Ie, Be) => {
      this.client.core.expirer.set(Ie, Mt$2(v$1.wc_sessionPropose.req.ttl)), await this.client.proposal.set(Ie, Be);
    }, this.setAuthRequest = async (Ie, Be) => {
      const { request: Pe, pairingTopic: Te, transportType: Me = M$1.relay } = Be;
      this.client.core.expirer.set(Ie, Pe.expiryTimestamp), await this.client.auth.requests.set(Ie, { authPayload: Pe.authPayload, requester: Pe.requester, expiryTimestamp: Pe.expiryTimestamp, id: Ie, pairingTopic: Te, verifyContext: Pe.verifyContext, transportType: Me });
    }, this.setPendingSessionRequest = async (Ie) => {
      const { id: Be, topic: Pe, params: Te, verifyContext: Me } = Ie, Ue = Te.request.expiryTimestamp || Mt$2(v$1.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(Be, Ue), await this.client.pendingRequest.set(Be, { id: Be, topic: Pe, params: Te, verifyContext: Me });
    }, this.sendRequest = async (Ie) => {
      const { topic: Be, method: Pe, params: Te, expiry: Me, relayRpcId: Ue, clientRpcId: je, throwOnFailedPublish: fn, appLink: Ve } = Ie, vn = formatJsonRpcRequest(Pe, Te, je);
      let En;
      const fi = !!Ve;
      try {
        const _i = fi ? lr$2 : ge$1;
        En = await this.client.core.crypto.encode(Be, vn, { encoding: _i });
      } catch (_i) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${Be} failed`), _i;
      }
      let bi;
      if (at.includes(Pe)) {
        const _i = yr$2(JSON.stringify(vn)), Ei = yr$2(En);
        bi = await this.client.core.verify.register({ id: Ei, decryptedId: _i });
      }
      const mi = v$1[Pe].req;
      if (mi.attestation = bi, Me && (mi.ttl = Me), Ue && (mi.id = Ue), this.client.core.history.set(Be, vn), fi) {
        const _i = xr$2(Ve, Be, En);
        await global.Linking.openURL(_i, this.client.name);
      } else {
        const _i = v$1[Pe].req;
        Me && (_i.ttl = Me), Ue && (_i.id = Ue), fn ? (_i.internal = D$1(I({}, _i.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(Be, En, _i)) : this.client.core.relayer.publish(Be, En, _i).catch((Ei) => this.client.logger.error(Ei));
      }
      return vn.id;
    }, this.sendResult = async (Ie) => {
      const { id: Be, topic: Pe, result: Te, throwOnFailedPublish: Me, encodeOpts: Ue, appLink: je } = Ie, fn = formatJsonRpcResult(Be, Te);
      let Ve;
      const vn = je && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const fi = vn ? lr$2 : ge$1;
        Ve = await this.client.core.crypto.encode(Pe, fn, D$1(I({}, Ue || {}), { encoding: fi }));
      } catch (fi) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${Pe} failed`), fi;
      }
      let En;
      try {
        En = await this.client.core.history.get(Pe, Be);
      } catch (fi) {
        throw this.client.logger.error(`sendResult() -> history.get(${Pe}, ${Be}) failed`), fi;
      }
      if (vn) {
        const fi = xr$2(je, Pe, Ve);
        await global.Linking.openURL(fi, this.client.name);
      } else {
        const fi = v$1[En.request.method].res;
        Me ? (fi.internal = D$1(I({}, fi.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(Pe, Ve, fi)) : this.client.core.relayer.publish(Pe, Ve, fi).catch((bi) => this.client.logger.error(bi));
      }
      await this.client.core.history.resolve(fn);
    }, this.sendError = async (Ie) => {
      const { id: Be, topic: Pe, error: Te, encodeOpts: Me, rpcOpts: Ue, appLink: je } = Ie, fn = formatJsonRpcError(Be, Te);
      let Ve;
      const vn = je && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const fi = vn ? lr$2 : ge$1;
        Ve = await this.client.core.crypto.encode(Pe, fn, D$1(I({}, Me || {}), { encoding: fi }));
      } catch (fi) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${Pe} failed`), fi;
      }
      let En;
      try {
        En = await this.client.core.history.get(Pe, Be);
      } catch (fi) {
        throw this.client.logger.error(`sendError() -> history.get(${Pe}, ${Be}) failed`), fi;
      }
      if (vn) {
        const fi = xr$2(je, Pe, Ve);
        await global.Linking.openURL(fi, this.client.name);
      } else {
        const fi = Ue || v$1[En.request.method].res;
        this.client.core.relayer.publish(Pe, Ve, fi);
      }
      await this.client.core.history.resolve(fn);
    }, this.cleanup = async () => {
      const Ie = [], Be = [];
      this.client.session.getAll().forEach((Pe) => {
        let Te = !1;
        Kt$2(Pe.expiry) && (Te = !0), this.client.core.crypto.keychain.has(Pe.topic) || (Te = !0), Te && Ie.push(Pe.topic);
      }), this.client.proposal.getAll().forEach((Pe) => {
        Kt$2(Pe.expiryTimestamp) && Be.push(Pe.id);
      }), await Promise.all([...Ie.map((Pe) => this.deleteSession({ topic: Pe })), ...Be.map((Pe) => this.deleteProposal(Pe))]);
    }, this.onRelayEventRequest = async (Ie) => {
      this.requestQueue.queue.push(Ie), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === x$1.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = x$1.active;
        const Ie = this.requestQueue.queue.shift();
        if (Ie) try {
          await this.processRequest(Ie);
        } catch (Be) {
          this.client.logger.warn(Be);
        }
      }
      this.requestQueue.state = x$1.idle;
    }, this.processRequest = async (Ie) => {
      const { topic: Be, payload: Pe, attestation: Te, transportType: Me, encryptedId: Ue } = Ie, je = Pe.method;
      if (!this.shouldIgnorePairingRequest({ topic: Be, requestMethod: je })) switch (je) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: Be, payload: Pe, attestation: Te, encryptedId: Ue });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(Be, Pe);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(Be, Pe);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(Be, Pe);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(Be, Pe);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(Be, Pe);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: Be, payload: Pe, attestation: Te, encryptedId: Ue, transportType: Me });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(Be, Pe);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: Be, payload: Pe, attestation: Te, encryptedId: Ue, transportType: Me });
        default:
          return this.client.logger.info(`Unsupported request method ${je}`);
      }
    }, this.onRelayEventResponse = async (Ie) => {
      const { topic: Be, payload: Pe, transportType: Te } = Ie, Me = (await this.client.core.history.get(Be, Pe.id)).request.method;
      switch (Me) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(Be, Pe, Te);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(Be, Pe);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(Be, Pe);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(Be, Pe);
        case "wc_sessionPing":
          return this.onSessionPingResponse(Be, Pe);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(Be, Pe);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(Be, Pe);
        default:
          return this.client.logger.info(`Unsupported response method ${Me}`);
      }
    }, this.onRelayEventUnknownPayload = (Ie) => {
      const { topic: Be } = Ie, { message: Pe } = S$4("MISSING_OR_INVALID", `Decoded payload on topic ${Be} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(Pe);
    }, this.shouldIgnorePairingRequest = (Ie) => {
      const { topic: Be, requestMethod: Pe } = Ie, Te = this.expectedPairingMethodMap.get(Be);
      return !Te || Te.includes(Pe) ? !1 : !!(Te.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }, this.onSessionProposeRequest = async (Ie) => {
      const { topic: Be, payload: Pe, attestation: Te, encryptedId: Me } = Ie, { params: Ue, id: je } = Pe;
      try {
        const fn = this.client.core.eventClient.getEvent({ topic: Be });
        this.isValidConnect(I({}, Pe.params));
        const Ve = Ue.expiryTimestamp || Mt$2(v$1.wc_sessionPropose.req.ttl), vn = I({ id: je, pairingTopic: Be, expiryTimestamp: Ve }, Ue);
        await this.setProposal(je, vn);
        const En = await this.getVerifyContext({ attestationId: Te, hash: yr$2(JSON.stringify(Pe)), encryptedId: Me, metadata: vn.proposer.metadata });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), fn == null || fn.setError($$1.proposal_listener_not_found)), fn == null || fn.addTrace(z$3.emit_session_proposal), this.client.events.emit("session_proposal", { id: je, params: vn, verifyContext: En });
      } catch (fn) {
        await this.sendError({ id: je, topic: Be, error: fn, rpcOpts: v$1.wc_sessionPropose.autoReject }), this.client.logger.error(fn);
      }
    }, this.onSessionProposeResponse = async (Ie, Be, Pe) => {
      const { id: Te } = Be;
      if (isJsonRpcResult(Be)) {
        const { result: Me } = Be;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: Me });
        const Ue = this.client.proposal.get(Te);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: Ue });
        const je = Ue.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: je });
        const fn = Me.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: fn });
        const Ve = await this.client.core.crypto.generateSharedKey(je, fn);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: Ve });
        const vn = await this.client.core.relayer.subscribe(Ve, { transportType: Pe });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: vn }), await this.client.core.pairing.activate({ topic: Ie });
      } else if (isJsonRpcError(Be)) {
        await this.client.proposal.delete(Te, U$2("USER_DISCONNECTED"));
        const Me = Lt$2("session_connect");
        if (this.events.listenerCount(Me) === 0) throw new Error(`emitting ${Me} without any listeners, 954`);
        this.events.emit(Lt$2("session_connect"), { error: Be.error });
      }
    }, this.onSessionSettleRequest = async (Ie, Be) => {
      const { id: Pe, params: Te } = Be;
      try {
        this.isValidSessionSettleRequest(Te);
        const { relay: Me, controller: Ue, expiry: je, namespaces: fn, sessionProperties: Ve, sessionConfig: vn } = Be.params, En = D$1(I(I({ topic: Ie, relay: Me, expiry: je, namespaces: fn, acknowledged: !0, pairingTopic: "", requiredNamespaces: {}, optionalNamespaces: {}, controller: Ue.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: Ue.publicKey, metadata: Ue.metadata } }, Ve && { sessionProperties: Ve }), vn && { sessionConfig: vn }), { transportType: M$1.relay }), fi = Lt$2("session_connect");
        if (this.events.listenerCount(fi) === 0) throw new Error(`emitting ${fi} without any listeners 997`);
        this.events.emit(Lt$2("session_connect"), { session: En }), await this.sendResult({ id: Be.id, topic: Ie, result: !0, throwOnFailedPublish: !0 });
      } catch (Me) {
        await this.sendError({ id: Pe, topic: Ie, error: Me }), this.client.logger.error(Me);
      }
    }, this.onSessionSettleResponse = async (Ie, Be) => {
      const { id: Pe } = Be;
      isJsonRpcResult(Be) ? (await this.client.session.update(Ie, { acknowledged: !0 }), this.events.emit(Lt$2("session_approve", Pe), {})) : isJsonRpcError(Be) && (await this.client.session.delete(Ie, U$2("USER_DISCONNECTED")), this.events.emit(Lt$2("session_approve", Pe), { error: Be.error }));
    }, this.onSessionUpdateRequest = async (Ie, Be) => {
      const { params: Pe, id: Te } = Be;
      try {
        const Me = `${Ie}_session_update`, Ue = yo.get(Me);
        if (Ue && this.isRequestOutOfSync(Ue, Te)) {
          this.client.logger.info(`Discarding out of sync request - ${Te}`), this.sendError({ id: Te, topic: Ie, error: U$2("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(I({ topic: Ie }, Pe));
        try {
          yo.set(Me, Te), await this.client.session.update(Ie, { namespaces: Pe.namespaces }), await this.sendResult({ id: Te, topic: Ie, result: !0, throwOnFailedPublish: !0 });
        } catch (je) {
          throw yo.delete(Me), je;
        }
        this.client.events.emit("session_update", { id: Te, topic: Ie, params: Pe });
      } catch (Me) {
        await this.sendError({ id: Te, topic: Ie, error: Me }), this.client.logger.error(Me);
      }
    }, this.isRequestOutOfSync = (Ie, Be) => parseInt(Be.toString().slice(0, -3)) <= parseInt(Ie.toString().slice(0, -3)), this.onSessionUpdateResponse = (Ie, Be) => {
      const { id: Pe } = Be, Te = Lt$2("session_update", Pe);
      if (this.events.listenerCount(Te) === 0) throw new Error(`emitting ${Te} without any listeners`);
      isJsonRpcResult(Be) ? this.events.emit(Lt$2("session_update", Pe), {}) : isJsonRpcError(Be) && this.events.emit(Lt$2("session_update", Pe), { error: Be.error });
    }, this.onSessionExtendRequest = async (Ie, Be) => {
      const { id: Pe } = Be;
      try {
        this.isValidExtend({ topic: Ie }), await this.setExpiry(Ie, Mt$2(z$1)), await this.sendResult({ id: Pe, topic: Ie, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_extend", { id: Pe, topic: Ie });
      } catch (Te) {
        await this.sendError({ id: Pe, topic: Ie, error: Te }), this.client.logger.error(Te);
      }
    }, this.onSessionExtendResponse = (Ie, Be) => {
      const { id: Pe } = Be, Te = Lt$2("session_extend", Pe);
      if (this.events.listenerCount(Te) === 0) throw new Error(`emitting ${Te} without any listeners`);
      isJsonRpcResult(Be) ? this.events.emit(Lt$2("session_extend", Pe), {}) : isJsonRpcError(Be) && this.events.emit(Lt$2("session_extend", Pe), { error: Be.error });
    }, this.onSessionPingRequest = async (Ie, Be) => {
      const { id: Pe } = Be;
      try {
        this.isValidPing({ topic: Ie }), await this.sendResult({ id: Pe, topic: Ie, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_ping", { id: Pe, topic: Ie });
      } catch (Te) {
        await this.sendError({ id: Pe, topic: Ie, error: Te }), this.client.logger.error(Te);
      }
    }, this.onSessionPingResponse = (Ie, Be) => {
      const { id: Pe } = Be, Te = Lt$2("session_ping", Pe);
      if (this.events.listenerCount(Te) === 0) throw new Error(`emitting ${Te} without any listeners`);
      setTimeout(() => {
        isJsonRpcResult(Be) ? this.events.emit(Lt$2("session_ping", Pe), {}) : isJsonRpcError(Be) && this.events.emit(Lt$2("session_ping", Pe), { error: Be.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (Ie, Be) => {
      const { id: Pe } = Be;
      try {
        this.isValidDisconnect({ topic: Ie, reason: Be.params }), Promise.all([new Promise((Te) => {
          this.client.core.relayer.once(v$2.publish, async () => {
            Te(await this.deleteSession({ topic: Ie, id: Pe }));
          });
        }), this.sendResult({ id: Pe, topic: Ie, result: !0, throwOnFailedPublish: !0 }), this.cleanupPendingSentRequestsForTopic({ topic: Ie, error: U$2("USER_DISCONNECTED") })]).catch((Te) => this.client.logger.error(Te));
      } catch (Te) {
        this.client.logger.error(Te);
      }
    }, this.onSessionRequest = async (Ie) => {
      var Be, Pe, Te;
      const { topic: Me, payload: Ue, attestation: je, encryptedId: fn, transportType: Ve } = Ie, { id: vn, params: En } = Ue;
      try {
        await this.isValidRequest(I({ topic: Me }, En));
        const fi = this.client.session.get(Me), bi = await this.getVerifyContext({ attestationId: je, hash: yr$2(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", En, vn))), encryptedId: fn, metadata: fi.peer.metadata, transportType: Ve }), mi = { id: vn, topic: Me, params: En, verifyContext: bi };
        await this.setPendingSessionRequest(mi), Ve === M$1.link_mode && (Be = fi.peer.metadata.redirect) != null && Be.universal && this.client.core.addLinkModeSupportedApp((Pe = fi.peer.metadata.redirect) == null ? void 0 : Pe.universal), (Te = this.client.signConfig) != null && Te.disableRequestQueue ? this.emitSessionRequest(mi) : (this.addSessionRequestToSessionRequestQueue(mi), this.processSessionRequestQueue());
      } catch (fi) {
        await this.sendError({ id: vn, topic: Me, error: fi }), this.client.logger.error(fi);
      }
    }, this.onSessionRequestResponse = (Ie, Be) => {
      const { id: Pe } = Be, Te = Lt$2("session_request", Pe);
      if (this.events.listenerCount(Te) === 0) throw new Error(`emitting ${Te} without any listeners`);
      isJsonRpcResult(Be) ? this.events.emit(Lt$2("session_request", Pe), { result: Be.result }) : isJsonRpcError(Be) && this.events.emit(Lt$2("session_request", Pe), { error: Be.error });
    }, this.onSessionEventRequest = async (Ie, Be) => {
      const { id: Pe, params: Te } = Be;
      try {
        const Me = `${Ie}_session_event_${Te.event.name}`, Ue = yo.get(Me);
        if (Ue && this.isRequestOutOfSync(Ue, Pe)) {
          this.client.logger.info(`Discarding out of sync request - ${Pe}`);
          return;
        }
        this.isValidEmit(I({ topic: Ie }, Te)), this.client.events.emit("session_event", { id: Pe, topic: Ie, params: Te }), yo.set(Me, Pe);
      } catch (Me) {
        await this.sendError({ id: Pe, topic: Ie, error: Me }), this.client.logger.error(Me);
      }
    }, this.onSessionAuthenticateResponse = (Ie, Be) => {
      const { id: Pe } = Be;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: Ie, payload: Be }), isJsonRpcResult(Be) ? this.events.emit(Lt$2("session_request", Pe), { result: Be.result }) : isJsonRpcError(Be) && this.events.emit(Lt$2("session_request", Pe), { error: Be.error });
    }, this.onSessionAuthenticateRequest = async (Ie) => {
      var Be;
      const { topic: Pe, payload: Te, attestation: Me, encryptedId: Ue, transportType: je } = Ie;
      try {
        const { requester: fn, authPayload: Ve, expiryTimestamp: vn } = Te.params, En = await this.getVerifyContext({ attestationId: Me, hash: yr$2(JSON.stringify(Te)), encryptedId: Ue, metadata: fn.metadata, transportType: je }), fi = { requester: fn, pairingTopic: Pe, id: Te.id, authPayload: Ve, verifyContext: En, expiryTimestamp: vn };
        await this.setAuthRequest(Te.id, { request: fi, pairingTopic: Pe, transportType: je }), je === M$1.link_mode && (Be = fn.metadata.redirect) != null && Be.universal && this.client.core.addLinkModeSupportedApp(fn.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: Pe, params: Te.params, id: Te.id, verifyContext: En });
      } catch (fn) {
        this.client.logger.error(fn);
        const Ve = Te.params.requester.publicKey, vn = await this.client.core.crypto.generateKeyPair(), En = this.getAppLinkIfEnabled(Te.params.requester.metadata, je), fi = { type: D$2, receiverPublicKey: Ve, senderPublicKey: vn };
        await this.sendError({ id: Te.id, topic: Pe, error: fn, encodeOpts: fi, rpcOpts: v$1.wc_sessionAuthenticate.autoReject, appLink: En });
      }
    }, this.addSessionRequestToSessionRequestQueue = (Ie) => {
      this.sessionRequestQueue.queue.push(Ie);
    }, this.cleanupAfterResponse = (Ie) => {
      this.deletePendingSessionRequest(Ie.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = x$1.idle, this.processSessionRequestQueue();
      }, cjs$3.toMiliseconds(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: Ie, error: Be }) => {
      const Pe = this.client.core.history.pending;
      Pe.length > 0 && Pe.filter((Te) => Te.topic === Ie && Te.request.method === "wc_sessionRequest").forEach((Te) => {
        const Me = Te.request.id, Ue = Lt$2("session_request", Me);
        if (this.events.listenerCount(Ue) === 0) throw new Error(`emitting ${Ue} without any listeners`);
        this.events.emit(Lt$2("session_request", Te.request.id), { error: Be });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === x$1.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const Ie = this.sessionRequestQueue.queue[0];
      if (!Ie) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = x$1.active, this.emitSessionRequest(Ie);
      } catch (Be) {
        this.client.logger.error(Be);
      }
    }, this.emitSessionRequest = (Ie) => {
      this.client.events.emit("session_request", Ie);
    }, this.onPairingCreated = (Ie) => {
      if (Ie.methods && this.expectedPairingMethodMap.set(Ie.topic, Ie.methods), Ie.active) return;
      const Be = this.client.proposal.getAll().find((Pe) => Pe.pairingTopic === Ie.topic);
      Be && this.onSessionProposeRequest({ topic: Ie.topic, payload: formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: Be.requiredNamespaces, optionalNamespaces: Be.optionalNamespaces, relays: Be.relays, proposer: Be.proposer, sessionProperties: Be.sessionProperties }, Be.id) });
    }, this.isValidConnect = async (Ie) => {
      if (!to(Ie)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(Ie)}`);
        throw new Error(je);
      }
      const { pairingTopic: Be, requiredNamespaces: Pe, optionalNamespaces: Te, sessionProperties: Me, relays: Ue } = Ie;
      if (I$3(Be) || await this.isValidPairingTopic(Be), !eo(Ue)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `connect() relays: ${Ue}`);
        throw new Error(je);
      }
      !I$3(Pe) && Z$3(Pe) !== 0 && this.validateNamespaces(Pe, "requiredNamespaces"), !I$3(Te) && Z$3(Te) !== 0 && this.validateNamespaces(Te, "optionalNamespaces"), I$3(Me) || this.validateSessionProps(Me, "sessionProperties");
    }, this.validateNamespaces = (Ie, Be) => {
      const Pe = Xr$1(Ie, "connect()", Be);
      if (Pe) throw new Error(Pe.message);
    }, this.isValidApprove = async (Ie) => {
      if (!to(Ie)) throw new Error(S$4("MISSING_OR_INVALID", `approve() params: ${Ie}`).message);
      const { id: Be, namespaces: Pe, relayProtocol: Te, sessionProperties: Me } = Ie;
      this.checkRecentlyDeleted(Be), await this.isValidProposalId(Be);
      const Ue = this.client.proposal.get(Be), je = Wn(Pe, "approve()");
      if (je) throw new Error(je.message);
      const fn = zn(Ue.requiredNamespaces, Pe, "approve()");
      if (fn) throw new Error(fn.message);
      if (!b$2(Te, !0)) {
        const { message: Ve } = S$4("MISSING_OR_INVALID", `approve() relayProtocol: ${Te}`);
        throw new Error(Ve);
      }
      I$3(Me) || this.validateSessionProps(Me, "sessionProperties");
    }, this.isValidReject = async (Ie) => {
      if (!to(Ie)) {
        const { message: Te } = S$4("MISSING_OR_INVALID", `reject() params: ${Ie}`);
        throw new Error(Te);
      }
      const { id: Be, reason: Pe } = Ie;
      if (this.checkRecentlyDeleted(Be), await this.isValidProposalId(Be), !ro(Pe)) {
        const { message: Te } = S$4("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(Pe)}`);
        throw new Error(Te);
      }
    }, this.isValidSessionSettleRequest = (Ie) => {
      if (!to(Ie)) {
        const { message: fn } = S$4("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${Ie}`);
        throw new Error(fn);
      }
      const { relay: Be, controller: Pe, namespaces: Te, expiry: Me } = Ie;
      if (!Jn(Be)) {
        const { message: fn } = S$4("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(fn);
      }
      const Ue = Zr$1(Pe, "onSessionSettleRequest()");
      if (Ue) throw new Error(Ue.message);
      const je = Wn(Te, "onSessionSettleRequest()");
      if (je) throw new Error(je.message);
      if (Kt$2(Me)) {
        const { message: fn } = S$4("EXPIRED", "onSessionSettleRequest()");
        throw new Error(fn);
      }
    }, this.isValidUpdate = async (Ie) => {
      if (!to(Ie)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `update() params: ${Ie}`);
        throw new Error(je);
      }
      const { topic: Be, namespaces: Pe } = Ie;
      this.checkRecentlyDeleted(Be), await this.isValidSessionTopic(Be);
      const Te = this.client.session.get(Be), Me = Wn(Pe, "update()");
      if (Me) throw new Error(Me.message);
      const Ue = zn(Te.requiredNamespaces, Pe, "update()");
      if (Ue) throw new Error(Ue.message);
    }, this.isValidExtend = async (Ie) => {
      if (!to(Ie)) {
        const { message: Pe } = S$4("MISSING_OR_INVALID", `extend() params: ${Ie}`);
        throw new Error(Pe);
      }
      const { topic: Be } = Ie;
      this.checkRecentlyDeleted(Be), await this.isValidSessionTopic(Be);
    }, this.isValidRequest = async (Ie) => {
      if (!to(Ie)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `request() params: ${Ie}`);
        throw new Error(je);
      }
      const { topic: Be, request: Pe, chainId: Te, expiry: Me } = Ie;
      this.checkRecentlyDeleted(Be), await this.isValidSessionTopic(Be);
      const { namespaces: Ue } = this.client.session.get(Be);
      if (!co(Ue, Te)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `request() chainId: ${Te}`);
        throw new Error(je);
      }
      if (!oo(Pe)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `request() ${JSON.stringify(Pe)}`);
        throw new Error(je);
      }
      if (!ao(Ue, Te, Pe.method)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `request() method: ${Pe.method}`);
        throw new Error(je);
      }
      if (Me && !po(Me, me)) {
        const { message: je } = S$4("MISSING_OR_INVALID", `request() expiry: ${Me}. Expiry must be a number (in seconds) between ${me.min} and ${me.max}`);
        throw new Error(je);
      }
    }, this.isValidRespond = async (Ie) => {
      var Be;
      if (!to(Ie)) {
        const { message: Me } = S$4("MISSING_OR_INVALID", `respond() params: ${Ie}`);
        throw new Error(Me);
      }
      const { topic: Pe, response: Te } = Ie;
      try {
        await this.isValidSessionTopic(Pe);
      } catch (Me) {
        throw (Be = Ie == null ? void 0 : Ie.response) != null && Be.id && this.cleanupAfterResponse(Ie), Me;
      }
      if (!so(Te)) {
        const { message: Me } = S$4("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(Te)}`);
        throw new Error(Me);
      }
    }, this.isValidPing = async (Ie) => {
      if (!to(Ie)) {
        const { message: Pe } = S$4("MISSING_OR_INVALID", `ping() params: ${Ie}`);
        throw new Error(Pe);
      }
      const { topic: Be } = Ie;
      await this.isValidSessionOrPairingTopic(Be);
    }, this.isValidEmit = async (Ie) => {
      if (!to(Ie)) {
        const { message: Ue } = S$4("MISSING_OR_INVALID", `emit() params: ${Ie}`);
        throw new Error(Ue);
      }
      const { topic: Be, event: Pe, chainId: Te } = Ie;
      await this.isValidSessionTopic(Be);
      const { namespaces: Me } = this.client.session.get(Be);
      if (!co(Me, Te)) {
        const { message: Ue } = S$4("MISSING_OR_INVALID", `emit() chainId: ${Te}`);
        throw new Error(Ue);
      }
      if (!io(Pe)) {
        const { message: Ue } = S$4("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(Pe)}`);
        throw new Error(Ue);
      }
      if (!uo(Me, Te, Pe.name)) {
        const { message: Ue } = S$4("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(Pe)}`);
        throw new Error(Ue);
      }
    }, this.isValidDisconnect = async (Ie) => {
      if (!to(Ie)) {
        const { message: Pe } = S$4("MISSING_OR_INVALID", `disconnect() params: ${Ie}`);
        throw new Error(Pe);
      }
      const { topic: Be } = Ie;
      await this.isValidSessionOrPairingTopic(Be);
    }, this.isValidAuthenticate = (Ie) => {
      const { chains: Be, uri: Pe, domain: Te, nonce: Me } = Ie;
      if (!Array.isArray(Be) || Be.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!b$2(Pe, !1)) throw new Error("uri is required parameter");
      if (!b$2(Te, !1)) throw new Error("domain is required parameter");
      if (!b$2(Me, !1)) throw new Error("nonce is required parameter");
      if ([...new Set(Be.map((je) => re$2(je).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: Ue } = re$2(Be[0]);
      if (Ue !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }, this.getVerifyContext = async (Ie) => {
      const { attestationId: Be, hash: Pe, encryptedId: Te, metadata: Me, transportType: Ue } = Ie, je = { verified: { verifyUrl: Me.verifyUrl || J$1, validation: "UNKNOWN", origin: Me.url || "" } };
      try {
        if (Ue === M$1.link_mode) {
          const Ve = this.getAppLinkIfEnabled(Me, Ue);
          return je.verified.validation = Ve && new URL(Ve).origin === new URL(Me.url).origin ? "VALID" : "INVALID", je;
        }
        const fn = await this.client.core.verify.resolve({ attestationId: Be, hash: Pe, encryptedId: Te, verifyUrl: Me.verifyUrl });
        fn && (je.verified.origin = fn.origin, je.verified.isScam = fn.isScam, je.verified.validation = fn.origin === new URL(Me.url).origin ? "VALID" : "INVALID");
      } catch (fn) {
        this.client.logger.warn(fn);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(je)}`), je;
    }, this.validateSessionProps = (Ie, Be) => {
      Object.values(Ie).forEach((Pe) => {
        if (!b$2(Pe, !1)) {
          const { message: Te } = S$4("MISSING_OR_INVALID", `${Be} must be in Record<string, string> format. Received: ${JSON.stringify(Pe)}`);
          throw new Error(Te);
        }
      });
    }, this.getPendingAuthRequest = (Ie) => {
      const Be = this.client.auth.requests.get(Ie);
      return typeof Be == "object" ? Be : void 0;
    }, this.addToRecentlyDeleted = (Ie, Be) => {
      if (this.recentlyDeletedMap.set(Ie, Be), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let Pe = 0;
        const Te = this.recentlyDeletedLimit / 2;
        for (const Me of this.recentlyDeletedMap.keys()) {
          if (Pe++ >= Te) break;
          this.recentlyDeletedMap.delete(Me);
        }
      }
    }, this.checkRecentlyDeleted = (Ie) => {
      const Be = this.recentlyDeletedMap.get(Ie);
      if (Be) {
        const { message: Pe } = S$4("MISSING_OR_INVALID", `Record was recently deleted - ${Be}: ${Ie}`);
        throw new Error(Pe);
      }
    }, this.isLinkModeEnabled = (Ie, Be) => {
      var Pe, Te, Me, Ue, je, fn, Ve, vn, En;
      return !Ie || Be !== M$1.link_mode ? !1 : ((Te = (Pe = this.client.metadata) == null ? void 0 : Pe.redirect) == null ? void 0 : Te.linkMode) === !0 && ((Ue = (Me = this.client.metadata) == null ? void 0 : Me.redirect) == null ? void 0 : Ue.universal) !== void 0 && ((fn = (je = this.client.metadata) == null ? void 0 : je.redirect) == null ? void 0 : fn.universal) !== "" && ((Ve = Ie == null ? void 0 : Ie.redirect) == null ? void 0 : Ve.universal) !== void 0 && ((vn = Ie == null ? void 0 : Ie.redirect) == null ? void 0 : vn.universal) !== "" && ((En = Ie == null ? void 0 : Ie.redirect) == null ? void 0 : En.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(Ie.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }, this.getAppLinkIfEnabled = (Ie, Be) => {
      var Pe;
      return this.isLinkModeEnabled(Ie, Be) ? (Pe = Ie == null ? void 0 : Ie.redirect) == null ? void 0 : Pe.universal : void 0;
    }, this.handleLinkModeMessage = ({ url: Ie }) => {
      if (!Ie || !Ie.includes("wc_ev") || !Ie.includes("topic")) return;
      const Be = Bt$2(Ie, "topic") || "", Pe = decodeURIComponent(Bt$2(Ie, "wc_ev") || ""), Te = this.client.session.keys.includes(Be);
      Te && this.client.session.update(Be, { transportType: M$1.link_mode }), this.client.core.dispatchEnvelope({ topic: Be, message: Pe, sessionExists: Te });
    }, this.registerLinkModeListeners = async () => {
      var Ie;
      if (Wt$2() || _$1() && (Ie = this.client.metadata.redirect) != null && Ie.linkMode) {
        const Be = global == null ? void 0 : global.Linking;
        if (typeof Be < "u") {
          Be.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const Pe = await Be.getInitialURL();
          Pe && setTimeout(() => {
            this.handleLinkModeMessage({ url: Pe });
          }, 50);
        }
      }
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S$4("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(v$2.message, (t) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(t) : this.onRelayMessage(t);
    });
  }
  async onRelayMessage(t) {
    const { topic: Ie, message: Be, attestation: Pe, transportType: Te } = t, { publicKey: Me } = this.client.auth.authKeys.keys.includes(ae) ? this.client.auth.authKeys.get(ae) : { responseTopic: void 0, publicKey: void 0 }, Ue = await this.client.core.crypto.decode(Ie, Be, { receiverPublicKey: Me, encoding: Te === M$1.link_mode ? lr$2 : ge$1 });
    try {
      isJsonRpcRequest(Ue) ? (this.client.core.history.set(Ie, Ue), this.onRelayEventRequest({ topic: Ie, payload: Ue, attestation: Pe, transportType: Te, encryptedId: yr$2(Be) })) : isJsonRpcResponse(Ue) ? (await this.client.core.history.resolve(Ue), await this.onRelayEventResponse({ topic: Ie, payload: Ue, transportType: Te }), this.client.core.history.delete(Ie, Ue.id)) : this.onRelayEventUnknownPayload({ topic: Ie, payload: Ue, transportType: Te });
    } catch (je) {
      this.client.logger.error(je);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(S$2.expired, async (t) => {
      const { topic: Ie, id: Be } = Vt$2(t.target);
      if (Be && this.client.pendingRequest.keys.includes(Be)) return await this.deletePendingSessionRequest(Be, S$4("EXPIRED"), !0);
      if (Be && this.client.auth.requests.keys.includes(Be)) return await this.deletePendingAuthRequest(Be, S$4("EXPIRED"), !0);
      Ie ? this.client.session.keys.includes(Ie) && (await this.deleteSession({ topic: Ie, expirerHasDeleted: !0 }), this.client.events.emit("session_expire", { topic: Ie })) : Be && (await this.deleteProposal(Be, !0), this.client.events.emit("proposal_expire", { id: Be }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(V$2.create, (t) => this.onPairingCreated(t)), this.client.core.pairing.events.on(V$2.delete, (t) => {
      this.addToRecentlyDeleted(t.topic, "pairing");
    });
  }
  isValidPairingTopic(t) {
    if (!b$2(t, !1)) {
      const { message: Ie } = S$4("MISSING_OR_INVALID", `pairing topic should be a string: ${t}`);
      throw new Error(Ie);
    }
    if (!this.client.core.pairing.pairings.keys.includes(t)) {
      const { message: Ie } = S$4("NO_MATCHING_KEY", `pairing topic doesn't exist: ${t}`);
      throw new Error(Ie);
    }
    if (Kt$2(this.client.core.pairing.pairings.get(t).expiry)) {
      const { message: Ie } = S$4("EXPIRED", `pairing topic: ${t}`);
      throw new Error(Ie);
    }
  }
  async isValidSessionTopic(t) {
    if (!b$2(t, !1)) {
      const { message: Ie } = S$4("MISSING_OR_INVALID", `session topic should be a string: ${t}`);
      throw new Error(Ie);
    }
    if (this.checkRecentlyDeleted(t), !this.client.session.keys.includes(t)) {
      const { message: Ie } = S$4("NO_MATCHING_KEY", `session topic doesn't exist: ${t}`);
      throw new Error(Ie);
    }
    if (Kt$2(this.client.session.get(t).expiry)) {
      await this.deleteSession({ topic: t });
      const { message: Ie } = S$4("EXPIRED", `session topic: ${t}`);
      throw new Error(Ie);
    }
    if (!this.client.core.crypto.keychain.has(t)) {
      const { message: Ie } = S$4("MISSING_OR_INVALID", `session topic does not exist in keychain: ${t}`);
      throw await this.deleteSession({ topic: t }), new Error(Ie);
    }
  }
  async isValidSessionOrPairingTopic(t) {
    if (this.checkRecentlyDeleted(t), this.client.session.keys.includes(t)) await this.isValidSessionTopic(t);
    else if (this.client.core.pairing.pairings.keys.includes(t)) this.isValidPairingTopic(t);
    else if (b$2(t, !1)) {
      const { message: Ie } = S$4("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${t}`);
      throw new Error(Ie);
    } else {
      const { message: Ie } = S$4("MISSING_OR_INVALID", `session or pairing topic should be a string: ${t}`);
      throw new Error(Ie);
    }
  }
  async isValidProposalId(t) {
    if (!no(t)) {
      const { message: Ie } = S$4("MISSING_OR_INVALID", `proposal id should be a number: ${t}`);
      throw new Error(Ie);
    }
    if (!this.client.proposal.keys.includes(t)) {
      const { message: Ie } = S$4("NO_MATCHING_KEY", `proposal id doesn't exist: ${t}`);
      throw new Error(Ie);
    }
    if (Kt$2(this.client.proposal.get(t).expiryTimestamp)) {
      await this.deleteProposal(t);
      const { message: Ie } = S$4("EXPIRED", `proposal id: ${t}`);
      throw new Error(Ie);
    }
  }
}
class Ss extends ni {
  constructor(t, Ie) {
    super(t, Ie, st, ye), this.core = t, this.logger = Ie;
  }
}
class yt extends ni {
  constructor(t, Ie) {
    super(t, Ie, rt, ye), this.core = t, this.logger = Ie;
  }
}
class Is extends ni {
  constructor(t, Ie) {
    super(t, Ie, ot, ye, (Be) => Be.id), this.core = t, this.logger = Ie;
  }
}
class fs extends ni {
  constructor(t, Ie) {
    super(t, Ie, pt, oe, () => ae), this.core = t, this.logger = Ie;
  }
}
class vs extends ni {
  constructor(t, Ie) {
    super(t, Ie, ht, oe), this.core = t, this.logger = Ie;
  }
}
class qs extends ni {
  constructor(t, Ie) {
    super(t, Ie, dt, oe, (Be) => Be.id), this.core = t, this.logger = Ie;
  }
}
class Ts {
  constructor(t, Ie) {
    this.core = t, this.logger = Ie, this.authKeys = new fs(this.core, this.logger), this.pairingTopics = new vs(this.core, this.logger), this.requests = new qs(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
}
class _e extends S$5 {
  constructor(t) {
    super(t), this.protocol = be, this.version = Ce, this.name = we.name, this.events = new eventsExports.EventEmitter(), this.on = (Be, Pe) => this.events.on(Be, Pe), this.once = (Be, Pe) => this.events.once(Be, Pe), this.off = (Be, Pe) => this.events.off(Be, Pe), this.removeListener = (Be, Pe) => this.events.removeListener(Be, Pe), this.removeAllListeners = (Be) => this.events.removeAllListeners(Be), this.connect = async (Be) => {
      try {
        return await this.engine.connect(Be);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.pair = async (Be) => {
      try {
        return await this.engine.pair(Be);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.approve = async (Be) => {
      try {
        return await this.engine.approve(Be);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.reject = async (Be) => {
      try {
        return await this.engine.reject(Be);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.update = async (Be) => {
      try {
        return await this.engine.update(Be);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.extend = async (Be) => {
      try {
        return await this.engine.extend(Be);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.request = async (Be) => {
      try {
        return await this.engine.request(Be);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.respond = async (Be) => {
      try {
        return await this.engine.respond(Be);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.ping = async (Be) => {
      try {
        return await this.engine.ping(Be);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.emit = async (Be) => {
      try {
        return await this.engine.emit(Be);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.disconnect = async (Be) => {
      try {
        return await this.engine.disconnect(Be);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.find = (Be) => {
      try {
        return this.engine.find(Be);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.authenticate = async (Be, Pe) => {
      try {
        return await this.engine.authenticate(Be, Pe);
      } catch (Te) {
        throw this.logger.error(Te.message), Te;
      }
    }, this.formatAuthMessage = (Be) => {
      try {
        return this.engine.formatAuthMessage(Be);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.approveSessionAuthenticate = async (Be) => {
      try {
        return await this.engine.approveSessionAuthenticate(Be);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.rejectSessionAuthenticate = async (Be) => {
      try {
        return await this.engine.rejectSessionAuthenticate(Be);
      } catch (Pe) {
        throw this.logger.error(Pe.message), Pe;
      }
    }, this.name = (t == null ? void 0 : t.name) || we.name, this.metadata = (t == null ? void 0 : t.metadata) || Nt$2(), this.signConfig = t == null ? void 0 : t.signConfig;
    const Ie = typeof (t == null ? void 0 : t.logger) < "u" && typeof (t == null ? void 0 : t.logger) != "string" ? t.logger : qt$3(k$2({ level: (t == null ? void 0 : t.logger) || we.logger }));
    this.core = (t == null ? void 0 : t.core) || new bn(t), this.logger = E$1(Ie, this.name), this.session = new yt(this.core, this.logger), this.proposal = new Ss(this.core, this.logger), this.pendingRequest = new Is(this.core, this.logger), this.engine = new Rs(this), this.auth = new Ts(this.core, this.logger);
  }
  static async init(t) {
    const Ie = new _e(t);
    return await Ie.initialize(), Ie;
  }
  get context() {
    return y$3(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), this.engine.processRelayMessageCache();
    } catch (t) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(t.message), t;
    }
  }
}
const Ns = yt, Ps = _e;
var l = { exports: {} }, c = typeof Reflect == "object" ? Reflect : null, y = c && typeof c.apply == "function" ? c.apply : function(Ae, t, Ie) {
  return Function.prototype.apply.call(Ae, t, Ie);
}, f;
c && typeof c.ownKeys == "function" ? f = c.ownKeys : Object.getOwnPropertySymbols ? f = function(Ae) {
  return Object.getOwnPropertyNames(Ae).concat(Object.getOwnPropertySymbols(Ae));
} : f = function(Ae) {
  return Object.getOwnPropertyNames(Ae);
};
function k(Ae) {
  console && console.warn && console.warn(Ae);
}
var w = Number.isNaN || function(Ae) {
  return Ae !== Ae;
};
function o() {
  o.init.call(this);
}
l.exports = o, l.exports.once = K, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
var L = 10;
function g(Ae) {
  if (typeof Ae != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof Ae);
}
Object.defineProperty(o, "defaultMaxListeners", { enumerable: !0, get: function() {
  return L;
}, set: function(Ae) {
  if (typeof Ae != "number" || Ae < 0 || w(Ae)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + Ae + ".");
  L = Ae;
} }), o.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o.prototype.setMaxListeners = function(Ae) {
  if (typeof Ae != "number" || Ae < 0 || w(Ae)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + Ae + ".");
  return this._maxListeners = Ae, this;
};
function _(Ae) {
  return Ae._maxListeners === void 0 ? o.defaultMaxListeners : Ae._maxListeners;
}
o.prototype.getMaxListeners = function() {
  return _(this);
}, o.prototype.emit = function(Ae) {
  for (var t = [], Ie = 1; Ie < arguments.length; Ie++) t.push(arguments[Ie]);
  var Be = Ae === "error", Pe = this._events;
  if (Pe !== void 0) Be = Be && Pe.error === void 0;
  else if (!Be) return !1;
  if (Be) {
    var Te;
    if (t.length > 0 && (Te = t[0]), Te instanceof Error) throw Te;
    var Me = new Error("Unhandled error." + (Te ? " (" + Te.message + ")" : ""));
    throw Me.context = Te, Me;
  }
  var Ue = Pe[Ae];
  if (Ue === void 0) return !1;
  if (typeof Ue == "function") y(Ue, this, t);
  else for (var je = Ue.length, fn = O(Ue, je), Ie = 0; Ie < je; ++Ie) y(fn[Ie], this, t);
  return !0;
};
function S(Ae, t, Ie, Be) {
  var Pe, Te, Me;
  if (g(Ie), Te = Ae._events, Te === void 0 ? (Te = Ae._events = /* @__PURE__ */ Object.create(null), Ae._eventsCount = 0) : (Te.newListener !== void 0 && (Ae.emit("newListener", t, Ie.listener ? Ie.listener : Ie), Te = Ae._events), Me = Te[t]), Me === void 0) Me = Te[t] = Ie, ++Ae._eventsCount;
  else if (typeof Me == "function" ? Me = Te[t] = Be ? [Ie, Me] : [Me, Ie] : Be ? Me.unshift(Ie) : Me.push(Ie), Pe = _(Ae), Pe > 0 && Me.length > Pe && !Me.warned) {
    Me.warned = !0;
    var Ue = new Error("Possible EventEmitter memory leak detected. " + Me.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    Ue.name = "MaxListenersExceededWarning", Ue.emitter = Ae, Ue.type = t, Ue.count = Me.length, k(Ue);
  }
  return Ae;
}
o.prototype.addListener = function(Ae, t) {
  return S(this, Ae, t, !1);
}, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(Ae, t) {
  return S(this, Ae, t, !0);
};
function D() {
  if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function C(Ae, t, Ie) {
  var Be = { fired: !1, wrapFn: void 0, target: Ae, type: t, listener: Ie }, Pe = D.bind(Be);
  return Pe.listener = Ie, Be.wrapFn = Pe, Pe;
}
o.prototype.once = function(Ae, t) {
  return g(t), this.on(Ae, C(this, Ae, t)), this;
}, o.prototype.prependOnceListener = function(Ae, t) {
  return g(t), this.prependListener(Ae, C(this, Ae, t)), this;
}, o.prototype.removeListener = function(Ae, t) {
  var Ie, Be, Pe, Te, Me;
  if (g(t), Be = this._events, Be === void 0) return this;
  if (Ie = Be[Ae], Ie === void 0) return this;
  if (Ie === t || Ie.listener === t) --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete Be[Ae], Be.removeListener && this.emit("removeListener", Ae, Ie.listener || t));
  else if (typeof Ie != "function") {
    for (Pe = -1, Te = Ie.length - 1; Te >= 0; Te--) if (Ie[Te] === t || Ie[Te].listener === t) {
      Me = Ie[Te].listener, Pe = Te;
      break;
    }
    if (Pe < 0) return this;
    Pe === 0 ? Ie.shift() : F(Ie, Pe), Ie.length === 1 && (Be[Ae] = Ie[0]), Be.removeListener !== void 0 && this.emit("removeListener", Ae, Me || t);
  }
  return this;
}, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(Ae) {
  var t, Ie, Be;
  if (Ie = this._events, Ie === void 0) return this;
  if (Ie.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Ie[Ae] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Ie[Ae]), this;
  if (arguments.length === 0) {
    var Pe = Object.keys(Ie), Te;
    for (Be = 0; Be < Pe.length; ++Be) Te = Pe[Be], Te !== "removeListener" && this.removeAllListeners(Te);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = Ie[Ae], typeof t == "function") this.removeListener(Ae, t);
  else if (t !== void 0) for (Be = t.length - 1; Be >= 0; Be--) this.removeListener(Ae, t[Be]);
  return this;
};
function b(Ae, t, Ie) {
  var Be = Ae._events;
  if (Be === void 0) return [];
  var Pe = Be[t];
  return Pe === void 0 ? [] : typeof Pe == "function" ? Ie ? [Pe.listener || Pe] : [Pe] : Ie ? z(Pe) : O(Pe, Pe.length);
}
o.prototype.listeners = function(Ae) {
  return b(this, Ae, !0);
}, o.prototype.rawListeners = function(Ae) {
  return b(this, Ae, !1);
}, o.listenerCount = function(Ae, t) {
  return typeof Ae.listenerCount == "function" ? Ae.listenerCount(t) : E.call(Ae, t);
}, o.prototype.listenerCount = E;
function E(Ae) {
  var t = this._events;
  if (t !== void 0) {
    var Ie = t[Ae];
    if (typeof Ie == "function") return 1;
    if (Ie !== void 0) return Ie.length;
  }
  return 0;
}
o.prototype.eventNames = function() {
  return this._eventsCount > 0 ? f(this._events) : [];
};
function O(Ae, t) {
  for (var Ie = new Array(t), Be = 0; Be < t; ++Be) Ie[Be] = Ae[Be];
  return Ie;
}
function F(Ae, t) {
  for (; t + 1 < Ae.length; t++) Ae[t] = Ae[t + 1];
  Ae.pop();
}
function z(Ae) {
  for (var t = new Array(Ae.length), Ie = 0; Ie < t.length; ++Ie) t[Ie] = Ae[Ie].listener || Ae[Ie];
  return t;
}
function K(Ae, t) {
  return new Promise(function(Ie, Be) {
    function Pe(Me) {
      Ae.removeListener(t, Te), Be(Me);
    }
    function Te() {
      typeof Ae.removeListener == "function" && Ae.removeListener("error", Pe), Ie([].slice.call(arguments));
    }
    R(Ae, t, Te, { once: !0 }), t !== "error" && U(Ae, Pe, { once: !0 });
  });
}
function U(Ae, t, Ie) {
  typeof Ae.on == "function" && R(Ae, "error", t, Ie);
}
function R(Ae, t, Ie, Be) {
  if (typeof Ae.on == "function") Be.once ? Ae.once(t, Ie) : Ae.on(t, Ie);
  else if (typeof Ae.addEventListener == "function") Ae.addEventListener(t, function Pe(Te) {
    Be.once && Ae.removeEventListener(t, Pe), Ie(Te);
  });
  else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof Ae);
}
const p = "Web3Wallet";
class x {
  constructor(t) {
    this.opts = t;
  }
}
class P {
  constructor(t) {
    this.client = t;
  }
}
var V = Object.defineProperty, B = Object.defineProperties, J = Object.getOwnPropertyDescriptors, q = Object.getOwnPropertySymbols, Y = Object.prototype.hasOwnProperty, Z = Object.prototype.propertyIsEnumerable, j = (Ae, t, Ie) => t in Ae ? V(Ae, t, { enumerable: !0, configurable: !0, writable: !0, value: Ie }) : Ae[t] = Ie, ee = (Ae, t) => {
  for (var Ie in t || (t = {})) Y.call(t, Ie) && j(Ae, Ie, t[Ie]);
  if (q) for (var Ie of q(t)) Z.call(t, Ie) && j(Ae, Ie, t[Ie]);
  return Ae;
}, te = (Ae, t) => B(Ae, J(t));
class se extends P {
  constructor(t) {
    super(t), this.init = async () => {
      this.signClient = await Ps.init({ core: this.client.core, metadata: this.client.metadata, signConfig: this.client.signConfig }), this.authClient = await zr.init({ core: this.client.core, projectId: "", metadata: this.client.metadata });
    }, this.pair = async (Ie) => {
      await this.client.core.pairing.pair(Ie);
    }, this.approveSession = async (Ie) => {
      const { topic: Be, acknowledged: Pe } = await this.signClient.approve(te(ee({}, Ie), { id: Ie.id, namespaces: Ie.namespaces, sessionProperties: Ie.sessionProperties, sessionConfig: Ie.sessionConfig }));
      return await Pe(), this.signClient.session.get(Be);
    }, this.rejectSession = async (Ie) => await this.signClient.reject(Ie), this.updateSession = async (Ie) => await this.signClient.update(Ie), this.extendSession = async (Ie) => await this.signClient.extend(Ie), this.respondSessionRequest = async (Ie) => await this.signClient.respond(Ie), this.disconnectSession = async (Ie) => await this.signClient.disconnect(Ie), this.emitSessionEvent = async (Ie) => await this.signClient.emit(Ie), this.getActiveSessions = () => this.signClient.session.getAll().reduce((Ie, Be) => (Ie[Be.topic] = Be, Ie), {}), this.getPendingSessionProposals = () => this.signClient.proposal.getAll(), this.getPendingSessionRequests = () => this.signClient.getPendingSessionRequests(), this.respondAuthRequest = async (Ie, Be) => await this.authClient.respond(Ie, Be), this.getPendingAuthRequests = () => this.authClient.requests.getAll().filter((Ie) => "requester" in Ie), this.formatMessage = (Ie, Be) => this.authClient.formatMessage(Ie, Be), this.approveSessionAuthenticate = async (Ie) => await this.signClient.approveSessionAuthenticate(Ie), this.rejectSessionAuthenticate = async (Ie) => await this.signClient.rejectSessionAuthenticate(Ie), this.formatAuthMessage = (Ie) => this.signClient.formatAuthMessage(Ie), this.registerDeviceToken = (Ie) => this.client.core.echoClient.registerDeviceToken(Ie), this.on = (Ie, Be) => (this.setEvent(Ie, "off"), this.setEvent(Ie, "on"), this.client.events.on(Ie, Be)), this.once = (Ie, Be) => (this.setEvent(Ie, "off"), this.setEvent(Ie, "once"), this.client.events.once(Ie, Be)), this.off = (Ie, Be) => (this.setEvent(Ie, "off"), this.client.events.off(Ie, Be)), this.removeListener = (Ie, Be) => (this.setEvent(Ie, "removeListener"), this.client.events.removeListener(Ie, Be)), this.onSessionRequest = (Ie) => {
      this.client.events.emit("session_request", Ie);
    }, this.onSessionProposal = (Ie) => {
      this.client.events.emit("session_proposal", Ie);
    }, this.onSessionDelete = (Ie) => {
      this.client.events.emit("session_delete", Ie);
    }, this.onAuthRequest = (Ie) => {
      this.client.events.emit("auth_request", Ie);
    }, this.onProposalExpire = (Ie) => {
      this.client.events.emit("proposal_expire", Ie);
    }, this.onSessionRequestExpire = (Ie) => {
      this.client.events.emit("session_request_expire", Ie);
    }, this.onSessionRequestAuthenticate = (Ie) => {
      this.client.events.emit("session_authenticate", Ie);
    }, this.setEvent = (Ie, Be) => {
      switch (Ie) {
        case "session_request":
          this.signClient.events[Be]("session_request", this.onSessionRequest);
          break;
        case "session_proposal":
          this.signClient.events[Be]("session_proposal", this.onSessionProposal);
          break;
        case "session_delete":
          this.signClient.events[Be]("session_delete", this.onSessionDelete);
          break;
        case "auth_request":
          this.authClient[Be]("auth_request", this.onAuthRequest);
          break;
        case "proposal_expire":
          this.signClient.events[Be]("proposal_expire", this.onProposalExpire);
          break;
        case "session_request_expire":
          this.signClient.events[Be]("session_request_expire", this.onSessionRequestExpire);
          break;
        case "session_authenticate":
          this.signClient.events[Be]("session_authenticate", this.onSessionRequestAuthenticate);
          break;
      }
    }, this.signClient = {}, this.authClient = {};
  }
}
const ne = { decryptMessage: async (Ae) => {
  const t = { core: new bn({ storageOptions: Ae.storageOptions, storage: Ae.storage }) };
  await t.core.crypto.init();
  const Ie = t.core.crypto.decode(Ae.topic, Ae.encryptedMessage);
  return t.core = null, Ie;
}, getMetadata: async (Ae) => {
  const t = { core: new bn({ storageOptions: Ae.storageOptions, storage: Ae.storage }), sessionStore: null };
  t.sessionStore = new Ns(t.core, t.core.logger), await t.sessionStore.init();
  const Ie = t.sessionStore.get(Ae.topic), Be = Ie == null ? void 0 : Ie.peer.metadata;
  return t.core = null, t.sessionStore = null, Be;
} }, T = class extends x {
  constructor(Ae) {
    super(Ae), this.events = new l.exports(), this.on = (t, Ie) => this.engine.on(t, Ie), this.once = (t, Ie) => this.engine.once(t, Ie), this.off = (t, Ie) => this.engine.off(t, Ie), this.removeListener = (t, Ie) => this.engine.removeListener(t, Ie), this.pair = async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.approveSession = async (t) => {
      try {
        return await this.engine.approveSession(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.rejectSession = async (t) => {
      try {
        return await this.engine.rejectSession(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.updateSession = async (t) => {
      try {
        return await this.engine.updateSession(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.extendSession = async (t) => {
      try {
        return await this.engine.extendSession(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.respondSessionRequest = async (t) => {
      try {
        return await this.engine.respondSessionRequest(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.disconnectSession = async (t) => {
      try {
        return await this.engine.disconnectSession(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.emitSessionEvent = async (t) => {
      try {
        return await this.engine.emitSessionEvent(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.getActiveSessions = () => {
      try {
        return this.engine.getActiveSessions();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionProposals = () => {
      try {
        return this.engine.getPendingSessionProposals();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.respondAuthRequest = async (t, Ie) => {
      try {
        return await this.engine.respondAuthRequest(t, Ie);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.getPendingAuthRequests = () => {
      try {
        return this.engine.getPendingAuthRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.formatMessage = (t, Ie) => {
      try {
        return this.engine.formatMessage(t, Ie);
      } catch (Be) {
        throw this.logger.error(Be.message), Be;
      }
    }, this.registerDeviceToken = (t) => {
      try {
        return this.engine.registerDeviceToken(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.approveSessionAuthenticate = (t) => {
      try {
        return this.engine.approveSessionAuthenticate(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.rejectSessionAuthenticate = (t) => {
      try {
        return this.engine.rejectSessionAuthenticate(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.formatAuthMessage = (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (Ie) {
        throw this.logger.error(Ie.message), Ie;
      }
    }, this.metadata = Ae.metadata, this.name = Ae.name || p, this.signConfig = Ae.signConfig, this.core = Ae.core, this.logger = this.core.logger, this.engine = new se(this);
  }
  static async init(Ae) {
    const t = new T(Ae);
    return await t.initialize(), t;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.engine.init(), this.logger.info("Web3Wallet Initialization Success");
    } catch (Ae) {
      throw this.logger.info("Web3Wallet Initialization Failure"), this.logger.error(Ae.message), Ae;
    }
  }
};
let v = T;
v.notifications = ne;
const ie = v;
export {
  Buffer$3 as B,
  CHAIN_NAMESPACES as C,
  EthereumSigningProvider as E,
  U$2 as U,
  Wr$1 as W,
  isAddressEqual as a,
  bn as b,
  isAddress as c,
  createPublicClient as d,
  http as e,
  formatEther as f,
  global as g,
  hexToBigInt as h,
  ie as i,
  createWalletClient as j,
  custom as k,
  defineChain as l,
  makeEthereumSigner as m,
  parseEther as p
};
